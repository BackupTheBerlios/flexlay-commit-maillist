<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Flexlay-commit] r631 - in trunk: . clanlib clanlib/API clanlib/API/Application clanlib/API/Core clanlib/API/Core/IOData clanlib/API/Core/Math clanlib/API/Core/Resources clanlib/API/Core/System clanlib/API/Core/XML clanlib/API/Display clanlib/API/Display/Collision clanlib/API/Display/Providers clanlib/API/GL clanlib/API/GUI clanlib/API/GUIStyleSilver clanlib/API/MikMod clanlib/API/Network clanlib/API/Network/IRC clanlib/API/Network/NetObjects clanlib/API/Network/NetSession clanlib/API/Network/NetVariables clanlib/API/Network/Socket clanlib/API/SDL clanlib/API/Signals clanlib/API/Sound clanlib/API/Sound/SoundFilters clanlib/API/Sound/SoundProviders clanlib/API/Vorbis clanlib/Application clanlib/Application/MacOS clanlib/Application/Unix clanlib/Application/Win32 clanlib/Core clanlib/Core/IOData clanlib/Core/IOData/Generic clanlib/Core/IOData/Unix clanlib/Core/IOData/Win32 clanlib/Core/Math clanlib/Core/Resources clanlib/Core/System clanlib/Core/System/Generic clanlib/Core/System/Unix! clanlib/Core/System/Win32 clanlib/Core/XML clanlib/Display clanlib/Display/Collision clanlib/Display/Providers clanlib/Display/Win32 clanlib/GL clanlib/GL/AGL clanlib/GL/GLX clanlib/GL/WGL clanlib/GUI clanlib/GUIStyleSilver clanlib/Signals clanlib/doc lib supertux windstille
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/flexlay-commit/2006-July/index.html" >
   <LINK REL="made" HREF="mailto:flexlay-commit%40lists.berlios.de?Subject=Re%3A%20%5BFlexlay-commit%5D%20r631%20-%20in%20trunk%3A%20.%20clanlib%20clanlib/API%20clanlib/API/Application%20clanlib/API/Core%20clanlib/API/Core/IOData%20clanlib/API/Core/Math%20clanlib/API/Core/Resources%20clanlib/API/Core/System%20clanlib/API/Core/XML%20clanlib/API/Display%20clanlib/API/Display/Collision%20clanlib/API/Display/Providers%20clanlib/API/GL%20clanlib/API/GUI%20clanlib/API/GUIStyleSilver%20clanlib/API/MikMod%20clanlib/API/Network%20clanlib/API/Network/IRC%20clanlib/API/Network/NetObjects%20clanlib/API/Network/NetSession%20clanlib/API/Network/NetVariables%20clanlib/API/Network/Socket%20clanlib/API/SDL%20clanlib/API/Signals%20clanlib/API/Sound%20clanlib/API/Sound/SoundFilters%20clanlib/API/Sound/SoundProviders%20clanlib/API/Vorbis%20clanlib/Application%20clanlib/Application/MacOS%20clanlib/Application/Unix%20clanlib/Application/Win32%20clanlib/Core%20clanlib/Core/IOData%20clanlib/Core/IOData/Generic%20clanlib/Core/IOData/Unix%20clanlib/Core/IOData/Win32%20clanlib/Core/Math%20clanlib/Core/Resources%20clanlib/Core/System%20clanlib/Core/System/Generic%20clanlib/Core/System/Unix%21%0A%20clanlib/Core/System/Win32%20clanlib/Core/XML%20clanlib/Display%20clanlib/Display/Collision%20clanlib/Display/Providers%20clanlib/Display/Win32%20clanlib/GL%20clanlib/GL/AGL%20clanlib/GL/GLX%20clanlib/GL/WGL%20clanlib/GUI%20clanlib/GUIStyleSilver%20clanlib/Signals%20clanlib/doc%20lib%20supertux%20windstille&In-Reply-To=%3C200607050426.k654Q8qn021044%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000127.html">
   <LINK REL="Next"  HREF="000128.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Flexlay-commit] r631 - in trunk: . clanlib clanlib/API clanlib/API/Application clanlib/API/Core clanlib/API/Core/IOData clanlib/API/Core/Math clanlib/API/Core/Resources clanlib/API/Core/System clanlib/API/Core/XML clanlib/API/Display clanlib/API/Display/Collision clanlib/API/Display/Providers clanlib/API/GL clanlib/API/GUI clanlib/API/GUIStyleSilver clanlib/API/MikMod clanlib/API/Network clanlib/API/Network/IRC clanlib/API/Network/NetObjects clanlib/API/Network/NetSession clanlib/API/Network/NetVariables clanlib/API/Network/Socket clanlib/API/SDL clanlib/API/Signals clanlib/API/Sound clanlib/API/Sound/SoundFilters clanlib/API/Sound/SoundProviders clanlib/API/Vorbis clanlib/Application clanlib/Application/MacOS clanlib/Application/Unix clanlib/Application/Win32 clanlib/Core clanlib/Core/IOData clanlib/Core/IOData/Generic clanlib/Core/IOData/Unix clanlib/Core/IOData/Win32 clanlib/Core/Math clanlib/Core/Resources clanlib/Core/System clanlib/Core/System/Generic clanlib/Core/System/Unix! clanlib/Core/System/Win32 clanlib/Core/XML clanlib/Display clanlib/Display/Collision clanlib/Display/Providers clanlib/Display/Win32 clanlib/GL clanlib/GL/AGL clanlib/GL/GLX clanlib/GL/WGL clanlib/GUI clanlib/GUIStyleSilver clanlib/Signals clanlib/doc lib supertux windstille</H1>
    <B>grumbel at BerliOS</B> 
    <A HREF="mailto:flexlay-commit%40lists.berlios.de?Subject=Re%3A%20%5BFlexlay-commit%5D%20r631%20-%20in%20trunk%3A%20.%20clanlib%20clanlib/API%20clanlib/API/Application%20clanlib/API/Core%20clanlib/API/Core/IOData%20clanlib/API/Core/Math%20clanlib/API/Core/Resources%20clanlib/API/Core/System%20clanlib/API/Core/XML%20clanlib/API/Display%20clanlib/API/Display/Collision%20clanlib/API/Display/Providers%20clanlib/API/GL%20clanlib/API/GUI%20clanlib/API/GUIStyleSilver%20clanlib/API/MikMod%20clanlib/API/Network%20clanlib/API/Network/IRC%20clanlib/API/Network/NetObjects%20clanlib/API/Network/NetSession%20clanlib/API/Network/NetVariables%20clanlib/API/Network/Socket%20clanlib/API/SDL%20clanlib/API/Signals%20clanlib/API/Sound%20clanlib/API/Sound/SoundFilters%20clanlib/API/Sound/SoundProviders%20clanlib/API/Vorbis%20clanlib/Application%20clanlib/Application/MacOS%20clanlib/Application/Unix%20clanlib/Application/Win32%20clanlib/Core%20clanlib/Core/IOData%20clanlib/Core/IOData/Generic%20clanlib/Core/IOData/Unix%20clanlib/Core/IOData/Win32%20clanlib/Core/Math%20clanlib/Core/Resources%20clanlib/Core/System%20clanlib/Core/System/Generic%20clanlib/Core/System/Unix%21%0A%20clanlib/Core/System/Win32%20clanlib/Core/XML%20clanlib/Display%20clanlib/Display/Collision%20clanlib/Display/Providers%20clanlib/Display/Win32%20clanlib/GL%20clanlib/GL/AGL%20clanlib/GL/GLX%20clanlib/GL/WGL%20clanlib/GUI%20clanlib/GUIStyleSilver%20clanlib/Signals%20clanlib/doc%20lib%20supertux%20windstille&In-Reply-To=%3C200607050426.k654Q8qn021044%40sheep.berlios.de%3E"
       TITLE="[Flexlay-commit] r631 - in trunk: . clanlib clanlib/API clanlib/API/Application clanlib/API/Core clanlib/API/Core/IOData clanlib/API/Core/Math clanlib/API/Core/Resources clanlib/API/Core/System clanlib/API/Core/XML clanlib/API/Display clanlib/API/Display/Collision clanlib/API/Display/Providers clanlib/API/GL clanlib/API/GUI clanlib/API/GUIStyleSilver clanlib/API/MikMod clanlib/API/Network clanlib/API/Network/IRC clanlib/API/Network/NetObjects clanlib/API/Network/NetSession clanlib/API/Network/NetVariables clanlib/API/Network/Socket clanlib/API/SDL clanlib/API/Signals clanlib/API/Sound clanlib/API/Sound/SoundFilters clanlib/API/Sound/SoundProviders clanlib/API/Vorbis clanlib/Application clanlib/Application/MacOS clanlib/Application/Unix clanlib/Application/Win32 clanlib/Core clanlib/Core/IOData clanlib/Core/IOData/Generic clanlib/Core/IOData/Unix clanlib/Core/IOData/Win32 clanlib/Core/Math clanlib/Core/Resources clanlib/Core/System clanlib/Core/System/Generic clanlib/Core/System/Unix! clanlib/Core/System/Win32 clanlib/Core/XML clanlib/Display clanlib/Display/Collision clanlib/Display/Providers clanlib/Display/Win32 clanlib/GL clanlib/GL/AGL clanlib/GL/GLX clanlib/GL/WGL clanlib/GUI clanlib/GUIStyleSilver clanlib/Signals clanlib/doc lib supertux windstille">grumbel at berlios.de
       </A><BR>
    <I>Wed Jul  5 06:26:08 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000127.html">[Flexlay-commit] r630 - trunk/supertux
</A></li>
        <LI>Next message: <A HREF="000128.html">[Flexlay-commit] r632 - trunk/ruby
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#131">[ date ]</a>
              <a href="thread.html#131">[ thread ]</a>
              <a href="subject.html#131">[ subject ]</a>
              <a href="author.html#131">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: grumbel
Date: 2006-07-05 06:25:17 +0200 (Wed, 05 Jul 2006)
New Revision: 631

Added:
   trunk/clanlib/
   trunk/clanlib/API/
   trunk/clanlib/API/Application/
   trunk/clanlib/API/Application/clanapp.h
   trunk/clanlib/API/Core/
   trunk/clanlib/API/Core/IOData/
   trunk/clanlib/API/Core/IOData/cl_endian.h
   trunk/clanlib/API/Core/IOData/datatypes.h
   trunk/clanlib/API/Core/IOData/directory.h
   trunk/clanlib/API/Core/IOData/directory_scanner.h
   trunk/clanlib/API/Core/IOData/inputsource.h
   trunk/clanlib/API/Core/IOData/inputsource_file.h
   trunk/clanlib/API/Core/IOData/inputsource_memory.h
   trunk/clanlib/API/Core/IOData/inputsource_provider.h
   trunk/clanlib/API/Core/IOData/inputsource_provider_file.h
   trunk/clanlib/API/Core/IOData/inputsource_zipped.h
   trunk/clanlib/API/Core/IOData/outputsource.h
   trunk/clanlib/API/Core/IOData/outputsource_file.h
   trunk/clanlib/API/Core/IOData/outputsource_memory.h
   trunk/clanlib/API/Core/IOData/outputsource_provider.h
   trunk/clanlib/API/Core/IOData/outputsource_zipped.h
   trunk/clanlib/API/Core/IOData/zip_archive.h
   trunk/clanlib/API/Core/IOData/zip_file_entry.h
   trunk/clanlib/API/Core/Math/
   trunk/clanlib/API/Core/Math/circle.h
   trunk/clanlib/API/Core/Math/cl_vector.h
   trunk/clanlib/API/Core/Math/delauney_triangulator.h
   trunk/clanlib/API/Core/Math/line_math.h
   trunk/clanlib/API/Core/Math/math.h
   trunk/clanlib/API/Core/Math/matrix4x4.h
   trunk/clanlib/API/Core/Math/number_pool.h
   trunk/clanlib/API/Core/Math/origin.h
   trunk/clanlib/API/Core/Math/outline_triangulator.h
   trunk/clanlib/API/Core/Math/point.h
   trunk/clanlib/API/Core/Math/pointset_math.h
   trunk/clanlib/API/Core/Math/quad.h
   trunk/clanlib/API/Core/Math/rect.h
   trunk/clanlib/API/Core/Math/size.h
   trunk/clanlib/API/Core/Math/triangle_math.h
   trunk/clanlib/API/Core/Math/vector2.h
   trunk/clanlib/API/Core/Math/vector2.inl
   trunk/clanlib/API/Core/Resources/
   trunk/clanlib/API/Core/Resources/resource.h
   trunk/clanlib/API/Core/Resources/resource_manager.h
   trunk/clanlib/API/Core/Resources/resourcedata.h
   trunk/clanlib/API/Core/Resources/resourcetype_boolean.h
   trunk/clanlib/API/Core/Resources/resourcetype_float.h
   trunk/clanlib/API/Core/Resources/resourcetype_integer.h
   trunk/clanlib/API/Core/Resources/resourcetype_raw.h
   trunk/clanlib/API/Core/Resources/resourcetype_string.h
   trunk/clanlib/API/Core/System/
   trunk/clanlib/API/Core/System/call_stack.h
   trunk/clanlib/API/Core/System/cl_assert.h
   trunk/clanlib/API/Core/System/cl_library.h
   trunk/clanlib/API/Core/System/clanstring.h
   trunk/clanlib/API/Core/System/clonable.h
   trunk/clanlib/API/Core/System/command_line.h
   trunk/clanlib/API/Core/System/console_window.h
   trunk/clanlib/API/Core/System/crash_reporter.h
   trunk/clanlib/API/Core/System/error.h
   trunk/clanlib/API/Core/System/event_listener.h
   trunk/clanlib/API/Core/System/event_trigger.h
   trunk/clanlib/API/Core/System/keep_alive.h
   trunk/clanlib/API/Core/System/lazycopyptr.h
   trunk/clanlib/API/Core/System/log.h
   trunk/clanlib/API/Core/System/mutex.h
   trunk/clanlib/API/Core/System/mutexsharedptr.h
   trunk/clanlib/API/Core/System/mutexweakptr.h
   trunk/clanlib/API/Core/System/owningptr.h
   trunk/clanlib/API/Core/System/setupcore.h
   trunk/clanlib/API/Core/System/sharedptr.h
   trunk/clanlib/API/Core/System/system.h
   trunk/clanlib/API/Core/System/thread.h
   trunk/clanlib/API/Core/System/threadfunc_v0.h
   trunk/clanlib/API/Core/System/threadfunc_v1.h
   trunk/clanlib/API/Core/System/threadfunc_v2.h
   trunk/clanlib/API/Core/System/timer.h
   trunk/clanlib/API/Core/System/weakptr.h
   trunk/clanlib/API/Core/XML/
   trunk/clanlib/API/Core/XML/dom_attr.h
   trunk/clanlib/API/Core/XML/dom_cdata_section.h
   trunk/clanlib/API/Core/XML/dom_character_data.h
   trunk/clanlib/API/Core/XML/dom_comment.h
   trunk/clanlib/API/Core/XML/dom_document.h
   trunk/clanlib/API/Core/XML/dom_document_fragment.h
   trunk/clanlib/API/Core/XML/dom_document_type.h
   trunk/clanlib/API/Core/XML/dom_element.h
   trunk/clanlib/API/Core/XML/dom_entity.h
   trunk/clanlib/API/Core/XML/dom_entity_reference.h
   trunk/clanlib/API/Core/XML/dom_exception.h
   trunk/clanlib/API/Core/XML/dom_implementation.h
   trunk/clanlib/API/Core/XML/dom_named_node_map.h
   trunk/clanlib/API/Core/XML/dom_node.h
   trunk/clanlib/API/Core/XML/dom_node_list.h
   trunk/clanlib/API/Core/XML/dom_notation.h
   trunk/clanlib/API/Core/XML/dom_processing_instruction.h
   trunk/clanlib/API/Core/XML/dom_text.h
   trunk/clanlib/API/Core/XML/xml_token.h
   trunk/clanlib/API/Core/XML/xml_token_load.h
   trunk/clanlib/API/Core/XML/xml_token_save.h
   trunk/clanlib/API/Core/XML/xml_token_string.h
   trunk/clanlib/API/Core/XML/xml_tokenizer.h
   trunk/clanlib/API/Core/XML/xml_writer.h
   trunk/clanlib/API/Core/core_iostream.h
   trunk/clanlib/API/Display/
   trunk/clanlib/API/Display/Collision/
   trunk/clanlib/API/Display/Collision/collision_outline.h
   trunk/clanlib/API/Display/Collision/contour.h
   trunk/clanlib/API/Display/Collision/outline_accuracy.h
   trunk/clanlib/API/Display/Collision/outline_circle.h
   trunk/clanlib/API/Display/Collision/outline_math.h
   trunk/clanlib/API/Display/Collision/outline_provider.h
   trunk/clanlib/API/Display/Collision/outline_provider_bitmap.h
   trunk/clanlib/API/Display/Collision/outline_provider_file.h
   trunk/clanlib/API/Display/Providers/
   trunk/clanlib/API/Display/Providers/dc_buffer.h
   trunk/clanlib/API/Display/Providers/jpeg_provider.h
   trunk/clanlib/API/Display/Providers/pcx_provider.h
   trunk/clanlib/API/Display/Providers/png_provider.h
   trunk/clanlib/API/Display/Providers/provider_factory.h
   trunk/clanlib/API/Display/Providers/provider_type.h
   trunk/clanlib/API/Display/Providers/provider_type_register.h
   trunk/clanlib/API/Display/Providers/targa_provider.h
   trunk/clanlib/API/Display/blend_func.h
   trunk/clanlib/API/Display/canvas.h
   trunk/clanlib/API/Display/color.h
   trunk/clanlib/API/Display/display.h
   trunk/clanlib/API/Display/display_iostream.h
   trunk/clanlib/API/Display/display_mode.h
   trunk/clanlib/API/Display/display_window.h
   trunk/clanlib/API/Display/display_window_description.h
   trunk/clanlib/API/Display/font.h
   trunk/clanlib/API/Display/frameratecounter.h
   trunk/clanlib/API/Display/glyph_buffer.h
   trunk/clanlib/API/Display/gradient.h
   trunk/clanlib/API/Display/graphic_context.h
   trunk/clanlib/API/Display/input_buffer.h
   trunk/clanlib/API/Display/input_button.h
   trunk/clanlib/API/Display/input_context.h
   trunk/clanlib/API/Display/input_device.h
   trunk/clanlib/API/Display/input_event.h
   trunk/clanlib/API/Display/joystick.h
   trunk/clanlib/API/Display/key_binding.h
   trunk/clanlib/API/Display/keyboard.h
   trunk/clanlib/API/Display/keys.h
   trunk/clanlib/API/Display/mouse.h
   trunk/clanlib/API/Display/palette.h
   trunk/clanlib/API/Display/pixel_buffer.h
   trunk/clanlib/API/Display/pixel_format.h
   trunk/clanlib/API/Display/pixel_format_type.h
   trunk/clanlib/API/Display/rle_surface.h
   trunk/clanlib/API/Display/setupdisplay.h
   trunk/clanlib/API/Display/sprite.h
   trunk/clanlib/API/Display/sprite_description.h
   trunk/clanlib/API/Display/sprite_packer.h
   trunk/clanlib/API/Display/stencil_func.h
   trunk/clanlib/API/Display/surface.h
   trunk/clanlib/API/Display/text_styler.h
   trunk/clanlib/API/GL/
   trunk/clanlib/API/GL/light_source.h
   trunk/clanlib/API/GL/material.h
   trunk/clanlib/API/GL/opengl.h
   trunk/clanlib/API/GL/opengl_state.h
   trunk/clanlib/API/GL/opengl_state_data.h
   trunk/clanlib/API/GL/opengl_surface.h
   trunk/clanlib/API/GL/opengl_window.h
   trunk/clanlib/API/GL/opengl_window_description.h
   trunk/clanlib/API/GL/opengl_wrap.h
   trunk/clanlib/API/GL/program_attribute.h
   trunk/clanlib/API/GL/program_object.h
   trunk/clanlib/API/GL/program_uniform.h
   trunk/clanlib/API/GL/setupgl.h
   trunk/clanlib/API/GL/shader_object.h
   trunk/clanlib/API/GL/texture.h
   trunk/clanlib/API/GL/texture_unit.h
   trunk/clanlib/API/GL/viewpoint.h
   trunk/clanlib/API/GUI/
   trunk/clanlib/API/GUI/button.h
   trunk/clanlib/API/GUI/checkbox.h
   trunk/clanlib/API/GUI/component.h
   trunk/clanlib/API/GUI/component_manager.h
   trunk/clanlib/API/GUI/component_move_handler.h
   trunk/clanlib/API/GUI/component_resize_handler.h
   trunk/clanlib/API/GUI/component_style.h
   trunk/clanlib/API/GUI/component_type.h
   trunk/clanlib/API/GUI/deck.h
   trunk/clanlib/API/GUI/filedialog.h
   trunk/clanlib/API/GUI/frame.h
   trunk/clanlib/API/GUI/gui_manager.h
   trunk/clanlib/API/GUI/image.h
   trunk/clanlib/API/GUI/inputbox.h
   trunk/clanlib/API/GUI/inputdialog.h
   trunk/clanlib/API/GUI/label.h
   trunk/clanlib/API/GUI/layout.h
   trunk/clanlib/API/GUI/listbox.h
   trunk/clanlib/API/GUI/listitem.h
   trunk/clanlib/API/GUI/menu.h
   trunk/clanlib/API/GUI/menu_item.h
   trunk/clanlib/API/GUI/menu_node.h
   trunk/clanlib/API/GUI/messagebox.h
   trunk/clanlib/API/GUI/progressbar.h
   trunk/clanlib/API/GUI/radiobutton.h
   trunk/clanlib/API/GUI/radiogroup.h
   trunk/clanlib/API/GUI/scrollbar.h
   trunk/clanlib/API/GUI/setupgui.h
   trunk/clanlib/API/GUI/stylemanager.h
   trunk/clanlib/API/GUI/treeitem.h
   trunk/clanlib/API/GUI/treenode.h
   trunk/clanlib/API/GUI/treeview.h
   trunk/clanlib/API/GUI/window.h
   trunk/clanlib/API/GUIStyleSilver/
   trunk/clanlib/API/GUIStyleSilver/button_silver.h
   trunk/clanlib/API/GUIStyleSilver/checkbox_silver.h
   trunk/clanlib/API/GUIStyleSilver/frame_silver.h
   trunk/clanlib/API/GUIStyleSilver/image_silver.h
   trunk/clanlib/API/GUIStyleSilver/inputbox_silver.h
   trunk/clanlib/API/GUIStyleSilver/label_silver.h
   trunk/clanlib/API/GUIStyleSilver/listbox_silver.h
   trunk/clanlib/API/GUIStyleSilver/menu_item_silver.h
   trunk/clanlib/API/GUIStyleSilver/menu_node_silver.h
   trunk/clanlib/API/GUIStyleSilver/menu_silver.h
   trunk/clanlib/API/GUIStyleSilver/progressbar_silver.h
   trunk/clanlib/API/GUIStyleSilver/radiobutton_silver.h
   trunk/clanlib/API/GUIStyleSilver/scrollbar_silver.h
   trunk/clanlib/API/GUIStyleSilver/stylemanager_silver.h
   trunk/clanlib/API/GUIStyleSilver/treeitem_silver.h
   trunk/clanlib/API/GUIStyleSilver/treeview_silver.h
   trunk/clanlib/API/GUIStyleSilver/window_silver.h
   trunk/clanlib/API/Makefile.am
   trunk/clanlib/API/MikMod/
   trunk/clanlib/API/MikMod/setupmikmod.h
   trunk/clanlib/API/MikMod/soundprovider_mikmod.h
   trunk/clanlib/API/Network/
   trunk/clanlib/API/Network/IRC/
   trunk/clanlib/API/Network/IRC/dcc_download.h
   trunk/clanlib/API/Network/IRC/irc_connection.h
   trunk/clanlib/API/Network/IRC/irc_numerics.h
   trunk/clanlib/API/Network/NetObjects/
   trunk/clanlib/API/Network/NetObjects/netobject_client.h
   trunk/clanlib/API/Network/NetObjects/netobject_controller.h
   trunk/clanlib/API/Network/NetObjects/netobject_server.h
   trunk/clanlib/API/Network/NetSession/
   trunk/clanlib/API/Network/NetSession/inputsource_netpacket.h
   trunk/clanlib/API/Network/NetSession/inputsource_netstream.h
   trunk/clanlib/API/Network/NetSession/netcomputer.h
   trunk/clanlib/API/Network/NetSession/netgroup.h
   trunk/clanlib/API/Network/NetSession/netpacket.h
   trunk/clanlib/API/Network/NetSession/netsession.h
   trunk/clanlib/API/Network/NetSession/netstream.h
   trunk/clanlib/API/Network/NetSession/outputsource_netpacket.h
   trunk/clanlib/API/Network/NetSession/outputsource_netstream.h
   trunk/clanlib/API/Network/NetVariables/
   trunk/clanlib/API/Network/NetVariables/netvariables.h
   trunk/clanlib/API/Network/Socket/
   trunk/clanlib/API/Network/Socket/inputsource_socket.h
   trunk/clanlib/API/Network/Socket/ip_address.h
   trunk/clanlib/API/Network/Socket/outputsource_socket.h
   trunk/clanlib/API/Network/Socket/socket.h
   trunk/clanlib/API/Network/setupnetwork.h
   trunk/clanlib/API/SDL/
   trunk/clanlib/API/SDL/setupsdl.h
   trunk/clanlib/API/Signals/
   trunk/clanlib/API/Signals/signal.h
   trunk/clanlib/API/Signals/signal_v0.h
   trunk/clanlib/API/Signals/signal_v1.h
   trunk/clanlib/API/Signals/signal_v2.h
   trunk/clanlib/API/Signals/signal_v3.h
   trunk/clanlib/API/Signals/signal_v4.h
   trunk/clanlib/API/Signals/signal_v5.h
   trunk/clanlib/API/Signals/slot.h
   trunk/clanlib/API/Signals/slot_container.h
   trunk/clanlib/API/Signals/slot_generic.h
   trunk/clanlib/API/Signals/slot_v0.h
   trunk/clanlib/API/Signals/slot_v1.h
   trunk/clanlib/API/Signals/slot_v2.h
   trunk/clanlib/API/Signals/slot_v3.h
   trunk/clanlib/API/Signals/slot_v4.h
   trunk/clanlib/API/Signals/slot_v5.h
   trunk/clanlib/API/Signals/slotbuffer_v0.h
   trunk/clanlib/API/Signals/slotbuffer_v1.h
   trunk/clanlib/API/Sound/
   trunk/clanlib/API/Sound/SoundFilters/
   trunk/clanlib/API/Sound/SoundFilters/echofilter.h
   trunk/clanlib/API/Sound/SoundFilters/fadefilter.h
   trunk/clanlib/API/Sound/SoundFilters/inverse_echofilter.h
   trunk/clanlib/API/Sound/SoundProviders/
   trunk/clanlib/API/Sound/SoundProviders/soundprovider_factory.h
   trunk/clanlib/API/Sound/SoundProviders/soundprovider_raw.h
   trunk/clanlib/API/Sound/SoundProviders/soundprovider_recorder.h
   trunk/clanlib/API/Sound/SoundProviders/soundprovider_type.h
   trunk/clanlib/API/Sound/SoundProviders/soundprovider_type_register.h
   trunk/clanlib/API/Sound/SoundProviders/soundprovider_wave.h
   trunk/clanlib/API/Sound/cd_drive.h
   trunk/clanlib/API/Sound/setupsound.h
   trunk/clanlib/API/Sound/sound.h
   trunk/clanlib/API/Sound/soundbuffer.h
   trunk/clanlib/API/Sound/soundbuffer_session.h
   trunk/clanlib/API/Sound/soundfilter.h
   trunk/clanlib/API/Sound/soundformat.h
   trunk/clanlib/API/Sound/soundoutput.h
   trunk/clanlib/API/Sound/soundoutput_description.h
   trunk/clanlib/API/Sound/soundprovider.h
   trunk/clanlib/API/Sound/soundprovider_session.h
   trunk/clanlib/API/Vorbis/
   trunk/clanlib/API/Vorbis/setupvorbis.h
   trunk/clanlib/API/Vorbis/soundprovider_vorbis.h
   trunk/clanlib/API/application.h
   trunk/clanlib/API/core.h
   trunk/clanlib/API/display.h
   trunk/clanlib/API/efence.h
   trunk/clanlib/API/gl.h
   trunk/clanlib/API/gui.h
   trunk/clanlib/API/guistylesilver.h
   trunk/clanlib/API/mikmod.h
   trunk/clanlib/API/network.h
   trunk/clanlib/API/sdl.h
   trunk/clanlib/API/signals.h
   trunk/clanlib/API/sound.h
   trunk/clanlib/API/vorbis.h
   trunk/clanlib/Application/
   trunk/clanlib/Application/MacOS/
   trunk/clanlib/Application/MacOS/clanapp.cpp
   trunk/clanlib/Application/Makefile.am
   trunk/clanlib/Application/Unix/
   trunk/clanlib/Application/Unix/clanapp.cpp
   trunk/clanlib/Application/Win32/
   trunk/clanlib/Application/Win32/clanapp.cpp
   trunk/clanlib/ClanLib
   trunk/clanlib/Core/
   trunk/clanlib/Core/IOData/
   trunk/clanlib/Core/IOData/Generic/
   trunk/clanlib/Core/IOData/Generic/datafile_inputprovider.cpp
   trunk/clanlib/Core/IOData/Generic/datafile_inputprovider.h
   trunk/clanlib/Core/IOData/Generic/directory.cpp
   trunk/clanlib/Core/IOData/Generic/directory_scanner.cpp
   trunk/clanlib/Core/IOData/Generic/directory_scanner_generic.h
   trunk/clanlib/Core/IOData/Generic/endianess.cpp
   trunk/clanlib/Core/IOData/Generic/inputsource.cpp
   trunk/clanlib/Core/IOData/Generic/inputsource_file.cpp
   trunk/clanlib/Core/IOData/Generic/inputsource_memory_generic.cpp
   trunk/clanlib/Core/IOData/Generic/inputsource_memory_generic.h
   trunk/clanlib/Core/IOData/Generic/inputsource_provider_file.cpp
   trunk/clanlib/Core/IOData/Generic/inputsource_zipped.cpp
   trunk/clanlib/Core/IOData/Generic/outputsource.cpp
   trunk/clanlib/Core/IOData/Generic/outputsource_file.cpp
   trunk/clanlib/Core/IOData/Generic/outputsource_memory_generic.cpp
   trunk/clanlib/Core/IOData/Generic/outputsource_memory_generic.h
   trunk/clanlib/Core/IOData/Generic/outputsource_zipped.cpp
   trunk/clanlib/Core/IOData/Unix/
   trunk/clanlib/Core/IOData/Unix/directory_scanner_unix.cpp
   trunk/clanlib/Core/IOData/Unix/directory_scanner_unix.h
   trunk/clanlib/Core/IOData/Win32/
   trunk/clanlib/Core/IOData/Win32/directory_scanner_win32.cpp
   trunk/clanlib/Core/IOData/Win32/directory_scanner_win32.h
   trunk/clanlib/Core/IOData/inputsource_memory.cpp
   trunk/clanlib/Core/IOData/inputsource_zip_fileentry.cpp
   trunk/clanlib/Core/IOData/inputsource_zip_fileentry.h
   trunk/clanlib/Core/IOData/outputsource_memory.cpp
   trunk/clanlib/Core/IOData/zip_64_end_of_central_directory_locator.cpp
   trunk/clanlib/Core/IOData/zip_64_end_of_central_directory_locator.h
   trunk/clanlib/Core/IOData/zip_64_end_of_central_directory_record.cpp
   trunk/clanlib/Core/IOData/zip_64_end_of_central_directory_record.h
   trunk/clanlib/Core/IOData/zip_archive.cpp
   trunk/clanlib/Core/IOData/zip_archive_generic.h
   trunk/clanlib/Core/IOData/zip_compression_method.h
   trunk/clanlib/Core/IOData/zip_digital_signature.cpp
   trunk/clanlib/Core/IOData/zip_digital_signature.h
   trunk/clanlib/Core/IOData/zip_end_of_central_directory_record.cpp
   trunk/clanlib/Core/IOData/zip_end_of_central_directory_record.h
   trunk/clanlib/Core/IOData/zip_file_entry.cpp
   trunk/clanlib/Core/IOData/zip_file_entry_generic.h
   trunk/clanlib/Core/IOData/zip_file_header.cpp
   trunk/clanlib/Core/IOData/zip_file_header.h
   trunk/clanlib/Core/IOData/zip_flags.h
   trunk/clanlib/Core/IOData/zip_local_file_descriptor.cpp
   trunk/clanlib/Core/IOData/zip_local_file_descriptor.h
   trunk/clanlib/Core/IOData/zip_local_file_header.cpp
   trunk/clanlib/Core/IOData/zip_local_file_header.h
   trunk/clanlib/Core/IOData/zip_version_attributes.h
   trunk/clanlib/Core/Makefile.am
   trunk/clanlib/Core/Math/
   trunk/clanlib/Core/Math/cl_vector.cpp
   trunk/clanlib/Core/Math/delauney_triangulator.cpp
   trunk/clanlib/Core/Math/delauney_triangulator_generic.cpp
   trunk/clanlib/Core/Math/delauney_triangulator_generic.h
   trunk/clanlib/Core/Math/line_math.cpp
   trunk/clanlib/Core/Math/matrix4x4.cpp
   trunk/clanlib/Core/Math/number_pool.cpp
   trunk/clanlib/Core/Math/origin.cpp
   trunk/clanlib/Core/Math/outline_triangulator.cpp
   trunk/clanlib/Core/Math/outline_triangulator_generic.cpp
   trunk/clanlib/Core/Math/outline_triangulator_generic.h
   trunk/clanlib/Core/Math/pointset_math.cpp
   trunk/clanlib/Core/Math/quad.cpp
   trunk/clanlib/Core/Math/rect.cpp
   trunk/clanlib/Core/Math/triangle_math.cpp
   trunk/clanlib/Core/Math/vector2.cpp
   trunk/clanlib/Core/Resources/
   trunk/clanlib/Core/Resources/resource.cpp
   trunk/clanlib/Core/Resources/resource_generic.cpp
   trunk/clanlib/Core/Resources/resource_generic.h
   trunk/clanlib/Core/Resources/resource_manager.cpp
   trunk/clanlib/Core/Resources/resource_manager_generic.cpp
   trunk/clanlib/Core/Resources/resource_manager_generic.h
   trunk/clanlib/Core/Resources/resourcedata.cpp
   trunk/clanlib/Core/Resources/resourcetype_boolean.cpp
   trunk/clanlib/Core/Resources/resourcetype_float.cpp
   trunk/clanlib/Core/Resources/resourcetype_integer.cpp
   trunk/clanlib/Core/Resources/resourcetype_raw.cpp
   trunk/clanlib/Core/Resources/resourcetype_string.cpp
   trunk/clanlib/Core/System/
   trunk/clanlib/Core/System/Generic/
   trunk/clanlib/Core/System/Generic/call_stack.cpp
   trunk/clanlib/Core/System/Generic/call_stack_generic.h
   trunk/clanlib/Core/System/Generic/cl_assert.cpp
   trunk/clanlib/Core/System/Generic/clanstring.cpp
   trunk/clanlib/Core/System/Generic/command_line.cpp
   trunk/clanlib/Core/System/Generic/command_line_generic.cpp
   trunk/clanlib/Core/System/Generic/command_line_generic.h
   trunk/clanlib/Core/System/Generic/console_window.cpp
   trunk/clanlib/Core/System/Generic/console_window_generic.cpp
   trunk/clanlib/Core/System/Generic/console_window_generic.h
   trunk/clanlib/Core/System/Generic/crash_reporter.cpp
   trunk/clanlib/Core/System/Generic/crash_reporter_generic.h
   trunk/clanlib/Core/System/Generic/detect_3dnow.cpp
   trunk/clanlib/Core/System/Generic/detect_mmx.cpp
   trunk/clanlib/Core/System/Generic/error.cpp
   trunk/clanlib/Core/System/Generic/event_listener.cpp
   trunk/clanlib/Core/System/Generic/event_listener_generic.cpp
   trunk/clanlib/Core/System/Generic/event_listener_generic.h
   trunk/clanlib/Core/System/Generic/event_trigger.cpp
   trunk/clanlib/Core/System/Generic/event_trigger_generic.cpp
   trunk/clanlib/Core/System/Generic/event_trigger_generic.h
   trunk/clanlib/Core/System/Generic/keep_alive_generic.cpp
   trunk/clanlib/Core/System/Generic/log.cpp
   trunk/clanlib/Core/System/Generic/setupcore.cpp
   trunk/clanlib/Core/System/Generic/timer_generic.cpp
   trunk/clanlib/Core/System/Unix/
   trunk/clanlib/Core/System/Unix/cl_library.cpp
   trunk/clanlib/Core/System/Unix/crash_reporter_unix.cpp
   trunk/clanlib/Core/System/Unix/crash_reporter_unix.h
   trunk/clanlib/Core/System/Unix/event_listener_unix.cpp
   trunk/clanlib/Core/System/Unix/event_listener_unix.h
   trunk/clanlib/Core/System/Unix/event_trigger_unix.cpp
   trunk/clanlib/Core/System/Unix/event_trigger_unix.h
   trunk/clanlib/Core/System/Unix/implementation.h
   trunk/clanlib/Core/System/Unix/init_linux.cpp
   trunk/clanlib/Core/System/Unix/init_linux.h
   trunk/clanlib/Core/System/Unix/mutex_pthread.cpp
   trunk/clanlib/Core/System/Unix/mutex_pthread.h
   trunk/clanlib/Core/System/Unix/thread_pthread.cpp
   trunk/clanlib/Core/System/Unix/thread_pthread.h
   trunk/clanlib/Core/System/Win32/
   trunk/clanlib/Core/System/Win32/cl_library.cpp
   trunk/clanlib/Core/System/Win32/crash_reporter_win32.cpp
   trunk/clanlib/Core/System/Win32/crash_reporter_win32.h
   trunk/clanlib/Core/System/Win32/event_listener_win32.cpp
   trunk/clanlib/Core/System/Win32/event_listener_win32.h
   trunk/clanlib/Core/System/Win32/event_trigger_win32.cpp
   trunk/clanlib/Core/System/Win32/event_trigger_win32.h
   trunk/clanlib/Core/System/Win32/init_win32.cpp
   trunk/clanlib/Core/System/Win32/init_win32.h
   trunk/clanlib/Core/System/Win32/mutex_win32.cpp
   trunk/clanlib/Core/System/Win32/mutex_win32.h
   trunk/clanlib/Core/System/Win32/thread_win32.cpp
   trunk/clanlib/Core/System/Win32/thread_win32.h
   trunk/clanlib/Core/XML/
   trunk/clanlib/Core/XML/dom_attr.cpp
   trunk/clanlib/Core/XML/dom_cdata_section.cpp
   trunk/clanlib/Core/XML/dom_character_data.cpp
   trunk/clanlib/Core/XML/dom_comment.cpp
   trunk/clanlib/Core/XML/dom_document.cpp
   trunk/clanlib/Core/XML/dom_document_fragment.cpp
   trunk/clanlib/Core/XML/dom_document_generic.cpp
   trunk/clanlib/Core/XML/dom_document_generic.h
   trunk/clanlib/Core/XML/dom_document_type.cpp
   trunk/clanlib/Core/XML/dom_element.cpp
   trunk/clanlib/Core/XML/dom_entity.cpp
   trunk/clanlib/Core/XML/dom_entity_reference.cpp
   trunk/clanlib/Core/XML/dom_exception.cpp
   trunk/clanlib/Core/XML/dom_implementation.cpp
   trunk/clanlib/Core/XML/dom_named_node_map.cpp
   trunk/clanlib/Core/XML/dom_named_node_map_generic.h
   trunk/clanlib/Core/XML/dom_node.cpp
   trunk/clanlib/Core/XML/dom_node_generic.h
   trunk/clanlib/Core/XML/dom_node_list.cpp
   trunk/clanlib/Core/XML/dom_notation.cpp
   trunk/clanlib/Core/XML/dom_processing_instruction.cpp
   trunk/clanlib/Core/XML/dom_text.cpp
   trunk/clanlib/Core/XML/xml_token_load.cpp
   trunk/clanlib/Core/XML/xml_token_load_generic.h
   trunk/clanlib/Core/XML/xml_token_save.cpp
   trunk/clanlib/Core/XML/xml_token_save_generic.h
   trunk/clanlib/Core/XML/xml_tokenizer.cpp
   trunk/clanlib/Core/XML/xml_tokenizer_generic.h
   trunk/clanlib/Core/XML/xml_writer.cpp
   trunk/clanlib/Core/XML/xml_writer_generic.h
   trunk/clanlib/Core/core_iostream.cpp
   trunk/clanlib/Core/precomp.cpp
   trunk/clanlib/Core/precomp.h
   trunk/clanlib/Display/
   trunk/clanlib/Display/Collision/
   trunk/clanlib/Display/Collision/collision_outline.cpp
   trunk/clanlib/Display/Collision/collision_outline_generic.cpp
   trunk/clanlib/Display/Collision/collision_outline_generic.h
   trunk/clanlib/Display/Collision/outline_math.cpp
   trunk/clanlib/Display/Collision/outline_provider_bitmap.cpp
   trunk/clanlib/Display/Collision/outline_provider_bitmap_generic.cpp
   trunk/clanlib/Display/Collision/outline_provider_bitmap_generic.h
   trunk/clanlib/Display/Collision/outline_provider_file.cpp
   trunk/clanlib/Display/Collision/outline_provider_file_generic.cpp
   trunk/clanlib/Display/Collision/outline_provider_file_generic.h
   trunk/clanlib/Display/Makefile.am
   trunk/clanlib/Display/Providers/
   trunk/clanlib/Display/Providers/jpeg_provider.cpp
   trunk/clanlib/Display/Providers/jpeg_provider_generic.cpp
   trunk/clanlib/Display/Providers/jpeg_provider_generic.h
   trunk/clanlib/Display/Providers/pcx_provider.cpp
   trunk/clanlib/Display/Providers/pcx_provider_generic.cpp
   trunk/clanlib/Display/Providers/pcx_provider_generic.h
   trunk/clanlib/Display/Providers/png_provider.cpp
   trunk/clanlib/Display/Providers/png_provider_generic.cpp
   trunk/clanlib/Display/Providers/png_provider_generic.h
   trunk/clanlib/Display/Providers/provider_factory.cpp
   trunk/clanlib/Display/Providers/provider_type.cpp
   trunk/clanlib/Display/Providers/targa_provider.cpp
   trunk/clanlib/Display/Providers/targa_provider_generic.cpp
   trunk/clanlib/Display/Providers/targa_provider_generic.h
   trunk/clanlib/Display/Win32/
   trunk/clanlib/Display/Win32/dc_buffer.cpp
   trunk/clanlib/Display/Win32/dc_buffer_generic.cpp
   trunk/clanlib/Display/Win32/dc_buffer_generic.h
   trunk/clanlib/Display/Win32/display_window_win32.cpp
   trunk/clanlib/Display/Win32/display_window_win32.h
   trunk/clanlib/Display/Win32/input_device_directinput.cpp
   trunk/clanlib/Display/Win32/input_device_directinput.h
   trunk/clanlib/Display/Win32/input_device_win32keyboard.cpp
   trunk/clanlib/Display/Win32/input_device_win32keyboard.h
   trunk/clanlib/Display/Win32/input_device_win32mouse.cpp
   trunk/clanlib/Display/Win32/input_device_win32mouse.h
   trunk/clanlib/Display/canvas.cpp
   trunk/clanlib/Display/canvas_generic.h
   trunk/clanlib/Display/color.cpp
   trunk/clanlib/Display/display.cpp
   trunk/clanlib/Display/display_iostream.cpp
   trunk/clanlib/Display/display_mode.cpp
   trunk/clanlib/Display/display_mode_generic.h
   trunk/clanlib/Display/display_precomp.cpp
   trunk/clanlib/Display/display_precomp.h
   trunk/clanlib/Display/display_target.cpp
   trunk/clanlib/Display/display_target.h
   trunk/clanlib/Display/display_window.cpp
   trunk/clanlib/Display/display_window_description.cpp
   trunk/clanlib/Display/display_window_description_generic.h
   trunk/clanlib/Display/display_window_generic.cpp
   trunk/clanlib/Display/display_window_generic.h
   trunk/clanlib/Display/font.cpp
   trunk/clanlib/Display/font_generic.cpp
   trunk/clanlib/Display/font_generic.h
   trunk/clanlib/Display/font_target.h
   trunk/clanlib/Display/font_target_sprite.cpp
   trunk/clanlib/Display/font_target_sprite.h
   trunk/clanlib/Display/frameratecounter.cpp
   trunk/clanlib/Display/frameratecounter_generic.h
   trunk/clanlib/Display/glyph_buffer.cpp
   trunk/clanlib/Display/graphic_context.cpp
   trunk/clanlib/Display/graphic_context_generic.cpp
   trunk/clanlib/Display/graphic_context_generic.h
   trunk/clanlib/Display/input_buffer.cpp
   trunk/clanlib/Display/input_buffer_generic.h
   trunk/clanlib/Display/input_button.cpp
   trunk/clanlib/Display/input_button_generic.cpp
   trunk/clanlib/Display/input_button_generic.h
   trunk/clanlib/Display/input_context.cpp
   trunk/clanlib/Display/input_context_generic.cpp
   trunk/clanlib/Display/input_context_generic.h
   trunk/clanlib/Display/input_device.cpp
   trunk/clanlib/Display/input_device_generic.cpp
   trunk/clanlib/Display/input_device_generic.h
   trunk/clanlib/Display/input_event.cpp
   trunk/clanlib/Display/joystick.cpp
   trunk/clanlib/Display/key_binding.cpp
   trunk/clanlib/Display/key_binding_generic.h
   trunk/clanlib/Display/keyboard.cpp
   trunk/clanlib/Display/mouse.cpp
   trunk/clanlib/Display/pixel_buffer.cpp
   trunk/clanlib/Display/pixel_buffer_generic.cpp
   trunk/clanlib/Display/pixel_buffer_generic.h
   trunk/clanlib/Display/pixel_buffer_memory.cpp
   trunk/clanlib/Display/pixel_buffer_memory.h
   trunk/clanlib/Display/pixel_format.cpp
   trunk/clanlib/Display/resourcedata_collisionoutline.cpp
   trunk/clanlib/Display/resourcedata_collisionoutline.h
   trunk/clanlib/Display/resourcedata_font.cpp
   trunk/clanlib/Display/resourcedata_font.h
   trunk/clanlib/Display/resourcedata_sprite.cpp
   trunk/clanlib/Display/resourcedata_sprite.h
   trunk/clanlib/Display/resourcedata_sprite_description.cpp
   trunk/clanlib/Display/resourcedata_sprite_description.h
   trunk/clanlib/Display/resourcedata_surface.cpp
   trunk/clanlib/Display/resourcedata_surface.h
   trunk/clanlib/Display/resourcedata_text_styler.cpp
   trunk/clanlib/Display/resourcedata_text_styler.h
   trunk/clanlib/Display/setupdisplay.cpp
   trunk/clanlib/Display/sprite.cpp
   trunk/clanlib/Display/sprite_description.cpp
   trunk/clanlib/Display/sprite_description_generic.h
   trunk/clanlib/Display/sprite_generic.cpp
   trunk/clanlib/Display/sprite_generic.h
   trunk/clanlib/Display/sprite_packer.cpp
   trunk/clanlib/Display/sprite_packer_generic.cpp
   trunk/clanlib/Display/sprite_packer_generic.h
   trunk/clanlib/Display/surface.cpp
   trunk/clanlib/Display/surface_generic.cpp
   trunk/clanlib/Display/surface_generic.h
   trunk/clanlib/Display/surface_target.cpp
   trunk/clanlib/Display/surface_target.h
   trunk/clanlib/Display/text_styler.cpp
   trunk/clanlib/Display/triangle_params.h
   trunk/clanlib/GL/
   trunk/clanlib/GL/AGL/
   trunk/clanlib/GL/AGL/display_window_opengl.cpp
   trunk/clanlib/GL/AGL/display_window_opengl.h
   trunk/clanlib/GL/AGL/input_device_mackeyboard.cpp
   trunk/clanlib/GL/AGL/input_device_mackeyboard.h
   trunk/clanlib/GL/AGL/input_device_macmouse.cpp
   trunk/clanlib/GL/AGL/input_device_macmouse.h
   trunk/clanlib/GL/GLX/
   trunk/clanlib/GL/GLX/display_window_opengl.cpp
   trunk/clanlib/GL/GLX/display_window_opengl.h
   trunk/clanlib/GL/GLX/input_device_linuxevent.cpp
   trunk/clanlib/GL/GLX/input_device_linuxevent.h
   trunk/clanlib/GL/GLX/input_device_linuxjoystick.cpp
   trunk/clanlib/GL/GLX/input_device_linuxjoystick.h
   trunk/clanlib/GL/GLX/input_device_linuxusbmouse.cpp
   trunk/clanlib/GL/GLX/input_device_linuxusbmouse.h
   trunk/clanlib/GL/GLX/input_device_x11keyboard.cpp
   trunk/clanlib/GL/GLX/input_device_x11keyboard.h
   trunk/clanlib/GL/GLX/input_device_x11mouse.cpp
   trunk/clanlib/GL/GLX/input_device_x11mouse.h
   trunk/clanlib/GL/GLX/input_device_xinput.cpp
   trunk/clanlib/GL/GLX/input_device_xinput.h
   trunk/clanlib/GL/Makefile.am
   trunk/clanlib/GL/WGL/
   trunk/clanlib/GL/WGL/display_window_opengl.cpp
   trunk/clanlib/GL/WGL/display_window_opengl.h
   trunk/clanlib/GL/canvas_opengl.cpp
   trunk/clanlib/GL/canvas_opengl.h
   trunk/clanlib/GL/fillmode.h
   trunk/clanlib/GL/gl_state.h
   trunk/clanlib/GL/gl_state_checker.cpp
   trunk/clanlib/GL/gl_state_checker.h
   trunk/clanlib/GL/graphic_context_opengl.cpp
   trunk/clanlib/GL/graphic_context_opengl.h
   trunk/clanlib/GL/light_source.cpp
   trunk/clanlib/GL/opengl.cpp
   trunk/clanlib/GL/opengl_state.cpp
   trunk/clanlib/GL/opengl_state_data.cpp
   trunk/clanlib/GL/opengl_state_generic.cpp
   trunk/clanlib/GL/opengl_state_generic.h
   trunk/clanlib/GL/opengl_surface.cpp
   trunk/clanlib/GL/opengl_target.cpp
   trunk/clanlib/GL/opengl_target.h
   trunk/clanlib/GL/opengl_window.cpp
   trunk/clanlib/GL/opengl_window_description.cpp
   trunk/clanlib/GL/opengl_window_description_generic.h
   trunk/clanlib/GL/pixel_buffer_opengl_texture.cpp
   trunk/clanlib/GL/pixel_buffer_opengl_texture.h
   trunk/clanlib/GL/program_attribute.cpp
   trunk/clanlib/GL/program_object.cpp
   trunk/clanlib/GL/program_uniform.cpp
   trunk/clanlib/GL/setupgl.cpp
   trunk/clanlib/GL/shader_object.cpp
   trunk/clanlib/GL/surface_target_opengl.cpp
   trunk/clanlib/GL/surface_target_opengl.h
   trunk/clanlib/GL/texture.cpp
   trunk/clanlib/GL/viewpoint.cpp
   trunk/clanlib/GUI/
   trunk/clanlib/GUI/Makefile.am
   trunk/clanlib/GUI/button.cpp
   trunk/clanlib/GUI/button_generic.cpp
   trunk/clanlib/GUI/button_generic.h
   trunk/clanlib/GUI/checkbox.cpp
   trunk/clanlib/GUI/component.cpp
   trunk/clanlib/GUI/component_generic.cpp
   trunk/clanlib/GUI/component_generic.h
   trunk/clanlib/GUI/component_manager.cpp
   trunk/clanlib/GUI/component_manager_generic.cpp
   trunk/clanlib/GUI/component_manager_generic.h
   trunk/clanlib/GUI/component_move_handler.cpp
   trunk/clanlib/GUI/component_resize_handler.cpp
   trunk/clanlib/GUI/component_type.cpp
   trunk/clanlib/GUI/component_type_generic.h
   trunk/clanlib/GUI/deck.cpp
   trunk/clanlib/GUI/deck_generic.cpp
   trunk/clanlib/GUI/deck_generic.h
   trunk/clanlib/GUI/default_component_types.h
   trunk/clanlib/GUI/filedialog.cpp
   trunk/clanlib/GUI/filedialog_generic.cpp
   trunk/clanlib/GUI/filedialog_generic.h
   trunk/clanlib/GUI/frame.cpp
   trunk/clanlib/GUI/frame_generic.cpp
   trunk/clanlib/GUI/frame_generic.h
   trunk/clanlib/GUI/gui_manager.cpp
   trunk/clanlib/GUI/gui_manager_generic.cpp
   trunk/clanlib/GUI/gui_manager_generic.h
   trunk/clanlib/GUI/image.cpp
   trunk/clanlib/GUI/image_generic.cpp
   trunk/clanlib/GUI/image_generic.h
   trunk/clanlib/GUI/inputbox.cpp
   trunk/clanlib/GUI/inputbox_generic.cpp
   trunk/clanlib/GUI/inputbox_generic.h
   trunk/clanlib/GUI/inputdialog.cpp
   trunk/clanlib/GUI/inputdialog_generic.cpp
   trunk/clanlib/GUI/inputdialog_generic.h
   trunk/clanlib/GUI/label.cpp
   trunk/clanlib/GUI/label_generic.cpp
   trunk/clanlib/GUI/label_generic.h
   trunk/clanlib/GUI/layout.cpp
   trunk/clanlib/GUI/layout_generic.cpp
   trunk/clanlib/GUI/layout_generic.h
   trunk/clanlib/GUI/layout_item.cpp
   trunk/clanlib/GUI/layout_item.h
   trunk/clanlib/GUI/listbox.cpp
   trunk/clanlib/GUI/listbox_generic.cpp
   trunk/clanlib/GUI/listbox_generic.h
   trunk/clanlib/GUI/menu.cpp
   trunk/clanlib/GUI/menu_generic.cpp
   trunk/clanlib/GUI/menu_generic.h
   trunk/clanlib/GUI/menu_item.cpp
   trunk/clanlib/GUI/menu_item_generic.cpp
   trunk/clanlib/GUI/menu_item_generic.h
   trunk/clanlib/GUI/menu_node.cpp
   trunk/clanlib/GUI/menu_node_generic.cpp
   trunk/clanlib/GUI/menu_node_generic.h
   trunk/clanlib/GUI/messagebox.cpp
   trunk/clanlib/GUI/messagebox_generic.cpp
   trunk/clanlib/GUI/messagebox_generic.h
   trunk/clanlib/GUI/precomp.cpp
   trunk/clanlib/GUI/precomp.h
   trunk/clanlib/GUI/progressbar.cpp
   trunk/clanlib/GUI/progressbar_generic.cpp
   trunk/clanlib/GUI/progressbar_generic.h
   trunk/clanlib/GUI/radiobutton.cpp
   trunk/clanlib/GUI/radiogroup.cpp
   trunk/clanlib/GUI/radiogroup_generic.cpp
   trunk/clanlib/GUI/radiogroup_generic.h
   trunk/clanlib/GUI/scrollbar.cpp
   trunk/clanlib/GUI/scrollbar_generic.cpp
   trunk/clanlib/GUI/scrollbar_generic.h
   trunk/clanlib/GUI/setupgui.cpp
   trunk/clanlib/GUI/stylemanager.cpp
   trunk/clanlib/GUI/treeitem.cpp
   trunk/clanlib/GUI/treeitem_generic.cpp
   trunk/clanlib/GUI/treeitem_generic.h
   trunk/clanlib/GUI/treenode.cpp
   trunk/clanlib/GUI/treenode_generic.cpp
   trunk/clanlib/GUI/treenode_generic.h
   trunk/clanlib/GUI/treeview.cpp
   trunk/clanlib/GUI/treeview_generic.cpp
   trunk/clanlib/GUI/treeview_generic.h
   trunk/clanlib/GUI/window.cpp
   trunk/clanlib/GUI/window_generic.cpp
   trunk/clanlib/GUI/window_generic.h
   trunk/clanlib/GUIStyleSilver/
   trunk/clanlib/GUIStyleSilver/Makefile.am
   trunk/clanlib/GUIStyleSilver/button_silver.cpp
   trunk/clanlib/GUIStyleSilver/checkbox_silver.cpp
   trunk/clanlib/GUIStyleSilver/frame_silver.cpp
   trunk/clanlib/GUIStyleSilver/image_silver.cpp
   trunk/clanlib/GUIStyleSilver/inputbox_silver.cpp
   trunk/clanlib/GUIStyleSilver/label_silver.cpp
   trunk/clanlib/GUIStyleSilver/listbox_silver.cpp
   trunk/clanlib/GUIStyleSilver/menu_item_silver.cpp
   trunk/clanlib/GUIStyleSilver/menu_node_silver.cpp
   trunk/clanlib/GUIStyleSilver/menu_silver.cpp
   trunk/clanlib/GUIStyleSilver/progressbar_silver.cpp
   trunk/clanlib/GUIStyleSilver/radiobutton_silver.cpp
   trunk/clanlib/GUIStyleSilver/scrollbar_silver.cpp
   trunk/clanlib/GUIStyleSilver/stylemanager_silver.cpp
   trunk/clanlib/GUIStyleSilver/treeitem_silver.cpp
   trunk/clanlib/GUIStyleSilver/treeview_silver.cpp
   trunk/clanlib/GUIStyleSilver/window_silver.cpp
   trunk/clanlib/Makefile.am
   trunk/clanlib/README
   trunk/clanlib/SConstruct
   trunk/clanlib/Signals/
   trunk/clanlib/Signals/Makefile.am
   trunk/clanlib/Signals/slot.cpp
   trunk/clanlib/Signals/slot_generic.cpp
   trunk/clanlib/doc/
   trunk/clanlib/doc/CODING_STYLE
   trunk/clanlib/doc/COPYING
   trunk/clanlib/doc/CREDITS
   trunk/clanlib/doc/INSTALL.borland
   trunk/clanlib/doc/INSTALL.linux
   trunk/clanlib/doc/INSTALL.macosx
   trunk/clanlib/doc/INSTALL.mingw
   trunk/clanlib/doc/INSTALL.win32
   trunk/clanlib/doc/README
   trunk/clanlib/doc/README.anjuta
   trunk/clanlib/doc/README.distros
   trunk/clanlib/doc/README.kdevelop
   trunk/clanlib/doc/README.sdl
   trunk/clanlib/doc/README.upgrade
   trunk/windstille/main.rb
Modified:
   trunk/SConstruct
   trunk/lib/SConstruct
   trunk/supertux/supertux.rb
Log:
- added a cutdown version of ClanLib-0.8

Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/SConstruct	2006-07-05 04:25:17 UTC (rev 631)
@@ -1,3 +1,4 @@
+SConscript(['clanlib/SConstruct'])
 SConscript(['lib/SConstruct'])
 SConscript(['ruby/SConstruct'])
 SConscript(['supertux/SConstruct'])

Added: trunk/clanlib/API/Application/clanapp.h
===================================================================
--- trunk/clanlib/API/Application/clanapp.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Application/clanapp.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,69 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanApp=&quot;System&quot;
+//! header=application.h
+
+#ifndef header_clanapp
+#define header_clanapp
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+//: The starting place for all applications.
+//- !group=App/System!
+//- !header=application.h!
+//- &lt;p&gt; The application class must be inherited by all ClanLib applications.
+//- In your application create a class inheriting CL_ClanApplication, 
+//- make a global instance of it, and fill in the main() function. &lt;/p&gt;
+class CL_ClanApplication
+{
+public:
+	//: Clan Application constructor
+	CL_ClanApplication();
+
+	//: Clan Application destructor
+	virtual ~CL_ClanApplication();
+
+	//: Main application function
+	//- &lt;p&gt; Every program made using ClanLib must implement this function. 
+	//- This is the main application function, which will be called 
+	//- &lt;i&gt;once&lt;/i&gt; following system initialization. &lt;/p&gt;
+	//param argc: The number of arguments to the program (c-style)
+	//param argv: A pointer to strings, containing the program arguments. The name of the program executable is always passed as first argument.
+	//return: Program return value
+	virtual int main(int argc, char** argv)=0;
+
+	//: Static pointer to an initialized instance of this class.
+	//: This is set by the constructor.
+	static CL_ClanApplication *app;
+};
+
+#endif

Added: trunk/clanlib/API/Core/IOData/cl_endian.h
===================================================================
--- trunk/clanlib/API/Core/IOData/cl_endian.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/IOData/cl_endian.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,90 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;I/O Data&quot;
+//! header=core.h
+
+#ifndef header_endian
+#define header_endian
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+//: Endianess management class.
+//- !group=Core/IO Data!
+//- !header=core.h!
+//- &lt;p&gt;The CL_Endian class is used to convert between different endianess. There
+//- are also a set of defines to the lazy developer:&lt;/p&gt;
+//- &lt;p&gt;#define SWAP_IF_BIG(i)&lt;br&gt;
+//- #define SWAP_IF_LITTLE(i)&lt;br&gt;
+//- #define SWAP_IF_BIG_ALOT(i, times)&lt;br&gt;
+//- #define SWAP_IF_LITTLE_ALOT(i, times)&lt;br&gt;
+//- #define IS_SYSTEM_64BIT()&lt;/p&gt;
+//- &lt;p&gt;Each of these defines call CL_Endian::is_system_big() and CL_Endian::swap.&lt;/p&gt;
+class CL_API_CORE CL_Endian
+{
+public:
+//! Operations:
+	//: Swaps larger amounts of data between little and big endian.
+	//param data: Data to be swapped.
+	//param type_size: Size of datatype to be swapped.
+	//param total_times: Number of 'type_size' size data chunks to be swapped.
+	static void swap(void *data, int type_size, int total_times=1);
+
+//! Attributes:
+	//: Returns true if big endian system.
+	//return: True if big endian system, false otherwise.
+	static bool is_system_big();
+
+	//: Returns true if 64 bit system.
+	//return: True if 64 bit, false otherwise.
+	static bool is_system_64bit();
+};
+
+// Defines to the lazy developer:
+#define SWAP_IF_BIG(i) if (CL_Endian::is_system_big()) CL_Endian::swap(&amp;i, sizeof(i))
+#define SWAP_IF_LITTLE(i) if (!CL_Endian::is_system_big()) CL_Endian::swap(&amp;i, sizeof(i))
+
+#define SWAP_IF_BIG_ALOT(i, times) if (CL_Endian::is_system_big()) CL_Endian::swap(&amp;i, sizeof(i), times)
+#define SWAP_IF_LITTLE_ALOT(i, times) if (!CL_Endian::is_system_big()) CL_Endian::swap(&amp;i, sizeof(i), times)
+
+#define IS_SYSTEM_64BIT() CL_Endian::is_system_64bit()
+
+#endif

Added: trunk/clanlib/API/Core/IOData/datatypes.h
===================================================================
--- trunk/clanlib/API/Core/IOData/datatypes.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/IOData/datatypes.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,60 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;I/O Data&quot;
+//! header=core.h
+
+#ifndef header_iotypes
+#define header_iotypes
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#if defined(WIN32) &amp;&amp; (defined(__MINGW32__) == 0)
+typedef __int8             cl_int8;
+typedef unsigned __int8    cl_uint8;
+typedef __int16            cl_int16;
+typedef unsigned __int16   cl_uint16;
+typedef __int32            cl_int32;
+typedef unsigned __int32   cl_uint32;
+typedef __int64            cl_int64;
+typedef unsigned __int64   cl_uint64;
+#else
+typedef char               cl_int8;
+typedef unsigned char      cl_uint8;
+typedef short              cl_int16;
+typedef unsigned short     cl_uint16;
+typedef int                cl_int32;
+typedef unsigned int       cl_uint32;
+typedef long long          cl_int64;
+typedef unsigned long long cl_uint64;
+#endif
+
+#endif

Added: trunk/clanlib/API/Core/IOData/directory.h
===================================================================
--- trunk/clanlib/API/Core/IOData/directory.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/IOData/directory.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,85 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;I/O Data&quot;
+//! header=core.h
+
+#ifndef header_directory
+#define header_directory
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+
+//: Directory utility class
+//- !group=Core/IO Data!
+//- !header=core.h!
+class CL_API_CORE CL_Directory
+{
+//! Operations:
+public:
+	//: Create directory.
+	//- &lt;p&gt;return true on success or false on error.&lt;/p&gt;
+	//param dir_name: Directory name for create.
+	static bool create(const std::string &amp;dir_name);
+
+	//: Remove directory.
+	//- &lt;p&gt;Return true on success or false on error.&lt;/p&gt;
+	//param dir_name: Directory name for delete.
+	//param delete_files: If true, function will delete files.
+	//param delete_sub_directoies: If true, function will delete
+	//param delete_sub_directoies: sub directoies too.
+	static bool remove(
+		const std::string &amp;dir_name,
+		bool delete_files = false,
+		bool delete_sub_directories = false);
+
+	//: Change current directory.
+	//- &lt;p&gt;Return true on success or false on error.&lt;/p&gt;
+	//param path: Directory name to change to.
+	static bool change_to(const std::string &amp;path);
+
+	//: Get current directory.
+	//- &lt;p&gt;Returns the current directory path.&lt;/p&gt;
+	static std::string get_current();
+};
+
+#endif // header_directory

Added: trunk/clanlib/API/Core/IOData/directory_scanner.h
===================================================================
--- trunk/clanlib/API/Core/IOData/directory_scanner.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/IOData/directory_scanner.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,139 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;I/O Data&quot;
+//! header=core.h
+
+#ifndef header_directory_scanner
+#define header_directory_scanner
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../System/sharedptr.h&quot;
+#include &lt;string&gt;
+
+class CL_DirectoryScanner_Generic;
+
+//: Directory scanning class.
+//- !group=Core/IO Data!
+//- !header=core.h!
+//- &lt;p&gt;CL_DirectoryScanner is used to parse through directory trees and return information about files.&lt;/p&gt;
+//-
+//- &lt;p&gt;Example that prints all files and directories found in the root directory:&lt;/p&gt;
+//- &lt;pre&gt;
+//- CL_DirectoryScanner scanner;
+//- if (scanner.scan(&quot;/&quot;, &quot;*&quot;))
+//- {
+//- 		while (scanner.next())
+//- 		{
+//- 				std::cout &lt;&lt; scanner.get_name() &lt;&lt; std::endl;
+//- 		}
+//- }
+//- &lt;/pre&gt;
+class CL_API_CORE CL_DirectoryScanner
+{
+//! Construction:
+public:
+	//: Constructs directory scanner for iterating over a directory.
+	CL_DirectoryScanner();
+
+	CL_DirectoryScanner(const CL_DirectoryScanner &amp;copy);
+
+	//: Destructor.
+	~CL_DirectoryScanner();
+
+//! Attributes:
+public:
+	//: Gets the directory being scanned.
+	//return: Directory being scanned.
+	std::string get_directory_path();
+
+	//: Gets the name of the current file.
+	//return: The name of the current found file.
+	std::string get_name();
+
+	//: Gets the size of the current file.
+	//return: The size of the current found file.
+	int get_size();
+
+	//: Gets the pathname of the current file.
+	//return: The name of the current found file, including the directory path.
+	std::string get_pathname();
+
+	//: Returns true if the current file is a directory.
+	//return: True if filename is a directory.
+	bool is_directory();
+
+	//: Returns true if the file is hidden.
+	//return: True if filename is hidden.
+	bool is_hidden();
+
+	//: Returns true if the file is readable by the current user.
+	//return: True if the file is readable.
+	bool is_readable();
+
+	//: Returns true if the file is writable by the current user.
+	//return: True if the file is writable.
+	bool is_writable();
+
+//! Operations:
+public:       
+	//: Selects the directory to scan through.
+	//- &lt;p&gt;Selects the directory to scan through and use a matching pattern on the files.
+	//The pattern is normal DOS pattern matching (*.*).&lt;/p&gt;
+	//param pathname: Path to the directory to scan.
+	//param pattern: Pattern to match files against.
+	//return: true if the directory can be accessed.
+	bool scan(const std::string&amp; pathname);
+
+	bool scan(const std::string&amp; pathname, const std::string&amp; pattern);
+
+	//: Find next file in directory scan. 
+	//return: false if no more files was found.
+	bool next();
+
+//! Implementation:
+private:
+	// Yada yada, usual data hiding.
+	CL_SharedPtr&lt;CL_DirectoryScanner_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/Core/IOData/inputsource.h
===================================================================
--- trunk/clanlib/API/Core/IOData/inputsource.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/IOData/inputsource.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,206 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;I/O Data&quot;
+//! header=core.h
+
+#ifndef header_inputsource
+#define header_inputsource
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+#include &quot;datatypes.h&quot;
+
+//: Interface to read data.
+//- !group=Core/IO Data!
+//- !header=core.h!
+//- &lt;p&gt; CL_InputSource is used to read data from different types of input sources.
+//- In most cases, this is regular files and ClanLib zlib compressed datafiles. &lt;/p&gt;
+//- 
+//- &lt;p&gt;To access some system specific input source types, such as datafiles and
+//- regular ones, use the static create functions in the CL_InputSourceProvider
+//- class.&lt;/p&gt;
+//also CL_InputSourceProvider: Interface to open input sources with.
+class CL_API_CORE CL_InputSource
+{
+//! Enums:
+public:
+	//: Enum used by seek()
+	enum SeekEnum
+	{
+		seek_set,	 // from beginning of index
+		seek_cur,	 // from current position
+		seek_end	 // from end of index
+	};
+
+//! Construction:
+public:
+	//: Input Source Constructor
+	CL_InputSource() { set_system_mode(); }
+
+	//: Input Source Destructor
+	virtual ~CL_InputSource() { return; }
+
+//! Attributes:
+public:
+	//: Returns current position in input source.
+	//return: Current position in input source.
+	virtual int tell() const = 0;
+
+	//: Returns the size of the input source
+	//return: Size of the input source.
+	virtual int size() const = 0;
+
+	//: Returns true if the input source is in little endian mode.
+	virtual bool is_little_endian() { return little_endian_mode; }
+
+//! Operations:
+public:
+	//: Changes input data endianess to the local systems mode.
+	virtual void set_system_mode();
+
+	//: Changes input data endianess to big endian mode.
+	virtual void set_big_endian_mode();
+
+	//: Changes input data endianess to little endian mode. This is the default setting.
+	virtual void set_little_endian_mode();
+	
+	//: Reads a signed 64 bit integer from input source.
+	//return: The integer read.
+	virtual cl_int64 read_int64();
+
+	//: Reads an unsigned 64 bit integer from input source.
+	//return: The integer read.
+	virtual cl_uint64 read_uint64();
+	
+	//: Reads a signed 32 bit integer from input source.
+	//return: The integer read.
+	virtual cl_int32 read_int32();
+
+	//: Reads an unsigned 32 bit integer from input source.
+	//return: The integer read.
+	virtual cl_uint32 read_uint32();
+	
+	//: Reads a signed 16 bit integer from input source.
+	//return: The integer read.
+	virtual cl_int16 read_int16();
+
+	//: Reads an unsigned 16 bit integer from input source.
+	//return: The integer read.
+	virtual cl_uint16 read_uint16();
+	
+	//: Reads a signed 8 bit integer from input source.
+	//return: The integer read.
+	virtual cl_int8 read_int8();
+
+	//: Reads an unsigned 8 bit integer from input source.
+	//return: The integer read.
+	virtual cl_uint8 read_uint8();
+
+	//: Reads a signed 16 bit integer (short) from input source.
+	//return: The short read.
+	virtual short read_short16();
+
+	//: Reads an unsigned 16 bit integer (short) from input source.
+	//return: The unsigned short read.
+	virtual unsigned short read_ushort16();
+
+	//: Reads a signed 8 bit integer (char) from input source.
+	//return: The char read.
+	virtual char read_char8();
+
+	//: Reads an unsigned 8 bit integer (char) from input source.
+	//return: The unsigned char read.
+	virtual unsigned char read_uchar8();
+
+	//: Reads an ieee format floating point from input source.
+	//return: The float read.
+	virtual float read_float32();
+
+	//: Reads an ieee format double from input source.
+	//return: The double read.
+	virtual double read_float64();
+
+	//: Reads a bool from input source.
+	//return: The bool read.
+	virtual bool read_bool8();
+
+	//: Reads larger amounts of data (no endian and 64 bit conversion).
+	//param data: Points to an array where the read data is stored.
+	//param size: Number of bytes to read.
+	//return: Num bytes actually read.
+	virtual int read(void *data, int size) = 0;
+	
+	//: Opens the input source. By default, it is open.
+	virtual void open() = 0;
+	
+	//: Closes the input source.
+	virtual void close() = 0;
+
+	//: Make a copy of the current inputsource, standing at the same position.
+	//return: The copy of the input source.
+	virtual CL_InputSource *clone() const = 0;
+
+	//: Reads a string from the input source.
+	//- &lt;p&gt;The binary format expected in the input source is first an uint32 telling the length of the
+	//- string, and then the string itself.&lt;/p&gt;
+	//return: The string read.
+	virtual std::string read_string();
+
+	//: Seeks to the specified position in the input source.
+	//param pos: Position relative to 'seek_type'.
+	//param seek_type: Defines what the 'pos' is relative to. Can be either seek_set, seek_cur og seek_end.
+	virtual void seek(int pos, SeekEnum seek_type) = 0;
+
+	//: Pushes the current input source position.
+	//: The position can be restored again with pop_position.
+	virtual void push_position() = 0;
+	
+	//: Pops a previous pushed input source position (returns to the position).
+	virtual void pop_position() = 0;
+
+//! Implementation:
+protected:
+	bool little_endian_mode;
+};
+
+#endif

Added: trunk/clanlib/API/Core/IOData/inputsource_file.h
===================================================================
--- trunk/clanlib/API/Core/IOData/inputsource_file.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/IOData/inputsource_file.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,112 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;I/O Data&quot;
+//! header=core.h
+
+#ifndef header_inputsource_file
+#define header_inputsource_file
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;inputsource.h&quot;
+
+#include &lt;string&gt;
+#include &lt;stack&gt;
+#include &lt;stdio.h&gt;
+
+//: Inputsource reading from file.
+//- !group=Core/IO Data!
+//- !header=core.h!
+class CL_InputSource_File : public CL_InputSource
+{
+//! Construction:
+public:
+	//: Input Souce File constructor.
+	CL_InputSource_File(const std::string &amp;filename);
+
+	CL_InputSource_File(const CL_InputSource_File *source);
+
+	//: Input Souce File destructor
+	virtual ~CL_InputSource_File();
+
+//! Attributes:
+public:
+	//: Returns current position in input source.
+	//return: Current position in input source.
+	virtual int tell() const;
+
+	//: Returns the size of the input source
+	//return: Size of the input source.
+	virtual int size() const;
+
+//! Operations:
+public:
+	//: Reads larger amounts of data (no endian and 64 bit conversion):
+	//param data: Points to an array where the read data is stored.
+	//param size: Number of bytes to read.
+	//return: Num bytes actually read.
+	virtual int read(void *data, int size);
+
+	//: Opens the input source. By default, it is open.
+	virtual void open();
+
+	//: Closes the input source.
+	virtual void close();
+
+	//: Make a copy of the current inputsource, standing at the same position.
+	//return: The copy of the input source.
+	virtual CL_InputSource *clone() const;
+
+	//: Seeks to the specified position in the input source.
+	//param pos: Position relative to 'seek_type'.
+	//param seek_type: Defines what the 'pos' is relative to. Can be either seek_set, seek_cur og seek_end.
+	virtual void seek(int pos, SeekEnum seek_type);
+
+	//: Pushes the current input source position.
+	//- &lt;p&gt;The position can be restored again with pop_position.&lt;/p&gt;
+	virtual void push_position();
+
+	//: Pops a previous pushed input source position (returns to the position).
+	virtual void pop_position();
+	
+	//: Gets the actual path after relative path translation.
+	static std::string translate_path(const std::string &amp;path);
+
+//! Implementation:
+private:
+	std::stack&lt;int&gt; stack;
+	std::string filename;
+	FILE *filehandle;
+	int filesize;
+};
+
+#endif

Added: trunk/clanlib/API/Core/IOData/inputsource_memory.h
===================================================================
--- trunk/clanlib/API/Core/IOData/inputsource_memory.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/IOData/inputsource_memory.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,121 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;I/O Data&quot;
+//! header=core.h
+
+#ifndef header_inputsource_memory
+#define header_inputsource_memory
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;inputsource.h&quot;
+
+//: Interface to read data from a memory source.
+//- !group=Core/IO Data!
+//- !header=core.h!
+//- &lt;p&gt;CL_InputSource_Memory is used to read data from a memory source.
+//- CL_InputSourceProvider - Interface to open input sources with.&lt;/p&gt;
+class CL_API_CORE CL_InputSource_Memory : public CL_InputSource
+{
+//! Construction:
+public:
+	//: Input Source Memory constructor.
+	CL_InputSource_Memory(const std::string &amp;data);
+
+	CL_InputSource_Memory(void *data, int size, bool copy_data = false);
+
+	//: Input Source Memory destructor.
+	virtual ~CL_InputSource_Memory();
+
+//! Attributes:
+public:
+	//: Returns current position in input source.
+	//return: Current position in input source.
+	virtual int tell() const;
+
+	//: Returns the size of the input source
+	//return: Size of the input source.
+	virtual int size() const;
+
+	//: Get the pointer to the internal data array in the memory source.
+	//return: String containing the internal data array's data.
+	std::string get_data() const;
+
+//! Operations:
+public:
+	//: Reads larger amounts of data (no endian and 64 bit conversion).
+	//param data: Points to an array where the read data is stored.
+	//param size: Number of bytes to read.
+	//return: Num bytes actually read.
+	virtual int read(void *data, int size);
+	
+	//: Opens the input source. By default, it is open.
+	virtual void open();
+	
+	//: Closes the input source.
+	virtual void close();
+
+	//: Make a copy of the current inputsource, standing at the same position.
+	//return: The copy of the input source.
+	virtual CL_InputSource *clone() const;
+
+	//: Seeks to the specified position in the input source.
+	//param pos: Position relative to 'seek_type'.
+	//param seek_type: Defines what the 'pos' is relative to. Can be either seek_set, seek_cur og seek_end.
+	virtual void seek(int pos, SeekEnum seek_type);
+
+	//: Pushes the current input source position.
+	//- &lt;p&gt;The position can be restored again with pop_position.&lt;/p&gt;
+	virtual void push_position();
+	
+	//: Pops a previous pushed input source position (returns to the position).
+	virtual void pop_position();
+
+//! Implementation:
+private:
+	unsigned char *data;
+	int data_size;
+	int pos;
+	std::string str_data;
+};
+
+#endif

Added: trunk/clanlib/API/Core/IOData/inputsource_provider.h
===================================================================
--- trunk/clanlib/API/Core/IOData/inputsource_provider.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/IOData/inputsource_provider.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,95 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;I/O Data&quot;
+//! header=core.h
+
+#ifndef header_inputsource_provider
+#define header_inputsource_provider
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+class CL_InputSource;
+
+//: Class that provides input sources.
+//- !group=Core/IO Data!
+//- !header=core.h!
+//- &lt;p&gt;CL_InputSourceProvider is used to open inputsources. This can be from a
+//- datafile where the inputsource is an index - or it a directory where the
+//- files are the inputsources.&lt;/p&gt;
+class CL_API_CORE CL_InputSourceProvider
+{
+public:
+//! Construction:
+	//: Input Source Provider destructor.
+	virtual ~CL_InputSourceProvider() { return; }
+
+	//: Creates a file provider.
+	//- &lt;p&gt;Input sources opened are considered as files.&lt;/p&gt;
+	//param path: Path where the files are located.
+	//return: The file input provider created.
+	static CL_InputSourceProvider *create_file_provider(const std::string &amp;path);
+
+	//: Creates a datafile provider.
+	//- &lt;p&gt;Input sources are opened as indexes in the specified datafile.&lt;/p&gt;
+	//param filename: Name of the datafile to be used.
+	//return: The datafile input provider created.
+	static CL_InputSourceProvider *create_datafile_provider(const std::string &amp;filename);
+
+//! Overrideables:
+	//: Opens an inputsource using the passed handle.
+	//param handle: handle/index/filename/identier to the input source requested.
+	//return: The opened input source.
+	virtual CL_InputSource *open_source(const std::string &amp;handle) = 0;
+
+	//: Returns a copy of the current provider.
+	//return: The copy of the inputsource provider.
+	virtual CL_InputSourceProvider *clone() = 0;
+
+	//: Get full path to source:
+	virtual std::string get_pathname(const std::string &amp;filename) = 0;
+
+	//: Returns a new inputsource provider object that uses a new path relative to current one.
+	virtual CL_InputSourceProvider *create_relative(const std::string &amp;path) = 0;
+};
+
+#endif

Added: trunk/clanlib/API/Core/IOData/inputsource_provider_file.h
===================================================================
--- trunk/clanlib/API/Core/IOData/inputsource_provider_file.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/IOData/inputsource_provider_file.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,92 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;I/O Data&quot;
+//! header=core.h
+
+#ifndef header_inputsource_provider_file
+#define header_inputsource_provider_file
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;inputsource_provider.h&quot;
+#include &lt;string&gt;
+
+class CL_InputSource;
+
+//: The Input Source Provider File Class    
+//- !group=Core/IO Data!
+//- !header=core.h!
+//- &lt;p&gt;CL_InputSourceProvider_File is a subclass of CL_InputSourceProvider.
+//- It provides a way to treat normal files as input sources and to read and write them 
+//- in a endian transparent manner.&lt;/p&gt;
+
+class CL_API_CORE CL_InputSourceProvider_File : public CL_InputSourceProvider
+{
+//! Construction:
+public:
+	//: Construtcs a file input source provider.
+	//param path: File to create a source for.
+	CL_InputSourceProvider_File(const std::string &amp;path);
+
+	//: Open input source using file as its source.
+	//param filename: Filename to open.
+	//return: InputSource for the file.
+	virtual CL_InputSource *open_source(const std::string &amp;filename);
+
+	//: Get full path to source:
+	virtual std::string get_pathname(const std::string &amp;filename);
+
+	//: Returns a new inputsource provider object that uses a new path relative to current one.
+	virtual CL_InputSourceProvider *create_relative(const std::string &amp;path);
+
+	//: Clone the provider.
+	//- &lt;p&gt;Creates a new instance of the class with the same internal data.
+	//- This is equivaled to &lt;i&gt;new CL_InputSourceProvider_File(get_path())&lt;/i&gt;.&lt;/p&gt;
+	//return: New instance of the current provider.
+	virtual CL_InputSourceProvider *clone();
+
+//! Implementation:
+private:
+	std::string provider_path;
+};
+
+#endif

Added: trunk/clanlib/API/Core/IOData/inputsource_zipped.h
===================================================================
--- trunk/clanlib/API/Core/IOData/inputsource_zipped.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/IOData/inputsource_zipped.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,116 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;I/O Data&quot;
+//! header=core.h
+
+#ifndef header_inputsource_zipped
+#define header_inputsource_zipped
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;inputsource.h&quot;
+
+class CL_InputSource_Zipped_Generic;
+
+//: Zlib compressed input source.
+//- !group=Core/IO Data!
+//- !header=core.h!
+//- &lt;p&gt;CL_InputSource_Zipped provides read access to gzip compressed source files
+//- and handles endianess internally.&lt;/p&gt;
+class CL_API_CORE CL_InputSource_Zipped : public CL_InputSource
+{
+//! Construction:
+public:
+	//: Starts reading zipped input from the specified input source.
+	//- &lt;p&gt;If 'delete_input' is true, the input source will be deleted when
+	//- the zipped input source is deleted.&lt;/p&gt;
+	CL_InputSource_Zipped(CL_InputSource *input, bool delete_input = false);
+
+	// Destructor.
+	virtual ~CL_InputSource_Zipped();
+
+//! Attributes:
+public:
+	//: Returns current position in input source.
+	//return: Current position in input source.
+	virtual int tell() const;
+
+	//: Returns the size of the input source
+	//return: Size of the input source.
+	virtual int size() const;
+
+//! Operations:
+public:
+	//: Reads larger amounts of data (no endian and 64 bit conversion).
+	//param data: Points to an array where the read data is stored.
+	//param size: Number of bytes to read.
+	//return: Num bytes actually read.
+	virtual int read(void *data, int size);
+
+	//: Opens the input source. By default, it is open.
+	virtual void open();
+
+	//: Closes the input source.
+	virtual void close();
+
+	//: Make a copy of the current inputsource, standing at the same position.
+	//return: The copy of the input source.
+	virtual CL_InputSource *clone() const;
+
+	//: Seeks to the specified position in the input source.
+	//param pos: Position relative to 'seek_type'.
+	//param seek_type: Defines what the 'pos' is relative to. Can be either seek_set, seek_cur og seek_end.
+	virtual void seek(int pos, SeekEnum seek_type);
+
+	//: Pushes the current input source position.
+	//- &lt;p&gt;The position can be restored again with pop_position.&lt;/p&gt;
+	virtual void push_position();
+	
+	//: Pops a previous pushed input source position (returns to the position).
+	virtual void pop_position();
+
+//! Implementation:
+private:
+	CL_InputSource_Zipped_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Core/IOData/outputsource.h
===================================================================
--- trunk/clanlib/API/Core/IOData/outputsource.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/IOData/outputsource.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,165 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;I/O Data&quot;
+//! header=core.h
+
+#ifndef header_outputsource
+#define header_outputsource
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;datatypes.h&quot;
+#include &lt;string&gt;
+
+//: Interface to write data to different types of output sources.
+//- !group=Core/IO Data!
+//- !header=core.h!
+//- &lt;p&gt;CL_OutputSource is used to write data to different types of input sources.
+//- In most cases, this is regular files and ClanLib zlib compressed datafiles.&lt;/p&gt;
+//- 
+//- &lt;p&gt;To access some system specific output source types, such as datafiles and
+//- regular ones, use the static create functions in the CL_OutputSourceProvider
+//- class.&lt;/p&gt;
+//- &lt;p&gt;CL_OutputSourceProvider - Interface to open output sources with.&lt;/p&gt;
+class CL_API_CORE CL_OutputSource
+{
+//! Construction:
+public:
+	//: Output Source constructor.
+	CL_OutputSource() { set_system_mode(); }
+
+	//: Output Source destructor.
+	virtual ~CL_OutputSource() { return; }
+
+//! Attributes:
+public:
+	//: Returns current position in output source.
+	//return: Current position in source.
+	virtual int tell() const = 0;
+
+	//: Returns the size of the output source.
+	//return: Size of the output source.
+	virtual int size() const = 0;
+
+//! Operations:
+public:
+	//: Changes output data endianess to the local systems mode.
+	virtual void set_system_mode();
+
+	//: Changes output data endianess to big endian mode.
+	virtual void set_big_endian_mode();
+
+	//: Changes output data endianess to little endian mode. This is the default setting.
+	virtual void set_little_endian_mode();
+
+	//: Writes a signed 64 bit integer to output source.
+	virtual void write_int64(cl_int64 data);
+
+	//: Writes an unsigned 64 bit integer to output source.
+	virtual void write_uint64(cl_uint64 data);
+
+	//: Writes a signed 32 bit integer to output source.
+	virtual void write_int32(cl_int32 data);
+
+	//: Writes an unsigned 32 bit integer to output source.
+	virtual void write_uint32(cl_uint32 data);
+
+	//: Writes a signed 16 bit integer to output source.
+	virtual void write_int16(cl_int16 data);
+
+	//: Writes an unsigned 16 bit integer to output source.
+	virtual void write_uint16(cl_uint16 data);
+
+	//: Writes a signed 8 bit integer to output source.
+	virtual void write_int8(cl_int8 data);
+
+	//: Writes an unsigned 8 bit integer to output source.
+	virtual void write_uint8(cl_uint8 data);
+
+	//: Writes a signed 16 bit integer (short) to output source.
+	virtual void write_short16(short data);
+
+	//: Writes an unsigned 16 bit integer (short) to output source.
+	virtual void write_ushort16(unsigned short data);
+
+	//: Writes a signed 8 bit integer (char) to output source.
+	virtual void write_char8(char data);
+
+	//: Writes an unsigned 8 bit integer (char) to output source.
+	virtual void write_uchar8(unsigned char data);
+
+	//: Writes an ieee format floating point to output source.
+	virtual void write_float32(float data);
+
+	//: Writes an ieee format double to output source.
+	void write_float64(double data);
+
+	//: Writes a bool to output source.
+	virtual void write_bool8(bool data);
+
+	//: Writes a string to the output source.
+	//- &lt;p&gt;The binary format written to the output source is first an uint32 telling the length of the
+	//- string, and then the string itself.&lt;/p&gt;
+	virtual void write_string(const std::string &amp;str);
+
+	//: Writes larger amounts of data (no endian and 64 bit conversion).
+	//param data: Points to the array from which to write.
+	//param size: Number of bytes to write.
+	//return: Num bytes actually written.
+	virtual int write(const void *data, int size) = 0;
+	
+	//: Opens the output source. By default, it is open.
+	virtual void open() = 0;
+	
+	//: Closes the output source.
+	virtual void close() = 0;
+
+	//: Make a copy of the current outputsource, standing at the same position.
+	//return: The copy of the output source.
+	virtual CL_OutputSource *clone() = 0;
+
+//! Implementation:
+protected:
+	bool little_endian_mode;
+};
+
+#endif

Added: trunk/clanlib/API/Core/IOData/outputsource_file.h
===================================================================
--- trunk/clanlib/API/Core/IOData/outputsource_file.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/IOData/outputsource_file.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,109 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;I/O Data&quot;
+//! header=core.h
+
+#ifndef header_outputsource_file
+#define header_outputsource_file
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;outputsource.h&quot;
+
+#include &lt;string&gt;
+#include &lt;stdio.h&gt;
+
+//: Outputsource writing to file.         
+//- !group=Core/IO Data!
+//- !header=core.h!
+//- &lt;p&gt;CL_OutputSource_File provides write access to files while internally dealing with endianess.
+//- CL_OutputSource_File should not be instantiated directly, but 
+//- rather CL_OutputSourceProvider should create the appropriate output source.&lt;/p&gt;
+class CL_API_CORE CL_OutputSource_File : public CL_OutputSource
+{
+//! Construction:
+public:
+	//: Construct file output source.
+	//param file: Filename of file that the output source will use as destination.
+	CL_OutputSource_File(const std::string &amp;file);
+
+	CL_OutputSource_File();
+
+	//: Output Source File destructor.
+	virtual ~CL_OutputSource_File();
+
+//! Attributes:
+public:
+	//: Returns current position in output source.
+	//return: Current position in source.
+	virtual int tell() const;
+
+	//: Returns the size of the output source.
+	//return: Current size of output source.
+	virtual int size() const;
+
+//! Operations:
+public:
+	//: Writes larger amounts of data (no endian and 64 bit conversion):
+	//param data: Points to the array written.
+	//param size: Number of bytes to write.
+	//return: Num bytes actually written.
+	virtual int write(const void *data, int size);
+	
+	//: Opens the output source. By default, it is open.
+	virtual void open();
+	
+	//: Closes the output source.
+	virtual void close();
+
+	//: Make a copy of the current outputsource, standing at the same position.
+	//return: The copy of the output source.
+	virtual CL_OutputSource *clone();
+
+//! Implementation:
+private:
+	unsigned int pos;
+	FILE *file;
+	std::string filename;
+};
+
+#endif

Added: trunk/clanlib/API/Core/IOData/outputsource_memory.h
===================================================================
--- trunk/clanlib/API/Core/IOData/outputsource_memory.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/IOData/outputsource_memory.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,108 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;I/O Data&quot;
+//! header=core.h
+
+#ifndef header_outputsource_memory
+#define header_outputsource_memory
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;outputsource.h&quot;
+
+//: Outputsource writing to memory.
+//- !group=Core/IO Data!
+//- !header=core.h!
+//- &lt;p&gt;CL_OutputSource_Memory provides a way to write to memory in a way that is abstracted from 
+//- the user. CL_OutputSource_Memory should not be instantiated directly, but 
+//- rather CL_OutputSourceProvider should create the appropriate output source.&lt;/p&gt;
+
+class CL_API_CORE CL_OutputSource_Memory : public CL_OutputSource
+{
+//! Construction:
+public:
+	//: Constructs a memory output source.
+	CL_OutputSource_Memory();
+
+	//: Output Source Memory destructor.
+	virtual ~CL_OutputSource_Memory();
+
+//! Attributes:
+public:
+	//: Returns current position in output source.
+	//return: Current position in source.
+	virtual int tell() const;
+
+	//: Returns the size of the output source.
+	//return: Size of the output source.
+	virtual int size() const;
+
+	//: Get the pointer to the internal data array in the memory source.
+	//- &lt;p&gt;Used to extract the data after usage.&lt;/p&gt;
+	//return: String containing the data written to the output source.
+	std::string get_data() const;
+
+//! Operations:
+public:
+	//: Writes larger amounts of data (no endian and 64 bit conversion).
+	//param data: Points to the array from which to write.
+	//param size: Number of bytes to write.
+	//return: Num bytes actually written.
+	virtual int write(const void *data, int size);
+	
+	//: Opens the output source. By default, it is open.
+	virtual void open();
+	
+	//: Closes the output source.
+	virtual void close();
+
+	//: Make a copy of the current outputsource, standing at the same position.
+	//return: The copy of the output source.
+	virtual CL_OutputSource *clone();
+
+//! Implementation:
+private:
+	std::string data;
+	unsigned int pos;
+};
+
+#endif

Added: trunk/clanlib/API/Core/IOData/outputsource_provider.h
===================================================================
--- trunk/clanlib/API/Core/IOData/outputsource_provider.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/IOData/outputsource_provider.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,67 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;I/O Data&quot;
+//! header=core.h
+
+#ifndef header_outputsource_provider
+#define header_outputsource_provider
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+
+class CL_OutputSource;
+
+//: Class that provides output targets.
+//- !group=Core/IO Data!
+//- !header=core.h!
+//- &lt;p&gt;CL_OutputSourceProvider is used to open output sources. This can be from a
+//- datafile where the outputsource is an index - or it a directory where the
+//- files are the outputsources.&lt;/p&gt;
+class CL_OutputSourceProvider
+{
+public:
+//! Overrideables:
+	//: Output Source Provider destructor.
+	virtual ~CL_OutputSourceProvider() { return; }
+
+	//: Opens an outputsource using the passed handle.
+	//param handle: handle/index/filename/identier to the output source requested.
+	//return: The output source opened.
+	virtual CL_OutputSource *open_source(const std::string &amp;handle) = 0;
+
+	//: Returns a copy of the current provider.
+	//return: The copy of the outputsource provider.
+	virtual CL_OutputSourceProvider *clone() = 0;
+};
+
+#endif

Added: trunk/clanlib/API/Core/IOData/outputsource_zipped.h
===================================================================
--- trunk/clanlib/API/Core/IOData/outputsource_zipped.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/IOData/outputsource_zipped.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,110 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;I/O Data&quot;
+//! header=core.h
+
+#ifndef header_outputsource_zipped
+#define header_outputsource_zipped
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;outputsource.h&quot;
+
+class CL_OutputSource_Zipped_Generic;
+
+//: Zlib compressed output source.
+//- !group=Core/IO Data!
+//- !header=core.h!
+//- &lt;p&gt;CL_OutputSource_Zipped_Generic provides write access to compress files while internally
+//-  dealing with endianess.&lt;/p&gt;
+//- &lt;p&gt;CL_OutputSource_Zipped_Generic should not be instantiated directly, but
+//- rather CL_OutputSourceProvider should create the appropriate output source.&lt;/p&gt;
+
+class CL_API_CORE CL_OutputSource_Zipped : public CL_OutputSource
+{
+//! Construction:
+public:
+	//: Constructs an output source that zips the data and passes it on to
+	//: the passed output source.
+	//- &lt;p&gt;If delete_output is true, the zipped output source will delete the
+	//- output source at destruction.&lt;/p&gt;
+	CL_OutputSource_Zipped(CL_OutputSource *output, bool delete_output = false);
+
+	CL_OutputSource_Zipped(const CL_OutputSource_Zipped &amp;copy);
+
+	//: Destructor.
+	virtual ~CL_OutputSource_Zipped();
+
+//! Attributes:
+public:
+	//: Returns current position in output source.
+	//return: Current position in source.
+	virtual int tell() const;
+
+	//: Returns the size of the output source
+	//return: Size of the output source.
+	virtual int size() const;
+
+//! Operations:
+public:
+	//: Writes larger amounts of data (no endian and 64 bit conversion):
+	//param data: Points to the array from which to write.
+	//param size: Number of bytes to write.
+	//return: Num bytes actually written.
+	virtual int write(const void *data, int size);
+	
+	//: Opens the output source. By default, it is open.
+	virtual void open();
+	
+	//: Closes the output source.
+	virtual void close();
+
+	//: Make a copy of the current outputsource, standing at the same position.
+	//return: The copy of the output source.
+	virtual CL_OutputSource *clone();
+
+//! Implementation:
+private:
+	CL_OutputSource_Zipped_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Core/IOData/zip_archive.h
===================================================================
--- trunk/clanlib/API/Core/IOData/zip_archive.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/IOData/zip_archive.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,122 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;I/O Data&quot;
+//! header=core.h
+
+#ifndef header_zip_archive
+#define header_zip_archive
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../System/sharedptr.h&quot;
+#include &quot;zip_file_entry.h&quot;
+#include &quot;inputsource_provider.h&quot;
+
+class CL_InputSource;
+class CL_OutputSource;
+class CL_Zip_Archive_Generic;
+
+//: Zip archive.
+//- !group=Core/IO Data!
+//- !header=core.h!
+class CL_API_CORE CL_Zip_Archive : public CL_InputSourceProvider
+{
+//! Construction:
+public:
+	//: Constructs or loads a ZIP archive.
+	//param filename: .zip archive to load.
+	CL_Zip_Archive();
+	
+	CL_Zip_Archive(const std::string &amp;filename);
+	
+	CL_Zip_Archive(const CL_Zip_Archive &amp;copy);
+	
+	~CL_Zip_Archive();
+
+//! Attributes:
+public:
+	//: List of file entries in archive.
+	std::vector&lt;CL_Zip_FileEntry&gt; &amp;get_file_list();
+
+//! Operations:
+public:
+	//: Opens a file in the archive.
+	CL_InputSource *open_source(const std::string &amp;filename);
+	
+	//: Clones this input source provider.
+	CL_InputSourceProvider *clone();
+
+	//: Get full path to source:
+	std::string get_pathname(const std::string &amp;filename);
+
+	//: Returns a new inputsource provider object that uses a new path relative to current one.
+	CL_InputSourceProvider *create_relative(const std::string &amp;path);
+
+	//: Creates a new file entry
+	CL_OutputSource *create_file(const std::string &amp;filename, bool compress = true);
+
+	//: Adds a file to zip archive.
+	//- &lt;p&gt;File is not added to zip file until it save() is called.&lt;/p&gt;
+	//param filename: Filename of file.
+	void add_file(const std::string &amp;filename, bool compress = true);
+
+	//: Saves zip archive.
+	//param filename: Filename of zip archive. Must not be used to save to the same as loaded from.
+	//- &lt;p&gt;If no filename parameter was passed, it will modify the zip
+	//- archive loaded at construction time. It does this by creating a
+	//- temporary file, saving the new archive, deletes the old one and
+	//- renames the temp file to the original archive filename.&lt;/p&gt;
+	//-
+	//- &lt;p&gt;If the archive was created instead of loaded, a filename must
+	//- be specify a filename. Likewise, if saving to same archive as
+	//- loaded from, a filename must not be specified. Doing so will
+	//- cause the save operation to fail.&lt;/p&gt;
+	void save();
+	
+	void save(const std::string &amp;filename);
+
+//! Implementation:
+private:
+	CL_SharedPtr&lt;CL_Zip_Archive_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/Core/IOData/zip_file_entry.h
===================================================================
--- trunk/clanlib/API/Core/IOData/zip_file_entry.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/IOData/zip_file_entry.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,94 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;I/O Data&quot;
+//! header=core.h
+
+#ifndef header_zip_file_entry
+#define header_zip_file_entry
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+#include &quot;datatypes.h&quot;
+
+class CL_Zip_FileEntry_Generic;
+
+//: File entry in zip file.
+//- !group=Core/IO Data!
+//- !header=core.h!
+class CL_API_CORE CL_Zip_FileEntry
+{
+//! Construction:
+public:
+	CL_Zip_FileEntry();
+	
+	CL_Zip_FileEntry(const CL_Zip_FileEntry &amp;copy);
+	
+	~CL_Zip_FileEntry();
+
+//! Attributes:
+public:
+	//: Returns the filename of file entry.
+	const std::string &amp; get_filename() const;
+	
+	//: Returns the uncompressed size of file entry.
+	cl_int64 get_uncompressed_size();
+	
+	//: Returns the compressed size of file entry.
+	cl_int64 get_compressed_size();
+
+//! Operations:
+public:
+	//: Copy assignment operator.
+	CL_Zip_FileEntry &amp;operator =(const CL_Zip_FileEntry &amp;copy);
+	
+	//: Sets the filename of file entry.
+	void set_filename(const std::string &amp;filename);
+
+//! Implementation:
+private:
+	CL_Zip_FileEntry_Generic *impl;
+	friend class CL_Zip_Archive;
+	friend class CL_InputSource_Zip_FileEntry;
+};
+
+#endif

Added: trunk/clanlib/API/Core/Math/circle.h
===================================================================
--- trunk/clanlib/API/Core/Math/circle.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/Math/circle.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,108 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Harry Storbacka
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;Math&quot;
+//! header=core.h
+
+#ifndef header_circle
+#define header_circle
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+class CL_Circlef;
+
+//: Circle (point,radius) structure.
+//- !group=Core/Math!
+//- !header=core.h!
+class CL_Circle
+{
+// Construction:
+public:
+	//: Constructs a Circle.
+	//param x: Initial x value.
+	//param y: Initial y value.
+	//param radius: Circle radius.
+	//param p: Point to use for initial values.
+	CL_Circle()
+	{ return; }
+
+	CL_Circle(int x, int y, int radius)
+	: position(x,y), radius(radius) { return; }
+
+	CL_Circle(const CL_Point &amp;p, int radius)
+	: position(p), radius(radius) { return; }
+
+	explicit CL_Circle(const CL_Circlef&amp; other);
+
+// Attributes:
+public:
+	//: Circle center point
+	CL_Point position;
+
+	//: Circle radius
+	int radius;
+};
+
+
+class CL_Circlef
+{
+// Construction:
+public:
+	//: Constructs a Circle.
+	//param x: Initial x value.
+	//param y: Initial y value.
+	//param radius: Circle radius.
+	//param p: Point to use for initial values.
+	CL_Circlef()
+	{ return; }
+
+	CL_Circlef(double x, double y, double radius)
+	: position((float)x,(float)y), radius(radius) { return; }
+
+	CL_Circlef(const CL_Pointf &amp;p, double radius)
+	: position(p), radius(radius) { return; }
+
+// Attributes:
+public:
+	//: Circle center point
+	CL_Pointf position;
+
+	//: Circle radius
+	double radius;
+};
+
+inline CL_Circle::CL_Circle(const CL_Circlef &amp;other)
+: position(other.position), radius(int(other.radius+0.5))
+{
+	return;
+}
+
+#endif

Added: trunk/clanlib/API/Core/Math/cl_vector.h
===================================================================
--- trunk/clanlib/API/Core/Math/cl_vector.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/Math/cl_vector.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,167 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;Math&quot;
+//! header=core.h
+
+#ifndef header_cl_vector
+#define header_cl_vector
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;iostream&gt;
+
+//: Vector class.
+//- !group=Core/Math!
+//- !header=core.h!
+//- &lt;p&gt;This class provides basic functions and operators for working with vectors.&lt;/p&gt;
+class CL_API_CORE CL_Vector
+{
+public:
+//! Variables:
+	//: x coordinate
+	float x;
+	//: y coordinate
+	float y;
+	//: z coordinate
+	float z;
+	//: w coordinate
+	float w;
+      
+public:
+	
+//! Construction:
+	//: Constructor that initializes a vector
+	//param x: Initial x coordinate of vector.
+	//param y: Initial y coordinate of vector.
+	//param z: Initial z coordinate of vector.
+	//param w: Initial w coordinate of vector.
+	//param other: vector to copy construct from.
+	CL_Vector(float x = 0.0, float y = 0.0, float z = 0.0, float w = 1.0);
+
+	CL_Vector(const CL_Vector &amp;other);
+
+//! Attributes:
+	//: Returns the (euclid) norm of the vector.
+	//- &lt;p&gt;This function does not use the w coordinate of the vector. It only uses
+	//- the x,y,z coordinates.&lt;/p&gt;
+	//return: the euclid norm of the vector (in R^3)
+	float norm() const;
+
+	//: Normalizes the vector (not taking into account the w ordinate!)
+	void normalize();
+
+	//: Dot products this vector with an other vector.
+	//param vector: Second vector used for the dot product.
+	//return: The resulting dot product of the two vectors.
+	float dot(const CL_Vector&amp; vector) const;
+	
+	//: Calculate the angle between this vector and an other vector.
+	//param vector: Second vector used to calculate angle.
+	//return: The angle between the two vectors.
+	float angle(const CL_Vector&amp; vector) const;
+
+	//: Calculate the cross product between this vector and an other vector.
+	//param vector: Second vector used to perform the calculation.
+	//return: The cross product of the two vectors.
+	CL_Vector cross(const CL_Vector&amp; vector) const;
+	
+	//: Rotate vector around an axis.
+	//param angle: Angle to rotate.
+	//param axis: Rotation axis.
+	//return: The resulting rotated vector.
+	CL_Vector rotate(float angle, const CL_Vector&amp; axis) const;
+
+	//: Rounds all components.
+	void round();
+
+//! Operators:
+	//: Scalar product (vector * scalar)
+	//return: The scalar product
+	CL_Vector operator * (float scalar) const;  
+
+	//: Scalar product (scalar * vector)
+	//return: The scalar product.
+	friend CL_Vector operator *  (float scalar, const CL_Vector&amp; vector);
+
+	//: += operator.
+	void operator += (const CL_Vector&amp; v);
+
+	//: -= operator.
+	void operator -= (const CL_Vector&amp; v);  
+
+	//: *= operator (scalar multiplication).
+	void operator *= (float s);  
+
+	//: + operator.
+	CL_Vector operator + (const CL_Vector&amp; v) const;
+	
+	//: - operator.
+	CL_Vector operator - (const CL_Vector&amp; v) const;
+	
+	//: unary - operator.
+	CL_Vector operator - () const;
+
+	//: assignment operator.
+	CL_Vector&amp; operator = (const CL_Vector&amp; v);
+
+	//: Returns true if current vector equals v.
+	//param v: other vector.
+	//return: true if v equals the current vector, false otherwise.
+	bool operator == (const CL_Vector&amp; v) const;
+    	
+	//: Returns false if current vector equals v.
+	//param v: other vector.
+	//return: false if v equals the current vector, true otherwise.
+	bool operator != (const CL_Vector&amp; v) const;
+	
+	//: Returns reference to n-th ordinate (0. == x, 1. == y, ...).
+	//param n: number of ordinate (starting with 0).
+	//return: reference to the n-th ordinate.
+	float&amp; operator [] (int n);
+	
+	//: cout's the x,y,z ordinates (meant for debugging).
+	friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp;, const CL_Vector&amp; v);
+};
+
+std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, const CL_Vector&amp; v);
+
+#endif

Added: trunk/clanlib/API/Core/Math/delauney_triangulator.h
===================================================================
--- trunk/clanlib/API/Core/Math/delauney_triangulator.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/Math/delauney_triangulator.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,118 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;Math&quot;
+//! header=core.h
+
+#ifndef header_delauney_triangulator
+#define header_delauney_triangulator
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../System/sharedptr.h&quot;
+
+//: Vertex in the delauney triangulation.
+class CL_API_CORE CL_DelauneyTriangulator_Vertex
+{
+//! Attributes:
+public:
+	//: Data pointer given when adding the vertex.
+	void *data;
+
+	//: X position of vertex.
+	double x;
+	
+	//: Y position of vertex.
+	double y;
+};
+
+//: Triangle generated from a delauney triangulation.
+class CL_DelauneyTriangulator_Triangle
+{
+//! Attributes:
+public:
+	//: First point in the triangle.
+	CL_DelauneyTriangulator_Vertex *vertex_A;
+
+	//: Second point in the triangle.
+	CL_DelauneyTriangulator_Vertex *vertex_B;
+
+	//: Third point in the triangle.
+	CL_DelauneyTriangulator_Vertex *vertex_C;
+};
+
+class CL_DelauneyTriangulator_Generic;
+
+//: Delauney triangulator.
+//- &lt;p&gt;This class uses the &lt;a href=&quot;<A HREF="http://astronomy.swin.edu.au/~pbourke/terrain/triangulate/">http://astronomy.swin.edu.au/~pbourke/terrain/triangulate/</A>&quot;&gt;
+//- delauney triangulation algorithm&lt;/a&gt; to produce
+//- triangles between a list of points.&lt;/p&gt;
+class CL_DelauneyTriangulator
+{
+//! Construction:
+public:
+	//: Creates a triangulator object.
+	CL_DelauneyTriangulator();
+
+	virtual ~CL_DelauneyTriangulator();
+
+//! Attributes:
+public:
+	//: Returns the list of vertices in the triangulation.
+	const std::vector&lt;CL_DelauneyTriangulator_Vertex&gt; &amp;get_vertices() const;
+
+	//: Returns the resulting triangles produced from triangulation.
+	const std::vector&lt;CL_DelauneyTriangulator_Triangle&gt; &amp;get_triangles() const;
+
+//! Operations:
+public:
+	//: This function specifies a point to be used in the triangulation.
+	void add_vertex(double x, double y, void *data);
+
+	//: Converts passed points into triangles.
+	void generate();
+
+//! Implementation:
+private:
+	CL_SharedPtr&lt;CL_DelauneyTriangulator_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/Core/Math/line_math.h
===================================================================
--- trunk/clanlib/API/Core/Math/line_math.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/Math/line_math.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,112 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;Math&quot;
+//! header=core.h
+
+#ifndef header_line_math
+#define header_line_math
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#include &quot;point.h&quot;
+
+//: Math operations on 2D lines.
+//- !group=Core/Math!
+//- !header=core.h!
+class CL_API_CORE CL_LineMath
+{
+ public:
+// Operations:
+	//: Return the distance from a point to a line.
+	//param float x: X coordinate of point.
+	//param float y: Y coordinate of point.
+	//param CL_Pointf point: The point.
+	//param float *line: Pointer to float array with elements {x1,y1,x2,y2}.
+	static float distance_to_line(const CL_Pointf &amp;point, float *line);
+	static float distance_to_line(float x, float y, float *line);
+
+	//: Return true if two line segments intersect.
+	//param float *lineA: First line. Pointer to float array with elements {x1,y1,x2,y2}.
+	//param float *lineB: Second line. Pointer to float array with elements {x1,y1,x2,y2}.
+	//param bool collinear_intersect: set if a collision is reported when all points are on the same line.
+	static bool intersects( float *lineA, float *lineB, bool collinear_intersect=false );
+
+	//: Return true if two line segments are collinear. (All points are on the same line.)
+	//param float *lineA: First line. Pointer to float array with elements {x1,y1,x2,y2}.
+	//param float *lineB: Second line. Pointer to float array with elements {x1,y1,x2,y2}.
+	static bool collinear( float *lineA, float *lineB );
+
+	//: Return the intersection point of two lines.
+	//param float *lineA: First line. Pointer to float array with elements {x1,y1,x2,y2}.
+	//param float *lineB: Second line. Pointer to float array with elements {x1,y1,x2,y2}.
+	static CL_Pointf get_intersection( float *lineA, float *lineB );	
+
+	//: Return [&lt;0, 0, &gt;0] if the Point P is right, on or left of the line trough A,B
+	//param float x: x coordinate of the point being tested.
+	//param float y: y coordinate of the point being tested.
+	//param float *line: The line. A pointer to a float array with the elements {x1,y1,x2,y2}.
+	//param float line_x1, line_y1: First point defining the line.
+	//param float line_x2, line_y2: Second point defining the line.
+	//param CL_Pointf P: Test point.
+	//param CL_Pointf A: First point defining the line.
+	//param CL_Pointf B: Second point defining the line.
+	static float point_right_of_line( float x, float y, float *line );
+
+	static float point_right_of_line( float x, float y, float line_x1, float line_y1, float line_x2, float line_y2 );
+
+	static float point_right_of_line( const CL_Pointf &amp;A, const CL_Pointf &amp;B, const CL_Pointf &amp;P );
+
+	//: Return the midpoint of the line from point A to point B.
+	//param CL_Pointf A: point A
+	//param CL_Pointf B: point B
+	static CL_Pointf midpoint( const CL_Pointf &amp;A, const CL_Pointf &amp;B );
+
+	//: Return the normal vector of the line from point A to point B.
+	//param CL_Pointf A: point A
+	//param CL_Pointf B: point B
+	//param float *line: pointer to line vertices {x1, y1, x2, y2}
+	static CL_Pointf normal( const CL_Pointf &amp;A, const CL_Pointf &amp;B );
+
+	static CL_Pointf normal( float x1, float y1, float x2, float y2 );
+
+	static CL_Pointf normal( float *line );
+
+	
+};
+
+#endif

Added: trunk/clanlib/API/Core/Math/math.h
===================================================================
--- trunk/clanlib/API/Core/Math/math.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/Math/math.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,47 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_math
+#define header_math
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;cmath&gt;
+#include &lt;math.h&gt;
+
+#ifndef PI
+#ifndef M_PI
+#define M_PI 3.1415926535897932384626433832795	// maybe more accuracy than needed ;-)
+#endif
+#define PI M_PI
+#endif
+
+#endif

Added: trunk/clanlib/API/Core/Math/matrix4x4.h
===================================================================
--- trunk/clanlib/API/Core/Math/matrix4x4.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/Math/matrix4x4.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,115 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;Math&quot;
+//! header=core.h
+
+#ifndef header_matrix4x4
+#define header_matrix4x4
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+//: 4x4 Matrix.
+class CL_API_CORE CL_Matrix4x4
+{
+//! Construction:
+public:
+	//: Constructs a 4x4 matrix.
+	//param identity: When true, initial matrix will be the identity matrix. If false, initial will be null matrix.
+	//param matrix[16]: Initial matrix.
+	CL_Matrix4x4(bool identity = false);
+
+	CL_Matrix4x4(const CL_Matrix4x4 &amp;copy);
+
+	CL_Matrix4x4(double *matrix);
+
+	CL_Matrix4x4(float *matrix);
+
+//! Attributes:
+public:
+	double matrix[16];
+
+	//: Operator that returns the matrix as a double[16] array.
+	operator double const*() const { return matrix; }
+
+	//: Operator that returns the matrix as a double[16] array.
+	operator double *() { return matrix; }
+
+	//: Operator that returns the matrix cell at the given index.
+	double &amp;operator[](int i) { return matrix[i]; }
+
+	//: Operator that returns the matrix cell at the given index.
+	const double &amp;operator[](int i) const { return matrix[i]; }
+
+	//: Operator that returns the matrix cell at the given index.
+	double &amp;operator[](unsigned int i) { return matrix[i]; }
+
+	//: Operator that returns the matrix cell at the given index.
+	const double &amp;operator[](unsigned int i) const { return matrix[i]; }
+
+	//: Returns the x coordinate for the point (0,0,0) multiplied with this matrix.
+	double get_origin_x() const;
+
+	//: Returns the y coordinate for the point (0,0,0) multiplied with this matrix.
+	double get_origin_y() const;
+
+	//: Returns the z coordinate for the point (0,0,0) multiplied with this matrix.
+	double get_origin_z() const;
+
+//! Operations:
+public:
+	//: Copy assignment operator.
+	CL_Matrix4x4 &amp;operator =(const CL_Matrix4x4 &amp;copy);
+
+	//: Equality operator.
+	bool operator==(const CL_Matrix4x4 &amp;other) const;
+
+	//: Not-equal operator.
+	bool operator!=(const CL_Matrix4x4 &amp;other) const;
+
+	//: Multiply two matrices.
+	CL_Matrix4x4 multiply(const CL_Matrix4x4 &amp;matrix) const;
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/API/Core/Math/number_pool.h
===================================================================
--- trunk/clanlib/API/Core/Math/number_pool.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/Math/number_pool.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,83 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;Math&quot;
+//! header=core.h
+
+#ifndef header_number_pool
+#define header_number_pool
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;climits&gt;
+#include &lt;set&gt;
+
+//: A number generator pool.
+//- !group=Core/Math!
+//- !header=core.h!
+//- &lt;p&gt;It generates unique numbers from a pool of ushort16.&lt;/p&gt;
+class CL_API_CORE CL_NumberPool
+{
+//! Construction:
+public:
+	//: Constructs a number pool.
+	CL_NumberPool();
+
+//! Operations:
+public:
+	//: Return a unique number.
+	unsigned short get_number();
+
+	//: Pass a number back in so as to beable to reuse the unique number.
+	//- &lt;p&gt;NOTE: numbers that were not given before or already returned back will be discarded.&lt;/p&gt;
+	void return_number(unsigned short number);
+
+//! Implementation:
+private:
+	//: A pool of available unique number.
+	std::set&lt;unsigned short&gt; available_numbers;
+
+	//: The initial number range.
+	unsigned short initial_number_range;
+
+};
+
+#endif

Added: trunk/clanlib/API/Core/Math/origin.h
===================================================================
--- trunk/clanlib/API/Core/Math/origin.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/Math/origin.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,75 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;Math&quot;
+//! header=core.h
+
+#ifndef header_origin
+#define header_origin
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;size.h&quot;
+#include &quot;point.h&quot;
+
+//: Alignment origins.
+//- !group=Core/Math!
+//- !header=core.h!
+enum CL_Origin
+{
+	origin_top_left,
+	origin_top_center,
+	origin_top_right,
+	origin_center_left,
+	origin_center,
+	origin_center_right,
+	origin_bottom_left,
+	origin_bottom_center,
+	origin_bottom_right
+};
+
+//: Returns the anchor point for the origin within the dimensions of the size structure.
+//- !group=Display/Display 2D!
+//- !header=display.h!
+CL_Point CL_API_CORE calc_origin(CL_Origin origin, const CL_Size &amp;size);
+CL_Pointf CL_API_CORE calc_origin(CL_Origin origin, const CL_Sizef &amp;size);
+
+#endif

Added: trunk/clanlib/API/Core/Math/outline_triangulator.h
===================================================================
--- trunk/clanlib/API/Core/Math/outline_triangulator.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/Math/outline_triangulator.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,87 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;Math&quot;
+//! header=core.h
+
+#ifndef header_outline_triangulator
+#define header_outline_triangulator
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../System/sharedptr.h&quot;
+
+class CL_OutlineTriangulator_Generic;
+
+//: Polygon Tesselator.
+//- &lt;p&gt;This class uses constrained delauney triangulation to convert polygon outlines into triangles.&lt;/p&gt;
+class CL_API_CORE CL_OutlineTriangulator
+{
+//! Construction:
+public:
+	//: Creates a tessellation object.
+	CL_OutlineTriangulator();
+
+	virtual ~CL_OutlineTriangulator();
+
+//! Attributes:
+public:
+
+//! Operations:
+public:
+	//: This function specifies a vertex on a polygon.
+	void add_vertex(double x, double y, void *data);
+
+	//: Mark next contour in polygon path.
+	void next_contour();
+
+	//: Mark next polygon.
+	void next_polygon();
+
+	//: Converts passed polygons into triangles.
+	void generate();
+
+//! Implementation:
+private:
+	CL_SharedPtr&lt;CL_OutlineTriangulator_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/Core/Math/point.h
===================================================================
--- trunk/clanlib/API/Core/Math/point.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/Math/point.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,245 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;Math&quot;
+//! header=core.h
+
+#ifndef header_point
+#define header_point
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;math.h&quot;
+
+class CL_Pointf;
+
+//: 2D (x,y) point structure.
+//- !group=Core/Math!
+//- !header=core.h!
+class CL_Point
+{
+// Construction:
+public:
+	//: Constructs a point.
+	//param x: Initial x value.
+	//param y: Initial y value.
+	//param p: Point to use for initial values.
+	CL_Point()
+	{ return; }
+
+	CL_Point(int x, int y)
+	: x(x), y(y) { }
+
+	CL_Point(const CL_Point &amp;p)
+	{ x = p.x; y = p.y; }
+
+	explicit CL_Point(const CL_Pointf&amp; p);
+
+// Operations:
+public:
+	//: Return a rotated version of this point.
+	//param hotspot: The point around which to rotate.
+	//param angle: The amount of degrees to rotate by, clockwise.
+	CL_Point rotate(
+		const CL_Point &amp;hotspot,
+		float angle) const
+	{
+		//Move the hotspot to 0,0
+		CL_Point r(x - hotspot.x, y - hotspot.y);
+		
+		//Do some Grumbel voodoo.
+
+		// Because MSVC sucks ass wrt standards compliance, it gets it own special function calls
+		#ifdef _MSC_VER
+		const float c = (float) sqrt((float)r.x*(float)r.x + (float)r.y*(float)r.y);
+		const float nw = (float)(atan2((float)r.y, (float)r.x) + ((angle + 180) * M_PI / 180));
+		r.x = (int)((sin(1.5 * M_PI - nw) * c) + 0.5) + hotspot.x;
+		r.y = -(int)((sin(nw) * c) + 0.5) + hotspot.y;
+		#else
+		const float c = (float) std::sqrt((float)r.x*(float)r.x + (float)r.y*(float)r.y);
+		const float nw = (float)(std::atan2((float)r.y, (float)r.x) + ((angle + 180) * M_PI / 180));
+ 		r.x = (int)((std::sin(1.5 * M_PI - nw) * c) + 0.5) + hotspot.x;
+		r.y = -(int)((std::sin(nw) * c) + 0.5) + hotspot.y;
+		#endif
+
+		return r;
+	}
+
+	//: Return the distance to another point.
+	//param CL_Point &amp;p: The other point.
+	int distance( const CL_Point &amp;p ) const
+	{
+		#ifdef _MSC_VER
+    	return int(sqrt(double((x-p.x)*(x-p.x) + (y-p.y)*(y-p.y))) + 0.5f);
+		#else
+    	return int(std::sqrt(double((x-p.x)*(x-p.x) + (y-p.y)*(y-p.y))) + 0.5f);
+		#endif
+	}
+	
+	//: Translate point.
+	CL_Point &amp;operator+=(const CL_Point &amp;p)
+	{ x += p.x; y += p.y; return *this; }
+
+	//: Translate point negatively.
+	CL_Point &amp;operator-=(const CL_Point &amp;p)
+	{ x -= p.x; y -= p.y; return *this; }
+	
+	//: Point + Point operator.
+	CL_Point operator+(const CL_Point &amp;p) const
+	{ return CL_Point(x + p.x, y + p.y); }
+
+	//: Point - Point operator.
+	CL_Point operator-(const CL_Point &amp;p) const
+	{ return CL_Point(x - p.x, y - p.y); }
+
+	//: Point == Point operator (deep compare)
+	bool operator==(const CL_Point &amp;p) const
+	{ return (x == p.x) &amp;&amp; (y == p.y); }
+
+	//: Point != Point operator (deep compare)
+	bool operator!=(const CL_Point &amp;p) const
+	{ return (x != p.x) || (y != p.y); }
+
+// Attributes:
+public:
+	//: X coordinate.
+	int x;
+
+	//: Y coordinate.
+	int y;
+};
+
+//: 2D (x,y) floating point point structure.
+class CL_Pointf
+{
+// Construction:
+public:
+	//: Constructs a point.
+	//param x: Initial x value.
+	//param y: Initial y value.
+	//param p: Point to use for initial values.
+	CL_Pointf()
+	{ return; }
+	
+	CL_Pointf(const CL_Point&amp; p) 
+		: x((float)p.x), y((float)p.y)
+	{}
+
+	CL_Pointf(float x, float y)
+	: x(x), y(y) { }
+	
+	CL_Pointf(const CL_Pointf &amp;p)
+	{ x = p.x; y = p.y; }
+	
+// Operations:
+public:
+	//: Return a rotated version of this point.
+	//param hotspot: The point around which to rotate.
+	//param angle: The amount of degrees to rotate by, clockwise.
+	CL_Pointf rotate(
+		const CL_Pointf &amp;hotspot,
+		float angle) const
+	{
+		//Move the hotspot to 0,0
+		CL_Pointf r(x - hotspot.x, y - hotspot.y);
+		
+		//Do some Grumbel voodoo.
+		// MSVC is doesn't recognize std::sin and friends
+		#ifdef _MSC_VER
+		const float c = (float)(sqrt(r.x*r.x + r.y*r.y));
+
+		const float nw = (float)((float)atan2(r.y, r.x) + ((angle + 180) * M_PI / 180));
+
+		r.x = ((float)(sin(1.5 * M_PI - nw)) * c) + hotspot.x;
+		r.y = -((float)(sin(nw)) * c) + hotspot.y;
+		#else
+ 		const float c = (float)(std::sqrt(r.x*r.x + r.y*r.y));
+
+		const float nw = (float)((float)std::atan2(r.y, r.x) + ((angle + 180) * M_PI / 180));
+
+		r.x = ((float)(std::sin(1.5 * M_PI - nw)) * c) + hotspot.x;
+		r.y = -((float)(std::sin(nw)) * c) + hotspot.y;
+		#endif
+		
+		return r;
+	}
+
+	//: Return the distance to another point.
+	//param CL_Pointf &amp;p: The other point.
+	float distance( const CL_Pointf &amp;p ) const
+	{
+		#ifdef _MSC_VER
+    	return (float) sqrt((x-p.x)*(x-p.x) + (y-p.y)*(y-p.y));
+		#else
+    	return std::sqrt((x-p.x)*(x-p.x) + (y-p.y)*(y-p.y));
+		#endif
+	}
+
+	//: Translate point.
+	CL_Pointf &amp;operator+=(const CL_Pointf &amp;p)
+	{ x += p.x; y += p.y; return *this; }
+	
+	//: Translate point negatively.
+	CL_Pointf &amp;operator-=(const CL_Pointf &amp;p)
+	{ x -= p.x; y -= p.y; return *this; }
+	
+	//: Point + Point operator.
+	CL_Pointf operator+(const CL_Pointf &amp;p) const
+	{ return CL_Pointf(x + p.x, y + p.y); }
+
+	//: Point - Point operator.
+	CL_Pointf operator-(const CL_Pointf &amp;p) const
+	{ return CL_Pointf(x - p.x, y - p.y); }
+
+	//: Point == Point operator (deep compare)
+	bool operator==(const CL_Pointf &amp;p) const
+	{ return (x == p.x) &amp;&amp; (y == p.y); }
+
+	//: Point != Point operator (deep compare)
+	bool operator!=(const CL_Pointf &amp;p) const
+	{ return (x != p.x) || (y != p.y); }
+
+// Attributes:
+public:
+	//: X coordinate.
+	float x;
+	
+	//: Y coordinate.
+	float y;
+};
+
+
+inline CL_Point::CL_Point(const CL_Pointf&amp; p)
+  : x(static_cast&lt;int&gt;(p.x)),
+    y(static_cast&lt;int&gt;(p.y))
+{}
+
+#endif

Added: trunk/clanlib/API/Core/Math/pointset_math.h
===================================================================
--- trunk/clanlib/API/Core/Math/pointset_math.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/Math/pointset_math.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,98 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Emanuel Griesen
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;Math&quot;
+//! header=core.h
+
+#ifndef header_pointset_math
+#define header_pointset_math
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#include &lt;vector&gt;
+#include &quot;point.h&quot;
+#include &quot;circle.h&quot;
+
+//: Math operations related to point sets.
+//- !group=Core/Math!
+//- !header=core.h!
+class CL_API_CORE CL_PointSetMath
+{
+	public:
+//! Operations:
+ public:
+	//: Find minimum spanning circle for the set of points
+	//param std::vector&lt;CL_Pointf&gt; &amp;points: the points to calulate on
+	static CL_Circlef minimum_enclosing_disc(
+		const std::vector&lt;CL_Pointf&gt; &amp;points);
+
+	//: Return the convex hull of the given set of points
+	//param std::vector&lt;CL_Pointf&gt; P: the set of points
+	static std::vector&lt;CL_Pointf&gt; convex_hull_from_polygon(std::vector&lt;CL_Pointf&gt; &amp;points);
+
+ private:
+
+	static void calculate_minimum_enclosing_disc(
+		CL_Circlef &amp;smalldisc,
+		const std::vector&lt;CL_Pointf&gt; &amp;points,
+		int start,
+		int end);
+
+	static void minimum_disc_with_1point(
+		CL_Circlef &amp;smalldisc,
+		const std::vector&lt;CL_Pointf&gt; &amp;points,
+		int start,
+		unsigned int i);
+
+	static void minimum_disc_with_2points(
+		CL_Circlef &amp;smalldisc,
+		const std::vector&lt;CL_Pointf&gt; &amp;points,
+		int start,
+		unsigned int i,
+		unsigned int j);
+
+	static void minimum_disc_with_3points(
+		CL_Circlef &amp;smalldisc,
+		const std::vector&lt;CL_Pointf&gt; &amp;points,
+		unsigned int i,
+		unsigned int j,
+		unsigned int k);
+
+	friend class CL_OutlineMath;
+};
+
+#endif

Added: trunk/clanlib/API/Core/Math/quad.h
===================================================================
--- trunk/clanlib/API/Core/Math/quad.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/Math/quad.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,227 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;Math&quot;
+//! header=core.h
+
+#ifndef header_quad
+#define header_quad
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;rect.h&quot;
+#include &quot;size.h&quot;
+#include &quot;point.h&quot;
+#include &quot;origin.h&quot;
+
+//: 2D (x1, y1, x2, y2, x3, y3, x4, y4) quad structure.
+//- !group=Core/Math!
+//- !header=core.h!
+class CL_API_CORE CL_Quad
+{
+//! Construction:
+public:
+	//: Constructs a quad.
+	//param x1: x-coord for first point of quad.
+	//param y1: y-coord for first point of quad.
+	//param x2: x-coord for second point of quad.
+	//param y2: y-coord for second of quad.
+	//param x3: x-coord for third point of quad.
+	//param y3: y-coord for third point of quad.
+	//param x4: x-coord for forth point of quad.
+	//param y4: y-coord for forth point of quad.
+	//param rect: Rectangle used to initialize the quad.
+	CL_Quad() { return; }
+
+	CL_Quad(int new_x1, int new_y1, int new_x2, int new_y2,
+		int new_x3, int new_y3, int new_x4, int new_y4)
+	{ x1 = new_x1; y1 = new_y1; x2 = new_x2; y2 = new_y2; 
+		x3 = new_x3; y3 = new_y3; x4 = new_x4; y4 = new_y4; 
+	}
+
+	CL_Quad(const CL_Rect &amp;rect)
+	{ x1 = rect.left; y1 = rect.top; x2 = rect.right; y2 = rect.top; 
+		x3 = rect.right; y3 = rect.bottom; x4 = rect.left; y4 = rect.bottom; 
+	}
+
+	CL_Quad(const CL_Quad &amp;q)
+	{ x1 = q.x1; y1 = q.y1; x2 = q.x2; y2 = q.y2; 
+		x3 = q.x3; y3 = q.y3; x4 = q.x4; y4 = q.y4; 
+	}
+
+	//: Quad += Quad operator.
+	CL_Quad &amp;operator+=(const CL_Quad &amp;q)
+	{ x1 += q.x1; y1 += q.y1; x2 += q.x2; y2 += q.y2; 
+		x3 += q.x3; y3 += q.y3; x4 += q.x4; y4 += q.y4; 
+		return *this;
+	}
+
+	//: Quad -= Quad operator.
+	CL_Quad &amp;operator-=(const CL_Quad &amp;q)
+	{ x1 -= q.x1; y1 -= q.y1; x2 -= q.x2; y2 -= q.y2; 
+		x3 -= q.x3; y3 -= q.y3; x4 -= q.x4; y4 -= q.y4; 
+		return *this;
+	}
+	
+	//: Quad += Point operator.
+	CL_Quad &amp;operator+=(const CL_Point &amp;p)
+	{ x1 += p.x; y1 += p.y; x2 += p.x; y2 += p.y; 
+		x3 += p.x; y3 += p.y; x4 += p.x; y4 += p.y; 
+		return *this;
+	}
+
+	//: Quad -= Point operator.
+	CL_Quad &amp;operator-=(const CL_Point &amp;p)
+	{ x1 -= p.x; y1 -= p.y; x2 -= p.x; y2 -= p.y; 
+		x3 -= p.x; y3 -= p.y; x4 -= p.x; y4 -= p.y; 
+		return *this;
+	}
+
+	//: Quad + Quad operator.
+	CL_Quad operator+(const CL_Quad &amp;q) const
+	{ return CL_Quad(x1 + q.x1, y1 + q.y1, x2 + q.x2, y2 + q.y2,
+		x3 + q.x3, y3 + q.y3, x4 + q.x4, y4 + q.y4); }
+
+	//: Quad - Quad operator.
+	CL_Quad operator-(const CL_Quad &amp;q) const
+	{ return CL_Quad(x1 - q.x1, y1 - q.y1, x2 - q.x2, y2 - q.y2,
+		x3 - q.x3, y3 - q.y3, x4 - q.x4, y4 - q.y4); }
+
+	//: Quad + Point operator.
+	CL_Quad operator+(const CL_Point &amp;p) const
+	{ return CL_Quad(x1 + p.x, y1 + p.y, x2 + p.x, y2 + p.y,
+		x3 + p.x, y3 + p.y, x4 + p.x, y4 + p.y); }
+
+	//: Quad - Point operator.
+	CL_Quad operator-(const CL_Point &amp;p) const
+	{ return CL_Quad(x1 - p.x, y1 - p.y, x2 - p.x, y2 - p.y,
+		x3 - p.x, y3 - p.y, x4 - p.x, y4 - p.y); }
+
+	//: Quad == Quad operator.
+	bool operator==(const CL_Quad &amp;q) const
+	{ return (x1 == q.x1 &amp;&amp; y1 == q.y1 &amp;&amp; x2 == q.x2 &amp;&amp; y2 == q.y2 &amp;&amp;
+		x3 == q.x3 &amp;&amp; y3 == q.y3 &amp;&amp; x4 == q.x4 &amp;&amp; y4 == q.y4); }
+
+	//: Quad != Quad operator.
+	bool operator!=(const CL_Quad &amp;q) const
+	{ return (x1 != q.x1 || y1 != q.y1 || x2 != q.x2 || y2 != q.y2 ||
+		x3 != q.x3 || y3 != q.y3 || x4 != q.x4 || y4 != q.y4); }
+
+//! Attributes:
+public:
+	//: X1-coordinate.
+	int x1;
+	
+	//: Y1-coordinate.
+	int y1;
+	
+	//: X2-coordinate.
+	int x2;
+	
+	//: Y2-coordinate.
+	int y2;
+	
+	//: X3-coordinate.
+	int x3;
+	
+	//: Y3-coordinate.
+	int y3;
+	
+	//: X4-coordinate.
+	int x4;
+	
+	//: Y4-coordinate.
+	int y4;
+	
+	//: Returns the width of the quad.
+	int get_width() const;
+	
+	//: Returns the height of the quad.
+	int get_height() const;
+
+	//: Returns the size of the rectangle.
+	CL_Size get_size() const { return CL_Size(get_width(), get_height()); }
+	
+	//: Returns the bounding box of the quad as a CL_Rect
+	//param hotspot: Point to rotate around.
+	//param origin: Determines the hotspot point within the rectangle
+	//param x, y: Offsets applied negatively to the hotspot point
+	//param angle: Angle to rotate in degrees.
+	CL_Rect get_bounds() const;
+	
+//! Operations:
+public:
+	//: Rotates the Quad
+	//param hotspot: Point to rotate around.
+	//param angle: Angle to rotate in degrees.
+	void rotate(const CL_Point &amp;hotspot, float angle);
+	
+	//: Scale the Quad
+	//param sx: Scale value in x-axis
+	//param sy: Scale value in y-axis
+	//param hotspot: Point to scale around.
+	void scale(float sx, float sy);
+	void scale(const CL_Point &amp;hotspot, float sx, float sy);
+	
+	//: Returns the center point of the quad
+	CL_Point center() const;
+	
+	//: Applies an origin and offset pair to this rectangle
+	//param origin: The new origin to adjust to from default upper-left position
+	//param x, y: Offsets applied negatively to each corner of the rectangle
+	void apply_alignment(CL_Origin origin, int x, int y)
+	{
+		CL_Point offset = calc_origin(origin, get_size());
+		offset.x -= x;
+		offset.y -= y;
+		
+		x1 += offset.x;
+		y1 += offset.y;
+		x2 += offset.x;
+		y2 += offset.y;
+		x3 += offset.x;
+		y3 += offset.y;
+		x4 += offset.x;
+		y4 += offset.y;
+	}
+};
+
+#endif

Added: trunk/clanlib/API/Core/Math/rect.h
===================================================================
--- trunk/clanlib/API/Core/Math/rect.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/Math/rect.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,390 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;Math&quot;
+//! header=core.h
+
+#ifndef header_rect
+#define header_rect
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;size.h&quot;
+#include &quot;point.h&quot;
+#include &quot;origin.h&quot;
+
+class CL_Rectf;
+
+//: 2D (left,top,right,bottom) rectangle structure.
+//- !group=Core/Math!
+//- !header=core.h!
+class CL_API_CORE CL_Rect
+{
+//! Construction:
+public:
+	//: Constructs an rectangle.
+	//param left: Initial left position of rectangle.
+	//param top: Initial top position of rectangle.
+	//param right: Initial right position of rectangle.
+	//param bottom: Initial bottom position of rectangle.
+	//param point: Initial top-left position of rectangle.
+	//param size: Initial size of rectangle.
+	//param rect: Initial rectangle position and size.
+	CL_Rect() { left = right = top = bottom = 0; }
+
+	explicit CL_Rect(const CL_Rectf&amp; rect);
+
+	CL_Rect(int new_left, int new_top, int new_right, int new_bottom)
+	{ left = new_left; top = new_top; right = new_right; bottom = new_bottom; }
+
+	CL_Rect(const CL_Point &amp;p, const CL_Size &amp;size)
+	{ left = p.x; top = p.y; right = left + size.width; bottom = top + size.height; }
+
+	CL_Rect(const CL_Rect &amp;rect)
+	{ left = rect.left; top = rect.top; right = rect.right; bottom = rect.bottom; }
+
+	//: Rect += Rect operator.
+	CL_Rect &amp;operator+=(const CL_Rect &amp;r)
+	{ left += r.left; top += r.top; right += r.right; bottom += r.bottom; return *this; }
+
+	//: Rect -= Rect operator.
+	CL_Rect &amp;operator-=(const CL_Rect &amp;r)
+	{ left -= r.left; top -= r.top; right -= r.right; bottom -= r.bottom; return *this; }
+	
+	//: Rect += Point operator.
+	CL_Rect &amp;operator+=(const CL_Point &amp;p)
+	{ left += p.x; top += p.y; right += p.x; bottom += p.y; return *this; }
+
+	//: Rect -= Point operator.
+	CL_Rect &amp;operator-=(const CL_Point &amp;p)
+	{ left -= p.x; top -= p.y; right -= p.x; bottom -= p.y; return *this; }
+
+	//: Rect + Rect operator.
+	CL_Rect operator+(const CL_Rect &amp;r) const
+	{ return CL_Rect(left + r.left, top + r.top, right + r.right, bottom + r.bottom); }
+
+	//: Rect - Rect operator.
+	CL_Rect operator-(const CL_Rect &amp;r) const
+	{ return CL_Rect(left - r.left, top - r.top, right - r.right, bottom - r.bottom); }
+
+	//: Rect + Point operator.
+	CL_Rect operator+(const CL_Point &amp;p) const
+	{ return CL_Rect(left + p.x, top + p.y, right + p.x, bottom + p.y); }
+
+	//: Rect - Point operator.
+	CL_Rect operator-(const CL_Point &amp;p) const
+	{ return CL_Rect(left - p.x, top - p.y, right - p.x, bottom - p.y); }
+
+	//: Rect == Rect operator.
+	bool operator==(const CL_Rect &amp;r) const
+	{ return (left == r.left &amp;&amp; top == r.top &amp;&amp; right == r.right &amp;&amp; bottom == r.bottom); }
+
+	//: Rect != Rect operator.
+	bool operator!=(const CL_Rect &amp;r) const
+	{ return (left != r.left || top != r.top || right != r.right || bottom != r.bottom); }
+
+//! Attributes:
+public:
+	//: X1-coordinate.
+	int left;
+	
+	//: Y1-coordinate.
+	int top;
+	
+	//: X2-coordinate.
+	int right;
+	
+	//: Y2-coordinate.
+	int bottom;
+	
+	//: Returns the width of the rectangle.
+	int get_width() const { return right - left; }
+	
+	//: Returns the height of the rectangle.
+	int get_height() const { return bottom - top; }
+
+	//: Returns the size of the rectangle.
+	CL_Size get_size() const { return CL_Size(right - left, bottom - top); }
+	
+	//: Returns true if point is inside the rectangle.
+	bool is_inside(const CL_Point &amp;p) const { return (p.x &gt;= left &amp;&amp; p.y &gt;= top &amp;&amp; p.x &lt;= right &amp;&amp; p.y &lt;= bottom); }
+
+	//: Returns true if rectangle passed is overlapping or inside this rectangle.
+	bool is_overlapped(const CL_Rect &amp;r) const 
+	{
+		return (r.left &lt; right &amp;&amp; r.right &gt; left &amp;&amp; r.top &lt; bottom &amp;&amp; r.bottom &gt; top);
+	}
+	
+	//: Returns another CL_Rect containing a rotated version of this one.
+	//param hotspot: Point to rotate around.
+	//param origin: Determines the hotspot point within the rectangle
+	//param x, y: Offsets applied negatively to the hotspot point
+	//param angle: Angle to rotate in degrees.
+	CL_Rect get_rot_bounds(const CL_Point &amp;hotspot, float angle) const;
+	CL_Rect get_rot_bounds(CL_Origin origin, int x, int y, float angle) const;
+	
+//! Operations:
+public:
+	//: Sets the size of the rectangle, maintaining top/left position.
+	void set_size(const CL_Size &amp;size)
+	{
+		right = left + size.width;
+		bottom = top + size.height;
+	}
+
+	//: Calculates and returns the union of two rectangles.
+	CL_Rect calc_union(const CL_Rect &amp;rect)
+	{
+		CL_Rect result;
+		if (left   &gt; rect.left)   result.left   = left;   else result.left   = rect.left;
+		if (right  &lt; rect.right)  result.right  = right;  else result.right  = rect.right;
+		if (top    &gt; rect.top)    result.top    = top;    else result.top    = rect.top;
+		if (bottom &lt; rect.bottom) result.bottom = bottom; else result.bottom = rect.bottom;
+		return result;
+	}
+
+	//: Normalize rectangle. Ensures that left is less than right and top is less than bottom.
+	void normalize()
+	{
+		if (left &gt; right)
+		{
+			int temp = right;
+			right = left;
+			left = temp;
+		}
+
+		if (top &gt; bottom)
+		{
+			int temp = bottom;
+			bottom = top;
+			top = temp;
+		}
+	}
+	
+	//: Applies an origin and offset pair to this rectangle
+	//param origin: The new origin to adjust to from default upper-left position
+	//param x, y: Offsets applied negatively to each corner of the rectangle
+	void apply_alignment(CL_Origin origin, int x, int y)
+	{
+		CL_Point offset = calc_origin(origin, get_size());
+		offset.x -= x;
+		offset.y -= y;
+		
+		left += offset.x;
+		top += offset.y;
+		right += offset.x;
+		bottom += offset.y;
+	}
+};
+
+//: 2D (left,top,right,bottom) floating point rectangle structure.
+class CL_Rectf
+{
+//! Construction:
+public:
+	//: Constructs an rectangle.
+	//param left: Initial left position of rectangle.
+	//param top: Initial top position of rectangle.
+	//param right: Initial right position of rectangle.
+	//param bottom: Initial bottom position of rectangle.
+	//param point: Initial top-left position of rectangle.
+	//param size: Initial size of rectangle.
+	//param rect: Initial rectangle position and size.
+	CL_Rectf() { left = right = top = bottom = 0.0f; }
+
+	CL_Rectf(const CL_Rect&amp; rect)
+		: left((float)rect.left), 
+		  top((float)rect.top), 
+		  right((float)rect.right), 
+		  bottom((float)rect.bottom)
+	{}
+
+	CL_Rectf(float new_left, float new_top, float new_right, float new_bottom)
+	{ left = new_left; top = new_top; right = new_right; bottom = new_bottom; }
+
+	CL_Rectf(const CL_Pointf &amp;p, const CL_Sizef &amp;size)
+	{ left = p.x; top = p.y; right = left + size.width; bottom = top + size.height; }
+
+	CL_Rectf(const CL_Rectf &amp;rect)
+	{ left = rect.left; top = rect.top; right = rect.right; bottom = rect.bottom; }
+
+	//: Rect += Rect operator.
+	CL_Rectf &amp;operator+=(const CL_Rectf &amp;r)
+	{ left += r.left; top += r.top; right += r.right; bottom += r.bottom; return *this; }
+
+	//: Rect -= Rect operator.
+	CL_Rectf &amp;operator-=(const CL_Rectf &amp;r)
+	{ left -= r.left; top -= r.top; right -= r.right; bottom -= r.bottom; return *this; }
+	
+	//: Rect += Point operator.
+	CL_Rectf &amp;operator+=(const CL_Pointf &amp;p)
+	{ left += p.x; top += p.y; right += p.x; bottom += p.y; return *this; }
+
+	//: Rect -= Point operator.
+	CL_Rectf &amp;operator-=(const CL_Pointf &amp;p)
+	{ left -= p.x; top -= p.y; right -= p.x; bottom -= p.y; return *this; }
+
+	//: Rect + Rect operator.
+	CL_Rectf operator+(const CL_Rectf &amp;r) const
+	{ return CL_Rectf(left + r.left, top + r.top, right + r.right, bottom + r.bottom); }
+
+	//: Rect - Rect operator.
+	CL_Rectf operator-(const CL_Rectf &amp;r) const
+	{ return CL_Rectf(left - r.left, top - r.top, right - r.right, bottom - r.bottom); }
+
+	//: Rect + Point operator.
+	CL_Rectf operator+(const CL_Pointf &amp;p) const
+	{ return CL_Rectf(left + p.x, top + p.y, right + p.x, bottom + p.y); }
+
+	//: Rect - Point operator.
+	CL_Rectf operator-(const CL_Pointf &amp;p) const
+	{ return CL_Rectf(left - p.x, top - p.y, right - p.x, bottom - p.y); }
+
+	//: Rect == Rect operator.
+	bool operator==(const CL_Rectf &amp;r) const
+	{ return (left == r.left &amp;&amp; top == r.top &amp;&amp; right == r.right &amp;&amp; bottom == r.bottom); }
+
+	//: Rect != Rect operator.
+	bool operator!=(const CL_Rect &amp;r) const
+	{ return (left != r.left || top != r.top || right != r.right || bottom != r.bottom); }
+
+//! Attributes:
+public:
+	//: X1-coordinate.
+	float left;
+	
+	//: Y1-coordinate.
+	float top;
+	
+	//: X2-coordinate.
+	float right;
+	
+	//: Y2-coordinate.
+	float bottom;
+	
+	//: Returns the width of the rectangle.
+	float get_width() const { return right - left; }
+	
+	//: Returns the height of the rectangle.
+	float get_height() const { return bottom - top; }
+
+	//: Returns the size of the rectangle.
+	CL_Sizef get_size() const { return CL_Sizef(right - left, bottom - top); }
+	
+	//: Returns true if point is inside the rectangle.
+	bool is_inside(const CL_Pointf &amp;p) const { return (p.x &gt;= left &amp;&amp; p.y &gt;= top &amp;&amp; p.x &lt;= right &amp;&amp; p.y &lt;= bottom); }
+	
+	//: Returns true if rectangle passed is overlapping or inside this rectangle.
+	bool is_overlapped(const CL_Rectf &amp;r) const 
+	{
+		return (r.left &lt; right &amp;&amp; r.right &gt; left &amp;&amp; r.top &lt; bottom &amp;&amp; r.bottom &gt; top);
+	}
+
+	//: Returns another CL_Rectf containing a rotated version of this one.
+	//param hotspot: Point to rotate around.
+	//param origin: Determines the hotspot point within the rectangle
+	//param x, y: Offsets applied negatively to the hotspot point
+	//param angle: Angle to rotate in degrees.
+	CL_Rectf get_rot_bounds(const CL_Pointf &amp;hotspot, float angle) const;
+	CL_Rectf get_rot_bounds(CL_Origin origin, float x, float y, float angle) const;
+	
+//! Operations:
+public:
+	//: Sets the size of the rectangle, maintaining top/left position.
+	void set_size(const CL_Size &amp;size)
+	{
+		right = left + size.width;
+		bottom = top + size.height;
+	}
+
+	//: Calculates and returns the union of two rectangles.
+	CL_Rectf calc_union(const CL_Rectf &amp;rect)
+	{
+		CL_Rectf result;
+		if (left   &gt; rect.left)   result.left   = left;   else result.left   = rect.left;
+		if (right  &lt; rect.right)  result.right  = right;  else result.right  = rect.right;
+		if (top    &gt; rect.top)    result.top    = top;    else result.top    = rect.top;
+		if (bottom &lt; rect.bottom) result.bottom = bottom; else result.bottom = rect.bottom;
+		return result;
+	}
+
+	//: Normalize rectangle. Ensures that left&lt;right and top&lt;bottom.
+	void normalize()
+	{
+		if (left &gt; right)
+		{
+			float temp = right;
+			right = left;
+			left = temp;
+		}
+
+		if (top &gt; bottom)
+		{
+			float temp = bottom;
+			bottom = top;
+			top = temp;
+		}
+	}
+	
+	//: Applies an origin and offset pair to this rectangle
+	//param origin: The new origin to adjust to from default upper-left position
+	//param x, y: Offsets applied negatively to each corner of the rectangle
+	void apply_alignment(CL_Origin origin, float x, float y)
+	{
+		CL_Pointf offset = calc_origin(origin, get_size());
+		offset.x -= x;
+		offset.y -= y;
+		
+		left += offset.x;
+		top += offset.y;
+		right += offset.x;
+		bottom += offset.y;
+	}
+};
+
+inline CL_Rect::CL_Rect(const CL_Rectf&amp; rect)
+	: left(static_cast&lt;int&gt;(rect.left)), 
+	  top(static_cast&lt;int&gt;(rect.top)), 
+	  right(static_cast&lt;int&gt;(rect.right)), 
+	  bottom(static_cast&lt;int&gt;(rect.bottom))
+{}
+
+#endif

Added: trunk/clanlib/API/Core/Math/size.h
===================================================================
--- trunk/clanlib/API/Core/Math/size.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/Math/size.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,160 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;Math&quot;
+//! header=core.h
+
+#ifndef header_size
+#define header_size
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+class CL_Sizef;
+
+//: 2D (width,height) size structure.
+//- !group=Core/Math!
+//- !header=core.h!
+class CL_Size
+{
+//! Construction:
+public:
+	//: Constructs a size structure.
+	//param width: Initial width of size structure.
+	//param height: Initial height of size structure.
+	//param size: Size structure to construct this one from.
+	CL_Size() { return; }
+
+	CL_Size(int width, int height)
+	: width(width), height(height) { }
+
+	CL_Size(const CL_Size &amp;s)
+	{ width = s.width; height = s.height; }
+
+	explicit CL_Size(const CL_Sizef&amp; s);
+
+//! Attributes:
+public:
+	//: Size width.
+	int width;
+
+	//: Size height.
+	int height;
+
+//! Operations:
+public:
+	//: Size += Size operator.
+	CL_Size &amp;operator+=(const CL_Size &amp;s)
+	{ width += s.width; height += s.height; return *this; }
+
+	//: Size -= Size operator.
+	CL_Size &amp;operator-=(const CL_Size &amp;s)
+	{ width -= s.width; height -= s.height; return *this; }
+	
+	//: Size + Size operator.
+	CL_Size operator+(const CL_Size &amp;s) const
+	{ return CL_Size(width + s.width, height + s.height); }
+
+	//: Size - Size operator.
+	CL_Size operator-(const CL_Size &amp;s) const
+	{ return CL_Size(width - s.width, height - s.height); }
+
+	//: Size == Size operator (deep compare).
+	bool operator==(const CL_Size &amp;s) const
+	{ return (width == s.width) &amp;&amp; (height == s.height); }
+
+	//: Size != Size operator (deep compare).
+	bool operator!=(const CL_Size &amp;s) const
+	{ return (width != s.width) || (height != s.height); }
+};
+
+//: 2D (width,height) floating point size structure.
+class CL_Sizef
+{
+//! Construction:
+public:
+	//: Constructs a size structure.
+	//param width: Initial width of size structure.
+	//param height: Initial height of size structure.
+	//param size: Size structure to construct this one from.
+	CL_Sizef() { return; }
+
+	CL_Sizef(const CL_Size&amp; s) 
+		: width((float)s.width),
+		  height((float)s.height)
+	{}
+
+	CL_Sizef(float width, float height)
+	: width(width), height(height) { }
+
+	CL_Sizef(const CL_Sizef &amp;s)
+	{ width = s.width; height = s.height; }
+
+//! Attributes:
+public:
+	//: Size width.
+	float width;
+
+	//: Size height.
+	float height;
+
+//! Operations:
+public:
+	//: Size += Size operator.
+	CL_Sizef &amp;operator+=(const CL_Sizef &amp;s)
+	{ width += s.width; height += s.height; return *this; }
+
+	//: Size -= Size operator.
+	CL_Sizef &amp;operator-=(const CL_Sizef &amp;s)
+	{ width -= s.width; height -= s.height; return *this; }
+	
+	//: Size + Size operator.
+	CL_Sizef operator+(const CL_Sizef &amp;s) const
+	{ return CL_Sizef(width + s.width, height + s.height); }
+
+	//: Size - Size operator.
+	CL_Sizef operator-(const CL_Sizef &amp;s) const
+	{ return CL_Sizef(width - s.width, height - s.height); }
+
+	//: Size == Size operator (deep compare).
+	bool operator==(const CL_Sizef &amp;s) const
+	{ return (width == s.width) &amp;&amp; (height == s.height); }
+
+	//: Size != Size operator (deep compare).
+	bool operator!=(const CL_Size &amp;s) const
+	{ return (width != s.width) || (height != s.height); }
+};
+
+inline CL_Size::CL_Size(const CL_Sizef&amp; s)
+	: width(static_cast&lt;int&gt;(s.width)),
+	  height(static_cast&lt;int&gt;(s.height))
+{}
+
+#endif

Added: trunk/clanlib/API/Core/Math/triangle_math.h
===================================================================
--- trunk/clanlib/API/Core/Math/triangle_math.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/Math/triangle_math.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,65 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;Math&quot;
+//! header=core.h
+
+#ifndef header_triangle_math
+#define header_triangle_math
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#include &quot;point.h&quot;
+
+//: Math operations on triangles.
+//- !group=Core/Math!
+//- !header=core.h!
+class CL_API_CORE CL_TriangleMath
+{
+ public:
+// Operations:
+
+	//: Return true if the point is inside the triangle.
+	//param CL_Pointf P: point to test
+	//param float *vertices: Pointer to triangle vertices {x1,y1,x2,y2,x3,y3}.
+	//param bool on_edge_is_outside: are points exactly on a edge in or out.
+	static bool point_inside_triangle(const CL_Pointf &amp;P, float *vertices, bool on_edge_is_outside);
+	static bool point_inside_triangle(float px, float py, float *vertices, bool on_edge_is_outside);
+
+};
+
+#endif

Added: trunk/clanlib/API/Core/Math/vector2.h
===================================================================
--- trunk/clanlib/API/Core/Math/vector2.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/Math/vector2.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,207 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magic Software - www.magic-software.com
+*/
+
+//! clanCore=&quot;Math&quot;
+//! header=core.h
+
+#ifndef header_vector2d
+#define header_vector2d
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+//: A 2D Vector class
+//- !group=Core/Math!
+//- !header=core.h!
+//- CL_Vector2 provides a 2D vector class.
+//- This is different from {link CL_Vector CL_Vector.html}
+class CL_API_CORE CL_Vector2
+{
+public:
+//! Construction:
+	//: Default constructor
+	CL_Vector2();
+	
+	//: Constructor with info
+	//param fX: The X coordinate.
+	//param fY: The Y coordinate.
+	CL_Vector2(float fX, float fY);
+
+	//: FIXME!
+	CL_Vector2(float afCoordinate[2]);
+
+	//: Copy constructor
+	//param rkVector: Vector to copy
+	CL_Vector2(const CL_Vector2&amp; rkVector);
+
+//! Operators:
+	// access vector V as V[0] = V.x, V[1] = V.y
+	//
+	// WARNING.  These member functions rely on
+	// (1) CL_Vector2 not having virtual functions
+	// (2) the data packed in a 2*sizeof(float) memory block
+	
+	//: Accessor
+	//- &lt;p&gt;Use vector V[0] for V.x
+	//- Use vector V[1] for V.y&lt;/p&gt;
+	//return: The requested parameter
+	const float&amp; operator[] (int i) const;
+	float&amp; operator[] (int i);
+
+	//: Unknown
+	operator float* ();
+
+	//: assignment operator
+	CL_Vector2&amp; operator= (const CL_Vector2&amp; rkVector);
+
+// comparison (supports fuzzy arithmetic when FUZZ &gt; 0)
+
+	//: Equivalancy operator
+	//- &lt;p&gt;Supports fuzzy arimatic when FUZZ &gt; 0&lt;/p&gt;
+	bool operator== (const CL_Vector2&amp; rkVector) const;
+	
+	//: Not-equals operator
+	//- &lt;p&gt;Supports fuzzy arimatic when FUZZ &gt; 0&lt;/p&gt;
+	bool operator!= (const CL_Vector2&amp; rkVector) const;
+	
+	//: Less than operator
+	//- &lt;p&gt;Supports fuzzy arimatic when FUZZ &gt; 0&lt;/p&gt;
+	bool operator&lt;  (const CL_Vector2&amp; rkVector) const;
+	
+	//: Less than or equal operator
+	//- &lt;p&gt;Supports fuzzy arimatic when FUZZ &gt; 0&lt;/p&gt;
+	bool operator&lt;= (const CL_Vector2&amp; rkVector) const;
+	
+	//: Greater than operator
+	//- &lt;p&gt;Supports fuzzy arimatic when FUZZ &gt; 0&lt;/p&gt;
+	bool operator&gt;  (const CL_Vector2&amp; rkVector) const;
+	
+	//: Greater than or equal operator		
+	//- &lt;p&gt;Supports fuzzy arimatic when FUZZ &gt; 0&lt;/p&gt;
+	bool operator&gt;= (const CL_Vector2&amp; rkVector) const;
+
+// arithmetic operations
+
+	//: Addition operator
+	CL_Vector2 operator+ (const CL_Vector2&amp; rkVector) const;
+	
+	//: Subtraction operator
+	CL_Vector2 operator- (const CL_Vector2&amp; rkVector) const;
+	
+	//: Multiplication operator
+	CL_Vector2 operator* (float fScalar) const;
+	
+	//: Division operator
+	CL_Vector2 operator/ (float fScalar) const;
+	
+	//: Negation operator
+	//return: The negative of the Vector
+	CL_Vector2 operator- () const;
+
+//	MAGICFM friend CL_Vector2 operator* (float fScalar, const CL_Vector2&amp; rkVector);
+
+// arithmetic updates
+
+	//: Addition assignment operator
+	CL_Vector2&amp; operator+= (const CL_Vector2&amp; rkVector);
+	
+	//: Subtraction assignment operator
+	CL_Vector2&amp; operator-= (const CL_Vector2&amp; rkVector);
+	
+	//: Multiplication assignment operator
+	CL_Vector2&amp; operator*= (float fScalar);
+	
+	//: Division assignment operator
+	CL_Vector2&amp; operator/= (float fScalar);
+
+//! Attributes:
+
+	//: Enable Fuzzy arithmatic
+	void set_fuzz() { FUZZ = 1.0; }
+
+	//: Disable Fuzzy arithmatic
+	void disable_fuzz() { FUZZ = 0.0; }
+
+	//: Using fuzzy arimatic
+	//return: True if using fuzzy arithmatic
+	bool get_fuzz() { return (FUZZ &gt; 0.0)? true : false ;}
+
+// vector operations
+	//: The length of the vector
+	//return: sqrt(x^2+y^2)
+	float length() const;
+
+	//: The squared length of the vector
+	//return: x^2+y^2
+	float squared_length() const;
+
+	//: FIXME!!!
+	float dot(const CL_Vector2&amp; rkVector) const;
+
+	//: FIXME!!!
+	float unitize(float fTolerance = 1e-06f);
+
+	//: Cross
+	//- FIXME
+	//return: Return y,-x
+	CL_Vector2 cross() const;
+
+	//: Unit Cross
+	//return: (y,-x)/sqrt(x^2+y^2)
+	CL_Vector2 unit_cross() const;
+
+	// Gram-Schmidt orthonormalization.
+//	static void Orthonormalize (CL_Vector2 akVector[/*2*/]);
+
+//! Variables:
+	// coordinates
+	float x, y;
+
+	// special points
+	static const CL_Vector2 ZERO;
+	static const CL_Vector2 UNIT_X;
+	static const CL_Vector2 UNIT_Y;
+
+	// fuzzy arithmetic (set FUZZ &gt; 0 to enable)
+	static float FUZZ;
+};
+
+#include &quot;vector2.inl&quot;
+
+#endif

Added: trunk/clanlib/API/Core/Math/vector2.inl
===================================================================
--- trunk/clanlib/API/Core/Math/vector2.inl	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/Math/vector2.inl	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,53 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magic Software - www.magic-software.com
+*/
+
+inline CL_Vector2::CL_Vector2 ()
+{
+    // For efficiency in construction of large arrays of vectors, the
+    // default constructor does not initialize the vector.
+}
+
+inline const float&amp; CL_Vector2::operator[](int i) const
+{
+    return ((const float*)this)[i];
+}
+
+inline float&amp; CL_Vector2::operator[](int i)
+{
+    return ((float*)this)[i];
+}
+
+inline CL_Vector2::operator float*()
+{
+    return (float*)this;
+}
+
+inline float CL_Vector2::squared_length() const
+{
+    return x*x + y*y;
+}

Added: trunk/clanlib/API/Core/Resources/resource.h
===================================================================
--- trunk/clanlib/API/Core/Resources/resource.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/Resources/resource.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,125 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;Resources&quot;
+//! header=core.h
+
+#ifndef header_resource
+#define header_resource
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../System/sharedptr.h&quot;
+#include &quot;../../signals.h&quot;
+#include &lt;string&gt;
+
+class CL_ResourceManager;
+class CL_ResourceData;
+class CL_Resource_Generic;
+
+#include &quot;../XML/dom_element.h&quot;
+
+//: Interface for accessing a resource in the resource manager.
+//- !group=Core/Resources!
+//- !header=core.h!
+class CL_API_CORE CL_Resource
+{
+//! Construction:
+public:
+	//: Resource constructor.
+	CL_Resource(
+		CL_DomElement &amp;element,
+		CL_ResourceManager *manager);
+
+	CL_Resource(const CL_Resource &amp;copy);
+
+	CL_Resource();
+
+	//: Resource destructor.
+	virtual ~CL_Resource();
+
+//! Attributes:
+public:
+	//: Returns the type of the resource.
+	std::string get_type() const;
+
+	//: Returns the name of the resource.
+	std::string get_name() const;
+
+	//: Returns the resource DOM element.
+	CL_DomElement &amp;get_element();
+
+	//: Returns the resource manager.
+	CL_ResourceManager get_manager();
+
+	//: Returns the data with the matching name.
+	CL_ResourceData *get_data(const std::string &amp;name);
+
+	//: Returns the current reference count.
+	int get_reference_count() const;
+
+//! Operations:
+public:
+	//: Attach some data to the resource.
+	void attach_data(const std::string &amp;name, CL_ResourceData *data);
+
+	//: Detach some data from the resource.
+	void detach_data(CL_ResourceData *data);
+
+	//: Unloads the resource from memory.
+	void unload();
+
+	//: Loads the resource, using the prefered source as specified by
+	//: the resource manager.
+	void load();
+
+//! Implementation:
+private:
+	CL_Resource(const CL_SharedPtr&lt;CL_Resource_Generic&gt; &amp;impl);
+
+	//: Pointer to implementation
+	CL_SharedPtr&lt;CL_Resource_Generic&gt; impl;
+
+	friend class CL_ResourceData;
+	friend class CL_ResourceManager_Generic;
+};
+
+#endif

Added: trunk/clanlib/API/Core/Resources/resource_manager.h
===================================================================
--- trunk/clanlib/API/Core/Resources/resource_manager.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/Resources/resource_manager.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,181 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;Resources&quot;
+//! header=core.h
+
+#ifndef header_resource_manager
+#define header_resource_manager
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../System/sharedptr.h&quot;
+#include &quot;../../signals.h&quot;
+#include &lt;list&gt;
+#include &lt;string&gt;
+
+class CL_Resource;
+class CL_InputSourceProvider;
+class CL_ResourceManager_Generic;
+
+class CL_API_CORE CL_ResourceManager
+//: The ClanLib resource manager.
+//- !group=Core/Resources!
+//- !header=core.h!
+//- &lt;p&gt;The resource manager is used to retrieve resources from a given
+//- resource source.&lt;/p&gt;
+//-
+//- &lt;p&gt;This can either be a resource script file (used as input to the
+//- datafile compiler), or a datafile with all the resources included into
+//- one large gzipped resource file.&lt;/p&gt;
+//-
+//- &lt;p&gt;To speedup loading of resources in a game, you can load entire sections
+//- of resources at once. When a resource in the section is requested, it is
+//- returned instantly without having to access the disk. This is especially
+//- useful to make sure all the game resources are loaded before the game is
+//- started.&lt;/p&gt;
+//-
+//- &lt;p&gt;Resources are normally not retrieved using the get_resource() function.
+//- Instead, you should load the resource using the appropiate resource type
+//- class. For instance, a surface is easiest loaded like this:&lt;/p&gt;
+//-
+//- &lt;pre&gt;
+//- CL_ResourceManager res_manager(&quot;my_datafile.dat&quot;, true);
+//- CL_Surface my_surface(&quot;my_surface&quot;, &amp;res_manager);
+//- &lt;/pre&gt;
+//-
+//- &lt;p&gt;Getting the same resource twice won't create a new instance of the
+//- resource; they are reference counted.&lt;/p&gt;
+{
+//! Construction:
+public:
+	//: Resource Manager constructor.
+	//param config_file: The name of the file in which the resources are defined.
+	//param provider: The optional inputprovider in which, the resource file is stored.
+	//param delete_inputsource_provider: If true, deletes the provider when CL_ResourceManager is destroyed.
+	CL_ResourceManager(
+		const std::string &amp;config_file,
+		CL_InputSourceProvider *provider = 0,
+		bool delete_inputsource_provider = false);
+
+	CL_ResourceManager(const CL_ResourceManager &amp;copy);
+
+	CL_ResourceManager();
+
+	//: Resource Manager destructor.
+	~CL_ResourceManager();
+
+//! Attributes:
+public:
+	//: Returns true if a resource exists.
+	bool exists(const std::string &amp;res_id);
+	
+	//: Returns a pointer to the CL_Resource representing the given resource.
+	CL_Resource &amp;get_resource(const std::string &amp;res_id, bool resolve_alias = true, int reserved = 0);
+
+	//: Returns a list of all resources available.
+	//return: The list of resources available, in the form [section/subsection/.../]resourcename.
+	std::vector&lt;std::string&gt; get_all_resources();
+
+	//: Returns a list of all resources available matching a given section. 
+	//return: The list of resources available, in the form [section/subsection/.../]resourcename.
+	std::vector&lt;std::string&gt; get_all_resources(const std::string &amp;section_name);
+
+	//: Returns a list of all resource sections available.
+	//return: The list of resource sections available, in the form [section/subsection/.../].
+	std::vector&lt;std::string&gt; get_all_sections();
+
+	//: Returns a list of the resource sections immediately under the given secion.
+	//return: The list of sections immediately available under the given section.
+	std::vector&lt;std::string&gt; get_sections(const std::string &amp;section_name);
+	
+	//: Returns a list of all resources available matching a given type. 
+	//return: The list of resources available.
+	std::vector&lt;std::string&gt; get_resources_of_type(const std::string &amp;type_id);
+
+	//: Returns a list of all resources available matching a given type in a given section. 
+	//return: The list of resources available.
+	std::vector&lt;std::string&gt; get_resources_of_type(const std::string &amp;type_id, const std::string &amp;section_name);
+
+	//: Returns a pointer to the input source provider, in which all resources are stored.
+	//- &lt;p&gt;This can be a file provider or a datafile provider depending
+	//- on method used to load the script file.&lt;/p&gt;
+	//return: Pointer to inputsourceprovider containing resource data.
+	CL_InputSourceProvider *get_resource_provider() const;
+
+//! Signals:
+public:
+	//: Signal invoked when a resource is added during loading of a resource file.
+	static CL_Signal_v1&lt;CL_Resource &amp;&gt; &amp;sig_resource_added();
+
+//! Operations:
+public:
+	//: Returns true resource managers handles the same object.
+	bool operator == (const CL_ResourceManager &amp;other) const;
+
+	//: Add resources from an other resource manager.
+	void add_resources(const CL_ResourceManager &amp;additional_resources);
+
+	//: Remove resources from an other resource manager.
+	void remove_resources(const CL_ResourceManager &amp;additional_resources);
+
+	//: Loads all resources into memory.
+	void load_all();
+
+	//: Unloads all resources from memory.
+	void unload_all();
+
+	//: Loads all resources in a given section into memory.
+	void load_section(const std::string &amp;section_name);
+
+	//: Unloads all resources in a given section into memory.
+	void unload_section(const std::string &amp;section_name);
+
+//! Implementation:
+private:
+	CL_ResourceManager(const CL_SharedPtr&lt;CL_ResourceManager_Generic&gt; &amp;impl);
+
+	//: Pointer to the implementation.
+	CL_SharedPtr&lt;CL_ResourceManager_Generic&gt; impl;
+
+	friend class CL_Resource;
+};
+#endif

Added: trunk/clanlib/API/Core/Resources/resourcedata.h
===================================================================
--- trunk/clanlib/API/Core/Resources/resourcedata.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/Resources/resourcedata.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,99 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;Resources&quot;
+//! header=core.h
+
+#ifndef header_resourcedata
+#define header_resourcedata
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;resource.h&quot;
+
+class CL_ResourceData_Generic;
+
+//: Data object attached to a resource.
+//- !group=Core/Resources!
+//- !header=core.h!
+//- &lt;p&gt;The CL_ResourceData class represents a data object connected to a
+//- resource. A resource can have one or more of these data objects
+//- attached, and they can be retrieved by making a call to
+//- CL_Resource::get_data.&lt;/p&gt;
+//- &lt;p&gt;Resource data objects are used to contain extra data associated with
+//- a certain resource. For instance, the surface resource has an object
+//- attached by the name &quot;surface&quot; that contain the loaded surface's
+//- data.&lt;/p&gt;
+class CL_API_CORE CL_ResourceData
+{
+//! Construction:
+public:
+	//: Constructs a resource data object.
+	//- &lt;p&gt;A resource data object will not by itself attach to a
+	//- CL_Resource. This must be done manually by making a call to
+	//- CL_Resource::attach_data.&lt;/p&gt;
+	//param resource: Resource object associated with this resource data
+	//param resource: object.
+	CL_ResourceData(CL_Resource &amp;resource);
+
+	//: Resource Data destructor.
+	virtual ~CL_ResourceData();
+
+//! Attributes:
+public:
+	//: Get Resource object.
+	CL_Resource get_resource();
+
+//! Operations:
+public:
+	//: Called first time CL_Resource::load() is called on the resource.
+	virtual void on_load() { return; }
+
+	//: Called last time CL_Resource::unload() is called on the resource.
+	virtual void on_unload() { return; }
+
+//! Implementation:
+private:
+	//: Pointer to the implementation.
+	CL_ResourceData_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Core/Resources/resourcetype_boolean.h
===================================================================
--- trunk/clanlib/API/Core/Resources/resourcetype_boolean.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/Resources/resourcetype_boolean.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,135 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;Resources&quot;
+//! header=core.h
+
+#ifndef header_resourcetype_boolean
+#define header_resourcetype_boolean
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;resourcedata.h&quot;
+#include &quot;resource_manager.h&quot;
+#include &quot;resource.h&quot;
+#include &lt;string&gt;
+#include &quot;../System/error.h&quot;
+#include &quot;../System/error.h&quot;
+
+//: Resource Data object for a 'boolean' resource type.
+//- !group=Core/Resources!
+//- !header=core.h!
+class CL_API_CORE CL_ResourceData_Boolean : public CL_ResourceData
+{
+//! Construction:
+public:
+	//: Resource Data Boolean Constructor.
+	CL_ResourceData_Boolean(class CL_Resource &amp;resource);
+
+//! Attributes:
+public:
+	//: Value
+	bool value;
+};
+
+//: Boolean resource accessor class.
+//- !group=Core/Resources!
+//- !header=core.h!
+class CL_Boolean
+{
+//! Construction:
+public:
+	//: Constructs a boolean.
+	//param res_id: Resource id of a boolean resource to be constructed from.
+	//param resources: Resource manager to load resource from.
+	//param def_value: Default value to use if resource is not found.
+	CL_Boolean(const std::string &amp;res_id, CL_ResourceManager *resources)
+	{
+		CL_Resource res = resources-&gt;get_resource(res_id);
+		res.load();
+		CL_ResourceData_Boolean *data = (CL_ResourceData_Boolean *) res.get_data(&quot;boolean&quot;);
+		value = data-&gt;value;
+		res.unload();
+	}
+
+	CL_Boolean(const std::string &amp;res_id, CL_ResourceManager *resources, bool def_value)
+	{
+		try
+		{
+			CL_Resource res = resources-&gt;get_resource(res_id);
+			res.load();
+			CL_ResourceData_Boolean *data = (CL_ResourceData_Boolean *) res.get_data(&quot;boolean&quot;);
+			value = data-&gt;value;
+			res.unload();
+		}
+		catch (CL_Error err)
+		{
+			value = def_value;
+		}
+	}
+
+//! Operators:
+	//: Converts a CL_Boolean to a bool.
+	operator bool() const
+	{
+		return value;
+	}
+
+	//: Loads a boolean from a resource.
+	//param res_id: Resource to load boolean from.
+	//param resources: Resource manager used to load boolean.
+	//param def_value: Default value if resource is not found.
+	static bool load( const std::string &amp;res_id, CL_ResourceManager *resources )
+	{
+		return (bool) CL_Boolean(res_id, resources );
+	}
+
+	static bool load( const std::string &amp;res_id, CL_ResourceManager *resources, bool def_value )
+	{
+		return (bool) CL_Boolean(res_id, resources, def_value );
+	}
+
+//! Implementation:
+private:
+	bool value;
+};
+
+#endif

Added: trunk/clanlib/API/Core/Resources/resourcetype_float.h
===================================================================
--- trunk/clanlib/API/Core/Resources/resourcetype_float.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/Resources/resourcetype_float.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,120 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;Resources&quot;
+//! header=core.h
+
+#ifndef header_resourcetype_float
+#define header_resourcetype_float
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;resourcedata.h&quot;
+#include &quot;resource_manager.h&quot;
+#include &quot;resource.h&quot;
+#include &lt;string&gt;
+#include &quot;../System/error.h&quot;
+#include &quot;../System/error.h&quot;
+
+//: Resource Data object for an 'float' resource type.
+//- !group=Core/Resources!
+//- !header=core.h!
+class CL_API_CORE CL_ResourceData_Float : public CL_ResourceData
+{
+//! Construction:
+public:
+	//: Resource Data Float Constructor.
+	CL_ResourceData_Float(class CL_Resource &amp;resource);
+
+//! Attributes:
+public:
+	//: Float Value.
+	float value;
+};
+
+//: r resource accessor class.
+//- !group=Core/Resources!
+//- !header=core.h!
+class CL_Float
+{
+//! Construction:
+public:
+	//: Constructs a float
+	//param res_id: Resource id of a float resource to be constructed from.
+	//param resources: Resource manager to load resource from.
+	//param def_value: Default value to use if resource is not found.
+	CL_Float(const std::string &amp;res_id, CL_ResourceManager *resources)
+	{
+		CL_Resource res = resources-&gt;get_resource(res_id);
+		res.load();
+		CL_ResourceData_Float *data = (CL_ResourceData_Float *) res.get_data(&quot;float&quot;);
+		value = data-&gt;value;
+		res.unload();
+	}
+
+	CL_Float(const std::string &amp;res_id, CL_ResourceManager *resources, float def_value)
+	{
+		try
+		{
+			CL_Resource res = resources-&gt;get_resource(res_id);
+			res.load();
+			CL_ResourceData_Float *data = (CL_ResourceData_Float *) res.get_data(&quot;float&quot;);
+			value = data-&gt;value;
+			res.unload();
+		}
+		catch (CL_Error err)
+		{
+			value = def_value;
+		}
+	}
+
+//! Operators:
+	//: Converts a CL_Float to a float.
+	operator float() const
+	{
+		return value;
+	}
+
+private:
+	float value;
+};
+
+#endif

Added: trunk/clanlib/API/Core/Resources/resourcetype_integer.h
===================================================================
--- trunk/clanlib/API/Core/Resources/resourcetype_integer.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/Resources/resourcetype_integer.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,135 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;Resources&quot;
+//! header=core.h
+
+#ifndef header_resourcetype_integer
+#define header_resourcetype_integer
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;resourcedata.h&quot;
+#include &quot;resource_manager.h&quot;
+#include &quot;resource.h&quot;
+#include &lt;string&gt;
+#include &quot;../System/error.h&quot;
+#include &quot;../System/error.h&quot;
+
+//: Resource Data object for an 'integer' resource type.
+//- !group=Core/Resources!
+//- !header=core.h!
+class CL_API_CORE CL_ResourceData_Integer : public CL_ResourceData
+{
+//! Construction:
+public:
+	//: Resource Data Integer Constructor.
+	CL_ResourceData_Integer(class CL_Resource &amp;resource);
+
+//! Attributes:
+public:
+	//: Integer Value.
+	int value;
+};
+
+//: Integer resource accessor class.
+//- !group=Core/Resources!
+//- !header=core.h!
+class CL_Integer
+{
+//! Construction:
+public:
+	//: Constructs an integer.
+	//param res_id: Resource id of an integer resource to be constructed from.
+	//param resources: Resource manager to load resource from.
+	//param def_value: Default value to use if resource is not found.
+	CL_Integer(const std::string &amp;res_id, CL_ResourceManager *resources)
+	{
+		CL_Resource res = resources-&gt;get_resource(res_id);
+		res.load();
+		CL_ResourceData_Integer *data = (CL_ResourceData_Integer *) res.get_data(&quot;integer&quot;);
+		value = data-&gt;value;
+		res.unload();
+	}
+
+	CL_Integer(const std::string &amp;res_id, CL_ResourceManager *resources, int def_value)
+	{
+		try
+		{
+			CL_Resource res = resources-&gt;get_resource(res_id);
+			res.load();
+			CL_ResourceData_Integer *data = (CL_ResourceData_Integer *) res.get_data(&quot;integer&quot;);
+			value = data-&gt;value;
+			res.unload();
+		}
+		catch (CL_Error err)
+		{
+			value = def_value;
+		}
+	}
+
+//! Operators:
+	//: Converts a CL_Integer to an integer.
+	operator int() const
+	{
+		return value;
+	}
+
+	//: Loads a boolean from a resource.
+	//param res_id: Resource to load boolean from.
+	//param resources: Resource manager used to load boolean.
+	//param def_value: Default value if resource is not found.
+	static int load( const std::string &amp;res_id, CL_ResourceManager *resources )
+	{
+		return (int) CL_Integer(res_id, resources );
+	}
+
+	static int load( const std::string &amp;res_id, CL_ResourceManager *resources, bool def_value )
+	{
+		return (int) CL_Integer(res_id, resources, def_value );
+	}
+
+//! Implementation:
+private:
+	int value;
+};
+
+#endif

Added: trunk/clanlib/API/Core/Resources/resourcetype_raw.h
===================================================================
--- trunk/clanlib/API/Core/Resources/resourcetype_raw.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/Resources/resourcetype_raw.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,135 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;Resources&quot;
+//! header=core.h
+
+#ifndef header_resourcetype_raw
+#define header_resourcetype_raw
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;resourcedata.h&quot;
+#include &quot;resource_manager.h&quot;
+#include &quot;resource.h&quot;
+#include &quot;../IOData/inputsource_memory.h&quot;
+#include &lt;string&gt;
+#include &lt;vector&gt;
+
+//: Resource Data object for a 'raw' resource type.
+//- !group=Core/Resources!
+//- !header=core.h!
+class CL_API_CORE CL_ResourceData_Raw : public CL_ResourceData
+{
+//! Construction:
+public:
+	//: Resource Data Raw Constructor.
+	CL_ResourceData_Raw(class CL_Resource &amp;resource);
+
+//! Attributes:
+public:
+	//: Vector array containing the raw data.
+	std::vector&lt;unsigned char&gt; value;
+
+//! Implementation:
+private:
+	void on_load();
+
+	void on_unload();
+};
+
+//: Raw resource accessor class.
+//- !group=Core/Resources!
+//- !header=core.h!
+class CL_Raw
+{
+//! Construction:
+public:
+	//: Constructs an raw object.
+	//param res_id: Resource id of an raw resource to load from.
+	//param resources: Resource manager to load resource from.
+	CL_Raw(const std::string &amp;res_id, CL_ResourceManager *resources)
+	{
+		res = resources-&gt;get_resource(res_id);
+		res.load();
+		data = (CL_ResourceData_Raw *) res.get_data(&quot;raw&quot;);
+	}
+
+	//: Raw Class destructor.
+	~CL_Raw()
+	{
+		res.unload();
+	}
+
+//! Attributes:
+public:
+	//: Returns the raw data as a vector.
+	std::vector&lt;unsigned char&gt; &amp;get_data()
+	{
+		return data-&gt;value;
+	}
+
+	const std::vector&lt;unsigned char&gt; &amp;get_data() const
+	{
+		return data-&gt;value;
+	}
+
+private:
+	CL_Resource res;
+	CL_ResourceData_Raw *data;
+};
+
+//: Input source interface for 'raw' resource types.
+//- !group=Core/Resources!
+//- !header=core.h!
+class CL_InputSource_Raw : public CL_Raw, public CL_InputSource_Memory
+{
+public:
+	//: Construct input source reading from a 'raw' resource type.
+	//param res_id: Resource id of an raw resource to load from.
+	//param resources: Resource manager to load resource from.
+	CL_InputSource_Raw(const std::string &amp;res_id, CL_ResourceManager *resources)
+		: CL_Raw(res_id, resources), CL_InputSource_Memory(std::string((char *) &amp;CL_Raw::get_data()[0], CL_Raw::get_data().size()))
+	{
+	}
+};
+
+#endif

Added: trunk/clanlib/API/Core/Resources/resourcetype_string.h
===================================================================
--- trunk/clanlib/API/Core/Resources/resourcetype_string.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/Resources/resourcetype_string.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,69 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;Resources&quot;
+//! header=core.h
+
+#ifndef header_resourcetype_string
+#define header_resourcetype_string
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;resourcedata.h&quot;
+#include &lt;string&gt;
+
+//: Resource Data object for a 'string' resource type.
+//- !group=Core/Resources!
+//- !header=core.h!
+class CL_API_CORE CL_ResourceData_String : public CL_ResourceData
+{
+//! Construction:
+public:
+	//: Resource Data String Constructor.
+	CL_ResourceData_String(class CL_Resource &amp;resource);
+
+//! Attributes:
+public:
+	//: The string.
+	std::string value;
+};
+
+#endif

Added: trunk/clanlib/API/Core/System/call_stack.h
===================================================================
--- trunk/clanlib/API/Core/System/call_stack.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/call_stack.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,84 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;System&quot;
+//! header=core.h
+
+#ifndef header_call_stack
+#define header_call_stack
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;sharedptr.h&quot;
+
+class CL_CallStack_Generic;
+
+//: Call stack for stack back trace.
+//- !group=Core/System!
+//- !header=core.h!
+
+class CL_API_CORE CL_CallStack
+{
+//! Construction:
+public:
+	CL_CallStack();
+
+	~CL_CallStack();
+
+//! Attributes:
+public:
+	//: Returns the number of stack call frames available.
+	int get_num_frames() const;
+
+	//: Returns the specified stack frame.
+	const std::string &amp;get_call_frame(int frame) const;
+
+//! Operations:
+public:
+	//: Adds a frame description to the call stack.
+	void add_call_frame(const std::string &amp;str_frame);
+
+//! Implementation:
+private:
+	CL_SharedPtr&lt;CL_CallStack_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/Core/System/cl_assert.h
===================================================================
--- trunk/clanlib/API/Core/System/cl_assert.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/cl_assert.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,80 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;System&quot;
+//! header=core.h
+
+#ifndef header_cl_assert
+#define header_cl_assert
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifndef __PRETTY_FUNCTION__ 
+#define __PRETTY_FUNCTION__ NULL
+#endif
+
+#ifndef __STRING
+#define cl_assert(a) CL_Assert::die(a, __FILE__, __LINE__, __PRETTY_FUNCTION__, #a);
+#else
+#define cl_assert(a) CL_Assert::die(a, __FILE__, __LINE__, __PRETTY_FUNCTION__, __STRING(a));
+#endif
+
+//: This is ClanLib's assertion class.
+//- !group=Core/System!
+//- !header=core.h!
+
+class CL_API_CORE CL_Assert
+{
+//! Operations:
+public:
+	//: Produces an assert.
+	//- &lt;p&gt;This function shouldn't be called directly -
+	//- instead, use the cl_assert macro.
+	//-  For example: cl_assert(should_not_be_zero != 0)&lt;/p&gt;
+	//param a: Asserts if false.
+	//param file: Name of the file where the assert occurred.
+	//param line: Line in the file where the assert occurred.
+	//param func: Function in which the assert occurred.
+	//param assert_str: String that describe the assertion check.
+	static void die(bool a, const char *file, int line, const char *func, const char *assert_str);
+};
+
+#endif

Added: trunk/clanlib/API/Core/System/cl_library.h
===================================================================
--- trunk/clanlib/API/Core/System/cl_library.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/cl_library.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,172 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;Library&quot;
+//! header=core.h
+
+#ifndef header_cl_library
+#define header_cl_library
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;map&gt;
+#include &lt;string&gt;
+#include &lt;functional&gt;
+
+#ifdef WIN32
+#include &quot;windows.h&quot;
+#endif
+
+#include &quot;error.h&quot;
+
+//: CL_LibraryFactory class
+//- !group=Core/System!
+//- !header=core.h!
+//- &lt;p&gt;Convenient abstract class that your own plugin-classes should inherit in order to be managed with CL_LibraryManager.&lt;/p&gt;
+class CL_API_CORE CL_LibraryFactory
+{
+public:
+	virtual ~CL_LibraryFactory() = 0;
+};
+
+inline CL_LibraryFactory::~CL_LibraryFactory() {}
+
+//: CL_LibraryLoader class
+//- !group=Core/System!
+//- !header=core.h!
+//- &lt;p&gt;This class is a wrapper to dynmanically load code from a dynamic library.&lt;/p&gt;            
+class CL_API_CORE CL_LibraryLoader
+{
+//! Construction:
+public:
+	//: Constructor that does nothing
+	//param filename: The filename parameter is the path to the dynamic library to be loaded. You can avoid the the exyension and the constructor will automatically ends the name with either a '.so' under Linux or a '.dll' under Windows
+	CL_LibraryLoader(const std::string&amp; filename);
+	
+	//: The destructor will unload the library if you didn't call yourself unoload() method
+	virtual ~CL_LibraryLoader();
+
+//! Attributes:
+private:
+	//: Name of the opened library (with the extension)
+	std::string filename;
+
+	//: State of the library
+	bool loaded;
+
+	//: Pointer to the dynamic loaded library
+#ifdef WIN32
+	HINSTANCE handle;
+#else
+	void *handle;
+#endif
+
+	//: Last error message emitted if an error happened
+	CL_Error *last_error;
+
+public:
+	//: Return the dynamic library filename
+	//return: Return the dynamic library filename
+	std::string name() const;
+
+	//: Resolve a symbol name within the library
+	//param symbol: Name of the symbol you're looking for within the library
+	//return: The address of the symbol if found or 0
+	void *resolve(const std::string&amp; symbol);
+
+	//: Return the state of the library
+	//return: true if the library is loaded otherwise false
+	bool is_loaded() const;
+
+	//: Load the library 
+	//return: true if succeeded, false otherwise. You might consider to look at the last error message in the latter case
+	bool load();
+
+	//: Unload the library
+	//return: true if succeeded, false otherwise. You might consider to look at the last error message in the latter case
+	bool unload();
+
+	//: Get the last error message
+	//return: The last error message
+	CL_Error *get_last_error() const;
+};
+
+typedef CL_LibraryFactory *CL_LibraryFactoryMaker();
+typedef CL_LibraryFactory *(*CL_LibraryFactoryMaker_t)();
+
+//: CL_LibraryManager class
+//- !group=Core/System!
+//- !header=core.h!
+//- &lt;p&gt;This a convenient class to manage all your loaded classes.&lt;/p&gt;
+class CL_API_CORE CL_LibraryManager
+{
+private:
+	//: This map stores all makers founded within a dynamic library. 
+	//- &lt;p&gt;C modules are easily parsed when looking for a symbol by underlaying librairies (like dlsym() for Linux or GetProcAddress() under Windows), but when it comes to parse C++ modules, these underlaying librairies fail as C++ compilators must decorate symbols name within module (this is due to C++ behaviour). Thus in order to dynamically load classes you must use a trick. Your class must inherit from an abstract class (the interface) and you must provide a C-style function that will be a maker. This function will only create an instance of the class you're looking for. Therefore, when you load a class, you first must retreive the maker function and call it. You'll get then an instance of the class that you can use as usual. This map stores maker function that have been resolved with CL_Library::resolve() method.&lt;/p&gt;
+	static std::map&lt;std::string, CL_LibraryFactoryMaker *, std::less&lt;std::string&gt; &gt; libraries;
+
+public:
+	virtual ~CL_LibraryManager() = 0;
+
+//! Operations:
+	//: Retreive a maker function
+	//param maker_name: The name of the maker function you're looking within the map
+	//return: The maker function
+	static CL_LibraryFactoryMaker_t get(const std::string&amp; maker_name);
+
+	//: Add a new maker function to the map
+	//param maker_name: The name of the maker function
+	//param maker: Maker function to add to the map
+	static void add(const std::string&amp; maker_name,CL_LibraryFactoryMaker *maker);
+
+	//: Remove a maker function from the map
+	//param maker_name: Maker name function
+	static void remove(const std::string&amp;);
+
+	//: Convenient method to check if a given maker function is already in the map
+	//param maker_name: Maker name function
+	//return: true if found false otherwise
+	static bool has(const std::string&amp; maker_name);
+};
+
+inline CL_LibraryManager::~CL_LibraryManager() {}
+
+#endif

Added: trunk/clanlib/API/Core/System/clanstring.h
===================================================================
--- trunk/clanlib/API/Core/System/clanstring.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/clanstring.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,277 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;System&quot;
+//! header=core.h
+
+#ifndef header_clanstring
+#define header_clanstring
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;sstream&gt;
+#include &lt;string&gt;
+#include &lt;vector&gt;
+
+class CL_ResourceManager;
+
+class CL_API_CORE CL_String
+//: ClanLib string class.
+//- !group=Core/System!
+//- !header=core.h!
+//- &lt;p&gt;This is a general purpose string class with formatting capabilities.&lt;/p&gt;
+//- &lt;p&gt;Example: str::string s = CL_String::format(&quot;You rock my %1, %2 (%3)&quot;, &quot;world&quot;, name, 47);&lt;/p&gt;
+{
+//! Operations:
+public:
+	//: Loads a string from a resource.
+	//param res_id: Resource to load string from.
+	//param resources: Resource manager used to load string.
+	//param def_value: Default value if resource is not found.
+	static std::string load(const std::string &amp;res_id, CL_ResourceManager *resources);
+
+	static std::string load(const std::string &amp;res_id, CL_ResourceManager *resources, const std::string &amp;def_value);
+	
+	//: Returns the first n characters of the string
+	static std::string left(std::string string, int n);
+	
+	//: Returns the last n characters in the string
+	static std::string right(std::string string, int n);
+
+	//: String formatting.
+	//- &lt;p&gt;The format specified is of the form &quot;Some text %1, some more text %2&quot;.
+	//- The %n markers can then be search/replaced using the arg() functions.&lt;/p&gt;
+	//- &lt;pre&gt;
+	//- Example 1:
+	//-   CL_String str;
+	//-   str.format(&quot;%1 world! Meaning of life is: %2&quot;);
+	//-   str.arg(&quot;Hello&quot;);
+	//-   str.arg(42);
+	//- Example 2:
+	//-   CL_String str;
+	//-   str.format(&quot;%1 is better than %2&quot;, &quot;ClanLib 0.7&quot;, &quot;ClanLib 0.6&quot;);
+	//- &lt;/pre&gt;
+	//static std::string format(const std::string &amp;format);
+
+	template&lt;class Param1&gt;
+	static std::string format(const std::string &amp;str_format, const Param1 &amp;p1)
+	{
+		std::string ret = str_format;
+		arg(ret, p1, 1);
+		
+		return ret;
+	}
+
+	template&lt;class Param1, class Param2&gt;
+	static std::string format(const std::string &amp;str_format, const Param1 &amp;p1, const Param2 &amp;p2)
+	{
+		std::string ret = str_format;
+		arg(ret, p1, 1);
+		arg(ret, p2, 2);
+
+		return ret;
+	}
+
+	template&lt;class Param1, class Param2, class Param3&gt;
+	static std::string format(const std::string &amp;str_format, const Param1 &amp;p1, const Param2 &amp;p2, const Param3 &amp;p3)
+	{
+		std::string ret = str_format;
+		arg(ret, p1, 1);
+		arg(ret, p2, 2);
+		arg(ret, p3, 3);
+		return ret;
+	}
+
+	template&lt;class Param1, class Param2, class Param3, class Param4&gt;
+	static std::string format(const std::string &amp;str_format, const Param1 &amp;p1, const Param2 &amp;p2, const Param3 &amp;p3, const Param4 &amp;p4)
+	{
+		std::string ret = str_format;
+		arg(ret, p1, 1);
+		arg(ret, p2, 2);
+		arg(ret, p3, 3);
+		arg(ret, p4, 4);
+		return ret;
+	}
+	
+	template&lt;class Param1, class Param2, class Param3, class Param4, class Param5&gt;
+	static std::string format(const std::string &amp;str_format, const Param1 &amp;p1, const Param2 &amp;p2, const Param3 &amp;p3, const Param4 &amp;p4, const Param5 &amp;p5)
+	{
+		std::string ret = str_format;
+		arg(ret, p1, 1);
+		arg(ret, p2, 2);
+		arg(ret, p3, 3);
+		arg(ret, p4, 4);
+		arg(ret, p5, 5);
+		return ret;
+	}
+
+	template&lt;class Param1, class Param2, class Param3, class Param4, class Param5, class Param6&gt;
+	static std::string format(const std::string &amp;str_format, const Param1 &amp;p1, const Param2 &amp;p2, const Param3 &amp;p3, const Param4 &amp;p4, const Param5 &amp;p5, const Param6 &amp;p6)
+	{
+		std::string ret = str_format;
+		arg(ret, p1, 1);
+		arg(ret, p2, 2);
+		arg(ret, p3, 3);
+		arg(ret, p4, 4);
+		arg(ret, p5, 5);
+		arg(ret, p6, 6);
+		return ret;
+	}
+
+	template&lt;class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7&gt;
+	static std::string format(const std::string &amp;str_format, const Param1 &amp;p1, const Param2 &amp;p2, const Param3 &amp;p3, const Param4 &amp;p4, const Param5 &amp;p5, const Param6 &amp;p6, const Param7 &amp;p7)
+	{
+		std::string ret = str_format;
+		arg(ret, p1, 1);
+		arg(ret, p2, 2);
+		arg(ret, p3, 3);
+		arg(ret, p4, 4);
+		arg(ret, p5, 5);
+		arg(ret, p6, 6);
+		arg(ret, p7, 7);
+		return ret;
+	}
+
+	//: Converts from an integer to string.
+	static std::string from_int(int value);
+
+	//: Converts from an float to string.
+	static std::string from_float(float value);
+
+	//: Converts from an double to string.
+	static std::string from_double(double value);
+
+	//: Returns &quot;true&quot; or &quot;false&quot; based on a boolean.
+	static std::string from_bool(bool value);
+
+	//: Converts a string to a boolean.
+	//- &lt;p&gt;Accepted values: &quot;1&quot;, &quot;0&quot;, &quot;yes&quot;, &quot;no&quot;, &quot;true&quot;, &quot;false&quot;. All other values return false.
+	//- The function is not case sensitive.&lt;/p&gt;
+	static bool to_bool(const std::string &amp;value);
+
+	//: Converts string to an integer.
+	static int to_int(const std::string&amp;);
+
+	//: Converts string to a floating point number.
+	static float to_float(const std::string&amp;);
+	
+	//: Converts string to a double precision floating point number.
+	static double to_double(const std::string&amp;);
+
+	//: Returns the string with all characters converted to lowercase.
+	static std::string to_lower(const std::string&amp;);
+	
+	//: Returns the string with all characters converted to uppercase.
+	static std::string to_upper(const std::string&amp;);
+
+	//: Breaks up the string into tokens.
+	static std::vector&lt;std::string&gt; tokenize(const std::string &amp;str, const std::string &amp;delimiter, bool skip_empty = true);
+
+	//: Does a case insensitive compare of string to other string.
+	static bool compare_nocase(const std::string&amp;, const std::string&amp;);
+
+	//: Returns the path part of a pathname (path+filename). If no path part is found, &quot;.&quot; is returned.
+	static std::string get_path(const std::string &amp;pathname);
+
+	//: Returns the filename part of a pathname (path+filename). If no path part is found, the entire string is returned.
+	static std::string get_filename(const std::string &amp;pathname);
+
+	//: Returns the extension path of a filename (text after the last dot). If no extension part is found, an empty string is returned.
+	static std::string get_extension(const std::string &amp;filename);
+
+	//: Returns a string trimmed for space characters in both ends of string.
+	static std::string trim_spaces(const std::string &amp;str);
+
+	//: Returns a string trimmed for whitespace characters in both ends of string.
+	//- &lt;p&gt;Whitespace are space, tabs, newlines and carrage return characters.&lt;/p&gt;
+	static std::string trim_whitespace(const std::string &amp;str);
+
+	//: Return a string with C style escapes ({'\','n'}, {'\', 't'} etc.) replaced with the real escapes ('\n', '\t').
+	//- &lt;p&gt;At the moment \n, \t and \\ are converted.&lt;br&gt;Single '\' will appear as such unless followed by one of the supported escape character.&lt;/p&gt;
+	static std::string convert_c_escapes(const std::string &amp;str);
+
+	//: Convert any type to a string
+	//- &lt;p&gt;Convert any type into a string, it is required that a operator&lt;&lt;(std::ostream, T) is defined for that type
+	template &lt;class T&gt;
+	static std::string to(const T&amp; any)
+	{
+		std::ostringstream oss;
+		oss &lt;&lt; any;
+		return oss.str();
+	}
+
+	//: Convert a string into any type
+	//- &lt;p&gt;Convert a string into the given type, it is required that a operator&gt;&gt;(std::ostream, T) is defined for that type	and that the string is a valid representation of that type. On error false is returned, on success true. The input string is not modified on error&lt;/p&gt;
+	template &lt;class T&gt;
+	static bool from(const std::string&amp; rep, T&amp; x)
+	{
+		// this is necessary so that if &quot;x&quot; is not modified if the conversion fails
+		T temp;
+		std::istringstream iss(rep);
+		
+		iss &gt;&gt; temp;
+  
+		if (iss.fail()) {
+			return false;
+		} else {
+			x = temp;
+			return true;
+		}
+	}
+
+//! Implementation:
+private:
+	// Private Constructor to prevent people from creating instances of CL_String
+	CL_String() {;}
+
+	// Replaces argument %(num) in format with arg
+	static void arg(std::string &amp;format, const std::string &amp;arg, int num);
+
+	static void arg(std::string &amp;format, const char *arg, int num);
+
+	static void arg(std::string &amp;format, int number, int num);
+
+	static void arg(std::string &amp;format, float number, int num);
+
+	static void arg(std::string &amp;format, double number, int num);
+};
+
+#endif

Added: trunk/clanlib/API/Core/System/clonable.h
===================================================================
--- trunk/clanlib/API/Core/System/clonable.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/clonable.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,53 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;System&quot;
+//! header=core.h
+
+#ifndef clanlib_clonable_header
+#define clanlib_clonable_header
+
+//: Clonable interface.
+//- !group=Core/System!
+//- !header=core.h!
+class CL_Clonable
+{
+//! Construction:
+public:
+	virtual ~CL_Clonable() {}
+
+	virtual CL_Clonable* clone() const =0;
+
+//! Attributes:
+public:
+	//: Dummy method; templates that require clonable can use this to check
+	void must_be_derived_from_cl_clonable() const {}
+};
+
+#endif

Added: trunk/clanlib/API/Core/System/command_line.h
===================================================================
--- trunk/clanlib/API/Core/System/command_line.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/command_line.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,167 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;System&quot;
+//! header=core.h
+
+#ifndef header_core_system_command_line
+#define header_core_system_command_line
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+
+class CL_CommandLine_Generic;
+
+//: Helper class to parse command line arguments
+//- !group=Core/System!
+//- !header=core.h!
+//- &lt;p&gt;The CL_CommandLine class helps to parse command line arguments, namely
+//- the argc/argv pair that you get from main(). CL_CommandLine mimics
+//- getopt_long() behaviour as closely as possible, while providing a
+//- cleaner interface and a few additional features, like automatic
+//- generation of '--help' output. CL_CommandLine can parse long arguments
+//- in the following styles:&lt;/p&gt;
+//-
+//- &lt;p&gt;program --file FILENAME&lt;br&gt;
+//- program --file=FILENAME&lt;/p&gt;
+//-
+//- &lt;p&gt;Short arguments are handled like this:&lt;/p&gt;
+//-
+//- &lt;p&gt;program -f FILENAME&lt;/p&gt;
+//-
+//- &lt;p&gt;Concatenating short arguments is also supported, so that:&lt;/p&gt;
+//- 
+//- &lt;p&gt;program -f -a -b FILENAME&lt;/p&gt;
+//-
+//- &lt;p&gt;is equivalent to:&lt;/p&gt;
+//-
+//- &lt;p&gt;program -fab FILENAME&lt;/p&gt;
+//-
+//- &lt;p&gt;Non-option arguments (aka rest arguments) are supported as well:&lt;/p&gt;
+//-
+//- &lt;p&gt;program SOMEFILE SOMEOTHERFILE ...&lt;/p&gt;
+//- 
+//- &lt;p&gt;To avoid ambiguity when a filename starts with '-' CL_CommandLine stops
+//- parsing arguments after the first encounter of a '--', so in&lt;/p&gt;
+//-
+//- &lt;p&gt;program -f -b -- -f -b&lt;/p&gt;
+//-
+//- &lt;p&gt;In the above example the first '-f -b' options are treated as
+//- normal while the ones after the '--' are treated as rest arguments
+//- (aka filenames in most programs).&lt;/p&gt;
+class CL_API_CORE CL_CommandLine
+{
+//! Construction:
+public:
+	CL_CommandLine();
+
+	~CL_CommandLine();
+
+//! Attributes:
+public:
+	enum
+	{
+		REST_ARG  = -2
+	};
+
+	//: Return the key of the current option
+	int get_key();
+
+	//: Return the argument to the current option
+	std::string get_argument();
+
+//! Operations:
+public:
+	//: Change the indention used for the help message, default is 18
+	void set_help_indent(int i);
+
+	//: Add a usage line to the help output, usage is for example
+	//: &quot;[OPTIONS]... FILE&quot;, the program name will get appended
+	//: automatically
+	void add_usage(const std::string&amp; usage);
+
+	//: Adds extra documentation to the help output, should only be
+	//: used at the beginning or at the end, to
+	void add_doc(const std::string&amp; doc);
+	
+	//: Starts a new group of options, the grouptopic gets printed
+	//: above the group of options in the print_help() output
+	void add_group(const std::string&amp; grouptopic);
+  
+	//: Adds a option to the parser
+	//param key: a letter for a short-option or a numeric value
+	//param key: larger than 255 that identifies the option
+	//param long_option: the long name of this option or &quot;&quot; if non
+	//param long_option: should be used for this option
+	//param argument: the type of the argument that this option
+	//param argument: requires (i.e. FILE, SIZE, WIDTH, etc.) or &quot;&quot; if no argument is
+	//param argument: required
+	//param help: the help string for this option
+	//param visible: true if the option should be listed in the help
+	//param visible: output, false will not list it in the help output which might
+	//param visible: be usefull for cheat-options or backward-compability options
+	//param visible: than would only clutter the help output
+	void add_option(
+		int key,
+		const std::string&amp; long_option, 
+		const std::string&amp; argument,
+		const std::string&amp; help,
+		bool visible = true);
+	
+	//: Parse the options arcording to the options added with
+	//: add_option(), result of the parsing is accessible via
+	//: next() and get_key()/get_argument()
+	void parse_args(int argc, char** argv);
+
+	//: Print the help output, normaly done via a --help option
+	void print_help();
+
+	//: Goto the next option
+	bool next();
+
+//! Implementation:
+private:
+	CL_CommandLine_Generic* impl;
+};
+
+#endif

Added: trunk/clanlib/API/Core/System/console_window.h
===================================================================
--- trunk/clanlib/API/Core/System/console_window.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/console_window.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,94 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;System&quot;
+//! header=core.h
+
+#ifndef header_console_window
+#define header_console_window
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+
+class CL_ConsoleWindow_Generic;
+
+//: Text console window.
+//- !group=Core/System!
+//- !header=core.h!
+//- &lt;p&gt;Note: This class has no effect under Linux.&lt;/p&gt;
+class CL_API_CORE CL_ConsoleWindow
+{
+//! Construction:
+public:
+	//: Console Window constructor.
+	//param title: Window title of console window.
+	//param width: Columns in console window.
+	//param height: Rows in console window.
+	CL_ConsoleWindow(
+		const std::string &amp;title,
+		int width = 80,
+		int height = 25);
+
+	//: Console Window destructor.
+	~CL_ConsoleWindow();
+
+//! Operations:
+public:
+	//: Redirects stdout, stdin and stderr to the console window.
+	void redirect_stdio();
+
+	//: Redirects stdout and stderr to filename.
+	void redirect_stdio(const std::string &amp;filename);
+
+	//: Waits until user hits a key.
+	void wait_for_key();
+
+	//: Displays 'press any key to close this console window',
+	//: and waits until user hits a key.
+	void display_close_message();
+
+//! Implementation:
+private:
+	CL_ConsoleWindow_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Core/System/crash_reporter.h
===================================================================
--- trunk/clanlib/API/Core/System/crash_reporter.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/crash_reporter.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,88 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;System&quot;
+//! header=core.h
+
+#ifndef header_crash_reporter
+#define header_crash_reporter
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../../signals.h&quot;
+#include &quot;call_stack.h&quot;
+#include &quot;sharedptr.h&quot;
+
+class CL_CrashReporter_Generic;
+
+//: Crash reporting tool.
+//- !group=Core/System!
+//- !header=core.h!
+//- &lt;p&gt;Constructing an instance of this class in a thread will cause any fatal errors
+//- (ie. segmentation faults) to be caught and handled by the crash reporter. It
+//- will then dump the callstack to file and then afterwards emit sig_crash.&lt;/p&gt;
+class CL_API_CORE CL_CrashReporter
+{
+//! Construction:
+public:
+	CL_CrashReporter();
+
+	~CL_CrashReporter();
+
+//! Attributes:
+public:
+	//: Returns the flag indicating if it will dump the callstack to file.
+	static bool get_dump_to_file();
+
+	//: If enabled, will dump the callstack to file before emitting sig_crash.
+	static void set_dump_to_file(bool enable);
+
+//! Operations:
+public:
+	//: Signal emitted when fatal errors are caught.
+	static CL_Signal_v2&lt;std::string, CL_CallStack&gt; &amp;sig_crash();
+
+//! Implementation:
+private:
+	CL_SharedPtr&lt;CL_CrashReporter_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/Core/System/error.h
===================================================================
--- trunk/clanlib/API/Core/System/error.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/error.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,74 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;System&quot;
+//! header=core.h
+
+#ifndef header_error
+#define header_error
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+
+//: Exception class in ClanLib.
+//- !group=Core/System!
+//- !header=core.h!
+//- &lt;p&gt;If something goes wrong in a clanlib function, it will throw an exception of
+//- this class.&lt;/p&gt;
+class CL_API_CORE CL_Error
+{
+public:
+//! Construction:
+	//: Error Constructor.
+	CL_Error(const char *message) { this-&gt;message = message; }
+
+	CL_Error(const std::string &amp;message) { this-&gt;message = message; }
+
+	//: The error message
+	std::string message;
+};
+
+//: This function throws an error.
+void CL_API_CORE cl_throw_error(const char *message);
+void CL_API_CORE cl_throw_error(const std::string &amp;message);
+
+#endif

Added: trunk/clanlib/API/Core/System/event_listener.h
===================================================================
--- trunk/clanlib/API/Core/System/event_listener.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/event_listener.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,100 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;System&quot;
+//! header=core.h
+
+#ifndef header_event_listener
+#define header_event_listener
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+class CL_EventTrigger;
+class CL_EventListener_Generic;
+
+//: Event listening interace.
+//- !group=Core/System!
+//- !header=core.h!
+//- &lt;p&gt;The event listener is used to collect a set of events, identified as CL_EventTrigger,
+//- and wait for one of them to occur. This is analog to the low level C socket select()
+//- function, except that this one operates on clanlib objects.&lt;/p&gt;
+class CL_API_CORE CL_EventListener
+{
+//! Construction:
+public:
+	//: Constructs an event listener object.
+	//param trigger: Initial trigger to be added to listener.
+	CL_EventListener();
+
+	CL_EventListener(CL_EventTrigger *trigger);
+
+	//: Event Listener destructor.
+	virtual ~CL_EventListener();
+
+//! Attributes:
+public:
+
+//! Operations:
+public:
+	//: Adds an event trigger to the listener.
+	void add_trigger(CL_EventTrigger *trigger);
+
+	//: Removes an event trigger from the listener.
+	void remove_trigger(CL_EventTrigger *trigger);
+
+	//: Removes all event triggers from the listener.
+	void clear();
+
+	//: Resets all event triggers added to the listener.
+	void reset_all();
+
+	//: Wait until one of the events triggers.
+	//param timeout - The timeout is in milliseconds. If -1, waits infinitely.
+	//- &lt;p&gt;If timeout = -1, this function will not timeout.&lt;/p&gt;
+	//returns: True if an event triggered, false if it timed out.
+	bool wait(int timeout = -1);
+
+//! Implementation:
+private:
+	CL_EventListener_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Core/System/event_trigger.h
===================================================================
--- trunk/clanlib/API/Core/System/event_trigger.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/event_trigger.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,98 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;System&quot;
+//! header=core.h
+
+#ifndef header_event_trigger
+#define header_event_trigger
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;sharedptr.h&quot;
+
+class CL_EventListener;
+class CL_EventTrigger_Generic;
+
+//: ClanLib Event trigger.
+//- !group=Core/System!
+//- !header=core.h!
+//- &lt;p&gt;This class represents an event that can be triggered.&lt;/p&gt;
+//- &lt;p&gt;Collect several triggers together using the CL_EventListener class, and then
+//- call the CL_EventListener::wait function to sleep until one of the events
+//- are triggered.&lt;/p&gt;
+class CL_API_CORE CL_EventTrigger
+{
+//! Construction:
+public:
+	//: Constructs an event trigger object.
+	CL_EventTrigger();
+
+	CL_EventTrigger(const CL_EventTrigger &amp;copy);
+
+	//: Event Trigger destructor.
+	virtual ~CL_EventTrigger();
+
+//! Attributes:
+public:
+	//: Returns true if the trigger flag has been raised.
+	bool get_flag() const;
+
+//! Operations:
+public:
+	//: Reset trigger flag.
+	void reset() const;
+
+	//: Raise trigger flag.
+	void set_flag();
+
+	//: Wait until the event triggers.
+	//param timeout - The timeout is in milliseconds. If -1, waits infinitely.
+	//- &lt;p&gt;If timeout = -1, this function will not timeout.&lt;/p&gt;
+	//returns: True if event triggered, false if it timed out.
+	bool wait(int timeout = -1);
+
+//! Implementation:
+public:
+	CL_SharedPtr&lt;CL_EventTrigger_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/Core/System/keep_alive.h
===================================================================
--- trunk/clanlib/API/Core/System/keep_alive.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/keep_alive.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,79 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;System&quot;
+//! header=core.h
+
+#ifndef header_keepalive
+#define header_keepalive
+
+#include &quot;thread.h&quot;
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+//: Keep alive callback interface.
+//- !group=Core/System!
+//- !header=core.h!
+//- &lt;p&gt;If you want to add something that gets called in a
+//- CL_System::keep_alive() call, inherit this class and create an instance
+//- of it.&lt;/p&gt;
+class CL_API_CORE CL_KeepAlive
+{
+//! Construction:
+public:
+	//: Constructs and registers the object as a keep_alive listener.
+	CL_KeepAlive();
+	
+	//: Unregisters the object as a keep_alive listener.
+	virtual ~CL_KeepAlive();
+
+//! Operations:
+public:
+	//: Called when CL_System::keep_alive() is called.
+	virtual void keep_alive()=0;
+
+//! Implementation:
+private:
+	//: Thread ID of thread this keep alive object was created in.
+	CL_ThreadId create_thread_id;
+};
+
+#endif

Added: trunk/clanlib/API/Core/System/lazycopyptr.h
===================================================================
--- trunk/clanlib/API/Core/System/lazycopyptr.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/lazycopyptr.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,114 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;System&quot;
+//! header=core.h
+
+#ifndef clanlib_lazycopyptr_header
+#define clanlib_lazycopyptr_header
+
+#include &quot;sharedptr.h&quot;
+
+//: Copy-on-write pointer class (acts like CL_OwningPtr, except holds off actual copy until non-const dereference).
+//- !group=Core/System!
+//- !header=core.h!
+//- &lt;p&gt; Use CL_LazyCopyPtr when you want stack-instance-like semantics for your data, but want to avoid
+//- doing an actual copy of the data until it's neccessary, if ever. This is often useful for classes
+//- containing implementation pointers with mutable data; the class might just be copied and the copy
+//- destroyed without any actual change of the copy's data. If that were the case and the class was
+//- using CL_LazyCopyPtr for its implementation pointer, an unneccessary copy would've been saved. &lt;/p&gt;
+//- &lt;p&gt; The way to take advantage of CL_LazyCopyPtr's lazy copying is to prefer const dereferences whenever
+//- possible. If the CL_LazyCopyPtr is a member of a class, and the dereference is within a const method
+//- of that class, then the const version of operator* or operator-&gt; is automatically used. To dereference
+//- the CL_LazyCopyPtr constly when not in a const method of a class owning the CL_LazyCopyPtr, use the cd() method. &lt;/p&gt;
+template &lt;typename T, typename U = T&gt; class CL_LazyCopyPtr
+{
+//! Construction:
+public:
+	//: Constructs a CL_LazyCopyPtr.
+	//param t: A pointer which was the return value of a 'new' call.
+	//- &lt;p&gt; Once the assignment statement is finished when assigning a passed pointer,
+	//- the CL_OwningPtr takes full control over that data. The original pointer shouldn't
+	//- be used to access or delete the data anymore; instead, use the CL_OwningPtr. &lt;/p&gt;
+	CL_LazyCopyPtr() {}
+	CL_LazyCopyPtr(T* t) : ptr(t) {}
+	
+//! Attributes:
+public:
+	//: Returns true if this CL_LazyCopyPtr is not dereferencable.
+	bool is_null() const {return ptr.is_null();}
+	
+	//: Returns number of references (including this one) to the data cache.
+	//- &lt;p&gt; Returns 0 if this pointer is null. &lt;/p&gt;
+	//- &lt;p&gt; If your code depends on this, it may not be using LazyCopyPtr correctly.
+	//- The idea is that the user code shouldn't concern itself with whether or
+	//- not a copy has taken place, just trust that LazyCopyPtr will copy it if
+	//- neccessary. &lt;/p&gt;
+	int get_ref_count() const {return ptr.ptr_ref_count();}
+	
+	//: Gives access to the pointer itself.
+	//- &lt;p&gt; Be careful not to keep the returned pointer around after doing any
+	//- non-const operations on the CL_LazyCopyPtr; it could be invalid
+	//- after that.&lt;/p&gt;
+	U* get() {return ptr.get();}
+	const U* get() const {return ptr.get();}
+	
+//! Operations:
+public:
+	//: Copy assignment operator.
+	//param t: A pointer which was the return value of a 'new' call.
+	//- &lt;p&gt; Once the assignment statement is finished when assigning a passed pointer,
+	//- the CL_LazyCopyPtr takes full control over that data. The original pointer shouldn't
+	//- be used to access or delete the data anymore; instead, use the CL_LazyCopyPtr. &lt;/p&gt;
+	CL_LazyCopyPtr&lt;T, U&gt;&amp; operator=(T* t) {ptr = t; return *this; }
+	
+	//: Dereferencing operator.
+	U&amp; operator*() {uniquify(); return *ptr;}
+	U const&amp; operator*() const {return *ptr;}
+	
+	//: Forces a const dereference.
+	//- &lt;p&gt; Like operator*, but forces a const dereference even if in non-const context. &lt;/p&gt;
+	U const&amp; cd() const {return *ptr;}
+	
+	//: Indirect member access operator.
+	U* operator-&gt;() {uniquify(); return ptr.operator-&gt;();}
+	U const* operator-&gt;() const {return ptr.operator-&gt;();}
+
+//! Implementation:
+private:
+	CL_SharedPtr&lt;T, U&gt; ptr;
+	
+	//: Ensures that we are the only user of this data
+	void uniquify() {if (ptr.get_ref_count() &gt; 1) ptr = CL_SharedPtr&lt;T, U&gt;((T*)(ptr-&gt;clone()));}
+	
+	//Not to be called, this just ensures that T is derived from CL_Clonable
+	void dummy() {ptr-&gt;must_be_derived_from_cl_clonable();}
+};
+
+#endif

Added: trunk/clanlib/API/Core/System/log.h
===================================================================
--- trunk/clanlib/API/Core/System/log.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/log.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,162 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;System&quot;
+//! header=core.h
+
+#ifndef header_log
+#define header_log
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../../signals.h&quot;
+#include &quot;clanstring.h&quot;
+
+//: Logging interface.
+//- !group=Core/System!
+//- !header=core.h!
+class CL_API_CORE CL_Log
+{
+//! Construction:
+public:
+
+//! Attributes:
+public:
+	//: Returns the signal that gets emitted every time a log is posted.
+	static CL_Signal_v3&lt;const std::string &amp;, int, const std::string &amp;&gt; &amp;sig_log();
+
+//! Operations:
+public:
+	//: Posts a log message with severity 0.
+	static void log(const std::string &amp;group, const std::string &amp;message);
+
+	//: Posts a log message.
+	static void log(const std::string &amp;group, int severity, const std::string &amp;message);
+
+	template&lt;class Param1&gt;
+	static void log(const std::string &amp;group, const std::string &amp;format, const Param1 &amp;p1)
+	{
+		log(group, CL_String::format(format, p1));
+	}
+
+	template&lt;class Param1, class Param2&gt;
+	static void log(const std::string &amp;group, const std::string &amp;format, const Param1 &amp;p1, const Param2 &amp;p2)
+	{
+		log(group, CL_String::format(format, p1, p2));
+	}
+
+	template&lt;class Param1, class Param2, class Param3&gt;
+	static void log(const std::string &amp;group, const std::string &amp;format, const Param1 &amp;p1, const Param2 &amp;p2, const Param3 &amp;p3)
+	{
+		log(group, CL_String::format(format, p1, p2, p3));
+	}
+
+	template&lt;class Param1, class Param2, class Param3, class Param4&gt;
+	static void log(const std::string &amp;group, const std::string &amp;format, const Param1 &amp;p1, const Param2 &amp;p2, const Param3 &amp;p3, const Param4 &amp;p4)
+	{
+		log(group, CL_String::format(format, p1, p2, p3, p4));
+	}
+
+	template&lt;class Param1, class Param2, class Param3, class Param4, class Param5&gt;
+	static void log(const std::string &amp;group, const std::string &amp;format, const Param1 &amp;p1, const Param2 &amp;p2, const Param3 &amp;p3, const Param4 &amp;p4, const Param5 &amp;p5)
+	{
+		log(group, CL_String::format(format, p1, p2, p3, p4, p5));
+	}
+
+	template&lt;class Param1, class Param2, class Param3, class Param4, class Param5, class Param6&gt;
+	static void log(const std::string &amp;group, const std::string &amp;format, const Param1 &amp;p1, const Param2 &amp;p2, const Param3 &amp;p3, const Param4 &amp;p4, const Param5 &amp;p5, const Param6 &amp;p6)
+	{
+		log(group, CL_String::format(format, p1, p2, p3, p4, p5, p6));
+	}
+
+	template&lt;class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7&gt;
+	static void log(const std::string &amp;group, const std::string &amp;format, const Param1 &amp;p1, const Param2 &amp;p2, const Param3 &amp;p3, const Param4 &amp;p4, const Param5 &amp;p5, const Param6 &amp;p6, const Param7 &amp;p7)
+	{
+		log(group, CL_String::format(format, p1, p2, p3, p4, p5, p6, p7));
+	}
+
+	template&lt;class Param1&gt;
+	static void log(const std::string &amp;group, int severity, const std::string &amp;format, const Param1 &amp;p1)
+	{
+		log(group, severity, CL_String::format(format, p1));
+	}
+
+	template&lt;class Param1, class Param2&gt;
+	static void log(const std::string &amp;group, int severity, const std::string &amp;format, const Param1 &amp;p1, const Param2 &amp;p2)
+	{
+		log(group, severity, CL_String::format(format, p1, p2));
+	}
+
+	template&lt;class Param1, class Param2, class Param3&gt;
+	static void log(const std::string &amp;group, int severity, const std::string &amp;format, const Param1 &amp;p1, const Param2 &amp;p2, const Param3 &amp;p3)
+	{
+		log(group, severity, CL_String::format(format, p1, p2, p3));
+	}
+
+	template&lt;class Param1, class Param2, class Param3, class Param4&gt;
+	static void log(const std::string &amp;group, int severity, const std::string &amp;format, const Param1 &amp;p1, const Param2 &amp;p2, const Param3 &amp;p3, const Param4 &amp;p4)
+	{
+		log(group, severity, CL_String::format(format, p1, p2, p3, p4));
+	}
+
+	template&lt;class Param1, class Param2, class Param3, class Param4, class Param5&gt;
+	static void log(const std::string &amp;group, int severity, const std::string &amp;format, const Param1 &amp;p1, const Param2 &amp;p2, const Param3 &amp;p3, const Param4 &amp;p4, const Param5 &amp;p5)
+	{
+		log(group, severity, CL_String::format(format, p1, p2, p3, p4, p5));
+	}
+
+	template&lt;class Param1, class Param2, class Param3, class Param4, class Param5, class Param6&gt;
+	static void log(const std::string &amp;group, int severity, const std::string &amp;format, const Param1 &amp;p1, const Param2 &amp;p2, const Param3 &amp;p3, const Param4 &amp;p4, const Param5 &amp;p5, const Param6 &amp;p6)
+	{
+		log(group, severity, CL_String::format(format, p1, p2, p3, p4, p5, p6));
+	}
+
+	template&lt;class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7&gt;
+	static void log(const std::string &amp;group, int severity, const std::string &amp;format, const Param1 &amp;p1, const Param2 &amp;p2, const Param3 &amp;p3, const Param4 &amp;p4, const Param5 &amp;p5, const Param6 &amp;p6, const Param7 &amp;p7)
+	{
+		log(group, severity, CL_String::format(format, p1, p2, p3, p4, p5, p6, p7));
+	}
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/API/Core/System/mutex.h
===================================================================
--- trunk/clanlib/API/Core/System/mutex.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/mutex.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,170 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;System&quot;
+//! header=core.h
+
+#ifndef header_mutex
+#define header_mutex
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+class CL_Mutex_Generic;
+
+//: Mutex interface.
+//- !group=Core/System!
+//- !header=core.h!
+//- &lt;p&gt;If you don't know what a mutex is, read a book. :-)&lt;/p&gt;
+class CL_API_CORE CL_Mutex
+{
+public:
+//! Construction:
+	//: Call this to create a mutex. (provided for 0.4 backward compatibility)
+	static CL_Mutex *create();
+
+	//: Construct a new mutex.
+	CL_Mutex();
+
+	//: Destroy mutex.
+	~CL_Mutex();
+	
+//! Operations:
+	//: Enter the critical section.
+	void enter();
+
+	//: Leave the critical section.
+	void leave();
+
+	//: Releases the mutex this thread has taken out and sends the
+	//: thread to sleep.
+	//- &lt;p&gt;Other threads can then acquire the mutex and
+	//- modify any data. When another thread calls notify, the thread
+	//- that called wait will wake up again and automatically reacquire
+	//- the mutex.&lt;/p&gt;
+	//-
+	//- &lt;p&gt;Warning: This function must not be called on an unlocked 
+	//- mutex. You must call enter first.&lt;/p&gt;
+	//-
+	//- &lt;p&gt;Warning: When wait returns (after another thread has called
+	//- notify/notifyAll, the current thread will have a mutex lock. Be
+	//- sure to call leave at some point.&lt;/p&gt;
+	//-
+	//- &lt;p&gt;Warning: Not implemented under Win32. If you need it,
+	//- please implement it in Sources/Core/System/Win32/mutex_win32.*,
+	//- and send me the patch. :-)&lt;/p&gt;
+	void wait();
+
+	//: Notify wakes up the first thread that has gone to sleep on this
+	//: mutex in order to wait for a notification.
+	//- &lt;p&gt;For safety reasons, you are advised to acquire the mutex
+	//- using 'enter' before calling notify. (Of course you have to
+	//- release the mutex using 'leave' after notifying, otherwise the
+	//- waiting thread cannot reacquire it).&lt;/p&gt;
+	//-
+	//- &lt;p&gt;Warning: Not implemented under Win32. If you need it,
+	//- please implement it in Sources/Core/System/Win32/mutex_win32.*,
+	//- and send me the patch. :-)&lt;/p&gt;
+	void notify();
+
+	//: NotifyAll wakes up all threads waiting on the mutex.
+	//- &lt;p&gt;Warning: Not implemented under Win32. If you need it,
+	//- please implement it in Sources/Core/System/Win32/mutex_win32.*,
+	//- and send me the patch. :-)&lt;/p&gt;
+	//also: CL_Mutex::notify
+	void notify_all();
+
+private:
+	// Disallow copy construction.
+	CL_Mutex(const CL_Mutex &amp;copy);
+
+	// Disallow mutex copy assignment.
+	void operator =(const CL_Mutex &amp;copy);
+
+	CL_Mutex_Generic *impl;
+};
+
+//: Lock a mutex until the end of a scope.
+//- &lt;p&gt;This class is a way to ensure a mutex will be released at the end of 
+//- a scope. When an instance is constructed, it will lock the mutex, and
+//- when the instance is destroyed (at the exit of its scope), it will
+//- unlock the mutex.&lt;/p&gt;
+class CL_MutexSection
+{
+//! Construction:
+public:
+	//: Mutex Section constructor.
+	CL_MutexSection(CL_Mutex *mutex, bool lock_at_construct = true)
+	: mutex(mutex), lock_count(0)
+	{
+		if (lock_at_construct) enter();
+	}
+
+	//: Mutex Section destructor.
+	virtual ~CL_MutexSection()
+	{
+		while (lock_count &gt; 0) leave();
+	}
+
+//! Operations:
+public:
+	//: Lock mutex.
+	void enter()
+	{
+		mutex-&gt;enter();
+		lock_count++;
+	}
+
+	//: Unlock mutex.
+	void leave()
+	{
+		if (lock_count == 0) return;
+		mutex-&gt;leave();
+		lock_count--;
+	}
+
+//! Implementation:
+private:
+	CL_Mutex *mutex;
+
+	int lock_count;
+};
+
+#endif

Added: trunk/clanlib/API/Core/System/mutexsharedptr.h
===================================================================
--- trunk/clanlib/API/Core/System/mutexsharedptr.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/mutexsharedptr.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,193 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;System&quot;
+//! header=core.h
+
+#ifndef clanlib_mutexsharedptr_header
+#define clanlib_mutexsharedptr_header
+
+#include &quot;mutex.h&quot;
+
+template &lt;typename TEvil&gt;
+class CL_MutexSharedPtr_Generic
+{
+public:
+	CL_MutexSharedPtr_Generic() : ptr(0), ref_count(1) { return; }
+
+	virtual ~CL_MutexSharedPtr_Generic() { return; }
+
+public:
+	//: Pointer to new-allocated data, or else 0:
+	TEvil *ptr;
+	
+	//: reference count:
+	unsigned int ref_count;
+
+	CL_Mutex mutex;
+};
+
+template &lt;typename T, typename TEvil&gt;
+class CL_MutexSharedPtr_Deleter : public CL_MutexSharedPtr_Generic&lt;T&gt;
+{
+public:
+	CL_MutexSharedPtr_Deleter(TEvil *e) { this-&gt;ptr = e; }
+
+	~CL_MutexSharedPtr_Deleter() { delete this-&gt;ptr; }
+};
+
+//: Mutex procted shared pointer class (automatically deletes data when all CL_MutexSharedPtrs to data are gone).
+//- !group=Core/System!
+//- !header=core.h!
+//- &lt;p&gt; Use CL_MutexSharedPtr when you have data that's intended to be shared between
+//- multiple users without each user needing an individual copy. &lt;/p&gt;
+//- &lt;p&gt; Note that CL_MutexSharedPtr uses a very simple reference counting system, so is susecptible
+//- to circular loop issues. &lt;/p&gt;
+//- &lt;p&gt; CL_MutexSharedPtr will guard its reference count with a mutex - so its threadsafe, unlike CL_SharedPtr.&lt;/p&gt;
+template &lt;typename T, typename U = T&gt;
+class CL_MutexSharedPtr
+{
+//! Construction:
+public:
+	//: Constructs a CL_MutexSharedPtr.
+	//param t: A pointer which was the return value of a 'new' call.
+	//- &lt;p&gt; After the CL_MutexSharedPtr has been constructed based on a passed pointer,
+	//- the CL_MutexSharedPtr takes full control over that data. The original pointer shouldn't
+	//- be used to access or delete the data anymore; instead, use the CL_MutexSharedPtr. &lt;/p&gt;
+	CL_MutexSharedPtr() : impl(0) { return; }
+
+	CL_MutexSharedPtr(const CL_MutexSharedPtr&lt;T, U&gt;&amp; other) : impl(other.impl) { increment(); }
+
+	template &lt;typename D&gt;
+	explicit CL_MutexSharedPtr(D* ptr) : impl(new CL_MutexSharedPtr_Deleter&lt;T, D&gt;(ptr)) { return; }
+
+	explicit CL_MutexSharedPtr(CL_MutexSharedPtr_Generic&lt;T&gt; *impl) : impl(impl) { increment(); }
+	
+	~CL_MutexSharedPtr() { decrement(); }
+	
+//! Attributes:
+public:
+	//: Returns true if this CL_MutexSharedPtr is not dereferencable.
+	bool is_null() const { return impl ? (impl-&gt;ptr == 0) : true; }
+
+	//: Returns number of references (including this one) to the data cache.
+	//- &lt;p&gt; Returns 0 if this pointer is null. &lt;/p&gt;
+	int get_ref_count() const { if (impl == 0) return 0; return impl-&gt;ref_count; }
+	
+	//: Gives access to the pointer itself.
+	//- &lt;p&gt; Be careful not to keep the returned pointer around after doing any
+	//- non-const operations on the CL_LazyCopyPtr; it could be invalid
+	//- after that.&lt;/p&gt;
+	U* get() { return (U*) ((impl != 0) ? impl-&gt;ptr : 0); }
+
+	const U* get() const { return (const U*) ((impl != 0) ? impl-&gt;ptr : 0); }
+
+	//: Return the pointer.
+	operator U*() { return get(); }
+
+	//: Returns the pointer.
+	operator const U*() const { return get(); }
+
+	//: Pointer equality check operator.
+	//- &lt;p&gt; This will return true if the CL_MutexSharedPtrs point to the same data. It doesn't
+	//- check the data itself for equality. &lt;/p&gt;
+	bool operator==(const T* other) const { return other == ((impl != 0) ? impl-&gt;ptr : 0); }
+
+	bool operator==(const CL_MutexSharedPtr&lt;T, U&gt;&amp; other) const { return other.impl == impl; }
+
+//! Operations:
+public:
+	//: Copy assignment operator.
+	//param t: A pointer which was the return value of a 'new' call.
+	//- &lt;p&gt; Once the assignment statement is finished when assigning a passed pointer,
+	//- the CL_MutexSharedPtr takes full control over that data. The original pointer shouldn't
+	//- be used to access or delete the data anymore; instead, use the CL_MutexSharedPtr. &lt;/p&gt;
+	CL_MutexSharedPtr&lt;T, U&gt;&amp; operator=(const CL_MutexSharedPtr&lt;T, U&gt;&amp; other)
+	{
+		if (other.impl != impl)
+		{
+			decrement();
+			impl = other.impl;
+			increment();
+		}
+		return *this;
+	}
+
+	template &lt;typename D&gt;
+	CL_MutexSharedPtr&lt;T, U&gt;&amp; operator=(D* t)
+	{
+		decrement();
+		impl = new CL_MutexSharedPtr_Deleter&lt;T, D&gt;(t);
+		return *this;
+	}
+	
+	//: Dereferencing operator.
+	U&amp; operator*() { return *((U*) impl-&gt;ptr); }
+
+	U const&amp; operator*() const { return *((const U*) impl-&gt;ptr); }
+	
+	//: Indirect member access operator.
+	U* operator-&gt;() { return (U*) impl-&gt;ptr; }
+
+	U const* operator-&gt;() const { return (const U*) impl-&gt;ptr; }
+
+	CL_MutexSharedPtr_Generic&lt;T&gt; *get_impl() { return impl; }
+
+//! Implementation:
+private:
+	// Shared data:
+	CL_MutexSharedPtr_Generic&lt;T&gt; *impl;
+	
+	//: Increases the ref count
+	void increment()
+	{
+		if (impl != 0)
+		{
+			CL_MutexSection lock(&amp;impl-&gt;mutex);
+			++impl-&gt;ref_count;
+		}
+	}
+	
+	//: Decreases the ref count, deletes entry and sets ptr to 0 if ptr_ref_count reaches zero
+	void decrement()
+	{
+		if (impl != 0)
+		{
+			CL_MutexSection lock(&amp;impl-&gt;mutex);
+			if (--impl-&gt;ref_count == 0)
+			{
+				lock.leave();
+				delete impl;
+				impl = 0;
+			}
+		}
+	}
+};
+
+#endif

Added: trunk/clanlib/API/Core/System/mutexweakptr.h
===================================================================
--- trunk/clanlib/API/Core/System/mutexweakptr.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/mutexweakptr.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,99 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;System&quot;
+//! header=core.h
+
+#ifndef clanlib_mutexweakptr_header
+#define clanlib_mutexweakptr_header
+
+#include &quot;sharedptr.h&quot;
+
+//: Weak pointer class (pointer to a CL_MutexSharedPtr object that dont increase reference count).
+//- !group=Core/System!
+//- !header=core.h!
+//- &lt;p&gt;Use CL_MutexWeakPtr when you want to have a pointer that is reference counted by CL_MutexSharedPtr
+//- but want a pointer that dont increase the reference count.&lt;/p&gt;
+//- &lt;p&gt;The purpose of CL_MutexWeakPtr is to avoid circular loop issues. By using CL_MutexWeakPtr you
+//- can construct new CL_MutexSharedPtr'ed objects based on the weak pointer.&lt;/p&gt;
+template &lt;typename T, typename U = T&gt;
+class CL_MutexWeakPtr
+{
+//! Construction:
+public:
+	CL_MutexWeakPtr() : impl(0) { return; }
+
+	CL_MutexWeakPtr(CL_MutexSharedPtr&lt;T, U&gt; &amp;other) : impl(other.get_impl()) { return; }
+
+//! Operations:
+public:
+	//: Returns true if this CL_MutexSharedPtr is not dereferencable.
+	bool is_null() const { return impl ? (impl-&gt;ptr == 0) : true; }
+
+	//: Returns number of references (including this one) to the data cache.
+	//- &lt;p&gt; Returns 0 if this pointer is null. &lt;/p&gt;
+	int get_ref_count() const { if (impl == 0) return 0; return impl-&gt;ref_count; }
+	
+	//: Gives access to the pointer itself.
+	//- &lt;p&gt; Be careful not to keep the returned pointer around after doing any
+	//- non-const operations on the CL_LazyCopyPtr; it could be invalid
+	//- after that.&lt;/p&gt;
+	U* get() { return (U*) ((impl != 0) ? impl-&gt;ptr : 0); }
+
+	const U* get() const { return (const U*) ((impl != 0) ? impl-&gt;ptr : 0); }
+
+	//: Returns the pointer.
+	operator const U*() const { return get(); }
+
+	//: Returns the pointer as a shared ptr.
+	operator CL_MutexSharedPtr&lt;T, U&gt;() const { return CL_MutexSharedPtr&lt;T, U&gt;(impl); }
+
+	//: Dereferencing operator.
+	U&amp; operator*() { return *((U*) impl-&gt;ptr); }
+
+	U const&amp; operator*() const { return *((const U*) impl-&gt;ptr); }
+	
+	//: Indirect member access operator.
+	U* operator-&gt;() { return (U*) impl-&gt;ptr; }
+
+	U const* operator-&gt;() const { return (const U*) impl-&gt;ptr; }
+
+	//: Pointer equality check operator.
+	//- &lt;p&gt; This will return true if the CL_MutexSharedPtrs point to the same data. It doesn't
+	//- check the data itself for equality. &lt;/p&gt;
+	bool operator==(const T* other) const { return other == ((impl != 0) ? impl-&gt;ptr : 0); }
+
+	bool operator==(const CL_MutexSharedPtr&lt;T, U&gt;&amp; other) const { return other.impl == impl; }
+
+//! Implementation:
+private:
+	CL_MutexSharedPtr_Generic&lt;T&gt; *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Core/System/owningptr.h
===================================================================
--- trunk/clanlib/API/Core/System/owningptr.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/owningptr.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,120 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;System&quot;
+//! header=core.h
+
+#ifndef clanlib_owningptr_header
+#define clanlib_owningptr_header
+
+//: Posessive pointer class (copying the pointer copies what it points to).
+//- !group=Core/System!
+//- !header=core.h!
+//- &lt;p&gt; Use CL_OwningPtr when you require the data to be on the heap, but otherwise
+//- want it to have very stack-instace-like semantics for copying, destruction, etc. &lt;/p&gt;
+template &lt;typename T, typename U = T&gt; class CL_OwningPtr
+{
+	//! Construction:
+	public:
+		//: Constructs a CL_OwningPtr.
+		//param t: A pointer which was the return value of a 'new' call.
+		//- &lt;p&gt; After the CL_OwningPtr has been constructed based on a passed pointer,
+		//- the CL_OwningPtr takes full control over that data. The original pointer shouldn't
+		//- be used to access or delete the data anymore; instead, use the CL_OwningPtr. &lt;/p&gt;
+		CL_OwningPtr() : ptr(0) {}
+		CL_OwningPtr(const CL_OwningPtr&lt;T, U&gt;&amp; other) : ptr((T*)(other.ptr-&gt;clone())) {}
+		CL_OwningPtr(T* t) : ptr(t) {}
+		
+		~CL_OwningPtr() {delete ptr;}
+	
+	//! Attributes:
+	public:		
+		//: Returns true if this CL_OwningPtr is not dereferencable.
+		bool is_null() const {if (ptr == 0) return true; return false;}
+		
+		//: Gives access to the pointer itself.
+		//- &lt;p&gt; Be careful not to keep the returned pointer around after doing any
+		//- non-const operations on the CL_LazyCopyPtr; it could be invalid
+		//- after that.&lt;/p&gt;
+		U* get() {return (U*)ptr;}
+		const U* get() const {return (const U*)ptr;}
+		
+	//! Operations:
+	public:	
+		//: Copy assignment operator.
+		//param t: A pointer which was the return value of a 'new' call.
+		//- &lt;p&gt; Once the assignment statement is finished when assigning a passed pointer,
+		//- the CL_OwningPtr takes full control over that data. The original pointer shouldn't
+		//- be used to access or delete the data anymore; instead, use the CL_OwningPtr. &lt;/p&gt;
+		CL_OwningPtr&lt;T, U&gt;&amp; operator=(const CL_OwningPtr&lt;T, U&gt;&amp; other)
+		{
+			if (&amp;other != this)
+			{
+				T* cpy;
+				if (other.ptr != 0)
+					cpy = (T*)(other.ptr-&gt;clone());
+				else
+					cpy = 0;
+				
+				delete ptr;
+				ptr = cpy;
+			}
+			
+			return *this;
+		}
+		CL_OwningPtr&lt;T, U&gt;&amp; operator=(T* t)
+		{
+			delete ptr;
+			ptr = t;
+			return *this;
+		}
+		
+		//: Dereferencing operator.
+		U&amp; operator*() {return *((U*)ptr);}
+		U const&amp; operator*() const {return *((const U*)ptr);}
+		
+		//: Forces a const dereference.
+		//- &lt;p&gt; Like operator*, but forces a const deref even if in non-const context. 
+		//- This is intended mostly to make it easy to exchange CL_OwningPtr and CL_LazyCopyPtr. &lt;/p&gt;
+		U const&amp; cd() const {return *((const U*)ptr);}
+		
+		//: Indirect member access operator.
+		U* operator-&gt;() {return (U*)ptr;}
+		U const* operator-&gt;() const {return (const U*)ptr;}
+	
+	//! Implementation:
+	private:
+		//Pointer to new-allocated data, or else 0
+		T* ptr;
+		
+		//Not to be called, this just ensures that T is derived from CL_Clonable
+		void dummy() { ptr-&gt;must_be_derived_from_cl_clonable(); }
+};
+
+#endif

Added: trunk/clanlib/API/Core/System/setupcore.h
===================================================================
--- trunk/clanlib/API/Core/System/setupcore.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/setupcore.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,91 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;System&quot;
+//! header=core.h
+
+#ifndef header_setupcore
+#define header_setupcore
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef WIN32
+#include &lt;windows.h&gt;
+#endif
+
+//: ClanCore initialization functions.
+//- !group=Core/System!
+//- !header=core.h!
+class CL_API_CORE CL_SetupCore
+{
+//! Construction:
+public:
+	//: Initializes clanCore.
+	//- &lt;p&gt;Constructing a CL_SetupCore object is equalent to calling CL_SetupCore::init().&lt;/p&gt;
+	//- &lt;p&gt;When the CL_SetupCore instance is destroyed, CL_SetupCore::deinit() is called.&lt;/p&gt;
+	CL_SetupCore(bool register_resources_only = false);
+
+	~CL_SetupCore();
+
+public:
+//! Operations:
+	//: Initialize clanCore.
+	//- &lt;p&gt;If you are using CL_ClanApplication to boot your
+	//- application, you do not need to call this function.&lt;/p&gt;
+	//- &lt;p&gt;If using Win32 (and without CL_ClanApplication) -
+	//- You must call CL_SetupCore::set_instance(HINSTANCE hInstance)
+	//- before this calling this function&lt;/p&gt;
+	static void init(bool register_resources_only = false);
+
+	//: Deinitialize clanCore.
+	//- &lt;p&gt;If you are using CL_ClanApplication to boot your
+	//- application, you do not need to call this function.&lt;/p&gt;
+	static void deinit();
+
+#ifdef WIN32
+	//: Set instance.
+	//- &lt;p&gt;If doing win32 initialization without using clanApp, you must call
+	//- this function before calling CL_SetupCore::init().&lt;/p&gt;
+	static void set_instance(HINSTANCE hInstance);
+#endif
+};
+
+#endif

Added: trunk/clanlib/API/Core/System/sharedptr.h
===================================================================
--- trunk/clanlib/API/Core/System/sharedptr.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/sharedptr.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,194 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;System&quot;
+//! header=core.h
+
+#ifndef clanlib_sharedptr_header
+#define clanlib_sharedptr_header
+
+template &lt;typename TEvil&gt;
+class CL_SharedPtr_Generic
+{
+public:
+	CL_SharedPtr_Generic() : ptr(0), ref_count(1) { return; }
+
+	virtual ~CL_SharedPtr_Generic() { return; }
+
+public:
+	//: Pointer to new-allocated data, or else 0:
+	TEvil *ptr;
+	
+	//: reference count:
+	unsigned int ref_count;
+};
+
+template &lt;typename T, typename TEvil&gt;
+class CL_SharedPtr_Deleter : public CL_SharedPtr_Generic&lt;T&gt;
+{
+public:
+	CL_SharedPtr_Deleter(TEvil *e) { this-&gt;ptr = e; }
+
+	~CL_SharedPtr_Deleter() { delete this-&gt;ptr; }
+};
+
+//: Shared pointer class (automatically deletes data when all CL_SharedPtrs to data are gone).
+//- !group=Core/System!
+//- !header=core.h!
+//- &lt;p&gt; Use CL_SharedPtr when you have data that's intended to be shared between
+//- multiple users without each user needing an individual copy. &lt;/p&gt;
+//- &lt;p&gt; Note that CL_SharedPtr uses a very simple reference counting system, so is susecptible
+//- to circular loop issues. &lt;/p&gt;
+template &lt;typename T, typename U = T&gt;
+class CL_SharedPtr
+{
+//! Construction:
+public:
+	//: Constructs a CL_SharedPtr.
+	//param t: A pointer which was the return value of a 'new' call.
+	//- &lt;p&gt; After the CL_SharedPtr has been constructed based on a passed pointer,
+	//- the CL_SharedPtr takes full control over that data. The original pointer shouldn't
+	//- be used to access or delete the data anymore; instead, use the CL_SharedPtr. &lt;/p&gt;
+	CL_SharedPtr() : impl(0) { return; }
+
+	CL_SharedPtr(const CL_SharedPtr&lt;T, U&gt;&amp; other) : impl(other.impl) { increment(); }
+
+	template &lt;typename D&gt;
+	explicit CL_SharedPtr(D* ptr) : impl(new CL_SharedPtr_Deleter&lt;T, D&gt;(ptr)) { return; }
+
+	explicit CL_SharedPtr(CL_SharedPtr_Generic&lt;T&gt; *impl) : impl(impl) { increment(); }
+	
+	~CL_SharedPtr() { decrement(); }
+	
+//! Attributes:
+public:
+	//: Returns true if this CL_SharedPtr is not dereferencable.
+	bool is_null() const { return impl ? (impl-&gt;ptr == 0) : true; }
+
+	//: Returns number of references (including this one) to the data cache.
+	//- &lt;p&gt; Returns 0 if this pointer is null. &lt;/p&gt;
+	int get_ref_count() const { if (impl == 0) return 0; return impl-&gt;ref_count; }
+	
+	//: Gives access to the pointer itself.
+	//- &lt;p&gt; Be careful not to keep the returned pointer around after doing any
+	//- non-const operations on the CL_LazyCopyPtr; it could be invalid
+	//- after that.&lt;/p&gt;
+	U* get() { return (U*) ((impl != 0) ? impl-&gt;ptr : 0); }
+
+	U const* get() const { return (const U*) ((impl != 0) ? impl-&gt;ptr : 0); }
+
+	//: Return the pointer.
+	operator U*() { return get(); }
+
+	//: Returns the pointer.
+	operator U const*() const { return get(); }
+
+	//: Pointer equality check operator.
+	//- &lt;p&gt; This will return true if the CL_SharedPtrs point to the same data. It doesn't
+	//- check the data itself for equality. &lt;/p&gt;
+	bool operator==(const T* other) const { return other == ((impl != 0) ? impl-&gt;ptr : 0); }
+
+	bool operator==(const CL_SharedPtr&lt;T, U&gt;&amp; other) const { return other.impl == impl; }
+
+	//: reelase the content of the CL_SharedPtr
+	//- &lt;p&gt; Decrements the reference count and sets the data pointer to null.
+	//- This is usefull for solving circular references&lt;/p&gt;
+	void release (void) 
+	{
+		if (impl!= 0)
+		{
+			decrement ();
+			impl = 0;
+		}
+	}
+//! Operations:
+public:
+	//: Copy assignment operator.
+	//param t: A pointer which was the return value of a 'new' call.
+	//- &lt;p&gt; Once the assignment statement is finished when assigning a passed pointer,
+	//- the CL_SharedPtr takes full control over that data. The original pointer shouldn't
+	//- be used to access or delete the data anymore; instead, use the CL_SharedPtr. &lt;/p&gt;
+	CL_SharedPtr&lt;T, U&gt;&amp; operator=(const CL_SharedPtr&lt;T, U&gt;&amp; other)
+	{
+		if (other.impl != impl)
+		{
+			decrement();
+			impl = other.impl;
+			increment();
+		}
+		return *this;
+	}
+
+	template &lt;typename D&gt;
+	CL_SharedPtr&lt;T, U&gt;&amp; operator=(D* t)
+	{
+		decrement();
+		impl = new CL_SharedPtr_Deleter&lt;T, D&gt;(t);
+		return *this;
+	}
+	
+	//: Dereferencing operator.
+	U&amp; operator*() { return *((U*) impl-&gt;ptr); }
+
+	U const&amp; operator*() const { return *((const U*) impl-&gt;ptr); }
+	
+	//: Indirect member access operator.
+	U* operator-&gt;() { return (U*) impl-&gt;ptr; }
+
+	U const* operator-&gt;() const { return (const U*) impl-&gt;ptr; }
+
+	CL_SharedPtr_Generic&lt;T&gt; *get_impl() { return impl; }
+
+//! Implementation:
+private:
+	// Shared data:
+	CL_SharedPtr_Generic&lt;T&gt; *impl;
+	
+	//: Increases the ref count
+	void increment()
+	{
+		if (impl != 0)
+			++impl-&gt;ref_count;
+	}
+	
+	//: Decreases the ref count, deletes entry and sets ptr to 0 if ptr_ref_count reaches zero
+	void decrement()
+	{
+		if (impl != 0)
+		{
+			if (--impl-&gt;ref_count == 0)
+			{
+				delete impl;
+				impl = 0;
+			}
+		}
+	}
+};
+
+#endif

Added: trunk/clanlib/API/Core/System/system.h
===================================================================
--- trunk/clanlib/API/Core/System/system.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/system.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,123 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;System&quot;
+//! header=core.h
+
+#ifndef header_system
+#define header_system
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+
+class CL_EventListener;
+class CL_Signal_v0;
+
+//: Generic functions that didn't fit in other places.
+//- !group=Core/System!
+//- !header=core.h!
+class CL_API_CORE CL_System
+{
+//! Attributes:
+public:
+	//: Get the current time (since system boot), in milliseconds, including effects of suspend_time()
+	static unsigned int get_time();
+	
+	//: Returns true if MMX technology is available on this CPU.
+	static bool detect_mmx();
+	
+	//: Returns true if 3DNow! technology is available on this CPU.
+	static bool detect_3dnow();
+
+	//: Returns true if extended 3DNow! is present on this CPU.
+	static bool detect_ext_3dnow();
+
+//! Operations:
+public:
+	//: Checks for system events, updates input and other stuff.
+	static void keep_alive();
+
+	//: Checks for system events (pump the CL_KeepAlive objects).
+	//- &lt;p&gt;Return when 'millis' has elapsed.&lt;/p&gt;
+	static void keep_alive(int millis);
+
+	//: Checks for system events (pump the CL_KeepAlive objects).
+	//- &lt;p&gt;Return when one of the events trigger, or when timeout has elapsed.&lt;/p&gt;
+	static bool keep_alive(CL_EventListener &amp;events, int timeout = -1);
+
+	//: Sleep for 'millis' milliseconds.
+	static void sleep(int millis);
+
+	//: Suspend the time.
+	//- &lt;p&gt;get_time() will continue to return the same value until resume_time() is called.&lt;/p&gt;
+	static void suspend_time();
+
+	//: Resumes the time.
+	//- &lt;p&gt;get_time() will return the current time again.&lt;/p&gt;
+	static void resume_time();
+	
+	//: Returns the full dirname of the executable that started this
+	//: process (aka argv[0])
+	//- &lt;p&gt;This is necessary since when programms are started from
+	//- the PATH there is no clean and simple way to figure out
+	//- the location of the data files, thus information is read
+	//- from &lt;tt&gt;/proc/self/exe&lt;/tt&gt; under GNU/Linux and from
+	//- GetModuleFileName() on Win32.&lt;/p&gt;
+        //return: full dirname of the executable, trailing slash is included
+	static std::string get_exe_path();
+
+//! Implementation:
+private:
+	//Starting sys_time() of the least recently started but still active suspend
+	static unsigned int susp_start;
+
+	//Number of active suspends
+	static unsigned int susp_cnt;
+
+	//Time taken up by suspends that occurred before
+	static unsigned int susp_accum;
+	
+	//Done by platform-specific stuff, returns the cur time without dealing with any of this suspend/resume stuff
+	static unsigned int sys_time();
+};
+
+#endif

Added: trunk/clanlib/API/Core/System/thread.h
===================================================================
--- trunk/clanlib/API/Core/System/thread.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/thread.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,170 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;System&quot;
+//! header=core.h
+
+#ifndef header_thread
+#define header_thread
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+class CL_Thread_Generic;
+class CL_ThreadId_Generic;
+
+//: Thread callback interface.
+//- !group=Core/System!
+//- !header=core.h!
+//- &lt;p&gt;When a thread is created, it will call run() in its attached CL_Runnable interface.&lt;/p&gt;
+class CL_Runnable
+{
+//! Construction:
+public:
+	virtual ~CL_Runnable() { return; }
+
+public:
+//! Overrideables:
+	//: Called when a thread is run.
+	virtual void run()=0;
+};
+
+//: Thread Priority Enum
+//- !group=Core/System!
+//- !header=core.h!
+enum EThreadPriority
+{
+	cl_priority_above_normal,
+	cl_priority_below_normal,
+	cl_priority_highest,
+	cl_priority_idle,
+	cl_priority_lowest,
+	cl_priority_normal,
+	cl_priority_time_critical
+};
+
+//: ThreadId Class
+//- !group=Core/System!
+//- !header=core.h!
+class CL_API_CORE CL_ThreadId
+{
+//! Construction:
+public:
+	//: Create a ThreadId.
+	CL_ThreadId();
+
+	CL_ThreadId(const CL_ThreadId &amp;copy);
+
+	//: Destructor.
+	~CL_ThreadId();
+
+//! Operations:
+public:
+	CL_ThreadId &amp;operator =(const CL_ThreadId &amp;copy);
+
+	bool operator ==(const CL_ThreadId &amp;cmp) const;
+
+	bool operator !=(const CL_ThreadId &amp;cmp) const;
+
+	bool operator &lt;(const CL_ThreadId &amp;cmp) const;
+	
+//! Implementation:
+private:
+	CL_ThreadId_Generic *impl;
+};
+
+//: Thread Class
+//- !group=Core/System!
+//- !header=core.h!
+class CL_API_CORE CL_Thread
+{
+//! Construction:
+public:
+	//: Create a thread.
+	//param runnable: CL_Runnable object to be used as the thread run function.
+	//param delete_runnable: If true, deletes the CL_Runnable object, when CL_Thread is destroyed.
+	//param func: Callback function used as the thread run function. Example: int my_callback(void *value).
+	//param value: Value parameter passed to callback function.
+	CL_Thread(CL_Runnable *runnable, bool delete_runnable = false);
+
+	CL_Thread(int (*func)(void*), void *value);
+
+	CL_Thread(const CL_Thread &amp;copy);
+
+	CL_Thread();
+	
+	//: Destructor.
+	~CL_Thread();
+	
+//! Attributes:
+public:
+	//: Returns the thread ID of the calling thread.
+	static CL_ThreadId get_current_id();
+	
+//! Operations:
+public:
+	//: Copy assignement operator.
+	CL_Thread &amp;operator =(const CL_Thread &amp;copy);
+
+	//: Starts the thread.
+	void start();
+
+	//: Terminate the thread. (use with caution under win98)
+	void terminate();
+
+	//: Wait until the thread finishes its execution.
+	void wait();
+
+	//: Set the thread priority.
+	void set_priority(EThreadPriority priority);
+
+//! Implementation:
+private:
+	CL_Thread_Generic *impl;
+};
+
+// Add support for doing cross platform Thread Local Storage variables:
+#ifdef MSVC
+	#define CL_TLS __declspec(thread)
+#else
+	#define CL_TLS __thread
+#endif
+
+#endif

Added: trunk/clanlib/API/Core/System/threadfunc_v0.h
===================================================================
--- trunk/clanlib/API/Core/System/threadfunc_v0.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/threadfunc_v0.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,90 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_threadfunc_v0
+#define header_threadfunc_v0
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;thread.h&quot;
+
+template&lt;class Class&gt;
+class CL_ThreadFunc_Runnable_v0 : public CL_Runnable
+{
+public:
+	typedef void (Class::*MemberFunc)();
+
+	CL_ThreadFunc_Runnable_v0(Class *self, MemberFunc func)
+	: self(self), func(func)
+	{
+	}
+
+private:
+	virtual void run()
+	{
+		(*self.*func)();
+	}
+
+	Class *self;
+	MemberFunc func;
+};
+
+//: Member function based thread callback interface.
+//- &lt;p&gt;The CL_ThreadFunc_v0&lt;MyClass&gt; is an interface used to call a member function
+//- in a new thread.&lt;/p&gt;
+//-
+//- Following code demonstrates how it is used:
+//- &lt;code&gt;
+//- class MyClass
+//- {
+//-   CL_Thread thread;
+//-
+//-   MyClass() : thread(CL_ThreadFunc_v0(this, MyClass::worker_function))
+//-   {
+//-     thread.start();
+//-   }
+//-
+//-   void worker_function() { return; }
+//- };
+//- &lt;/code&gt;&lt;/p&gt;
+#define CL_ThreadFunc_v0(a, b) CL_Thread(new CL_ThreadFunc_Runnable_v0(a, b), true)
+
+/* Following code procudes internal compiler error with msvc++
+template&lt;class Class&gt;
+CL_Thread CL_ThreadFunc_v0(
+	Class *self,
+	CL_ThreadFunc_Runnable_v0&lt;Class&gt;::MemberFunc func)
+{
+	return CL_Thread(new CL_ThreadFunc_Runnable_v0&lt;Class&gt;(self, func), true);
+}
+*/
+
+#endif

Added: trunk/clanlib/API/Core/System/threadfunc_v1.h
===================================================================
--- trunk/clanlib/API/Core/System/threadfunc_v1.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/threadfunc_v1.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,92 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_threadfunc_v1
+#define header_threadfunc_v1
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;thread.h&quot;
+
+template&lt;class Class, class Param&gt;
+class CL_ThreadFunc_Runnable_v1 : public CL_Runnable
+{
+public:
+	typedef void (Class::*MemberFunc)(Param &amp;param);
+
+	CL_ThreadFunc_Runnable_v1(Class *self, MemberFunc func, const Param &amp;param)
+	: self(self), func(func), param(param)
+	{
+	}
+
+private:
+	virtual void run()
+	{
+		(*self.*func)(param);
+	}
+
+	Class *self;
+	MemberFunc func;
+	Param param;
+};
+
+//: Member function based thread callback interface.
+//- &lt;p&gt;The CL_ThreadFunc_v1&lt;MyClass, MyParam&gt; is an interface used to call a member function
+//- in a new thread.&lt;/p&gt;
+//-
+//- &lt;p&gt;Following code demonstrates how it is used:
+//- &lt;code&gt;
+//- class MyClass
+//- {
+//-   CL_Thread thread;
+//-
+//-   MyClass() : thread(CL_ThreadFunc_v1(this, MyClass::worker_function, 15))
+//-   {
+//-     thread.start();
+//-   }
+//-
+//-   void worker_function(int value) { assert(value == 15); }
+//- };
+//- &lt;/code&gt;&lt;/p&gt;
+#define CL_ThreadFunc_v1(a, b, c) CL_Thread(new CL_ThreadFunc_Runnable_v1(a, b, c), true)
+
+/* Following code procudes internal compiler error with msvc++
+template&lt;class Class, class Param&gt;
+CL_Thread CL_ThreadFunc_v1(
+	Class *self,
+	CL_ThreadFunc_Runnable_v1&lt;Class, Param&gt;::MemberFunc func,
+	const Param &amp;param)
+{
+	return CL_Thread(new CL_ThreadFunc_Runnable_v1&lt;Class, Param&gt;(self, func, param), true);
+}
+*/
+
+#endif

Added: trunk/clanlib/API/Core/System/threadfunc_v2.h
===================================================================
--- trunk/clanlib/API/Core/System/threadfunc_v2.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/threadfunc_v2.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,94 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_threadfunc_v2
+#define header_threadfunc_v2
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;thread.h&quot;
+
+template&lt;class Class, class Param1, class Param2&gt;
+class CL_ThreadFunc_Runnable_v2 : public CL_Runnable
+{
+public:
+	typedef void (Class::*MemberFunc)(Param1 &amp;param1, Param2 &amp;param2);
+
+	CL_ThreadFunc_Runnable_v2(Class *self, MemberFunc func, const Param1 &amp;param1, const Param2 &amp;param2)
+	: self(self), func(func), param1(param1), param2(param2)
+	{
+	}
+
+private:
+	virtual void run()
+	{
+		(*self.*func)(param1, param2);
+	}
+
+	Class *self;
+	MemberFunc func;
+	Param1 param1;
+	Param2 param2;
+};
+
+//: Member function based thread callback interface.
+//- &lt;p&gt;The CL_ThreadFunc_v2&lt;MyClass, MyParam1, MyParam2&gt; is an interface used to call a member function
+//- in a new thread.&lt;/p&gt;
+//-
+//- &lt;p&gt;Following code demonstrates how it is used:
+//- &lt;code&gt;
+//- class MyClass
+//- {
+//-   CL_Thread thread;
+//-
+//-   MyClass() : thread(CL_ThreadFunc_v2(this, MyClass::worker_function, 15, 16))
+//-   {
+//-     thread.start();
+//-   }
+//-
+//-   void worker_function(int value1, int value2) { assert(value1 == 15 &amp;&amp; value2 == 16); }
+//- };
+//- &lt;/code&gt;&lt;/p&gt;
+#define CL_ThreadFunc_v2(a, b, c, d) CL_Thread(new CL_ThreadFunc_Runnable_v1(a, b, c, d), true)
+
+/* Following code procudes internal compiler error with msvc++
+template&lt;class Class, class Param1, class Param2&gt;
+CL_Thread CL_ThreadFunc_v2(
+	Class *self,
+	CL_ThreadFunc_Runnable_v2&lt;Class, Param1, Param2&gt;::MemberFunc func,
+	const Param1 &amp;param1,
+	const Param2 &amp;param2)
+{
+	return CL_Thread(new CL_ThreadFunc_Runnable_v2&lt;Class, Param1, Param2&gt;(self, func, param1, param2), true);
+}
+*/
+
+#endif

Added: trunk/clanlib/API/Core/System/timer.h
===================================================================
--- trunk/clanlib/API/Core/System/timer.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/timer.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,103 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;System&quot;
+//! header=core.h
+
+#ifndef header_timer
+#define header_timer
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;keep_alive.h&quot;
+#include &quot;../../signals.h&quot;
+
+//: Timer signal emitter.
+//- !group=Core/System!
+//- !header=core.h!
+//- &lt;p&gt;Use this class to emit a signal as a timer event.&lt;/p&gt;
+class CL_API_CORE CL_Timer : public CL_KeepAlive
+{
+//! Construction:
+public:
+	//: Constructs and registers the timer as a keep alive listener.
+	//- &lt;p&gt;Note that it is disabled by default, so you need to enable() it.&lt;/p&gt;
+	//param interval: Interval in millisecs between each signal emit.
+	CL_Timer(unsigned long interval = 1000);
+	
+//! Attributes:
+public:
+	//: Returns the current time interval.
+	//return: The current time interval.
+	unsigned long get_interval();
+
+	//: Returns true if the timer is enabled, false otherwise.
+	bool is_enabled();
+
+//! Operations:
+public:
+	//: Sets a new interval for the timer.
+	//param interval: Interval in millisecs between each signal emit.
+	void set_interval(unsigned long interval);
+
+	//: Call this function to enable the timer.
+	void enable();
+	
+	//: Call this function to disable the timer.
+	void disable();
+	
+//! Signals:
+public:
+	//: Signal emitted everytime the interval has elapsed.
+	CL_Signal_v0 &amp;sig_timer();
+	
+//! Implementation:
+private:
+	virtual void keep_alive();
+
+	unsigned long interval;
+	unsigned long last_time;
+	bool enabled;
+
+	CL_Signal_v0 signal_timer;
+};
+
+#endif

Added: trunk/clanlib/API/Core/System/weakptr.h
===================================================================
--- trunk/clanlib/API/Core/System/weakptr.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/System/weakptr.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,99 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;System&quot;
+//! header=core.h
+
+#ifndef clanlib_weakptr_header
+#define clanlib_weakptr_header
+
+#include &quot;sharedptr.h&quot;
+
+//: Weak pointer class (pointer to a CL_SharedPtr object that dont increase reference count).
+//- !group=Core/System!
+//- !header=core.h!
+//- &lt;p&gt;Use CL_WeakPtr when you want to have a pointer that is reference counted by CL_SharedPtr
+//- but want a pointer that dont increase the reference count.&lt;/p&gt;
+//- &lt;p&gt;The purpose of CL_WeakPtr is to avoid circular loop issues. By using CL_WeakPtr you
+//- can construct new CL_SharedPtr'ed objects based on the weak pointer.&lt;/p&gt;
+template &lt;typename T, typename U = T&gt;
+class CL_WeakPtr
+{
+//! Construction:
+public:
+	CL_WeakPtr() : impl(0) { return; }
+
+	CL_WeakPtr(CL_SharedPtr&lt;T, U&gt; &amp;other) : impl(other.get_impl()) { return; }
+
+//! Operations:
+public:
+	//: Returns true if this CL_SharedPtr is not dereferencable.
+	bool is_null() const { return impl ? (impl-&gt;ptr == 0) : true; }
+
+	//: Returns number of references (including this one) to the data cache.
+	//- &lt;p&gt; Returns 0 if this pointer is null. &lt;/p&gt;
+	int get_ref_count() const { if (impl == 0) return 0; return impl-&gt;ref_count; }
+	
+	//: Gives access to the pointer itself.
+	//- &lt;p&gt; Be careful not to keep the returned pointer around after doing any
+	//- non-const operations on the CL_LazyCopyPtr; it could be invalid
+	//- after that.&lt;/p&gt;
+	U* get() { return (U*) ((impl != 0) ? impl-&gt;ptr : 0); }
+
+	const U* get() const { return (const U*) ((impl != 0) ? impl-&gt;ptr : 0); }
+
+	//: Returns the pointer.
+	operator const U*() const { return get(); }
+
+	//: Returns the pointer as a shared ptr.
+	operator CL_SharedPtr&lt;T, U&gt;() const { return CL_SharedPtr&lt;T, U&gt;(impl); }
+
+	//: Dereferencing operator.
+	U&amp; operator*() { return *((U*) impl-&gt;ptr); }
+
+	U const&amp; operator*() const { return *((const U*) impl-&gt;ptr); }
+	
+	//: Indirect member access operator.
+	U* operator-&gt;() { return (U*) impl-&gt;ptr; }
+
+	U const* operator-&gt;() const { return (const U*) impl-&gt;ptr; }
+
+	//: Pointer equality check operator.
+	//- &lt;p&gt; This will return true if the CL_SharedPtrs point to the same data. It doesn't
+	//- check the data itself for equality. &lt;/p&gt;
+	bool operator==(const T* other) const { return other == ((impl != 0) ? impl-&gt;ptr : 0); }
+
+	bool operator==(const CL_SharedPtr&lt;T, U&gt;&amp; other) const { return other.impl == impl; }
+
+//! Implementation:
+private:
+	CL_SharedPtr_Generic&lt;T&gt; *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Core/XML/dom_attr.h
===================================================================
--- trunk/clanlib/API/Core/XML/dom_attr.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/XML/dom_attr.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,123 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;XML&quot;
+//! header=core.h
+
+#ifndef header_dom_attr
+#define header_dom_attr
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;dom_node.h&quot;
+
+//: DOM Attribute class.
+//- !group=Core/XML!
+//- !header=core.h!
+//- &lt;p&gt;The Attr interface represents an attribute in an Element object. Typically
+//- the allowable values for the attribute are defined in a document type definition.&lt;/p&gt;
+//- &lt;p&gt;Attr objects inherit the Node interface, but since they are not actually child
+//- nodes of the element they describe, the DOM does not consider them part of the
+//- document tree. Thus, the Node attributes parentNode, previousSibling, and nextSibling
+//- have a null value for Attr objects. The DOM takes the view that attributes are
+//- properties of elements rather than having a separate identity from the elements
+//- they are associated with; this should make it more efficient to implement such
+//- features as default attributes associated with all elements of a given type. Furthermore,
+//- Attr nodes may not be immediate children of a DocumentFragment. However, they can
+//- be associated with Element nodes contained within a DocumentFragment. In short,
+//- users and implementors of the DOM need to be aware that Attr nodes have some
+//- things in common with other objects inheriting the Node interface, but they also
+//- are quite distinct.&lt;/p&gt;
+//- &lt;p&gt;The attribute's effective value is determined as follows: if this attribute
+//- has been explicitly assigned any value, that value is the attribute's effective
+//- value; otherwise, if there is a declaration for this attribute, and that declaration
+//- includes a default value, then that default value is the attribute's effective value;
+//- otherwise, the attribute does not exist on this element in the structure model until
+//- it has been explicitly added. Note that the nodeValue attribute on the Attr instance
+//- can also be used to retrieve the string version of the attribute's value(s).&lt;/p&gt;
+//- &lt;p&gt;In XML, where the value of an attribute can contain entity references, the child
+//- nodes of the Attr node provide a representation in which entity references are not
+//- expanded. These child nodes may be either Text or EntityReference nodes. Because the
+//- attribute type may be unknown, there are no tokenized attribute values.&lt;/p&gt;
+class CL_API_CORE CL_DomAttr : public CL_DomNode
+{
+//! Construction:
+public:
+	//: Constructs a DOM Attr handle.
+	CL_DomAttr();
+	
+	CL_DomAttr(CL_DomDocument doc, const std::string &amp;name);
+
+	CL_DomAttr(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl);
+	
+	~CL_DomAttr();
+
+//! Attributes:
+public:
+	//: Returns the name of this attribute.
+	std::string get_name() const;
+
+	//: If this attribute was explicitly given a value in the original document, this is true; otherwise, it is false.
+	//- &lt;ul&gt;
+	//- &lt;li&gt;If the attribute has an assigned value in the document then specified is true,
+	//- and the value is the assigned value.&lt;/li&gt;
+	//- &lt;li&gt;If the attribute has no assigned value in the document and has a default value
+	//- in the DTD, then specified is false, and the value is the default value in the DTD.&lt;/li&gt;
+	//- &lt;li&gt;If the attribute has no assigned value in the document and has a value of #IMPLIED
+	//- in the DTD, then the attribute does not appear in the structure model of the document.&lt;/li&gt;
+	//- &lt;/ul&gt;
+	bool get_specified() const;
+	
+	//: Returns the value of the attribute.
+	std::string get_value() const;
+
+	//: Sets the value of the attribute.
+	void set_value(const std::string &amp;value);
+
+//! Operations:
+public:
+
+//! Implementation:
+private:
+	friend class CL_DomElement;
+};
+
+#endif

Added: trunk/clanlib/API/Core/XML/dom_cdata_section.h
===================================================================
--- trunk/clanlib/API/Core/XML/dom_cdata_section.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/XML/dom_cdata_section.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,88 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;XML&quot;
+//! header=core.h
+
+#ifndef header_dom_cdata_section
+#define header_dom_cdata_section
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;dom_text.h&quot;
+
+//: DOM CDATA Section.
+//- !group=Core/XML!
+//- !header=core.h!
+//- &lt;p&gt;CDATA sections are used to escape blocks of text containing characters that would
+//- otherwise be regarded as markup. The only delimiter that is recognized in a CDATA
+//- section is the &quot;]]&gt;&quot; string that ends the CDATA section. CDATA sections can not be
+//- nested. The primary purpose is for including material such as XML fragments, without
+//- needing to escape all the delimiters.&lt;/p&gt;
+//- &lt;p&gt;The DOMString attribute of the Text node holds the text that is contained by the
+//- CDATA section. Note that this may contain characters that need to be escaped outside
+//- of CDATA sections and that, depending on the character encoding (&quot;charset&quot;) chosen
+//- for serialization, it may be impossible to write out some characters as part of a
+//- CDATA section.&lt;/p&gt;
+//- &lt;p&gt;The CDATASection interface inherits the CharacterData interface through the Text
+//- interface. Adjacent CDATASections nodes are not merged by use of the Element.normalize()
+//- method.&lt;/p&gt;
+class CL_API_CORE CL_DomCDATASection : public CL_DomText
+{
+//! Construction:
+public:
+	//: Constructs a DOM CDATA Section handle.
+	CL_DomCDATASection();
+
+	CL_DomCDATASection(CL_DomDocument &amp;doc, const std::string &amp;data);
+
+	CL_DomCDATASection(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl);
+	
+	~CL_DomCDATASection();
+
+//! Attributes:
+public:
+
+//! Operations:
+public:
+};
+
+#endif

Added: trunk/clanlib/API/Core/XML/dom_character_data.h
===================================================================
--- trunk/clanlib/API/Core/XML/dom_character_data.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/XML/dom_character_data.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,109 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;XML&quot;
+//! header=core.h
+
+#ifndef header_dom_character_data
+#define header_dom_character_data
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;dom_node.h&quot;
+
+//: DOM Character Data class.
+//- !group=Core/XML!
+//- !header=core.h!
+//- &lt;p&gt;The CharacterData interface extends Node with a set of attributes and methods
+//- for accessing character data in the DOM. For clarity this set is defined here
+//- rather than on each object that uses these attributes and methods. No DOM objects
+//- correspond directly to CharacterData, though Text and others do inherit the
+//- interface from it.&lt;/p&gt;
+class CL_API_CORE CL_DomCharacterData : public CL_DomNode
+{
+//! Construction:
+public:
+	//: Constructs a DOM CharacterData handle.
+	CL_DomCharacterData();
+
+	CL_DomCharacterData(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl);
+	
+	~CL_DomCharacterData();
+	
+//! Attributes:
+public:
+	//: The number of characters that are available through data and the substringData method below.
+	//- &lt;p&gt;This may have the value zero, i.e., CharacterData nodes may be empty.&lt;/p&gt;
+	unsigned long get_length();
+
+//! Operations:
+public:
+	//: Extracts a range of data from the node.
+	//param offset: Start offset of substring to extract.
+	//param count: The number of characters to extract.
+	//retval: The specified substring. If the sum of offset and count exceeds the length, then all characters to the end of the data are returned.
+	std::string substring_data(unsigned long offset, unsigned long count);
+
+	//: Append the string to the end of the character data of the node.
+	void append_data(const std::string &amp;arg);
+
+	//: Insert a string at the specified character offset.
+	//param offset: The character offset at which to insert.
+	//param arg: The DOMString to insert.
+	void insert_data(unsigned long offset, const std::string &amp;arg);
+
+	//: Remove a range of characters from the node.
+	//param offset: The offset from which to remove characters.
+	//param count: The number of characters to delete. If the sum of offset and count exceeds length then all characters from offset to the end of the data are deleted.
+	void delete_data(unsigned long offset, unsigned long count);
+
+	//: Replace the characters starting at the specified character offset with the specified string.
+	//param offset: The offset from which to start replacing.
+	//param count: The number of characters to replace. If the sum of offset and count exceeds length, then all characters to the end of the data are replaced (i.e., the effect is the same as a remove method call with the same range, followed by an append method invocation).
+	//param arg: The DOMString with which the range must be replaced.
+	void replace_data(unsigned long offset, unsigned long count, const std::string &amp;arg);
+
+//! Implementation:
+protected:
+	CL_DomCharacterData(CL_DomDocument &amp;doc, unsigned short node_type);
+};
+
+#endif

Added: trunk/clanlib/API/Core/XML/dom_comment.h
===================================================================
--- trunk/clanlib/API/Core/XML/dom_comment.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/XML/dom_comment.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,78 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;XML&quot;
+//! header=core.h
+
+#ifndef header_dom_comment
+#define header_dom_comment
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;dom_character_data.h&quot;
+
+//: DOM Comment class.
+//- !group=Core/XML!
+//- !header=core.h!
+//- &lt;p&gt;This represents the content of a comment, i.e., all the characters between the starting
+//- '&lt;!--' and ending '--&gt;'. Note that this is the definition of a comment in XML, and,
+//- in practice, HTML, although some HTML tools may implement the full SGML comment structure.&lt;/p&gt;
+class CL_API_CORE CL_DomComment : public CL_DomCharacterData
+{
+//! Construction:
+public:
+	//: Constructs a DOM Comment handle.
+	CL_DomComment();
+
+	CL_DomComment(CL_DomDocument &amp;doc, const std::string &amp;data);
+
+	CL_DomComment(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl);
+	
+	~CL_DomComment();
+
+//! Attributes:
+public:
+
+//! Operations:
+public:
+};
+
+#endif

Added: trunk/clanlib/API/Core/XML/dom_document.h
===================================================================
--- trunk/clanlib/API/Core/XML/dom_document.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/XML/dom_document.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,175 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;XML&quot;
+//! header=core.h
+
+#ifndef header_dom_document
+#define header_dom_document
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;dom_node.h&quot;
+
+class CL_InputSource;
+class CL_OutputSource;
+class CL_DomDocumentType;
+class CL_DomImplementation;
+class CL_DomCDATASection;
+class CL_DomProcessingInstruction;
+class CL_DomElement;
+class CL_DomDocumentFragment;
+class CL_DomComment;
+class CL_DomText;
+class CL_DomAttr;
+class CL_DomEntityReference;
+class CL_DomNodeList;
+class CL_DomDocument_Generic;
+
+//: DOM Document class.
+//- !group=Core/XML!
+//- !header=core.h!
+//- &lt;p&gt;The Document interface represents the entire HTML or XML document.
+//- Conceptually, it is the root of the document tree, and provides the
+//- primary access to the document's data.&lt;/p&gt;
+//- &lt;p&gt;Since elements, text nodes, comments, processing instructions, etc.
+//- cannot exist outside the context of a Document, the Document interface
+//- also contains the factory methods needed to create these objects. The
+//- Node objects created have a ownerDocument attribute which associates
+//- them with the Document within whose context they were created.&lt;/p&gt;
+class CL_API_CORE CL_DomDocument : public CL_DomNode
+{
+//! Construction:
+public:
+	//: Constructs a DOM Document.
+	CL_DomDocument();
+
+	CL_DomDocument(CL_InputSource *input, bool delete_input = false, bool eat_whitespace = true);
+
+	CL_DomDocument(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl);
+	
+	~CL_DomDocument();
+	
+//! Attributes:
+public:
+	//: Returns the Document Type Declaration (see CL_DomDocumentType)associated with this document.
+	//- &lt;p&gt;For HTML documents as well as XML documents without a document type declaration this
+	//- returns null. The DOM Level 1 does not support editing the Document Type Declaration,
+	//- therefore docType cannot be altered in any way.&lt;/p&gt;
+	CL_DomDocumentType get_doctype();
+
+	//: Returns the CL_DomImplementation object that handles this document.
+	CL_DomImplementation get_implementation();
+
+	//: Returns the root document element node.
+	//- &lt;p&gt;This is a convenience attribute that allows direct access to the child node that is
+	//- the root element of the document. For HTML documents, this is the element with the tag name &quot;HTML&quot;.&lt;/p&gt;
+	CL_DomElement get_document_element();
+	
+//! Operations:
+public:
+	//: Creates an element of the type specified.
+	//- &lt;p&gt;Note that the instance returned implements the Element interface, so attributes can be
+	//- specified directly on the returned object.&lt;/p&gt;
+	//param tag_name: The name of the element type to instantiate. For XML, this is case-sensitive.
+	CL_DomElement create_element(const std::string &amp;tag_name);
+
+	//: Creates an empty DocumentFragment object.
+	CL_DomDocumentFragment create_document_fragment();
+
+	//: Creates a Text node given the specified string.
+	//param data: The data for the node.
+	CL_DomText create_text_node(const std::string &amp;data);
+
+	//: Creates a Comment node given the specified string.
+	//param data: The data for the node.
+	CL_DomComment create_comment(const std::string &amp;data);
+
+	//: Creates a CDATASection node whose value is the specified string.
+	//param data: The data for the CDATASection contents.
+	CL_DomCDATASection create_cdata_section(const std::string &amp;data);
+	
+	//: Creates a ProcessingInstruction node given the specified name and data strings.
+	//param target: The target part of the processing instruction.
+	//param data: The data for the node.
+	CL_DomProcessingInstruction create_processing_instruction(
+		const std::string &amp;target,
+		const std::string &amp;data);
+
+	//: Creates an Attr of the given name.
+	//- &lt;p&gt;Note that the Attr instance can then be set on an Element using the setAttribute method.&lt;/p&gt;
+	//param name: The name of the attribute.
+	CL_DomAttr create_attribute(const std::string &amp;name);
+
+	//: Creates an EntityReference object.
+	//param name: The name of the entity to reference.
+	CL_DomEntityReference create_entity_reference(const std::string &amp;name);
+
+	//: Returns a NodeList of all the Elements with a given tag name in the order in which they would be encountered in a preorder traversal of the Document tree.
+	//param tagname: The name of the tag to match on. The special value &quot;*&quot; matches all tags.
+	CL_DomNodeList get_elements_by_tag_name(const std::string &amp;tag_name);
+
+	//: Loads the DOM document as XML from an input source.
+	//param input: Input source to read from.
+	//param delete_input: If true, will delete input source after usage.
+	//param eat_whitespace: Passed on to CL_XMLTokenizer::set_eat_whitespace.
+	//param insert_point: Place in the DOM to insert the loaded XML code.
+	//retval: List of all top level nodes created.
+	std::vector&lt;CL_DomNode&gt; load(
+		CL_InputSource *input,
+		bool delete_input = false,
+		bool eat_whitespace = true,
+		CL_DomNode insert_point = CL_DomNode());
+
+	//: Saves the DOM document as XML to an input source.
+	//param output: Output source to write to.
+	//param delete_output: If true, will delete output source after usage.
+	//param insert_whitespace: Passed on to CL_XMLWriter::set_insert_whitespace.
+	void save(CL_OutputSource *output, bool delete_output = false, bool insert_whitespace = true);
+
+	//: Removes all nodes from the DOM document.
+	void clear_all();
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/API/Core/XML/dom_document_fragment.h
===================================================================
--- trunk/clanlib/API/Core/XML/dom_document_fragment.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/XML/dom_document_fragment.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,98 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;XML&quot;
+//! header=core.h
+
+#ifndef header_dom_document_fragment
+#define header_dom_document_fragment
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;dom_node.h&quot;
+
+//: DOM Document Fragment class.
+//- !group=Core/XML!
+//- !header=core.h!
+//- &lt;p&gt;DocumentFragment is a &quot;lightweight&quot; or &quot;minimal&quot; Document object. It
+//- is very common to want to be able to extract a portion of a document's
+//- tree or to create a new fragment of a document. Imagine implementing a
+//- user command like cut or rearranging a document by moving fragments
+//- around. It is desirable to have an object which can hold such fragments
+//- and it is quite natural to use a Node for this purpose. While it is true
+//- that a Document object could fulfil this role, a Document object can
+//- potentially be a heavyweight object, depending on the underlying
+//- implementation. What is really needed for this is a very lightweight
+//- object. DocumentFragment is such an object.&lt;/p&gt;
+//- &lt;p&gt;Furthermore, various operations -- such as inserting nodes as children
+//- of another Node -- may take DocumentFragment objects as arguments; this
+//- results in all the child nodes of the DocumentFragment being moved to the
+//- child list of this node.&lt;/p&gt;
+//- &lt;p&gt;The children of a DocumentFragment node are zero or more nodes
+//- representing the tops of any sub-trees defining the structure of the
+//- document. DocumentFragment nodes do not need to be well-formed XML documents
+//- (although they do need to follow the rules imposed upon well-formed XML
+//- parsed entities, which can have multiple top nodes). For example, a
+//- DocumentFragment might have only one child and that child node could be
+//- a Text node. Such a structure model represents neither an HTML document
+//- nor a well-formed XML document.&lt;/p&gt;
+//- &lt;p&gt;When a DocumentFragment is inserted into a Document (or indeed any
+//- other Node that may take children) the children of the DocumentFragment
+//- and not the DocumentFragment itself are inserted into the Node. This
+//- makes the DocumentFragment very useful when the user wishes to create
+//- nodes that are siblings; the DocumentFragment acts as the parent of these
+//- nodes so that the user can use the standard methods from the Node interface,
+//- such as insertBefore() and appendChild().&lt;/p&gt;
+class CL_API_CORE CL_DomDocumentFragment : public CL_DomNode
+{
+//! Construction:
+public:
+	//: Constructs a DOM Document Fragment handle.
+	CL_DomDocumentFragment();
+	
+	CL_DomDocumentFragment(CL_DomDocument &amp;doc);
+
+	CL_DomDocumentFragment(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl);
+
+	~CL_DomDocumentFragment();
+};
+
+#endif

Added: trunk/clanlib/API/Core/XML/dom_document_type.h
===================================================================
--- trunk/clanlib/API/Core/XML/dom_document_type.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/XML/dom_document_type.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,92 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;XML&quot;
+//! header=core.h
+
+#ifndef header_dom_document_type
+#define header_dom_document_type
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;dom_node.h&quot;
+
+class CL_DomNamedNodeMap;
+
+//: DOM Document Type class.
+//- !group=Core/XML!
+//- !header=core.h!
+//- &lt;p&gt;Each Document has a doctype attribute whose value is either null
+//- or a DocumentType object. The DocumentType interface in the DOM Level 1
+//- Core provides an interface to the list of entities that are defined for
+//- the document, and little else because the effect of namespaces and the
+//- various XML scheme efforts on DTD representation are not clearly understood
+//- as of this writing.&lt;/p&gt;
+//- &lt;p&gt;The DOM Level 1 doesn't support editing DocumentType nodes.&lt;/p&gt;
+class CL_API_CORE CL_DomDocumentType : public CL_DomNode
+{
+//! Construction:
+public:
+	//: Constructs a DOM Document Type handle.
+	CL_DomDocumentType();
+
+	CL_DomDocumentType(CL_DomDocument &amp;doc);
+	
+	CL_DomDocumentType(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl);
+
+	~CL_DomDocumentType();
+
+//! Attributes:
+public:
+	//: The name of DTD; i.e., the name immediately following the DOCTYPE keyword.
+	std::string get_name() const;
+
+	//: A NamedNodeMap containing the general entities, both external and internal, declared in the DTD.
+	CL_DomNamedNodeMap get_entities() const;
+
+	//: A NamedNodeMap containing the notations declared in the DTD.
+	CL_DomNamedNodeMap get_notations() const;
+
+//! Operations:
+public:
+};
+
+#endif

Added: trunk/clanlib/API/Core/XML/dom_element.h
===================================================================
--- trunk/clanlib/API/Core/XML/dom_element.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/XML/dom_element.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,135 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;XML&quot;
+//! header=core.h
+
+#ifndef header_dom_element
+#define header_dom_element
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;dom_node.h&quot;
+
+//: DOM Element class.
+//- !group=Core/XML!
+//- !header=core.h!
+//- &lt;p&gt;By far the vast majority of objects (apart from text) that authors encounter when
+//- traversing a document are Element nodes. Assume the following XML document:&lt;/p&gt;
+//- &lt;pre&gt;
+//- &lt;elementExample id=&quot;demo&quot;&gt;
+//-  &lt;subelement1/&gt;
+//-  &lt;subelement2&gt;&lt;subsubelement/&gt;&lt;/subelement2&gt;
+//- &lt;/elementExample/gt;
+//- &lt;/pre&gt;
+//- &lt;p&gt;When represented using DOM, the top node is an Element node for &quot;elementExample&quot;,
+//- which contains two child Element nodes, one for &quot;subelement1&quot; and one for &quot;subelement2&quot;.
+//- &quot;subelement1&quot; contains no child nodes.&lt;/p&gt;
+//- &lt;p&gt;Elements may have attributes associated with them; since the Element interface
+//- inherits from Node, the generic Node interface method getAttributes may be used to
+//- retrieve the set of all attributes for an element. There are methods on the Element
+//- interface to retrieve either an Attr object by name or an attribute value by name.
+//- In XML, where an attribute value may contain entity references, an Attr object should
+//- be retrieved to examine the possibly fairly complex sub-tree representing the attribute
+//- value.&lt;/p&gt;
+class CL_API_CORE CL_DomElement : public CL_DomNode
+{
+//! Construction:
+public:
+	//: Constructs a DOM Element handle.
+	CL_DomElement();
+	
+	CL_DomElement(CL_DomDocument &amp;doc, const std::string &amp;tag_name);
+
+	CL_DomElement(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl);
+
+	~CL_DomElement();
+
+//! Attributes:
+public:
+	//: Returns the name of the element.
+	std::string get_tag_name() const;
+
+//! Operations:
+public:
+	//: Returns true if the element has the specified attribute.
+	bool has_attribute(const std::string &amp;name) const;
+
+	//: Returns the specified attribute.
+	std::string get_attribute(const std::string &amp;name) const;
+
+	//: Returns the specified attribute, using a default value if its not there.
+	std::string get_attribute(const std::string &amp;name, const std::string &amp;default_value) const;
+
+	//: Adds a new attribute.
+	//- &lt;p&gt;If an attribute with that name is already present in the element, its value is
+	//- changed to be that of the value parameter.&lt;/p&gt;
+	//- &lt;p&gt;This value is a simple string, it is not parsed as it is being set. So any markup
+	//- (such as syntax to be recognized as an entity reference) is treated as literal text, and
+	//- is appropriately escaped by the implementation when it is written out. In order to
+	//- assign an attribute value that contains entity references, the user must create an Attr
+	//- node plus any Text and EntityReference nodes, build the appropriate subtree, and use
+	//- set_attribute_node to assign it as the value of an attribute.&lt;/p&gt;
+	void set_attribute(const std::string &amp;name, const std::string &amp;value);
+
+	//: Removes an attribute by name.
+	//- &lt;p&gt;If the removed attribute has a default value it is immediately replaced.&lt;/p&gt;
+	void remove_attribute(const std::string &amp;name);
+	
+	//: Returns a NodeList of all descendant elements with a given tag name.
+	//- &lt;p&gt;The descendant elements are returned in the order in which they would be
+	//- encountered in a preorder traversal of the Element tree.&lt;/p&gt;
+	CL_DomNodeList get_elements_by_tag_name(const std::string &amp;name);
+
+	//: Merges any adjacent Text nodes.
+	//- &lt;p&gt;Puts all Text nodes in the full depth of the sub-tree underneath this Element into
+	//- a &quot;normal&quot; form where only markup (e.g., tags, comments, processing instructions, CDATA
+	//- sections, and entity references) separates Text nodes, i.e., there are no adjacent Text
+	//- nodes. This can be used to ensure that the DOM view of a document is the same as if it
+	//- were saved and re-loaded, and is useful when operations (such as XPointer lookups) that
+	//- depend on a particular document tree structure are to be used.&lt;/p&gt;
+	void normalize();
+
+	//: Returns the text of all child Text nodes appended together.
+	std::string get_text() const;
+};
+
+#endif

Added: trunk/clanlib/API/Core/XML/dom_entity.h
===================================================================
--- trunk/clanlib/API/Core/XML/dom_entity.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/XML/dom_entity.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,88 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;XML&quot;
+//! header=core.h
+
+#ifndef header_dom_entity
+#define header_dom_entity
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;dom_node.h&quot;
+
+//: DOM Entity class.
+//- !group=Core/XML!
+//- !header=core.h!
+//- &lt;p&gt;This interface represents an entity, either parsed or unparsed, in an
+//- XML document. Note that this models the entity itself not the entity
+//- declaration. Entity declaration modeling has been left for a later Level
+//- of the DOM specification.&lt;/p&gt;
+class CL_API_CORE CL_DomEntity : public CL_DomNode
+{
+//! Construction:
+public:
+	//: Constructs a DOM Entity handle.
+	CL_DomEntity();
+	
+	CL_DomEntity(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl);
+
+	~CL_DomEntity();
+
+//! Attributes:
+public:
+	//: The public identifier associated with the entity.
+	//- &lt;p&gt;If the public identifier was not specified, this is null.&lt;/p&gt;
+	std::string get_public_id() const;
+
+	//: The system identifier associated with the entity.
+	//- &lt;p&gt;If the system identifier was not specified, this is null.&lt;/p&gt;
+	std::string get_system_id() const;
+
+	//: For unparsed entities, the name of the notation for the entity.
+	//- &lt;p&gt;For parsed entities, this is null.&lt;/p&gt;
+	std::string get_notation_name() const;
+
+//! Operations:
+public:
+};
+
+#endif

Added: trunk/clanlib/API/Core/XML/dom_entity_reference.h
===================================================================
--- trunk/clanlib/API/Core/XML/dom_entity_reference.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/XML/dom_entity_reference.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,85 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;XML&quot;
+//! header=core.h
+
+#ifndef header_dom_entity_reference
+#define header_dom_entity_reference
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;dom_node.h&quot;
+
+//: DOM Entity Reference class.
+//- !group=Core/XML!
+//- !header=core.h!
+//- &lt;p&gt;EntityReference objects may be inserted into the structure model when an entity reference
+//- is in the source document, or when the user wishes to insert an entity reference. Note that
+//- character references and references to predefined entities are considered to be expanded by
+//- the HTML or XML processor so that characters are represented by their Unicode equivalent rather
+//- than by an entity reference. Moreover, the XML processor may completely expand references to
+//- entities while building the structure model, instead of providing EntityReference objects. If
+//- it does provide such objects, then for a given EntityReference node, it may be that there is no
+//- Entity node representing the referenced entity; but if such an Entity exists, then the child list
+//- of the EntityReference node is the same as that of the Entity node. As with the Entity node, all
+//- descendants of the EntityReference are readonly.&lt;/p&gt;
+class CL_API_CORE CL_DomEntityReference : public CL_DomNode
+{
+//! Construction:
+public:
+	//: Constructs a DOM Entity Reference handle.
+	CL_DomEntityReference();
+	
+	CL_DomEntityReference(CL_DomDocument &amp;doc, const std::string &amp;name);
+
+	CL_DomEntityReference(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl);
+
+	~CL_DomEntityReference();
+
+//! Attributes:
+public:
+
+//! Operations:
+public:
+};
+
+#endif

Added: trunk/clanlib/API/Core/XML/dom_exception.h
===================================================================
--- trunk/clanlib/API/Core/XML/dom_exception.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/XML/dom_exception.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,87 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;XML&quot;
+//! header=core.h
+
+#ifndef header_dom_exception
+#define header_dom_exception
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../System/error.h&quot;
+
+//: DOM Exception class.
+//- !group=Core/XML!
+//- !header=core.h!
+class CL_API_CORE CL_DomException : public CL_Error
+{
+//! Construction:
+public:
+	CL_DomException(unsigned short code);
+
+	CL_DomException(
+		const std::string &amp;message,
+		unsigned short code);
+
+//! Attributes:
+public:
+	enum ExceptionCodes
+	{
+		INDEX_SIZE_ERR               = 1,
+		DOMSTRING_SIZE_ERR           = 2,
+		HIERARCHY_REQUEST_ERR        = 3,
+		WRONG_DOCUMENT_ERR           = 4,
+		INVALID_CHARACTER_ERR        = 5,
+		NO_DATA_ALLOWED_ERR          = 6,
+		NO_MODIFICATION_ALLOWED_ERR  = 7,
+		NOT_FOUND_ERR                = 8,
+		NOT_SUPPORTED_ERR            = 9,
+		INUSE_ATTRIBUTE_ERR          = 10
+	};
+
+	unsigned short code;
+	
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/API/Core/XML/dom_implementation.h
===================================================================
--- trunk/clanlib/API/Core/XML/dom_implementation.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/XML/dom_implementation.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,87 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;XML&quot;
+//! header=core.h
+
+#ifndef header_dom_implementation
+#define header_dom_implementation
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../System/sharedptr.h&quot;
+
+class CL_DomImplementation_Generic;
+class CL_DomDocument;
+
+//: DOM Implementation class.
+//- !group=Core/XML!
+//- !header=core.h!
+//- &lt;p&gt;The DOM Implementation interface provides a number of methods for performing
+//- operations that are independent of any particular instance of the document object model.&lt;/p&gt;
+class CL_API_CORE CL_DomImplementation
+{
+//! Construction:
+public:
+	//: Constructs a DOM Implementation handle.
+	CL_DomImplementation();
+
+	CL_DomImplementation(CL_DomDocument &amp;doc);
+
+	~CL_DomImplementation();
+
+//! Attributes:
+public:
+
+//! Operations:
+public:
+	//: Test if the DOM implementation implements a specific feature.
+	//param feature: The package name of the feature to test. In Level 1, the legal values are &quot;HTML&quot; and &quot;XML&quot; (case-insensitive).
+	//param version: This is the version number of the package name to test. In Level 1, this is the string &quot;1.0&quot;. If the version is not specified, supporting any version of the feature will cause the method to return true.
+	//retval: true if the feature is implemented in the specified version, false otherwise.
+	bool has_feature(const std::string &amp;feature, const std::string &amp;version);
+
+//! Implementation:
+private:
+	CL_SharedPtr&lt;CL_DomImplementation_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/Core/XML/dom_named_node_map.h
===================================================================
--- trunk/clanlib/API/Core/XML/dom_named_node_map.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/XML/dom_named_node_map.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,109 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;XML&quot;
+//! header=core.h
+
+#ifndef header_dom_named_node_map
+#define header_dom_named_node_map
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../System/sharedptr.h&quot;
+
+class CL_DomNode;
+class CL_DomNamedNodeMap_Generic;
+
+//: DOM Named Node Map class.
+//- !group=Core/XML!
+//- !header=core.h!
+//- &lt;p&gt;Objects implementing the NamedNodeMap interface are used to represent collections of nodes
+//- that can be accessed by name. Note that NamedNodeMap does not inherit from NodeList;
+//- NamedNodeMaps are not maintained in any particular order. Objects contained in an object
+//- implementing NamedNodeMap may also be accessed by an ordinal index, but this is simply to
+//- allow convenient enumeration of the contents of a NamedNodeMap, and does not imply that the
+//- DOM specifies an order to these Nodes.&lt;/p&gt;
+class CL_API_CORE CL_DomNamedNodeMap
+{
+//! Construction:
+public:
+	//: Constructs a DOM NamedNodeMap handle.
+	CL_DomNamedNodeMap();
+	
+	CL_DomNamedNodeMap(CL_DomNode &amp;node);
+
+	~CL_DomNamedNodeMap();
+	
+//! Attributes:
+public:
+	//: The number of nodes in the map.
+	int get_length() const;
+	
+//! Operations:
+public:
+	//: Retrieves a node specified by name.
+	CL_DomNode get_named_item(const std::string &amp;name) const;
+
+	//: Adds a node using its node name attribute.
+	//- &lt;p&gt;As the node name attribute is used to derive the name which the node must be stored
+	//- under, multiple nodes of certain types (those that have a &quot;special&quot; string value) cannot
+	//- be stored as the names would clash. This is seen as preferable to allowing nodes to be
+	//- aliased.&lt;/p&gt;
+	//param arg: A node to store in a named node map. The node will later be accessible using the value of the node name attribute of the node. If a node with that name is already present in the map, it is replaced by the new one.
+	//retval: If the new Node replaces an existing node with the same name the previously existing Node is returned, otherwise null is returned.
+	CL_DomNode set_named_item(const CL_DomNode &amp;node);
+
+	//: Removes a node specified by name.
+	//- &lt;p&gt;If the removed node is an Attr with a default value it is immediately replaced.&lt;/p&gt;
+	//param name: The name of a node to remove.
+	//retval: The node removed from the map or null if no node with such a name exists.
+	CL_DomNode remove_named_item(const std::string &amp;name);
+
+	//: Returns the indexth item in the map.
+	//- &lt;p&gt;If index is greater than or equal to the number of nodes in the map, this returns null.&lt;/p&gt;
+	CL_DomNode item(unsigned long index) const;
+	
+//! Implementation:
+private:
+	CL_SharedPtr&lt;CL_DomNamedNodeMap_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/Core/XML/dom_node.h
===================================================================
--- trunk/clanlib/API/Core/XML/dom_node.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/XML/dom_node.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,351 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;XML&quot;
+//! header=core.h
+
+#ifndef header_dom_node
+#define header_dom_node
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../System/sharedptr.h&quot;
+#include &lt;string&gt;
+
+class CL_DomElement;
+class CL_DomAttr;
+class CL_DomText;
+class CL_DomCDATASection;
+class CL_DomEntityReference;
+class CL_DomEntity;
+class CL_DomProcessingInstruction;
+class CL_DomComment;
+class CL_DomDocument;
+class CL_DomDocumentType;
+class CL_DomDocumentFragment;
+class CL_DomNotation;
+class CL_DomNodeList;
+class CL_DomNamedNodeMap;
+class CL_DomNode_Generic;
+
+//: DOM Node class.
+//- !group=Core/XML!
+//- !header=core.h!
+//- &lt;p&gt;The Node interface is the primary datatype for the entire Document Object Model.
+//- It represents a single node in the document tree. While all objects implementing
+//- the Node interface expose methods for dealing with children, not all objects
+//- implementing the Node interface may have children. For example, Text nodes may
+//- not have children, and adding children to such nodes results in a CL_DOMException
+//- being thrown.&lt;/p&gt;
+//- &lt;p&gt;The attributes 'node_name', 'node_value' and 'attributes' are included as a
+//- mechanism to get at node information without casting down to the specific derived
+//- interface. In cases where there is no obvious mapping of these attributes for a
+//- specific node_type (e.g., node_value for an Element or attributes for a Comment),
+//- this returns null. Note that the specialized interfaces may contain additional
+//- and more convenient mechanisms to get and set the relevant information.&lt;/p&gt;
+class CL_API_CORE CL_DomNode
+{
+//! Construction:
+public:
+	CL_DomNode();
+
+	CL_DomNode(const CL_DomNode &amp;copy);
+	
+	~CL_DomNode();
+
+//! Attributes:
+public:
+	//: An integer indicating which type of node this is.
+	enum NodeType
+	{
+		NULL_NODE                     = 0,
+		ELEMENT_NODE                  = 1,
+		ATTRIBUTE_NODE                = 2,
+		TEXT_NODE                     = 3,
+		CDATA_SECTION_NODE            = 4,
+		ENTITY_REFERENCE_NODE         = 5,
+		ENTITY_NODE                   = 6,
+		PROCESSING_INSTRUCTION_NODE   = 7,
+		COMMENT_NODE                  = 8,
+		DOCUMENT_NODE                 = 9,
+		DOCUMENT_TYPE_NODE            = 10,
+		DOCUMENT_FRAGMENT_NODE        = 11,
+		NOTATION_NODE                 = 12
+	};
+	
+	//: Returns the node name.
+	//- &lt;p&gt;The return value vary according to the node type as follows:&lt;/p&gt;
+	//- &lt;ul&gt;
+	//- &lt;li&gt;Element: name of tag&lt;/li&gt;
+	//- &lt;li&gt;Attr: name of attribute&lt;/li&gt;
+	//- &lt;li&gt;Text: &quot;#text&quot;&lt;/li&gt;
+	//- &lt;li&gt;CDataSection: &quot;#cdata-section&quot;&lt;/li&gt;
+	//- &lt;li&gt;EntityReference: name of entity referenced&lt;/li&gt;
+	//- &lt;li&gt;Entity: entity name&lt;/li&gt;
+	//- &lt;li&gt;ProcessingInstruction: target&lt;/li&gt;
+	//- &lt;li&gt;Comment: &quot;#comment&quot;&lt;/li&gt;
+	//- &lt;li&gt;Document: &quot;#document&quot;&lt;/li&gt;
+	//- &lt;li&gt;DocumentType: document type name&lt;/li&gt;
+	//- &lt;li&gt;DocumentFragment: &quot;#document-fragment&quot;&lt;/li&gt;
+	//- &lt;li&gt;Notation: notation name&lt;/li&gt;
+	//- &lt;/ul&gt;
+	std::string get_node_name() const;
+	
+	//: Returns the node value.
+	//- &lt;p&gt;The return value vary according to the node type as follows:&lt;/p&gt;
+	//- &lt;ul&gt;
+	//- &lt;li&gt;Element: null&lt;/li&gt;
+	//- &lt;li&gt;Attr: value of attribute&lt;/li&gt;
+	//- &lt;li&gt;Text: content of text node&lt;/li&gt;
+	//- &lt;li&gt;CDataSection: content of CDATA Section&lt;/li&gt;
+	//- &lt;li&gt;EntityReference: null&lt;/li&gt;
+	//- &lt;li&gt;Entity: null&lt;/li&gt;
+	//- &lt;li&gt;ProcessingInstruction: entire content excluding the target&lt;/li&gt;
+	//- &lt;li&gt;Comment: content of the comment&lt;/li&gt;
+	//- &lt;li&gt;Document: null&lt;/li&gt;
+	//- &lt;li&gt;DocumentType: null&lt;/li&gt;
+	//- &lt;li&gt;DocumentFragment: null&lt;/li&gt;
+	//- &lt;li&gt;Notation: null&lt;/li&gt;
+	//- &lt;/ul&gt;
+	std::string get_node_value() const;
+
+	//: Sets the node value.
+	void set_node_value(const std::string &amp;value);
+
+	//: Returns the node type (one of those in the NodeType enum).
+	unsigned short get_node_type() const;
+	
+	//: Returns the parent of this node.
+	//- &lt;p&gt;All nodes, except Document, DocumentFragment, and Attr may have a parent.
+	//- However, if a node has just been created and not yet added to the tree, or if
+	//- it has been removed from the tree, this is null.&lt;/p&gt;
+	CL_DomNode get_parent_node() const;
+
+	//: Returns a NodeList that contains all children of this node.
+	//- &lt;p&gt;If there are no children, this is a NodeList containing no nodes. The content
+	//- of the returned NodeList is &quot;live&quot; in the sense that, for instance, changes to
+	//- the children of the node object that it was created from are immediately reflected
+	//- in the nodes returned by the NodeList accessors; it is not a static snapshot of
+	//- the content of the node. This is true for every NodeList, including the ones
+	//- returned by the getElementsByTagName method.&lt;/p&gt;
+	CL_DomNodeList get_child_nodes() const;
+
+	//: The first child of this node.
+	//- &lt;p&gt;If there is no such node, this returns a null node.&lt;/p&gt;
+	CL_DomNode get_first_child() const;
+	
+	//: The last child of this node.
+	//- &lt;p&gt;If there is no such node, this returns a null node.&lt;/p&gt;
+	CL_DomNode get_last_child() const;
+	
+	//: The node immediately preceding this node.
+	//- &lt;p&gt;If there is no such node, this returns a null node.&lt;/p&gt;
+	CL_DomNode get_previous_sibling() const;
+	
+	//: The node immediately following this node.
+	//- &lt;p&gt;If there is no such node, this returns a null node.&lt;/p&gt;
+	CL_DomNode get_next_sibling() const;
+
+	//: A NamedNodeMap containing the attributes of this node (if it is an Element) or null otherwise.
+	CL_DomNamedNodeMap get_attributes();
+
+	//: The Document object associated with this node.
+	//- &lt;p&gt;This is also the Document object used to create new nodes. When this node is a Document this is null.&lt;/p&gt;
+	CL_DomDocument get_owner_document();
+
+	//: Returns true if this is a null node.
+	bool is_null() const;
+
+	//: Returns true if this is an element node.
+	bool is_element() const;
+
+	//: Returns true if this is an attribute node.
+	bool is_attr() const;
+
+	//: Returns true if this is a text node.
+	bool is_text() const;
+
+	//: Returns true if this is a CDATA section node.
+	bool is_cdata_section() const;
+
+	//: Returns true if this is an entity reference node.
+	bool is_entity_reference() const;
+
+	//: Returns true if this is an entity node.
+	bool is_entity() const;
+
+	//: Returns true if this is a processing instruction node.
+	bool is_processing_instruction() const;
+
+	//: Returns true if this is a comment node.
+	bool is_comment() const;
+
+	//: Returns true if this is a document node.
+	bool is_document() const;
+
+	//: Returns true if this is a document type node.
+	bool is_document_type() const;
+
+	//: Returns true if this is a document fragment node.
+	bool is_document_fragment() const;
+
+	//: Returns true if this is a notation node.
+	bool is_notation() const;
+
+	//: Returns true if this node has any children.
+	bool has_child_nodes() const;
+	
+//! Operations:
+public:
+	//: Copy assignment operator.
+	//- &lt;p&gt;All objects in the DOM are handles to the underlying implementation. Therefore this doesn't
+	//- actually copy contents between two CL_DomNode's, but instead change the two CL_DomNode's to point
+	//- at the same node in the DOM.&lt;/p&gt;
+	CL_DomNode &amp;operator =(const CL_DomNode &amp;copy);
+
+	//: Compare operator.
+	bool operator ==(const CL_DomNode &amp;other) const;
+
+	//: Inserts the node new_child before the existing child node ref_child.
+	//- &lt;p&gt;If refChild is a null node, inserts new_child at the end of the list of children.&lt;/p&gt;
+	//- &lt;p&gt;If newChild is a DocumentFragment object, all of its children are inserted, in the same order,
+	//- before ref_child. If the new_child is already in the tree, it is first removed.&lt;/p&gt;
+	//param new_child: The node to insert.
+	//param ref_child: The reference node, i.e., the node before which the new node must be inserted.
+	//retval: The node being inserted.
+	CL_DomNode insert_before(CL_DomNode &amp;new_child, CL_DomNode &amp;ref_child);
+
+	//: Replaces the child node old_child with new_child in the list of children.
+	//- &lt;p&gt;If the new_child is already in the tree, it is first removed.&lt;/p&gt;
+	//param new_child: The new node to put in the child list.
+	//param old_child: The node being replaced in the list.
+	//retval: The node replaced.
+	CL_DomNode replace_child(CL_DomNode &amp;new_child, CL_DomNode &amp;old_child);
+
+	//: Removes the child node indicated by old_child from the list of children, and returns it.
+	CL_DomNode remove_child(CL_DomNode &amp;old_child);
+
+	//: Adds the node new_child to the end of the list of children of this node.
+	//- &lt;p&gt;If the new_child is already in the tree, it is first removed.&lt;/p&gt;
+	CL_DomNode append_child(CL_DomNode new_child);
+
+	//: Returns a duplicate of this node, i.e., serves as a generic copy constructor for nodes.
+	//- &lt;p&gt;The duplicate node has no parent.&lt;/p&gt;
+	//- &lt;p&gt;Cloning an Element copies all attributes and their values, including those generated
+	//- by the XML processor to represent defaulted attributes, but this method does not copy
+	//- any text it contains unless it is a deep clone, since the text is contained in a child
+	//- Text node. Cloning any other type of node simply returns a copy of this node.&lt;/p&gt;
+	//param deep: If true, recursively clone the subtree under the specified node; if false, clone only the node itself (and its attributes, if it is an Element).
+	//retval: The duplicate node.
+	CL_DomNode clone_node(bool deep) const;
+	
+	//: Returns whether this node is the same node as the given one.
+    //- &lt;p&gt;This method provides a way to determine whether two Node references returned by the implementation reference the same object.
+	//- When two Node references are references to the same object, even if through a proxy, the references may be used completely interchangeably,
+	//- such that all attributes have the same values and calling the same DOM method on either reference always has exactly the same effect.&lt;/p&gt;
+	//param other: The node to test against.
+	//retval: Returns true if the nodes are the same, false otherwise.
+	bool is_same_node(const CL_DomNode &amp;other) const;
+
+	//: Returns the Element interface to this node.
+	//- &lt;p&gt;If the node is not an Element node, then it returns a null node.&lt;/p&gt;
+	CL_DomElement to_element() const;
+
+	//: Returns the Attribute interface to this node.
+	//- &lt;p&gt;If the node is not an Attribute node, then it returns a null node.&lt;/p&gt;
+	CL_DomAttr to_attr() const;
+
+	//: Returns the Text interface to this node.
+	//- &lt;p&gt;If the node is not a Text node, then it returns a null node.&lt;/p&gt;
+	CL_DomText to_text() const;
+
+	//: Returns the CDATA Section interface to this node.
+	//- &lt;p&gt;If the node is not a CDATA Section node, then it returns a null node.&lt;/p&gt;
+	CL_DomCDATASection to_cdata_section() const;
+
+	//: Returns the Entity Reference interface to this node.
+	//- &lt;p&gt;If the node is not an Entity Reference node, then it returns a null node.&lt;/p&gt;
+	CL_DomEntityReference to_entity_reference() const;
+
+	//: Returns the Entity interface to this node.
+	//- &lt;p&gt;If the node is not an Entity node, then it returns a null node.&lt;/p&gt;
+	CL_DomEntity to_entity() const;
+
+	//: Returns the Processing Instruction interface to this node.
+	//- &lt;p&gt;If the node is not a Processing Instrucion node, then it returns a null node.&lt;/p&gt;
+	CL_DomProcessingInstruction to_processing_instruction() const;
+
+	//: Returns the Comment interface to this node.
+	//- &lt;p&gt;If the node is not a Comment node, then it returns a null node.&lt;/p&gt;
+	CL_DomComment to_comment() const;
+
+	//: Returns the Document interface to this node.
+	//- &lt;p&gt;If the node is not a Document node, then it returns a null node.&lt;/p&gt;
+	CL_DomDocument to_document() const;
+
+	//: Returns the Document Type interface to this node.
+	//- &lt;p&gt;If the node is not a Document Type node, then it returns a null node.&lt;/p&gt;
+	CL_DomDocumentType to_document_type() const;
+
+	//: Returns the Document Fragment interface to this node.
+	//- &lt;p&gt;If the node is not a DocumentFragment node, then it returns a null node.&lt;/p&gt;
+	CL_DomDocumentFragment to_document_fragment() const;
+
+	//: Returns the Notation interface to this node.
+	//- &lt;p&gt;If the node is not a Notation node, then it returns a null node.&lt;/p&gt;
+	CL_DomNotation to_notation() const;
+
+	//: Returns the first child node with the specified node name.
+	//- &lt;p&gt;Returns a null node if no child is found.&lt;/p&gt;
+	CL_DomNode named_item(const std::string &amp;name) const;
+
+//! Implementation:
+protected:
+	CL_DomNode(CL_DomDocument &amp;doc, unsigned short node_type);
+
+	CL_DomNode(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl);
+
+	CL_SharedPtr&lt;CL_DomNode_Generic&gt; impl;
+
+	friend class CL_DomDocument;
+};
+
+#endif

Added: trunk/clanlib/API/Core/XML/dom_node_list.h
===================================================================
--- trunk/clanlib/API/Core/XML/dom_node_list.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/XML/dom_node_list.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,92 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;XML&quot;
+//! header=core.h
+
+#ifndef header_dom_node_list
+#define header_dom_node_list
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../System/sharedptr.h&quot;
+#include &lt;vector&gt;
+
+class CL_DomNode;
+class CL_DomNodeList_Generic;
+class CL_DomDocument;
+
+//: DOM Node List class.
+//- !group=Core/XML!
+//- !header=core.h!
+//- &lt;p&gt;The NodeList interface provides the abstraction of an ordered collection of nodes,
+//- without defining or constraining how this collection is implemented.&lt;/p&gt;
+class CL_API_CORE CL_DomNodeList
+{
+//! Construction:
+public:
+	//: Constructs a DOM NodeList handle.
+	CL_DomNodeList();
+	
+	CL_DomNodeList(CL_DomNode &amp;node, const std::string &amp;tag_name);
+
+	~CL_DomNodeList();
+	
+//! Attributes:
+public:
+	//: The number of nodes in the list.
+	int get_length() const;
+
+//! Operations:
+public:
+	//: Returns the indexth item in the collection.
+	//- &lt;p&gt;If index is greater than or equal to the number of nodes in the list, this returns an empty node.&lt;/p&gt;
+	CL_DomNode item(unsigned long index) const;
+	
+	//: Adds a CL_DomNode to the list.
+	void add_item(CL_DomNode &amp;to_add);
+//! Implementation:
+private:
+	//CL_SharedPtr&lt;CL_DomNodeList_Generic&gt; impl;
+	std::vector&lt;CL_DomNode&gt; node_list;
+};
+
+#endif

Added: trunk/clanlib/API/Core/XML/dom_notation.h
===================================================================
--- trunk/clanlib/API/Core/XML/dom_notation.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/XML/dom_notation.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,87 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;XML&quot;
+//! header=core.h
+
+#ifndef header_dom_notation
+#define header_dom_notation
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;dom_node.h&quot;
+
+//: DOM Notation class.
+//- !group=Core/XML!
+//- !header=core.h!
+//- &lt;p&gt;This interface represents a notation declared in the DTD. A notation either declares,
+//- by name, the format of an unparsed entity (see section 4.7 of the XML 1.0 specification),
+//- or is used for formal declaration of Processing Instruction targets (see section 2.6 of
+//- the XML 1.0 specification). The node name attribute inherited from Node is set to the
+//- declared name of the notation.&lt;/p&gt;
+//- &lt;p&gt;The DOM Level 1 does not support editing Notation nodes; they are therefore readonly.&lt;/p&gt;
+//- &lt;p&gt;A Notation node does not have any parent.&lt;/p&gt;
+class CL_API_CORE CL_DomNotation : public CL_DomNode
+{
+//! Construction:
+public:
+	//: Constructs a DOM Notation handle.
+	CL_DomNotation();
+	
+	CL_DomNotation(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl);
+
+	~CL_DomNotation();
+	
+//! Attributes:
+public:
+	//: The public identifier of this notation.
+	//- &lt;p&gt;If the public identifier was not specified, this is null.&lt;/p&gt;
+	std::string get_public_id() const;
+
+	//: The system identifier of this notation.
+	//- &lt;p&gt;If the system identifier was not specified, this is null.&lt;/p&gt;
+	std::string get_system_id() const;
+
+//! Operations:
+public:
+};
+
+#endif

Added: trunk/clanlib/API/Core/XML/dom_processing_instruction.h
===================================================================
--- trunk/clanlib/API/Core/XML/dom_processing_instruction.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/XML/dom_processing_instruction.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,88 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;XML&quot;
+//! header=core.h
+
+#ifndef header_dom_processing_instruction
+#define header_dom_processing_instruction
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;dom_node.h&quot;
+
+//: DOM Processing Instruction class.
+//- !group=Core/XML!
+//- !header=core.h!
+//- &lt;p&gt;The ProcessingInstruction interface represents a &quot;processing instruction&quot;, used in
+//- XML as a way to keep processor-specific information in the text of the document.&lt;/p&gt;
+class CL_API_CORE CL_DomProcessingInstruction : public CL_DomNode
+{
+//! Construction:
+public:
+	//: Constructs a DOM Processing Instruction handle.
+	CL_DomProcessingInstruction();
+	
+	CL_DomProcessingInstruction(CL_DomDocument &amp;doc, const std::string &amp;target, const std::string &amp;data);
+
+	CL_DomProcessingInstruction(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl);
+
+	~CL_DomProcessingInstruction();
+	
+//! Attributes:
+public:
+	//: The target of this processing instruction.
+	//- &lt;p&gt;XML defines this as being the first token following the markup that begins
+	//- the processing instruction.&lt;/p&gt;
+	std::string get_target() const;
+
+	//: The content of this processing instruction.
+	//- &lt;p&gt;This is from the first non white space character after the target to the
+	//- character immediately preceding the ?&gt;.&lt;/p&gt;
+	std::string get_data() const;
+	
+	void set_data(const std::string &amp;data);
+
+//! Operations:
+public:
+};
+
+#endif

Added: trunk/clanlib/API/Core/XML/dom_text.h
===================================================================
--- trunk/clanlib/API/Core/XML/dom_text.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/XML/dom_text.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,99 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;XML&quot;
+//! header=core.h
+
+#ifndef header_dom_text
+#define header_dom_text
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;dom_character_data.h&quot;
+
+//: DOM Text class.
+//- !group=Core/XML!
+//- !header=core.h!
+//- &lt;p&gt;The Text interface represents the textual content (termed character data
+//- in XML) of an Element or Attr. If there is no markup inside an element's content,
+//- the text is contained in a single object implementing the Text interface that is
+//- the only child of the element. If there is markup, it is parsed into a list of
+//- elements and Text nodes that form the list of children of the element.&lt;/p&gt;
+//- &lt;p&gt;When a document is first made available via the DOM, there is only one Text
+//- node for each block of text. Users may create adjacent Text nodes that represent
+//- the contents of a given element without any intervening markup, but should be aware
+//- that there is no way to represent the separations between these nodes in XML or HTML,
+//- so they will not (in general) persist between DOM editing sessions. The normalize()
+//- method on Element merges any such adjacent Text objects into a single node for each
+//- block of text; this is recommended before employing operations that depend on a
+//- particular document structure, such as navigation with XPointers.&lt;/p&gt;
+class CL_API_CORE CL_DomText : public CL_DomCharacterData
+{
+//! Construction:
+public:
+	//: Constructs a DOM Text handle.
+	CL_DomText();
+
+	CL_DomText(CL_DomDocument &amp;doc, const std::string &amp;data);
+
+	CL_DomText(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl);
+	
+	~CL_DomText();
+
+//! Attributes:
+public:
+
+//! Operations:
+public:
+	//: Breaks this Text node into two Text nodes at the specified offset, keeping both in the tree as siblings.
+	//- &lt;p&gt;node then only contains all the content up to the offset point. And a new Text node, which
+	//- is inserted as the next sibling of this node, contains all the content at and after the offset
+	//- point.&lt;/p&gt;
+	//param offset: The offset at which to split.
+	//retval: The new Text node.
+	CL_DomText splitText(unsigned long offset);
+
+//! Implementation:
+protected:
+	CL_DomText(CL_DomDocument &amp;doc, unsigned short node_type);
+};
+
+#endif

Added: trunk/clanlib/API/Core/XML/xml_token.h
===================================================================
--- trunk/clanlib/API/Core/XML/xml_token.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/XML/xml_token.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,130 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;XML&quot;
+//! header=core.h
+
+#ifndef header_xml_token
+#define header_xml_token
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+//#include &lt;map&gt;
+#include &lt;string&gt;
+
+//class CL_XMLToken_Generic;
+
+//: XML token in a XML file.
+//- !group=Core/XML!
+//- !header=core.h!
+class CL_XMLToken
+{
+//! Construction:
+public:
+//	CL_XMLToken();
+//	
+//	CL_XMLToken(const CL_XMLToken &amp;copy);
+	
+	virtual ~CL_XMLToken() {};
+	
+//! Attributes:
+public:
+	enum TokenType
+	{
+		NULL_TOKEN                     = 0,
+		ELEMENT_TOKEN                  = 1,
+		TEXT_TOKEN                     = 3,
+		CDATA_SECTION_TOKEN            = 4,
+		ENTITY_REFERENCE_TOKEN         = 5,
+		ENTITY_TOKEN                   = 6,
+		PROCESSING_INSTRUCTION_TOKEN   = 7,
+		COMMENT_TOKEN                  = 8,
+		DOCUMENT_TYPE_TOKEN            = 10,
+		NOTATION_TOKEN                 = 12
+	};
+	
+	enum TokenVariant
+	{
+		BEGIN  = 1,
+		END    = 2,
+		SINGLE = 3
+	};
+
+	//: Returns the token type.
+	virtual TokenType get_type() const = 0;
+	
+	//: Returns the token variant.
+	virtual TokenVariant get_variant() const = 0;
+	
+	//: Returns the name of the token.
+	virtual std::string get_name() const = 0;
+	
+	//: Returns the value of the token.
+	virtual std::string get_value() const = 0;
+	
+/*
+	//: Returns all the attributes attached to the token.
+	const std::vector&lt; std::pair&lt;std::string, std::string&gt; &gt; &amp;get_attributes() const;
+*/
+	virtual int get_attributes_number() const = 0;
+
+	//: Returns the attribute name and value for attribute with specified index.
+	virtual std::pair&lt;std::string, std::string&gt; get_attribute(int attribute_num) const = 0;
+
+	//: Returns the value of a named attribute.
+//	virtual std::string get_attribute(const std::string &amp;name) const = 0;
+
+//! Operations:
+//public:
+	//: Copy assignment operator.
+//	CL_XMLToken &amp;operator =(const CL_XMLToken &amp;copy);
+
+//	//: Sets the type of the token.
+//	void set_type(TokenType type);
+//
+//	//: Sets if token ends with a slash.
+//	void set_variant(TokenVariant variant);
+//
+//	//: Sets the name of the token.
+//	void set_name(const std::string &amp;name);
+//
+//	//: Sets the value of the token.
+//	void set_value(const std::string &amp;value);
+//	
+//	//: Attaches attribute to token.
+//	void set_attribute(const std::string &amp;name, const std::string &amp;value);
+
+//! Implementation:
+//private:
+//	CL_XMLToken_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Core/XML/xml_token_load.h
===================================================================
--- trunk/clanlib/API/Core/XML/xml_token_load.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/XML/xml_token_load.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,114 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;XML&quot;
+//! header=core.h
+
+#ifndef header_xml_token_load
+#define header_xml_token_load
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../System/sharedptr.h&quot;
+#include &quot;xml_token.h&quot;
+#include &lt;string&gt;
+
+class CL_XMLTokenLoad_Generic;
+class CL_XMLTokenString;
+
+//: XML token in a XML file.
+//- !group=Core/XML!
+//- !header=core.h!
+class CL_API_CORE CL_XMLTokenLoad : public CL_XMLToken
+{
+//! Construction:
+public:
+	CL_XMLTokenLoad();
+	CL_XMLTokenLoad(const CL_XMLTokenLoad &amp;copy);
+	
+	virtual ~CL_XMLTokenLoad();
+	
+//! Attributes:
+public:
+
+	//: Returns the token type.
+	virtual TokenType get_type() const;
+	
+	//: Returns the token variant.
+	virtual TokenVariant get_variant() const;
+	
+	//: Returns the name of the token.
+	virtual std::string get_name() const;
+	
+	//: Returns the value of the token.
+	virtual std::string get_value() const;
+	
+	//: Returns number of attributes.
+	virtual int get_attributes_number() const;
+
+	//: Returns the attribute name and value for attribute with specified index.
+	virtual std::pair&lt;std::string, std::string&gt; get_attribute(int attribute_num) const;
+
+	const std::pair&lt;CL_XMLTokenString, CL_XMLTokenString&gt; &amp; get_attribute_fast(int attribute_num) const;
+
+//! Operations:
+public:
+	//: Sets the type of the token.
+	void set_type(TokenType type);
+
+	//: Sets if token ends with a slash.
+	void set_variant(TokenVariant variant);
+
+	//: Sets the name of the token.
+	void set_name(const CL_XMLTokenString &amp; name);
+
+	//: Sets the value of the token.
+	void set_value(const CL_XMLTokenString &amp; value);
+	
+	//: Attaches attribute to token.
+	void set_attribute(const CL_XMLTokenString &amp; name, const CL_XMLTokenString &amp; value);
+
+//! Implementation:
+private:
+	CL_SharedPtr&lt;CL_XMLTokenLoad_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/Core/XML/xml_token_save.h
===================================================================
--- trunk/clanlib/API/Core/XML/xml_token_save.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/XML/xml_token_save.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,113 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;XML&quot;
+//! header=core.h
+
+#ifndef header_xml_token_save
+#define header_xml_token_save
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../System/sharedptr.h&quot;
+#include &quot;xml_token.h&quot;
+#include &lt;string&gt;
+
+class CL_XMLTokenSave_Generic;
+class CL_XMLTokenString;
+
+//: XML token in a XML file.
+//- !group=Core/XML!
+//- !header=core.h!
+class CL_API_CORE CL_XMLTokenSave : public CL_XMLToken
+{
+//! Construction:
+public:
+	CL_XMLTokenSave();
+
+	CL_XMLTokenSave(const CL_XMLTokenSave &amp;copy);
+	
+	virtual ~CL_XMLTokenSave();
+	
+//! Attributes:
+public:
+
+	//: Returns the token type.
+	virtual TokenType get_type() const;
+	
+	//: Returns the token variant.
+	virtual TokenVariant get_variant() const;
+	
+	//: Returns the name of the token.
+	virtual std::string get_name() const;
+	
+	//: Returns the value of the token.
+	virtual std::string get_value() const;
+	
+	//: Returns number of attributes.
+	virtual int get_attributes_number() const;
+
+	//: Returns the attribute name and value for attribute with specified index.
+	virtual std::pair&lt;std::string, std::string&gt; get_attribute(int attribute_num) const;
+
+//! Operations:
+public:
+	//: Sets the type of the token.
+	void set_type(TokenType type);
+
+	//: Sets if token ends with a slash.
+	void set_variant(TokenVariant variant);
+
+	//: Sets the name of the token.
+	void set_name(const std::string &amp; name);
+
+	//: Sets the value of the token.
+	void set_value(const std::string &amp; value);
+	
+	//: Attaches attribute to token.
+	void set_attribute(const std::string &amp; name, const std::string &amp; value);
+
+//! Implementation:
+private:
+	CL_SharedPtr&lt;CL_XMLTokenSave_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/Core/XML/xml_token_string.h
===================================================================
--- trunk/clanlib/API/Core/XML/xml_token_string.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/XML/xml_token_string.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,279 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;XML&quot;
+//! header=core.h
+
+#ifndef header_xml_writer_generic
+#define header_xml_writer_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+#include &lt;algorithm&gt;
+
+//: String class for XML Tokens.
+//- !group=Core/XML!
+//- !header=core.h!
+class CL_XMLTokenString
+{
+public:
+	CL_XMLTokenString();
+	CL_XMLTokenString(char const * pointer, int len, bool is_need_escape);
+	CL_XMLTokenString(char * pointer, int len, bool is_need_escape);
+	CL_XMLTokenString(const CL_XMLTokenString &amp; copy);
+	
+	CL_XMLTokenString &amp; operator=(const CL_XMLTokenString &amp; copy);
+
+public:
+	char * ptr();
+	char const * ptr() const;
+    int length() const;
+
+	char operator[](int i) const;
+	char &amp; operator[](int i);
+
+	std::string to_string() const;
+	bool empty() const;
+	bool need_escape() const;
+
+	char * begin();
+	char * end();
+	char * begin() const;
+	char * end() const;
+
+private:
+	char * pointer;
+	int len;
+	bool is_need_escape;
+};
+
+
+inline CL_XMLTokenString::CL_XMLTokenString()
+	: pointer(0)
+	, len(0)
+	, is_need_escape(false)
+{
+}
+
+inline CL_XMLTokenString::CL_XMLTokenString(char * pointer, int len, bool is_need_escape)
+	: pointer(pointer)
+	, len(len)
+	, is_need_escape(is_need_escape)
+{
+}
+
+// unsafe ctor
+inline CL_XMLTokenString::CL_XMLTokenString(char const * pointer, int len, bool is_need_escape)
+	: pointer(const_cast&lt;char*&gt;(pointer))
+	, len(len)
+	, is_need_escape(is_need_escape)
+{
+}
+
+inline CL_XMLTokenString::CL_XMLTokenString(const CL_XMLTokenString &amp; copy)
+	: pointer(copy.pointer)
+	, len(copy.len)
+	, is_need_escape(copy.is_need_escape)
+{
+}
+
+inline CL_XMLTokenString &amp; CL_XMLTokenString::operator=(const CL_XMLTokenString &amp; copy)
+{
+	if (this == &amp;copy)
+		return *this;
+
+	pointer = copy.pointer;
+	len = copy.len;
+	is_need_escape = copy.is_need_escape;
+
+	return *this;
+}
+
+inline char * CL_XMLTokenString::ptr()
+{
+	return pointer;
+}
+
+inline char const * CL_XMLTokenString::ptr() const
+{
+	return pointer;
+}
+   
+inline int CL_XMLTokenString::length() const
+{
+	return len;
+}
+
+inline bool CL_XMLTokenString::empty() const
+{
+	return len == 0;
+}
+
+inline char * CL_XMLTokenString::begin()
+{
+	return pointer;
+}
+
+inline char * CL_XMLTokenString::end()
+{
+	return pointer + len;
+}
+
+inline char * CL_XMLTokenString::begin() const
+{
+	return pointer;
+}
+
+inline char * CL_XMLTokenString::end() const
+{
+	return pointer + len;
+}
+
+inline bool CL_XMLTokenString::need_escape() const
+{
+	return is_need_escape;
+}
+
+inline bool operator==(CL_XMLTokenString const &amp; lhs, CL_XMLTokenString const &amp; rhs)
+{
+	return lhs.length() == rhs.length() &amp;&amp; !memcmp(lhs.ptr(), rhs.ptr(), lhs.length());
+}
+
+inline char CL_XMLTokenString::operator[](int i) const
+{
+	return pointer[i];
+}
+
+inline char &amp; CL_XMLTokenString::operator[](int i)
+{
+	return pointer[i];
+}
+
+template &lt;typename Container, typename Iter&gt;
+inline bool append_escape(Container &amp; buff, size_t &amp; buff_size, Iter &amp; begin, Iter end, std::string const &amp; escape, char escape_char)
+{
+	if ((int)escape.size() &lt;= (end - begin))
+		if (std::equal(escape.begin(), escape.end(), begin))
+		{
+			buff[buff_size] = escape_char;
+			buff_size += 1;
+			begin += escape.size();
+			return true;
+		}
+	return false;
+}
+
+inline std::string replace_escapes_fast(CL_XMLTokenString const &amp; token_string)
+{
+	static std::string const amp(&quot;&amp;&quot;);
+	static std::string const quot(&quot;&quot;&quot;);
+	static std::string const apos(&quot;&apos;&quot;);
+	static std::string const lt(&quot;&lt;&quot;);
+	static std::string const gt(&quot;&gt;&quot;);
+
+	char const * begin = token_string.begin();
+	char const * end = token_string.end();
+
+	std::string::size_type size = token_string.length();
+
+	static std::vector&lt;char&gt; buff;
+	if (buff.size() &lt; size)
+		buff.resize(size);
+
+	size_t buff_size = 0;
+
+	while(begin != end)
+	{
+		char const * pos = std::find(begin, end, '&amp;');
+		std::copy(begin, pos, buff.begin() + buff_size);
+		buff_size += std::distance(begin, pos);
+
+		if (pos == end)
+			break;
+
+		begin = pos;
+		if (	append_escape(buff, buff_size, begin, end, amp, '&amp;')
+			||	append_escape(buff, buff_size, begin, end, quot, '\&quot;')
+			||	append_escape(buff, buff_size, begin, end, apos, '\'')
+			||	append_escape(buff, buff_size, begin, end, gt, '&gt;')
+			||	append_escape(buff, buff_size, begin, end, lt, '&lt;'))
+		{
+		}
+		else
+		{
+			buff[buff_size] = '&amp;';
+			buff_size += 1;
+			++begin;
+		}
+	}
+	return std::string(&amp;buff[0], buff_size);
+}
+
+inline std::string CL_XMLTokenString::to_string() const
+{
+	if (!is_need_escape)
+		return std::string(pointer, len);
+
+	return replace_escapes_fast(*this);
+}
+
+inline CL_XMLTokenString trim_whitespace(CL_XMLTokenString const &amp; str)
+{
+	if (str.empty())
+		return str;
+
+	char const *whitechars = &quot;\r\n\t &quot;;
+	int white_start, white_end;
+	for (white_start = 0; white_start &lt; str.length(); white_start++)
+	{
+		if (str[white_start] != whitechars[0] &amp;&amp;
+			str[white_start] != whitechars[1] &amp;&amp;
+			str[white_start] != whitechars[2] &amp;&amp;
+			str[white_start] != whitechars[3])
+			break;
+	}
+	if (white_start == str.length())
+		return CL_XMLTokenString();
+
+	for (white_end = str.length(); white_end &gt; white_start; white_end--)
+	{
+		if (str[white_end-1] != whitechars[0] &amp;&amp;
+			str[white_end-1] != whitechars[1] &amp;&amp;
+			str[white_end-1] != whitechars[2] &amp;&amp;
+			str[white_end-1] != whitechars[3])
+			break;
+	}
+
+	return CL_XMLTokenString(str.ptr()+white_start, white_end - white_start, str.need_escape());
+}
+
+#endif

Added: trunk/clanlib/API/Core/XML/xml_tokenizer.h
===================================================================
--- trunk/clanlib/API/Core/XML/xml_tokenizer.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/XML/xml_tokenizer.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,89 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;XML&quot;
+//! header=core.h
+
+#ifndef header_xml_tokenizer
+#define header_xml_tokenizer
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../System/sharedptr.h&quot;
+
+class CL_InputSource;
+class CL_XMLTokenLoad;
+class CL_XMLTokenizer_Generic;
+
+//: The XML Tokenizer breaks a XML file into XML tokens.
+//- !group=Core/XML!
+//- !header=core.h!
+class CL_API_CORE CL_XMLTokenizer
+{
+//! Construction:
+public:
+	CL_XMLTokenizer();
+	
+	CL_XMLTokenizer(const CL_XMLTokenizer &amp;copy);
+
+	CL_XMLTokenizer(CL_InputSource *input, bool delete_input = false);
+	
+	virtual ~CL_XMLTokenizer();
+	
+//! Attributes:
+public:
+	//: Returns true if eat whitespace flag is set.
+	bool get_eat_whitespace() const;
+
+	//: If enabled, will eat any whitespace between tags.
+	void set_eat_whitespace(bool enable);
+
+//! Operations:
+public:
+	//: Returns the next token available in input stream.
+	CL_XMLTokenLoad next();
+
+//! Implementation:
+private:
+	CL_SharedPtr&lt;CL_XMLTokenizer_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/Core/XML/xml_writer.h
===================================================================
--- trunk/clanlib/API/Core/XML/xml_writer.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/XML/xml_writer.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,89 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore=&quot;XML&quot;
+//! header=core.h
+
+#ifndef header_xml_writer
+#define header_xml_writer
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../System/sharedptr.h&quot;
+
+class CL_OutputSource;
+class CL_XMLTokenSave;
+class CL_XMLWriter_Generic;
+
+//: The XML Writer writes a XML file based on XML tokens.
+//- !group=Core/XML!
+//- !header=core.h!
+class CL_API_CORE CL_XMLWriter
+{
+//! Construction:
+public:
+	CL_XMLWriter();
+	
+	CL_XMLWriter(const CL_XMLWriter &amp;copy);
+	
+	CL_XMLWriter(CL_OutputSource *output, bool delete_output = false);
+	
+	virtual ~CL_XMLWriter();
+
+//! Attributes:
+public:
+	//: Returns the insert whitespace flag.
+	bool get_insert_whitespace() const;
+
+	//: Inserts whitespace between tags if enabled.
+	void set_insert_whitespace(bool enable);
+
+//! Operations:
+public:
+	//: Write token to file.
+	void write(const CL_XMLTokenSave &amp;token);
+	
+//! Implementation:
+private:
+	CL_SharedPtr&lt;CL_XMLWriter_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/Core/core_iostream.h
===================================================================
--- trunk/clanlib/API/Core/core_iostream.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Core/core_iostream.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,63 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Ingo Ruhnke
+**    Dieter Buys
+*/
+
+#ifndef header_core_iostream
+#define header_core_iostream
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#include &lt;iosfwd&gt;
+
+
+class CL_Rect;
+class CL_Rectf;
+class CL_Point;
+class CL_Pointf;
+class CL_Size;
+class CL_Sizef;
+class CL_Error;
+
+CL_API_CORE std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const CL_Rect&amp; rect);
+CL_API_CORE std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const CL_Rectf&amp; rect);
+CL_API_CORE std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const CL_Point&amp; point);
+CL_API_CORE std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const CL_Pointf&amp; point);
+CL_API_CORE std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const CL_Size&amp; size);
+CL_API_CORE std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const CL_Sizef&amp; size);
+CL_API_CORE std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const CL_Error&amp; error);
+
+
+#endif

Added: trunk/clanlib/API/Display/Collision/collision_outline.h
===================================================================
--- trunk/clanlib/API/Display/Collision/collision_outline.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/Collision/collision_outline.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,285 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Harry Storbacka
+**    Magnus Norddahl
+**    James Wynn
+**    Emanuel Greisen
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Collision&quot;
+//! header=display.h
+
+#ifndef header_collision_outline
+#define header_collision_outline
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &quot;contour.h&quot;
+#include &quot;outline_accuracy.h&quot;
+#include &quot;../../Core/Resources/resource.h&quot;
+#include &quot;../../Core/Math/origin.h&quot;
+#include &quot;../../Core/Math/circle.h&quot;
+#include &quot;../../GL/opengl_wrap.h&quot;
+
+class CL_CollisionOutline_Generic;
+class CL_ResourceManager;
+class CL_PixelBuffer;
+class CL_OutputSourceProvider;
+class CL_GraphicContext;
+class CL_Color;
+
+
+//: Collision point information structure.
+//- !group=Display/Collision !
+//- !header=display.h!
+//- &lt;p&gt;Structure used for returning information about collisions&lt;/p&gt;
+struct CL_CollisionPoint
+{
+	//: Coordinates of the point where the contours intersected.
+	CL_Pointf point;
+
+	//: Normal vector at the point where the contours intersected.
+	CL_Pointf normal;
+
+	//: Every contour intersection has an entry and exit point. True, if this is an entry point.
+	bool is_entry;
+
+	//: Indexes of intersecting lines on the contours.
+	int contour1_line_start, contour2_line_start, contour1_line_end, contour2_line_end;
+};
+
+//: Strurcture containing information about contours that collided.
+//- !group=Display/Collision !
+//- !header=display.h!/
+//- &lt;p&gt;Structure used for returning information about collisions&lt;/p&gt;
+struct CL_CollidingContours
+{
+	const CL_Contour *contour1;
+	const CL_Contour *contour2;
+	bool inside;
+	std::vector&lt;CL_CollisionPoint&gt; points;
+
+	CL_Pointf penetration_normal;
+	float penetration_depth;
+	CL_Pointf contour1_deep_point;
+	CL_Pointf contour2_deep_point;
+	CL_CollidingContours(const CL_Contour *c1, const CL_Contour *c2, bool in=false) :
+		contour1(c1),
+		contour2(c2),
+		inside(in),
+		penetration_normal(0.0f,0.0f),
+		penetration_depth(0.0f),
+		contour1_deep_point(0.0f,0.0f),
+		contour2_deep_point(0.0f,0.0f)
+	{
+		points.clear();
+	}
+};
+
+
+//: Collision detection outline.
+//- !group=Display/Collision !
+//- !header=display.h!
+//- &lt;p&gt;A collision outline is used in collision detection&lt;/p&gt;
+class CL_API_DISPLAY CL_CollisionOutline
+{
+//! Construction:
+ public:
+	//: Construct a collision outline.
+	//param CL_PixelBuffer pbuf : Find alpha outline from a pixel buffer
+	//param int alpha_limit : Alpha limit for pixels considered solid (collidable) 
+	//param CL_OutlineAccuracy accuracy : Amount of optimization of the outline (default: medium)
+	//param std::string filename : Load outline from a file. The file can be an image or a precompiled outline.
+	CL_CollisionOutline();
+	CL_CollisionOutline(const CL_CollisionOutline &amp;other);
+	CL_CollisionOutline( CL_PixelBuffer pbuf, int alpha_limit=128, CL_OutlineAccuracy accuracy=accuracy_medium );
+	CL_CollisionOutline( const std::string &amp;filename, int alpha_limit=128, CL_OutlineAccuracy accuracy=accuracy_medium, bool get_insides=true);
+	CL_CollisionOutline( const std::string &amp;resource_id, CL_ResourceManager *manager );
+	CL_CollisionOutline(std::vector&lt;CL_Contour&gt; contours, int width, int height);
+
+	~CL_CollisionOutline();
+
+//! Attributes:
+ public:
+	//: Returns the contour used as an object bounding box. (an rotated rectangle)
+	const CL_Contour &amp;get_object_bounding_box() const;
+	
+	//: Returns the radius of the outline.
+	//float get_radius() const;
+	CL_Circlef get_minimum_enclosing_disc() const;
+		
+	//: Returns true if completely-inside test is used.
+	bool get_inside_test() const;
+
+	//: Returns the contours in the outline.
+	std::vector&lt;CL_Contour&gt; &amp;get_contours() const;
+
+	//: Returns the position of the outline.
+	CL_Pointf get_translation() const;
+
+	//: Returns the scaling factor.
+	CL_Pointf get_scale() const;
+
+	//: Returns the rotation angle.
+	float get_angle() const;
+	
+	//: Returns the width of the image this outline was created from.
+	unsigned int get_width() const;
+
+	//: Returns the height of the image this outline was created from.
+	unsigned int get_height() const;
+
+	//: Get the translation origin and hotspot of the outline.	
+	void get_alignment( CL_Origin &amp;origin, float &amp;x, float &amp;y ) const;
+
+	//: Get the rotation hotspot of the outline.	
+	void get_rotation_hotspot( CL_Origin &amp;origin, float &amp;x, float &amp;y) const;
+
+	//: Return the info about the collisions. (collision points, normals, pointers to contours, and indexes to lines that intersected)
+	std::vector&lt;CL_CollidingContours&gt; &amp;get_collision_info() const;
+
+	//: Fetch the state of the collision testing variables.
+	void get_collision_info_state(bool &amp;points, bool &amp;normals, bool &amp;metadata, bool &amp;pendepth) const;
+
+	//: Resource owning this outline, if any.
+	CL_Resource resource;
+	
+//! Operations:
+ public:
+	//: Assignment operator
+	CL_CollisionOutline &amp;operator=(const CL_CollisionOutline &amp;other);
+
+	//: Optimize the outline by removing redundant points.
+	//param unsigned char check_distance : the distance of points compared on the outline
+	//param float corner_angle : angle for a corner
+	void optimize( unsigned char check_distance=3, float corner_angle=M_PI/5.0f );
+
+	//: Draw outline on graphic context.
+	//param x, y: Anchor position of where to render sprite. Actual rendering position depends on the anchor and the alignment mode.
+	//param gc: Graphic context on which to render upon. If null, will use CL_Display's current graphic context.
+	void draw(
+		float x,
+		float y,
+		const CL_Color &amp;color,
+		CL_GraphicContext *gc = 0);
+	
+	//: Draw the subcircles surrounding the linesegments on graphic context.
+	//param x, y: Anchor position of where to render cirles. Actual rendering position depends on the anchor and the alignment mode.
+	//param gc: Graphic context on which to render upon. If null, will use CL_Display's current graphic context.
+	void draw_sub_circles(
+		float x,
+		float y,
+		const CL_Color &amp;color,
+		CL_GraphicContext *gc = 0);
+
+	//: Draw the disc enclosing the entire outline.
+	//param x, y: Anchor position of where to render the cirle. Actual rendering position depends on the anchor and the alignment mode.
+	//param gc: Graphic context on which to render upon. If null, will use CL_Display's current graphic context.
+	void draw_smallest_enclosing_disc(
+		float x,
+		float y,
+		const CL_Color &amp;color,
+		CL_GraphicContext *gc);
+
+	//: Set the translation hotspot of the outline.
+	void set_alignment( CL_Origin origin, float x=0, float y=0 );
+
+	//: Set the rotation hotspot of the outline.	
+	void set_rotation_hotspot( CL_Origin origin, float x=0, float y=0 );
+
+	//: Set the position of the outline.	
+	void set_translation( float x, float y );
+	
+	//: Set the scale of the outline.	
+	void set_scale( float x, float y );
+	
+	//: Set the angle (in degrees) of the outline.	
+	void set_angle( float angle );
+	
+	//: Rotate the outline by angle (in degrees).
+	void rotate( float angle );
+	
+	//: Set to true if completely-inside test should be done
+	void set_inside_test( bool value );
+
+	//: Enable collision info gathering.
+	void enable_collision_info( bool points=true, bool normals=false, bool metadata=false, bool pen_depth=false);
+
+	//: This will set the collision info of the outline
+	void set_collision_info(const std::vector&lt;CL_CollidingContours&gt; &amp;colinfo);
+
+	//: This will empty the collision-info vector
+	void clean_collision_info();
+
+	//: (Re)calculate the radius of the outline.
+	void calculate_radius();
+
+	//: (Re)calculate the subcircle segmentation of the outline.
+	void calculate_sub_circles(float radius_multiplier=3.5f);
+
+	//: (Re)calculate the smallest circles enclosing every contour in the outline.
+	void calculate_smallest_enclosing_discs();
+
+	//: (Re)calculate the convex hull for every contour in the outline
+	void calculate_convex_hulls();
+
+	//: Write the outline to a file.
+	//param std::string filename: Name of file.
+	//param CL_OutputSourceProvider *provider: (Optional) OutputSourceProvider to use.
+	void save(const std::string &amp;filename, CL_OutputSourceProvider *provider=0) const;
+
+	//: Returns true if outlines overlap
+	//param CL_CollisionOutline outline : Outline to test against.
+	bool collide( const CL_CollisionOutline &amp;outline, bool remove_old_collision_info=true );
+
+	//: Will calculate the penetration_depth and penetration_normal for all colliding contours.
+	static void calculate_penetration_depth(std::vector&lt;CL_CollidingContours&gt; &amp;collision_info);
+	
+	//: Returns true if a point is inside the outline.
+	//param CL_Pointf &amp;point: the point to test.
+	bool point_inside( const CL_Pointf &amp;point ) const;
+
+//! Implementation:
+ private:
+	CL_CollisionOutline_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Display/Collision/contour.h
===================================================================
--- trunk/clanlib/API/Display/Collision/contour.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/Collision/contour.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,72 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Harry Storbacka
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Collision&quot;
+//! header=display.h
+
+#ifndef header_contour
+#define header_contour
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;vector&gt;
+#include &quot;outline_circle.h&quot;
+
+//: Collision detection contour.
+//- !group=Display/Collision !
+//- !header=display.h!
+//- &lt;p&gt;A outline consists of contours, which hold the actual outline geometry&lt;/p&gt;
+class CL_Contour
+{
+//! Construction:
+ public:
+	//: Construct a contour
+	CL_Contour() : is_inside_contour(false) {};
+	~CL_Contour() {};
+
+//! Attributes:
+ public:
+	// Points forming the countour.
+	std::vector&lt;CL_Pointf&gt; points;
+
+	// boolean specifying if this contour is inside-out (the inside of a hollow polygon)
+	// if that is the case, then the collision-test will skip the inside_contour-test (because you can
+	// be inside this one, without causing a collision)
+	bool is_inside_contour;
+
+	// Circles encapsulating a part of the outline.
+	// If two circles arent intersecting, none of the lines inside them
+	// collide either.
+	std::vector&lt;CL_OutlineCircle&gt; sub_circles;
+};
+
+#endif

Added: trunk/clanlib/API/Display/Collision/outline_accuracy.h
===================================================================
--- trunk/clanlib/API/Display/Collision/outline_accuracy.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/Collision/outline_accuracy.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,53 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Harry Storbacka
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Collision&quot;
+//! header=display.h
+
+#ifndef header_outline_accuracy
+#define header_outline_accuracy
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+//: Outline optimization accuracy.
+//- !group=Display/Collision!
+//- !header=display.h!
+enum CL_OutlineAccuracy
+{
+	accuracy_raw,
+	accuracy_high,
+	accuracy_medium,
+	accuracy_low,
+	accuracy_poor
+};
+
+#endif

Added: trunk/clanlib/API/Display/Collision/outline_circle.h
===================================================================
--- trunk/clanlib/API/Display/Collision/outline_circle.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/Collision/outline_circle.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,90 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Harry Storbacka
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Collision&quot;
+//! header=display.h
+
+#ifndef header_outline_circle
+#define header_outline_circle
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../../Core/Math/point.h&quot;
+#include &lt;cmath&gt;
+
+//: Collision detection outline segmentation circle.
+//- !group=Display/Collision !
+//- !header=display.h!
+//- &lt;p&gt;Outline circles split the line segments into groups for faster collision detection.
+//- If two circles encapsulating the lines don't collide, none of the lines inside them can 
+//- collide either. &lt;/p&gt;
+class CL_OutlineCircle
+{
+//! Construction:
+ public:
+	//: Construct a outline circle
+	CL_OutlineCircle() :
+		position(-1.0f,-1.0f),
+		radius(0),
+		start(0),
+		end(0)
+	{
+		return;
+	}
+	
+//! Operations:
+ public:
+	//: Construct a outline circle
+	//param CL_OutlineCircle &amp;other : Other circle to test.
+	bool collide(const CL_OutlineCircle &amp;other) const
+	{
+		if( &amp;other == this )
+			return false;
+
+		CL_Pointf pos = position - other.position;
+		float dist = (float) sqrt( pos.x*pos.x+pos.y*pos.y );	
+		
+		if( dist &gt; (radius + other.radius) )
+			return false;
+
+		return true;
+	}
+
+//! Attributes:
+ public:
+	CL_Pointf position;
+	float radius;
+	unsigned int start;
+	unsigned int end;
+};
+
+#endif

Added: trunk/clanlib/API/Display/Collision/outline_math.h
===================================================================
--- trunk/clanlib/API/Display/Collision/outline_math.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/Collision/outline_math.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,94 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Emanuel Greisen
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Collision&quot;
+//! header=display.h
+
+#ifndef header_outline_math
+#define header_outline_math
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;vector&gt;
+
+class CL_Pointf;
+class CL_OutlineCircle;
+
+//: Math operations on outlines
+//- !group=Core/Collision !
+//- !header=display.h!
+//- &lt;p&gt;This class provides general methods for calulating things on outlines.&lt;/p&gt;
+class CL_OutlineMath
+{
+//! Operations:
+ public:
+	//: Find minimum spanning circle for the set of points
+	//param std::vector&lt;CL_Pointf&gt; &amp;points: the points to calulate on
+	static CL_OutlineCircle minimum_enclosing_disc(
+		const std::vector&lt;CL_Pointf&gt; &amp;points);
+	static void minimum_enclosing_disc(
+		CL_OutlineCircle &amp;smalldisc,
+		const std::vector&lt;CL_Pointf&gt; &amp;points);
+
+ private:
+	static void minimum_disc_with_1point(
+		CL_OutlineCircle &amp;smalldisc,
+		const std::vector&lt;CL_Pointf&gt; &amp;points,
+		unsigned int i);
+	static void minimum_disc_with_2points(
+		CL_OutlineCircle &amp;smalldisc,
+		const std::vector&lt;CL_Pointf&gt; &amp;points ,
+		unsigned int i,
+		unsigned int j);
+	static void minimum_disc_with_3points(
+		CL_OutlineCircle &amp;smalldisc,
+		const std::vector&lt;CL_Pointf&gt; &amp;points ,
+		unsigned int i,
+		unsigned int j,
+		unsigned int k);
+
+	public:
+		static void minimum_enclosing_sub_circle(
+			CL_OutlineCircle &amp;smalldisc,
+			const std::vector&lt;CL_Pointf&gt; &amp;points,
+			float maxradius);
+	private:
+		static void minimum_enclosing_sub_circle_with_1point(
+			CL_OutlineCircle &amp;smalldisc,
+			const std::vector&lt;CL_Pointf&gt; &amp;points);
+		static void minimum_enclosing_sub_circle_with_2points(
+			CL_OutlineCircle &amp;smalldisc,
+			const std::vector&lt;CL_Pointf&gt; &amp;points,
+			unsigned int j);
+
+};
+
+#endif

Added: trunk/clanlib/API/Display/Collision/outline_provider.h
===================================================================
--- trunk/clanlib/API/Display/Collision/outline_provider.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/Collision/outline_provider.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,67 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Harry Storbacka
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Collision&quot;
+//! header=display.h
+
+#ifndef header_outline_provider
+#define header_outline_provider
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;contour.h&quot;
+
+//: Collision detection contour.
+//- !group=Display/Collision !
+//- !header=display.h!
+//- &lt;p&gt;Abstract Base class for outline providers. Don't use this!&lt;/p&gt;
+class CL_OutlineProvider
+{
+//! Construction:
+ public:
+	//: Construct a outline provider
+	CL_OutlineProvider() {};
+	virtual ~CL_OutlineProvider() {}; 
+
+//! Attributes:
+ public:
+	//: return the countours that make up the outline
+	virtual std::vector&lt;CL_Contour&gt; get_contours()=0;
+
+	//: return the width of the image used as basis for outline creation, or -1 when loading a precompiled outline.
+	virtual int get_width()=0;
+
+	//: return the height of the image used as basis for outline creation, or -1 when loading a precompiled outline.
+	virtual int get_height()=0;
+};
+
+#endif

Added: trunk/clanlib/API/Display/Collision/outline_provider_bitmap.h
===================================================================
--- trunk/clanlib/API/Display/Collision/outline_provider_bitmap.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/Collision/outline_provider_bitmap.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,90 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Harry Storbacka
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Collision&quot;
+//! header=display.h
+
+#ifndef header_outline_provider_bitmap
+#define header_outline_provider_bitmap
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;vector&gt;
+#include &lt;string&gt;
+
+#include &quot;outline_provider.h&quot;
+#include &quot;outline_accuracy.h&quot;
+
+class CL_OutlineProviderBitmap_Generic;
+class CL_PixelBuffer;
+
+//: Bitmap outline provider.
+//- !group=Display/Collision !
+//- !header=display.h!
+//- &lt;p&gt;A CL_OutlineProviderBitmap is used to find outlines based on the alpha channel of images.&lt;/p&gt;
+class CL_API_DISPLAY CL_OutlineProviderBitmap : public CL_OutlineProvider
+{
+//! Construction:
+ public:
+	//: Construct a contour
+	//param CL_PixelBuffer *pbuf : PixelBuffer containing image data.
+	//param int alpha_limit : Minimum alpha value for a colliding pixel
+	CL_OutlineProviderBitmap(CL_PixelBuffer pbuf, int alpha_limit=128, bool get_insides=true);
+	~CL_OutlineProviderBitmap();
+
+//! Attributes:
+ public:
+	//: return the countours that make up the outline
+	virtual std::vector&lt;CL_Contour&gt; get_contours();
+
+	//: return the width of the image used as basis for outline creation.
+	virtual int get_width();
+
+	//: return the height of the image used as basis for outline creation.
+	virtual int get_height();
+
+//! Implementation:
+ private:
+	CL_OutlineProviderBitmap_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Display/Collision/outline_provider_file.h
===================================================================
--- trunk/clanlib/API/Display/Collision/outline_provider_file.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/Collision/outline_provider_file.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,86 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Harry Storbacka
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Collision&quot;
+//! header=display.h
+
+#ifndef header_outline_provider_file
+#define header_outline_provider_file
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;outline_provider.h&quot;
+
+class CL_OutlineProviderFile_Generic;
+class CL_InputSourceProvider;
+
+//: File outline provider is used to load precompiled outlines.
+//- !group=Display/Collision !
+//- !header=display.h!
+//- &lt;p&gt;A CL_OutlineProviderFile is used to load precompiled outlines.&lt;/p&gt;
+class CL_API_DISPLAY CL_OutlineProviderFile : public CL_OutlineProvider
+{
+//! Construction:
+ public:
+	//: Construct a outline provider
+	//param std::string filename : Name of file to load.
+	//param CL_InputSourceProvider *provider : (optional) Use this input source provider as source of data.
+	CL_OutlineProviderFile(const std::string &amp;filename, CL_InputSourceProvider *provider=0);
+	~CL_OutlineProviderFile();
+
+//! Attributes:
+ public:
+	//: return the countours that make up the outline
+	virtual std::vector&lt;CL_Contour&gt; get_contours();
+
+	//: Not used for file provider. Returns -1.
+	virtual int get_width();
+
+	//: Not used for file provider. Returns -1.
+	virtual int get_height();
+
+//! Implementation:
+ private:
+	CL_OutlineProviderFile_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Display/Providers/dc_buffer.h
===================================================================
--- trunk/clanlib/API/Display/Providers/dc_buffer.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/Providers/dc_buffer.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,78 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Surface Providers&quot;
+//! header=display.h
+
+#ifndef header_dc_buffer
+#define header_dc_buffer
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef WIN32
+#include &lt;windows.h&gt;
+
+#include &quot;../pixel_buffer.h&quot;
+
+//: Win32 Device Context pixelbuffer.
+//- !group=Display/Surface Providers!
+//- !header=display.h!
+//- &lt;p&gt;This is class is not crossplatform. It allows win32 applications to paint
+//- to a pixelbuffer using device context system calls.&lt;/p&gt;
+class CL_API_DISPLAY CL_DeviceContextBuffer : public CL_PixelBuffer
+{
+//! Construction:
+public:
+	//: Construct a pixelbuffer using the pixel format of the passed device context.
+	CL_DeviceContextBuffer(HDC reference_dc, int width, int height, bool monocrome_alpha = false);
+
+//! Attributes:
+public:
+	//: Returns device context of pixelbuffer.
+	HDC get_dc();
+
+//! Implementation:
+private:
+};
+
+#endif
+
+#endif

Added: trunk/clanlib/API/Display/Providers/jpeg_provider.h
===================================================================
--- trunk/clanlib/API/Display/Providers/jpeg_provider.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/Providers/jpeg_provider.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,82 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Surface Providers&quot;
+//! header=display.h
+
+#ifndef header_jpeg_provider
+#define header_jpeg_provider
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../pixel_buffer.h&quot;
+#include &lt;string&gt;
+
+class CL_InputSourceProvider;
+class CL_OutputSourceProvider;
+
+//: Surface provider that can load JPEG (.jpg) files.
+//- !group=Display/Surface Providers!
+//- !header=display.h!
+class CL_JPEGProvider : public CL_PixelBuffer
+{
+//! Construction:
+public:
+	//: Constructs a surface provider that can read JPEG files.
+	//param name: Name of the JPEG file to load.
+	//param provider: Input source provider that delivers the JPEG file.
+	CL_JPEGProvider(
+		const std::string &amp;name, 
+		CL_InputSourceProvider *provider = 0);
+
+	//: Save the given PixelBuffer into a JPEG
+	//param buffer: The CL_PixelBuffer to save, format doesn't matter its converted if needed
+	//param filename: to which the JPEG file is saved
+	//param output_provider:
+	//param quality: the quality level of the JPEG (0-100), 100 being best quality
+	static void save(
+		CL_PixelBuffer buffer,
+		const std::string &amp;filename,
+		CL_OutputSourceProvider *output_provider = 0,
+		int quality = 85);
+};
+
+#endif

Added: trunk/clanlib/API/Display/Providers/pcx_provider.h
===================================================================
--- trunk/clanlib/API/Display/Providers/pcx_provider.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/Providers/pcx_provider.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,76 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Surface Providers&quot;
+//! header=display.h
+
+#ifndef header_pcx_provider
+#define header_pcx_provider
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../pixel_buffer.h&quot;
+#include &lt;string&gt;
+
+class CL_InputSourceProvider;
+class CL_OutputSourceProvider;
+
+//: Surface provider that can load PCX files.
+//- !group=Display/Surface Providers!
+//- !header=display.h!
+class CL_API_DISPLAY CL_PCXProvider : public CL_PixelBuffer
+{
+//! Construction:
+public:
+	//: Constructs a surface provider that can read pcx files.
+	//param name: Name of the pcx file to load.
+	//param provider: Input source provider that delivers the pcx file.
+	CL_PCXProvider(
+		const std::string &amp;name,
+		CL_InputSourceProvider *provider = 0);
+
+  static void save(
+	  CL_PixelBuffer buffer,
+	  const std::string &amp;filename,
+	  CL_OutputSourceProvider *output_provider = 0);
+};
+
+#endif

Added: trunk/clanlib/API/Display/Providers/png_provider.h
===================================================================
--- trunk/clanlib/API/Display/Providers/png_provider.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/Providers/png_provider.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,77 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Surface Providers&quot;
+//! header=display.h
+
+#ifndef header_png_provider
+#define header_png_provider
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../pixel_buffer.h&quot;
+#include &lt;string&gt;
+
+class CL_InputSourceProvider;
+class CL_OutputSourceProvider;
+
+//: Surface provider that can load PNG (.png) files.
+//- !group=Display/Surface Providers!
+//- !header=display.h!
+class CL_API_DISPLAY CL_PNGProvider : public CL_PixelBuffer
+{
+//! Construction:
+public:
+	//: Constructs a surface provider that can read PNG files.
+	//param name: Name of the PNG file to load.
+	//param provider: Input source provider that delivers the PNG file.
+	CL_PNGProvider(
+		const std::string &amp;name, 
+		CL_InputSourceProvider *provider = 0);
+
+	//: Called to save a given PixelBuffer to a file
+  static void save(
+	  CL_PixelBuffer buffer,
+	  const std::string &amp;filename,
+	  CL_OutputSourceProvider *output_provider = 0);
+};
+
+#endif

Added: trunk/clanlib/API/Display/Providers/provider_factory.h
===================================================================
--- trunk/clanlib/API/Display/Providers/provider_factory.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/Providers/provider_factory.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,91 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Surface Providers&quot;
+//! header=display.h
+
+#ifndef header_provider_factory
+#define header_provider_factory
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;map&gt;
+#include &lt;string&gt;
+
+class CL_PixelBuffer;
+class CL_InputSourceProvider;
+class CL_OutputSourceProvider;
+class CL_ProviderType;
+
+//: Provider factory
+//- !group=Display/Surface Providers!
+//- !header=display.h!
+class CL_API_DISPLAY CL_ProviderFactory
+{
+//! Static Attributes:
+public:
+	//: Map of the class factories for each provider type.
+	static std::map&lt;std::string, CL_ProviderType *&gt; types;
+
+//! Operations:
+public:
+	//: Loads an image file from 'filename', using the provider
+	//: identified by 'type'.
+	//- &lt;p&gt;If the type is an empty string, it uses the extension of
+	//- the filename to determine what type it is.&lt;/p&gt;
+	//- &lt;p&gt;The input provider will be used as a the source for filename,
+	//- if specified.&lt;/p&gt;
+	static CL_PixelBuffer load(
+		const std::string &amp;filename,
+		const std::string &amp;type = &quot;&quot;,
+		CL_InputSourceProvider *input_provider = 0);
+
+	//: Saves the given CL_PixelBuffer to the file given by 'filename'.
+	//- &lt;p&gt;If the type is an empty string, it uses the extension of the
+	//- filename to determine what type it is &lt;/p&gt;
+	static void save(
+		CL_PixelBuffer buffer,
+		const std::string &amp;filename,
+		const std::string &amp;type = &quot;&quot;,
+		CL_OutputSourceProvider *output_provider = 0);
+};
+
+#endif

Added: trunk/clanlib/API/Display/Providers/provider_type.h
===================================================================
--- trunk/clanlib/API/Display/Providers/provider_type.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/Providers/provider_type.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,88 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Surface Providers&quot;
+//! header=display.h
+
+#ifndef header_provider_type
+#define header_provider_type
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+#include &quot;../pixel_buffer.h&quot;
+#include &quot;../../Core/System/error.h&quot;
+
+class CL_PixelBuffer;
+class CL_InputSourceProvider;
+class CL_OutputSourceProvider;
+
+//: Provider type
+//- !group=Display/Surface Providers!
+//- !header=display.h!
+class CL_API_DISPLAY CL_ProviderType
+{
+//! Construction:
+public:
+	//: Registers a provider type in the CL_ProviderFactory.
+	CL_ProviderType(const std::string &amp;type);
+
+	//: Unregisters a provider type in the CL_ProviderFactory.
+	virtual ~CL_ProviderType();
+
+//! Operations:
+public:
+	//: Called to load an image with this provider type.
+	virtual CL_PixelBuffer load(
+		const std::string &amp;filename,
+		CL_InputSourceProvider *input_provider)=0;
+
+	//: Called to save a given PixelBuffer to a file
+	virtual void save(
+		CL_PixelBuffer buffer,
+		const std::string &amp;filename,
+		CL_OutputSourceProvider *output_provider)=0;
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/API/Display/Providers/provider_type_register.h
===================================================================
--- trunk/clanlib/API/Display/Providers/provider_type_register.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/Providers/provider_type_register.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,74 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Surface Providers&quot;
+//! header=display.h
+
+#ifndef header_provider_type_register
+#define header_provider_type_register
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;provider_type.h&quot;
+
+//: Class template to register a provider type.
+//- !group=Display/Surface Providers!
+//- !header=display.h!
+template&lt;class ProviderClass&gt;
+class CL_ProviderType_Register : public CL_ProviderType
+{
+//! Construction:
+public:
+	//: Registers provider type in the CL_ProviderFactory.
+	CL_ProviderType_Register(const std::string &amp;type) : CL_ProviderType(type)
+	{
+	}
+
+//! Operations:
+public:
+	//: Called to load an image with this provider type.
+	virtual CL_PixelBuffer load(
+		const std::string &amp;filename,
+		CL_InputSourceProvider *input_provider)
+	{
+		return ProviderClass(filename, input_provider);
+	}
+
+	virtual void save(
+		CL_PixelBuffer buffer,
+		const std::string &amp;filename,
+		CL_OutputSourceProvider *output_provider)
+	{
+		ProviderClass::save(buffer, filename, output_provider);
+	}
+};
+
+#endif

Added: trunk/clanlib/API/Display/Providers/targa_provider.h
===================================================================
--- trunk/clanlib/API/Display/Providers/targa_provider.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/Providers/targa_provider.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,76 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Surface Providers&quot;
+//! header=display.h
+
+#ifndef header_targaprovider
+#define header_targaprovider
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../pixel_buffer.h&quot;
+#include &lt;string&gt;
+
+class CL_InputSourceProvider;
+class CL_OutputSourceProvider;
+
+//: Surface provider that can load targa (.tga) files.
+//- !group=Display/Surface Providers!
+//- !header=display.h!
+class CL_TargaProvider : public CL_PixelBuffer
+{
+//! Construction:
+public:
+	//: Constructs a surface provider that can read targa files.
+	//param name: Name of the targa file to load.
+	//param provider: Input source provider that delivers the targa file.
+	CL_TargaProvider(
+		const std::string &amp;name,
+		CL_InputSourceProvider *provider = 0);
+
+	static void save(
+		CL_PixelBuffer buffer,
+		const std::string &amp;filename,
+		CL_OutputSourceProvider *output_provider = 0);
+};
+
+#endif

Added: trunk/clanlib/API/Display/blend_func.h
===================================================================
--- trunk/clanlib/API/Display/blend_func.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/blend_func.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,62 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Display 2D&quot;
+//! header=display.h
+
+#ifndef header_blend_func
+#define header_blend_func
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+//: Blending functions.
+//- !group=Display/Display 2D!
+//- !header=display.h!
+enum CL_BlendFunc
+{
+	blend_zero,                     // source or destination (0, 0, 0, 0)
+	blend_one,                      // source or destination (1, 1, 1, 1)
+	blend_dest_color,               // source                (Rd, Gd, Bd, Ad)
+	blend_src_color,                // destination           (Rs, Gs, Bs, As)
+	blend_one_minus_dest_color,     // source                (1, 1, 1, 1) - (Rd, Gd, Bd, Ad)
+	blend_one_minus_src_color,      // destination           (1, 1, 1, 1) - (Rs, Gs, Bs, As)
+	blend_src_alpha,                // source or destination (As, As, As, As)
+	blend_one_minus_src_alpha,      // source or destination (1, 1, 1, 1) - (As, As, As, As)
+	blend_dst_alpha,                // source or destination (Ad, Ad, Ad, Ad)
+	blend_one_minus_dest_alpha,     // source or destination (1, 1, 1, 1) - (Ad, Ad, Ad, Ad)
+	blend_src_alpha_saturate,       // source                (f, f, f, 1) - f = min(As, 1 - Ad)
+	blend_constant_color,           // source or destination (Rc, Gc, Bc, Ac)
+	blend_one_minus_constant_color, // source or destination (1, 1, 1, 1) - (Rc, Gc, Bc, Ac)
+	blend_constant_alpha,           // source or destination (Ac, Ac, Ac, Ac)
+	blend_one_minus_constant_alpha  // source or destination (1, 1, 1, 1) - (Ac, Ac, Ac, Ac)
+};
+
+#endif

Added: trunk/clanlib/API/Display/canvas.h
===================================================================
--- trunk/clanlib/API/Display/canvas.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/canvas.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,147 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Display 2D&quot;
+//! header=display.h
+
+#ifndef header_canvas
+#define header_canvas
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Core/System/sharedptr.h&quot;
+
+class CL_Surface;
+class CL_PixelBuffer;
+class CL_Rect;
+class CL_Point;
+class CL_GraphicContext;
+class CL_Canvas_Generic;
+
+//: Construct hardware accelerated (where available) off-screen canvas buffer.
+//- !group=Display/Display 2D!
+//- !header=display.h!
+//- &lt;p&gt;For the OpenGL target, this object represents an OpenGL &quot;pbuffer&quot;. A pbuffer
+//- is an off-screen OpenGL context that can function as hardware accelerated rendering
+//- to a canvas.&lt;/p&gt;
+//- &lt;p&gt;To use CL_Canvas, first create an instance of CL_Canvas. Then load a surface into
+//- the canvas. This will make ClanLib copy the contents of the surface (texture for GL)
+//- to the canvas. After this rendering operations can be performed on the canvas.&lt;/p&gt;
+//- &lt;p&gt;If the surface selected into the canvas is drawn, ClanLib will automatically upload
+//- the contents of the canvas back into the surface. Likewise if another surface is selected
+//- into the canvas the surface will be updated.&lt;/p&gt;
+//- &lt;p&gt;It is recommended to limit the amount of canvas objects in the application. Every
+//- canvas require construction of a new OpenGL context, and canvases consume frame buffer
+//- memory.&lt;/p&gt;
+//- &lt;p&gt;In Windows a pbuffer can get 'lost', meaning that the operating system can suddenly
+//- just use the memory for something else, without warning. Because of this
+//- it is adviced to keep data in the canvas for as little time as possible - sync_surface()
+//- can be used force uploading of the canvas' contents to the surface. Generally you do not
+//- need to do this since drawing the surface will force such an upload, but if the surface
+//- is not be drawn for some time, forcing an upload is a good idea.&lt;/p&gt;
+//- &lt;p&gt;If the pbuffer is lost, ClanLib will automatically try to reclaim the canvas and sync
+//- it with the latest version stored in the surface (the texture). As long as the pbuffer is
+//- lost, any drawing commands on the canvas will be silently ignored. This cannot guarantee
+//- never loosing what is drawn to the canvas, but at least not everything will be completely
+//- lost.&lt;/p&gt;
+//- &lt;p&gt;Example of usage:&lt;/p&gt;
+//- &lt;p&gt;
+//- CL_Surface surface_foo(&quot;foo.png&quot;);&lt;br&gt;
+//- CL_Surface surface_bar(&quot;bar.png&quot;);&lt;br&gt;
+//- CL_Canvas canvas;&lt;br&gt;
+//- canvas.select_surface(surface_foo);&lt;br&gt;
+//- surface_bar.draw(5, 5, canvas.get_gc());&lt;br&gt;
+//- canvas.get_gc()-&gt;draw_line(0, 0, 100, 100, CL_Color::yellow);&lt;br&gt;
+//- canvas.sync_surface();
+//- &lt;/p&gt;
+class CL_API_DISPLAY CL_Canvas
+{
+//! Construction:
+public:
+	//: Constructs canvas buffer.
+	CL_Canvas();
+	
+	CL_Canvas(const CL_Surface &amp;initial_active_surface);
+	
+	CL_Canvas(const CL_Canvas &amp;copy);
+	
+	virtual ~CL_Canvas();
+
+//! Attributes:
+public:
+	//: Returns the graphic context for the canvas.
+	CL_GraphicContext *get_gc();
+
+	//: Returns the contents of the canvas.
+	CL_PixelBuffer get_pixeldata();
+	
+	CL_PixelBuffer get_pixeldata(const CL_Rect &amp;area);
+
+	//: Returns the width of currently selected surface.
+	int get_width() const;
+	
+	//: Returns the height of currently selected surface.
+	int get_height() const;
+
+//! Operations:
+public:
+	//: Copy assignment operator.
+	CL_Canvas &amp;operator =(const CL_Canvas &amp;copy);
+
+	//: Set contents of canvas.
+	void set_pixeldata(const CL_PixelBuffer &amp;data);
+
+	void set_pixeldata(const CL_Point &amp;dest, const CL_PixelBuffer &amp;data);
+
+	void set_pixeldata(const CL_Point &amp;dest, const CL_Rect &amp;src, const CL_PixelBuffer &amp;data);
+
+	//: Sets the surface that canvas is currently drawing on.
+	void select_surface(CL_Surface &amp;surface);
+	
+	//: Forces syncronization of the contents between canvas and selected surface.
+	void sync_surface();
+	
+//! Implementation:
+private:
+	CL_SharedPtr&lt;CL_Canvas_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/Display/color.h
===================================================================
--- trunk/clanlib/API/Display/color.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/color.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,642 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Display 2D&quot;
+//! header=display.h
+
+#ifndef header_color
+#define header_color
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+
+class CL_PixelFormat;
+class CL_Colorf;
+
+//: Color description class.
+//- !group=Display/Display 2D!
+//- !header=display.h!
+class CL_API_DISPLAY CL_Color
+{
+//! Construction:
+public:
+	//: Constructs a color.
+	//- &lt;p&gt;Color components are specified in the range 0 to 255.&lt;/p&gt;
+	//- &lt;p&gt;An alpha value of 0 means complete transparency, while 255 means completely opaque (solid).&lt;/p&gt;
+	//param red: Red color component.
+	//param green: Green color component.
+	//param blue: Blue color component.
+	//param alpha: Alpha (transparency) color component.
+	CL_Color() : color(0) { return; }
+
+	explicit CL_Color(const CL_Colorf&amp;);
+
+	CL_Color(unsigned int red, unsigned int green, unsigned int blue, unsigned int alpha = 255)
+		: color((alpha&lt;&lt;24) | (red&lt;&lt;16) | (green&lt;&lt;8) | blue) { return; }
+
+//! Attributes:
+public:
+	//: Returns the alpha color component, in the range 0-255.
+	unsigned int get_alpha() const { return (color &gt;&gt; 24) &amp; 0xff; }
+
+	//: Returns the red color component, in the range 0-255.
+	unsigned int get_red() const { return (color &gt;&gt; 16) &amp; 0xff; }
+
+	//: Returns the green color component, in the range 0-255.
+	unsigned int get_green() const { return (color &gt;&gt; 8) &amp; 0xff; }
+
+	//: Returns the blue color component, in the range 0-255.
+	unsigned int get_blue() const { return color &amp; 0xff; }
+
+	//: Color in ARGB8888 format.
+	unsigned int color;
+
+// Operations:
+public:
+	//: Color == Color operator (deep compare)
+	bool operator==(const CL_Color &amp;c) const
+	{ return (color == c.color); }
+
+	//: Color != Color operator (deep compare)
+	bool operator!=(const CL_Color &amp;c) const
+	{ return (color != c.color); }
+
+//! Statics:
+public:
+	//: &lt;img src=&quot;../images/aliceblue-chip.png&quot; width=16 height=16 /&gt; rgb(240, 248, 255).
+	static CL_Color aliceblue;
+
+	//: &lt;img src=&quot;../images/antiquewhite-chip.png&quot; width=16 height=16 /&gt; rgb(250, 235, 215).
+	static CL_Color antiquewhite;
+
+	//: &lt;img src=&quot;../images/aqua-chip.png&quot; width=16 height=16 /&gt; rgb( 0, 255, 255).
+	static CL_Color aqua;
+
+	//: &lt;img src=&quot;../images/aquamarine-chip.png&quot; width=16 height=16 /&gt; rgb(127, 255, 212).
+	static CL_Color aquamarine;
+
+	//: &lt;img src=&quot;../images/azure-chip.png&quot; width=16 height=16 /&gt; rgb(240, 255, 255).
+	static CL_Color azure;
+
+	//: &lt;img src=&quot;../images/beige-chip.png&quot; width=16 height=16 /&gt; rgb(245, 245, 220).
+	static CL_Color beige;
+
+	//: &lt;img src=&quot;../images/bisque-chip.png&quot; width=16 height=16 /&gt; rgb(255, 228, 196).
+	static CL_Color bisque;
+
+	//: &lt;img src=&quot;../images/black-chip.png&quot; width=16 height=16 /&gt; rgb( 0, 0, 0).
+	static CL_Color black;
+
+	//: &lt;img src=&quot;../images/blanchedalmond-chip.png&quot; width=16 height=16 /&gt; rgb(255, 235, 205).
+	static CL_Color blanchedalmond;
+
+	//: &lt;img src=&quot;../images/blue-chip.png&quot; width=16 height=16 /&gt; rgb( 0, 0, 255).
+	static CL_Color blue;
+
+	//: &lt;img src=&quot;../images/blueviolet-chip.png&quot; width=16 height=16 /&gt; rgb(138, 43, 226).
+	static CL_Color blueviolet;
+
+	//: &lt;img src=&quot;../images/brown-chip.png&quot; width=16 height=16 /&gt; rgb(165, 42, 42).
+	static CL_Color brown;
+
+	//: &lt;img src=&quot;../images/burlywood-chip.png&quot; width=16 height=16 /&gt; rgb(222, 184, 135).
+	static CL_Color burlywood;
+
+	//: &lt;img src=&quot;../images/cadetblue-chip.png&quot; width=16 height=16 /&gt; rgb( 95, 158, 160).
+	static CL_Color cadetblue;
+
+	//: &lt;img src=&quot;../images/chartreuse-chip.png&quot; width=16 height=16 /&gt; rgb(127, 255, 0).
+	static CL_Color chartreuse;
+
+	//: &lt;img src=&quot;../images/chocolate-chip.png&quot; width=16 height=16 /&gt; rgb(210, 105, 30).
+	static CL_Color chocolate;
+
+	//: &lt;img src=&quot;../images/coral-chip.png&quot; width=16 height=16 /&gt; rgb(255, 127, 80).
+	static CL_Color coral;
+
+	//: &lt;img src=&quot;../images/cornflowerblue-chip.png&quot; width=16 height=16 /&gt; rgb(100, 149, 237).
+	static CL_Color cornflowerblue;
+
+	//: &lt;img src=&quot;../images/cornsilk-chip.png&quot; width=16 height=16 /&gt; rgb(255, 248, 220).
+	static CL_Color cornsilk;
+
+	//: &lt;img src=&quot;../images/crimson-chip.png&quot; width=16 height=16 /&gt; rgb(220, 20, 60).
+	static CL_Color crimson;
+
+	//: &lt;img src=&quot;../images/cyan-chip.png&quot; width=16 height=16 /&gt; rgb( 0, 255, 255).
+	static CL_Color cyan;
+
+	//: &lt;img src=&quot;../images/darkblue-chip.png&quot; width=16 height=16 /&gt; rgb( 0, 0, 139).
+	static CL_Color darkblue;
+
+	//: &lt;img src=&quot;../images/darkcyan-chip.png&quot; width=16 height=16 /&gt; rgb( 0, 139, 139).
+	static CL_Color darkcyan;
+
+	//: &lt;img src=&quot;../images/darkgoldenrod-chip.png&quot; width=16 height=16 /&gt; rgb(184, 134, 11).
+	static CL_Color darkgoldenrod;
+
+	//: &lt;img src=&quot;../images/darkgray-chip.png&quot; width=16 height=16 /&gt; rgb(169, 169, 169).
+	static CL_Color darkgray;
+
+	//: &lt;img src=&quot;../images/darkgreen-chip.png&quot; width=16 height=16 /&gt; rgb( 0, 100, 0).
+	static CL_Color darkgreen;
+
+	//: &lt;img src=&quot;../images/darkgrey-chip.png&quot; width=16 height=16 /&gt; rgb(169, 169, 169).
+	static CL_Color darkgrey;
+
+	//: &lt;img src=&quot;../images/darkkhaki-chip.png&quot; width=16 height=16 /&gt; rgb(189, 183, 107).
+	static CL_Color darkkhaki;
+
+	//: &lt;img src=&quot;../images/darkmagenta-chip.png&quot; width=16 height=16 /&gt; rgb(139, 0, 139).
+	static CL_Color darkmagenta;
+
+	//: &lt;img src=&quot;../images/darkolivegreen-chip.png&quot; width=16 height=16 /&gt; rgb( 85, 107, 47).
+	static CL_Color darkolivegreen;
+
+	//: &lt;img src=&quot;../images/darkorange-chip.png&quot; width=16 height=16 /&gt; rgb(255, 140, 0).
+	static CL_Color darkorange;
+
+	//: &lt;img src=&quot;../images/darkorchid-chip.png&quot; width=16 height=16 /&gt; rgb(153, 50, 204).
+	static CL_Color darkorchid;
+
+	//: &lt;img src=&quot;../images/darkred-chip.png&quot; width=16 height=16 /&gt; rgb(139, 0, 0).
+	static CL_Color darkred;
+
+	//: &lt;img src=&quot;../images/darksalmon-chip.png&quot; width=16 height=16 /&gt; rgb(233, 150, 122).
+	static CL_Color darksalmon;
+
+	//: &lt;img src=&quot;../images/darkseagreen-chip.png&quot; width=16 height=16 /&gt; rgb(143, 188, 143).
+	static CL_Color darkseagreen;
+
+	//: &lt;img src=&quot;../images/darkslateblue-chip.png&quot; width=16 height=16 /&gt; rgb( 72, 61, 139).
+	static CL_Color darkslateblue;
+
+	//: &lt;img src=&quot;../images/darkslategray-chip.png&quot; width=16 height=16 /&gt; rgb( 47, 79, 79).
+	static CL_Color darkslategray;
+
+	//: &lt;img src=&quot;../images/darkslategrey-chip.png&quot; width=16 height=16 /&gt; rgb( 47, 79, 79).
+	static CL_Color darkslategrey;
+
+	//: &lt;img src=&quot;../images/darkturquoise-chip.png&quot; width=16 height=16 /&gt; rgb( 0, 206, 209).
+	static CL_Color darkturquoise;
+
+	//: &lt;img src=&quot;../images/darkviolet-chip.png&quot; width=16 height=16 /&gt; rgb(148, 0, 211).
+	static CL_Color darkviolet;
+
+	//: &lt;img src=&quot;../images/deeppink-chip.png&quot; width=16 height=16 /&gt; rgb(255, 20, 147).
+	static CL_Color deeppink;
+
+	//: &lt;img src=&quot;../images/deepskyblue-chip.png&quot; width=16 height=16 /&gt; rgb( 0, 191, 255).
+	static CL_Color deepskyblue;
+
+	//: &lt;img src=&quot;../images/dimgray-chip.png&quot; width=16 height=16 /&gt; rgb(105, 105, 105).
+	static CL_Color dimgray;
+
+	//: &lt;img src=&quot;../images/dimgrey-chip.png&quot; width=16 height=16 /&gt; rgb(105, 105, 105).
+	static CL_Color dimgrey;
+
+	//: &lt;img src=&quot;../images/dodgerblue-chip.png&quot; width=16 height=16 /&gt; rgb( 30, 144, 255).
+	static CL_Color dodgerblue;
+
+	//: &lt;img src=&quot;../images/firebrick-chip.png&quot; width=16 height=16 /&gt; rgb(178, 34, 34).
+	static CL_Color firebrick;
+
+	//: &lt;img src=&quot;../images/floralwhite-chip.png&quot; width=16 height=16 /&gt; rgb(255, 250, 240).
+	static CL_Color floralwhite;
+
+	//: &lt;img src=&quot;../images/forestgreen-chip.png&quot; width=16 height=16 /&gt; rgb( 34, 139, 34).
+	static CL_Color forestgreen;
+
+	//: &lt;img src=&quot;../images/fuchsia-chip.png&quot; width=16 height=16 /&gt; rgb(255, 0, 255).
+	static CL_Color fuchsia;
+
+	//: &lt;img src=&quot;../images/gainsboro-chip.png&quot; width=16 height=16 /&gt; rgb(220, 220, 220).
+	static CL_Color gainsboro;
+
+	//: &lt;img src=&quot;../images/ghostwhite-chip.png&quot; width=16 height=16 /&gt; rgb(248, 248, 255).
+	static CL_Color ghostwhite;
+
+	//: &lt;img src=&quot;../images/gold-chip.png&quot; width=16 height=16 /&gt; rgb(255, 215, 0).
+	static CL_Color gold;
+
+	//: &lt;img src=&quot;../images/goldenrod-chip.png&quot; width=16 height=16 /&gt; rgb(218, 165, 32).
+	static CL_Color goldenrod;
+
+	//: &lt;img src=&quot;../images/gray-chip.png&quot; width=16 height=16 /&gt; rgb(128, 128, 128).
+	static CL_Color gray;
+
+	//: &lt;img src=&quot;../images/grey-chip.png&quot; width=16 height=16 /&gt; rgb(128, 128, 128).
+	static CL_Color grey;
+
+	//: &lt;img src=&quot;../images/green-chip.png&quot; width=16 height=16 /&gt; rgb( 0, 128, 0).
+	static CL_Color green;
+
+	//: &lt;img src=&quot;../images/greenyellow-chip.png&quot; width=16 height=16 /&gt; rgb(173, 255, 47).
+	static CL_Color greenyellow;
+
+	//: &lt;img src=&quot;../images/honeydew-chip.png&quot; width=16 height=16 /&gt; rgb(240, 255, 240).
+	static CL_Color honeydew;
+
+	//: &lt;img src=&quot;../images/hotpink-chip.png&quot; width=16 height=16 /&gt; rgb(255, 105, 180).
+	static CL_Color hotpink;
+
+	//: &lt;img src=&quot;../images/indianred-chip.png&quot; width=16 height=16 /&gt; rgb(205, 92, 92).
+	static CL_Color indianred;
+
+	//: &lt;img src=&quot;../images/indigo-chip.png&quot; width=16 height=16 /&gt; rgb( 75, 0, 130).
+	static CL_Color indigo;
+
+	//: &lt;img src=&quot;../images/ivory-chip.png&quot; width=16 height=16 /&gt; rgb(255, 255, 240).
+	static CL_Color ivory;
+
+	//: &lt;img src=&quot;../images/khaki-chip.png&quot; width=16 height=16 /&gt; rgb(240, 230, 140).
+	static CL_Color khaki;
+
+	//: &lt;img src=&quot;../images/lavender-chip.png&quot; width=16 height=16 /&gt; rgb(230, 230, 250).
+	static CL_Color lavender;
+
+	//: &lt;img src=&quot;../images/lavenderblush-chip.png&quot; width=16 height=16 /&gt; rgb(255, 240, 245).
+	static CL_Color lavenderblush;
+
+	//: &lt;img src=&quot;../images/lawngreen-chip.png&quot; width=16 height=16 /&gt; rgb(124, 252, 0).
+	static CL_Color lawngreen;
+
+	//: &lt;img src=&quot;../images/lemonchiffon-chip.png&quot; width=16 height=16 /&gt; rgb(255, 250, 205).
+	static CL_Color lemonchiffon;
+
+	//: &lt;img src=&quot;../images/lightblue-chip.png&quot; width=16 height=16 /&gt; rgb(173, 216, 230).
+	static CL_Color lightblue;
+
+	//: &lt;img src=&quot;../images/lightcoral-chip.png&quot; width=16 height=16 /&gt; rgb(240, 128, 128).
+	static CL_Color lightcoral;
+
+	//: &lt;img src=&quot;../images/lightcyan-chip.png&quot; width=16 height=16 /&gt; rgb(224, 255, 255).
+	static CL_Color lightcyan;
+
+	//: &lt;img src=&quot;../images/lightgoldenrodyellow-chip.png&quot; width=16 height=16 /&gt; rgb(250, 250, 210).
+	static CL_Color lightgoldenrodyellow;
+
+	//: &lt;img src=&quot;../images/lightgray-chip.png&quot; width=16 height=16 /&gt; rgb(211, 211, 211).
+	static CL_Color lightgray;
+
+	//: &lt;img src=&quot;../images/lightgreen-chip.png&quot; width=16 height=16 /&gt; rgb(144, 238, 144).
+	static CL_Color lightgreen;
+
+	//: &lt;img src=&quot;../images/lightgrey-chip.png&quot; width=16 height=16 /&gt; rgb(211, 211, 211).
+	static CL_Color lightgrey;
+
+	//: &lt;img src=&quot;../images/lightpink-chip.png&quot; width=16 height=16 /&gt; rgb(255, 182, 193).
+	static CL_Color lightpink;
+
+	//: &lt;img src=&quot;../images/lightsalmon-chip.png&quot; width=16 height=16 /&gt; rgb(255, 160, 122).
+	static CL_Color lightsalmon;
+
+	//: &lt;img src=&quot;../images/lightseagreen-chip.png&quot; width=16 height=16 /&gt; rgb( 32, 178, 170).
+	static CL_Color lightseagreen;
+
+	//: &lt;img src=&quot;../images/lightskyblue-chip.png&quot; width=16 height=16 /&gt; rgb(135, 206, 250).
+	static CL_Color lightskyblue;
+
+	//: &lt;img src=&quot;../images/lightslategray-chip.png&quot; width=16 height=16 /&gt; rgb(119, 136, 153).
+	static CL_Color lightslategray;
+
+	//: &lt;img src=&quot;../images/lightslategrey-chip.png&quot; width=16 height=16 /&gt; rgb(119, 136, 153).
+	static CL_Color lightslategrey;
+
+	//: &lt;img src=&quot;../images/lightsteelblue-chip.png&quot; width=16 height=16 /&gt; rgb(176, 196, 222).
+	static CL_Color lightsteelblue;
+
+	//: &lt;img src=&quot;../images/lightyellow-chip.png&quot; width=16 height=16 /&gt; rgb(255, 255, 224).
+	static CL_Color lightyellow;
+
+	//: &lt;img src=&quot;../images/lime-chip.png&quot; width=16 height=16 /&gt; rgb( 0, 255, 0).
+	static CL_Color lime;
+
+	//: &lt;img src=&quot;../images/limegreen-chip.png&quot; width=16 height=16 /&gt; rgb( 50, 205, 50).
+	static CL_Color limegreen;
+
+	//: &lt;img src=&quot;../images/linen-chip.png&quot; width=16 height=16 /&gt; rgb(250, 240, 230).
+	static CL_Color linen;
+
+	//: &lt;img src=&quot;../images/magenta-chip.png&quot; width=16 height=16 /&gt; rgb(255, 0, 255).
+	static CL_Color magenta;
+
+	//: &lt;img src=&quot;../images/maroon-chip.png&quot; width=16 height=16 /&gt; rgb(128, 0, 0).
+	static CL_Color maroon;
+
+	//: &lt;img src=&quot;../images/mediumaquamarine-chip.png&quot; width=16 height=16 /&gt; rgb(102, 205, 170).
+	static CL_Color mediumaquamarine;
+
+	//: &lt;img src=&quot;../images/mediumblue-chip.png&quot; width=16 height=16 /&gt; rgb( 0, 0, 205).
+	static CL_Color mediumblue;
+
+	//: &lt;img src=&quot;../images/mediumorchid-chip.png&quot; width=16 height=16 /&gt; rgb(186, 85, 211).
+	static CL_Color mediumorchid;
+
+	//: &lt;img src=&quot;../images/mediumpurple-chip.png&quot; width=16 height=16 /&gt; rgb(147, 112, 219).
+	static CL_Color mediumpurple;
+
+	//: &lt;img src=&quot;../images/mediumseagreen-chip.png&quot; width=16 height=16 /&gt; rgb( 60, 179, 113).
+	static CL_Color mediumseagreen;
+
+	//: &lt;img src=&quot;../images/mediumslateblue-chip.png&quot; width=16 height=16 /&gt; rgb(123, 104, 238).
+	static CL_Color mediumslateblue;
+
+	//: &lt;img src=&quot;../images/mediumspringgreen-chip.png&quot; width=16 height=16 /&gt; rgb( 0, 250, 154).
+	static CL_Color mediumspringgreen;
+
+	//: &lt;img src=&quot;../images/mediumturquoise-chip.png&quot; width=16 height=16 /&gt; rgb( 72, 209, 204).
+	static CL_Color mediumturquoise;
+
+	//: &lt;img src=&quot;../images/mediumvioletred-chip.png&quot; width=16 height=16 /&gt; rgb(199, 21, 133).
+	static CL_Color mediumvioletred;
+
+	//: &lt;img src=&quot;../images/midnightblue-chip.png&quot; width=16 height=16 /&gt; rgb( 25, 25, 112).
+	static CL_Color midnightblue;
+
+	//: &lt;img src=&quot;../images/mintcream-chip.png&quot; width=16 height=16 /&gt; rgb(245, 255, 250).
+	static CL_Color mintcream;
+
+	//: &lt;img src=&quot;../images/mistyrose-chip.png&quot; width=16 height=16 /&gt; rgb(255, 228, 225).
+	static CL_Color mistyrose;
+
+	//: &lt;img src=&quot;../images/moccasin-chip.png&quot; width=16 height=16 /&gt; rgb(255, 228, 181).
+	static CL_Color moccasin;
+
+	//: &lt;img src=&quot;../images/navajowhite-chip.png&quot; width=16 height=16 /&gt; rgb(255, 222, 173).
+	static CL_Color navajowhite;
+
+	//: &lt;img src=&quot;../images/navy-chip.png&quot; width=16 height=16 /&gt; rgb( 0, 0, 128).
+	static CL_Color navy;
+
+	//: &lt;img src=&quot;../images/oldlace-chip.png&quot; width=16 height=16 /&gt; rgb(253, 245, 230).
+	static CL_Color oldlace;
+
+	//: &lt;img src=&quot;../images/olive-chip.png&quot; width=16 height=16 /&gt; rgb(128, 128, 0).
+	static CL_Color olive;
+
+	//: &lt;img src=&quot;../images/olivedrab-chip.png&quot; width=16 height=16 /&gt; rgb(107, 142, 35).
+	static CL_Color olivedrab;
+
+	//: &lt;img src=&quot;../images/orange-chip.png&quot; width=16 height=16 /&gt; rgb(255, 165, 0).
+	static CL_Color orange;
+
+	//: &lt;img src=&quot;../images/orangered-chip.png&quot; width=16 height=16 /&gt; rgb(255, 69, 0).
+	static CL_Color orangered;
+
+	//: &lt;img src=&quot;../images/orchid-chip.png&quot; width=16 height=16 /&gt; rgb(218, 112, 214).
+	static CL_Color orchid;
+
+	//: &lt;img src=&quot;../images/palegoldenrod-chip.png&quot; width=16 height=16 /&gt; rgb(238, 232, 170).
+	static CL_Color palegoldenrod;
+
+	//: &lt;img src=&quot;../images/palegreen-chip.png&quot; width=16 height=16 /&gt; rgb(152, 251, 152).
+	static CL_Color palegreen;
+
+	//: &lt;img src=&quot;../images/paleturquoise-chip.png&quot; width=16 height=16 /&gt; rgb(175, 238, 238).
+	static CL_Color paleturquoise;
+
+	//: &lt;img src=&quot;../images/palevioletred-chip.png&quot; width=16 height=16 /&gt; rgb(219, 112, 147).
+	static CL_Color palevioletred;
+
+	//: &lt;img src=&quot;../images/papayawhip-chip.png&quot; width=16 height=16 /&gt; rgb(255, 239, 213).
+	static CL_Color papayawhip;
+
+	//: &lt;img src=&quot;../images/peachpuff-chip.png&quot; width=16 height=16 /&gt; rgb(255, 218, 185).
+	static CL_Color peachpuff;
+
+	//: &lt;img src=&quot;../images/peru-chip.png&quot; width=16 height=16 /&gt; rgb(205, 133, 63).
+	static CL_Color peru;
+
+	//: &lt;img src=&quot;../images/pink-chip.png&quot; width=16 height=16 /&gt; rgb(255, 192, 203).
+	static CL_Color pink;
+
+	//: &lt;img src=&quot;../images/plum-chip.png&quot; width=16 height=16 /&gt; rgb(221, 160, 221).
+	static CL_Color plum;
+
+	//: &lt;img src=&quot;../images/powderblue-chip.png&quot; width=16 height=16 /&gt; rgb(176, 224, 230).
+	static CL_Color powderblue;
+
+	//: &lt;img src=&quot;../images/purple-chip.png&quot; width=16 height=16 /&gt; rgb(128, 0, 128).
+	static CL_Color purple;
+
+	//: &lt;img src=&quot;../images/red-chip.png&quot; width=16 height=16 /&gt; rgb(255, 0, 0).
+	static CL_Color red;
+
+	//: &lt;img src=&quot;../images/rosybrown-chip.png&quot; width=16 height=16 /&gt; rgb(188, 143, 143).
+	static CL_Color rosybrown;
+
+	//: &lt;img src=&quot;../images/royalblue-chip.png&quot; width=16 height=16 /&gt; rgb( 65, 105, 225).
+	static CL_Color royalblue;
+
+	//: &lt;img src=&quot;../images/saddlebrown-chip.png&quot; width=16 height=16 /&gt; rgb(139, 69, 19).
+	static CL_Color saddlebrown;
+
+	//: &lt;img src=&quot;../images/salmon-chip.png&quot; width=16 height=16 /&gt; rgb(250, 128, 114).
+	static CL_Color salmon;
+
+	//: &lt;img src=&quot;../images/sandybrown-chip.png&quot; width=16 height=16 /&gt; rgb(244, 164, 96).
+	static CL_Color sandybrown;
+
+	//: &lt;img src=&quot;../images/seagreen-chip.png&quot; width=16 height=16 /&gt; rgb( 46, 139, 87).
+	static CL_Color seagreen;
+
+	//: &lt;img src=&quot;../images/seashell-chip.png&quot; width=16 height=16 /&gt; rgb(255, 245, 238).
+	static CL_Color seashell;
+
+	//: &lt;img src=&quot;../images/sienna-chip.png&quot; width=16 height=16 /&gt; rgb(160, 82, 45).
+	static CL_Color sienna;
+
+	//: &lt;img src=&quot;../images/silver-chip.png&quot; width=16 height=16 /&gt; rgb(192, 192, 192).
+	static CL_Color silver;
+
+	//: &lt;img src=&quot;../images/skyblue-chip.png&quot; width=16 height=16 /&gt; rgb(135, 206, 235).
+	static CL_Color skyblue;
+
+	//: &lt;img src=&quot;../images/slateblue-chip.png&quot; width=16 height=16 /&gt; rgb(106, 90, 205).
+	static CL_Color slateblue;
+
+	//: &lt;img src=&quot;../images/slategray-chip.png&quot; width=16 height=16 /&gt; rgb(112, 128, 144).
+	static CL_Color slategray;
+
+	//: &lt;img src=&quot;../images/slategrey-chip.png&quot; width=16 height=16 /&gt; rgb(112, 128, 144).
+	static CL_Color slategrey;
+
+	//: &lt;img src=&quot;../images/snow-chip.png&quot; width=16 height=16 /&gt; rgb(255, 250, 250).
+	static CL_Color snow;
+
+	//: &lt;img src=&quot;../images/springgreen-chip.png&quot; width=16 height=16 /&gt; rgb( 0, 255, 127).
+	static CL_Color springgreen;
+
+	//: &lt;img src=&quot;../images/steelblue-chip.png&quot; width=16 height=16 /&gt; rgb( 70, 130, 180).
+	static CL_Color steelblue;
+
+	//: &lt;img src=&quot;../images/tan-chip.png&quot; width=16 height=16 /&gt; rgb(210, 180, 140).
+	static CL_Color tan;
+
+	//: &lt;img src=&quot;../images/teal-chip.png&quot; width=16 height=16 /&gt; rgb( 0, 128, 128).
+	static CL_Color teal;
+
+	//: &lt;img src=&quot;../images/thistle-chip.png&quot; width=16 height=16 /&gt; rgb(216, 191, 216).
+	static CL_Color thistle;
+
+	//: &lt;img src=&quot;../images/tomato-chip.png&quot; width=16 height=16 /&gt; rgb(255, 99, 71).
+	static CL_Color tomato;
+
+	//: &lt;img src=&quot;../images/turquoise-chip.png&quot; width=16 height=16 /&gt; rgb( 64, 224, 208).
+	static CL_Color turquoise;
+
+	//: &lt;img src=&quot;../images/violet-chip.png&quot; width=16 height=16 /&gt; rgb(238, 130, 238).
+	static CL_Color violet;
+
+	//: &lt;img src=&quot;../images/wheat-chip.png&quot; width=16 height=16 /&gt; rgb(245, 222, 179).
+	static CL_Color wheat;
+
+	//: &lt;img src=&quot;../images/white-chip.png&quot; width=16 height=16 /&gt; rgb(255, 255, 255).
+	static CL_Color white;
+
+	//: &lt;img src=&quot;../images/whitesmoke-chip.png&quot; width=16 height=16 /&gt; rgb(245, 245, 245).
+	static CL_Color whitesmoke;
+
+	//: &lt;img src=&quot;../images/yellow-chip.png&quot; width=16 height=16 /&gt; rgb(255, 255, 0).
+	static CL_Color yellow;
+
+	//: &lt;img src=&quot;../images/yellowgreen-chip.png&quot; width=16 height=16 /&gt; rgb(154, 205, 50).
+	static CL_Color yellowgreen;
+	
+	//: Find and returns the static color matching a string.
+	//param name: Name of color to match, eg. &quot;blue&quot;.
+	//return: Reference to matching static color, or rgba(0,0,0,0) if there was no match.
+	static CL_Color &amp;find_color(const std::string &amp;name);
+	
+	//: Returns the names of static colors defined.
+	static std::vector&lt;std::string&gt; &amp;get_names();
+
+//! Operations:
+public:
+	//: Set alpha color component, in the range 0-255.
+	void set_alpha(unsigned int value) { color = (color &amp; 0x00ffffff) | (value &lt;&lt; 24); }
+
+	//: Set red color component, in the range 0-255.
+	void set_red(unsigned int value) { color = (color &amp; 0xff00ffff) | (value &lt;&lt; 16); }
+
+	//: Set green color component, in the range 0-255.
+	void set_green(unsigned int value) { color = (color &amp; 0xffff00ff) | (value &lt;&lt; 8); }
+
+	//: Set blue color component, in the range 0-255.
+	void set_blue(unsigned int value) { color = (color &amp; 0xffffff00) | value; }
+
+	//: Set color based on rgba color components in the range 0-255.
+	void set_color(unsigned int red, unsigned int green, unsigned int blue, unsigned int alpha = 255)
+	{ color = (alpha&lt;&lt;24) | (red&lt;&lt;16) | (green&lt;&lt;8) | blue; }
+
+	//: Converts the color to a given pixel format.
+	unsigned int to_pixelformat(const CL_PixelFormat &amp;pf) const;
+
+	//: Converts a raw pixel in a given pixel format to a color.
+	static CL_Color from_pixelformat(unsigned int raw_color, const CL_PixelFormat &amp;pf);
+};
+
+//: float pointing based Color description class.
+//- !group=Display/Display 2D!
+//- !header=display.h!
+class CL_Colorf
+{
+//! Attributes:
+public:
+	float red;
+	float green;
+	float blue;
+	float alpha;
+
+//! Operations:
+public:
+
+	//: Constructs a black and fully transparent color.
+	CL_Colorf()
+		: red(0.0f),
+		  green(0.0f),
+		  blue(0.0f),
+		  alpha(0.0f)
+	{}
+
+	//: Construct a CL_Colorf out of a given byte based CL_Color
+	CL_Colorf(const CL_Color&amp; color)
+		: red(color.get_red()/255.0f), 
+		  green(color.get_green()/255.0f), 
+		  blue(color.get_blue()/255.0f), 
+		  alpha(color.get_alpha()/255.0f)
+	{}
+
+	//: Constructs a color.
+	//- &lt;p&gt;Color components are specified in the range 0.0f to 1.0f.&lt;/p&gt;
+	//- &lt;p&gt;An alpha value of 0.0f means complete transparency, while 1.0f means completely opaque (solid).&lt;/p&gt;
+	//param red: Red color component.
+	//param green: Green color component.
+	//param blue: Blue color component.
+	//param alpha: Alpha (transparency) color component.
+	CL_Colorf(float r, float g, float b, float a = 1.0f)
+		: red(r), green(g), blue(b), alpha(a)
+	{}
+
+	//: Normalize the color by ensuring that all color values lie inbetween (0.0, 1.0)
+	void normalize() 
+	{
+		red   = (red   &lt; 0.0f) ? 0.0f : ((red   &gt; 1.0f) ? 1.0f : red);
+		green = (green &lt; 0.0f) ? 0.0f : ((green &gt; 1.0f) ? 1.0f : green);
+		blue  = (blue  &lt; 0.0f) ? 0.0f : ((blue  &gt; 1.0f) ? 1.0f : blue);
+		alpha = (alpha &lt; 0.0f) ? 0.0f : ((alpha &gt; 1.0f) ? 1.0f : alpha);
+	}
+
+// Operations:
+public:
+	//: Color == Color operator (deep compare)
+	bool operator==(const CL_Colorf &amp;c) const
+	{ return (red == c.red) &amp;&amp; (green == c.green) &amp;&amp; (blue == c.blue) &amp;&amp; (alpha == c.alpha); }
+
+	//: Color != Color operator (deep compare)
+	bool operator!=(const CL_Colorf &amp;c) const
+	{ return (red != c.red) || (green != c.green) || (blue != c.blue) || (alpha != c.alpha); }
+};
+
+#endif

Added: trunk/clanlib/API/Display/display.h
===================================================================
--- trunk/clanlib/API/Display/display.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/display.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,375 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Display 2D&quot;
+//! header=display.h
+
+#ifndef header_display
+#define header_display
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4786)
+#endif
+
+#include &lt;string&gt;
+#include &quot;color.h&quot;
+#include &quot;gradient.h&quot;
+#include &quot;../signals.h&quot;
+#include &quot;../Core/Math/rect.h&quot;
+#include &quot;../Core/Math/quad.h&quot;
+#include &quot;../Core/Math/size.h&quot;
+#include &quot;../Core/Math/point.h&quot;
+#include &quot;../Core/Math/matrix4x4.h&quot;
+
+class CL_DisplayWindow;
+class CL_InputEvent;
+class CL_PixelBuffer;
+class CL_DisplayMode;
+class CL_Surface;
+
+//: Top level display class.
+//- !group=Display/Display 2D!
+//- !header=display.h!
+//- &lt;p&gt;The display class provides a static function interface to
+//- CL_DisplayWindow and other clanDisplay classes. It uses a selected
+//- display window (by default the first created window) to call the
+//- equalent functions in CL_DisplayWindow, CL_GraphicContext and such.&lt;/p&gt;
+//- &lt;p&gt;The entire point of this is to allow applications with only one
+//- window to not pass around a pointer to the display window.&lt;/p&gt;
+class CL_API_DISPLAY CL_Display
+{
+//! Attributes:
+public:
+	//: Returns the currently selected window.
+	static CL_DisplayWindow *get_current_window();
+
+	//: Returns the current width of the window.
+	static int get_width();
+
+	//: Returns the current height of the window.
+	static int get_height();
+
+	//: Returns true if window is currently running fullscreen.
+	static bool is_fullscreen();
+
+	//: Returns true if window has focus.
+	static bool has_focus();
+
+	//: Returns the pixel buffer for the specified flipping buffer.
+	static CL_PixelBuffer get_buffer(int i);
+
+	//: Returns the amount of flipping buffers being used.
+	static int get_buffer_count();
+
+	//: Returns the current flipping buffer being used as the front buffer.
+	static CL_PixelBuffer get_front_buffer();
+
+	//: Returns the current flipping buffer being used as the back buffer.
+	static CL_PixelBuffer get_back_buffer();
+
+	//: Returns the current clipping rectangle used on the graphic context.
+	static const CL_Rect &amp;get_cliprect();
+
+	//: Returns the current effective modelview.
+	static const CL_Matrix4x4 &amp;get_modelview();
+	
+//! Operations:
+public:
+	//: Sets the currently selected window.
+	static void set_current_window(CL_DisplayWindow *window);
+
+	//: Change window to running fullscreen mode.
+	static void set_fullscreen(int width, int height, int bpp);
+
+	//: Change window to running fullscreen mode.
+	static void set_fullscreen(const CL_DisplayMode &amp;display_mode);
+
+	//: Change window to running windowed mode.
+	static void set_windowed();
+
+	//: Change window title.
+	static void set_title(const std::string &amp;title);
+
+	//: Set window position and size.
+	static void set_position(const CL_Rect &amp;pos);
+
+	static void set_position(int x, int y);
+
+	//: Resize window.
+	static void set_size(int width, int height);
+
+	//: Changes the amount of surface buffers used in the flipping system.
+	//: (2 = double buffer, 3 = triple buffer)
+	static void set_buffer_count(int flipping_buffers);
+
+	//: Copy the specified rectangle area from back buffer to front buffer.
+	static void update(const CL_Rect &amp;rect);
+
+	//: Flip back buffer to front, making changes visible on screen.
+	//param interval: Specifies the minimum number of video frames that are displayed before a buffer swap will occur.
+	//- &lt;p&gt;The parameter interval specifies the minimum number of video frames
+	//- that are displayed before a buffer swap will occur.&lt;/p&gt;
+	//- &lt;p&gt;A video frame period is the time required by the monitor to display a 
+	//- full frame of video data.  In the case of an interlaced monitor,
+	//- this is typically the time required to display both the even and odd 
+	//- fields of a frame of video data.  An interval set to a value of 2
+	//- means that the color buffers will be swapped at most every other video
+	//- frame.&lt;/p&gt;
+	//- &lt;p&gt;If interval is set to a value of 0, buffer swaps are not synchronized
+	//- to a video frame.  The interval value is silently clamped to
+	//- the maximum implementation-dependent value supported before being
+	//- stored.&lt;/p&gt;
+	//- &lt;p&gt;If interval is set to a value of -1 (the default), then it will use
+	//- the buffer swap used for previous flip. If its the first flip, it will
+	//- use the system default, which per default is 1.&lt;/p&gt;
+	static void flip(int interval = -1);
+
+	//: Flushes current rendering batch.
+	//- &lt;p&gt;With the OpenGL target, this causes the graphic context to end its current
+	//- active glBegin()/glEnd() pair, making it possible to call other OpenGL calls.&lt;/p&gt;
+	static void flush();
+
+	//: Draw a pixel at (x, y) using the specified color.
+	static void draw_pixel(int x, int y, const CL_Color &amp;color);
+
+	//: Draw a line from (x1, y1) to (x2, y2) using the specified color.
+	static void draw_line(float x1, float y1, float x2, float y2, const CL_Color &amp;color);
+	static void draw_line(const CL_Pointf &amp;a, const CL_Pointf &amp;b, const CL_Color &amp;color);
+
+	//: Draw multiple lines using the specified color.
+	//param double *vertices : start/end points of line segments in format x,y,x,y,x...
+	//param CL_Color &amp;color : color of lines
+	static void draw_lines(int count, double *vertices, const CL_Color &amp;color);
+
+	//: Draw a rectangle using the specified color.
+	static void draw_rect(const CL_Rectf &amp;rect, const CL_Color &amp;color);
+
+	//: Draw a gradient rectangle using the specified gradient.
+	static void fill_rect(const CL_Rectf &amp;rect, const CL_Gradient &amp;gradient);
+
+	//: Draw a filled rectangle using the specified color.
+	static void fill_rect(const CL_Rectf &amp;rect, const CL_Color &amp;color);
+	
+	//: Draw a quad using the specified color.
+	static void draw_quad(const CL_Quad &amp;quad, const CL_Color &amp;color);
+
+	//: Draw a gradient quad using the specified gradient.
+	static void fill_quad(const CL_Quad &amp;quad, const CL_Gradient &amp;gradient);
+
+	//: Draw a filled quad using the specified color.
+	static void fill_quad(const CL_Quad &amp;quad, const CL_Color &amp;color);
+
+	//: Draw a triangle using the specified color.
+	//param double x : x coordinates of triangle vertices
+	//param double y : y coordinates of triangle vertices
+	//param CL_Color &amp;Color : color to use
+	static void draw_triangle(
+		double x1, double y1,
+		double x2, double y2,
+		double x3, double y3,
+		const CL_Color &amp;color);
+
+	//: Draw a gradient filled triangle.
+	//param double x : x coordinates of triangle vertices
+	//param double y : y coordinates of triangle vertices
+	//param CL_Gradient &amp;gradient : color gradient to use
+	static void fill_triangle(
+		double x1, double y1,
+		double x2, double y2,
+		double x3, double y3,
+		const CL_Gradient &amp;gradient);
+
+	//: Draw triangles with color array (optionally textured).
+	//- &lt;p&gt;uchar color array, range: 0-255
+	//- integer (pixel) texture coordinates&lt;/p&gt;
+	//param unsigned int count : number of triangles to draw
+	//param bool fill : draw filled/outline
+	//param double *vertices : pointer to array of triangle vertices (x y z x y z x...)
+	//param unsigned char *color : pointer to array of triangle vertice colors (r b g a r g b a r...)
+	//param int *uv : (optional) pointer to array of triangle vertice texture coordinates (u v u v u...)
+	//param CL_Surface *texture : (optional) texture to use
+	static void draw_triangles(
+		unsigned int count,
+		bool fill,
+		double *vertices,
+		unsigned char *color,
+		int *uv=0,
+		CL_Surface *texture=0);
+
+	//: Draw triangles with single color (optionally textured).
+	//- &lt;p&gt;single color
+	//- integer (pixel) texture coordinates&lt;/p&gt;
+	//param unsigned int count : number of triangles to draw
+	//param bool fill : draw filled/outline
+	//param double *vertices : pointer to array of triangle vertices (x y z x y z x...)
+	//param CL_Color &amp;color : triangle color
+	//param int *uv : (optional) pointer to array of triangle vertice texture coordinates (u v u v u...)
+	//param CL_Surface *texture : (optional) texture to use
+	static void draw_triangles(
+		unsigned int count,
+		bool fill,
+		double *vertices,
+		const CL_Color &amp;color,
+		int *uv=0,
+		CL_Surface *texture=0);
+
+	//: Draw triangle array with color array (optionally textured).
+	//- &lt;p&gt; double color array, range: 0-1
+	//- double (0-1) texture coordinates&lt;/p&gt;
+	//param unsigned int count : number of triangles to draw
+	//param bool fill : draw filled/outline
+	//param double *vertices : pointer to array of triangle vertices (x y z x y z x...)
+	//param double *color : pointer to array of triangle vertice colors (r b g a r g b a r...)
+	//param int *uv : (optional) pointer to array of triangle vertice texture coordinates (u v u v u...)
+	//param CL_Surface *texture : (optional) texture to use
+	static void draw_trianglesd(
+		unsigned int count,
+		bool fill,
+		double *vertices,
+		double *color=0,
+		double *uv=0,
+		CL_Surface *texture=0);
+
+	//: Draw triangles with single color (optionally textured).
+	//- &lt;p&gt;single color
+	//- double (0-1) texture coordinates&lt;/p&gt;
+	//param unsigned int count : number of triangles to draw
+	//param bool fill : draw filled/outline
+	//param double *vertices : pointer to array of triangle vertices (x y z x y z x...)
+	//param CL_Color &amp;color : triangle color
+	//param double *uv : (optional) pointer to array of triangle vertice texture coordinates (u v u v u...)
+	//param CL_Surface *texture : (optional) texture to use
+	static void draw_trianglesd(
+		unsigned int count,
+		bool fill,
+		double *vertices,
+		const CL_Color &amp;color,
+		double *uv=0,
+		CL_Surface *texture=0);
+
+	//: Clears the whole window using the specified color.
+	static void clear(const CL_Color &amp;color = CL_Color(0,0,0));
+
+	//: Set the current clipping rectangle.
+	static void set_cliprect(const CL_Rect &amp;rect);
+
+	//: Push current clipping rectangle to stack.
+	//- &lt;p&gt;If a rectangle is passed, it afterwards sets clipping
+	//- rectangle to the union of the current rectangle and the passed
+	//- rectangle.&lt;/p&gt;
+	static void push_cliprect(const CL_Rect &amp;rect);
+
+	static void push_cliprect();
+
+	//: Pop current clipping rectangle from the stack.
+	static void pop_cliprect();
+
+	//: Sets the model view matrix to a new matrix.
+	static void set_modelview(const CL_Matrix4x4 &amp;matrix);
+
+	//: Multiplies the passed matrix onto the model view matrix.
+	static void add_modelview(const CL_Matrix4x4 &amp;matrix);
+
+	//: Pushes current model view matrix onto the model view stack.
+	static void push_modelview();
+
+	//: Sets a translate offset matrix, ignoring any earlier modelview settings.
+	//- &lt;p&gt; This offset will affect any subsequent display operations on the current
+	//- displaycard, by translating the position of the display operation with the offset.&lt;/p&gt;
+	static void set_translate(double x, double y, double z = 0.0);
+
+	//: Adds the translate offset.
+	//- &lt;p&gt; This offset will affect any subsequent display operations on the current
+	//- displaycard, by translating the position of the display operation with the offset.
+	//- The offset will be offset by any previous offsets pushed onto the stack,
+	//- eg. it inherits the previous offset. &lt;/p&gt;
+	static void add_translate(double x, double y, double z = 0.0);
+	
+	//: Push translation offset onto model view stack.
+	//- &lt;p&gt;This function is a convenience function for calling push_modelview, then add_translate.&lt;/p&gt;
+	//- &lt;p&gt; This offset will affect any subsequent display operations on the current
+	//- displaycard, by translating the position of the display operation with the offset.
+	//- The offset will be offset by any previous offsets pushed onto the stack,
+	//- eg. it inherits the previous offset. &lt;/p&gt;
+	static void push_translate(double x, double y, double z = 0.0);
+
+	//: Sets a rotation matrix, ignoring any earlier model view settings.
+	static void set_rotate(double angle, double x = 0.0, double y = 0.0, double z = 1.0);
+
+	//: Adds a rotation matrix to existing model view.
+	static void add_rotate(double angle, double x = 0.0, double y = 0.0, double z = 1.0);
+
+	//: Pushes a rotation matrix onto model view stack.
+	static void push_rotate(double angle, double x = 0.0, double y = 0.0, double z = 1.0);
+
+	//: Sets a scale matrix, ignoring any earlier model view settings.
+	static void set_scale(double x, double y, double z = 1.0);
+
+	//: Adds a scale matrix to existing model view.
+	static void add_scale(double x, double y, double z = 1.0);
+
+	//: Pushes a scale matrix onto model view stack.
+	static void push_scale(double x, double y, double z = 1.0);
+
+	//: Pops last pushed model view matrix off the stack and makes it the active one.
+	static void pop_modelview();
+
+//! Signals:
+public:
+	//: Signal emitted when window is resized.
+	static CL_Signal_v2&lt;int, int&gt; &amp;sig_resize();
+
+	//: Signal emitted when an area of the window is invalidated.
+	static CL_Signal_v1&lt;const CL_Rect &amp;&gt; &amp;sig_paint();
+
+	//: Signal emitted when window lost focus.
+	static CL_Signal_v0 &amp;sig_lost_focus();
+
+	//: Signal emitted when window gain focus.
+	static CL_Signal_v0 &amp;sig_got_focus();
+
+	//: Signal emitted when window is closed.
+	static CL_Signal_v0 &amp;sig_window_close();
+};
+
+#endif

Added: trunk/clanlib/API/Display/display_iostream.h
===================================================================
--- trunk/clanlib/API/Display/display_iostream.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/display_iostream.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,43 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_display_iostream
+#define header_display_iostream
+
+#include &lt;iosfwd&gt;
+
+class CL_DisplayWindow;
+class CL_InputDevice;
+class CL_InputEvent;
+
+std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const CL_DisplayWindow&amp; window);
+std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const CL_InputDevice&amp; device);
+std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const CL_InputEvent&amp; event);
+
+#endif

Added: trunk/clanlib/API/Display/display_mode.h
===================================================================
--- trunk/clanlib/API/Display/display_mode.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/display_mode.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,110 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Display 2D&quot;
+//! header=display.h
+
+#ifndef header_display_mode
+#define header_display_mode
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4786)
+#endif
+
+#include &lt;vector&gt;
+#include &lt;string&gt;
+
+class CL_Size;
+class CL_DisplayMode_Generic;
+
+//: Display mode class.
+//- !group=Display/Display 2D!
+//- !header=display.h!
+//- &lt;p&gt;This class contains information about one display mode available.
+//- It also contains a static function to get a list of all available display modes.&lt;/p&gt;
+//- &lt;p&gt;Code example which dumps a list over all available modes:&lt;/p&gt;
+//- &lt;pre&gt;
+//- std::vector &lt; CL_DisplayMode &gt; &amp;modes = CL_DisplayMode::get_display_modes();
+//- for(unsigned int i=0; i &lt; modes.size(); ++i)
+//-     std::cout &lt;&lt; modes[i].get_string() &lt;&lt; std::endl;
+//- &lt;/pre&gt;
+class CL_API_DISPLAY CL_DisplayMode
+{
+//! Construction:
+public:
+	CL_DisplayMode(const CL_Size &amp;res, int bpp, int refresh_rate);
+
+	CL_DisplayMode(const CL_DisplayMode &amp;copy);
+
+	virtual ~CL_DisplayMode();
+
+//! Attributes:
+public:
+	//: Returns the resolution of the displaymode.
+	CL_Size get_resolution() const;
+
+	//: Returns the numbers of bytes per pixel of the displaymode.
+	int get_bpp() const;
+
+	//: Returns the refresh rate of the displaymode.
+	//- &lt;p&gt;Specifies the frequency, in hertz (cycles per second).
+	//- This value is also known as the vertical refresh rate.&lt;/p&gt;
+	int get_refresh_rate() const;
+
+	//: Returns the information as a string in the format &quot;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">640x480x32 at 60</A>&quot;
+	std::string get_string() const;
+
+	//: Returns a list over all available display modes.
+	static std::vector&lt;CL_DisplayMode&gt; &amp;get_display_modes();
+
+//! Operations:
+public:
+	//: Copy assignment operator.
+	CL_DisplayMode &amp;operator =(const CL_DisplayMode &amp;copy);
+
+//! Implementation:
+private:
+	CL_DisplayMode_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Display/display_window.h
===================================================================
--- trunk/clanlib/API/Display/display_window.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/display_window.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,226 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Display 2D&quot;
+//! header=display.h
+
+#ifndef header_display_window
+#define header_display_window
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4786)
+#endif
+
+#include &lt;string&gt;
+#include &quot;../signals.h&quot;
+
+class CL_PixelBuffer;
+class CL_InputEvent;
+class CL_Rect;
+class CL_Size;
+class CL_GraphicContext;
+class CL_InputContext;
+class CL_DisplayWindow_Generic;
+class CL_Sprite;
+class CL_DisplayWindowDescription;
+class CL_DisplayMode;
+
+//: Toplevel window class.
+//- !group=Display/Display 2D!
+//- !header=display.h!
+//- &lt;p&gt;CL_DisplayWindow represents a window in your windowing system
+//- (Windows, X11). You need to create at least one display window in order
+//- to draw graphics in ClanLib.&lt;/p&gt;
+class CL_API_DISPLAY CL_DisplayWindow
+{
+//! Construction:
+public:
+	//: Constructs a window.
+	//param title: Titlebar text.
+	//param width: Width in pixels of window.
+	//param height: Height in pixels of window.
+	//param start_fullscreen: If true, window will go fullscreen.
+	//param allow_resize: If true, window will have resize grabbers and can be resized.
+	//param flipping_buffers: Number of flipping buffers in system.
+	//param flipping_buffers: Default is that there is a front buffer and a back buffer.
+	//param description: Structure that describes how to create the display window.
+	CL_DisplayWindow();
+
+	CL_DisplayWindow(const CL_DisplayWindow &amp;copy);
+
+	CL_DisplayWindow(
+		const std::string &amp;title,
+		int width,
+		int height,
+		bool start_fullscreen = false,
+		bool allow_resize = false,
+		int flipping_buffers = 2);
+
+	CL_DisplayWindow(const CL_DisplayWindowDescription &amp;description);
+
+	~CL_DisplayWindow();
+
+//! Attributes:
+public:
+	//: Returns the current width of the window.
+	int get_width() const;
+
+	//: Returns the current height of the window.
+	int get_height() const;
+
+	//: Returns true if window is currently running fullscreen.
+	bool is_fullscreen() const;
+
+	//: Returns true if window has focus.
+	bool has_focus() const;
+
+	//: Returns the pixel buffer for the specified flipping buffer.
+	CL_PixelBuffer get_buffer(int i) const;
+
+	//: Returns the amount of flipping buffers being used.
+	int get_buffer_count() const;
+
+	//: Returns the current flipping buffer being used as the front buffer.
+	CL_PixelBuffer get_front_buffer();
+
+	//: Returns the current flipping buffer being used as the back buffer.
+	CL_PixelBuffer get_back_buffer();
+
+	//: Returns the graphic context of the current back buffer.
+	CL_GraphicContext *get_gc();
+
+	//: Returns the input context of this window.
+	CL_InputContext *get_ic();
+
+//! Operations:
+public:
+	//: Copy assignment operator.
+	CL_DisplayWindow &amp;operator =(const CL_DisplayWindow &amp;copy);
+
+	//: Change window to running fullscreen mode.
+	void set_fullscreen(int width=0, int height=0, int bpp=0, int refresh_rate=0);
+
+	//: Change window to running fullscreen mode.
+	void set_fullscreen(const CL_DisplayMode &amp;display_mode);
+
+	//: Change window to running windowed mode.
+	void set_windowed();
+
+	//: Change window title.
+	void set_title(const std::string &amp;title);
+
+	//: Set window position and size.
+	//param pos: Window position and size.
+	//param x: Window x position on desktop.
+	//param y: Window y position on desktop.
+	void set_position(const CL_Rect &amp;pos);
+
+	void set_position(int x, int y);
+
+	//: Resize window.
+	//param width: New width of window in pixels.
+	//param height: New height of window in pixels.
+	void set_size(int width, int height);
+
+	//: Changes the amount of pixel buffers used in the flipping system.
+	//param flipping_buffers: New number of flipping buffers.
+	//- &lt;p&gt;2 = double buffer, 3 = triple buffer.&lt;/p&gt;
+	void set_buffer_count(int flipping_buffers);
+
+	//: Copy the specified rectangle area from back buffer to front buffer.
+	//param rect: Area that should be copied.
+	void update(const CL_Rect &amp;rect);
+
+	//: Flip back buffer to front, making changes visible on screen.
+	//param interval: Specifies the minimum number of video frames that are displayed before a buffer swap will occur.
+	//- &lt;p&gt;The parameter interval specifies the minimum number of video frames
+	//- that are displayed before a buffer swap will occur.&lt;/p&gt;
+	//- &lt;p&gt;A video frame period is the time required by the monitor to display a 
+	//- full frame of video data.  In the case of an interlaced monitor,
+	//- this is typically the time required to display both the even and odd 
+	//- fields of a frame of video data.  An interval set to a value of 2
+	//- means that the color buffers will be swapped at most every other video
+	//- frame.&lt;/p&gt;
+	//- &lt;p&gt;If interval is set to a value of 0, buffer swaps are not synchronized
+	//- to a video frame.  The interval value is silently clamped to
+	//- the maximum implementation-dependent value supported before being
+	//- stored.&lt;/p&gt;
+	//- &lt;p&gt;If interval is set to a value of -1 (the default), then it will use
+	//- the buffer swap used for previous flip. If its the first flip, it will
+	//- use the system default, which per default is 1.&lt;/p&gt;
+	void flip(int interval = -1);
+
+	//: Sets the mouse cursor shape.
+	void set_cursor(const CL_Sprite &amp;cursor);
+
+	//: Shows the mouse cursor.
+	void show_cursor();
+
+	//: Hides the mouse cursor.
+	void hide_cursor();
+
+//! Signals:
+public:
+	//: Signal emitted when window lost focus.
+	CL_Signal_v0 &amp;sig_lost_focus();
+
+	//: Signal emitted when window gain focus.
+	CL_Signal_v0 &amp;sig_got_focus();
+
+	//: Signal emitted when window is resized.
+	CL_Signal_v2&lt;int, int&gt; &amp;sig_resize();
+
+	//: Signal emitted when an area of the window is invalidated.
+	CL_Signal_v1&lt;const CL_Rect &amp;&gt; &amp;sig_paint();
+
+	//: Signal emitted when window is closed.
+	CL_Signal_v0 &amp;sig_window_close();
+
+//! Implementation:
+protected:
+	CL_DisplayWindow(CL_DisplayWindow_Generic *impl);
+
+	CL_DisplayWindow_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Display/display_window_description.h
===================================================================
--- trunk/clanlib/API/Display/display_window_description.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/display_window_description.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,149 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Display 2D&quot;
+//! header=display.h
+
+#ifndef header_display_window_description
+#define header_display_window_description
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+#include &quot;../Core/Math/rect.h&quot;
+#include &quot;../Core/System/sharedptr.h&quot;
+
+class CL_DisplayWindowDescription_Generic;
+
+//: Display window description class.
+//- !group=Display/Display 2D!
+//- !header=display.h!
+//- &lt;p&gt;This class allows you to setup a more advanced description when creating
+//- a display window.&lt;/p&gt;
+class CL_API_DISPLAY CL_DisplayWindowDescription
+{
+//! Construction:
+public:
+	//: Constructs a window description with default values.
+	CL_DisplayWindowDescription();
+
+	CL_DisplayWindowDescription(const CL_DisplayWindowDescription &amp;copy);
+
+	virtual ~CL_DisplayWindowDescription();
+
+//! Attributes:
+public:
+	//: Returns the window title stored in the description.
+	const std::string &amp;get_title() const;
+
+	//: Returns the size of the window stored in description.
+	CL_Size get_size() const;
+
+	//: Returns the initial position of the window.
+	CL_Rect get_position() const;
+
+	//: Returns if window should be initially fullscreen.
+	bool is_fullscreen() const;
+
+	//: Returns the amount of flipping buffers to be created.
+	int get_flipping_buffers() const;
+
+	//: Returns true if window should be resizeable.
+	bool get_allow_resize() const;
+	
+	//: Returns the numbers of bytes per pixel in the window.
+	int get_bpp() const;
+
+	//: Returns the refresh rate of the displaymode.
+	//- &lt;p&gt;Specifies the frequency, in hertz (cycles per second).
+	//- This value is also known as the vertical refresh rate.&lt;/p&gt; 
+	int get_refresh_rate() const;
+
+#ifdef WIN32
+	//: Windows 2000/XP only. Returns true if window is layered.
+	bool is_layered() const;
+#endif
+
+//! Operations:
+public:
+	//: Copy assignment operator.
+	CL_DisplayWindowDescription &amp;operator =(const CL_DisplayWindowDescription &amp;copy);
+
+	//: Sets the title of the window.
+	void set_title(const std::string &amp;title);
+
+	//: Sets the size of the window.
+	void set_size(const CL_Size &amp;size);
+
+	//: Sets the position of the window.
+	void set_position(const CL_Rect &amp;position);
+
+	//: Makes the window initially fullscreen.
+	void set_fullscreen(bool fullscreen = true);
+
+	//: Sets the amount of flipping buffers to be used.
+	void set_flipping_buffers(int num_buffers = 2);
+
+	//: Sets if windows should be resizeable.
+	void set_allow_resize(bool allow_resize);
+	
+	//: Sets the number of bytes per pixel
+	void set_bpp(int bpp);
+
+	//: Set the refresh rate of the displaymode.
+	//- &lt;p&gt;Specifies the frequency, in hertz (cycles per second).
+	//- This value is also known as the vertical refresh rate.&lt;/p&gt; 
+	void set_refresh_rate(int refresh_rate);
+
+#ifdef WIN32
+	//: Windows 2000/XP only. Creates a layered window (complex shaped window).
+	void set_layered(bool layered);
+#endif
+
+//! Implementation:
+protected:
+	CL_DisplayWindowDescription(CL_DisplayWindowDescription_Generic *impl);
+
+public:
+	CL_SharedPtr&lt;CL_DisplayWindowDescription_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/Display/font.h
===================================================================
--- trunk/clanlib/API/Display/font.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/font.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,424 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Fonts&quot;
+//! header=display.h
+
+#ifndef header_font
+#define header_font
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4786)
+#endif
+
+#include &lt;string&gt;
+#include &lt;utility&gt; //For std::pair
+
+#include &quot;../Core/Math/origin.h&quot;
+#include &quot;blend_func.h&quot;
+#include &quot;color.h&quot;
+#include &quot;../Core/Math/rect.h&quot;
+#include &quot;../Core/Math/point.h&quot;
+#include &quot;../Core/Math/size.h&quot;
+#include &quot;../Core/Resources/resource.h&quot;
+#include &quot;../Core/System/lazycopyptr.h&quot;
+#include &quot;../Core/System/clonable.h&quot;
+
+class CL_GlyphBuffer;
+class CL_Sprite;
+class CL_TextStyler;
+class CL_Font_Generic;
+class CL_GraphicContext;
+class CL_ResourceManager;
+
+//: Draws text using system fonts or glyph sprites.
+//- !group=Display/Fonts!
+//- !header=display.h!
+//- &lt;p&gt;A font can be constructed either from a CL_Sprite (aka a bitmap font) or from a system
+//- font A bitmap font uses a CL_Sprite as the source for the font
+//- glyphs (letters), where each frame frame in the sprite
+//- represents one glyph. A string (&lt;i&gt;letter_chars&lt;/i&gt;) is then
+//- describing which character each glyph corresponds to. If the
+//- sprite contains the letters ABCZXY123 in that order, then the
+//- string should be &quot;ABCZXY123&quot;. A system font uses the underlaying windowing system to create
+//- the font glyphs. This means that in Windows you can choose any
+//- TTF font, and same applies to X11 if the font server supports
+//- it.&lt;/p&gt;
+//- &lt;p&gt;Newlines always have a width of zero.
+//- Other than that, characters for which glyphs weren't specified have the width of a space.&lt;/p&gt;
+//- &lt;p&gt;Unlike CL_Surface and CL_Sprite, scaling affects the calculation
+//- of any bounding rectangles (such as the result returned
+//- by draw(), bounding_rect(), or get_size(), or the rectangle calculated internally by
+//- draw() for alignment). This is because scaling
+//- the CL_Font is effectively just changing the point size of the glyphs,
+//- and that affects all sorts of things, such as word wrapping.&lt;/p&gt;
+//- &lt;p&gt;Word wrapping works automatically whenever you pass CL_Font a destination rectangle
+//- or size with non-zero width. CL_Font uses the delims string (which can be changed
+//- using the set_delims() method)
+//- to determine where divisions between words are. Word wrapping does allow
+//- blank characters (characters for which there isn't a glyph supplied)
+//- to extend over the border line; this helps wrapped text to remain flush.&lt;/p&gt;
+class CL_API_DISPLAY CL_Font
+{
+//! Construction:
+public:
+	//: Constructs a font.
+	//- &lt;p&gt;If spacelen is unspecified, CL_Font attempts to resolve
+	//- it itself. First, it looks to see if you have specified a
+	//- space character in letter_chars: if you have, it uses that
+	//- glyph's width as the space width (as well as using it
+	//- to actually draw the space). If it does not find a space
+	//- glyph, then it will look at every glyph's width and make
+	//- the space width the average of that.&lt;/p&gt;
+	//param resource_id: Font resource name.
+	//param manager: Resource manager used to load font.
+	//param glyphs: CL_Sprite containing the letters of a bitmap font.
+	//param letters: String mapping each frame of the bitmap font sprite to letters.
+	//param spacelen: Width in pixels of the space glyph. If -1, uses the average of all glyph widths.
+	//param monospace: If true, treats all glyphs as being the same width.
+	//param font_name: System font name (eg. &quot;Arial&quot;).
+	//param letter_chars: The characters to include in the font (if a sprite font, must be in frame order).
+	//param height: Height of font in pixels.
+	//param width: Width of font in pixels. If 0, uses best fitting width for the specified height.
+	//param bold: If true, will use bold font.
+	//param italic: If true, will use italic font.
+	//param underline: If true, will use underlined font.
+	//param strikeout: If true, will use striked out font.
+	CL_Font();
+	
+	CL_Font(const CL_Font &amp;copy);
+	
+	CL_Font(
+		const std::string &amp;resource_id,
+		CL_ResourceManager *manager);
+	
+	CL_Font(
+		const CL_Sprite &amp;glyphs,
+		const std::string &amp;letters,
+		int spacelen = -1,
+		bool monospace = false);
+	
+	CL_Font(
+		const std::string &amp;font_name,
+		const std::string &amp;letters,
+		int height,
+		int width = 0,
+		bool bold = false,
+		bool italic = false,
+		bool underline = false,
+		bool strikeout = false);
+	
+	CL_Font(
+		const std::string &amp;font_name,
+		int height,
+		int width = 0,
+		bool bold = false,
+		bool italic = false,
+		bool underline = false,
+		bool strikeout = false);
+	
+	virtual ~CL_Font();
+
+//! Attributes:
+public:
+	//: Returns delimiters string.
+	//- &lt;p&gt; This string contains characters (other than newline) that divide words apart.
+	//- Do not include newline in this string, it's an implicit delimiter.&lt;/p&gt;
+	std::string get_delims() const;
+	
+	//: Returns width offset.
+	//- &lt;p&gt; The width offset can be used to kern glyphs together or spread them apart. &lt;/p&gt; 
+	int get_width_offset() const;
+	
+	//: Returns height offset.
+	//- &lt;p&gt; The height offset can be used to create space between lines, or to merge them together. &lt;/p&gt; 
+	int get_height_offset() const;
+	
+	//: Returns current scale.
+	//- &lt;p&gt; 1.0f is normal scale, 2.0f is twice the size, etc. &lt;/p&gt;
+	void get_scale(float &amp;x, float &amp;y) const;
+
+	//: Returns current alpha.
+	//- &lt;p&gt; 0.0f is full transparency, and 1.0f is full visibility. &lt;/p&gt;
+	float get_alpha() const;
+
+	//: Returns current color.
+	//- &lt;p&gt; Alpha 0.0f is full transparency, and 1.0f is full visibility (solid). &lt;/p&gt;
+	void get_color(float &amp;red, float &amp;green, float &amp;blue, float &amp;alpha) const;
+	CL_Color get_color() const;
+
+	//: Returns blending functions.
+	void get_blend_func(CL_BlendFunc &amp;src, CL_BlendFunc &amp;dest) const;
+	
+	//: Returns glyph rotation hotspot.
+	//- &lt;p&gt; This is for the optional angle parameter to draw_glyphs(). &lt;/p&gt;
+	void get_glyph_rot_hotspot(CL_Origin &amp;origin, int &amp;x, int &amp;y) const;
+	
+	//: Returns translation hotspot.
+	void get_alignment(CL_Origin &amp;origin, int &amp;x, int &amp;y) const;
+	
+	//: Returns the drawn height of the entire font or a string.
+	//return: The height in pixels.
+	//param str: String to get the height of.
+	//param start: A starting iterator, inclusive.
+	//param end: An ending iterator, exclusive.
+	//param max_size: Same effect as the size of the dest rectangle passed to draw(), for word wrapping and height truncating.
+	//- &lt;p&gt; The height of the entire font is the height of the tallest glyph in the font; this
+	//- is what is returned if you specify no arguments. The point of having the height functions
+	//- accept a string is to compensate for strings spanning multiple lines. Generally, get_height(&quot; &quot;) will return zero, since usually 
+	//- the space glyph isn't given in the font, and so it has a height and width of zero. &lt;/p&gt;
+	int get_height() const;
+	
+	int get_height(
+		const std::string &amp;str,
+		CL_Size max_size = CL_Size(0,0)) const;
+	
+	int get_height(
+		std::string::const_iterator start,
+		std::string::const_iterator end,
+		CL_Size max_size = CL_Size(0,0)) const;
+	
+	//: Returns the drawn width of a character or string.
+	//return: The width in pixels.
+	//param letter: Character to get the width of.
+	//param str: String to get the width of.
+	//param start: A starting iterator, inclusive.
+	//param end: An ending iterator, exclusive.
+	//param max_size: Same effect as the size of the dest rectangle passed to draw(), for word wrapping and height truncating.
+	int get_width(unsigned int letter) const;
+	
+	int get_width(
+		const std::string &amp;str,
+		CL_Size max_size = CL_Size(0,0)) const;
+	
+	int get_width(
+		std::string::const_iterator start,
+		std::string::const_iterator end,
+		CL_Size max_size = CL_Size(0,0)) const;
+	
+	//: Returns the drawn size of a string.
+	//return: The size in pixels.
+	//param letter: Character to get the size of. If unrecognized, returns space width.
+	//param str: String to get the size of.
+	//param start: A starting iterator, inclusive.
+	//param end: An ending iterator, exclusive.
+	//param max_size: Same effect as the size of the dest rectangle passed to draw(), for word wrapping and height truncating.
+	CL_Size get_size(unsigned int letter) const;
+	
+	CL_Size get_size(
+		const std::string &amp;str,
+		CL_Size max_size = CL_Size(0,0)) const;
+	
+	CL_Size get_size(
+		std::string::const_iterator start,
+		std::string::const_iterator end,
+		CL_Size max_size = CL_Size(0,0)) const;
+	
+	//: Calculate the rectangle that would be occupied by a draw operation.
+	//param str: The input string to process.
+	//param start: String position to begin processing at, inclusive.
+	//param end: String position to end processing at, exclusive.
+	//param x, y: Anchor position to simulate draw at. Actual position depends on the alignment mode.
+	//param dest: Rectangle to draw text in. The text will be word-wrapped against delimiters to fit inside the rectangle.
+	//- &lt;p&gt; You can specify a dest rectangle with a width or height of zero or less to disable word wrapping
+	//- or height truncating, respectively. &lt;/p&gt;
+	CL_Rect bounding_rect(int x, int y, const std::string &amp;str) const;
+	
+	CL_Rect bounding_rect(CL_Rect dest, const std::string &amp;str) const;
+	
+	CL_Rect bounding_rect(
+		int x, int y,
+		std::string::const_iterator start,
+		std::string::const_iterator end) const;
+	
+	CL_Rect bounding_rect(
+		CL_Rect dest,
+		std::string::const_iterator start,
+		std::string::const_iterator end) const;
+	
+	//: Returns whether or not a glyph exists for a given character
+	//- &lt;p&gt; This is the same as checking if get_width(chr) returns zero. &lt;/p&gt;
+	bool is_glyph(unsigned int chr) const;
+	
+	//: Resource owning this font, if any.
+	CL_Resource resource;
+	
+//! Operations:
+public:
+	//: Copy assignment operator.
+	CL_Font &amp;operator =(const CL_Font &amp;copy);
+	
+	//: Return true if the CL_Font object is valid
+	operator bool() const;
+
+	//: Draws text to a graphic context.
+	//return: The number of glyphs that were drawn.
+	//param str: The input string to draw.
+	//param start: String position to begin drawing at, inclusive.
+	//param end: String position to end drawing at, exclusive.
+	//param x, y: Anchor position to draw at. Actual drawing position depends on the alignment mode.
+	//param gc: Graphic context on which to draw. If null, will use CL_Display's current graphic context.
+	//param dest: Rectangle to draw text in. The text will be word-wrapped against delimiters to fit inside the rectangle.
+	//- &lt;p&gt; You can specify a dest rectangle with a width or height of zero or less to disable word wrapping
+	//- or height truncating, respectively. &lt;/p&gt;
+	int draw(
+		int x,
+		int y,
+		const std::string &amp;str,
+		CL_GraphicContext *context = 0) const;
+	
+	int draw(
+		CL_Rect dest,
+		const std::string &amp;str,
+		CL_GraphicContext *context = 0) const;
+	
+	int draw(
+		int x,
+		int y,
+		std::string::const_iterator start,
+		std::string::const_iterator end,
+		CL_GraphicContext *context = 0) const;
+	
+	int draw(
+		CL_Rect dest,
+		std::string::const_iterator start,
+		std::string::const_iterator end,
+		CL_GraphicContext *context = 0) const;
+	
+	//: Inserts data into a CL_GlyphBuffer, treating the glyphs already there as part of a previous draw_to_gb().
+	//return: The number of glyphs that were inserted. This could be negative if it backtracks.
+	//param str: The input string to draw.
+	//param start: String position to begin drawing at, inclusive.
+	//param end: String position to end drawing at, exclusive.
+	//param max_size: Sets size for word wrapping and height truncating. Either can be zero to disable that feature.
+	//param gb: The glyph buffer to mess with.
+	//- &lt;p&gt; The CL_GlyphBuffer's contents (the glyphs vector, the font markers map, and the effects maps),
+	//- if any, must not have been created/altered by anything but CL_Font::draw_to_gb() and/or CL_TextStyler::draw_to_gb()
+	//- for this method to work.&lt;/p&gt;
+	//- &lt;p&gt; If you are doing draw_to_gb several sequential times
+	//- to the same CL_GlyphBuffer, then you must pass the same maximum width to each call of
+	//- draw_to_gb. &lt;/p&gt;
+	//- &lt;p&gt; Each glyph inserted into the CL_GlyphBuffer corresponds with exactly one character of the input string, with
+	//- the order in the vector and the order in the string being the same. That is, if you start out with an empty CL_GlyphBuffer,
+	//- run this method on it, and afterwords the CL_GlyphBuffer contains 100 glyphs, then you know the first 100 characters
+	//- of the source string range were processed. This includes whitespace and newline characters.&lt;/p&gt;
+	//- &lt;p&gt; If you call this method on a CL_GlyphBuffer with a last line that is center-justified or left-justified, be aware
+	//- that there's no way for this function to differentiate that line from a left-justified line with an indent, and it
+	//- always assumes the latter. &lt;/p&gt;
+	//- &lt;p&gt; You can tell when you've filled the buffer up to the height in max_size when a call to this method returns
+	//- anything less than the size of the string. There's also the chance that it will backtrack and return
+	//- a negative value if it runs out
+	//- of vertical space in the process of wrapping a just-completed word; this is still a sign that you've
+	//- ran out of vertical space.&lt;/p&gt;
+	int draw_to_gb(
+		const std::string &amp;str,
+		CL_GlyphBuffer &amp;gb,
+		CL_Size max_size = CL_Size(0,0)) const;
+
+	int draw_to_gb(
+		std::string::const_iterator start,
+		std::string::const_iterator end,
+		CL_GlyphBuffer &amp;gb,
+		CL_Size max_size = CL_Size(0,0)) const;
+	
+	//: Draws a single glyph to a given spot.
+	//param x, y: The upper-left coordinates of where to draw the glyph.
+	//param chr: The character to draw the glyph of.
+	//param ang: The amount to rotate the glyph by. The hotspot is set with CL_Font::set_glyph_rot_hotspot().
+	//param gc: Graphic context to render to. If null, will render to the CL_Display currently set window.
+	//- &lt;p&gt; If there is no glyph for the given index, then nothing is drawn. &lt;/p&gt;
+	void draw_glyph(int x, int y, unsigned int glyph, float ang = 0.0, CL_GraphicContext *gc = 0);
+	
+	//: Draws a single character to a given spot.
+	//param x, y: The upper-left coordinates of where to draw the character.
+	//param chr: The character to draw the glyph of.
+	//param ang: The amount to rotate the glyph by. The hotspot is set with CL_Font::set_glyph_rot_hotspot().
+	//param gc: Graphic context to render to. If null, will render to the CL_Display currently set window.
+	//- &lt;p&gt; If there is no glyph for the given character, then nothing is drawn. &lt;/p&gt;
+	void draw_character(int x, int y, unsigned int chr, float ang = 0.0, CL_GraphicContext *gc = 0);
+	
+	//: Sets delimiters string.
+	//- &lt;p&gt; This string contains characters (other than newline) that divide words apart.
+	//- Do not include newline in this string, it's an implicit delimiter.&lt;/p&gt;
+	void set_delims(const std::string &amp;delims);
+	
+	//: Sets width offset.
+	//- &lt;p&gt; The width offset can be used to kern glyphs together or spread them apart. &lt;/p&gt; 
+	void set_width_offset(int offset);
+	
+	//: Sets height offset.
+	//- &lt;p&gt; The height offset can be used to create space between lines, or to merge them together. &lt;/p&gt; 
+	void set_height_offset(int offset);
+	
+	//: Sets scale for x and y directions individually.
+	//- &lt;p&gt; 1.0f is normal scale, 2.0f is twice the size, etc. &lt;/p&gt;
+	void set_scale(float x, float y);
+	
+	//: Sets transparency.
+	//- &lt;p&gt; 0.0f is full transparency, and 1.0f is full visibility. &lt;/p&gt;
+	void set_alpha(float alpha);
+	
+	//: Sets the color.
+	//- &lt;p&gt; Alpha 0.0f is full transparency, and 1.0f is full visibility (solid). &lt;/p&gt;
+	void set_color(float r, float g, float b, float a = 1.0f);
+	void set_color(const CL_Color&amp; c);
+	
+	//: Sets blending functions.
+	void set_blend_func(CL_BlendFunc src, CL_BlendFunc dest);
+	
+	//: Sets glyph rotation hotspot.
+	//- &lt;p&gt; This is for the optional angle parameter to draw_glyphs(). &lt;/p&gt;
+	void set_glyph_rot_hotspot(CL_Origin origin, int x = 0, int y = 0);
+	
+	//: Sets translation hotspot.
+	void set_alignment(CL_Origin origin, int x = 0, int y = 0);
+	
+	//  Get the sprite glyphs
+	CL_Sprite&amp; get_glyphs();
+	
+//! Implementation:
+private:
+	CL_LazyCopyPtr&lt;CL_Clonable, CL_Font_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/Display/frameratecounter.h
===================================================================
--- trunk/clanlib/API/Display/frameratecounter.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/frameratecounter.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,77 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Display 2D&quot;
+//! header=display.h
+
+#ifndef header_frameratecounter
+#define header_frameratecounter
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Core/System/keep_alive.h&quot;
+
+class CL_FramerateCounter_Generic;
+
+//: Framerate counter class.
+//- !group=Display/Display 2D!
+//- !header=display.h!
+class CL_API_DISPLAY CL_FramerateCounter : public CL_KeepAlive
+{
+//! Construction:
+public:
+	//: Constructs a framerate counter.
+	CL_FramerateCounter();
+	~CL_FramerateCounter ();
+
+//! Attributes:
+public:
+	int get_fps();
+	void set_fps_limit(int fps);
+
+//! Implementation:
+private:
+	virtual void keep_alive();
+
+	CL_FramerateCounter_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Display/glyph_buffer.h
===================================================================
--- trunk/clanlib/API/Display/glyph_buffer.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/glyph_buffer.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,577 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Fonts&quot;
+//! header=display.h
+
+#ifndef header_glyph_buffer
+#define header_glyph_buffer
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4786)
+#endif
+
+#include &lt;map&gt;
+#include &lt;vector&gt;
+#include &lt;utility&gt;
+
+#include &quot;font.h&quot;
+#include &quot;../Core/Math/origin.h&quot;
+#include &quot;color.h&quot;
+
+#if defined(__APPLE__) &amp;&amp; defined(verify)
+	// I guess sometimes &quot;verify&quot; is defined on OSX by some system headers
+	// it manifests itself with an odd error on the following line (below):
+	//   void verify(const CL_GlyphBuffer&amp; gb);
+	// there might be a better solution to this, but it seems to work out
+	#undef verify
+#endif
+
+class CL_Point;
+class CL_Rect;
+class CL_GraphicContext;
+
+//: Stores and draws glyphs in one or more fonts.
+//- !group=Display/Fonts!
+//- !header=display.h!
+//- &lt;p&gt;CL_GlyphBuffer is mostly useful for text effects, for concatenating
+//- multiple CL_Font or CL_TextStyler draw_to_gb()s, or for
+//- when you need access to the low-level glyph positioning data. You can
+//- also use it to save time by only rendering a bit of text once when you need
+//- to, for example, both draw that text and know its bounding rectangle. But
+//- for optimiziation purposes alone when dealing with unchanging text, you
+//- should instead
+//- have CL_Font or CL_TextStyler render onto a CL_Canvas or CL_Surface.&lt;/p&gt;
+//- &lt;p&gt;A glyph buffer consists of a series of characters and positions,
+//- and markers for font changes and various other text-altering infomration. The internal data structures used
+//- are made accessible and mutable externally. CL_Font
+//- and CL_TextStyler both have draw_to_gb() methods, which allows them to
+//- put data into a CL_GlyphBuffer rather than drawing to a CL_GraphicContext. &lt;/p&gt;
+//- &lt;p&gt;The effect maps for color, angle, and scale allow you to affect those properties
+//- for individual glyphs during drawing and bounding rect calculation. The angle and scale maps are different
+//- from the GlyphBuffer angle and scale properties; the properties apply to the entire CL_GlyphBuffer as a whole, while entries
+//- in the effect maps affect individual glyphs seperately. It's not legal to insert
+//- an effect map entry for a glyph that doesn't exist.&lt;/p&gt;
+//- &lt;p&gt;Unlike scale effects map entries, which are multiplied by the CL_Font's existing scale, 
+//- color effect map entries entirely override the CL_Font's color. No blending between
+//- the two colors is performed. Also, it's your responsibility to make sure that CL_Fonts have the right
+//- blending functions.&lt;/p&gt;
+//- &lt;p&gt;In functions that calculate the size or bounding rectangle of the GlyphBuffer
+//- (such as bouding_rect(), get_size(), and the alignment calculations within draw),
+//- effect properties do take effect on the final rectangle, but GlyphBuffer rotation
+//- and scaling (set with CL_GlyphBuffer::set_angle(), and CL_GlyphBuffer::set_scale(),
+//- respectively) do not. This is consistent with the behavior of CL_Sprite and CL_Surface; the content
+//- affects bounding rect calculation, but the other properties of the object
+//- do not.&lt;/p&gt;
+class CL_API_DISPLAY CL_GlyphBuffer
+{
+//! Construction:
+public:
+	//: Constructs a glyph buffer.
+	CL_GlyphBuffer();
+	
+	virtual ~CL_GlyphBuffer() {;}
+	
+//! Subclasses:
+public:
+	//: A character and position describing a glyph in the buffer, stored in the glyphs vector.
+	struct Glyph
+	{
+		//:Constructs a new Glyph
+		//p: The CL_Point that will be assigned to pos
+		//c: The unsigned int that will be assigned to character
+		Glyph() {;}
+		Glyph(CL_Point p, unsigned int c) : pos(p), character(c) {;}
+		
+		//: The position where the glyph is drawn.
+		CL_Point pos;
+		
+		//: The character which determines the glyph that's drawn.
+		unsigned int character;
+	};
+
+	//: Represents a subsection of the buffer
+	struct Range
+	{
+		//:Constructs a new Range.
+		//new_start: The starting index of the range, inclusive
+		//new_end: The ending index of the range, exclusive
+		//gb: Constructs a new Range that encompasses this entire CL_GlyphBuffer
+		Range() : start(0), end(0) {;}
+		Range(const CL_GlyphBuffer&amp; gb) : start(0), end(int(gb.get_glyphs().size())) {;}
+		Range(int new_start, int new_end) : start(new_start), end(new_end) {;}
+		
+		//: Makes range valid for a given GlyphBuffer.
+		//- &lt;p&gt; This is automatically called when you pass the range to any GlyphBuffer method.&lt;/p&gt;
+		void verify(const CL_GlyphBuffer&amp; gb);
+		
+		//: Pulls in the range at the beginning until it reaches a drawable glyph
+		void remove_invis_left(const CL_GlyphBuffer&amp; gb);
+		
+		//: Pulls in the range at the end until it reaches a drawable glyph
+		void remove_invis_right(const CL_GlyphBuffer&amp; gb);
+		
+		//: Pulls in the range at both sides until it reaches a drawable glyph
+		void remove_invis_both(const CL_GlyphBuffer&amp; gb)
+			{remove_invis_left(gb); remove_invis_right(gb);}
+		
+		//The starting index of the range, inclusive.
+		int start;
+		
+		//The ending index of the range, exclusive.
+		int end;
+	};
+	
+//! Attributes:
+public:
+	//: Returns a reference to the glyphs in the buffer and their drawing positions.
+	//- &lt;p&gt;See CL_GlyphBuffer::Glyph for details./p&gt;
+	std::vector&lt;Glyph&gt;&amp; get_glyphs() {return glyphs;}
+	const std::vector&lt;Glyph&gt;&amp; get_glyphs() const {return glyphs;}
+	
+	//: Returns a reference to the font map.
+	//- &lt;p&gt;Elements of the glyphs vector before the first font marker are ignored. Each element
+	//- within this map causes a change in the font while drawing, where the key of the
+	//- element is the index in the glyphs vector before which the font is changed.&lt;/p&gt;
+	std::map&lt;int, CL_Font&gt;&amp; get_font_markers() {return font_markers;}
+	const std::map&lt;int, CL_Font&gt;&amp; get_font_markers() const {return font_markers;}
+	
+	//: Returns a reference to the color effect map.
+	std::map&lt;int, CL_Color&gt;&amp; get_color_effects() {return color_effects;}
+	const std::map&lt;int, CL_Color&gt;&amp; get_color_effects() const {return color_effects;}
+	
+	//: Returns a reference to the x scale effect map.
+	//- &lt;p&gt; Scaling occurs away from the upper-left corner of each glyph. &lt;/p&gt;
+	std::map&lt;int, float&gt;&amp; get_scale_x_effects() {return scale_x_effects;}
+	const std::map&lt;int, float&gt;&amp; get_scale_x_effects() const {return scale_x_effects;}
+	
+	//: Returns a reference to the y scale effect map.
+	//- &lt;p&gt; Scaling occurs away from the upper-left corner of each glyph. &lt;/p&gt;
+	std::map&lt;int, float&gt;&amp; get_scale_y_effects() {return scale_y_effects;}
+	const std::map&lt;int, float&gt;&amp; get_scale_y_effects() const {return scale_y_effects;}
+	
+	//: Returns a reference to the character angle effect map.
+	std::map&lt;int, float&gt;&amp; get_angle_effects() {return angle_effects;}
+	const std::map&lt;int, float&gt;&amp; get_angle_effects() const {return angle_effects;}
+	
+	//: Returns an iterator to the font_marker associated with a particular glyph.
+	//- &lt;p&gt; If a negative index is supplied, assumes glyph 0. If an index
+	//- past the last element is supplied, assumes the last element. If
+	//- there are no CL_Fonts in the GlyphBuffer, or if there is no CL_Font
+	//- associated with that glyph, returns the end iterator.&lt;/p&gt;
+	std::map&lt;int, CL_Font&gt;::iterator get_font_for(int glyph_index);
+	std::map&lt;int, CL_Font&gt;::const_iterator get_font_for(int glyph_index) const;
+	
+	//: Returns the width of the entire buffer, or a sub-Range.
+	//return: The width in pixels.
+	//param range: A subsection of the glyphs vector to get the width of.
+	//param idx: The vector index of a single glyph to get the width of.
+	//param ignore_invis: If true, ignores invisible glyphs (glyphs without an actual visual glyph in the font)
+	int get_width(bool ignore_invis = true) const
+		{return get_width(Range(*this), ignore_invis);}
+	int get_width(int idx, bool ignore_invis = true) const
+		{return get_width(Range(idx, idx+1), ignore_invis);}
+	int get_width(Range range, bool ignore_invis = true) const
+		{return get_size(range, ignore_invis).width;}
+	
+	//: Returns the height of the entire buffer, or a sub-Range.
+	//return: The height in pixels.
+	//param range: A subsection of the glyphs vector to get the height of.
+	//param idx: The vector index of a single glyph to get the height of.
+	//param ignore_invis: If true, ignores invisible glyphs (glyphs without an actual visual glyph in the font)
+	int get_height(bool ignore_invis = true) const
+		{return get_height(Range(*this), ignore_invis);}
+	
+	int get_height(int idx, bool ignore_invis = true) const
+		{return get_height(Range(idx, idx+1), ignore_invis);}
+	
+	int get_height(Range range, bool ignore_invis = true) const
+		{return get_size(range, ignore_invis).height;}
+	
+	//: Returns the size of the entire buffer, or a sub-Range.
+	//return: The size in pixels.
+	//param range: A subsection of the glyphs vector to get the size of.
+	//param idx: The vector index of a single glyph to get the size of.
+	//param ignore_invis: If true, ignores invisible glyphs (glyphs without an actual visual glyph in the font)
+	CL_Size get_size(bool ignore_invis = true) const
+		{return get_size(Range(*this), ignore_invis);}
+	
+	CL_Size get_size(int idx, bool ignore_invis = true) const
+		{return get_size(Range(idx, idx+1), ignore_invis);}
+	
+	CL_Size get_size(Range range, bool ignore_invis = true) const
+		{return internal_rect(range, ignore_invis).get_size();}
+	
+	//: Returns current angle.
+	//- &lt;p&gt; This rotates the entire glyph field when drawing.
+	//- The fonts' glyph rotation origin must be origin_top_left:0:0 for this
+	//- to produce legible results. See CL_Font::set_glyph_rotation_hotspot(). &lt;/p&gt;
+	float get_angle() const
+		{return rot_angle;}
+	
+	//: Returns scale for x and y.
+	//- &lt;p&gt; 1.0f is normal scale, 2.0f is twice the size, etc. &lt;/p&gt;
+	void get_scale(float &amp;x, float &amp;y) const
+		{x = scale_x; y = scale_y;}
+	
+	//: Returns translation hotspot for the entire glyph field.
+	void get_alignment(CL_Origin &amp;origin, int &amp;x, int &amp;y) const
+		{origin = trans_origin; x = trans_x; y = trans_y;}
+	
+	//: Returns rotation hotspot for the entire glyph field.
+	void get_rotation_hotspot(CL_Origin &amp;origin, int &amp;x, int &amp;y) const
+		{origin = rot_origin; x = rot_x; y = rot_y;}
+	
+	//: Returns the area that would be drawn to if a draw were performed.
+	//return: The area into which any pixels would be drawn. If buffer is empty, returns a rectangle with zero size.
+	//param x, y: Anchor position to start &quot;drawing&quot; at. Actual rendering position depends on the alignment mode.
+	//param dest: Rectangle to render glyphs in. The glyphs will be positioned within the rectangle depending on the alignment mode.
+	//param range: The subsection of the glyphs vector to use.
+	//param ignore_invis: If true, ignores invisible glyphs (glyphs without an actual visual glyph in the font)
+	CL_Rect bounding_rect(int x = 0, int y = 0, bool ignore_invis = true) const
+		{return bounding_rect(Range(*this), x, y, ignore_invis);}
+	
+	CL_Rect bounding_rect(Range range, int x = 0, int y = 0, bool ignore_invis = true) const
+		{return bounding_rect(range, CL_Rect(x, y, x, y), ignore_invis);}
+	
+	CL_Rect bounding_rect(CL_Rect dest, bool ignore_invis = true) const
+		{return bounding_rect(Range(*this), dest, ignore_invis);}
+	
+	CL_Rect bounding_rect(Range range, CL_Rect dest, bool ignore_invis = true) const;
+	
+	//: Returns the area occupied by glyphs inside the glyph buffer's coordinate space.
+	//return: The area occupied by all glyphs, inside the buffer. If buffer is empty, returns a rectangle with zero size.
+	//param range: The subsection of the glyphs vector to get the internal bounding rect of.
+	//param idx: The vector index of a single glyph to get the internal bounding rect of.
+	//param ignore_invis: If true, ignores invisible glyphs (glyphs without an actual visual glyph in the font)
+	CL_Rect internal_rect(bool ignore_invis = true) const
+		{return internal_rect(Range(*this), ignore_invis);}
+	CL_Rect internal_rect(int idx, bool ignore_invis = true) const
+		{return internal_rect(Range(idx, idx+1), ignore_invis);}
+	CL_Rect internal_rect(Range range, bool ignore_invis = true) const;
+	
+	//: Returns a vector of CL_GlyphBuffer::Range, each of which contains one line.
+	//param range: The subsection of the glyphs vector to look through, which is expanded both ways.
+	//- &lt;p&gt; The CL_GlyphBuffer's contents (the glyphs vector, the font markers map, and the effects maps),
+	//- if any, must not have been created/altered by anything but CL_Font::draw_to_gb() or CL_TextStyler::draw_to_gb()
+	//- or the CL_GlyphBuffer justification functions or using CL_GlyphBuffer::remove to take glyphs off the end
+	//- for this method to work.&lt;/p&gt;
+	std::vector&lt;Range&gt; get_lines() const
+		{return get_lines(Range(*this));}
+		
+	std::vector&lt;Range&gt; get_lines(Range range) const;
+	
+	//: Returns a single CL_GlyphBuffer::Range containing the line that contains a given glyph.
+	//param idx: The index in the glpyhs vector of the glyph.
+	//- &lt;p&gt; The CL_GlyphBuffer's contents (the glyphs vector, the font markers map, and the effects maps),
+	//- if any, must not have been created/altered by anything but CL_Font::draw_to_gb() or CL_TextStyler::draw_to_gb()
+	//- or the CL_GlyphBuffer justification functions or using CL_GlyphBuffer::remove to take glyphs off the end
+	//- for this method to work.&lt;/p&gt;
+	CL_GlyphBuffer::Range get_line(int idx) const;
+
+//! Operations
+public:
+	//: Add elements onto the end of the glyphs vector.
+	//return: A reference to this object, allowing you to chain multiple calls of add() together.
+	//param x, y: The position to add the characters at (always upper-left positioning inside the buffer).
+	//param center_x, center_y: Where to realign the origin of the input GlyphBuffer to in this GlyphBuffer.
+	//param character: A single character to add without preprocessing.
+	//param other: Another CL_GlyphBuffer to copy all glyphs and data from to the specified position.
+	//param range: The subsection of the other GlyphBuffer to add onto the end of this one
+	//- &lt;p&gt; It's usually more useful and efficient to have ClanLib draw many glyphs into the GlyphBuffer at once using
+	//- CL_Font::draw_to_gb() or CL_TextStyler::draw_to_gb() than to use this function or the glyphs vector
+	//- to manually add glyphs.&lt;/p&gt;
+	CL_GlyphBuffer &amp;add(int x, int y, unsigned int character)
+		{glyphs.push_back(Glyph(CL_Point(x,y), character)); return *this;}
+	
+	CL_GlyphBuffer &amp;add(const CL_GlyphBuffer &amp;other, int center_x = 0, int center_y = 0)
+		{return add(other, Range(other), center_x, center_y);}
+	
+	CL_GlyphBuffer &amp;add(const CL_GlyphBuffer &amp;other, Range range, int center_x = 0, int center_y = 0);
+	
+	//: Removes an element or elements from the glyphs vector, reorganizes the font and effect maps to compensate.
+	//return: A reference to this object, allowing you to chain multiple calls of remove() together.
+	//param index: The index in the glyphs vector to remove (all elements beyond this are slid back)
+	//param range: The subsection of the glyphs vector to erase
+	CL_GlyphBuffer &amp;remove(int index)
+		{return remove(Range(index, index+1));}
+	
+	CL_GlyphBuffer &amp;remove(Range range);
+	
+	//: Adds a font change marker, set to occur before the next glyph/location you add is drawn.
+	//return: A reference to this object, allowing you to chain change_font() into chains of calls to add().
+	//param font: The font to change to.
+	CL_GlyphBuffer &amp;change_font(const CL_Font &amp;font);
+	
+	//: Remove all the character position and font marker data in the buffer.
+	void clear();
+	
+	//: Draw the glyphs in the buffer.
+	//param x, y: Anchor position to draw at. Actual drawing position depends on the alignment mode.
+	//param gc: Graphic context on which to render. If null, will use CL_Display's current graphic context.
+	//param dest: Rectangle to draw glyphs in. The glyphs will be positioned within the rectangle depending on the alignment mode.
+	//param range: The subsection of the glyphs vector to use.
+	void draw(
+		int x = 0,
+		int y = 0,
+		CL_GraphicContext *gc = 0)
+		{draw(Range(*this), CL_Rect(x, y, x, y), gc);}
+	
+	void draw(
+		Range range,
+		int x = 0,
+		int y = 0,
+		CL_GraphicContext *gc = 0)
+		{draw(range, CL_Rect(x, y, x, y), gc);}
+	
+	void draw(
+		CL_Rect dest,
+		CL_GraphicContext *gc = 0)
+		{draw(Range(*this), dest, gc);}
+	
+	void draw(
+		Range range,
+		CL_Rect dest,
+		CL_GraphicContext *gc = 0)
+		{CL_Rect irect = internal_rect(range); draw_glyphs(range, i2e_offset(irect, dest), irect, gc);}
+	
+	//: Draws the glyphs in the buffer without bounding rect alignment.
+	//param x, y: Glyphs are drawn with the CL_GlyphBuffer's internal origin at this location.
+	//param gc: Graphic context on which to render. If null, will use CL_Display's current graphic context.
+	//param range: The subsection of the glyphs vector to use.
+	void fixed_draw(
+		int x = 0,
+		int y = 0,
+		CL_GraphicContext *gc = 0)
+		{fixed_draw(Range(*this), x, y, gc);}
+	
+	void fixed_draw(
+		Range range,
+		int x = 0,
+		int y = 0,
+		CL_GraphicContext *gc = 0)
+		{draw_glyphs(range, CL_Point(x, y), CL_Rect(0,0,0,0), gc);}
+	
+	//: Rejustifies lines in the GlyphBuffer to the left.
+	//param range: The subsection of the glyphs vector to change, which is expanded out both ways to contain at least one line.
+	//param left: The x coordinate of the vertical line that text should be moved up against.
+	//- &lt;p&gt; The CL_GlyphBuffer's contents (the glyphs vector, the font markers map, and the effects maps),
+	//- if any, must not have been created/altered by anything but CL_Font::draw_to_gb() or CL_TextStyler::draw_to_gb()
+	//- or the CL_GlyphBuffer justification functions or using CL_GlyphBuffer::remove to take glyphs off the end
+	//- for this method to work.&lt;/p&gt;
+	//- &lt;p&gt; To preserve indentation, this method takes into account whitespace (glyphs not provided by the font) when justifying.&lt;/p&gt;
+	void justify_left(int left = 0)
+		{justify_left(Range(*this), left);}
+	
+	void justify_left(Range range, int left = 0);
+	
+	//: Rejustifies lines in the GlyphBuffer to the center.
+	//param range: The subsection of the glyphs vector to change, which is expanded out both ways to contain at least one line.
+	//param center: The x coordinate of the vertical line that text should be centered at.
+	//- &lt;p&gt; The CL_GlyphBuffer's contents (the glyphs vector, the font markers map, and the effects maps),
+	//- if any, must not have been created/altered by anything but CL_Font::draw_to_gb() or CL_TextStyler::draw_to_gb()
+	//- or the CL_GlyphBuffer justification functions or using CL_GlyphBuffer::remove to take glyphs off the end
+	//- for this method to work.&lt;/p&gt;
+	//- &lt;p&gt; This method ignores whitespace (glyphs not provided by the font) when justifying. &lt;/p&gt;
+	void justify_center(int center = 0)
+		{justify_center(Range(*this), center);}
+	
+	void justify_center(Range range, int center = 0);
+	
+	//: Rejustifies lines in the GlyphBuffer to the right.
+	//param range: The subsection of the glyphs vector to change, which is expanded out both ways to contain at least one line.
+	//param right: The x coordinate of the vertical line that text should be moved up against.
+	//- &lt;p&gt; The CL_GlyphBuffer's contents (the glyphs vector, the font markers map, and the effects maps),
+	//- if any, must not have been created/altered by anything but CL_Font::draw_to_gb() or CL_TextStyler::draw_to_gb()
+	//- or the CL_GlyphBuffer justification functions or using CL_GlyphBuffer::remove to take glyphs off the end
+	//- for this method to work.&lt;/p&gt;
+	//- &lt;p&gt; This method ignores whitespace (glyphs not provided by the font) when justifying. &lt;/p&gt;
+	void justify_right(int right = 0)
+		{justify_right(Range(*this), right);}
+	
+	void justify_right(Range range, int right = 0);
+	
+	//: Set absolute rotation angle.
+	//- &lt;p&gt; This rotates the entire glyph field when drawing.
+	//- The fonts' glyph rotation origin must be origin_top_left:0:0 for this
+	//- to produce legible results. See CL_Font::set_glyph_rotation_hotspot(). &lt;/p&gt;
+	void set_angle(float angle);
+	
+	//: Add angle to current angle.
+	//- &lt;p&gt; This rotates the entire glyph field when drawing.
+	//- The fonts' glyph rotation origin must be origin_top_left:0:0 for this
+	//- to produce legible results. See CL_Font::set_glyph_rotation_hotspot(). &lt;/p&gt;
+	void rotate(float angle)
+		{angle += rot_angle; set_angle(angle);}
+	
+	//: Set scale for x and y directions individually.
+	//- &lt;p&gt; 1.0f is normal scale, 2.0f is twice the size, etc. &lt;/p&gt;
+	void set_scale(float x, float y)
+		{scale_x = x; scale_y = y;}
+	
+	//: Sets translation hotspot.
+	void set_alignment(CL_Origin origin, int x = 0, int y = 0)
+		{trans_origin = origin; trans_x = x; trans_y = y;}
+	
+	//: Sets rotation hotspot.
+	void set_rotation_hotspot(CL_Origin origin, int x = 0, int y = 0)
+		{rot_origin = origin; rot_x = x; rot_y = y;}
+	
+//! Implementation:
+private:
+	//: Used to iterate through the buffer, changing font and applying effects as needed
+	class Iter;
+	friend class Iter;
+	class Iter {
+		private:
+			//Pointer to the GlyphBuffer
+			const CL_GlyphBuffer* pgb;
+			
+			//The current index in the glyphs vector
+			int glyph_num;
+			
+			//Do not allow default construction
+			Iter() {}
+			
+		public:
+			//Constructs a new Iter
+			//param range: The beginning index in this Range is used as the initial glyph_num
+			Iter(const CL_GlyphBuffer&amp; new_gb, Range range)
+				: pgb(&amp;new_gb), glyph_num(range.start) {}
+			
+			//Advances to the next glyph (prefix)
+			Iter&amp; operator ++() {++glyph_num; return *this;}
+
+			//Advances to the next glyph (postfix)
+			const Iter operator ++(int) {Iter old = *this; ++(*this); return old;}
+			
+			//Returns true if the iterator has covered everything (i.e. is past-the-end)
+			//param range: The ending index in this Range is checked against
+			bool at_end(Range range) const {if (glyph_num &gt;= range.end) return true; return false;}
+			
+			//Returns the index in the glyphs vector
+			int get_glyph_num() const {return glyph_num;}
+			
+			//Returns the scale effect, or 1.0 if no scale effect for this glyph
+			void get_scale_eff(float&amp; x, float&amp; y) const;
+			
+			//Returns the angle effect, or 0.0 if no angle effect for this glyph
+			float get_angle_eff() const;
+			
+			//Returns the color effect, or given font's color if no color effect for this glyph
+			CL_Color get_color_eff(const CL_Font&amp; fnt) const;
+			
+			//Returns a non-mutable reference to the current font
+			const CL_Font&amp; get_font() const;
+	};
+
+	//: Returns true if the given glyph index is directly before a linebreak, manual or logical
+	//param fnt: The font that idx is in
+	bool is_linebreak(int idx, const CL_Font&amp; fnt) const;
+	
+	//: Erases all elements of a map&lt;int, T&gt; in [start, end), then slides back elements
+	template &lt;typename T&gt;
+	static void cut_range(std::map&lt;int, T&gt;&amp; target, int start, int end)
+	{
+		//Remove all the elements inside the range
+		target.erase(target.lower_bound(start), target.upper_bound(end));
+		
+		//Move back all the elements from the end of the range to the end of the map
+		for (typename std::map&lt;int, T&gt;::iterator it = target.lower_bound(end); it != target.end();)
+		{
+			target[it-&gt;first - (end - start)] = it-&gt;second;
+			target.erase(it++);
+		}
+	}
+	
+	//: Returns the offset to align an internal bounding rectangle to an external bounding rectangle.
+	CL_Point i2e_offset(CL_Rect src, CL_Rect dest) const;
+	
+	//: Returns the point to scale away from.
+	//param irect: Internal rectangle containing all glyphs
+	CL_Point get_scale_hotspot(CL_Rect irect) const;
+	
+	//: Returns the point to rotate around.
+	//param irect: Internal rectangle containing all glyphs
+	CL_Point get_rot_hotspot(CL_Rect irect) const;
+	
+	//: Draws all the glyphs in the buffer.
+	//param offset: Added to each position right before drawing, to move to external coords
+	//param irect: Result of internal_rect() passed in if caller has it, for efficiency's sake, else CL_Rect(0,0,0,0)
+	//param gc: The graphics context to draw to (default if 0)
+	//param range: The subsection of the glyphs vector to use
+	void draw_glyphs(
+		Range range,
+		CL_Point offset,
+		CL_Rect irect,
+		CL_GraphicContext* gc) const;
+	
+	//: Scale.
+	float scale_x;
+	float scale_y;
+	
+	//: Angle and rotation hotspot.
+	float rot_angle;
+	CL_Origin rot_origin;
+	int rot_x;
+	int rot_y;
+	
+	//: Alignment.
+	CL_Origin trans_origin;
+	int trans_x;
+	int trans_y;
+	
+	//: The glyphs and their positions.
+	std::vector&lt;Glyph&gt; glyphs;
+	
+	//: The font change markers.
+	mutable std::map&lt;int, CL_Font&gt; font_markers;
+	
+	//: Color, scale, and angle font effect maps.
+	std::map&lt;int, CL_Color&gt; color_effects;
+	std::map&lt;int, float&gt; scale_x_effects;
+	std::map&lt;int, float&gt; scale_y_effects;
+	std::map&lt;int, float&gt; angle_effects;
+};
+
+#endif

Added: trunk/clanlib/API/Display/gradient.h
===================================================================
--- trunk/clanlib/API/Display/gradient.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/gradient.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,67 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Display 2D&quot;
+//! header=display.h
+
+#ifndef header_gradient
+#define header_gradient
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;color.h&quot;
+
+//: Colorgradient description class.
+//- !group=Display/Display 2D!
+//- !header=display.h!
+class CL_Gradient
+{
+//! Construction:
+public:
+	//: Constructs a color gradient.
+	//param top_left: Top left color component.
+	//param top_right: Top right color component.
+	//param bottom_left: Bottom left color component.
+	//param bottom_right: Bottom right color component.
+	CL_Gradient() { return; }
+
+	CL_Gradient(const CL_Color &amp;top_left, const CL_Color &amp;top_right, const CL_Color &amp;bottom_left, const CL_Color &amp;bottom_right)
+		: top_left(top_left), top_right(top_right), bottom_left(bottom_left), bottom_right(bottom_right) { return; }
+
+//! Attributes:
+public:
+	CL_Color top_left;
+	CL_Color top_right;
+	CL_Color bottom_left;
+	CL_Color bottom_right;
+};
+
+#endif

Added: trunk/clanlib/API/Display/graphic_context.h
===================================================================
--- trunk/clanlib/API/Display/graphic_context.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/graphic_context.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,335 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Display 2D&quot;
+//! header=display.h
+
+#ifndef header_graphic_context
+#define header_graphic_context
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4786)
+#endif
+
+#include &quot;../signals.h&quot;
+#include &lt;stack&gt;
+#include &quot;color.h&quot;
+#include &quot;gradient.h&quot;
+#include &quot;stencil_func.h&quot;
+#include &quot;pixel_buffer.h&quot;
+#include &quot;../Core/Math/point.h&quot;
+#include &quot;../Core/Math/rect.h&quot;
+#include &quot;../Core/Math/quad.h&quot;
+#include &quot;../Core/Math/matrix4x4.h&quot;
+
+class CL_GraphicContext_Generic;
+class CL_Surface;
+
+//: Graphic rendering target.
+//- !group=Display/Display 2D!
+//- !header=display.h!
+//- &lt;p&gt;A graphic context is something that ClanLib can render onto.&lt;/p&gt;
+class CL_API_DISPLAY CL_GraphicContext
+{
+//! Construction:
+public:
+	//: Constructs a graphic context.
+	CL_GraphicContext();
+
+	CL_GraphicContext(const CL_GraphicContext &amp;copy);
+
+	virtual ~CL_GraphicContext();
+
+//! Attributes:
+public:
+	//: Returns the current width of the context.
+	int get_width() const;
+
+	//: Returns the current height of the context.
+	int get_height() const;
+
+	//: Returns the current clipping rectangle used on the graphic context.
+	const CL_Rect &amp;get_cliprect() const;
+
+	//: Returns the current effective modelview matrix.
+	const CL_Matrix4x4 &amp;get_modelview() const;
+
+	//: Returns a pixel value at specified coordinates.
+	CL_Color get_pixel(int x, int y) const;
+
+	//: Return the content of buffer 'i' copyied into a CL_PixelBuffer
+	CL_PixelBuffer get_pixeldata(const CL_Rect&amp; rect = CL_Rect(0,0,0,0), int i = 0) const;
+
+	//: Returns the maximum size of a surface this graphic context supports.
+	//- &lt;p&gt;It returns CL_Size(0,0) if there is no limitation to the max
+	//- surface size. Of course it is still limited by available memory,
+	//- which is not considered by this function.&lt;/p&gt;
+	CL_Size get_max_surface_size() const;
+
+//! Operations:
+public:
+	//: Copy assignment operator.
+	CL_GraphicContext &amp;operator =(const CL_GraphicContext &amp;copy);
+
+	//: Flushes current rendering batch. &lt;i&gt;Deprecated&lt;/i&gt;
+	//- &lt;p&gt;With the OpenGL target, this causes the graphic context to end its current
+	//- active glBegin()/glEnd() pair, making it possible to call other OpenGL calls.&lt;/p&gt;
+	//- &lt;p&gt;&lt;i&gt;This function is deprecated&lt;/i&gt;&lt;/p&gt;.
+	void flush();
+
+	//: Draw a pixel at (x, y) using the specified color.
+	void draw_pixel(int x, int y, const CL_Color &amp;color);
+
+	//: Draw a line from (x1, y1) to (x2, y2) using the specified color.
+	void draw_line(float x1, float y1, float x2, float y2, const CL_Color &amp;color);
+
+	//: Draw a continuous chain of lines in the specified color.
+	void draw_lines(int count, double *vertices, const CL_Color &amp;color);
+
+	//: Draw a rectangle using the specified color.
+	void draw_rect(const CL_Rectf &amp;rect, const CL_Color &amp;color);
+
+	//: Draw a gradient rectangle using the specified gradient.
+	void fill_rect(const CL_Rectf &amp;rect, const CL_Gradient &amp;gradient);
+
+	//: Draw a filled rectangle using the specified color.
+	void fill_rect(const CL_Rectf &amp;rect, const CL_Color &amp;color);
+	
+	//: Draw a quad using the specified color.
+	void draw_quad(const CL_Quad &amp;quad, const CL_Color &amp;color);
+
+	//: Draw a gradient quad using the specified gradient.
+	void fill_quad(const CL_Quad &amp;quad, const CL_Gradient &amp;gradient);
+
+	//: Draw a filled quad using the specified color.
+	void fill_quad(const CL_Quad &amp;quad, const CL_Color &amp;color);
+
+	//: Draw a triangle using the specified color.
+	//param double x : x coordinates of triangle vertices
+	//param double y : y coordinates of triangle vertices
+	//param CL_Color &amp;Color : color to use
+	void draw_triangle(
+		double x1, double y1,
+		double x2, double y2,
+		double x3, double y3,
+		const CL_Color &amp;color);
+
+	//: Draw a gradient filled triangle.
+	//param double x : x coordinates of triangle vertices
+	//param double y : y coordinates of triangle vertices
+	//param CL_Gradient &amp;gradient : color gradient to use
+	void fill_triangle(
+		double x1, double y1,
+		double x2, double y2,
+		double x3, double y3,
+		const CL_Gradient &amp;gradient);
+
+	//: Draw triangles with color array (optionally textured).
+	//- &lt;p&gt;uchar color array, range: 0-255
+	//- integer (pixel) texture coordinates&lt;/p&gt;
+	//param unsigned int count : number of triangles to draw
+	//param bool fill : draw filled/outline
+	//param double *vertices : pointer to array of triangle vertices (x y z x y z x...)
+	//param unsigned char *color : pointer to array of triangle vertice colors (r b g a r g b a r...)
+	//param int *uv : (optional) pointer to array of triangle vertice texture coordinates (u v u v u...)
+	//param CL_Surface *texture : (optional) texture to use
+	void draw_triangles(
+		unsigned int count,
+		bool fill,
+		double *vertices,
+		unsigned char *color,
+		int *uv=0,
+		CL_Surface *texture=0);
+
+	//: Draw triangles with single color (optionally textured).
+	//- &lt;p&gt;single color
+	//- integer (pixel) texture coordinates&lt;/p&gt;
+	//param unsigned int count : number of triangles to draw
+	//param bool fill : draw filled/outline
+	//param double *vertices : pointer to array of triangle vertices (x y z x y z x...)
+	//param CL_Color &amp;color : triangle color
+	//param int *uv : (optional) pointer to array of triangle vertice texture coordinates (u v u v u...)
+	//param CL_Surface *texture : (optional) texture to use
+	void draw_triangles(
+		unsigned int count,
+		bool fill,
+		double *vertices,
+		const CL_Color &amp;color,
+		int *uv=0,
+		CL_Surface *texture=0);
+
+	//: Draw triangle array with color array (optionally textured).
+	//- &lt;p&gt; double color array, range: 0-1
+	//- double (0-1) texture coordinates&lt;/p&gt;
+	//param unsigned int count : number of triangles to draw
+	//param bool fill : draw filled/outline
+	//param double *vertices : pointer to array of triangle vertices (x y z x y z x...)
+	//param double *color : pointer to array of triangle vertice colors (r b g a r g b a r...)
+	//param int *uv : (optional) pointer to array of triangle vertice texture coordinates (u v u v u...)
+	//param CL_Surface *texture : (optional) texture to use
+	void draw_trianglesd(
+		unsigned int count,
+		bool fill,
+		double *vertices,
+		const CL_Color &amp;color,
+		double *uv=0,
+		CL_Surface *texture=0);
+
+	//: Draw triangles with single color (optionally textured).
+	//- &lt;p&gt;single color
+	//- double (0-1) texture coordinates&lt;/p&gt;
+	//param unsigned int count : number of triangles to draw
+	//param bool fill : draw filled/outline
+	//param double *vertices : pointer to array of triangle vertices (x y z x y z x...)
+	//param CL_Color &amp;color : triangle color
+	//param double *uv : (optional) pointer to array of triangle vertice texture coordinates (u v u v u...)
+	//param CL_Surface *texture : (optional) texture to use
+	void draw_trianglesd(
+		unsigned int count,
+		bool fill,
+		double *vertices,
+		double *color,
+		double *uv=0,
+		CL_Surface *texture=0);
+
+	//: Clears the whole context using the specified color.
+	void clear(const CL_Color &amp;color = CL_Color(0,0,0));
+
+	//: Set the current clipping rectangle.
+	void set_cliprect(const CL_Rect &amp;rect);
+
+	//: Push current clipping rectangle to stack.
+	//- &lt;p&gt;If a rectangle is passed, it afterwards sets clipping
+	//- rectangle to the union of the current rectangle and the passed
+	//- rectangle.&lt;/p&gt;
+	void push_cliprect(const CL_Rect &amp;rect);
+
+	void push_cliprect();
+
+	//: Pop current clipping rectangle from the stack.
+	void pop_cliprect();
+
+	//: Sets the model view matrix to a new matrix.
+	void set_modelview(const CL_Matrix4x4 &amp;matrix);
+
+	//: Multiplies the passed matrix onto the model view matrix.
+	void add_modelview(const CL_Matrix4x4 &amp;matrix);
+
+	//: Pushes current model view matrix onto the model view stack.
+	void push_modelview();
+
+	//: Sets a translate offset matrix, ignoring any earlier model view settings.
+	//- &lt;p&gt; This offset will affect any subsequent display operations on the current
+	//- displaycard, by translating the position of the display operation with the offset.&lt;/p&gt;
+	void set_translate(double x, double y, double z = 0.0);
+
+	//: Adds the translate offset.
+	//- &lt;p&gt; This offset will affect any subsequent display operations on the current
+	//- displaycard, by translating the position of the display operation with the offset.
+	//- The offset will be offset by any previous offsets pushed onto the stack,
+	//- eg. it inherits the previous offset. &lt;/p&gt;
+	void add_translate(double x, double y, double z = 0.0);
+	
+	//: Push translation offset onto model view stack.
+	//- &lt;p&gt;This function is a convenience function for calling push_modelview, then add_translate.&lt;/p&gt;
+	//- &lt;p&gt; This offset will affect any subsequent display operations on the current
+	//- displaycard, by translating the position of the display operation with the offset.
+	//- The offset will be offset by any previous offsets pushed onto the stack,
+	//- eg. it inherits the previous offset. &lt;/p&gt;
+	void push_translate(double x, double y, double z = 0.0);
+
+	//: Sets a rotation matrix, ignoring any earlier model view settings.
+	void set_rotate(double angle, double x = 0.0, double y = 0.0, double z = 1.0);
+
+	//: Adds a rotation matrix to existing model view.
+	void add_rotate(double angle, double x = 0.0, double y = 0.0, double z = 1.0);
+
+	//: Pushes a rotation matrix onto model view stack.
+	void push_rotate(double angle, double x = 0.0, double y = 0.0, double z = 1.0);
+
+	//: Sets a scale matrix, ignoring any earlier model view settings.
+	void set_scale(double x, double y, double z = 1.0);
+
+	//: Adds a scale matrix to existing model view.
+	void add_scale(double x, double y, double z = 1.0);
+
+	//: Pushes a scale matrix onto model view stack.
+	void push_scale(double x, double y, double z = 1.0);
+
+	//: Pops last pushed model view matrix off the stack and makes it the active one.
+	void pop_modelview();
+
+	//: Clear the stencil buffer
+	//param int value : value to clear to. Default: 0
+	void clear_stencil(int value=0);
+
+	//: Set stencil test function when writing to stencil, and operations to do when a test passes or fails
+	//param CL_StencilOp pass : Modification to stencil buffer when a test passes.
+	//param CL_StencilOp fail : Modification to stencil buffer when a test fails.
+	//param CL_StencilFunc func : Type of test to do when writing to stencil.
+	//param int ref : value compared to stencil contents. Default: 1
+	void set_stencil_operation(CL_StencilOp pass, CL_StencilOp fail, CL_StencilFunc func, int ref=1);
+
+	//: Enables writing to the stencil buffer 
+	//param bool enabled : Enables/disables stencil testing.
+	//param bool visible : Enables/disables color buffer writing if stencil writing is enabled. Default: true.
+	//param float alpha_limit : Only pixels with alpha &gt;= alpha limit are drawn to the stencil buffer. Default: 0.1f
+	void enable_stencil_write(bool enabled, bool visible=true, float alpha_limit=0.1f);
+
+	//: Enables stencil buffer testing
+	//- &lt;p&gt; Individual pixels are tested against the values in the stencil buffer, and
+	//- drawn depending on the comparison result. This can be used for masking and
+	//- boolean operations on bitmaps &lt;/p&gt;
+	//param bool enabled : Enables/disables stencil testing.
+	//param int func : Type of comparison. Default: lequal (pass if ref &lt;= stencil)
+	//param int ref : Reference value that the stencil is compared with. Default: 1
+	void enable_stencil_test(bool enabled, CL_StencilFunc func=stencil_lequal, int ref=1);
+
+//! Implementation:
+public:
+	CL_GraphicContext(CL_GraphicContext_Generic *impl);
+	
+	CL_GraphicContext_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Display/input_buffer.h
===================================================================
--- trunk/clanlib/API/Display/input_buffer.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/input_buffer.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,120 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Input&quot;
+//! header=display.h
+
+#ifndef header_inputbuffer
+#define header_inputbuffer
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4786)
+#endif
+
+#include &lt;queue&gt;
+#include &quot;input_event.h&quot;
+#include &quot;../signals.h&quot;
+
+class CL_Component;
+class CL_InputDevice;
+class CL_InputContext;
+class CL_InputBuffer_Generic;
+
+//: Input buffer interface.
+//- !group=Display/Input!
+//- !header=display.h!
+//- &lt;p&gt; Use this class to read buffered keys from the keyboard or any other device. &lt;/p&gt;
+class CL_API_DISPLAY CL_InputBuffer
+{
+//! Construction:
+public:
+	//: Constructs an input buffer.
+	//param ic: Input context that input buffer should connect to get keys.
+	//param sig_key_down: Signal input buffer should connect to get key presses.
+	//param sig_key_up: Signal input buffer should connect to get key released.
+	//param device: Input device that input buffer should connect to get keys.
+	//- &lt;p&gt;Detailed description that explains what this damn constructors really do.&lt;/p&gt;
+	CL_InputBuffer();
+
+	CL_InputBuffer(CL_InputDevice &amp;device);
+
+	CL_InputBuffer(CL_InputContext *ic);
+
+	CL_InputBuffer(const CL_InputBuffer &amp;copy);
+
+	//: Input Buffer destructor.
+	virtual ~CL_InputBuffer();
+
+//! Attributes:
+public:
+	//: Returns number of keys still available in the buffer.
+	//return: Number of key values left in buffer.
+	int keys_left() const;
+
+	//: Returns the next key in the buffer, but unlike pop_key() it does not
+	//: pop it from the input buffer.
+	CL_InputEvent peek_key() const;
+
+//! Operations:
+public:
+	//: Copy assignment operator.
+	CL_InputBuffer &amp;operator =(const CL_InputBuffer &amp;copy);
+
+	//: Adds a device that input buffer should connect to get keys.
+	void add_device(CL_InputDevice &amp;device);
+
+	//: Adds all devices from a inputcontext that input buffer should connect to get keys.
+	void add_devices(CL_InputContext *ic);
+	
+	//: Pops the next key in the buffer and returns it.
+	CL_InputEvent pop_key();
+
+	//: Clears the buffer.
+	void clear();
+	
+//! Implementation:
+private:
+	CL_InputBuffer_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Display/input_button.h
===================================================================
--- trunk/clanlib/API/Display/input_button.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/input_button.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,119 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Input&quot;
+//! header=display.h
+
+#ifndef header_inputbutton
+#define header_inputbutton
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;input_event.h&quot;
+#include &quot;key_binding.h&quot;
+
+class CL_InputButton_Generic;
+
+//: Input Button interface.
+//- !group=Display/Input!
+//- !header=display.h!
+//- Use this class to bind inputevents to this class. You can then check if any input events has
+//- be activated (like a mouse-press, a certain keypress etc).
+//- Useful for things like mapping SPACE and LEFT MOUSE to a Fire Action.
+class CL_API_DISPLAY CL_InputButton
+{
+//! Construction:
+public:
+	//: Constructor.
+	CL_InputButton();
+
+	//: Copy constructor.
+	CL_InputButton(const CL_InputButton &amp;copy);
+
+	//: Destructor.
+	virtual ~CL_InputButton();
+
+//! Attributes:
+public:
+	//: Returns the number of presses this inputbutton has been pressed.
+	//- Returns - Number of key presses of this inputbutton.
+	int peek_pressed() const;
+
+	//: Returns the CL_InputEvent of the last input press.
+	//- Returns - CL_InputEvent of the last input press.
+	CL_InputEvent peek_key() const;
+
+//! Operations:
+public:
+	//: Copy assignment operator.
+	CL_InputButton &amp;operator =(const CL_InputButton &amp;copy);
+
+	//: Binds a key.
+	void bind(const CL_KeyBinding &amp;key);
+
+	//: Unbinds a key.
+	void unbind(const CL_KeyBinding &amp;key);
+
+	//: Unbinds all keys.
+	void unbind_all();
+
+	//: Returns a list over all keys bound to this inputbutton.
+	const std::list&lt;CL_KeyBinding&gt; &amp;get_bindings() const;
+
+	//: Returns the number of presses this inputbutton has been pressed.
+	//: This clears the state of this inputbutton.
+	//- Returns - Number of key presses of this inputbutton.
+	int pop_pressed();
+
+	//: Returns the CL_InputEvent of the last input press.
+	//: This clears the state of the inputbutton.
+	//- Returns - CL_InputEvent containing information on last input press.
+	CL_InputEvent pop_key();
+
+	//: Clears the state of the inputbutton.
+	void clear();
+
+//! Implementation:
+private:
+	CL_InputButton_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Display/input_context.h
===================================================================
--- trunk/clanlib/API/Display/input_context.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/input_context.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,117 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Input&quot;
+//! header=display.h
+
+#ifndef header_input_context
+#define header_input_context
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../signals.h&quot;
+
+class CL_InputDevice;
+class CL_InputEvent;
+class CL_InputContext_Generic;
+
+//: Input events interface.
+//- !group=Display/Input!
+//- !header=display.h!
+//- &lt;p&gt;An input context is a collection of inputdevices available in
+//- a displaywindow.&lt;/p&gt;
+class CL_API_DISPLAY CL_InputContext
+{
+//! Construction:
+public:
+	//: Constructs an input context.
+	CL_InputContext();
+
+	CL_InputContext(const CL_InputContext &amp;copy);
+
+	~CL_InputContext();
+
+//! Attributes:
+public:
+	//: Returns the number of keyboards available.
+	int get_keyboard_count() const;
+
+	//: Returns the number of mice available.
+	int get_mouse_count() const;
+
+	//: Returns the number of joysticks available.
+	int get_joystick_count() const;
+
+	//: Returns the input device for the specified keyboard.
+	CL_InputDevice &amp;get_keyboard(int keyboard = 0);
+
+	//: Returns the input device for the specified mouse.
+	CL_InputDevice &amp;get_mouse(int mouse = 0);
+
+	//: Returns the input device for the specified joystick.
+	CL_InputDevice &amp;get_joystick(int joystick = 0);
+
+	//: Returns the input device with the given devicename
+	CL_InputDevice &amp;get_device(const std::string&amp; devicename);
+
+//! Operations:
+public:
+	//: Copy assignment operator.
+	CL_InputContext &amp;operator =(CL_InputContext &amp;copy);
+
+	//: Removes all devices from this input context.
+	void clear();
+
+	//: Adds a new keyboard to the input context.
+	void add_keyboard(const CL_InputDevice &amp;keyboard);
+
+	//: Adds a new mouse to the input context.
+	void add_mouse(const CL_InputDevice &amp;mouse);
+
+	//: Adds a new joystick to the input context.
+	void add_joystick(const CL_InputDevice &amp;joystick);
+
+//! Implementation:
+private:
+	CL_InputContext_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Display/input_device.h
===================================================================
--- trunk/clanlib/API/Display/input_device.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/input_device.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,169 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Input&quot;
+//! header=display.h
+
+#ifndef header_inputdevice
+#define header_inputdevice
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4786)
+#endif
+
+#include &lt;string&gt;
+
+#include &quot;../signals.h&quot;
+
+class CL_InputDevice_Generic;
+class CL_InputEvent;
+
+//: General input device.
+//- !group=Display/Input!
+//- !header=display.h!
+class CL_API_DISPLAY CL_InputDevice
+{
+public:
+	//: Input device types.
+	enum Type
+	{
+		keyboard,
+		mouse,
+		joystick,
+                tablet,
+                unknown
+	};
+
+//! Construction:
+public:
+	//: Constructs an input device.
+	CL_InputDevice();
+
+	CL_InputDevice(const CL_InputDevice &amp;copy);
+
+	~CL_InputDevice();
+
+//! Attributes:
+public:
+	//: Returns the human readable name of the device (i.e. 'Microsoft Sidewinder 3D').
+	std::string get_name() const;
+
+	//: Return the hardware id/device for this device (i.e. /dev/input/js0)
+	std::string get_device_name() const;
+
+	//: Returns the input device type.
+	Type get_type() const;
+
+	//: Friendly key name for specified identifier (A, B, Leertaste, Backspace, Mouse Left, ...).
+	//- &lt;p&gt;Note that this key name is localized, meaning it should only be used for menus
+	//- where the user view key bindings, and not configuration files and such.&lt;/p&gt;
+	std::string get_key_name(int id) const;
+
+	//: Returns a generic string name for the specified key code. 
+	std::string keyid_to_string(int keycode) const;
+
+	//: Returns the key code for the specified generic string key name.
+	int string_to_keyid(const std::string &amp;str) const;
+
+	//: Returns true if the passed key code is down for this device.
+	//- &lt;p&gt;See keys.h for list of key codes.&lt;/p&gt;
+	bool get_keycode(int keycode) const;
+	
+	//: Returns the x position of the device.
+	//- &lt;p&gt;Only valid for mouse.&lt;/p&gt;
+	int get_x() const;
+
+	//: Returns the y position of the device.
+	//- &lt;p&gt;Only valid for mouse.&lt;/p&gt;
+	int get_y() const;
+
+	//: Returns the the current position of a joystick axis.
+	float get_axis(int index) const;
+
+	//: Returns the number of axes available on this device.
+	int get_axis_count() const;
+
+	//: Returns the number of buttons available on this device.
+	//- &lt;p&gt;If used on a keyboard, this function returns -1.&lt;/p&gt;
+	int get_button_count() const;
+
+//! Operations:
+public:
+	CL_InputDevice &amp;operator =(const CL_InputDevice &amp;copy);
+
+	//: Sets the position of the device.
+	//- &lt;p&gt;Only valid for mouse.&lt;/p&gt;
+	void set_position(int x, int y);
+
+//! Signals:
+public:
+	//: Signal emitted when key is pressed.
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;sig_key_down();
+
+	//: Signal emitted when key is released.
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;sig_key_up();
+
+	//: Signal emitted when the mouse is double-clicked.
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;sig_key_dblclk();
+
+	//: Signal emitted when pointer is moved (absolute movement).
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;sig_pointer_move();
+
+	//: Signal emitted when pointer's ball is moved (relative movement).
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;sig_ball_move();
+
+	//: Signal emitted when axis is moved.
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;sig_axis_move();
+
+	//: Deprecated. Use sig_pointer_move() instead.
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;sig_move();
+
+//! Implementation:
+public:
+	CL_InputDevice(CL_InputDevice_Generic *impl);
+
+private:
+	CL_InputDevice_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Display/input_event.h
===================================================================
--- trunk/clanlib/API/Display/input_event.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/input_event.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,109 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Input&quot;
+//! header=display.h
+
+#ifndef header_inputevent
+#define header_inputevent
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;input_device.h&quot;
+#include &quot;../Core/Math/point.h&quot;
+
+//: Structure descripting an input device event.
+//- !group=Display/Input!
+//- !header=display.h!
+class CL_API_DISPLAY CL_InputEvent
+{
+public:
+	//: Event types.
+	enum Type
+	{
+		no_key            = 0,
+		pressed           = 1,
+		released          = 2,
+		moved             = 4,
+		pointer_moved     = 4,
+		axis_moved        = 5,
+		ball_moved        = 6
+	};
+
+//! Construction:
+public:
+	//: Constructs a 'NoKey' key.
+	CL_InputEvent();
+
+	~CL_InputEvent();
+
+//! Attributes:
+public:
+	//: Key identifier.
+	int id;
+
+	//: Character sequence generated by event.
+	//- &lt;p&gt;A key press can generate one, none or multiple characters,
+	//- the reason for this are deadkeys, ie. press ^ + a and get &#226;, so
+	//- the first press would generate no key and the second one, in
+	//- case that the second key being pressed doesn't support the ^ it
+	//- would generate two characters (ie. ^ + 5 =&gt; &quot;&quot;, &quot;^5&quot;)&lt;/p&gt;
+	std::string str;
+
+	//: Event type.
+	Type type;
+
+	//: Device that event originates from.
+	CL_InputDevice device;
+	
+	//: Mouse position at event time.
+	CL_Point mouse_pos;
+
+	//: Axis position.
+	float axis_pos;
+
+	//: The repeat count for this event.
+	//- &lt;p&gt;The variable contains the number of times the keystroke is
+	//- autorepeated as a result of the user holding down the key.&lt;/p&gt;
+	int repeat_count;
+};
+
+#endif

Added: trunk/clanlib/API/Display/joystick.h
===================================================================
--- trunk/clanlib/API/Display/joystick.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/joystick.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,100 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Input&quot;
+//! header=display.h
+
+#ifndef header_joystick
+#define header_joystick
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4786)
+#endif
+
+#include &lt;string&gt;
+#include &quot;../signals.h&quot;
+
+class CL_InputEvent;
+class CL_InputDevice;
+
+//: Joystick class.
+//- !group=Display/Input!
+//- !header=display.h!
+class CL_API_DISPLAY CL_Joystick
+{
+//! Construction:
+public:
+
+//! Attributes:
+public:
+	//: Returns the number of joysticks available.
+	static int get_device_count();
+
+	//: Returns a joystick device.
+	static CL_InputDevice &amp;get_device(int joystick = 0);
+	
+	//: Returns true if the key with the specified key code is pressed.
+	static bool get_keycode(int keycode, int joystick = 0);
+
+	//: Key name for specified identifier (Joystick Button 1).
+	static std::string get_key_name(int id);
+
+//! Operations:
+public:
+
+//! Signals:
+public:
+	//: Signal emitted when a joystick button is pressed on the specified joystick.
+	static CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;sig_key_down(int joystick = 0);
+
+	//: Signal emitted when a joystick button is released on the specified joystick.
+	static CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;sig_key_up(int joystick = 0);
+
+	//: Signal emitted when specified joystick is moved.
+	static CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;sig_move(int joystick = 0);
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/API/Display/key_binding.h
===================================================================
--- trunk/clanlib/API/Display/key_binding.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/key_binding.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,108 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Input&quot;
+//! header=display.h
+
+#ifndef header_keybinding
+#define header_keybinding
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+
+class CL_KeyBinding_Generic;
+class CL_InputDevice;
+
+//: Input Button binding interface.
+//- !group=Display/Input!
+//- !header=display.h!
+//- Use this class to ...
+class CL_API_DISPLAY CL_KeyBinding
+{
+//! Construction:
+public:
+	//: Constructor.
+	CL_KeyBinding();
+
+	//: Constructor.
+	CL_KeyBinding(int keycode, const CL_InputDevice &amp;device);
+
+	//: Copy constructor.
+	CL_KeyBinding(const CL_KeyBinding &amp;copy);
+
+//! Attributes:
+public:
+	//:
+	bool operator ==(const CL_KeyBinding &amp;other) const;
+
+	//:
+	bool operator &lt;(const CL_KeyBinding &amp;other) const;
+
+	//:
+	bool operator &gt;(const CL_KeyBinding &amp;other) const;
+
+	//:
+	CL_InputDevice &amp;get_device() const;
+
+	//:	
+	int get_keycode() const;
+
+	//:
+	std::string get_key_name() const;
+
+//! Operations:
+public:
+	//:
+	CL_KeyBinding &amp;operator =(const CL_KeyBinding &amp;copy);
+
+	//:
+	void set_keycode(int keycode);
+
+	//:
+	void set_device(const CL_InputDevice &amp;device);
+
+//! Implementation:
+private:
+	CL_KeyBinding_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Display/keyboard.h
===================================================================
--- trunk/clanlib/API/Display/keyboard.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/keyboard.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,97 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Input&quot;
+//! header=display.h
+
+#ifndef header_keyboard
+#define header_keyboard
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4786)
+#endif
+
+#include &lt;string&gt;
+#include &quot;../signals.h&quot;
+
+class CL_InputEvent;
+class CL_InputDevice;
+
+//: Keyboard class.
+//- !group=Display/Input!
+//- !header=display.h!
+class CL_API_DISPLAY CL_Keyboard
+{
+//! Construction:
+public:
+
+//! Attributes:
+public:
+	//: Returns the number of keyboards available.
+	static int get_device_count();
+
+	//: Returns a keyboard device.
+	static CL_InputDevice &amp;get_device(int keyboard = 0);
+
+	//: Returns true if the key with the specified key code is pressed.
+	static bool get_keycode(int keycode, int keyboard = 0);
+
+	//: Key name for specified identifier (A, B, Space, Backspace).
+	static std::string get_key_name(int id);
+
+//! Operations:
+public:
+
+//! Signals:
+public:
+	//: Signal emitted when key is pressed on the specified keyboard.
+	static CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;sig_key_down(int keyboard = 0);
+
+	//: Signal emitted when key is released on the specified keyboard.
+	static CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;sig_key_up(int keyboard = 0);
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/API/Display/keys.h
===================================================================
--- trunk/clanlib/API/Display/keys.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/keys.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,485 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Input&quot;
+//! header=display.h
+
+#ifndef header_keys
+#define header_keys
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+// Keyboard &amp; mouse platform independence support.
+
+#ifdef WIN32
+
+#include &lt;windows.h&gt;
+
+#define CL_MOUSE_LEFT 0
+#define CL_MOUSE_RIGHT 1
+#define CL_MOUSE_MIDDLE 2
+#define CL_MOUSE_WHEEL_UP 3
+#define CL_MOUSE_WHEEL_DOWN 4
+#define CL_MOUSE_XBUTTON1 5
+#define CL_MOUSE_XBUTTON2 6
+
+#define CL_KEY_BACKSPACE VK_BACK
+#define CL_KEY_TAB VK_TAB
+#define CL_KEY_CLEAR VK_CLEAR
+#define CL_KEY_RETURN VK_RETURN
+#define CL_KEY_SHIFT VK_SHIFT
+#define CL_KEY_CONTROL VK_CONTROL
+#define CL_KEY_MENU VK_MENU
+#define CL_KEY_PAUSE VK_PAUSE
+#define CL_KEY_ESCAPE VK_ESCAPE
+
+#if !defined(__CYGWIN__) &amp;&amp; !defined(__MINGW32__)
+#  define CL_KEY_KANJI      VK_KANJI
+#  define CL_KEY_CONVERT    VK_CONVERT
+#  define CL_KEY_NONCONVERT VK_NONCONVERT
+#endif
+
+#define CL_KEY_SPACE VK_SPACE
+#define CL_KEY_PRIOR VK_PRIOR
+#define CL_KEY_NEXT VK_NEXT
+#define CL_KEY_END VK_END
+#define CL_KEY_HOME VK_HOME
+#define CL_KEY_LEFT VK_LEFT
+#define CL_KEY_UP VK_UP
+#define CL_KEY_RIGHT VK_RIGHT
+#define CL_KEY_DOWN VK_DOWN
+#define CL_KEY_SELECT VK_SELECT
+#define CL_KEY_PRINT VK_PRINT
+#define CL_KEY_EXECUTE VK_EXECUTE
+#define CL_KEY_INSERT VK_INSERT
+#define CL_KEY_DELETE VK_DELETE
+#define CL_KEY_HELP VK_HELP
+#define CL_KEY_0 '0'
+#define CL_KEY_1 '1'
+#define CL_KEY_2 '2'
+#define CL_KEY_3 '3'
+#define CL_KEY_4 '4'
+#define CL_KEY_5 '5'
+#define CL_KEY_6 '6'
+#define CL_KEY_7 '7'
+#define CL_KEY_8 '8'
+#define CL_KEY_9 '9'
+#define CL_KEY_A 'A'
+#define CL_KEY_B 'B'
+#define CL_KEY_C 'C'
+#define CL_KEY_D 'D'
+#define CL_KEY_E 'E'
+#define CL_KEY_F 'F'
+#define CL_KEY_G 'G'
+#define CL_KEY_H 'H'
+#define CL_KEY_I 'I'
+#define CL_KEY_J 'J'
+#define CL_KEY_K 'K'
+#define CL_KEY_L 'L'
+#define CL_KEY_M 'M'
+#define CL_KEY_N 'N'
+#define CL_KEY_O 'O'
+#define CL_KEY_P 'P'
+#define CL_KEY_Q 'Q'
+#define CL_KEY_R 'R'
+#define CL_KEY_S 'S'
+#define CL_KEY_T 'T'
+#define CL_KEY_U 'U'
+#define CL_KEY_V 'V'
+#define CL_KEY_W 'W'
+#define CL_KEY_X 'X'
+#define CL_KEY_Y 'Y'
+#define CL_KEY_Z 'Z'
+#define CL_KEY_LWIN VK_LWIN
+#define CL_KEY_RWIN VK_RWIN
+#define CL_KEY_APPS VK_APPS
+#define CL_KEY_NUMPAD0 VK_NUMPAD0
+#define CL_KEY_NUMPAD1 VK_NUMPAD1
+#define CL_KEY_NUMPAD2 VK_NUMPAD2
+#define CL_KEY_NUMPAD3 VK_NUMPAD3
+#define CL_KEY_NUMPAD4 VK_NUMPAD4
+#define CL_KEY_NUMPAD5 VK_NUMPAD5
+#define CL_KEY_NUMPAD6 VK_NUMPAD6
+#define CL_KEY_NUMPAD7 VK_NUMPAD7
+#define CL_KEY_NUMPAD8 VK_NUMPAD8
+#define CL_KEY_NUMPAD9 VK_NUMPAD9
+#define CL_KEY_MULTIPLY VK_MULTIPLY
+#define CL_KEY_ADD VK_ADD
+#define CL_KEY_SEPARATOR VK_SEPARATOR
+#define CL_KEY_SUBTRACT VK_SUBTRACT
+#define CL_KEY_DECIMAL VK_DECIMAL
+#define CL_KEY_DIVIDE VK_DIVIDE
+#define CL_KEY_F1 VK_F1
+#define CL_KEY_F2 VK_F2
+#define CL_KEY_F3 VK_F3
+#define CL_KEY_F4 VK_F4
+#define CL_KEY_F5 VK_F5
+#define CL_KEY_F6 VK_F6
+#define CL_KEY_F7 VK_F7
+#define CL_KEY_F8 VK_F8
+#define CL_KEY_F9 VK_F9
+#define CL_KEY_F10 VK_F10
+#define CL_KEY_F11 VK_F11
+#define CL_KEY_F12 VK_F12
+#define CL_KEY_F13 VK_F13
+#define CL_KEY_F14 VK_F14
+#define CL_KEY_F15 VK_F15
+#define CL_KEY_F16 VK_F16
+#define CL_KEY_F17 VK_F17
+#define CL_KEY_F18 VK_F18
+#define CL_KEY_F19 VK_F19
+#define CL_KEY_F20 VK_F20
+#define CL_KEY_F21 VK_F21
+#define CL_KEY_F22 VK_F22
+#define CL_KEY_F23 VK_F23
+#define CL_KEY_F24 VK_F24
+#define CL_KEY_NUMLOCK VK_NUMLOCK
+#define CL_KEY_SCROLL VK_SCROLL
+#define CL_KEY_LSHIFT VK_LSHIFT
+#define CL_KEY_RSHIFT VK_RSHIFT
+#define CL_KEY_LCONTROL VK_LCONTROL
+#define CL_KEY_RCONTROL VK_RCONTROL
+#define CL_KEY_LMENU VK_LMENU
+#define CL_KEY_RMENU VK_RMENU
+#define CL_KEY_GRAVE VK_OEM_3  //unshifted tilde - at least on US keyboards - verify?
+
+#else
+#ifdef __APPLE__
+
+#include &lt;Carbon/carbon.h&gt;
+
+// Seems like this platform dont have keysyms, or their docs suck so much I
+// can't find it.
+//
+// To solve this matter I've made my own virtual key numbering. If a key
+// pressed does not match any of these, then it will return the actual
+// MacOSX keycode in the high order word (keycode + 0x10000000).
+//
+// Naturally this require that they dont use keycode values above 0xffff,
+// but if they do complain to Apple for their crappy keyboard support.
+// Already kinda pissed that the keys for typing { and } are alt+shift+8 and
+// alt+shift+9, plus that backslash is alt+shift+7. How hostile is that!?!?
+// Oh well what can you expect from a company that write &quot;Designed by Apple
+// in California&quot; with big letters when you open your box that the powerbook
+// came in. Yes it fucking shows thats its designed in California!!
+//
+// (No offence to California though. Been there once and loved the place.)
+
+#define CL_MOUSE_LEFT			0
+#define CL_MOUSE_RIGHT			1
+#define CL_MOUSE_MIDDLE			2
+#define CL_MOUSE_WHEEL_UP		3
+#define CL_MOUSE_WHEEL_DOWN		4
+#define CL_MOUSE_XBUTTON1		5
+#define CL_MOUSE_XBUTTON2		6
+
+#define CL_KEY_BACKSPACE		10
+#define CL_KEY_TAB				11
+#define CL_KEY_CLEAR			12
+#define CL_KEY_RETURN			13
+#define CL_KEY_SHIFT			14
+#define CL_KEY_CONTROL			15
+#define CL_KEY_OPTION			16
+#define CL_KEY_PAUSE			17
+#define CL_KEY_KANJI			18
+#define CL_KEY_ESCAPE			19
+#define CL_KEY_CONVERT			20
+#define CL_KEY_NONCONVERT		21
+#define CL_KEY_SPACE			22
+#define CL_KEY_PRIOR			23
+#define CL_KEY_NEXT				24
+#define CL_KEY_END				25
+#define CL_KEY_HOME				26
+#define CL_KEY_LEFT				27
+#define CL_KEY_UP				28
+#define CL_KEY_RIGHT			29
+#define CL_KEY_DOWN				30
+#define CL_KEY_SELECT			31
+#define CL_KEY_PRINT			32
+#define CL_KEY_EXECUTE			33
+#define CL_KEY_INSERT			34
+#define CL_KEY_DELETE			35
+#define CL_KEY_HELP				36
+#define CL_KEY_0				37
+#define CL_KEY_1				38
+#define CL_KEY_2				39
+#define CL_KEY_3				40
+#define CL_KEY_4				41
+#define CL_KEY_5				42
+#define CL_KEY_6				43
+#define CL_KEY_7				44
+#define CL_KEY_8				45
+#define CL_KEY_9				46
+#define CL_KEY_A				47
+#define CL_KEY_B				48
+#define CL_KEY_C				49
+#define CL_KEY_D				50
+#define CL_KEY_E				51
+#define CL_KEY_F				52
+#define CL_KEY_G				53
+#define CL_KEY_H				54
+#define CL_KEY_I				55
+#define CL_KEY_J				56
+#define CL_KEY_K				57
+#define CL_KEY_L				58
+#define CL_KEY_M				59
+#define CL_KEY_N				60
+#define CL_KEY_O				61
+#define CL_KEY_P				62
+#define CL_KEY_Q				63
+#define CL_KEY_R				64
+#define CL_KEY_S				65
+#define CL_KEY_T				66
+#define CL_KEY_U				67
+#define CL_KEY_V				68
+#define CL_KEY_W				69
+#define CL_KEY_X				70
+#define CL_KEY_Y				71
+#define CL_KEY_Z				72
+#define CL_KEY_LWIN				73
+#define CL_KEY_RWIN				74
+#define CL_KEY_APPS				75
+#define CL_KEY_NUMPAD0			76
+#define CL_KEY_NUMPAD1			77
+#define CL_KEY_NUMPAD2			78
+#define CL_KEY_NUMPAD3			79
+#define CL_KEY_NUMPAD4			80
+#define CL_KEY_NUMPAD5			81
+#define CL_KEY_NUMPAD6			82
+#define CL_KEY_NUMPAD7			83
+#define CL_KEY_NUMPAD8			84
+#define CL_KEY_NUMPAD9			85
+#define CL_KEY_MULTIPLY			86
+#define CL_KEY_ADD				87
+#define CL_KEY_SUBTRACT			89
+#define CL_KEY_PERIOD			90
+#define CL_KEY_DIVIDE			91
+#define CL_KEY_F1				92
+#define CL_KEY_F2				93
+#define CL_KEY_F3				94
+#define CL_KEY_F4				95
+#define CL_KEY_F5				96
+#define CL_KEY_F6				97
+#define CL_KEY_F7				98
+#define CL_KEY_F8				99
+#define CL_KEY_F9				100
+#define CL_KEY_F10				101
+#define CL_KEY_F11				102
+#define CL_KEY_F12				103
+#define CL_KEY_F13				104
+#define CL_KEY_F14				105
+#define CL_KEY_F15				106
+#define CL_KEY_F16				107
+#define CL_KEY_F17				108
+#define CL_KEY_F18				109
+#define CL_KEY_F19				110
+#define CL_KEY_F20				111
+#define CL_KEY_F21				112
+#define CL_KEY_F22				113
+#define CL_KEY_F23				114
+#define CL_KEY_F24				115
+#define CL_KEY_NUMLOCK			116
+#define CL_KEY_SCROLL			117
+#define CL_KEY_LSHIFT			118
+#define CL_KEY_RSHIFT			119
+#define CL_KEY_LCONTROL			120
+#define CL_KEY_RCONTROL			121
+#define CL_KEY_LMENU			122
+#define CL_KEY_RMENU			123
+#define CL_KEY_NUMPAD_DECIMAL	124
+#define CL_KEY_NUMPAD_MULTIPLY	125
+#define CL_KEY_NUMPAD_ADD		126
+#define CL_KEY_NUMPAD_DIVIDE	127
+#define CL_KEY_NUMPAD_ENTER		128
+#define CL_KEY_NUMPAD_SUBTRACT	129
+#define CL_KEY_NUMPAD_EQUALS	130
+#define CL_KEY_QUOTE			131
+#define CL_KEY_SEMICOLON		132
+#define CL_KEY_COMMA			133
+#define CL_KEY_GRAVE			134
+#define CL_KEY_PAGE_UP			135
+#define CL_KEY_PAGE_DOWN		136
+#define CL_KEY_EQUALS			137
+#define CL_KEY_CAPSLOCK			138
+#define CL_KEY_COMMAND			139
+
+// remappings:
+#define CL_KEY_NUMPAD_0			CL_KEY_NUMPAD0
+#define CL_KEY_NUMPAD_1			CL_KEY_NUMPAD1
+#define CL_KEY_NUMPAD_2			CL_KEY_NUMPAD2
+#define CL_KEY_NUMPAD_3			CL_KEY_NUMPAD3
+#define CL_KEY_NUMPAD_4			CL_KEY_NUMPAD4
+#define CL_KEY_NUMPAD_5			CL_KEY_NUMPAD5
+#define CL_KEY_NUMPAD_6			CL_KEY_NUMPAD6
+#define CL_KEY_NUMPAD_7			CL_KEY_NUMPAD7
+#define CL_KEY_NUMPAD_8			CL_KEY_NUMPAD8
+#define CL_KEY_NUMPAD_9			CL_KEY_NUMPAD9
+#define CL_KEY_MENU				CL_KEY_OPTION
+#define CL_KEY_ALT				CL_KEY_OPTION
+#define CL_KEY_SEPARATOR		CL_KEY_DIVIDE
+#define CL_KEY_DECIMAL			CL_KEY_PERIOD
+
+#else
+
+#include &lt;X11/keysym.h&gt;
+
+#define CL_MOUSE_LEFT 0
+#define CL_MOUSE_RIGHT 1
+#define CL_MOUSE_MIDDLE 2
+#define CL_MOUSE_WHEEL_UP 3
+#define CL_MOUSE_WHEEL_DOWN 4
+#define CL_MOUSE_XBUTTON1 5
+#define CL_MOUSE_XBUTTON2 6
+
+#define CL_KEY_BACKSPACE XK_BackSpace
+#define CL_KEY_TAB XK_Tab
+#define CL_KEY_CLEAR XK_Clear
+#define CL_KEY_RETURN XK_Return
+#define CL_KEY_SHIFT XK_Shift_L
+#define CL_KEY_CONTROL XK_Control_L
+#define CL_KEY_MENU XK_Alt_L
+#define CL_KEY_PAUSE XK_Pause
+#define CL_KEY_KANJI XK_Kanji
+#define CL_KEY_ESCAPE XK_Escape
+#define CL_KEY_CONVERT XK_Henkan_Mode
+#define CL_KEY_NONCONVERT XK_Muhenkan
+#define CL_KEY_SPACE XK_space
+#define CL_KEY_PRIOR XK_Prior // aka PAGEUP
+#define CL_KEY_NEXT XK_Next // aka PAGEDOWN
+#define CL_KEY_END XK_End
+#define CL_KEY_HOME XK_Home
+#define CL_KEY_LEFT XK_Left
+#define CL_KEY_UP XK_Up
+#define CL_KEY_RIGHT XK_Right
+#define CL_KEY_DOWN XK_Down
+#define CL_KEY_SELECT XK_Select
+#define CL_KEY_PRINT XK_Print
+#define CL_KEY_EXECUTE XK_Execute
+#define CL_KEY_INSERT XK_Insert
+#define CL_KEY_DELETE XK_Delete
+#define CL_KEY_HELP XK_Help
+#define CL_KEY_0 XK_0
+#define CL_KEY_1 XK_1
+#define CL_KEY_2 XK_2
+#define CL_KEY_3 XK_3
+#define CL_KEY_4 XK_4
+#define CL_KEY_5 XK_5
+#define CL_KEY_6 XK_6
+#define CL_KEY_7 XK_7
+#define CL_KEY_8 XK_8
+#define CL_KEY_9 XK_9
+#define CL_KEY_A XK_a
+#define CL_KEY_B XK_b
+#define CL_KEY_C XK_c
+#define CL_KEY_D XK_d
+#define CL_KEY_E XK_e
+#define CL_KEY_F XK_f
+#define CL_KEY_G XK_g
+#define CL_KEY_H XK_h
+#define CL_KEY_I XK_i
+#define CL_KEY_J XK_j
+#define CL_KEY_K XK_k
+#define CL_KEY_L XK_l
+#define CL_KEY_M XK_m
+#define CL_KEY_N XK_n
+#define CL_KEY_O XK_o
+#define CL_KEY_P XK_p
+#define CL_KEY_Q XK_q
+#define CL_KEY_R XK_r
+#define CL_KEY_S XK_s
+#define CL_KEY_T XK_t
+#define CL_KEY_U XK_u
+#define CL_KEY_V XK_v
+#define CL_KEY_W XK_w
+#define CL_KEY_X XK_x
+#define CL_KEY_Y XK_y
+#define CL_KEY_Z XK_z
+#define CL_KEY_LWIN XK_Super_L
+#define CL_KEY_RWIN XK_Multi_key
+#define CL_KEY_APPS XK_Menu
+#define CL_KEY_NUMPAD0 XK_KP_0
+#define CL_KEY_NUMPAD1 XK_KP_1
+#define CL_KEY_NUMPAD2 XK_KP_2
+#define CL_KEY_NUMPAD3 XK_KP_3
+#define CL_KEY_NUMPAD4 XK_KP_4
+#define CL_KEY_NUMPAD5 XK_KP_5
+#define CL_KEY_NUMPAD6 XK_KP_6
+#define CL_KEY_NUMPAD7 XK_KP_7
+#define CL_KEY_NUMPAD8 XK_KP_8
+#define CL_KEY_NUMPAD9 XK_KP_9
+#define CL_KEY_MULTIPLY XK_KP_Multiply
+#define CL_KEY_ADD XK_KP_Add
+#define CL_KEY_SEPARATOR XK_KP_Separator
+#define CL_KEY_SUBTRACT XK_KP_Subtract
+#define CL_KEY_DECIMAL XK_KP_Decimal
+#define CL_KEY_DIVIDE XK_KP_Divide
+#define CL_KEY_F1 XK_F1
+#define CL_KEY_F2 XK_F2
+#define CL_KEY_F3 XK_F3
+#define CL_KEY_F4 XK_F4
+#define CL_KEY_F5 XK_F5
+#define CL_KEY_F6 XK_F6
+#define CL_KEY_F7 XK_F7
+#define CL_KEY_F8 XK_F8
+#define CL_KEY_F9 XK_F9
+#define CL_KEY_F10 XK_F10
+#define CL_KEY_F11 XK_F11
+#define CL_KEY_F12 XK_F12
+#define CL_KEY_F13 XK_F13
+#define CL_KEY_F14 XK_F14
+#define CL_KEY_F15 XK_F15
+#define CL_KEY_F16 XK_F16
+#define CL_KEY_F17 XK_F17
+#define CL_KEY_F18 XK_F18
+#define CL_KEY_F19 XK_F19
+#define CL_KEY_F20 XK_F20
+#define CL_KEY_F21 XK_F21
+#define CL_KEY_F22 XK_F22
+#define CL_KEY_F23 XK_F23
+#define CL_KEY_F24 XK_F24
+#define CL_KEY_NUMLOCK XK_Num_Lock
+#define CL_KEY_SCROLL XK_Scroll_Lock
+#define CL_KEY_LSHIFT XK_Shift_L
+#define CL_KEY_RSHIFT XK_Shift_R
+#define CL_KEY_LCONTROL XK_Control_L
+#define CL_KEY_RCONTROL XK_Control_R
+#define CL_KEY_LMENU XK_Meta_L
+#define CL_KEY_RMENU XK_Meta_R
+#define CL_KEY_GRAVE XK_grave
+#endif
+#endif
+
+#define CL_KEY_ENTER CL_KEY_RETURN
+#define CL_KEY_LAPPLE CL_KEY_LWIN
+#define CL_KEY_RAPPLE CL_KEY_RWIN
+#define CL_KEY_TILDE CL_KEY_GRAVE
+
+#endif

Added: trunk/clanlib/API/Display/mouse.h
===================================================================
--- trunk/clanlib/API/Display/mouse.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/mouse.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,121 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Input&quot;
+//! header=display.h
+
+#ifndef header_mouse
+#define header_mouse
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4786)
+#endif
+
+#include &lt;string&gt;
+#include &quot;../signals.h&quot;
+
+class CL_InputEvent;
+class CL_InputDevice;
+class CL_Sprite;
+
+//: Class for handling mouse device.
+//- !group=Display/Input!
+//- !header=display.h!
+class CL_API_DISPLAY CL_Mouse
+{
+//! Construction:
+public:
+
+//! Attributes:
+public:
+	//: Returns the number of mice available.
+	static int get_device_count();
+
+	//: Returns a mouse device.
+	static CL_InputDevice &amp;get_device(int mouse = 0);
+
+	//: Returns the x position of a mouse device.
+	static int get_x(int mouse = 0);
+	
+	//: Returns the y position of a mouse device.
+	static int get_y(int mouse = 0);
+	
+	//: Returns true if the key with the specified key code is pressed.
+	static bool get_keycode(int keycode, int mouse = 0);
+
+	//: Key name for specified identifier (Mouse Left, Mouse Right).
+	static std::string get_key_name(int id);
+
+//! Operations:
+public:
+	//: Sets the position of a mouse device.
+	static void set_position(int x, int y, int mouse = 0);
+
+	//: Set a custom mouse cursor.
+	static void set_cursor(const CL_Sprite &amp;sprite);
+
+	//: Shows the mouse cursor. 
+	static void show();
+
+	//: Hides the mouse cursor.
+	static void hide();
+
+//! Signals:
+public:
+	//: Signal emitted when mouse is pressed on the specified mouse.
+	static CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;sig_key_down(int mouse = 0);
+
+	//: Signal emitted when mouse is released on the specified mouse.
+	static CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;sig_key_up(int mouse = 0);
+
+	//: Signal emitted when mouse is double-clicked on the specified mouse.
+	static CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;sig_key_dblclk(int mouse = 0);
+
+	//: Signal emitted when specified mouse is moved.
+	static CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;sig_move(int mouse = 0);
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/API/Display/palette.h
===================================================================
--- trunk/clanlib/API/Display/palette.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/palette.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,76 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Display 2D&quot;
+//! header=display.h
+
+#ifndef header_palette
+#define header_palette
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4786)
+#endif
+
+#include &quot;color.h&quot;
+#include &lt;string.h&gt;
+
+//: 256 color ARGB palette class.
+//- !group=Display/Display 2D!
+//- !header=display.h!
+class CL_Palette
+{
+//! Construction:
+public:
+	//: Constructs a palette.
+	//param copy: Integer array of ARGB8888 color components to use as initial palette.
+	CL_Palette() { return; }
+
+	CL_Palette(const unsigned int *copy) { memcpy(colors, copy, sizeof(int)*256); }
+
+//! Attributes:
+public:
+	//: Palette color entries.
+	CL_Color colors[256];
+
+	//: Return color at index.
+	const CL_Color &amp;operator[](int index) const { return colors[index]; }
+
+	CL_Color &amp;operator[](int index) { return colors[index]; }
+
+	//: Returns the palette in ARGB8888 format.
+	operator const unsigned int*() const { return (const unsigned int *) colors; }
+
+	operator unsigned int*() { return (unsigned int *) colors; }
+};
+
+#endif

Added: trunk/clanlib/API/Display/pixel_buffer.h
===================================================================
--- trunk/clanlib/API/Display/pixel_buffer.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/pixel_buffer.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,162 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Display 2D&quot;
+//! header=display.h
+
+#ifndef header_pixel_buffer
+#define header_pixel_buffer
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Core/Math/rect.h&quot;
+
+class CL_PixelFormat;
+class CL_Palette;
+class CL_PixelBuffer_Generic;
+class CL_GraphicContext;
+class CL_Color;
+
+//: Pixel data access.
+//- !group=Display/Display 2D!
+//- !header=display.h!
+class CL_API_DISPLAY CL_PixelBuffer
+{
+//! Construction:
+public:
+	//: Constructs a pixel buffer.
+	//param width: Width of pixel buffer, in pixels.
+	//param height: Height of pixel buffer, in pixels.
+	//param pitch: Bytes per line in pixel buffer.
+	//param format: Pixel format of pixel buffer.
+	//param palette: Palette used in pixel buffer.
+	//param data: Data pointer to pixel data. If null, will construct a memory pixel buffer with the given dimensions.
+	//- &lt;p&gt;If the data pointer is not null, it will internally just point at the memory location specified by data.
+	//- In other words, CL_PixelBuffer do not copy the data, and it does not delete the data pointer when destroyed itself.&lt;/p&gt;
+	CL_PixelBuffer(int width, int height, int pitch, const CL_PixelFormat &amp;format, void *data = 0);
+
+	CL_PixelBuffer(int width, int height, int pitch, const CL_PixelFormat &amp;format, const CL_Palette &amp;palette, void *data = 0);
+
+	CL_PixelBuffer(const CL_PixelBuffer &amp;copy);
+
+	CL_PixelBuffer();
+
+	virtual ~CL_PixelBuffer();
+
+//! Attributes:
+public:
+	//: Returns the pixel format of the pixel buffer.
+	const CL_PixelFormat &amp;get_format() const;
+
+	//: Returns the palette of the pixel buffer.
+	const CL_Palette &amp;get_palette() const;
+
+	//: Returns the buffer width.
+	int get_width() const;
+
+	//: Returns the buffer height.
+	int get_height() const;
+
+	//: Returns the pitch (bytes per scanline).
+	unsigned int get_pitch() const;
+
+	//: Returns a pointer to the beginning of the pixel buffer. Pointer
+	//: is only valid inside a lock/unlock session.
+	void *get_data();
+	
+	//: Returns the pixel at coordinates x and y.
+	//: Only valid within a lock/unlock session.
+	CL_Color get_pixel(int x, int y);
+
+//! Operations:
+public:
+	//: Copy assignment operator.
+	CL_PixelBuffer &amp;operator =(const CL_PixelBuffer &amp;copy);
+
+	//: Return true if the CL_PixelBuffer is valid and useable
+	operator bool () const;
+
+	//: Locks the pixel buffer, making calls to get_data() valid.
+	void lock();
+
+	//: Unlocks the pixelbuffer.
+	void unlock();
+
+	//: Convert pixel buffer to the pixel format of the target buffer, storing
+	//: the result in the target buffer.
+	//param target: Target pixel buffer.
+	//param buffer: Buffer getting stored pixels in the specified format and pitch.
+	//param format: Pixel format of target buffer.
+	//param dest_pitch: Bytes per line of target buffer.
+	//param dest_rect: Destination rectangle for conversion.
+	//param src_rect: Source rectangle for conversion.
+	void convert(CL_PixelBuffer target);
+
+	void convert(void *buffer, const CL_PixelFormat &amp;format, int dest_pitch, const CL_Rect &amp;dest_rect, const CL_Rect &amp;src_rect=CL_Rect(0,0,0,0));
+
+	//: Convert one line of pixel data to target buffer.
+	//param buffer: Buffer getting stored pixels in the specified format
+	//param format: Pixel format of target buffer.
+	//param y: Specifies which line to convert when converting one single line.
+	void convert_line(void *buffer, const CL_PixelFormat &amp;format, int y);
+
+	//: Converts current buffer to a new pixel format and returns the result.
+	CL_PixelBuffer to_format(const CL_PixelFormat &amp;format);
+
+	//: Sets a new colorkey without converting the buffer.
+	//param enabled: Enable or disable the colorkey.
+	//param colorkey: New colorkey to use.
+	void set_colorkey(bool enabled, unsigned int colorkey);
+	
+	//: Draw a pixel at (x, y) using the specified color.
+	//: Only valid within a lock/unlock session.
+	void draw_pixel(int x, int y, const CL_Color &amp;color);
+
+//! Implementation:
+public:
+	CL_PixelBuffer(CL_PixelBuffer_Generic *impl);
+
+protected:
+	//: Pixel data implementation.
+	CL_PixelBuffer_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Display/pixel_format.h
===================================================================
--- trunk/clanlib/API/Display/pixel_format.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/pixel_format.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,265 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Display 2D&quot;
+//! header=display.h
+
+#ifndef header_pixelformat
+#define header_pixelformat
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;pixel_format_type.h&quot;
+
+//: Pixel data format description.
+//- !group=Display/Display 2D!
+//- !header=display.h!
+class CL_API_DISPLAY CL_PixelFormat
+{
+//! Construction:
+public:
+	//: Constructs a pixel format description.
+	//param depth: Bits per pixel.
+	//param red_mask: Red color mask.
+	//param green_mask: Green color mask.
+	//param blue_mask: Blue color mask.
+	//param alpha_mask: Alpha transparency mask.
+	//param use_colorkey: True if source color key transparency is used (single color transparency).
+	//param colorkey: Source color key (pixel value that means transparent).
+	CL_PixelFormat();
+
+	CL_PixelFormat(const CL_PixelFormat &amp;copy);
+
+	CL_PixelFormat(
+		int depth,
+		unsigned int red_mask,
+		unsigned int green_mask,
+		unsigned int blue_mask,
+		unsigned int alpha_mask = 0,
+		bool use_colorkey = false,
+		unsigned int colorkey = 0,
+		CL_PixelFormatType type = pixelformat_rgba);
+
+//! Attributes:
+public:
+	//: Returns true if this pixel format is the same as the other one.
+	bool operator ==(const CL_PixelFormat &amp;other) const;
+
+	//: Returns true if this pixel format is not the same as the other one.
+	bool operator !=(const CL_PixelFormat &amp;other) const;
+	
+	//: Returns the pixel format type (RGB or Indexed).
+	CL_PixelFormatType get_type() const { return type; }
+
+	//: Returns true if format uses a source color key.
+	bool has_colorkey() const { return colorkey_enabled; }
+
+	//: Returns the depth of the pixel format.
+	int get_depth() const { return depth; }
+
+	//: Returns the source color key.
+	unsigned int get_colorkey() const { return colorkey; }
+
+	//: Returns the red component color mask.
+	unsigned int get_red_mask() const { return red_mask; }
+
+	//: Returns the green component color mask.
+	unsigned int get_green_mask() const { return green_mask; }
+
+	//: Returns the blue component color mask.
+	unsigned int get_blue_mask() const { return blue_mask; }
+
+	//: Returns the alpha component color mask.
+	unsigned int get_alpha_mask() const { return alpha_mask; }
+
+//! Statics:
+public:
+	//: Pixel format with 32 bit depth, 8 bits per color mask.
+	//- &lt;table&gt;
+	//- &lt;tr&gt;&lt;td&gt;red mask&lt;/td&gt;  &lt;td&gt;=&lt;/td&gt;&lt;td&gt;0xff000000&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;green mask&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x00ff0000&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;blue mask&lt;/td&gt; &lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x0000ff00&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;alpha mask&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x000000ff&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;/table&gt;
+	static CL_PixelFormat rgba8888;
+
+	//: Pixel format with 24 bit depth, 8 bits per color mask, no alpha.
+	//- &lt;table&gt;
+	//- &lt;tr&gt;&lt;td&gt;red mask&lt;/td&gt;  &lt;td&gt;=&lt;/td&gt;&lt;td&gt;0xff0000&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;green mask&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x00ff00&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;blue mask&lt;/td&gt; &lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x0000ff&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;/table&gt;
+	static CL_PixelFormat rgb888;
+
+	//: Pixel format with 16 bit depth, 4 bits per color mask.
+	//- &lt;table&gt;
+	//- &lt;tr&gt;&lt;td&gt;red mask&lt;/td&gt;  &lt;td&gt;=&lt;/td&gt;&lt;td&gt;0xf000&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;green mask&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x0f00&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;blue mask&lt;/td&gt; &lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x00f0&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;alpha mask&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x000f&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;/table&gt;
+	static CL_PixelFormat rgba4444;
+
+	//: Pixel format with 16 bit depth, 5 bits per color mask, one bit unused.
+	//- &lt;table&gt;
+	//- &lt;tr&gt;&lt;td&gt;red mask&lt;/td&gt;  &lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x7c00&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;green mask&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x03e0&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;blue mask&lt;/td&gt; &lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x001f&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;alpha mask&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x0000&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;/table&gt;
+	static CL_PixelFormat rgb555;
+
+	//: Pixel format with 16 bit depth, 5 bits for red and blue, 6 bits for green.
+	//- &lt;table&gt;
+	//- &lt;tr&gt;&lt;td&gt;red mask&lt;/td&gt;  &lt;td&gt;=&lt;/td&gt;&lt;td&gt;0xf800&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;green mask&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x07e0&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;blue mask&lt;/td&gt; &lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x001f&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;alpha mask&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x0000&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;/table&gt;
+	static CL_PixelFormat rgb565;
+
+	//: Pixel format with 32 bit depth, 8 bits per color mask.
+	//- &lt;table&gt;
+	//- &lt;tr&gt;&lt;td&gt;red mask&lt;/td&gt;  &lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x000000ff&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;green mask&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x0000ff00&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;blue mask&lt;/td&gt; &lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x00ff0000&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;alpha mask&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;0xff000000&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;/table&gt;
+	static CL_PixelFormat abgr8888;
+
+	//: Pixel format with 24 bit depth, 8 bits per color mask, no alpha.
+	//- &lt;table&gt;
+	//- &lt;tr&gt;&lt;td&gt;red mask&lt;/td&gt;  &lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x0000ff&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;green mask&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x00ff00&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;blue mask&lt;/td&gt; &lt;td&gt;=&lt;/td&gt;&lt;td&gt;0xff0000&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;/table&gt;
+	static CL_PixelFormat bgr888;
+
+	//: Pixel format with 16 bit depth, 4 bits per color mask.
+	//- &lt;table&gt;
+	//- &lt;tr&gt;&lt;td&gt;red mask&lt;/td&gt;  &lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x000f&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;green mask&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x00f0&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;blue mask&lt;/td&gt; &lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x0f00&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;alpha mask&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;0xf000&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;/table&gt;
+	static CL_PixelFormat abgr4444;
+
+	//: Pixel format with 16 bit depth, 5 bits per color mask, one bit unused.
+	//- &lt;table&gt;
+	//- &lt;tr&gt;&lt;td&gt;red mask&lt;/td&gt;  &lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x001f&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;green mask&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x03e0&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;blue mask&lt;/td&gt; &lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x7c00&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;alpha mask&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x0000&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;/table&gt;
+	static CL_PixelFormat bgr555;
+
+	//: Pixel format with 16 bit depth, 5 bits for red and blue, 6 bits for green.
+	//- &lt;table&gt;
+	//- &lt;tr&gt;&lt;td&gt;red mask&lt;/td&gt;  &lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x001f&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;green mask&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x07e0&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;blue mask&lt;/td&gt; &lt;td&gt;=&lt;/td&gt;&lt;td&gt;0xf800&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;tr&gt;&lt;td&gt;alpha mask&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;0x0000&lt;/td&gt;&lt;/tr&gt;
+	//- &lt;/table&gt;
+	static CL_PixelFormat bgr565;
+
+	//: Returns the shift of a color mask.
+	static int get_mask_shift(unsigned int mask);
+	
+	//: Returns the bit count of a color mask.
+	static int get_mask_bits(unsigned int mask);
+
+	//: Returns the color mask based on bit count and shift.
+	static unsigned int get_bitmask(int bits, int shift);
+
+//! Operations:
+public:
+	//: Sets the pixel format type (RGB or Indexed).
+	void set_type(CL_PixelFormatType new_type) { type = new_type; }
+
+	//: Enable/disable color key.
+	void enable_colorkey(bool enable = true) { colorkey_enabled = enable; }
+
+	//: Sets the color key.
+	void set_colorkey(unsigned int i) { colorkey = i; }
+
+	//: Sets the depth of the pixel format.
+	void set_depth(int i) { depth = i; }
+
+	//: Sets the red component color mask.
+	void set_red_mask(unsigned int i) { red_mask = i; }
+
+	//: Sets the green component color mask.
+	void set_green_mask(unsigned int i) { green_mask = i; }
+
+	//: Sets the blue component color mask.
+	void set_blue_mask(unsigned int i) { blue_mask = i; }
+
+	//: Sets the alpha component color mask.
+	void set_alpha_mask(unsigned int i) { alpha_mask = i; }
+
+//! Implementation:
+private:
+	//: Pixel format type.
+	CL_PixelFormatType type;
+
+	//: True if colorkeying is enabled in the pixel format.
+	bool colorkey_enabled;
+
+	//: Colorkey value, if enabled.
+	unsigned int colorkey;
+	
+	//: Bitmask marking the red component in a pixel.
+	unsigned int red_mask;
+	
+	//: Bitmask marking the green component in a pixel.
+	unsigned int green_mask;
+	
+	//: Bitmask marking the blue component in a pixel.
+	unsigned int blue_mask;
+	
+	//: Bitmask marking the alpha component in a pixel.
+	unsigned int alpha_mask;
+	
+	//: Bitdepth of a pixel.
+	int depth;
+};
+
+#endif

Added: trunk/clanlib/API/Display/pixel_format_type.h
===================================================================
--- trunk/clanlib/API/Display/pixel_format_type.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/pixel_format_type.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,52 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Display 2D&quot;
+//! header=display.h
+
+#ifndef header_pixel_format_type
+#define header_pixel_format_type
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+ 
+//: Pixel format types.
+//- !group=Display/Display 2D!
+//- !header=display.h!
+enum CL_PixelFormatType
+{
+	//: RGBA format.
+	pixelformat_rgba,
+	
+	//: Indexed palette format.
+	pixelformat_index
+};
+
+#endif

Added: trunk/clanlib/API/Display/rle_surface.h
===================================================================
--- trunk/clanlib/API/Display/rle_surface.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/rle_surface.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,87 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Display 2D&quot;
+//! header=display.h
+
+#ifndef header_rle_surface
+#define header_rle_surface
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+class CL_PixelBuffer;
+class CL_GraphicContext;
+class CL_InputSource;
+class CL_OutputSource;
+class CL_RLESurface_Generic;
+
+//: Runlength encoded surface.
+//- !group=Display/Display 2D!
+//- !header=display.h!
+class CL_API_DISPLAY CL_RLESurface
+{
+//! Construction:
+public:
+	//: Constructs a run length encoded surface.
+	//param provider: Pixel buffer containing image data to be used for constructing RLE surface.
+	//param delete_provider: If true, deletes the provider after copying its image data.
+	//param input: Input source to load a surface in encoded form.
+	CL_RLESurface(CL_PixelBuffer provider);
+
+	CL_RLESurface(CL_InputSource *input);
+
+//! Operations:
+public:
+	//: Draw surface on screen.
+	void put_screen(int x, int y, CL_GraphicContext *context = 0);
+
+	//: Draw surface onto pixel buffer.
+	void blit(int x, int y, CL_PixelBuffer buffer);
+
+	//: Save surface in encoded form to an output source.
+	void save(CL_OutputSource *output);
+
+//! Implementation:
+private:
+//	CL_RLESurface_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Display/setupdisplay.h
===================================================================
--- trunk/clanlib/API/Display/setupdisplay.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/setupdisplay.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,73 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;System&quot;
+//! header=display.h
+
+#ifndef header_setupdisplay
+#define header_setupdisplay
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+//: ClanDisplay initialization functions.
+//- !group=Display/System!
+//- !header=display.h!
+class CL_API_DISPLAY CL_SetupDisplay
+{
+//! Construction:
+public:
+	//: Initializes clanDisplay.
+	//- &lt;p&gt;Constructing a CL_SetupDisplay object is equalent to calling CL_SetupDisplay::init().&lt;/p&gt;
+	//- &lt;p&gt;When the CL_SetupDisplay instance is destroyed, CL_SetupDisplay::deinit() is called.&lt;/p&gt;
+	CL_SetupDisplay(bool register_resources_only = false);
+
+	~CL_SetupDisplay();
+
+//! Operations:
+public:
+	//: Initialize the clanDisplay library.
+	static void init(bool register_resources_only = false);
+	
+	//: Deinitialize the clanDisplay library.
+	static void deinit();
+};
+
+#endif

Added: trunk/clanlib/API/Display/sprite.h
===================================================================
--- trunk/clanlib/API/Display/sprite.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/sprite.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,326 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Sprites&quot;
+//! header=display.h
+
+#ifndef header_sprite
+#define header_sprite
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;surface.h&quot;
+#include &quot;blend_func.h&quot;
+#include &quot;../Core/Math/origin.h&quot;
+
+#include &quot;../Core/Math/size.h&quot;
+#include &quot;../Core/Math/rect.h&quot;
+#include &quot;../Core/Resources/resource.h&quot;
+
+class CL_ResourceManager;
+class CL_SpriteDescription;
+class CL_Sprite_Generic;
+class CL_GraphicContext;
+
+//: This class handles displaying sprites on the screen. 
+//- !group=Display/Sprites!
+//- !header=display.h!
+//- &lt;p&gt;There are two overviews describing the sprite system in ClanLib.
+//- The &lt;a href=&quot;../../Overview/sprites_overview.html&quot;&gt;sprites overview&lt;/a&gt;, and the
+//- &lt;a href=&quot;../../Overview/sprites_resources.html&quot;&gt;sprites resources overview.&lt;/a&gt;&lt;/p&gt;
+class CL_API_DISPLAY CL_Sprite
+{ 
+//! Enums:
+public:
+	enum ShowOnFinish
+	{
+		show_blank, show_last_frame, show_first_frame
+	};
+	
+//! Construction:
+public:
+	//: Constructs a sprite.
+	//param resource_id: Resource name of a sprite resource.
+	//param manager: Resource manager used to load resource.
+	//param sprite_description: Sprite description used to construct sprite.
+	//param pack_texture: If true, will try to pack sprite into as few textures as possible.
+	CL_Sprite(
+		const std::string &amp;resource_id,
+		CL_ResourceManager *manager);
+
+	CL_Sprite(const CL_SpriteDescription &amp;sprite_description, bool pack_texture = true);
+
+	CL_Sprite(const CL_Sprite &amp;sprite);
+
+	CL_Sprite();
+
+	virtual ~CL_Sprite();
+
+//! Attributes:
+public:
+	//: Returns current angle in degrees.
+	float get_angle() const;
+
+	//: Returns the current rotational yaw angle in degrees.
+	float get_angle_yaw() const;
+
+	//: Returns the current rotational pitch angle in degrees.
+	float get_angle_pitch() const;
+
+	//: Returns the base angle in degrees - angle added to any rotation set with set_rotate() or rotate().
+	float get_base_angle() const;
+
+	//: Returns scale for x and y.
+	//- &lt;p&gt; 1.0f is normal scale, 2.0f is twice the size, etc. &lt;/p&gt;
+	void get_scale(float &amp;x, float &amp;y) const;
+
+	//: Returns current alpha.
+	//- &lt;p&gt; Alpha 0.0f is full transparency, and 1.0f is full visibility (solid). &lt;/p&gt;
+	float get_alpha() const;
+
+	//: Returns current color.
+	//- &lt;p&gt; Alpha 0.0f is full transparency, and 1.0f is full visibility (solid). &lt;/p&gt;
+	void get_color(float &amp;red, float &amp;green, float &amp;blue, float &amp;alpha) const;
+	CL_Color get_color() const {float r,g,b,a; get_color(r,g,b,a); return CL_Color(int(r*255.0f),int(g*255.0f),int(b*255.0f),int(a*255.0f));}
+
+	//: Returns blending functions.
+	void get_blend_func(CL_BlendFunc &amp;src, CL_BlendFunc &amp;dest) const;
+
+	//: Returns translation hotspot.
+	void get_alignment(CL_Origin &amp;origin, int &amp;x, int &amp;y) const;
+
+	//: Returns rotation hotspot.
+	void get_rotation_hotspot(CL_Origin &amp;origin, int &amp;x, int &amp;y) const;
+
+	//: Returns current frame in animation. 0 is first frame.
+	int get_current_frame() const;
+
+	//: Returns number of frames in animation.
+	int get_frame_count() const;
+
+	//: Returns the delay of a frame. 0 is first frame.
+	float get_frame_delay(int frame) const;
+
+	//: Returns the translation offset of a frame. 0 is first frame.
+	CL_Point get_frame_offset(int frame) const;
+	
+	//: Returns the size of a frame. 0 is first frame.
+	CL_Size get_frame_size(int frame) const;
+
+	//: Return the width of the current frame, shortcut for
+	//: 'get_frame_size(get_current_frame()).width'
+	int get_width() const;
+
+	//: Return the height of the current frame, shortcut for
+	//: 'get_frame_size(get_current_frame()).height'
+	int get_height() const;
+
+	//: Returns the surface of a frame. 0 is first frame.
+	//- &lt;p&gt; Returns an empty surface if frame is invalid. &lt;/p&gt;
+	CL_Surface get_frame_surface(int frame) const;
+
+	//: Returns a CL_PixelBuffer with the same dimensions
+	//: as this sprite.
+	//- &lt;p&gt; Returns an empty pixelbuffer if frame is invalid. &lt;/p&gt;
+	CL_PixelBuffer get_frame_pixeldata(int frame) const;
+
+	//: Returns the attached id (if exists).
+	int get_id() const;
+	
+	//: Returns true if this is an unattached sprite.
+	bool is_null() const;
+	
+	//: Returns true if animation is played in loop (more than once).
+	bool is_play_loop() const;
+
+	//: Returns true if animation is played in from right to left (starts at end).
+	bool is_play_backward() const;
+
+	//: Returns true if animation is played in ping-pong mode.
+	bool is_play_pingpong() const;
+
+	//: Returns an enum for what is shown when the animation is finished.
+	//- &lt;p&gt; If show_blank is returned, nothing is shown when animation is done. &lt;/p&gt;
+	ShowOnFinish get_show_on_finish() const;
+
+	//: Returns true if animation is finished.
+	//- &lt;p&gt; When an animation is finished, it will no longer show, unless ShowLastFrame is set
+	//- to anything other than show_blank &lt;/p&gt;
+	bool is_finished() const;
+
+	//: Resource owning this sprite, if any.
+	CL_Resource resource;
+
+//! Operations:
+public:
+	//: Copy assignment operator.
+	CL_Sprite &amp;operator =(const CL_Sprite &amp;copy);
+
+	//: Return true if the CL_Sprite is valid and useable
+	operator bool () const;
+
+	//: Sets the image data from another sprite.
+	//- Use this to change the look of your sprite.
+	void set_image_data(const CL_Sprite &amp;image_source);
+	
+	//: Draw sprite on graphic context.
+	//param x, y: Anchor position of where to render sprite. Actual rendering position depends on the anchor and the alignment mode.
+	//param gc: Graphic context on which to render upon. If null, will use CL_Display's current graphic context.
+	//param dest: Rectangle to draw sprite in.
+	void draw(
+                float x,
+		float y,
+		CL_GraphicContext *gc = 0);
+
+	void draw(
+		const CL_Rect &amp;dest,
+		CL_GraphicContext *gc = 0);
+
+	//sub pixel accuracy versions
+
+	void draw(
+		const CL_Rectf &amp;dest,
+		CL_GraphicContext *gc = 0);
+
+	void draw_subpixel(
+		float x,
+		float y,
+		CL_GraphicContext *gc = 0);
+
+	
+	//: Call this function to update the animation.
+	//- Returns the time elapsed parameter, the automatic calculated one if you used 0.
+	//param time_elapsed: milliseconds since last update. Use 0 for automatic time calculation.
+	float update(float time_elapsed = 0);
+
+	//: Set absolute rotation angle in degrees.
+	void set_angle(float angle);
+	
+	//: Set absolute rotation pitch angle in degrees.
+	void set_angle_pitch(float angle);
+	
+	//: Set absolute rotation yaw angle in degrees.
+	void set_angle_yaw(float angle);
+
+	//: Add angle in degrees to current angle.
+	void rotate(float angle);
+	
+	//: Add angle in degrees to current pitch angle.
+	void rotate_pitch(float angle);
+	
+	//: Add angle in degrees to current yaw angle.
+	void rotate_yaw(float angle);
+
+	//: Sets the base angle in degrees - angle added to any rotation set with set_rotate() or rotate().
+	void set_base_angle(float angle);
+
+	//: Set scale for x and y directions individually.
+	//- &lt;p&gt; 1.0f is normal scale, 2.0f is twice the size, etc. &lt;/p&gt;
+	void set_scale(float x, float y);
+
+	//: Sets transparency.
+	//- &lt;p&gt; Alpha 0.0f is full transparency, and 1.0f is full visibility (solid). &lt;/p&gt;
+	void set_alpha(float alpha);
+
+	//: Sets the color.
+	//- &lt;p&gt; Alpha 0.0f is full transparency, and 1.0f is full visibility (solid). &lt;/p&gt;
+	void set_color(float r, float g, float b, float a = 1.0f);
+	void set_color(const CL_Color&amp; c) {set_color(float(c.get_red())/255.0f,float(c.get_green())/255.0f,float(c.get_blue())/255.0f,float(c.get_alpha())/255.0f);}
+
+	//: Sets blending functions.
+	void set_blend_func(CL_BlendFunc src, CL_BlendFunc dest);
+
+	//: Sets blending functions.
+	void set_blend_func_separate(CL_BlendFunc src, CL_BlendFunc dest,
+                                     CL_BlendFunc src_alpha, CL_BlendFunc dest_alpha);
+
+	//: Sets translation hotspot.
+	void set_alignment(CL_Origin origin, int x = 0, int y = 0);
+
+	//: Sets rotation hotspot.
+	void set_rotation_hotspot(CL_Origin origin, int x = 0, int y = 0);
+
+	//: Sets current animation frame. 0 is first frame.
+	//: It will cap to available range.
+	void set_frame(unsigned int frame);
+
+	//: Sets the delay of a specific frame. 0 is first frame.
+	void set_frame_delay(int frame, float delay);
+
+	//: Sets the translate offset of a specific frame. 0 is first frame.
+	void set_frame_offset(int frame, CL_Point offset);
+	
+	//: Sets an attached id.
+	void set_id(int id);
+	
+	//: Finish animation.
+	//- &lt;p&gt; When an animation is finished, it will no longer show, unless ShowLastFrame is set to anything
+	//- other than show_blank &lt;/p&gt;
+	void finish();
+
+	//: Restart animation.
+	void restart();
+
+	//: Set to true if animation should loop, false otherwise.
+	void set_play_loop(bool loop = true);
+
+	//: Set to true if animation should loop, false otherwise.
+	void set_play_pingpong(bool pingpong = true);
+
+	//: Set to true if animation should go backward (start at end).
+	void set_play_backward(bool backward = true);
+
+	//: Set what is shown when the animation is finished.
+	void set_show_on_finish(CL_Sprite::ShowOnFinish show_on_finish);
+
+	//: Adds a frame to the animation
+	void add_frame(CL_Surface surface, const CL_Rect&amp; rect = CL_Rect(0,0,0,0), float delay = 0.06f, CL_Point offset = CL_Point(0, 0));
+
+//! Signals:
+public:
+	CL_Signal_v0 &amp;sig_animation_finished();
+	
+//! Implementation:
+private:
+	CL_Sprite_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Display/sprite_description.h
===================================================================
--- trunk/clanlib/API/Display/sprite_description.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/sprite_description.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,160 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Sprites&quot;
+//! header=display.h
+
+#ifndef header_sprite_description
+#define header_sprite_description
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4786)
+#endif
+
+#include &lt;string&gt;
+#include &lt;map&gt;
+#include &lt;list&gt;
+
+#include &quot;../Core/Math/rect.h&quot;
+#include &quot;surface.h&quot;
+
+class CL_ResourceManager;
+class CL_PixelBuffer;
+class CL_SpriteDescription_Generic;
+
+//: This class contains everything to construct a sprite - its data, default settings etc.
+//- !group=Display/Sprites!
+//- !header=display.h!
+//- &lt;p&gt;CL_SpriteDescription is used by CL_Sprite to construct itself based
+//- on the description. The description class give a big flexibility
+//- creating a sprite, individual frames can come from different image
+//- sources, or be cut out from an image source using various different
+//- techniques.&lt;/p&gt;
+class CL_API_DISPLAY CL_SpriteDescription
+{ 
+//! Construction:
+public:
+	//: Constructs a sprite description.
+	//param resource_id: Resource name of a sprite description resource.
+	//param resources: Resource manager used to load resource.
+	CL_SpriteDescription(const std::string &amp;resource_id, CL_ResourceManager *resources);
+
+	CL_SpriteDescription();
+
+	CL_SpriteDescription(const CL_SpriteDescription &amp;copy);
+
+	~CL_SpriteDescription();
+
+//! Attributes:
+public:
+	//: CL_PixelBuffer provider, CL_Rect position.
+	typedef std::pair&lt;CL_PixelBuffer, CL_Rect&gt; FramePair;
+
+	//: Returns a list over all available frames.
+	const std::list&lt;FramePair&gt; &amp;get_frames() const;
+
+	//: Returns the surface flag to be used.
+	int get_surface_flag() const;
+
+//! Operations:
+public:
+	//: Copy assignment operator.
+	CL_SpriteDescription &amp;operator =(const CL_SpriteDescription &amp;copy);
+
+	//: Sets what surface flag CL_Sprite should use for its surfaces.
+	void set_surface_flag(int flag);
+
+	//: Adds a single image.
+	//param provider: Image source.
+	//param delete_provider: If true, deletes provider when sprite description is destroyed.
+	void add_frame(CL_PixelBuffer provider);
+
+	//: Adds images formed in a grid.
+	//- &lt;p&gt;This function will cut out a grid of frames from one image.&lt;/p&gt;
+	//param provider: Image source.
+	//param xpos, ypos: Position of where image grid starts.
+	//param width, height: Size of a frame in the grid.
+	//param xarray, yarray: Number of columns and rows in grid.
+	//param array_skipframes: Number of frames to skip at last gridline.
+	//param xspacing, yspacing: Pixel interspacing between grid frames.
+	//param delete_provider: If true, deletes provider when sprite description is destroyed.
+	void add_gridclipped_frames(CL_PixelBuffer provider, int xpos, int ypos, int width, int height, int xarray = 1, int yarray = 1, int array_skipframes = 0, int xspacing = 0, int yspacing = 0);
+
+	//: Adds images separated with pure alpha (within trans_limit).
+	//- &lt;p&gt;The alpha clipper will cut out frames from an image based on
+	//- the transparency in the picture. It first determines the height
+	//- of a row by searching for the first line that it considers
+	//- completely transparent. Then it finds the width of each frame on
+	//- this line by looking for columns that are completely transparency.&lt;/p&gt;
+	//param provider: Image source.
+	//param xpos, ypos: Upper left position where alpha cutting should begin.
+	//param trans_limit: Amount of non-transparent alpha allowed before a pixel is not considered transparent.
+	//param delete_provider: If true, deletes provider when sprite description is destroyed.
+	void add_alphaclipped_frames(CL_PixelBuffer provider, int xpos = 0, int ypos = 0, float trans_limit = 0.05f);
+
+	//: Adds images separated with pure alpha (within trans_limit).
+	//- &lt;p&gt;The alpha clipper will cut out frames from an image based on
+	//- the transparency in the picture. It scans the lines horizontally
+	//- from top to bottom. As soon as a non-transarent pixel is discovered,
+	//- the clipper finds the bounding box for that region and then moves on.&lt;/p&gt;
+	//param provider: Image source.
+	//param xpos, ypos: Upper left position where alpha cutting should begin.
+	//param trans_limit: Amount of non-transparent alpha allowed before a pixel is not considered transparent.
+	//param delete_provider: If true, deletes provider when sprite description is destroyed.
+	void add_alphaclipped_frames_free(CL_PixelBuffer provider, int xpos = 0, int ypos = 0, float trans_limit = 0.05f);
+
+	//: Adds images separated with palette-colours defining the boundaries.
+	//param provider: Image source.
+	//param xpos, ypos: Upper left position where cutting should begin.
+	//param delete_provider: If true, deletes provider when sprite description is destroyed.
+	void add_paletteclipped_frames(CL_PixelBuffer provider, int xpos = 0, int ypos = 0);
+	
+//! Implementation:
+private:
+	//: SpriteDescription implementation.
+	CL_SpriteDescription_Generic *impl;
+};
+
+#endif
+
+

Added: trunk/clanlib/API/Display/sprite_packer.h
===================================================================
--- trunk/clanlib/API/Display/sprite_packer.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/sprite_packer.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,111 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Sprites&quot;
+//! header=display.h
+
+#ifndef header_sprite_packer
+#define header_sprite_packer
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4786)
+#endif
+
+#include &quot;surface.h&quot;
+#include &quot;../Core/Math/size.h&quot;
+#include &quot;../Core/Math/rect.h&quot;
+
+#include &lt;vector&gt;
+
+class CL_SpriteDescription;
+class CL_SpritePacker_Generic;
+
+//: Packs sprite into one or more textures.
+//- !group=Display/Sprites!
+//- !header=display.h!
+class CL_API_DISPLAY CL_SpritePacker
+{ 
+//! Construction:
+public:
+	//: Constructs a CL_SpritePacker.
+	CL_SpritePacker(const CL_SpriteDescription &amp;description);
+
+	~CL_SpritePacker();
+
+//! Attributes:
+public:
+	//: Returns a list over all the textures needed for the packed-frames.
+	//- &lt;p&gt; The get_frames() method returns a list consisting of many TexturePair, where each pair
+	//- has an index into this list. &lt;/p&gt;
+	const std::vector&lt;CL_Size&gt; &amp;get_texture_sizes() const;
+
+	typedef std::pair&lt;int, CL_Rect&gt; TexturePair;	// int texture, CL_Rect frame_position
+	//: Returns a list over all frames - which texture it is packed in and where within the
+	//: texture it is located.
+	//- &lt;p&gt; This list is arranged exactly the same order as the spritedescription frames. &lt;/p&gt;
+	const std::list&lt;TexturePair&gt; &amp;get_frames() const;
+
+//! Operations:
+public:
+	//: Packs all frames into one or more textures.
+	//: Returns false if it was unable to pack all frames.
+	bool pack(
+		int max_width = 256, int max_height = 256,
+		int min_width = 16, int min_height = 16,
+		int max_textures = -1);
+
+//! Implementation:
+private:
+	// Disallow copy construction.
+	CL_SpritePacker(const CL_SpritePacker &amp;copy);
+
+	//: Disallow copy assignment.
+	CL_SpritePacker &amp;operator =(const CL_SpritePacker &amp;copy);
+
+	//: CL_SpritePacker implementation.
+	CL_SpritePacker_Generic *impl;
+};
+
+#endif
+
+

Added: trunk/clanlib/API/Display/stencil_func.h
===================================================================
--- trunk/clanlib/API/Display/stencil_func.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/stencil_func.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,68 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Display 2D&quot;
+//! header=display.h
+
+#ifndef header_stencil_func
+#define header_stencil_func
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+//: Stencil test functions.
+//- !group=Display/Display 2D!
+//- !header=display.h!
+enum CL_StencilFunc
+{
+	stencil_never,
+	stencil_less,
+	stencil_lequal,
+	stencil_greater,
+	stencil_gequal,
+	stencil_equal,
+	stencil_notequal,
+	stencil_always
+};
+
+//: Stencil operations
+//- !group=Display/Display 2D!
+//- !header=display.h!
+enum CL_StencilOp
+{
+	stencil_keep,
+	stencil_zero,
+	stencil_replace,
+	stencil_incr,
+	stencil_decr,
+	stencil_invert
+};
+
+#endif

Added: trunk/clanlib/API/Display/surface.h
===================================================================
--- trunk/clanlib/API/Display/surface.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/surface.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,350 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Display 2D&quot;
+//! header=display.h
+
+#ifndef header_surface
+#define header_surface
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4786)
+#endif
+
+#include &quot;blend_func.h&quot;
+#include &quot;../Core/Math/origin.h&quot;
+#include &quot;color.h&quot;
+#include &lt;string&gt;
+
+#include &quot;../Core/Resources/resource.h&quot;
+#include &quot;pixel_buffer.h&quot;
+
+class CL_GraphicContext;
+class CL_Point;
+class CL_Rect;
+class CL_ResourceManager;
+class CL_Sprite;
+class CL_Surface_Generic;
+class CL_Canvas;
+
+//: Drawing parameters (level 1) for stateless draw of CL_Surface.
+//
+struct CL_Surface_DrawParams1
+{
+		CL_Surface_DrawParams1()
+		{
+			//for compatibility with older code that doesn't know about sub_pixel_accuracy
+			sub_pixel_accuracy = false;
+		}
+	
+	int srcX[4];
+	int srcY[4];
+	double destX[4];
+	double destY[4];
+	double destZ;
+	double red[4];
+	double green[4];
+	double blue[4];
+	double alpha[4];
+	CL_BlendFunc blend_src;
+	CL_BlendFunc blend_dest;
+	CL_BlendFunc blendfunc_src_alpha;
+	CL_BlendFunc blendfunc_dest_alpha;
+	bool sub_pixel_accuracy;
+};
+
+//: Drawing parameters (level 2) for stateless draw of CL_Surface.
+struct CL_Surface_DrawParams2
+{
+	CL_Surface_DrawParams2()
+	{
+		//for compatibility with older code that doesn't know about sub_pixel_accuracy
+		sub_pixel_accuracy = false;
+	}
+
+	int srcX;
+	int srcY;
+	int srcWidth;
+	int srcHeight;
+	double destX;
+	double destY;
+	double destZ;
+	double red;
+	double green;
+	double blue;
+	double alpha;
+	CL_BlendFunc blend_src;
+	CL_BlendFunc blend_dest;
+	CL_BlendFunc blendfunc_src_alpha;
+	CL_BlendFunc blendfunc_dest_alpha;
+	double scale_x;
+	double scale_y;
+	CL_Origin translate_origin;
+	int translate_x;
+	int translate_y;
+	double rotate_angle;
+	double rotate_pitch;
+	double rotate_yaw;
+	CL_Origin rotate_origin;
+	int rotate_x;
+	int rotate_y;
+	bool sub_pixel_accuracy;
+};
+
+//: Construct hardware accelerated (where available) 2D surface.
+//- !group=Display/Display 2D!
+//- !header=display.h!
+// TODO: Add flip_vertical, flip_horizontal ?
+class CL_API_DISPLAY CL_Surface
+{
+//! Enums:
+public:
+	enum Flag
+	{
+		flag_none = 0,
+
+		//: pixelbuffer will be kept around after creation, to be able
+		//: to retrive it with get_pixeldata() without conversion loss.
+		flag_keep_pixelbuffer = 1,
+
+		//: surface will be forced to use 16bit even on 32bit displays.
+		flag_force_16bit = 2
+	};
+
+//! Construction:
+public:
+	//: Constructs a surface.
+	//param provider: Image that surface will use.
+	//param delete_provider: If true, will delete provider after it has copied its image data.
+	//param flag: Flags which affects how surface will be created.
+	//param filename: Name of an image file to load image data from.
+	CL_Surface();
+
+	CL_Surface(
+		CL_PixelBuffer provider,
+		int flag = flag_none);
+
+	CL_Surface(
+		const std::string &amp;resource_id,
+		CL_ResourceManager *manager);
+
+	CL_Surface(const std::string &amp;filename, int flag = flag_none);
+
+	CL_Surface(const CL_Surface &amp;copy);
+
+	virtual ~CL_Surface();
+
+//! Attributes:
+public:
+	//: Returns the width.
+	int get_width() const;
+	
+	//: Returns the height.
+	int get_height() const;
+	
+	//: Returns current angle in degrees.
+	float get_angle() const;
+
+	//: Returns scale for x and y.
+	//- &lt;p&gt; 1.0f is normal scale, 2.0f is twice the size, etc. &lt;/p&gt;
+	void get_scale(float &amp;x, float &amp;y) const;
+
+	//: Returns current alpha.
+	//- &lt;p&gt; Alpha 0.0f is full transparency, and 1.0f is full visibility (solid). &lt;/p&gt;
+	float get_alpha() const;
+
+	//: Returns current color.
+	//- &lt;p&gt; Alpha 0.0f is full transparency, and 1.0f is full visibility (solid). &lt;/p&gt;
+	void get_color(float &amp;red, float &amp;green, float &amp;blue, float &amp;alpha) const;
+	CL_Color get_color() const {float r,g,b,a; get_color(r,g,b,a); return CL_Color(int(r*255.0f),int(g*255.0f),int(b*255.0f),int(a*255.0f));}
+	
+	//: Returns blending functions.
+	void get_blend_func(CL_BlendFunc &amp;src, CL_BlendFunc &amp;dest) const;
+
+	//: Returns translation hotspot.
+	void get_alignment(CL_Origin &amp;origin, int &amp;x, int &amp;y) const;
+
+	//: Returns rotation hotspot.
+	void get_rotation_hotspot(CL_Origin &amp;origin, int &amp;x, int &amp;y) const;
+	
+	//: Returns a pixelbuffer object for accessing surface data.
+	CL_PixelBuffer get_pixeldata() const;
+	
+	//: Resource owning this surface, if any.
+	CL_Resource resource;
+
+//! Operations:
+public:
+	//: Copy assignment operator.
+	CL_Surface &amp;operator =(const CL_Surface &amp;copy);
+
+	//: Return true if the CL_Surface is valid and useable
+	operator bool () const;
+
+	//: Uploads pixel data to surface.
+	//!param pos, x, y: Position on surface where pixel data should be put.
+	//!param src_rect: Part of pixelbuffer that should be uploaded.
+	//!param pixeldata: CL_PixelBuffer containing the image to be uploaded.
+	void set_pixeldata(CL_PixelBuffer &amp;pixeldata);
+	
+	void set_pixeldata(int x, int y, CL_PixelBuffer &amp;pixeldata);
+	
+	void set_pixeldata(const CL_Point &amp;pos, CL_PixelBuffer &amp;pixeldata);
+	
+	void set_pixeldata(const CL_Point &amp;pos, const CL_Rect &amp;src_rect, CL_PixelBuffer &amp;pixeldata);
+
+	//: Stateful draw surface on graphic context.
+	//- &lt;p&gt;These drawing functions will draw the surface on the graphic context, using the attributes on CL_Surface.
+	//- Attributes such as scaling, translate hotspot, rotate hotspot, blend functions, color will be used when
+	//- drawing the surface.&lt;/p&gt;
+	//- Note: The Rectf version automatically sets the sub_pixel_accuracy flag internally.
+	//param x, y: Anchor position of where to render surface. Actual rendering position depends on the anchor and the alignment mode.
+	//param context: Graphic context on which to render upon. If null, will use CL_Display's current graphic context.
+	//param dest: Rectangle to draw surface in.
+	//param src: Rectangle specifying the sub section of a surface to render.
+	
+	void draw(
+		float x = 0,
+		float y = 0,
+		CL_GraphicContext *context = 0);
+
+	void draw(
+		const CL_Rect &amp;dest,
+		CL_GraphicContext *context = 0);
+
+	void draw(
+		const CL_Rect &amp;src,
+		const CL_Rect &amp;dest,
+		CL_GraphicContext *context = 0);
+
+	void draw(
+		const CL_Rectf &amp;src,
+		const CL_Rectf &amp;dest,
+		CL_GraphicContext *context = 0);
+
+	//: Stateless draw surface on graphic context.
+	//- &lt;p&gt;Stateless drawing functions will not use any of the state attributes on CL_Surface. The state attributes
+	//- on CL_Surface are parameters such as scaling, hotspots, blending functions and color. Instead the drawing
+	//- functions take all the parameters it need to perform the render.&lt;/p&gt;
+	//param srcX, srcY, srcWidth, srcHeight: Source rectangle for the surface.
+	//param srcX[4], srcY[4]: Four vertex points used as the source rectangle for the render.
+	//param destX, destY: Destination origin point for render.
+	//param destZ: Depth value for zbuffer when rendering.
+	//param red[4], green[4], blue[4], alpha[4]: Color for each corner of rectangle.
+	//param red, green, blue, alpha: Color for entire rectangle.
+	//param blend_src: Source blend function.
+	//param blend_dest: Destination blend function.
+	//param scale_x, scale_y: Scale values for render.
+	//param translate_origin: Alignment origin.
+	//param translate_x, translate_y: Translate relative to alignment origin.
+	//param rotate_angle: Angle in degrees to rotate the surface in the X-Y direction.
+	//param rotate_pitch: Angle in degrees to rotate the surface in the Y-Z direction.
+	//param rotate_yaw: Angle in degrees to rotate the surface in the X-Z direction.
+	//param rotate_origin: Rotation origin.
+	//param rotate_x, rotate_y: Rotation hotspot relative to rotation origin.
+	//param sub_pixel_accuracy: If true, floating point data isn't truncated and the texture matrix isn't offset (applicable to GL only)
+	//param context: Graphic context on which to render upon. If null, will use CL_Display's current graphic context.
+	void draw(
+		const CL_Surface_DrawParams1&amp; params1,
+		CL_GraphicContext *context = 0);
+
+	void draw(
+		const CL_Surface_DrawParams2&amp; params2,
+		CL_GraphicContext *context = 0);
+
+	//: Set absolute rotation angle in degrees.
+	void set_angle(float angle);
+	
+	//: Set absolute rotation pitch angle in degrees.
+	void set_angle_pitch(float angle);
+	
+	//: Set absolute rotation yaw angle in degrees.
+	void set_angle_yaw(float angle);
+
+	//: Add angle in degrees to current angle.
+	void rotate(float angle);
+	
+	//: Add angle in degrees to current pitch angle.
+	void rotate_pitch(float angle);
+	
+	//: Add angle in degrees to current yaw angle.
+	void rotate_yaw(float angle);
+
+	//: Set scale for x and y directions individually.
+	//- &lt;p&gt; 1.0f is normal scale, 2.0f is twice the size, etc. &lt;/p&gt;
+	void set_scale(float x, float y);
+
+	//: Sets transparency.
+	//- &lt;p&gt; Alpha 0.0f is full transparency, and 1.0f is full visibility (solid). &lt;/p&gt;
+	void set_alpha(float alpha);
+
+	//: Sets the color.
+	//- &lt;p&gt; Alpha 0.0f is full transparency, and 1.0f is full visibility (solid). &lt;/p&gt;
+	void set_color(float r, float g, float b, float a = 1.0f);
+	void set_color(const CL_Color&amp; c) {set_color(float(c.get_red())/255.0f,float(c.get_green())/255.0f,float(c.get_blue())/255.0f,float(c.get_alpha())/255.0f);}
+	
+	//: Sets blending functions.
+	void set_blend_func(CL_BlendFunc src, CL_BlendFunc dest);
+
+	//: Sets blending functions.
+	void set_blend_func_separate(CL_BlendFunc src, CL_BlendFunc dest,
+                                     CL_BlendFunc src_alpha, CL_BlendFunc dest_alpha);
+
+	//: Sets translation hotspot.
+	void set_alignment(CL_Origin origin, int x = 0, int y = 0);
+
+	//: Sets rotation hotspot.
+	void set_rotation_hotspot(CL_Origin origin, int x = 0, int y = 0);
+
+	//  Get the surface handle
+	int get_handle();
+	
+// Implementation:
+protected:
+	CL_Surface_Generic *impl;
+
+	friend class CL_Canvas;
+	friend class CL_GraphicContext;
+};
+
+#endif

Added: trunk/clanlib/API/Display/text_styler.h
===================================================================
--- trunk/clanlib/API/Display/text_styler.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Display/text_styler.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,348 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanDisplay=&quot;Fonts&quot;
+//! header=display.h
+
+#ifndef header_text_styler
+#define header_text_styler
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4786)
+#endif
+
+#include &lt;string&gt;
+#include &lt;map&gt;
+#include &lt;list&gt;
+
+#include &quot;font.h&quot;
+#include &quot;glyph_buffer.h&quot;
+#include &quot;../Core/Math/origin.h&quot;
+#include &quot;../Core/Math/rect.h&quot;
+#include &quot;../Core/Math/point.h&quot;
+#include &quot;../Core/Resources/resource.h&quot;
+
+class CL_GraphicContext;
+class CL_ResourceManager;
+
+//: Draws specially formatted text in one or several fonts.
+//- !group=Display/Fonts!
+//- !header=display.h!
+//- &lt;p&gt; A CL_TextStyler consists of a collection of named CL_Fonts.
+//- When passed a string to draw, it uses vaguely HTMLish tags to select 
+//- which font to draw text in. For example:&lt;/p&gt;
+//- &lt;code&gt; &quot;Here's some text, {italic}isn't it {bold}amazing?{/bold}{/italic}&quot; &lt;/code&gt;
+//- &lt;p&gt; CL_TextStyler does not have any mechanisms on its own for bold
+//- and italic text, so in order for this to work, there must be fonts named 'bold' and
+//- 'italic' that it knows of. Text outside font tags is
+//- drawn in the font named 'default', if it exists. No blending 
+//- or anything like that is performed with nested fonts; the innermost font
+//- is the one used, and the nesting is for convienence.&lt;/p&gt;
+//- &lt;p&gt;There are also special tags which are bounded by [ and ].
+//- These can be used for justification, scaling, color, and newlines.&lt;/p&gt;
+//- &lt;p&gt;Justification can be
+//- either left, center, or right, shown by this example:&lt;/p&gt;
+//- &lt;code&gt; &quot;This line is left justified.\n[j center]This line is center
+//- justified.\n[j right]This line is right justified.\n[/j][/j]Back to
+//- left justification.&quot; &lt;/code&gt;
+//- &lt;p&gt;Scaling tags affect both x and y scaling the same amount when given a single number, but
+//- can be given two numbers to affect both:&lt;/p&gt;
+//- &lt;code&gt; &quot;Regular size.[s 2.0 1.0]Double wide text.[/s][s 1.0 2.0]Double tall text.&quot; &lt;/code&gt;
+//- &lt;p&gt;Scaling tags are also cumulative, as shown by this example:&lt;/p&gt;
+//- &lt;code&gt; &quot;This text is at regular size.[s 2.0]This text is at double size.[s 2.0]This text is at quadruple
+//- size.[/s]Double size again.[/s]Regular size again.&quot; &lt;/code&gt;
+//- &lt;p&gt;Color tags allow specification of RGB and RGBA values, as well as use of named colors (see CL_Color's
+//- documentation for a reference). The color overrides the font's existing color entirely, and does not blend
+//- with it. Be sure that the blending functions of a font are set properly before using that font in a TextStyler
+//- with color tags.&lt;/p&gt;
+//- &lt;code&gt; &quot;This text is in whatever the font's default color is.[c blue]This text is blue.[c red]This text
+//- is red, not blue-red; there's no blending between nested colors.[/c][/c][c 0 255 0]This text is green.[/c]
+//- [c 255 0 255 175]This text is translucent purple; the fourth number is the alpha value, which
+//- is set to opaque (255) if unspecified.[/c]&quot; &lt;/code&gt;
+//- &lt;p&gt;Newline tags are only helpful when loading TextStyler-intented strings from XML resource
+//- files, where there's no easy way to insert an actual newline character:&lt;/p&gt;
+//- &lt;code&gt; &quot;First line.[n]Second line.&quot; &lt;/code&gt;
+//- &lt;p&gt;To draw a real a left brace or left square bracket and not start a tag, just escape it by putting two
+//- of the characters in a row; right braces and right square brackets don't need to be escaped,
+//- and CL_TextStyler will take them literally if they don't seem to end an open tag. References to fonts which are
+//- not in the CL_TextStyler's font map will be silently ignored. Using bad nesting order is
+//- also allowed (i.e. {a}{b}{/a}{/b}). However, you can't have a partial tag in the string
+//- (that is, &quot;blah blah {tag doesnt end&quot;), and you are not allowed to
+//- put any of the four tag opening/closing characters inside a tag, or in
+//- a font name, even if they're escaped. &lt;/p&gt;
+//- &lt;p&gt;Like with CL_Font, scaling affects the calculation
+//- of any bounding rectangles (such as the result returned
+//- by draw() or bounding_rect(), or the rectangle calculated internally by
+//- draw() for alignment). This is because scaling
+//- the CL_TextStyler is effectively just changing the point size of the glyphs,
+//- and that affects all sorts of things, such as word wrapping.&lt;/p&gt;
+
+class CL_API_DISPLAY CL_TextStyler
+{
+//! Construction:
+public:
+	//: Constructs a text styler.
+	CL_TextStyler();
+	CL_TextStyler(const CL_TextStyler&amp; other);
+	CL_TextStyler(
+		const std::string &amp;resource_id,
+		CL_ResourceManager *manager);
+	
+	//: Destruction
+	virtual ~CL_TextStyler() {resource.unload();}
+
+//! Attributes:
+public:
+	//: Returns a reference to the font map.
+	std::map&lt;std::string, CL_Font&gt;&amp; get_fonts()
+		{return fonts;}
+	const std::map&lt;std::string, CL_Font&gt;&amp; get_fonts() const
+		{return fonts;}
+	
+	//: Returns scale for x and y.
+	//- &lt;p&gt; 1.0f is normal scale, 2.0f is twice the size, etc. &lt;/p&gt;
+	void get_scale(float &amp;x, float &amp;y) const
+		{x = scale_x, y = scale_y;}
+	
+	//: Returns translation hotspot.
+	void get_alignment(CL_Origin &amp;origin, int &amp;x, int &amp;y) const
+		{origin = trans_origin; x = trans_x; y = trans_y;}
+	
+	//: Returns the drawn height of some source text, or of the default font if no arguments passed.
+	//return: The height in pixels.
+	//param str: The source string to parse and render.
+	//param start: A starting iterator, inclusive.
+	//param end: An ending iterator, exclusive.
+	//param max_size: Acts like the size of a dest rectangle passed to draw(), for height truncating and word wrapping.
+	//- &lt;p&gt; Generally, get_height(&quot; &quot;) will return zero, since usually 
+	//- the space glyph isn't given in the font, and so it has a height and width of zero. 
+	//- Calling get_height() on a CL_TextStyler without arguments is the same as calling
+	//- get_height() without arguments on that CL_TextStyler's default font.&lt;/p&gt;
+	int get_height() const;
+	
+	int get_height(
+		const std::string &amp;str,
+		CL_Size max_size = CL_Size(0,0)) const
+		{return get_size(str, max_size).height;}
+	
+	int get_height(
+		std::string::const_iterator start,
+		std::string::const_iterator end,
+		CL_Size max_size = CL_Size(0,0)) const
+		{return get_size(start, end, max_size).height;}
+	
+	//: Returns the drawn width of some source text.
+	//return: The width in pixels.
+	//param str: The source string to parse and render.
+	//param start: A starting iterator, inclusive.
+	//param end: An ending iterator, exclusive.
+	//param max_size: Acts like the size of a dest rectangle passed to draw(), for height truncating and word wrapping.
+	//- &lt;p&gt;Newlines have a width of zero unless you gave them a glyph (which is pretty useless anyways).
+	//- Other unknown characters have the width of a space in their respective font.&lt;/p&gt;
+	int get_width(
+		const std::string &amp;str,
+		CL_Size max_size = CL_Size(0,0)) const
+		{return get_size(str, max_size).width;}
+	
+	int get_width(
+		std::string::const_iterator start,
+		std::string::const_iterator end,
+		CL_Size max_size = CL_Size(0,0)) const
+		{return get_size(start, end, max_size).width;}
+	
+	//: Returns the drawn size of some source text.
+	//return: The size in pixels.
+	//param str: The source string to parse and render.
+	//param start: A starting iterator, inclusive.
+	//param end: An ending iterator, exclusive.
+	//param max_size: Acts like the size of a dest rectangle passed to draw(), for height truncating and word wrapping.
+	//- &lt;p&gt;Newlines have a width of zero unless you gave them a glyph (which is pretty useless anyways).
+	//- Other unknown characters have the width of a space in their respective font.&lt;/p&gt;
+	CL_Size get_size(
+		const std::string &amp;str,
+		CL_Size max_size = CL_Size(0,0)) const
+		{return get_size(str.begin(), str.end(), max_size);}
+	
+	CL_Size get_size(
+		std::string::const_iterator start,
+		std::string::const_iterator end,
+		CL_Size max_size = CL_Size(0,0)) const;
+	
+	//: Calculate the rectangle that would be occupied by a draw operation.
+	//param x, y: Anchor position of where to render text. Actual rendering position depends on the alignment mode.
+	//param dest: Rectangle to draw text in. The text will be word-wrapped against delimiters to fit inside the rectangle.
+	//param str: The source string to parse and render.
+	//param start: String position to begin rendering at, inclusive.
+	//param end: String position to end rendering at, exclusive.
+	//- &lt;p&gt; You can specify a dest rectangle with a width or height of zero or less to disable word wrapping
+	//- or height truncating, respectively. &lt;/p&gt;
+	//- &lt;p&gt; It's more efficient to draw text into a GlyphBuffer, then use that for drawing and bounding
+	//- rect calculation. This method is just for convienence. &lt;/p&gt;
+	CL_Rect bounding_rect(
+		int x,
+		int y,
+		const std::string&amp; str) const
+		{return bounding_rect(CL_Rect(x, y, x, y), str.begin(), str.end());}
+	
+	CL_Rect bounding_rect(
+		CL_Rect dest,
+		const std::string&amp; str) const
+		{return bounding_rect(dest, str.begin(), str.end());}
+	
+	CL_Rect bounding_rect(
+		int x,
+		int y,
+		std::string::const_iterator start,
+		std::string::const_iterator end) const
+		{return bounding_rect(CL_Rect(x, y, x, y), start, end);}
+	
+	CL_Rect bounding_rect(
+		CL_Rect dest,
+		std::string::const_iterator start,
+		std::string::const_iterator end) const;
+	
+	//: Resource owning this text styler, if any.
+	CL_Resource resource;
+
+//! Operations:
+public:
+	//: Copy assignment
+	CL_TextStyler&amp; operator=(const CL_TextStyler&amp; other);
+	
+	//: Adds a new font to the map
+	void add_font(std::string name, const CL_Font&amp; font)
+		{fonts.insert(std::pair&lt;std::string, CL_Font&gt;(name, font));}
+	
+	//: Draws text onto a graphics context.
+	//return: The number of glyphs that were drawn.
+	//param x, y: Anchor position of where to draw at. Actual rendering position depends on the alignment mode.
+	//param dest: Rectangle to draw text in. The text will be word-wrapped against delimiters to fit inside the rectangle.
+	//param str: The source string to parse and render.
+	//param start: String position to begin rendering at, inclusive.
+	//param end: String position to end rendering at, exclusive.
+	//param context: Graphic context on which to render upon. If null, will use CL_Display's current graphic context.
+	//- &lt;p&gt; You can specify a dest rectangle with a width or height of zero or less to disable word wrapping
+	//- or height truncating, respectively. &lt;/p&gt;
+	int draw(
+		int x,
+		int y,
+		const std::string&amp; str,
+		CL_GraphicContext *context = 0) const
+		{return draw(CL_Rect(x, y, x, y), str.begin(), str.end(), context);}
+	
+	int draw(
+		CL_Rect dest,
+		const std::string&amp; str,
+		CL_GraphicContext *context = 0) const
+		{return draw(dest, str.begin(), str.end(), context);}
+	
+	int draw(
+		int x,
+		int y,
+		std::string::const_iterator start,
+		std::string::const_iterator end,
+		CL_GraphicContext *context = 0) const
+		{return draw(CL_Rect(x, y, x, y), start, end, context);}
+	
+	int draw(
+		CL_Rect dest,
+		std::string::const_iterator start,
+		std::string::const_iterator end,
+		CL_GraphicContext *context = 0) const;
+	
+	//: Inserts data into a CL_GlyphBuffer, treating the glyphs already there as part of a previous draw_to_gb().
+	//return: The number of glyphs that were drawn.
+	//param str: The input string to draw.
+	//param start: String position to begin drawing at, inclusive.
+	//param end: String position to end drawing at, exclusive.
+	//param max_size: Sets size for word wrapping and height truncating. Either can be zero to disable that feature.
+	//param gb: The glyph buffer to mess with.
+	//- &lt;p&gt; The CL_GlyphBuffer's contents (the glyphs vector, the font markers map, and the effects maps),
+	//- if any, must not have been created/altered by anything but CL_Font::draw_to_gb() and/or CL_TextStyler::draw_to_gb()
+	//- for this method to work.&lt;/p&gt;
+	//- &lt;p&gt; If you are doing draw_to_gb several sequential times
+	//- to the same CL_GlyphBuffer, then you must pass the same maximum width to each call of
+	//- draw_to_gb. &lt;/p&gt;
+	//- &lt;p&gt; You can tell when you've filled the buffer up to the height in max_size when a call to this method returns
+	//- anything less than the size of the string. There's also the chance that it will backtrack and return
+	//- a negative value if it runs out
+	//- of vertical space in the process of wrapping a just-completed word; this is still a sign that you've
+	//- ran out of vertical space.&lt;/p&gt;
+	//- &lt;p&gt; Scale tags create new font markers in the GB, they don't use the GB scale effects map. &lt;/p&gt;
+	int draw_to_gb(
+		const std::string &amp;str,
+		CL_GlyphBuffer &amp;gb,
+		CL_Size max_size = CL_Size(0,0)) const
+		{return draw_to_gb(str.begin(), str.end(), gb, max_size);}
+	
+	int draw_to_gb(
+		std::string::const_iterator start,
+		std::string::const_iterator end,
+		CL_GlyphBuffer &amp;gb,
+		CL_Size max_size = CL_Size(0,0)) const;
+	
+	//: Set scale for x and y directions individually.
+	//- &lt;p&gt; 1.0f is normal scale, 2.0f is twice the size, etc. &lt;/p&gt;
+	void set_scale(float x, float y)
+		{scale_x = x; scale_y = y;}
+	
+	//: Sets translation hotspot.
+	void set_alignment(CL_Origin origin, int x = 0, int y = 0)
+		{trans_origin = origin; trans_x = x; trans_y = y;}
+	
+// Implementation:
+private:
+	//: Scale.
+	float scale_x;
+	float scale_y;
+	
+	//: Alignment.
+	CL_Origin trans_origin;
+	int trans_x;
+	int trans_y;
+	
+	//: The font map.
+	std::map&lt;std::string, CL_Font&gt; fonts;
+};
+
+#endif

Added: trunk/clanlib/API/GL/light_source.h
===================================================================
--- trunk/clanlib/API/GL/light_source.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GL/light_source.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,186 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGL=&quot;Display 3D&quot;
+//! header=gl.h
+
+#ifndef header_light_source
+#define header_light_source
+
+#ifdef CL_API_DLL
+#ifdef CL_GL_EXPORT
+#define CL_API_GL __declspec(dllexport)
+#else
+#define CL_API_GL __declspec(dllimport)
+#endif
+#else
+#define CL_API_GL
+#endif
+
+#include &quot;viewpoint.h&quot;
+#include &quot;opengl.h&quot;
+
+//: OpenGL glLight container.
+//- !group=GL/Display 3D!
+//- !header=gl.h!
+class CL_API_GL CL_LightSource
+{
+//! Construction:
+public:
+	//: Constructs a light source container.
+	CL_LightSource();
+
+	~CL_LightSource();
+
+//! Attributes:
+public:
+	//: Returns the intensity distribution of the light.
+	//- &lt;p&gt;Only values in the range [0,128] are accepted. The default spot exponent is 0,
+	//- resulting in uniform light distribution.&lt;/p&gt;
+	float get_spot_exponent() const;
+
+	//: Returns the spot cutoff angle (the maximum spread angle of a light source).
+	//- &lt;p&gt;The default spot cutoff is 180, resulting in uniform light distribution.&lt;/p&gt;
+	float get_spot_cutoff() const;
+
+	//: Returns constant attenuation of the light.
+	//- &lt;p&gt;The default attenuation factors are (1,0,0), resulting in no attenuation.&lt;/p&gt;
+	float get_constant_attenuation() const;
+
+	//: Returns linear attenuation of the light.
+	//- &lt;p&gt;The default attenuation factors are (1,0,0), resulting in no attenuation.&lt;/p&gt;
+	float get_linear_attenuation() const;
+
+	//: Returns quadratic attenuation of the light.
+	//- &lt;p&gt;The default attenuation factors are (1,0,0), resulting in no attenuation.&lt;/p&gt;
+	float get_quadratic_attenuation() const;
+
+	//: Returns the ambient (global light) intensity of the light.
+	void get_ambient_intensity(float &amp;red, float &amp;green, float &amp;blue, float &amp;alpha) const;
+
+	//: Returns the diffuse (spread over wide area) intensity of the light.
+	void get_diffuse_intensity(float &amp;red, float &amp;green, float &amp;blue, float &amp;alpha) const;
+
+	//: Returns the specular (mirror reflective) intensity of the light.
+	void get_specular_intensity(float &amp;red, float &amp;green, float &amp;blue, float &amp;alpha) const;
+
+	//: Returns the light position.
+	CL_Vector get_position() const;
+
+	//: Returns the light spot direction.
+	CL_Vector get_spot_direction() const;
+
+//! Operations:
+public:
+	//: Sets the intensity distribution of the light.
+	//- &lt;p&gt;Only values in the range [0,128] are accepted. The default spot exponent is 0,
+	//- resulting in uniform light distribution.&lt;/p&gt;
+	void set_spot_exponent(float spot_exponent);
+
+	//: Sets the spot cutoff angle (the maximum spread angle of a light source).
+	//- &lt;p&gt;The default spot cutoff is 180, resulting in uniform light distribution.&lt;/p&gt;
+	void set_spot_cutoff(float spot_cutoff);
+
+	//: Sets the constant attenuation of the light.
+	//- &lt;p&gt;The default attenuation factors are (1,0,0), resulting in no attenuation.&lt;/p&gt;
+	void set_constant_attenuation(float constant_attenuation);
+
+	//: Sets linear attenuation of the light.
+	//- &lt;p&gt;The default attenuation factors are (1,0,0), resulting in no attenuation.&lt;/p&gt;
+	void set_linear_attenuation(float linear_attenuation);
+
+	//: Sets quadratic attenuation of the light.
+	//- &lt;p&gt;The default attenuation factors are (1,0,0), resulting in no attenuation.&lt;/p&gt;
+	void set_quadratic_attenuation(float quadratic_attenuation);
+
+	//: Sets the ambient (global light) intensity of the light.
+	void set_ambient_intensity(float red, float green, float blue, float alpha = 1.0f);
+
+	//: Sets the diffuse (spread over wide area) intensity of the light.
+	void set_diffuse_intensity(float red, float green, float blue, float alpha = 1.0f);
+
+	//: Sets the specular (mirror reflective) intensity of the light.
+	void set_specular_intensity(float red, float green, float blue, float alpha = 1.0f);
+
+	//: Sets the light position.
+	//- &lt;p&gt;The position is transformed by the modelview matrix when glLight is called
+	//- (just as if it were a point), and it is stored in eye coordinates. If the w
+	//- component of the position is 0.0, the light is treated as a directional source.&lt;/p&gt;
+	//- &lt;p&gt;Diffuse and specular lighting calculations take the lights direction, but not
+	//- its actual position, into account, and attenuation is disabled. Otherwise, diffuse
+	//- and specular lighting calculations are based on the actual location of the light
+	//- in eye coordinates, and attenuation is enabled.&lt;/p&gt;
+	//- &lt;p&gt;The default position is (0,0,1,0); thus, the default light source is directional,
+	//- parallel to, and in the direction of the &#150;z axis.&lt;/p&gt;
+	void set_position(const CL_Vector &amp;position);
+
+	//: Sets the light spot direction.
+	void set_spot_direction(const CL_Vector &amp;spot_direction);
+
+	//: Sets position and spot direction as a viewpoint.
+	//- &lt;p&gt;The position is transformed by the modelview matrix when glLight is called
+	//- (just as if it were a point), and it is stored in eye coordinates. If the w
+	//- component of the position is 0.0, the light is treated as a directional source.&lt;/p&gt;
+	//- &lt;p&gt;Diffuse and specular lighting calculations take the lights direction, but not
+	//- its actual position, into account, and attenuation is disabled. Otherwise, diffuse
+	//- and specular lighting calculations are based on the actual location of the light
+	//- in eye coordinates, and attenuation is enabled.&lt;/p&gt;
+	//- &lt;p&gt;The default position is (0,0,1,0); thus, the default light source is directional,
+	//- parallel to, and in the direction of the &#150;z axis.&lt;/p&gt;
+	void set_viewpoint(const CL_Viewpoint &amp;viewpoint);
+
+	//: Sends the light configuration to OpenGL.
+	//param light_identifier: OpenGL light identifier to be setup for this light.
+	//param light_identifier: They are identified by symbolic names of the form CL_LIGHTi.
+	void setup_light(CLenum light_identifier);
+
+//! Implementation:
+private:
+	float spot_exponent;
+
+	float spot_cutoff;
+
+	float constant_attenuation;
+
+	float linear_attenuation;
+
+	float quadratic_attenuation;
+
+	float ambient[4];
+
+	float diffuse[4];
+
+	float specular[4];
+
+	CL_Vector position;
+
+	CL_Vector spot_direction;
+};
+
+#endif

Added: trunk/clanlib/API/GL/material.h
===================================================================
--- trunk/clanlib/API/GL/material.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GL/material.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,112 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGL=&quot;Display 3D&quot;
+//! header=gl.h
+
+#ifndef header_material
+#define header_material
+
+#ifdef CL_API_DLL
+#ifdef CL_GL_EXPORT
+#define CL_API_GL __declspec(dllexport)
+#else
+#define CL_API_GL __declspec(dllimport)
+#endif
+#else
+#define CL_API_GL
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Core/System/sharedptr.h&quot;
+
+class CL_Material_Generic;
+
+//: glMaterial container.
+class CL_API_GL CL_Material
+{
+//! Construction:
+public:
+	//: Constructs a material.
+	CL_Material();
+
+	~CL_Material();
+
+//! Attributes:
+public:
+	//: Returns the ambient intensity of the material.
+	void get_ambient(float &amp;red, float &amp;green, float &amp;blue, float &amp;alpha) const;
+
+	//: Returns the diffuse (spread over wide area) intensity of the material.
+	void get_diffuse(float &amp;red, float &amp;green, float &amp;blue, float &amp;alpha) const;
+
+	//: Returns the specular (mirror reflective) intensity of the material.
+	void get_specular(float &amp;red, float &amp;green, float &amp;blue, float &amp;alpha) const;
+
+	//: Returns the combined ambient and diffuse intensity of the material.
+	void get_ambient_and_diffuse(float &amp;red, float &amp;green, float &amp;blue, float &amp;alpha) const;
+
+	//: Returns the emission of the material.
+	void get_emission(float &amp;red, float &amp;green, float &amp;blue, float &amp;alpha) const;
+
+	//: Returns the shininess of the material.
+	float get_shininess() const;
+
+//! Operations:
+public:
+	//: Set the ambient intensity of the material.
+	void set_ambient(float red, float green, float blue, float alpha);
+
+	//: Set the diffuse (spread over wide area) intensity of the material.
+	void set_diffuse(float red, float green, float blue, float alpha);
+
+	//: Set the specular (mirror reflective) intensity of the material.
+	void set_specular(float red, float green, float blue, float alpha);
+
+	//: Set the combined ambient and diffuse intensity of the material.
+	void set_ambient_and_diffuse(float red, float green, float blue, float alpha);
+
+	//: Set the emission of the material.
+	void set_emission(float red, float green, float blue, float alpha);
+
+	//: Set the shininess of the material.
+	void set_shininess(float value);
+
+	//: Send the material configuration to OpenGL.
+	void setup_material(CLenum face);
+
+//! Implementation:
+private:
+	CL_SharedPtr&lt;CL_Material_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/GL/opengl.h
===================================================================
--- trunk/clanlib/API/GL/opengl.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GL/opengl.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,131 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGL=&quot;System&quot;
+//! header=gl.h
+
+#ifndef header_opengl
+#define header_opengl
+
+#ifdef CL_API_DLL
+#ifdef CL_GL_EXPORT
+#define CL_API_GL __declspec(dllexport)
+#else
+#define CL_API_GL __declspec(dllimport)
+#endif
+#else
+#define CL_API_GL
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+#include &lt;utility&gt;
+#include &quot;../Display/pixel_format.h&quot;
+
+class CL_GLFunctions;
+
+//: Extension procedure address typedef for OpenGL.
+typedef void (CL_ProcAddress)();
+
+#ifndef __APPLE__
+typedef unsigned int CLenum;
+typedef unsigned char CLboolean;
+typedef unsigned int CLbitfield;
+typedef signed char CLbyte;
+typedef short CLshort;
+typedef int CLint;
+typedef int CLsizei;
+typedef unsigned char CLubyte;
+typedef unsigned short CLushort;
+typedef unsigned int CLuint;
+typedef float CLfloat;
+typedef float CLclampf;
+typedef double CLdouble;
+typedef double CLclampd;
+typedef void CLvoid;
+typedef char CLchar;
+typedef long int CLsizeiptr;
+typedef long int CLintptr;
+#else
+typedef unsigned long CLenum;
+typedef unsigned char CLboolean;
+typedef unsigned long CLbitfield;
+typedef signed char CLbyte;
+typedef short CLshort;
+typedef long CLint;
+typedef long CLsizei;
+typedef unsigned char CLubyte;
+typedef unsigned short CLushort;
+typedef unsigned long CLuint;
+typedef float CLfloat;
+typedef float CLclampf;
+typedef double CLdouble;
+typedef double CLclampd;
+typedef void CLvoid;
+typedef char CLchar;
+#if defined(_WIN64)
+typedef __int64 GLintptr;
+typedef __int64 GLsizeiptr
+#elif defined(__ia64__) || defined(__x86_64__)
+typedef long int GLintptr;
+typedef long int GLsizeiptr;
+#else
+typedef int CLsizeiptr;
+typedef int CLintptr;
+#endif
+#endif
+
+//: OpenGL utility class.
+//- !group=GL/System!
+//- !header=gl.h!
+class CL_API_GL CL_OpenGL
+{
+//! Attributes:
+public:
+	//: Get OpenGL extension specific function address.
+	static CL_ProcAddress *get_proc_address(const std::string &amp;function_name);
+
+	//: Function table for OpenGL 2.0.
+	static CL_GLFunctions *functions;
+
+	//: Get a pixel format out of an OpenGL format.
+	//- &lt;p&gt;The function returns false if it can't convert format, otherwise the
+	//- the formatare returned with values in pf.&lt;/p&gt;
+	static bool from_opengl_pixelformat(CLenum format, CLenum type, CL_PixelFormat &amp;pf);
+
+	//: Get a OpenGL format out of a pixel format.
+	//- &lt;p&gt;The function returns false if pixelformat color depth is not convertible to 
+	//- OpenGL pixel format, otherwise the format and type are returned with values in format and type.&lt;/p&gt;
+	static bool to_opengl_pixelformat(const CL_PixelFormat &amp;pf, CLenum &amp;format, CLenum &amp;type);
+};
+
+#endif

Added: trunk/clanlib/API/GL/opengl_state.h
===================================================================
--- trunk/clanlib/API/GL/opengl_state.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GL/opengl_state.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,105 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGL=&quot;System&quot;
+//! header=gl.h
+
+#ifndef header_opengl_state
+#define header_opengl_state
+
+#ifdef CL_API_DLL
+#ifdef CL_GL_EXPORT
+#define CL_API_GL __declspec(dllexport)
+#else
+#define CL_API_GL __declspec(dllimport)
+#endif
+#else
+#define CL_API_GL
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Core/System/sharedptr.h&quot;
+
+class CL_GraphicContext;
+class CL_GraphicContext_OpenGL;
+class CL_OpenGLStateData;
+class CL_OpenGLState_Generic;
+class CL_GLStateChecker;
+
+//: OpenGL state setup handler class.
+//- !group=GL/System!
+//- !header=gl.h!
+class CL_API_GL CL_OpenGLState
+{
+//! Construction:
+public:
+	//: Constructs an opengl state set.
+	CL_OpenGLState();
+
+	CL_OpenGLState(CL_GraphicContext *gc);
+
+	CL_OpenGLState(const CL_OpenGLState &amp;copy);
+
+	~CL_OpenGLState();
+
+//! Attributes:
+public:
+	//: Returns true if opengl state is currently active.
+	bool is_active() const;
+
+//! Operations:
+public:
+	//: Activates this OpenGL state set.
+	void set_active();
+
+	//: Attaches a new data object responsible for saving and restoring states.
+	void attach_data(CL_OpenGLStateData *data, bool delete_data = false);
+
+	//: Detaches a data object.
+	void detach_data(CL_OpenGLStateData *data);
+
+	//: Setup window 2D rendering mode.
+	//param upside_down: If set to true, (0,0) will be in the lower left corner.
+	//- &lt;p&gt; This effectively loads a Orto 2D projection matrix and makes sure
+	//- the device are using sane texture parameter values.&lt;/p&gt;
+	void setup_2d(bool upside_down = false);
+
+//! Implementation:
+private:
+	CL_OpenGLState(CL_GraphicContext_OpenGL *gc_opengl);
+
+	CL_SharedPtr&lt;CL_OpenGLState_Generic&gt; impl;
+
+	friend class CL_GLStateChecker;
+};
+
+#endif

Added: trunk/clanlib/API/GL/opengl_state_data.h
===================================================================
--- trunk/clanlib/API/GL/opengl_state_data.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GL/opengl_state_data.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,75 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGL=&quot;System&quot;
+//! header=gl.h
+
+#ifndef header_opengl_state_data
+#define header_opengl_state_data
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+class CL_OpenGLStateData_Generic;
+
+//: OpenGL state worker; responsible for saving and restoring states.
+//- !group=GL/System!
+//- !header=gl.h!
+class CL_OpenGLStateData
+{
+//! Construction:
+public:
+	CL_OpenGLStateData();
+
+	virtual ~CL_OpenGLStateData();
+
+//! Attributes:
+public:
+
+//! Operations:
+public:
+	//: Save state information needed to restore this OpenGL state.
+	virtual void on_save()=0;
+
+	//: Load state information and setup OpenGL to this state.
+	virtual void on_load()=0;
+
+	//: Flush current rendering batch.
+	//- &lt;p&gt;This is a hint from clanDisplay that it needs to perform some state changes.
+	//- Usually this happens if translate, viewport or scissor needs updating.&lt;/p&gt;
+	//- &lt;p&gt;Internally ClanLib uses this to end any open glBegin render batches.&lt;/p&gt;
+	virtual void on_flush()=0;
+
+//! Implementation:
+private:
+	CL_OpenGLStateData_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/GL/opengl_surface.h
===================================================================
--- trunk/clanlib/API/GL/opengl_surface.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GL/opengl_surface.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,88 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGL=&quot;Display 2D&quot;
+//! header=gl.h
+
+#ifndef header_opengl_surface
+#define header_opengl_surface
+
+#ifdef CL_API_DLL
+#ifdef CL_GL_EXPORT
+#define CL_API_GL __declspec(dllexport)
+#else
+#define CL_API_GL __declspec(dllimport)
+#endif
+#else
+#define CL_API_GL
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Display/surface.h&quot;
+
+//: OpenGL surface.
+//- !group=GL/Display 2D!
+//- !header=gl.h!
+class CL_API_GL CL_OpenGLSurface : public CL_Surface
+{
+//! Construction:
+public:
+	//: Constructs an opengl surface.
+	CL_OpenGLSurface();
+	
+	CL_OpenGLSurface(const CL_Surface &amp;copy);
+	
+	CL_OpenGLSurface(
+		CL_PixelBuffer provider,
+		int flag = flag_none);
+
+	CL_OpenGLSurface(
+		const std::string &amp;resource_id,
+		CL_ResourceManager *manager);
+
+	CL_OpenGLSurface(const std::string &amp;filename, int flag = flag_none);
+
+	virtual ~CL_OpenGLSurface();
+
+//! Attributes:
+public:
+
+//! Operations:
+public:
+	//: Bind surface texture in OpenGL.
+	void bind();
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/API/GL/opengl_window.h
===================================================================
--- trunk/clanlib/API/GL/opengl_window.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GL/opengl_window.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,112 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGL=&quot;Display 2D&quot;
+//! header=gl.h
+
+#ifndef header_opengl_window
+#define header_opengl_window
+
+#ifdef CL_API_DLL
+#ifdef CL_GL_EXPORT
+#define CL_API_GL __declspec(dllexport)
+#else
+#define CL_API_GL __declspec(dllimport)
+#endif
+#else
+#define CL_API_GL
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Display/display_window.h&quot;
+
+#ifdef WIN32
+#include &lt;windows.h&gt;
+#else
+#ifndef __APPLE__
+#include &lt;X11/Xlib.h&gt;
+#endif
+#endif
+
+//: OpenGL top level window.
+//- !group=GL/Display 2D!
+//- !header=gl.h!
+class CL_API_GL CL_OpenGLWindow : public CL_DisplayWindow
+{
+//! Construction:
+public:
+	//: Constructs an opengl window.
+	//param title: Titlebar text.
+	//param width, height: Size of window, in pixels.
+	//param start_fullscreen: If true, window will go full screen.
+	//param allow_resize: If true, window will have resize grabbers.
+	//param flipping_buffer: Amount of buffers in flipping system.
+	CL_OpenGLWindow();
+
+	CL_OpenGLWindow(const CL_OpenGLWindow &amp;copy);
+
+	CL_OpenGLWindow(
+		const std::string &amp;title,
+		int width,
+		int height,
+		bool start_fullscreen = false,
+		bool allow_resize = false,
+		int flipping_buffers = 2);
+
+	~CL_OpenGLWindow();
+
+//! Attributes:
+public:
+#ifdef WIN32
+	//: Returns the Win32 OpenGL resource context.
+	HGLRC get_context();
+
+	//: Returns the Win32 device context handle.
+	HDC get_dc();
+
+	//: Returns the Win32 window handle.
+	HWND get_wnd();
+#else
+#ifndef __APPLE__
+	//: Retuens the X11 display handle.
+	Display *get_wnd();
+#endif
+#endif
+
+//! Operations:
+public:
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/API/GL/opengl_window_description.h
===================================================================
--- trunk/clanlib/API/GL/opengl_window_description.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GL/opengl_window_description.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,217 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGL=&quot;Display 2D&quot;
+//! header=gl.h
+
+#ifndef header_opengl_window_description
+#define header_opengl_window_description
+
+#ifdef CL_API_DLL
+#ifdef CL_GL_EXPORT
+#define CL_API_GL __declspec(dllexport)
+#else
+#define CL_API_GL __declspec(dllimport)
+#endif
+#else
+#define CL_API_GL
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Display/display_window_description.h&quot;
+
+class CL_OpenGLWindowDescription_Generic;
+
+//: OpenGL specific display window description.
+//- !group=GL/Display 2D!
+//- !header=gl.h!
+//- &lt;p&gt;Use this class to setup OpenGL specific settings for a top level
+//- window:&lt;/p&gt;
+//- &lt;pre&gt;
+//- CL_OpenGLWindowDescription desc;
+//- dest.set_title(&quot;OpenGL window with stereo visual&quot;);
+//- desc.set_stereo(true);
+//- desc.set_stencil_size(4);
+//- CL_DisplayWindow window(desc);
+//- &lt;/pre&gt;
+class CL_API_GL CL_OpenGLWindowDescription : public CL_DisplayWindowDescription
+{
+//! Construction:
+public:
+	//: Constructs a window description with default values.
+	CL_OpenGLWindowDescription();
+
+	virtual ~CL_OpenGLWindowDescription();
+
+//! Attributes:
+public:
+	//: Returns true if only TrueColor and DirectColor visuals are considered.
+	//- &lt;p&gt;If not enabled, only PseudoColor and StaticColor visuals are considered.&lt;/p&gt;
+	bool get_rgba() const;
+
+	//: Returns true if only double-buffered visuals are considered.
+	//- &lt;p&gt;If not enabled, only single-buffered visuals are considered.&lt;/p&gt;
+	bool get_doublebuffer() const;
+
+	//: Returns true if only stereo visuals are considered.
+	//- &lt;p&gt;If not enabled, only monoscopic visuals are considered.&lt;/p&gt;
+	bool get_stereo() const;
+
+	//: Returns the desired color index buffer size.
+	//- &lt;p&gt;Ignored in GLX (X11) if the RGBA flag is set.&lt;/p&gt;
+	//- &lt;p&gt;In WGL (Windows) it specifies the size of the color buffer, excluding the alpha bitplanes.&lt;/p&gt;
+	int get_buffer_size() const;
+
+	//: Returns the required buffer level.
+	//- &lt;p&gt;Buffer level zero corresponds to the main frame buffer of the display. Buffer
+	//- level one is the first overlay frame buffer, level two the second overlay frame
+	//- buffer, and so on. Negative buffer levels correspond to underlay frame buffers.&lt;/p&gt;
+	int get_level() const;
+
+	//: Returns the desired number of auxilary buffers.
+	int get_aux_buffers() const;
+
+	//: Returns the minimum required red buffer.
+	int get_red_size() const;
+
+	//: Returns the minimum required green buffer.
+	int get_green_size() const;
+
+	//: Returns the minimum required blue buffer.
+	int get_blue_size() const;
+
+	//: Returns the minimum required alpha buffer.
+	int get_alpha_size() const;
+
+	//: Returns the minimum required depth buffer.
+	int get_depth_size() const;
+
+	//: Returns the minimum required stencil buffer.
+	int get_stencil_size() const;
+
+	//: Returns the minimum required red accumulation buffer.
+	int get_accum_red_size() const;
+
+	//: Returns the minimum required green accumulation buffer.
+	int get_accum_green_size() const;
+
+	//: Returns the minimum required blue accumulation buffer.
+	int get_accum_blue_size() const;
+
+	//: Returns the minimum required alpha accumulation buffer.
+	int get_accum_alpha_size() const;
+
+//! Operations:
+public:
+	//: Sets if only TrueColor and DirectColor visuals are considered.
+	//- &lt;p&gt;If not enabled, only PseudoColor and StaticColor visuals are considered.&lt;/p&gt;
+	void set_rgba(bool value);
+
+	//: Sets if only double-buffered visuals are considered.
+	//- &lt;p&gt;If not enabled, only single-buffered visuals are considered.&lt;/p&gt;
+	void set_doublebuffer(bool value);
+
+	//: Sets if only stereo visuals are to be considered.
+	//- &lt;p&gt;If not enabled, only monoscopic visuals are considered.&lt;/p&gt;
+	void set_stereo(bool value);
+
+	//: Sets the desired color index buffer size.
+	//- &lt;p&gt;Ignored in GLX (X11) if the RGBA flag is set.&lt;/p&gt;
+	//- &lt;p&gt;In WGL (Windows) it specifies the size of the color buffer, excluding the alpha bitplanes.&lt;/p&gt;
+	void set_buffer_size(int value);
+
+	//: Sets the required buffer level.
+	//- &lt;p&gt;Buffer level zero corresponds to the main frame buffer of the display. Buffer
+	//- level one is the first overlay frame buffer, level two the second overlay frame
+	//- buffer, and so on. Negative buffer levels correspond to underlay frame buffers.&lt;/p&gt;
+	void set_level(int value);
+
+	//: Sets the desired number of auxilary buffers.
+	//- &lt;p&gt;Visuals with the smallest number of auxiliary buffers that meets or exceeds
+	//- the specified number are preferred.&lt;/p&gt;
+	void set_aux_buffers(int value);
+
+	//: Sets the minimum required red buffer.
+	//- &lt;p&gt;If this value is zero, the smallest available red buffer is preferred. Otherwise,
+	//- the largest available red buffer of at least the minimum size is preferred.&lt;/p&gt;
+	void set_red_size(int value);
+
+	//: Sets the minimum required green buffer.
+	//- &lt;p&gt;If this value is zero, the smallest available green buffer is preferred. Otherwise,
+	//- the largest available green buffer of at least the minimum size is preferred.&lt;/p&gt;
+	void set_green_size(int value);
+
+	//: Sets the minimum required blue buffer.
+	//- &lt;p&gt;If this value is zero, the smallest available blue buffer is preferred. Otherwise,
+	//- the largest available blue buffer of at least the minimum size is preferred.&lt;/p&gt;
+	void set_blue_size(int value);
+
+	//: Sets the minimum required alpha buffer.
+	//- &lt;p&gt;If this value is zero, the smallest available alpha buffer is preferred. Otherwise,
+	//- the largest available alpha buffer of at least the minimum size is preferred.&lt;/p&gt;
+	void set_alpha_size(int value);
+
+	//: Sets the minimum required depth buffer.
+	//- &lt;p&gt;If this value is zero, the smallest available depth buffer is preferred. Otherwise,
+	//- the largest available depth buffer of at least the minimum size is preferred.&lt;/p&gt;
+	void set_depth_size(int value);
+
+	//: Sets the minimum required stencil buffer.
+	//- &lt;p&gt;If this value is zero, the smallest available stencil buffer is preferred. Otherwise,
+	//- the largest available stencil buffer of at least the minimum size is preferred.&lt;/p&gt;
+	void set_stencil_size(int value);
+
+	//: Sets the minimum required red accumulation buffer.
+	//- &lt;p&gt;If this value is zero, the smallest available red accumulation buffer is preferred. Otherwise,
+	//- the largest available red accumulation buffer of at least the minimum size is preferred.&lt;/p&gt;
+	void set_accum_red_size(int value);
+
+	//: Sets the minimum required green accumulation buffer.
+	//- &lt;p&gt;If this value is zero, the smallest available green accumulation buffer is preferred. Otherwise,
+	//- the largest available green accumulation buffer of at least the minimum size is preferred.&lt;/p&gt;
+	void set_accum_green_size(int value);
+
+	//: Sets the minimum required blue accumulation buffer.
+	//- &lt;p&gt;If this value is zero, the smallest available blue accumulation buffer is preferred. Otherwise,
+	//- the largest available blue accumulation buffer of at least the minimum size is preferred.&lt;/p&gt;
+	void set_accum_blue_size(int value);
+
+	//: Sets the minimum required alpha accumulation buffer.
+	//- &lt;p&gt;If this value is zero, the smallest available alpha accumulation buffer is preferred. Otherwise,
+	//- the largest available alpha accumulation buffer of at least the minimum size is preferred.&lt;/p&gt;
+	void set_accum_alpha_size(int value);
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/API/GL/opengl_wrap.h
===================================================================
--- trunk/clanlib/API/GL/opengl_wrap.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GL/opengl_wrap.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,4920 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGL=&quot;System&quot;
+//! header=gl.h
+
+#ifndef header_opengl_wrap
+#define header_opengl_wrap
+
+#ifdef CL_API_DLL
+#ifdef CL_GL_EXPORT
+#define CL_API_GL __declspec(dllexport)
+#else
+#define CL_API_GL __declspec(dllimport)
+#endif
+#else
+#define CL_API_GL
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;opengl.h&quot;
+
+#ifdef WIN32
+#define CL_GLFUNC WINAPI
+#else
+#define CL_GLFUNC
+#endif
+
+//: OpenGL 2.0 defines
+//- !group=GL/System!
+//- !header=gl.h!
+enum CL_GLDefines
+{
+	// AccumOp:
+
+	CL_ACCUM                          = 0x0100,
+	CL_LOAD                           = 0x0101,
+	CL_RETURN                         = 0x0102,
+	CL_MULT                           = 0x0103,
+	CL_ADD                            = 0x0104,
+
+	// AlphaFunction:
+
+	CL_NEVER                          = 0x0200,
+	CL_LESS                           = 0x0201,
+	CL_EQUAL                          = 0x0202,
+	CL_LEQUAL                         = 0x0203,
+	CL_GREATER                        = 0x0204,
+	CL_NOTEQUAL                       = 0x0205,
+	CL_GEQUAL                         = 0x0206,
+	CL_ALWAYS                         = 0x0207,
+
+	// AttribMask:
+
+	CL_CURRENT_BIT                    = 0x00000001,
+	CL_POINT_BIT                      = 0x00000002,
+	CL_LINE_BIT                       = 0x00000004,
+	CL_POLYGON_BIT                    = 0x00000008,
+	CL_POLYGON_STIPPLE_BIT            = 0x00000010,
+	CL_PIXEL_MODE_BIT                 = 0x00000020,
+	CL_LIGHTING_BIT                   = 0x00000040,
+	CL_FOG_BIT                        = 0x00000080,
+	CL_DEPTH_BUFFER_BIT               = 0x00000100,
+	CL_ACCUM_BUFFER_BIT               = 0x00000200,
+	CL_STENCIL_BUFFER_BIT             = 0x00000400,
+	CL_VIEWPORT_BIT                   = 0x00000800,
+	CL_TRANSFORM_BIT                  = 0x00001000,
+	CL_ENABLE_BIT                     = 0x00002000,
+	CL_COLOR_BUFFER_BIT               = 0x00004000,
+	CL_HINT_BIT                       = 0x00008000,
+	CL_EVAL_BIT                       = 0x00010000,
+	CL_LIST_BIT                       = 0x00020000,
+	CL_TEXTURE_BIT                    = 0x00040000,
+	CL_SCISSOR_BIT                    = 0x00080000,
+	CL_ALL_ATTRIB_BITS                = 0x000fffff,
+
+	// BeginMode:
+
+	CL_POINTS                         = 0x0000,
+	CL_LINES                          = 0x0001,
+	CL_LINE_LOOP                      = 0x0002,
+	CL_LINE_STRIP                     = 0x0003,
+	CL_TRIANGLES                      = 0x0004,
+	CL_TRIANGLE_STRIP                 = 0x0005,
+	CL_TRIANGLE_FAN                   = 0x0006,
+	CL_QUADS                          = 0x0007,
+	CL_QUAD_STRIP                     = 0x0008,
+	CL_POLYGON                        = 0x0009,
+
+	// BlendEquationMode:
+
+	// CL_LOGIC_OP
+	// CL_FUNC_ADD
+	// CL_MIN
+	// CL_MAX
+	// CL_FUNC_SUBTRACT
+	// CL_FUNC_REVERSE_SUBTRACT
+
+	// BlendingFactorDest:
+
+	CL_ZERO                           = 0,
+	CL_ONE                            = 1,
+	CL_SRC_COLOR                      = 0x0300,
+	CL_ONE_MINUS_SRC_COLOR            = 0x0301,
+	CL_SRC_ALPHA                      = 0x0302,
+	CL_ONE_MINUS_SRC_ALPHA            = 0x0303,
+	CL_DST_ALPHA                      = 0x0304,
+	CL_ONE_MINUS_DST_ALPHA            = 0x0305,
+	// CL_CONSTANT_COLOR
+	// CL_ONE_MINUS_CONSTANT_COLOR
+	// CL_CONSTANT_ALPHA
+	// CL_ONE_MINUS_CONSTANT_ALPHA
+
+	// BlendingFactorSrc:
+
+	// CL_ZERO
+	// CL_ONE
+	CL_DST_COLOR                      = 0x0306,
+	CL_ONE_MINUS_DST_COLOR            = 0x0307,
+	CL_SRC_ALPHA_SATURATE             = 0x0308,
+	// CL_SRC_ALPHA
+	// CL_ONE_MINUS_SRC_ALPHA
+	// CL_DST_ALPHA
+	// CL_ONE_MINUS_DST_ALPHA
+	// CL_CONSTANT_COLOR
+	// CL_ONE_MINUS_CONSTANT_COLOR
+	// CL_CONSTANT_ALPHA
+	// CL_ONE_MINUS_CONSTANT_ALPHA
+
+	// Boolean:
+
+	CL_TRUE                           = 1,
+	CL_FALSE                          = 0,
+
+	// ClearBufferMask:
+
+	// COLOR_BUFFER_BIT
+	// ACCUM_BUFFER_BIT
+	// STENCIL_BUFFER_BIT
+	// DEPTH_BUFFER_BIT
+
+	// ClientArrayType:
+
+	// VERTEX_ARRAY
+	// NORMAL_ARRAY
+	// COLOR_ARRAY
+	// INDEX_ARRAY
+	// TEXTURE_COORD_ARRAY
+	// EDGE_FLAG_ARRAY
+
+	// ClipPlaneName:
+
+	CL_CLIP_PLANE0                    = 0x3000,
+	CL_CLIP_PLANE1                    = 0x3001,
+	CL_CLIP_PLANE2                    = 0x3002,
+	CL_CLIP_PLANE3                    = 0x3003,
+	CL_CLIP_PLANE4                    = 0x3004,
+	CL_CLIP_PLANE5                    = 0x3005,
+
+	// ColorMaterialFace:
+
+	// CL_FRONT
+	// CL_BACK
+	// CL_FRONT_AND_BACK
+
+	// ColorMaterialParameter:
+
+	// CL_AMBIENT
+	// CL_DIFFUSE
+	// CL_SPECULAR
+	// CL_EMISSION
+	// CL_AMBIENT_AND_DIFFUSE
+
+	// ColorPointerType:
+
+	// CL_BYTE
+	// CL_UNSIGNED_BYTE
+	// CL_SHORT
+	// CL_UNSIGNED_SHORT
+	// CL_INT
+	// CL_UNSIGNED_INT
+	// CL_FLOAT
+	// CL_DOUBLE
+
+	// ColorTableParameterPName:
+
+	// CL_COLOR_TABLE_SCALE
+	// CL_COLOR_TABLE_BIAS
+
+	// ColorTableTarget:
+
+	// CL_COLOR_TABLE
+	// CL_POST_CONVOLUTION_COLOR_TABLE
+	// CL_POST_COLOR_MATRIX_COLOR_TABLE
+	// CL_PROXY_COLOR_TABLE
+	// CL_PROXY_POST_CONVOLUTION_COLOR_TABLE
+	// CL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE
+
+	// ConvolutionBorderMode:
+
+	// CL_REDUCE
+	// CL_IGNORE_BORDER
+	// CL_CONSTANT_BORDER
+
+	// ConvolutionParameter:
+
+	// CL_CONVOLUTION_BORDER_MODE
+	// CL_CONVOLUTION_FILTER_SCALE
+	// CL_CONVOLUTION_FILTER_BIAS
+
+	// ConvolutionTarget:
+
+	// CL_CONVOLUTION_1D
+	// CL_CONVOLUTION_2D
+
+	// CullFaceMode:
+
+	// CL_FRONT
+	// CL_BACK
+	// CL_FRONT_AND_BACK
+
+	// DataType:
+
+	CL_BYTE                           = 0x1400,
+	CL_UNSIGNED_BYTE                  = 0x1401,
+	CL_SHORT                          = 0x1402,
+	CL_UNSIGNED_SHORT                 = 0x1403,
+	CL_INT                            = 0x1404,
+	CL_UNSIGNED_INT                   = 0x1405,
+	CL_FLOAT                          = 0x1406,
+	CL_2_BYTES                        = 0x1407,
+	CL_3_BYTES                        = 0x1408,
+	CL_4_BYTES                        = 0x1409,
+	CL_DOUBLE                         = 0x140A,
+
+	// DepthFunction:
+
+	// CL_NEVER
+	// CL_LESS
+	// CL_EQUAL
+	// CL_LEQUAL
+	// CL_GREATER
+	// CL_NOTEQUAL
+	// CL_GEQUAL
+	// CL_ALWAYS
+
+	// DrawBufferMode:
+
+	CL_NONE                           = 0,
+	CL_FRONT_LEFT                     = 0x0400,
+	CL_FRONT_RIGHT                    = 0x0401,
+	CL_BACK_LEFT                      = 0x0402,
+	CL_BACK_RIGHT                     = 0x0403,
+	CL_FRONT                          = 0x0404,
+	CL_BACK                           = 0x0405,
+	CL_LEFT                           = 0x0406,
+	CL_RIGHT                          = 0x0407,
+	CL_FRONT_AND_BACK                 = 0x0408,
+	CL_AUX0                           = 0x0409,
+	CL_AUX1                           = 0x040A,
+	CL_AUX2                           = 0x040B,
+	CL_AUX3                           = 0x040C,
+
+	// Enable:
+
+	// CL_FOG
+	// CL_LIGHTING
+	// CL_TEXTURE_1D
+	// CL_TEXTURE_2D
+	// CL_LINE_STIPPLE
+	// CL_POLYGON_STIPPLE
+	// CL_CULL_FACE
+	// CL_ALPHA_TEST
+	// CL_BLEND
+	// CL_INDEX_LOGIC_OP
+	// CL_COLOR_LOGIC_OP
+	// CL_DITHER
+	// CL_STENCIL_TEST
+	// CL_DEPTH_TEST
+	// CL_CLIP_PLANE0
+	// CL_CLIP_PLANE1
+	// CL_CLIP_PLANE2
+	// CL_CLIP_PLANE3
+	// CL_CLIP_PLANE4
+	// CL_CLIP_PLANE5
+	// CL_LIGHT0
+	// CL_LIGHT1
+	// CL_LIGHT2
+	// CL_LIGHT3
+	// CL_LIGHT4
+	// CL_LIGHT5
+	// CL_LIGHT6
+	// CL_LIGHT7
+	// CL_TEXTURE_GEN_S
+	// CL_TEXTURE_GEN_T
+	// CL_TEXTURE_GEN_R
+	// CL_TEXTURE_GEN_Q
+	// CL_MAP1_VERTEX_3
+	// CL_MAP1_VERTEX_4
+	// CL_MAP1_COLOR_4
+	// CL_MAP1_INDEX
+	// CL_MAP1_NORMAL
+	// CL_MAP1_TEXTURE_COORD_1
+	// CL_MAP1_TEXTURE_COORD_2
+	// CL_MAP1_TEXTURE_COORD_3
+	// CL_MAP1_TEXTURE_COORD_4
+	// CL_MAP2_VERTEX_3
+	// CL_MAP2_VERTEX_4
+	// CL_MAP2_COLOR_4
+	// CL_MAP2_INDEX
+	// CL_MAP2_NORMAL
+	// CL_MAP2_TEXTURE_COORD_1
+	// CL_MAP2_TEXTURE_COORD_2
+	// CL_MAP2_TEXTURE_COORD_3
+	// CL_MAP2_TEXTURE_COORD_4
+	// CL_POINT_SMOOTH
+	// CL_LINE_SMOOTH
+	// CL_POLYGON_SMOOTH
+	// CL_SCISSOR_TEST
+	// CL_COLOR_MATERIAL
+	// CL_NORMALIZE
+	// CL_AUTO_NORMAL
+	// CL_VERTEX_ARRAY
+	// CL_NORMAL_ARRAY
+	// CL_COLOR_ARRAY
+	// CL_INDEX_ARRAY
+	// CL_TEXTURE_COORD_ARRAY
+	// CL_EDGE_FLAG_ARRAY
+	// CL_POLYGON_OFFSET_POINT
+	// CL_POLYGON_OFFSET_LINE
+	// CL_POLYGON_OFFSET_FILL
+	// CL_COLOR_TABLE
+	// CL_POST_CONVOLUTION_COLOR_TABLE
+	// CL_POST_COLOR_MATRIX_COLOR_TABLE
+	// CL_CONVOLUTION_1D
+	// CL_CONVOLUTION_2D
+	// CL_SEPARABLE_2D
+	// CL_HISTOGRAM
+	// CL_MINMAX
+	// CL_RESCALE_NORMAL
+	// CL_TEXTURE_3D
+
+	// ErrorCode:
+
+	CL_NO_ERROR                     = 0,
+	CL_INVALID_ENUM                 = 0x0500,
+	CL_INVALID_VALUE                = 0x0501,
+	CL_INVALID_OPERATION            = 0x0502,
+	CL_STACK_OVERFLOW               = 0x0503,
+	CL_STACK_UNDERFLOW              = 0x0504,
+	CL_OUT_OF_MEMORY                = 0x0505,
+	// CL_TABLE_TOO_LARGE
+
+	// FeedBackMode:
+
+	CL_2D                           = 0x0600,
+	CL_3D                           = 0x0601,
+	CL_3D_COLOR                     = 0x0602,
+	CL_3D_COLOR_TEXTURE             = 0x0603,
+	CL_4D_COLOR_TEXTURE             = 0x0604,
+
+	// FeedBackToken:
+
+	CL_PASS_THROUGH_TOKEN           = 0x0700,
+	CL_POINT_TOKEN                  = 0x0701,
+	CL_LINE_TOKEN                   = 0x0702,
+	CL_POLYGON_TOKEN                = 0x0703,
+	CL_BITMAP_TOKEN                 = 0x0704,
+	CL_DRAW_PIXEL_TOKEN             = 0x0705,
+	CL_COPY_PIXEL_TOKEN             = 0x0706,
+	CL_LINE_RESET_TOKEN             = 0x0707,
+
+	// FogMode:
+
+	// CL_LINEAR
+	CL_EXP                          = 0x0800,
+	CL_EXP2                         = 0x0801,
+
+	// FogParameter:
+
+	// CL_FOG_COLOR
+	// CL_FOG_DENSITY
+	// CL_FOG_END
+	// CL_FOG_INDEX
+	// CL_FOG_MODE
+	// CL_FOG_START
+
+	// FrontFaceDirection:
+
+	CL_CW                           = 0x0900,
+	CL_CCW                          = 0x0901,
+
+	// GetColorTableParameterPName:
+
+	// CL_COLOR_TABLE_SCALE
+	// CL_COLOR_TABLE_BIAS
+	// CL_COLOR_TABLE_FORMAT
+	// CL_COLOR_TABLE_WIDTH
+	// CL_COLOR_TABLE_RED_SIZE
+	// CL_COLOR_TABLE_GREEN_SIZE
+	// CL_COLOR_TABLE_BLUE_SIZE
+	// CL_COLOR_TABLE_ALPHA_SIZE
+	// CL_COLOR_TABLE_LUMINANCE_SIZE
+	// CL_COLOR_TABLE_INTENSITY_SIZE
+
+	// GetConvolutionParameterPName:
+
+	// CL_CONVOLUTION_BORDER_COLOR
+	// CL_CONVOLUTION_BORDER_MODE
+	// CL_CONVOLUTION_FILTER_SCALE
+	// CL_CONVOLUTION_FILTER_BIAS
+	// CL_CONVOLUTION_FORMAT
+	// CL_CONVOLUTION_WIDTH
+	// CL_CONVOLUTION_HEIGHT
+	// CL_MAX_CONVOLUTION_WIDTH
+	// CL_MAX_CONVOLUTION_HEIGHT
+
+	// GetHistogramParameterPName:
+
+	// CL_HISTOGRAM_WIDTH
+	// CL_HISTOGRAM_FORMAT
+	// CL_HISTOGRAM_RED_SIZE
+	// CL_HISTOGRAM_GREEN_SIZE
+	// CL_HISTOGRAM_BLUE_SIZE
+	// CL_HISTOGRAM_ALPHA_SIZE
+	// CL_HISTOGRAM_LUMINANCE_SIZE
+	// CL_HISTOGRAM_SINK
+
+	// GetMapTarget:
+
+	CL_COEFF                        = 0x0A00,
+	CL_ORDER                        = 0x0A01,
+	CL_DOMAIN                       = 0x0A02,
+
+	// GetMinmaxParameterPName:
+
+	// CL_MINMAX_FORMAT
+	// CL_MINMAX_SINK
+
+	// GetPixelMap:
+
+	// CL_PIXEL_MAP_I_TO_I
+	// CL_PIXEL_MAP_S_TO_S
+	// CL_PIXEL_MAP_I_TO_R
+	// CL_PIXEL_MAP_I_TO_G
+	// CL_PIXEL_MAP_I_TO_B
+	// CL_PIXEL_MAP_I_TO_A
+	// CL_PIXEL_MAP_R_TO_R
+	// CL_PIXEL_MAP_G_TO_G
+	// CL_PIXEL_MAP_B_TO_B
+	// CL_PIXEL_MAP_A_TO_A
+
+	// GetPointerTarget:
+
+	// CL_VERTEX_ARRAY_POINTER
+	// CL_NORMAL_ARRAY_POINTER
+	// CL_COLOR_ARRAY_POINTER
+	// CL_INDEX_ARRAY_POINTER
+	// CL_TEXTURE_COORD_ARRAY_POINTER
+	// CL_EDGE_FLAG_ARRAY_POINTER
+
+	// GetTarget:
+
+	CL_CURRENT_COLOR                = 0x0B00,
+	CL_CURRENT_INDEX                = 0x0B01,
+	CL_CURRENT_NORMAL               = 0x0B02,
+	CL_CURRENT_TEXTURE_COORDS       = 0x0B03,
+	CL_CURRENT_RASTER_COLOR         = 0x0B04,
+	CL_CURRENT_RASTER_INDEX         = 0x0B05,
+	CL_CURRENT_RASTER_TEXTURE_COORDS= 0x0B06,
+	CL_CURRENT_RASTER_POSITION      = 0x0B07,
+	CL_CURRENT_RASTER_POSITION_VALID= 0x0B08,
+	CL_CURRENT_RASTER_DISTANCE      = 0x0B09,
+	CL_POINT_SMOOTH                 = 0x0B10,
+	CL_POINT_SIZE                   = 0x0B11,
+	CL_POINT_SIZE_RANGE             = 0x0B12,
+	CL_POINT_SIZE_GRANULARITY       = 0x0B13,
+	CL_LINE_SMOOTH                  = 0x0B20,
+	CL_LINE_WIDTH                   = 0x0B21,
+	CL_LINE_WIDTH_RANGE             = 0x0B22,
+	CL_LINE_WIDTH_GRANULARITY       = 0x0B23,
+	CL_LINE_STIPPLE                 = 0x0B24,
+	CL_LINE_STIPPLE_PATTERN         = 0x0B25,
+	CL_LINE_STIPPLE_REPEAT          = 0x0B26,
+	// CL_SMOOTH_POINT_SIZE_RANGE
+	// CL_SMOOTH_POINT_SIZE_GRANULARITY
+	// CL_SMOOTH_LINE_WIDTH_RANGE
+	// CL_SMOOTH_LINE_WIDTH_GRANULARITY
+	// CL_ALIASED_POINT_SIZE_RANGE
+	// CL_ALIASED_LINE_WIDTH_RANGE
+	CL_LIST_MODE                    = 0x0B30,
+	CL_MAX_LIST_NESTING             = 0x0B31,
+	CL_LIST_BASE                    = 0x0B32,
+	CL_LIST_INDEX                   = 0x0B33,
+	CL_POLYGON_MODE                 = 0x0B40,
+	CL_POLYGON_SMOOTH               = 0x0B41,
+	CL_POLYGON_STIPPLE              = 0x0B42,
+	CL_EDGE_FLAG                    = 0x0B43,
+	CL_CULL_FACE                    = 0x0B44,
+	CL_CULL_FACE_MODE               = 0x0B45,
+	CL_FRONT_FACE                   = 0x0B46,
+	CL_LIGHTING                     = 0x0B50,
+	CL_LIGHT_MODEL_LOCAL_VIEWER     = 0x0B51,
+	CL_LIGHT_MODEL_TWO_SIDE         = 0x0B52,
+	CL_LIGHT_MODEL_AMBIENT          = 0x0B53,
+	CL_SHADE_MODEL                  = 0x0B54,
+	CL_COLOR_MATERIAL_FACE          = 0x0B55,
+	CL_COLOR_MATERIAL_PARAMETER     = 0x0B56,
+	CL_COLOR_MATERIAL               = 0x0B57,
+	CL_FOG                          = 0x0B60,
+	CL_FOG_INDEX                    = 0x0B61,
+	CL_FOG_DENSITY                  = 0x0B62,
+	CL_FOG_START                    = 0x0B63,
+	CL_FOG_END                      = 0x0B64,
+	CL_FOG_MODE                     = 0x0B65,
+	CL_FOG_COLOR                    = 0x0B66,
+	CL_DEPTH_RANGE                  = 0x0B70,
+	CL_DEPTH_TEST                   = 0x0B71,
+	CL_DEPTH_WRITEMASK              = 0x0B72,
+	CL_DEPTH_CLEAR_VALUE            = 0x0B73,
+	CL_DEPTH_FUNC                   = 0x0B74,
+	CL_ACCUM_CLEAR_VALUE            = 0x0B80,
+	CL_STENCIL_TEST                 = 0x0B90,
+	CL_STENCIL_CLEAR_VALUE          = 0x0B91,
+	CL_STENCIL_FUNC                 = 0x0B92,
+	CL_STENCIL_VALUE_MASK           = 0x0B93,
+	CL_STENCIL_FAIL                 = 0x0B94,
+	CL_STENCIL_PASS_DEPTH_FAIL      = 0x0B95,
+	CL_STENCIL_PASS_DEPTH_PASS      = 0x0B96,
+	CL_STENCIL_REF                  = 0x0B97,
+	CL_STENCIL_WRITEMASK            = 0x0B98,
+	CL_MATRIX_MODE                  = 0x0BA0,
+	CL_NORMALIZE                    = 0x0BA1,
+	CL_VIEWPORT                     = 0x0BA2,
+	CL_MODELVIEW_STACK_DEPTH        = 0x0BA3,
+	CL_PROJECTION_STACK_DEPTH       = 0x0BA4,
+	CL_TEXTURE_STACK_DEPTH          = 0x0BA5,
+	CL_MODELVIEW_MATRIX             = 0x0BA6,
+	CL_PROJECTION_MATRIX            = 0x0BA7,
+	CL_TEXTURE_MATRIX               = 0x0BA8,
+	CL_ATTRIB_STACK_DEPTH           = 0x0BB0,
+	CL_CLIENT_ATTRIB_STACK_DEPTH    = 0x0BB1,
+	CL_ALPHA_TEST                   = 0x0BC0,
+	CL_ALPHA_TEST_FUNC              = 0x0BC1,
+	CL_ALPHA_TEST_REF               = 0x0BC2,
+	CL_DITHER                       = 0x0BD0,
+	CL_BLEND_DST                    = 0x0BE0,
+	CL_BLEND_SRC                    = 0x0BE1,
+	CL_BLEND                        = 0x0BE2,
+	CL_LOGIC_OP_MODE                = 0x0BF0,
+	CL_INDEX_LOGIC_OP               = 0x0BF1,
+	CL_COLOR_LOGIC_OP               = 0x0BF2,
+	CL_AUX_BUFFERS                  = 0x0C00,
+	CL_DRAW_BUFFER                  = 0x0C01,
+	CL_READ_BUFFER                  = 0x0C02,
+	CL_SCISSOR_BOX                  = 0x0C10,
+	CL_SCISSOR_TEST                 = 0x0C11,
+	CL_INDEX_CLEAR_VALUE            = 0x0C20,
+	CL_INDEX_WRITEMASK              = 0x0C21,
+	CL_COLOR_CLEAR_VALUE            = 0x0C22,
+	CL_COLOR_WRITEMASK              = 0x0C23,
+	CL_INDEX_MODE                   = 0x0C30,
+	CL_RGBA_MODE                    = 0x0C31,
+	CL_DOUBLEBUFFER                 = 0x0C32,
+	CL_STEREO                       = 0x0C33,
+	CL_RENDER_MODE                  = 0x0C40,
+	CL_PERSPECTIVE_CORRECTION_HINT  = 0x0C50,
+	CL_POINT_SMOOTH_HINT            = 0x0C51,
+	CL_LINE_SMOOTH_HINT             = 0x0C52,
+	CL_POLYGON_SMOOTH_HINT          = 0x0C53,
+	CL_FOG_HINT                     = 0x0C54,
+	CL_TEXTURE_GEN_S                = 0x0C60,
+	CL_TEXTURE_GEN_T                = 0x0C61,
+	CL_TEXTURE_GEN_R                = 0x0C62,
+	CL_TEXTURE_GEN_Q                = 0x0C63,
+	CL_PIXEL_MAP_I_TO_I             = 0x0C70,
+	CL_PIXEL_MAP_S_TO_S             = 0x0C71,
+	CL_PIXEL_MAP_I_TO_R             = 0x0C72,
+	CL_PIXEL_MAP_I_TO_G             = 0x0C73,
+	CL_PIXEL_MAP_I_TO_B             = 0x0C74,
+	CL_PIXEL_MAP_I_TO_A             = 0x0C75,
+	CL_PIXEL_MAP_R_TO_R             = 0x0C76,
+	CL_PIXEL_MAP_G_TO_G             = 0x0C77,
+	CL_PIXEL_MAP_B_TO_B             = 0x0C78,
+	CL_PIXEL_MAP_A_TO_A             = 0x0C79,
+	CL_PIXEL_MAP_I_TO_I_SIZE        = 0x0CB0,
+	CL_PIXEL_MAP_S_TO_S_SIZE        = 0x0CB1,
+	CL_PIXEL_MAP_I_TO_R_SIZE        = 0x0CB2,
+	CL_PIXEL_MAP_I_TO_G_SIZE        = 0x0CB3,
+	CL_PIXEL_MAP_I_TO_B_SIZE        = 0x0CB4,
+	CL_PIXEL_MAP_I_TO_A_SIZE        = 0x0CB5,
+	CL_PIXEL_MAP_R_TO_R_SIZE        = 0x0CB6,
+	CL_PIXEL_MAP_G_TO_G_SIZE        = 0x0CB7,
+	CL_PIXEL_MAP_B_TO_B_SIZE        = 0x0CB8,
+	CL_PIXEL_MAP_A_TO_A_SIZE        = 0x0CB9,
+	CL_UNPACK_SWAP_BYTES            = 0x0CF0,
+	CL_UNPACK_LSB_FIRST             = 0x0CF1,
+	CL_UNPACK_ROW_LENGTH            = 0x0CF2,
+	CL_UNPACK_SKIP_ROWS             = 0x0CF3,
+	CL_UNPACK_SKIP_PIXELS           = 0x0CF4,
+	CL_UNPACK_ALIGNMENT             = 0x0CF5,
+	CL_PACK_SWAP_BYTES              = 0x0D00,
+	CL_PACK_LSB_FIRST               = 0x0D01,
+	CL_PACK_ROW_LENGTH              = 0x0D02,
+	CL_PACK_SKIP_ROWS               = 0x0D03,
+	CL_PACK_SKIP_PIXELS             = 0x0D04,
+	CL_PACK_ALIGNMENT               = 0x0D05,
+	CL_MAP_COLOR                    = 0x0D10,
+	CL_MAP_STENCIL                  = 0x0D11,
+	CL_INDEX_SHIFT                  = 0x0D12,
+	CL_INDEX_OFFSET                 = 0x0D13,
+	CL_RED_SCALE                    = 0x0D14,
+	CL_RED_BIAS                     = 0x0D15,
+	CL_ZOOM_X                       = 0x0D16,
+	CL_ZOOM_Y                       = 0x0D17,
+	CL_GREEN_SCALE                  = 0x0D18,
+	CL_GREEN_BIAS                   = 0x0D19,
+	CL_BLUE_SCALE                   = 0x0D1A,
+	CL_BLUE_BIAS                    = 0x0D1B,
+	CL_ALPHA_SCALE                  = 0x0D1C,
+	CL_ALPHA_BIAS                   = 0x0D1D,
+	CL_DEPTH_SCALE                  = 0x0D1E,
+	CL_DEPTH_BIAS                   = 0x0D1F,
+	CL_MAX_EVAL_ORDER               = 0x0D30,
+	CL_MAX_LIGHTS                   = 0x0D31,
+	CL_MAX_CLIP_PLANES              = 0x0D32,
+	CL_MAX_TEXTURE_SIZE             = 0x0D33,
+	CL_MAX_PIXEL_MAP_TABLE          = 0x0D34,
+	CL_MAX_ATTRIB_STACK_DEPTH       = 0x0D35,
+	CL_MAX_MODELVIEW_STACK_DEPTH    = 0x0D36,
+	CL_MAX_NAME_STACK_DEPTH         = 0x0D37,
+	CL_MAX_PROJECTION_STACK_DEPTH   = 0x0D38,
+	CL_MAX_TEXTURE_STACK_DEPTH      = 0x0D39,
+	CL_MAX_VIEWPORT_DIMS            = 0x0D3A,
+	CL_MAX_CLIENT_ATTRIB_STACK_DEPTH= 0x0D3B,
+	CL_SUBPIXEL_BITS                = 0x0D50,
+	CL_INDEX_BITS                   = 0x0D51,
+	CL_RED_BITS                     = 0x0D52,
+	CL_GREEN_BITS                   = 0x0D53,
+	CL_BLUE_BITS                    = 0x0D54,
+	CL_ALPHA_BITS                   = 0x0D55,
+	CL_DEPTH_BITS                   = 0x0D56,
+	CL_STENCIL_BITS                 = 0x0D57,
+	CL_ACCUM_RED_BITS               = 0x0D58,
+	CL_ACCUM_GREEN_BITS             = 0x0D59,
+	CL_ACCUM_BLUE_BITS              = 0x0D5A,
+	CL_ACCUM_ALPHA_BITS             = 0x0D5B,
+	CL_NAME_STACK_DEPTH             = 0x0D70,
+	CL_AUTO_NORMAL                  = 0x0D80,
+	CL_MAP1_COLOR_4                 = 0x0D90,
+	CL_MAP1_INDEX                   = 0x0D91,
+	CL_MAP1_NORMAL                  = 0x0D92,
+	CL_MAP1_TEXTURE_COORD_1         = 0x0D93,
+	CL_MAP1_TEXTURE_COORD_2         = 0x0D94,
+	CL_MAP1_TEXTURE_COORD_3         = 0x0D95,
+	CL_MAP1_TEXTURE_COORD_4         = 0x0D96,
+	CL_MAP1_VERTEX_3                = 0x0D97,
+	CL_MAP1_VERTEX_4                = 0x0D98,
+	CL_MAP2_COLOR_4                 = 0x0DB0,
+	CL_MAP2_INDEX                   = 0x0DB1,
+	CL_MAP2_NORMAL                  = 0x0DB2,
+	CL_MAP2_TEXTURE_COORD_1         = 0x0DB3,
+	CL_MAP2_TEXTURE_COORD_2         = 0x0DB4,
+	CL_MAP2_TEXTURE_COORD_3         = 0x0DB5,
+	CL_MAP2_TEXTURE_COORD_4         = 0x0DB6,
+	CL_MAP2_VERTEX_3                = 0x0DB7,
+	CL_MAP2_VERTEX_4                = 0x0DB8,
+	CL_MAP1_GRID_DOMAIN             = 0x0DD0,
+	CL_MAP1_GRID_SEGMENTS           = 0x0DD1,
+	CL_MAP2_GRID_DOMAIN             = 0x0DD2,
+	CL_MAP2_GRID_SEGMENTS           = 0x0DD3,
+	CL_TEXTURE_1D                   = 0x0DE0,
+	CL_TEXTURE_2D                   = 0x0DE1,
+	CL_FEEDBACK_BUFFER_POINTER      = 0x0DF0,
+	CL_FEEDBACK_BUFFER_SIZE         = 0x0DF1,
+	CL_FEEDBACK_BUFFER_TYPE         = 0x0DF2,
+	CL_SELECTION_BUFFER_POINTER     = 0x0DF3,
+	CL_SELECTION_BUFFER_SIZE        = 0x0DF4,
+	// CL_TEXTURE_BINDING_1D
+	// CL_TEXTURE_BINDING_2D
+	// CL_TEXTURE_BINDING_3D
+	// CL_VERTEX_ARRAY
+	// CL_NORMAL_ARRAY
+	// CL_COLOR_ARRAY
+	// CL_INDEX_ARRAY
+	// CL_TEXTURE_COORD_ARRAY
+	// CL_EDGE_FLAG_ARRAY
+	// CL_VERTEX_ARRAY_SIZE
+	// CL_VERTEX_ARRAY_TYPE
+	// CL_VERTEX_ARRAY_STRIDE
+	// CL_NORMAL_ARRAY_TYPE
+	// CL_NORMAL_ARRAY_STRIDE
+	// CL_COLOR_ARRAY_SIZE
+	// CL_COLOR_ARRAY_TYPE
+	// CL_COLOR_ARRAY_STRIDE
+	// CL_INDEX_ARRAY_TYPE
+	// CL_INDEX_ARRAY_STRIDE
+	// CL_TEXTURE_COORD_ARRAY_SIZE
+	// CL_TEXTURE_COORD_ARRAY_TYPE
+	// CL_TEXTURE_COORD_ARRAY_STRIDE
+	// CL_EDGE_FLAG_ARRAY_STRIDE
+	// CL_POLYGON_OFFSET_FACTOR
+	// CL_POLYGON_OFFSET_UNITS
+	// CL_COLOR_TABLE
+	// CL_POST_CONVOLUTION_COLOR_TABLE
+	// CL_POST_COLOR_MATRIX_COLOR_TABLE
+	// CL_CONVOLUTION_1D
+	// CL_CONVOLUTION_2D
+	// CL_SEPARABLE_2D
+	// CL_POST_CONVOLUTION_RED_SCALE
+	// CL_POST_CONVOLUTION_GREEN_SCALE
+	// CL_POST_CONVOLUTION_BLUE_SCALE
+	// CL_POST_CONVOLUTION_ALPHA_SCALE
+	// CL_POST_CONVOLUTION_RED_BIAS
+	// CL_POST_CONVOLUTION_GREEN_BIAS
+	// CL_POST_CONVOLUTION_BLUE_BIAS
+	// CL_POST_CONVOLUTION_ALPHA_BIAS
+	// CL_COLOR_MATRIX
+	// CL_COLOR_MATRIX_STACK_DEPTH
+	// CL_MAX_COLOR_MATRIX_STACK_DEPTH
+	// CL_POST_COLOR_MATRIX_RED_SCALE
+	// CL_POST_COLOR_MATRIX_GREEN_SCALE
+	// CL_POST_COLOR_MATRIX_BLUE_SCALE
+	// CL_POST_COLOR_MATRIX_ALPHA_SCALE
+	// CL_POST_COLOR_MATRIX_RED_BIAS
+	// CL_POST_COLOR_MATRIX_GREEN_BIAS
+	// CL_POST_COLOR_MATRIX_BLUE_BIAS
+	// CL_POST_COLOR_MATRIX_ALPHA_BIAS
+	// CL_HISTOGRAM
+	// CL_MINMAX
+	// CL_MAX_ELEMENTS_VERTICES
+	// CL_MAX_ELEMENTS_INDICES
+	// CL_RESCALE_NORMAL
+	// CL_LIGHT_MODEL_COLOR_CONTROL
+	// CL_PACK_SKIP_IMAGES
+	// CL_PACK_IMAGE_HEIGHT
+	// CL_UNPACK_SKIP_IMAGES
+	// CL_UNPACK_IMAGE_HEIGHT
+	// CL_TEXTURE_3D
+	// CL_MAX_3D_TEXTURE_SIZE
+	// CL_BLEND_COLOR
+	// CL_BLEND_EQUATION
+	// CL_ACTIVE_TEXTURE
+	// CL_CLIENT_ACTIVE_TEXTURE
+	// CL_MAX_TEXTURE_UNITS
+
+	// GetTextureParameter:
+
+	// CL_TEXTURE_MAG_FILTER
+	// CL_TEXTURE_MIN_FILTER
+	// CL_TEXTURE_WRAP_S
+	// CL_TEXTURE_WRAP_T
+	CL_TEXTURE_WIDTH                = 0x1000,
+	CL_TEXTURE_HEIGHT               = 0x1001,
+	CL_TEXTURE_INTERNAL_FORMAT      = 0x1003,
+	CL_TEXTURE_BORDER_COLOR         = 0x1004,
+	CL_TEXTURE_BORDER               = 0x1005,
+	// CL_TEXTURE_RED_SIZE
+	// CL_TEXTURE_GREEN_SIZE
+	// CL_TEXTURE_BLUE_SIZE
+	// CL_TEXTURE_ALPHA_SIZE
+	// CL_TEXTURE_LUMINANCE_SIZE
+	// CL_TEXTURE_INTENSITY_SIZE
+	// CL_TEXTURE_PRIORITY
+	// CL_TEXTURE_RESIDENT
+	// CL_TEXTURE_DEPTH
+	// CL_TEXTURE_WRAP_R
+	// CL_TEXTURE_MIN_LOD
+	// CL_TEXTURE_MAX_LOD
+	// CL_TEXTURE_BASE_LEVEL
+	// CL_TEXTURE_MAX_LEVEL
+
+	// HintMode:
+
+	CL_DONT_CARE                    = 0x1100,
+	CL_FASTEST                      = 0x1101,
+	CL_NICEST                       = 0x1102,
+
+	// HintTarget:
+
+	// CL_PERSPECTIVE_CORRECTION_HINT
+	// CL_POINT_SMOOTH_HINT
+	// CL_LINE_SMOOTH_HINT
+	// CL_POLYGON_SMOOTH_HINT
+	// CL_FOG_HINT
+
+	// HistogramTarget:
+
+	// CL_HISTOGRAM
+	// CL_PROXY_HISTOGRAM
+
+	// IndexPointerType:
+
+	// CL_SHORT
+	// CL_INT
+	// CL_FLOAT
+	// CL_DOUBLE
+
+	// LightModelColorControl:
+
+	// CL_SINGLE_COLOR
+	// CL_SEPARATE_SPECULAR_COLOR
+
+	// LightModelParameter:
+
+	// CL_LIGHT_MODEL_AMBIENT
+	// CL_LIGHT_MODEL_LOCAL_VIEWER
+	// CL_LIGHT_MODEL_TWO_SIDE
+	// CL_LIGHT_MODEL_COLOR_CONTROL
+
+	// LightName:
+
+	CL_LIGHT0                       = 0x4000,
+	CL_LIGHT1                       = 0x4001,
+	CL_LIGHT2                       = 0x4002,
+	CL_LIGHT3                       = 0x4003,
+	CL_LIGHT4                       = 0x4004,
+	CL_LIGHT5                       = 0x4005,
+	CL_LIGHT6                       = 0x4006,
+	CL_LIGHT7                       = 0x4007,
+
+	// LightParameter:
+
+	CL_AMBIENT                      = 0x1200,
+	CL_DIFFUSE                      = 0x1201,
+	CL_SPECULAR                     = 0x1202,
+	CL_POSITION                     = 0x1203,
+	CL_SPOT_DIRECTION               = 0x1204,
+	CL_SPOT_EXPONENT                = 0x1205,
+	CL_SPOT_CUTOFF                  = 0x1206,
+	CL_CONSTANT_ATTENUATION         = 0x1207,
+	CL_LINEAR_ATTENUATION           = 0x1208,
+	CL_QUADRATIC_ATTENUATION        = 0x1209,
+
+	// InterleavedArrays:
+
+	// CL_V2F
+	// CL_V3F
+	// CL_C4UB_V2F
+	// CL_C4UB_V3F
+	// CL_C3F_V3F
+	// CL_N3F_V3F
+	// CL_C4F_N3F_V3F
+	// CL_T2F_V3F
+	// CL_T4F_V4F
+	// CL_T2F_C4UB_V3F
+	// CL_T2F_C3F_V3F
+	// CL_T2F_N3F_V3F
+	// CL_T2F_C4F_N3F_V3F
+	// CL_T4F_C4F_N3F_V4F
+
+	// ListMode:
+
+	CL_COMPILE                      = 0x1300,
+	CL_COMPILE_AND_EXECUTE          = 0x1301,
+
+	// ListNameType:
+
+	// CL_BYTE
+	// CL_UNSIGNED_BYTE
+	// CL_SHORT
+	// CL_UNSIGNED_SHORT
+	// CL_INT
+	// CL_UNSIGNED_INT
+	// CL_FLOAT
+	// CL_2_BYTES
+	// CL_3_BYTES
+	// CL_4_BYTES
+
+	// LogicOp:
+
+	CL_CLEAR                        = 0x1500,
+	CL_AND                          = 0x1501,
+	CL_AND_REVERSE                  = 0x1502,
+	CL_COPY                         = 0x1503,
+	CL_AND_INVERTED                 = 0x1504,
+	CL_NOOP                         = 0x1505,
+	CL_XOR                          = 0x1506,
+	CL_OR                           = 0x1507,
+	CL_NOR                          = 0x1508,
+	CL_EQUIV                        = 0x1509,
+	CL_INVERT                       = 0x150A,
+	CL_OR_REVERSE                   = 0x150B,
+	CL_COPY_INVERTED                = 0x150C,
+	CL_OR_INVERTED                  = 0x150D,
+	CL_NAND                         = 0x150E,
+	CL_SET                          = 0x150F,
+
+	// MapTarget:
+
+	// CL_MAP1_COLOR_4
+	// CL_MAP1_INDEX
+	// CL_MAP1_NORMAL
+	// CL_MAP1_TEXTURE_COORD_1
+	// CL_MAP1_TEXTURE_COORD_2
+	// CL_MAP1_TEXTURE_COORD_3
+	// CL_MAP1_TEXTURE_COORD_4
+	// CL_MAP1_VERTEX_3
+	// CL_MAP1_VERTEX_4
+	// CL_MAP2_COLOR_4
+	// CL_MAP2_INDEX
+	// CL_MAP2_NORMAL
+	// CL_MAP2_TEXTURE_COORD_1
+	// CL_MAP2_TEXTURE_COORD_2
+	// CL_MAP2_TEXTURE_COORD_3
+	// CL_MAP2_TEXTURE_COORD_4
+	// CL_MAP2_VERTEX_3
+	// CL_MAP2_VERTEX_4
+
+	// MaterialFace:
+
+	// CL_FRONT
+	// CL_BACK
+	// CL_FRONT_AND_BACK
+
+	// MaterialParameter:
+
+	CL_EMISSION                     = 0x1600,
+	CL_SHININESS                    = 0x1601,
+	CL_AMBIENT_AND_DIFFUSE          = 0x1602,
+	CL_COLOR_INDEXES                = 0x1603,
+	// CL_AMBIENT
+	// CL_DIFFUSE
+	// CL_SPECULAR
+
+	// MatrixMode:
+
+	CL_MODELVIEW                    = 0x1700,
+	CL_PROJECTION                   = 0x1701,
+	CL_TEXTURE                      = 0x1702,
+
+	// MeshMode1:
+
+	// CL_POINT
+	// CL_LINE
+
+	// MeshMode2:
+
+	// CL_POINT
+	// CL_LINE
+	// CL_FILL
+
+	// MinmaxTarget:
+
+	// CL_MINMAX
+
+	// NormalPointerType:
+
+	// CL_BYTE
+	// CL_SHORT
+	// CL_INT
+	// CL_FLOAT
+	// CL_DOUBLE
+
+	// PixelCopyType:
+
+	CL_COLOR                        = 0x1800,
+	CL_DEPTH                        = 0x1801,
+	CL_STENCIL                      = 0x1802,
+
+	// PixelFormat:
+
+	CL_COLOR_INDEX                  = 0x1900,
+	CL_STENCIL_INDEX                = 0x1901,
+	CL_DEPTH_COMPONENT              = 0x1902,
+	CL_RED                          = 0x1903,
+	CL_GREEN                        = 0x1904,
+	CL_BLUE                         = 0x1905,
+	CL_ALPHA                        = 0x1906,
+	CL_RGB                          = 0x1907,
+	CL_RGBA                         = 0x1908,
+	CL_LUMINANCE                    = 0x1909,
+	CL_LUMINANCE_ALPHA              = 0x190A,
+	// CL_ABGR
+
+	// PixelInternalFormat:
+
+	// CL_ALPHA4
+	// CL_ALPHA8
+	// CL_ALPHA12
+	// CL_ALPHA16
+	// CL_LUMINANCE4
+	// CL_LUMINANCE8
+	// CL_LUMINANCE12
+	// CL_LUMINANCE16
+	// CL_LUMINANCE4_ALPHA4
+	// CL_LUMINANCE6_ALPHA2
+	// CL_LUMINANCE8_ALPHA8
+	// CL_LUMINANCE12_ALPHA4
+	// CL_LUMINANCE12_ALPHA12
+	// CL_LUMINANCE16_ALPHA16
+	// CL_INTENSITY
+	// CL_INTENSITY4
+	// CL_INTENSITY8
+	// CL_INTENSITY12
+	// CL_INTENSITY16
+	// CL_R3_G3_B2
+	// CL_RGB4
+	// CL_RGB5
+	// CL_RGB8
+	// CL_RGB10
+	// CL_RGB12
+	// CL_RGB16
+	// CL_RGBA2
+	// CL_RGBA4
+	// CL_RGB5_A1
+	// CL_RGBA8
+	// CL_RGB10_A2
+	// CL_RGBA12
+	// CL_RGBA16
+
+	// PixelMap:
+
+	// CL_PIXEL_MAP_I_TO_I
+	// CL_PIXEL_MAP_S_TO_S
+	// CL_PIXEL_MAP_I_TO_R
+	// CL_PIXEL_MAP_I_TO_G
+	// CL_PIXEL_MAP_I_TO_B
+	// CL_PIXEL_MAP_I_TO_A
+	// CL_PIXEL_MAP_R_TO_R
+	// CL_PIXEL_MAP_G_TO_G
+	// CL_PIXEL_MAP_B_TO_B
+	// CL_PIXEL_MAP_A_TO_A
+
+	// PixelStore:
+
+	// CL_UNPACK_SWAP_BYTES
+	// CL_UNPACK_LSB_FIRST
+	// CL_UNPACK_ROW_LENGTH
+	// CL_UNPACK_SKIP_ROWS
+	// CL_UNPACK_SKIP_PIXELS
+	// CL_UNPACK_ALIGNMENT
+	// CL_PACK_SWAP_BYTES
+	// CL_PACK_LSB_FIRST
+	// CL_PACK_ROW_LENGTH
+	// CL_PACK_SKIP_ROWS
+	// CL_PACK_SKIP_PIXELS
+	// CL_PACK_ALIGNMENT
+	// CL_PACK_SKIP_IMAGES
+	// CL_PACK_IMAGE_HEIGHT
+	// CL_UNPACK_SKIP_IMAGES
+	// CL_UNPACK_IMAGE_HEIGHT
+
+	// PixelTransfer:
+
+	// CL_MAP_COLOR
+	// CL_MAP_STENCIL
+	// CL_INDEX_SHIFT
+	// CL_INDEX_OFFSET
+	// CL_RED_SCALE
+	// CL_RED_BIAS
+	// CL_GREEN_SCALE
+	// CL_GREEN_BIAS
+	// CL_BLUE_SCALE
+	// CL_BLUE_BIAS
+	// CL_ALPHA_SCALE
+	// CL_ALPHA_BIAS
+	// CL_DEPTH_SCALE
+	// CL_DEPTH_BIAS
+	// CL_POST_CONVOLUTION_RED_SCALE
+	// CL_POST_CONVOLUTION_GREEN_SCALE
+	// CL_POST_CONVOLUTION_BLUE_SCALE
+	// CL_POST_CONVOLUTION_ALPHA_SCALE
+	// CL_POST_CONVOLUTION_RED_BIAS
+	// CL_POST_CONVOLUTION_GREEN_BIAS
+	// CL_POST_CONVOLUTION_BLUE_BIAS
+	// CL_POST_CONVOLUTION_ALPHA_BIAS
+	// CL_POST_COLOR_MATRIX_RED_SCALE
+	// CL_POST_COLOR_MATRIX_GREEN_SCALE
+	// CL_POST_COLOR_MATRIX_BLUE_SCALE
+	// CL_POST_COLOR_MATRIX_ALPHA_SCALE
+	// CL_POST_COLOR_MATRIX_RED_BIAS
+	// CL_POST_COLOR_MATRIX_GREEN_BIAS
+	// CL_POST_COLOR_MATRIX_BLUE_BIAS
+	// CL_POST_COLOR_MATRIX_ALPHA_BIAS
+
+	// PixelType:
+
+	CL_BITMAP                       = 0x1A00,
+	// CL_BYTE
+	// CL_UNSIGNED_BYTE
+	// CL_SHORT
+	// CL_UNSIGNED_SHORT
+	// CL_INT
+	// CL_UNSIGNED_INT
+	// CL_FLOAT
+	// CL_BGR
+	// CL_BGRA
+	// CL_UNSIGNED_BYTE_3_3_2
+	// CL_UNSIGNED_SHORT_4_4_4_4
+	// CL_UNSIGNED_SHORT_5_5_5_1
+	// CL_UNSIGNED_INT_8_8_8_8
+	// CL_UNSIGNED_INT_10_10_10_2
+	// CL_UNSIGNED_SHORT_5_6_5
+	// CL_UNSIGNED_BYTE_2_3_3_REV
+	// CL_UNSIGNED_SHORT_5_6_5_REV
+	// CL_UNSIGNED_SHORT_4_4_4_4_REV
+	// CL_UNSIGNED_SHORT_1_5_5_5_REV
+	// CL_UNSIGNED_INT_8_8_8_8_REV
+	// CL_UNSIGNED_INT_2_10_10_10_REV
+
+	// PolygonMode:
+
+	CL_POINT                        = 0x1B00,
+	CL_LINE                         = 0x1B01,
+	CL_FILL                         = 0x1B02,
+
+	// ReadBufferMode:
+
+	// CL_FRONT_LEFT
+	// CL_FRONT_RIGHT
+	// CL_BACK_LEFT
+	// CL_BACK_RIGHT
+	// CL_FRONT
+	// CL_BACK
+	// CL_LEFT
+	// CL_RIGHT
+	// CL_AUX0
+	// CL_AUX1
+	// CL_AUX2
+	// CL_AUX3
+
+	// RenderingMode:
+
+	CL_RENDER                       = 0x1C00,
+	CL_FEEDBACK                     = 0x1C01,
+	CL_SELECT                       = 0x1C02,
+
+	// SeparableTarget:
+
+	// CL_SEPARABLE_2D
+
+	// ShadingModel:
+
+	CL_FLAT                         = 0x1D00,
+	CL_SMOOTH                       = 0x1D01,
+
+	// StencilFunction:
+
+	// CL_NEVER
+	// CL_LESS
+	// CL_EQUAL
+	// CL_LEQUAL
+	// CL_GREATER
+	// CL_NOTEQUAL
+	// CL_GEQUAL
+	// CL_ALWAYS
+
+	// StencilOp:
+
+	// CL_ZERO
+	CL_KEEP                         = 0x1E00,
+	CL_REPLACE                      = 0x1E01,
+	CL_INCR                         = 0x1E02,
+	CL_DECR                         = 0x1E03,
+	// CL_INVERT
+
+	// StringName:
+
+	CL_VENDOR                       = 0x1F00,
+	CL_RENDERER                     = 0x1F01,
+	CL_VERSION                      = 0x1F02,
+	CL_EXTENSIONS                   = 0x1F03,
+
+	// TextureCoordName:
+
+	CL_S                            = 0x2000,
+	CL_T                            = 0x2001,
+	CL_R                            = 0x2002,
+	CL_Q                            = 0x2003,
+
+	// TexCoordPointerType:
+
+	// CL_SHORT
+	// CL_INT
+	// CL_FLOAT
+	// CL_DOUBLE
+
+	// TextureEnvMode:
+
+	CL_MODULATE                     = 0x2100,
+	CL_DECAL                        = 0x2101,
+	// CL_BLEND
+	// CL_REPLACE
+
+	// TextureEnvParameter:
+
+	CL_TEXTURE_ENV_MODE             = 0x2200,
+	CL_TEXTURE_ENV_COLOR            = 0x2201,
+
+	// TextureEnvTarget:
+
+	CL_TEXTURE_ENV                  = 0x2300,
+
+	// TextureGenMode:
+
+	CL_EYE_LINEAR                   = 0x2400,
+	CL_OBJECT_LINEAR                = 0x2401,
+	CL_SPHERE_MAP                   = 0x2402,
+
+	// TextureGenParameter:
+
+	CL_TEXTURE_GEN_MODE             = 0x2500,
+	CL_OBJECT_PLANE                 = 0x2501,
+	CL_EYE_PLANE                    = 0x2502,
+
+	// TextureMagFilter:
+
+	CL_NEAREST                      = 0x2600,
+	CL_LINEAR                       = 0x2601,
+
+	// TextureMinFilter:
+
+	// CL_NEAREST
+	// CL_LINEAR
+	CL_NEAREST_MIPMAP_NEAREST       = 0x2700,
+	CL_LINEAR_MIPMAP_NEAREST        = 0x2701,
+	CL_NEAREST_MIPMAP_LINEAR        = 0x2702,
+	CL_LINEAR_MIPMAP_LINEAR         = 0x2703,
+
+	// TextureParameterName:
+
+	CL_TEXTURE_MAG_FILTER           = 0x2800,
+	CL_TEXTURE_MIN_FILTER           = 0x2801,
+	CL_TEXTURE_WRAP_S               = 0x2802,
+	CL_TEXTURE_WRAP_T               = 0x2803,
+	// CL_TEXTURE_BORDER_COLOR
+	// CL_TEXTURE_PRIORITY
+	// CL_TEXTURE_WRAP_R
+	// CL_TEXTURE_MIN_LOD
+	// CL_TEXTURE_MAX_LOD
+	// CL_TEXTURE_BASE_LEVEL
+	// CL_TEXTURE_MAX_LEVEL
+
+	// TextureTarget:
+
+	// CL_TEXTURE_1D
+	// CL_TEXTURE_2D
+	// CL_PROXY_TEXTURE_1D
+	// CL_PROXY_TEXTURE_2D
+	// CL_TEXTURE_3D
+	// CL_PROXY_TEXTURE_3D
+
+	// TextureUnit:
+
+	// CL_TEXTURE0
+	// CL_TEXTURE1
+	// CL_TEXTURE2
+	// CL_TEXTURE3
+	// CL_TEXTURE4
+	// CL_TEXTURE5
+	// CL_TEXTURE6
+	// CL_TEXTURE7
+	// CL_TEXTURE8
+	// CL_TEXTURE9
+	// CL_TEXTURE10
+	// CL_TEXTURE11
+	// CL_TEXTURE12
+	// CL_TEXTURE13
+	// CL_TEXTURE14
+	// CL_TEXTURE15
+	// CL_TEXTURE16
+	// CL_TEXTURE17
+	// CL_TEXTURE18
+	// CL_TEXTURE19
+	// CL_TEXTURE20
+	// CL_TEXTURE21
+	// CL_TEXTURE22
+	// CL_TEXTURE23
+	// CL_TEXTURE24
+	// CL_TEXTURE25
+	// CL_TEXTURE26
+	// CL_TEXTURE27
+	// CL_TEXTURE28
+	// CL_TEXTURE29
+	// CL_TEXTURE30
+	// CL_TEXTURE31
+
+	// TextureWrapMode:
+
+	CL_CLAMP                        = 0x2900,
+	CL_REPEAT                       = 0x2901,
+	// CL_CLAMP_TO_EDGE
+
+	// VertexPointerType:
+
+	// CL_SHORT
+	// CL_INT
+	// CL_FLOAT
+	// CL_DOUBLE
+
+	// ClientAttribMask:
+
+	CL_CLIENT_PIXEL_STORE_BIT       = 0x00000001,
+	CL_CLIENT_VERTEX_ARRAY_BIT      = 0x00000002,
+	CL_CLIENT_ALL_ATTRIB_BITS       = 0xffffffff,
+
+	// polygon_offset:
+
+	CL_POLYGON_OFFSET_FACTOR        = 0x8038,
+	CL_POLYGON_OFFSET_UNITS         = 0x2A00,
+	CL_POLYGON_OFFSET_POINT         = 0x2A01,
+	CL_POLYGON_OFFSET_LINE          = 0x2A02,
+	CL_POLYGON_OFFSET_FILL          = 0x8037,
+
+	// texture:
+
+	CL_ALPHA4                       = 0x803B,
+	CL_ALPHA8                       = 0x803C,
+	CL_ALPHA12                      = 0x803D,
+	CL_ALPHA16                      = 0x803E,
+	CL_LUMINANCE4                   = 0x803F,
+	CL_LUMINANCE8                   = 0x8040,
+	CL_LUMINANCE12                  = 0x8041,
+	CL_LUMINANCE16                  = 0x8042,
+	CL_LUMINANCE4_ALPHA4            = 0x8043,
+	CL_LUMINANCE6_ALPHA2            = 0x8044,
+	CL_LUMINANCE8_ALPHA8            = 0x8045,
+	CL_LUMINANCE12_ALPHA4           = 0x8046,
+	CL_LUMINANCE12_ALPHA12          = 0x8047,
+	CL_LUMINANCE16_ALPHA16          = 0x8048,
+	CL_INTENSITY                    = 0x8049,
+	CL_INTENSITY4                   = 0x804A,
+	CL_INTENSITY8                   = 0x804B,
+	CL_INTENSITY12                  = 0x804C,
+	CL_INTENSITY16                  = 0x804D,
+	CL_R3_G3_B2                     = 0x2A10,
+	CL_RGB4                         = 0x804F,
+	CL_RGB5                         = 0x8050,
+	CL_RGB8                         = 0x8051,
+	CL_RGB10                        = 0x8052,
+	CL_RGB12                        = 0x8053,
+	CL_RGB16                        = 0x8054,
+	CL_RGBA2                        = 0x8055,
+	CL_RGBA4                        = 0x8056,
+	CL_RGB5_A1                      = 0x8057,
+	CL_RGBA8                        = 0x8058,
+	CL_RGB10_A2                     = 0x8059,
+	CL_RGBA12                       = 0x805A,
+	CL_RGBA16                       = 0x805B,
+	CL_TEXTURE_RED_SIZE             = 0x805C,
+	CL_TEXTURE_GREEN_SIZE           = 0x805D,
+	CL_TEXTURE_BLUE_SIZE            = 0x805E,
+	CL_TEXTURE_ALPHA_SIZE           = 0x805F,
+	CL_TEXTURE_LUMINANCE_SIZE       = 0x8060,
+	CL_TEXTURE_INTENSITY_SIZE       = 0x8061,
+	CL_PROXY_TEXTURE_1D             = 0x8063,
+	CL_PROXY_TEXTURE_2D             = 0x8064,
+
+	// texture_object:
+
+	CL_TEXTURE_PRIORITY             = 0x8066,
+	CL_TEXTURE_RESIDENT             = 0x8067,
+	CL_TEXTURE_BINDING_1D           = 0x8068,
+	CL_TEXTURE_1D_BINDING           = 0x8068,
+	CL_TEXTURE_BINDING_2D           = 0x8069,
+	CL_TEXTURE_2D_BINDING           = 0x8069,
+	CL_TEXTURE_BINDING_3D           = 0x806A,
+	CL_TEXTURE_3D_BINDING           = 0x806A,
+
+	// vertex_array:
+	
+	CL_VERTEX_ARRAY                 = 0x8074,
+	CL_NORMAL_ARRAY                 = 0x8075,
+	CL_COLOR_ARRAY                  = 0x8076,
+	CL_INDEX_ARRAY                  = 0x8077,
+	CL_TEXTURE_COORD_ARRAY          = 0x8078,
+	CL_EDGE_FLAG_ARRAY              = 0x8079,
+	CL_VERTEX_ARRAY_SIZE            = 0x807A,
+	CL_VERTEX_ARRAY_TYPE            = 0x807B,
+	CL_VERTEX_ARRAY_STRIDE          = 0x807C,
+	CL_NORMAL_ARRAY_TYPE            = 0x807E,
+	CL_NORMAL_ARRAY_STRIDE          = 0x807F,
+	CL_COLOR_ARRAY_SIZE             = 0x8081,
+	CL_COLOR_ARRAY_TYPE             = 0x8082,
+	CL_COLOR_ARRAY_STRIDE           = 0x8083,
+	CL_INDEX_ARRAY_TYPE             = 0x8085,
+	CL_INDEX_ARRAY_STRIDE           = 0x8086,
+	CL_TEXTURE_COORD_ARRAY_SIZE     = 0x8088,
+	CL_TEXTURE_COORD_ARRAY_TYPE     = 0x8089,
+	CL_TEXTURE_COORD_ARRAY_STRIDE   = 0x808A,
+	CL_EDGE_FLAG_ARRAY_STRIDE       = 0x808C,
+	CL_VERTEX_ARRAY_POINTER         = 0x808E,
+	CL_NORMAL_ARRAY_POINTER         = 0x808F,
+	CL_COLOR_ARRAY_POINTER          = 0x8090,
+	CL_INDEX_ARRAY_POINTER          = 0x8091,
+	CL_TEXTURE_COORD_ARRAY_POINTER  = 0x8092,
+	CL_EDGE_FLAG_ARRAY_POINTER      = 0x8093,
+	CL_V2F                          = 0x2A20,
+	CL_V3F                          = 0x2A21,
+	CL_C4UB_V2F                     = 0x2A22,
+	CL_C4UB_V3F                     = 0x2A23,
+	CL_C3F_V3F                      = 0x2A24,
+	CL_N3F_V3F                      = 0x2A25,
+	CL_C4F_N3F_V3F                  = 0x2A26,
+	CL_T2F_V3F                      = 0x2A27,
+	CL_T4F_V4F                      = 0x2A28,
+	CL_T2F_C4UB_V3F                 = 0x2A29,
+	CL_T2F_C3F_V3F                  = 0x2A2A,
+	CL_T2F_N3F_V3F                  = 0x2A2B,
+	CL_T2F_C4F_N3F_V3F              = 0x2A2C,
+	CL_T4F_C4F_N3F_V4F              = 0x2A2D,
+
+	// bgra
+
+	CL_BGR                          = 0x80E0,
+	CL_BGRA                         = 0x80E1,
+
+	// blend_color
+
+	CL_CONSTANT_COLOR               = 0x8001,
+	CL_ONE_MINUS_CONSTANT_COLOR     = 0x8002,
+	CL_CONSTANT_ALPHA               = 0x8003,
+	CL_ONE_MINUS_CONSTANT_ALPHA     = 0x8004,
+	CL_BLEND_COLOR                  = 0x8005,
+
+	// blend_minmax
+
+	CL_FUNC_ADD                     = 0x8006,
+	CL_MIN                          = 0x8007,
+	CL_MAX                          = 0x8008,
+	CL_BLEND_EQUATION               = 0x8009,
+
+	// blend_subtract
+
+	CL_FUNC_SUBTRACT                = 0x800A,
+	CL_FUNC_REVERSE_SUBTRACT        = 0x800B,
+
+	// color_matrix
+
+	CL_COLOR_MATRIX                 = 0x80B1,
+	CL_COLOR_MATRIX_STACK_DEPTH     = 0x80B2,
+	CL_MAX_COLOR_MATRIX_STACK_DEPTH = 0x80B3,
+	CL_POST_COLOR_MATRIX_RED_SCALE  = 0x80B4,
+	CL_POST_COLOR_MATRIX_GREEN_SCALE= 0x80B5,
+	CL_POST_COLOR_MATRIX_BLUE_SCALE = 0x80B6,
+	CL_POST_COLOR_MATRIX_ALPHA_SCALE= 0x80B7,
+	CL_POST_COLOR_MATRIX_RED_BIAS   = 0x80B8,
+	CL_POST_COLOR_MATRIX_GREEN_BIAS = 0x80B9,
+	CL_POST_COLOR_MATRIX_BLUE_BIAS  = 0x80BA,
+	CL_POST_COLOR_MATRIX_ALPHA_BIAS = 0x80BB,
+
+	// color_table
+
+	CL_COLOR_TABLE                  = 0x80D0,
+	CL_POST_CONVOLUTION_COLOR_TABLE = 0x80D1,
+	CL_POST_COLOR_MATRIX_COLOR_TABLE= 0x80D2,
+	CL_PROXY_COLOR_TABLE            = 0x80D3,
+	CL_PROXY_POST_CONVOLUTION_COLOR_TABLE = 0x80D4,
+	CL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE = 0x80D5,
+	CL_COLOR_TABLE_SCALE            = 0x80D6,
+	CL_COLOR_TABLE_BIAS             = 0x80D7,
+	CL_COLOR_TABLE_FORMAT           = 0x80D8,
+	CL_COLOR_TABLE_WIDTH            = 0x80D9,
+	CL_COLOR_TABLE_RED_SIZE         = 0x80DA,
+	CL_COLOR_TABLE_GREEN_SIZE       = 0x80DB,
+	CL_COLOR_TABLE_BLUE_SIZE        = 0x80DC,
+	CL_COLOR_TABLE_ALPHA_SIZE       = 0x80DD,
+	CL_COLOR_TABLE_LUMINANCE_SIZE   = 0x80DE,
+	CL_COLOR_TABLE_INTENSITY_SIZE   = 0x80DF,
+
+	// convolution
+
+	CL_CONVOLUTION_1D               = 0x8010,
+	CL_CONVOLUTION_2D               = 0x8011,
+	CL_SEPARABLE_2D                 = 0x8012,
+	CL_CONVOLUTION_BORDER_MODE      = 0x8013,
+	CL_CONVOLUTION_FILTER_SCALE     = 0x8014,
+	CL_CONVOLUTION_FILTER_BIAS      = 0x8015,
+	CL_REDUCE                       = 0x8016,
+	CL_CONVOLUTION_FORMAT           = 0x8017,
+	CL_CONVOLUTION_WIDTH            = 0x8018,
+	CL_CONVOLUTION_HEIGHT           = 0x8019,
+	CL_MAX_CONVOLUTION_WIDTH        = 0x801A,
+	CL_MAX_CONVOLUTION_HEIGHT       = 0x801B,
+	CL_POST_CONVOLUTION_RED_SCALE   = 0x801C,
+	CL_POST_CONVOLUTION_GREEN_SCALE = 0x801D,
+	CL_POST_CONVOLUTION_BLUE_SCALE  = 0x801E,
+	CL_POST_CONVOLUTION_ALPHA_SCALE = 0x801F,
+	CL_POST_CONVOLUTION_RED_BIAS    = 0x8020,
+	CL_POST_CONVOLUTION_GREEN_BIAS  = 0x8021,
+	CL_POST_CONVOLUTION_BLUE_BIAS   = 0x8022,
+	CL_POST_CONVOLUTION_ALPHA_BIAS  = 0x8023,
+	CL_CONSTANT_BORDER              = 0x8151,
+	CL_REPLICATE_BORDER             = 0x8153,
+	CL_CONVOLUTION_BORDER_COLOR     = 0x8154,
+
+	// draw_range_elements
+
+	CL_MAX_ELEMENTS_VERTICES        = 0x80E8,
+	CL_MAX_ELEMENTS_INDICES         = 0x80E9,
+
+	// histogram
+
+	CL_HISTOGRAM                    = 0x8024,
+	CL_PROXY_HISTOGRAM              = 0x8025,
+	CL_HISTOGRAM_WIDTH              = 0x8026,
+	CL_HISTOGRAM_FORMAT             = 0x8027,
+	CL_HISTOGRAM_RED_SIZE           = 0x8028,
+	CL_HISTOGRAM_GREEN_SIZE         = 0x8029,
+	CL_HISTOGRAM_BLUE_SIZE          = 0x802A,
+	CL_HISTOGRAM_ALPHA_SIZE         = 0x802B,
+	CL_HISTOGRAM_LUMINANCE_SIZE     = 0x802C,
+	CL_HISTOGRAM_SINK               = 0x802D,
+	CL_MINMAX                       = 0x802E,
+	CL_MINMAX_FORMAT                = 0x802F,
+	CL_MINMAX_SINK                  = 0x8030,
+	CL_TABLE_TOO_LARGE              = 0x8031,
+
+	// packed_pixels
+
+	CL_UNSIGNED_BYTE_3_3_2          = 0x8032,
+	CL_UNSIGNED_SHORT_4_4_4_4       = 0x8033,
+	CL_UNSIGNED_SHORT_5_5_5_1       = 0x8034,
+	CL_UNSIGNED_INT_8_8_8_8         = 0x8035,
+	CL_UNSIGNED_INT_10_10_10_2      = 0x8036,
+	CL_UNSIGNED_BYTE_2_3_3_REV      = 0x8362,
+	CL_UNSIGNED_SHORT_5_6_5         = 0x8363,
+	CL_UNSIGNED_SHORT_5_6_5_REV     = 0x8364,
+	CL_UNSIGNED_SHORT_4_4_4_4_REV   = 0x8365,
+	CL_UNSIGNED_SHORT_1_5_5_5_REV   = 0x8366,
+	CL_UNSIGNED_INT_8_8_8_8_REV     = 0x8367,
+	CL_UNSIGNED_INT_2_10_10_10_REV  = 0x8368,
+
+	CL_MIRRORED_REPEAT              = 0x8370,
+
+	// rescale_normal
+
+	CL_RESCALE_NORMAL               = 0x803A,
+
+	// separate_specular_color
+
+	CL_LIGHT_MODEL_COLOR_CONTROL    = 0x81F8,
+	CL_SINGLE_COLOR                 = 0x81F9,
+	CL_SEPARATE_SPECULAR_COLOR      = 0x81FA,
+
+	// texture3D
+
+	CL_PACK_SKIP_IMAGES             = 0x806B,
+	CL_PACK_IMAGE_HEIGHT            = 0x806C,
+	CL_UNPACK_SKIP_IMAGES           = 0x806D,
+	CL_UNPACK_IMAGE_HEIGHT          = 0x806E,
+	CL_TEXTURE_3D                   = 0x806F,
+	CL_PROXY_TEXTURE_3D             = 0x8070,
+	CL_TEXTURE_DEPTH                = 0x8071,
+	CL_TEXTURE_WRAP_R               = 0x8072,
+	CL_MAX_3D_TEXTURE_SIZE          = 0x8073,
+
+	// texture_edge_clamp
+
+	CL_CLAMP_TO_BORDER              = 0x812D,
+	CL_CLAMP_TO_EDGE                = 0x812F,
+
+	// texture_lod
+
+	CL_TEXTURE_MIN_LOD              = 0x813A,
+	CL_TEXTURE_MAX_LOD              = 0x813B,
+	CL_TEXTURE_BASE_LEVEL           = 0x813C,
+	CL_TEXTURE_MAX_LEVEL            = 0x813D,
+
+	// GetTarget1_2:
+
+	CL_SMOOTH_POINT_SIZE_RANGE      = 0x0B12,
+	CL_SMOOTH_POINT_SIZE_GRANULARITY= 0x0B13,
+	CL_SMOOTH_LINE_WIDTH_RANGE      = 0x0B22,
+	CL_SMOOTH_LINE_WIDTH_GRANULARITY= 0x0B23,
+	CL_ALIASED_POINT_SIZE_RANGE     = 0x846D,
+	CL_ALIASED_LINE_WIDTH_RANGE     = 0x846E,
+
+	// multitexture:
+
+	CL_TEXTURE0                 = 0x84C0,
+	CL_TEXTURE1                 = 0x84C1,
+	CL_TEXTURE2                 = 0x84C2,
+	CL_TEXTURE3                 = 0x84C3,
+	CL_TEXTURE4                 = 0x84C4,
+	CL_TEXTURE5                 = 0x84C5,
+	CL_TEXTURE6                 = 0x84C6,
+	CL_TEXTURE7                 = 0x84C7,
+	CL_TEXTURE8                 = 0x84C8,
+	CL_TEXTURE9                 = 0x84C9,
+	CL_TEXTURE10                = 0x84CA,
+	CL_TEXTURE11                = 0x84CB,
+	CL_TEXTURE12                = 0x84CC,
+	CL_TEXTURE13                = 0x84CD,
+	CL_TEXTURE14                = 0x84CE,
+	CL_TEXTURE15                = 0x84CF,
+	CL_TEXTURE16                = 0x84D0,
+	CL_TEXTURE17                = 0x84D1,
+	CL_TEXTURE18                = 0x84D2,
+	CL_TEXTURE19                = 0x84D3,
+	CL_TEXTURE20                = 0x84D4,
+	CL_TEXTURE21                = 0x84D5,
+	CL_TEXTURE22                = 0x84D6,
+	CL_TEXTURE23                = 0x84D7,
+	CL_TEXTURE24                = 0x84D8,
+	CL_TEXTURE25                = 0x84D9,
+	CL_TEXTURE26                = 0x84DA,
+	CL_TEXTURE27                = 0x84DB,
+	CL_TEXTURE28                = 0x84DC,
+	CL_TEXTURE29                = 0x84DD,
+	CL_TEXTURE30                = 0x84DE,
+	CL_TEXTURE31                = 0x84DF,
+	CL_ACTIVE_TEXTURE           = 0x84E0,
+	CL_CLIENT_ACTIVE_TEXTURE    = 0x84E1,
+	CL_MAX_TEXTURE_UNITS        = 0x84E2,
+
+	// EXT_abgr:
+
+	CL_ABGR                     = 0x8000,
+
+	// EXT_blend_color:
+
+	// CL_CONSTANT_COLOR           = 0x8001,
+	// CL_ONE_MINUS_CONSTANT_COLOR = 0x8002,
+	// CL_CONSTANT_ALPHA           = 0x8003,
+	// CL_ONE_MINUS_CONSTANT_ALPHA = 0x8004,
+	// CL_BLEND_COLOR              = 0x8005,
+
+	// EXT_blend_minmax:
+
+	// CL_FUNC_ADD                 = 0x8006,
+	// CL_MIN                      = 0x8007,
+	// CL_MAX                      = 0x8008,
+	// CL_BLEND_EQUATION           = 0x8009,
+
+	// EXT_blend_subtract:
+
+	// CL_FUNC_SUBTRACT            = 0x800A,
+	// CL_FUNC_REVERSE_SUBTRACT    = 0x800B,
+
+	// EXT_texture_env_combine:
+
+	CL_COMBINE                  = 0x8570,
+	CL_COMBINE_RGB              = 0x8571,
+	CL_COMBINE_ALPHA            = 0x8572,
+	CL_RGB_SCALE                = 0x8573,
+	CL_ADD_SIGNED               = 0x8574,
+	CL_INTERPOLATE              = 0x8575,
+	CL_CONSTANT                 = 0x8576,
+	CL_PRIMARY_COLOR            = 0x8577,
+	CL_PREVIOUS                 = 0x8578,
+	CL_SOURCE0_RGB              = 0x8580,
+	CL_SOURCE1_RGB              = 0x8581,
+	CL_SOURCE2_RGB              = 0x8582,
+	CL_SOURCE0_ALPHA            = 0x8588,
+	CL_SOURCE1_ALPHA            = 0x8589,
+	CL_SOURCE2_ALPHA            = 0x858A,
+	CL_OPERAND0_RGB             = 0x8590,
+	CL_OPERAND1_RGB             = 0x8591,
+	CL_OPERAND2_RGB             = 0x8592,
+	CL_OPERAND0_ALPHA           = 0x8598,
+	CL_OPERAND1_ALPHA           = 0x8599,
+	CL_OPERAND2_ALPHA           = 0x859A,
+
+	// OpenGL 1.5 token renames:
+	CL_SRC0_RGB                 = CL_SOURCE0_RGB,
+	CL_SRC1_RGB                 = CL_SOURCE1_RGB,
+	CL_SRC2_RGB                 = CL_SOURCE2_RGB,
+	CL_SRC0_ALPHA               = CL_SOURCE0_ALPHA,
+	CL_SRC1_ALPHA               = CL_SOURCE1_ALPHA,
+	CL_SRC2_ALPHA               = CL_SOURCE2_ALPHA,
+
+	// ARB_texture_compression:
+
+	CL_COMPRESSED_ALPHA           = 0x84e9,
+	CL_COMPRESSED_LUMINANCE       = 0x84ea,
+	CL_COMPRESSED_LUMINANCE_ALPHA = 0x84eb,
+	CL_COMPRESSED_INTENSITY       = 0x84ec,
+	CL_COMPRESSED_RGB             = 0x84ed,
+	CL_COMPRESSED_RGBA            = 0x84ee,
+	CL_TEXTURE_COMPRESSION_HINT   = 0x84ef,
+	CL_TEXTURE_COMPRESSED_IMAGE_SIZE = 0x86a0,
+	CL_TEXTURE_COMPRESSED         = 0x86a1,
+	CL_NUM_COMPRESSED_TEXTURE_FORMATS = 0x86a2,
+	CL_COMPRESSED_TEXTURE_FORMATS = 0x86a3,
+
+	// ARB_texture_cube_map:
+
+	CL_NORMAL_MAP                 = 0x8511,
+	CL_REFLECTION_MAP             = 0x8512,
+	CL_TEXTURE_CUBE_MAP           = 0x8513,
+	CL_TEXTURE_BINDING_CUBE_MAP   = 0x8514,
+	CL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515,
+	CL_TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516,
+	CL_TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517,
+	CL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518,
+	CL_TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519,
+	CL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851a,
+	CL_PROXY_TEXTURE_CUBE_MAP     = 0x851b,
+	CL_MAX_CUBE_MAP_TEXTURE_SIZE  = 0x851c,
+
+	// ARB_multisample:
+
+	CL_MULTISAMPLE                = 0x809d,
+	CL_SAMPLE_ALPHA_TO_COVERAGE   = 0x809e,
+	CL_SAMPLE_ALPHA_TO_ONE        = 0x809f,
+	CL_SAMPLE_COVERAGE            = 0x80a0,
+	CL_SAMPLE_BUFFERS             = 0x80a8,
+	CL_SAMPLES                    = 0x80a9,
+	CL_SAMPLE_COVERAGE_VALUE      = 0x80aa,
+	CL_SAMPLE_COVERAGE_INVERT     = 0x80ab,
+	CL_MULTISAMPLE_BIT            = 0x20000000,
+
+	// ARB_texture_env_combine:
+
+	CL_SUBTRACT                   = 0x84e7,
+	// CL_COMBINE                    = 0x8570,
+	// CL_COMBINE_RGB                = 0x8571,
+	// CL_COMBINE_ALPHA              = 0x8572,
+	// CL_RGB_SCALE                  = 0x8573,
+	// CL_ADD_SIGNED                 = 0x8574,
+	// CL_INTERPOLATE                = 0x8575,
+	// CL_CONSTANT                   = 0x8576,
+	// CL_PRIMARY_COLOR              = 0x8577,
+	// CL_PREVIOUS                   = 0x8578,
+	// CL_SOURCE0_RGB                = 0x8580,
+	// CL_SOURCE1_RGB                = 0x8581,
+	// CL_SOURCE2_RGB                = 0x8582,
+	// CL_SOURCE0_ALPHA              = 0x8588,
+	// CL_SOURCE1_ALPHA              = 0x8589,
+	// CL_SOURCE2_ALPHA              = 0x858a,
+	// CL_OPERAND0_RGB               = 0x8590,
+	// CL_OPERAND1_RGB               = 0x8591,
+	// CL_OPERAND2_RGB               = 0x8592,
+	// CL_OPERAND0_ALPHA             = 0x8598,
+	// CL_OPERAND1_ALPHA             = 0x8599,
+	// CL_OPERAND2_ALPHA             = 0x859a,
+
+	// ARB_texture_env_dot3:
+
+	CL_DOT3_RGB                   = 0x86ae,
+	CL_DOT3_RGBA                  = 0x86af,
+
+	// ARB_transpose_matrix:
+
+	CL_TRANSPOSE_MODELVIEW_MATRIX  = 0x84e3,
+	CL_TRANSPOSE_PROJECTION_MATRIX = 0x84e4,
+	CL_TRANSPOSE_TEXTURE_MATRIX    = 0x84e5,
+	CL_TRANSPOSE_COLOR_MATRIX      = 0x84e6,
+
+	// SGIS_generate_mipmap:
+
+	CL_GENERATE_MIPMAP             = 0x8191,
+	CL_GENERATE_MIPMAP_HINT        = 0x8192,
+
+	// ARB_depth_texture:
+
+	CL_DEPTH_COMPONENT16           = 0x81a5,
+	CL_DEPTH_COMPONENT24           = 0x81a6,
+	CL_DEPTH_COMPONENT32           = 0x81a7,
+	CL_TEXTURE_DEPTH_SIZE          = 0x884a,
+	CL_DEPTH_TEXTURE_MODE          = 0x884b,
+
+	// ARB_shadow:
+
+	CL_TEXTURE_COMPARE_MODE        = 0x884c,
+	CL_TEXTURE_COMPARE_FUNC        = 0x884d,
+	CL_COMPARE_R_TO_TEXTURE        = 0x884e,
+
+	// EXT_fog_coord:
+
+	CL_FOG_COORDINATE_SOURCE       = 0x8450,
+	CL_FOG_COORDINATE              = 0x8451,
+	CL_FRAGMENT_DEPTH              = 0x8452,
+	CL_CURRENT_FOG_COORDINATE      = 0x8453,
+	CL_FOG_COORDINATE_ARRAY_TYPE   = 0x8454,
+	CL_FOG_COORDINATE_ARRAY_STRIDE = 0x8455,
+	CL_FOG_COORDINATE_ARRAY_POINTER = 0x8456,
+	CL_FOG_COORDINATE_ARRAY        = 0x8457,
+	
+	// OpenGL 1.5 token renames:
+	CL_FOG_COORD_SRC               = CL_FOG_COORDINATE_SOURCE,
+	CL_FOG_COORD                   = CL_FOG_COORDINATE,
+	CL_CURRENT_FOG_COORD           = CL_CURRENT_FOG_COORDINATE,
+	CL_FOG_COORD_ARRAY_TYPE        = CL_FOG_COORDINATE_ARRAY_TYPE,
+	CL_FOG_COORD_ARRAY_STRIDE      = CL_FOG_COORDINATE_ARRAY_STRIDE,
+	CL_FOG_COORD_ARRAY_POINTER     = CL_FOG_COORDINATE_ARRAY_POINTER,
+	CL_FOG_COORD_ARRAY             = CL_FOG_COORDINATE_ARRAY,
+	
+	// ARB_point_parameters:
+
+	CL_POINT_SIZE_MIN              = 0x8126,
+	CL_POINT_SIZE_MAX_ARB          = 0x8127,
+	CL_POINT_FADE_THRESHOLD_SIZE   = 0x8128,
+	CL_POINT_DISTANCE_ATTENUATION  = 0x8129,
+
+	// EXT_secondary_color:
+
+	CL_COLOR_SUM                   = 0x8458,
+	CL_CURRENT_SECONDARY_COLOR     = 0x8459,
+	CL_SECONDARY_COLOR_ARRAY_SIZE  = 0x845a,
+	CL_SECONDARY_COLOR_ARRAY_TYPE  = 0x845b,
+	CL_SECONDARY_COLOR_ARRAY_STRIDE = 0x845c,
+	CL_SECONDARY_COLOR_ARRAY_POINTER = 0x845d,
+	CL_SECONDARY_COLOR_ARRAY       = 0x845e,
+
+	// EXT_blend_func_separate:
+
+	CL_BLEND_DST_RGB               = 0x80c8,
+	CL_BLEND_SRC_RGB               = 0x80c9,
+	CL_BLEND_DST_ALPHA             = 0x80ca,
+	CL_BLEND_SRC_ALPHA             = 0x80cb,
+
+	// EXT_stencil_wrap:
+
+	CL_INCR_WRAP                   = 0x8507,
+	CL_DECR_WRAP                   = 0x8508,
+
+	// EXT_texture_lod_bias:
+
+	CL_MAX_TEXTURE_LOD_BIAS        = 0x84fd,
+	CL_TEXTURE_FILTER_CONTROL      = 0x8500,
+	CL_TEXTURE_LOD_BIAS            = 0x8501,
+
+	// ARB_vertex_buffer_object:
+	
+	CL_ARRAY_BUFFER                        = 0x8892,
+	CL_ELEMENT_ARRAY_BUFFER                = 0x8893,
+	CL_ARRAY_BUFFER_BINDING                = 0x8894,
+	CL_ELEMENT_ARRAY_BUFFER_BINDING        = 0x8895,
+	CL_VERTEX_ARRAY_BUFFER_BINDING         = 0x8896,
+	CL_NORMAL_ARRAY_BUFFER_BINDING         = 0x8897,
+	CL_COLOR_ARRAY_BUFFER_BINDING          = 0x8898,
+	CL_INDEX_ARRAY_BUFFER_BINDING          = 0x8899,
+	CL_TEXTURE_COORD_ARRAY_BUFFER_BINDING  = 0x889A,
+	CL_EDGE_FLAG_ARRAY_BUFFER_BINDING      = 0x889B,
+	CL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING = 0x889C,
+	CL_FOG_COORDINATE_ARRAY_BUFFER_BINDING = 0x889D,
+	CL_FOG_COORD_ARRAY_BUFFER_BINDING      = CL_FOG_COORDINATE_ARRAY_BUFFER_BINDING,
+	CL_WEIGHT_ARRAY_BUFFER_BINDING         = 0x889E,
+	CL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING  = 0x889F,
+	CL_STREAM_DRAW                         = 0x88E0,
+	CL_STREAM_READ                         = 0x88E1,
+	CL_STREAM_COPY                         = 0x88E2,
+	CL_STATIC_DRAW                         = 0x88E4,
+	CL_STATIC_READ                         = 0x88E5,
+	CL_STATIC_COPY                         = 0x88E6,
+	CL_DYNAMIC_DRAW                        = 0x88E8,
+	CL_DYNAMIC_READ                        = 0x88E9,
+	CL_DYNAMIC_COPY                        = 0x88EA,
+	CL_READ_ONLY                           = 0x88B8,
+	CL_WRITE_ONLY                          = 0x88B9,
+	CL_READ_WRITE                          = 0x88BA,
+	CL_BUFFER_SIZE                         = 0x8764,
+	CL_BUFFER_USAGE                        = 0x8765,
+	CL_BUFFER_ACCESS                       = 0x88BB,
+	CL_BUFFER_MAPPED                       = 0x88BC,
+	CL_BUFFER_MAP_POINTER                  = 0x88BD,
+
+	// ARB_occlusion_query:
+
+	CL_SAMPLES_PASSED                      = 0x8914,
+	CL_QUERY_COUNTER_BITS                  = 0x8864,
+	CL_CURRENT_QUERY                       = 0x8865,
+	CL_QUERY_RESULT                        = 0x8866,
+	CL_QUERY_RESULT_AVAILABLE              = 0x8867,
+
+	// ARB_shader_objects:
+	
+	CL_PROGRAM_OBJECT                      = 0x8B40,
+	CL_TYPE                                = 0x8B4E,
+	CL_SUBTYPE                             = 0x8B4F,
+	CL_DELETE_STATUS                       = 0x8B80,
+	CL_COMPILE_STATUS                      = 0x8B81,
+	CL_LINK_STATUS                         = 0x8B82,
+	CL_VALIDATE_STATUS                     = 0x8B83,
+	CL_INFO_LOG_LENGTH                     = 0x8B84,
+	CL_ATTACHED_OBJECTS                    = 0x8B85,
+	CL_ACTIVE_UNIFORMS                     = 0x8B86,
+	CL_ACTIVE_UNIFORM_MAX_LENGTH           = 0x8B87,
+	CL_SHADER_SOURCE_LENGTH                = 0x8B88,
+	CL_OBJECT_TYPE                         = CL_TYPE,
+	CL_OBJECT_SUBTYPE                      = CL_SUBTYPE,
+	CL_OBJECT_DELETE_STATUS                = CL_DELETE_STATUS,
+	CL_OBJECT_COMPILE_STATUS               = CL_COMPILE_STATUS,
+	CL_OBJECT_LINK_STATUS                  = CL_LINK_STATUS,
+	CL_OBJECT_VALIDATE_STATUS              = CL_VALIDATE_STATUS,
+	CL_OBJECT_INFO_LOG_LENGTH              = CL_INFO_LOG_LENGTH,
+	CL_OBJECT_ATTACHED_OBJECTS             = CL_ATTACHED_OBJECTS,
+	CL_OBJECT_ACTIVE_UNIFORMS              = CL_ACTIVE_UNIFORMS,
+	CL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH    = CL_ACTIVE_UNIFORM_MAX_LENGTH,
+	CL_OBJECT_SHADER_SOURCE_LENGTH         = CL_SHADER_SOURCE_LENGTH,
+	CL_SHADER_OBJECT                       = 0x8B48,
+	// CL_FLOAT                               = 0x1406,
+	// CL_FLOAT_VEC2                          = 0x8B50,
+	// CL_FLOAT_VEC3                          = 0x8B51,
+	// CL_FLOAT_VEC4                          = 0x8B52,
+	// CL_INT                                 = 0x1404,
+	CL_INT_VEC2                            = 0x8B53,
+	CL_INT_VEC3                            = 0x8B54,
+	CL_INT_VEC4                            = 0x8B55,
+	CL_BOOL                                = 0x8B56,
+	CL_BOOL_VEC2                           = 0x8B57,
+	CL_BOOL_VEC3                           = 0x8B58,
+	CL_BOOL_VEC4                           = 0x8B59,
+	CL_FLOAT_MAT2                          = 0x8B5A,
+	CL_FLOAT_MAT3                          = 0x8B5B,
+	CL_FLOAT_MAT4                          = 0x8B5C,
+	CL_SAMPLER_1D                          = 0x8B5D,
+	CL_SAMPLER_2D                          = 0x8B5E,
+	CL_SAMPLER_3D                          = 0x8B5F,
+	CL_SAMPLER_CUBE                        = 0x8B60,
+	CL_SAMPLER_1D_SHADOW                   = 0x8B61,
+	CL_SAMPLER_2D_SHADOW                   = 0x8B62,
+	CL_SAMPLER_2D_RECT                     = 0x8B63,
+	CL_SAMPLER_2D_RECT_SHADOW              = 0x8B64,
+
+	// ARB_vertex_shader:
+
+	CL_VERTEX_SHADER                       = 0x8B31,
+	CL_MAX_VERTEX_UNIFORM_COMPONENTS       = 0x8B4A,
+	CL_MAX_VARYING_FLOATS                  = 0x8B4B,
+	CL_MAX_VERTEX_ATTRIBS                  = 0x8869,
+	CL_MAX_TEXTURE_IMAGE_UNITS             = 0x8872,
+	CL_MAX_VERTEX_TEXTURE_IMAGE_UNITS      = 0x8B4C,
+	CL_MAX_COMBINED_TEXTURE_IMAGE_UNITS    = 0x8B4D,
+	CL_MAX_TEXTURE_COORDS                  = 0x8871,
+	CL_VERTEX_PROGRAM_POINT_SIZE           = 0x8642,
+	CL_VERTEX_PROGRAM_TWO_SIDE             = 0x8643,
+	CL_ACTIVE_ATTRIBUTES                   = 0x8B89,
+	CL_ACTIVE_ATTRIBUTE_MAX_LENGTH         = 0x8B8A,
+	CL_OBJECT_ACTIVE_ATTRIBUTES            = CL_ACTIVE_ATTRIBUTES,
+	CL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH  = CL_ACTIVE_ATTRIBUTE_MAX_LENGTH,
+	CL_VERTEX_ATTRIB_ARRAY_ENABLED         = 0x8622,
+	CL_VERTEX_ATTRIB_ARRAY_SIZE            = 0x8623,
+	CL_VERTEX_ATTRIB_ARRAY_STRIDE          = 0x8624,
+	CL_VERTEX_ATTRIB_ARRAY_TYPE            = 0x8625,
+	CL_VERTEX_ATTRIB_ARRAY_NORMALIZED      = 0x886A,
+	CL_CURRENT_VERTEX_ATTRIB               = 0x8626,
+	CL_VERTEX_ATTRIB_ARRAY_POINTER         = 0x8645,
+	// CL_FLOAT                               = 0x1406,
+	CL_FLOAT_VEC2                          = 0x8B50,
+	CL_FLOAT_VEC3                          = 0x8B51,
+	CL_FLOAT_VEC4                          = 0x8B52,
+	// CL_FLOAT_MAT2                          = 0x8B5A,
+	// CL_FLOAT_MAT3                          = 0x8B5B,
+	// CL_FLOAT_MAT4                          = 0x8B5C,
+
+	// ARB_fragment_shader:
+
+	CL_FRAGMENT_SHADER                     = 0x8B30,
+	CL_MAX_FRAGMENT_UNIFORM_COMPONENTS     = 0x8B49,
+	// CL_MAX_TEXTURE_COORDS                  = 0x8871,
+	// CL_MAX_TEXTURE_IMAGE_UNITS             = 0x8872,
+	CL_FRAGMENT_SHADER_DERIVATIVE_HINT     = 0x8B8B,
+
+	// ARB_draw_buffers:
+
+	CL_MAX_DRAW_BUFFERS                    = 0x8824,
+	CL_DRAW_BUFFER0                        = 0x8825,
+	CL_DRAW_BUFFER1                        = 0x8826,
+	CL_DRAW_BUFFER2                        = 0x8827,
+	CL_DRAW_BUFFER3                        = 0x8828,
+	CL_DRAW_BUFFER4                        = 0x8829,
+	CL_DRAW_BUFFER5                        = 0x882A,
+	CL_DRAW_BUFFER6                        = 0x882B,
+	CL_DRAW_BUFFER7                        = 0x882C,
+	CL_DRAW_BUFFER8                        = 0x882D,
+	CL_DRAW_BUFFER9                        = 0x882E,
+	CL_DRAW_BUFFER10                       = 0x882F,
+	CL_DRAW_BUFFER11                       = 0x8830,
+	CL_DRAW_BUFFER12                       = 0x8831,
+	CL_DRAW_BUFFER13                       = 0x8832,
+	CL_DRAW_BUFFER14                       = 0x8833,
+	CL_DRAW_BUFFER15                       = 0x8834,
+
+	// ARB_point_sprite:
+
+	CL_POINT_SPRITE                        = 0x8861,
+	CL_COORD_REPLACE                       = 0x8862,
+	// CL_POINT_SPRITE_COORD_ORIGIN           = cant find this token value anywhere :/
+
+	// ATI_separate_stencil:
+
+	// CL_KEEP                                = 0x1E00,
+	// CL_ZERO                                = 0x0000,
+	// CL_REPLACE                             = 0x1E01,
+	// CL_INCR                                = 0x1E02,
+	// CL_DECR                                = 0x1E03,
+	// CL_INVERT                              = 0x150A,
+	// CL_NEVER                               = 0x0200,
+	// CL_LESS                                = 0x0201,
+	// CL_LEQUAL                              = 0x0203,
+	// CL_GREATER                             = 0x0204,
+	// CL_GEQUAL                              = 0x0206,
+	// CL_EQUAL                               = 0x0202,
+	// CL_NOTEQUAL                            = 0x0205,
+	// CL_ALWAYS                              = 0x0207,
+	// CL_FRONT                               = 0x0404,
+	// CL_BACK                                = 0x0405,
+	// CL_FRONT_AND_BACK                      = 0x0408,
+	CL_STENCIL_BACK_FUNC                   = 0x8800,
+	CL_STENCIL_BACK_FAIL                   = 0x8801,
+	CL_STENCIL_BACK_PASS_DEPTH_FAIL        = 0x8802,
+	CL_STENCIL_BACK_PASS_DEPTH_PASS        = 0x8803,
+	
+	// EXT_stencil_two_side additional states:
+
+	CL_STENCIL_TEST_TWO_SIDE               = 0x8910,
+	CL_ACTIVE_STENCIL_FACE                 = 0x8911
+};
+
+//! OpenGL 2.0 binds:
+//- !group=GL/System!
+//- !header=gl.h!
+class CL_API_GL CL_GLFunctions
+{
+//! Typedefs:
+public:
+	typedef void (CL_GLFUNC *ptr_glAccum)(CLenum op, CLfloat value);
+	typedef void (CL_GLFUNC *ptr_glAlphaFunc)(CLenum func, CLclampf ref);
+	typedef CLboolean (CL_GLFUNC *ptr_glAreTexturesResident)(CLsizei n, const CLuint *textures, CLboolean *residences);
+	typedef void (CL_GLFUNC *ptr_glArrayElement)(CLint i);
+	typedef void (CL_GLFUNC *ptr_glBegin)(CLenum mode);
+	typedef void (CL_GLFUNC *ptr_glBindTexture)(CLenum target, CLuint texture);
+	typedef void (CL_GLFUNC *ptr_glBitmap)(CLsizei width, CLsizei height, CLfloat xorig, CLfloat yorig, CLfloat xmove, CLfloat ymove, const CLubyte *bitmap);
+	typedef void (CL_GLFUNC *ptr_glBlendFunc)(CLenum sfactor, CLenum dfactor);
+	typedef void (CL_GLFUNC *ptr_glCallList)(CLuint list);
+	typedef void (CL_GLFUNC *ptr_glCallLists)(CLsizei n, CLenum type, const CLvoid *lists);
+	typedef void (CL_GLFUNC *ptr_glClear)(CLbitfield mask);
+	typedef void (CL_GLFUNC *ptr_glClearAccum)(CLfloat red, CLfloat green, CLfloat blue, CLfloat alpha);
+	typedef void (CL_GLFUNC *ptr_glClearColor)(CLclampf red, CLclampf green, CLclampf blue, CLclampf alpha);
+	typedef void (CL_GLFUNC *ptr_glClearDepth)(CLclampd depth);
+	typedef void (CL_GLFUNC *ptr_glClearIndex)(CLfloat c);
+	typedef void (CL_GLFUNC *ptr_glClearStencil)(CLint s);
+	typedef void (CL_GLFUNC *ptr_glClipPlane)(CLenum plane, const CLdouble *equation);
+	typedef void (CL_GLFUNC *ptr_glColor3b)(CLbyte red, CLbyte green, CLbyte blue);
+	typedef void (CL_GLFUNC *ptr_glColor3bv)(const CLbyte *v);
+	typedef void (CL_GLFUNC *ptr_glColor3d)(CLdouble red, CLdouble green, CLdouble blue);
+	typedef void (CL_GLFUNC *ptr_glColor3dv)(const CLdouble *v);
+	typedef void (CL_GLFUNC *ptr_glColor3f)(CLfloat red, CLfloat green, CLfloat blue);
+	typedef void (CL_GLFUNC *ptr_glColor3fv)(const CLfloat *v);
+	typedef void (CL_GLFUNC *ptr_glColor3i)(CLint red, CLint green, CLint blue);
+	typedef void (CL_GLFUNC *ptr_glColor3iv)(const CLint *v);
+	typedef void (CL_GLFUNC *ptr_glColor3s)(CLshort red, CLshort green, CLshort blue);
+	typedef void (CL_GLFUNC *ptr_glColor3sv)(const CLshort *v);
+	typedef void (CL_GLFUNC *ptr_glColor3ub)(CLubyte red, CLubyte green, CLubyte blue);
+	typedef void (CL_GLFUNC *ptr_glColor3ubv)(const CLubyte *v);
+	typedef void (CL_GLFUNC *ptr_glColor3ui)(CLuint red, CLuint green, CLuint blue);
+	typedef void (CL_GLFUNC *ptr_glColor3uiv)(const CLuint *v);
+	typedef void (CL_GLFUNC *ptr_glColor3us)(CLushort red, CLushort green, CLushort blue);
+	typedef void (CL_GLFUNC *ptr_glColor3usv)(const CLushort *v);
+	typedef void (CL_GLFUNC *ptr_glColor4b)(CLbyte red, CLbyte green, CLbyte blue, CLbyte alpha);
+	typedef void (CL_GLFUNC *ptr_glColor4bv)(const CLbyte *v);
+	typedef void (CL_GLFUNC *ptr_glColor4d)(CLdouble red, CLdouble green, CLdouble blue, CLdouble alpha);
+	typedef void (CL_GLFUNC *ptr_glColor4dv)(const CLdouble *v);
+	typedef void (CL_GLFUNC *ptr_glColor4f)(CLfloat red, CLfloat green, CLfloat blue, CLfloat alpha);
+	typedef void (CL_GLFUNC *ptr_glColor4fv)(const CLfloat *v);
+	typedef void (CL_GLFUNC *ptr_glColor4i)(CLint red, CLint green, CLint blue, CLint alpha);
+	typedef void (CL_GLFUNC *ptr_glColor4iv)(const CLint *v);
+	typedef void (CL_GLFUNC *ptr_glColor4s)(CLshort red, CLshort green, CLshort blue, CLshort alpha);
+	typedef void (CL_GLFUNC *ptr_glColor4sv)(const CLshort *v);
+	typedef void (CL_GLFUNC *ptr_glColor4ub)(CLubyte red, CLubyte green, CLubyte blue, CLubyte alpha);
+	typedef void (CL_GLFUNC *ptr_glColor4ubv)(const CLubyte *v);
+	typedef void (CL_GLFUNC *ptr_glColor4ui)(CLuint red, CLuint green, CLuint blue, CLuint alpha);
+	typedef void (CL_GLFUNC *ptr_glColor4uiv)(const CLuint *v);
+	typedef void (CL_GLFUNC *ptr_glColor4us)(CLushort red, CLushort green, CLushort blue, CLushort alpha);
+	typedef void (CL_GLFUNC *ptr_glColor4usv)(const CLushort *v);
+	typedef void (CL_GLFUNC *ptr_glColorMask)(CLboolean red, CLboolean green, CLboolean blue, CLboolean alpha);
+	typedef void (CL_GLFUNC *ptr_glColorMaterial)(CLenum face, CLenum mode);
+	typedef void (CL_GLFUNC *ptr_glColorPointer)(CLint size, CLenum type, CLsizei stride, const CLvoid *pointer);
+	typedef void (CL_GLFUNC *ptr_glCopyPixels)(CLint x, CLint y, CLsizei width, CLsizei height, CLenum type);
+	typedef void (CL_GLFUNC *ptr_glCopyTexImage1D)(CLenum target, CLint level, CLenum internalformat, CLint x, CLint y, CLsizei width, CLint border);
+	typedef void (CL_GLFUNC *ptr_glCopyTexImage2D)(CLenum target, CLint level, CLenum internalformat, CLint x, CLint y, CLsizei width, CLsizei height, CLint border);
+	typedef void (CL_GLFUNC *ptr_glCopyTexSubImage1D)(CLenum target, CLint level, CLint xoffset, CLint x, CLint y, CLsizei width);
+	typedef void (CL_GLFUNC *ptr_glCopyTexSubImage2D)(CLenum target, CLint level, CLint xoffset, CLint yoffset, CLint x, CLint y, CLsizei width, CLsizei height);
+	typedef void (CL_GLFUNC *ptr_glCullFace)(CLenum mode);
+	typedef void (CL_GLFUNC *ptr_glDeleteLists)(CLuint list, CLsizei range);
+	typedef void (CL_GLFUNC *ptr_glDeleteTextures)(CLsizei n, const CLuint *textures);
+	typedef void (CL_GLFUNC *ptr_glDepthFunc)(CLenum func);
+	typedef void (CL_GLFUNC *ptr_glDepthMask)(CLboolean flag);
+	typedef void (CL_GLFUNC *ptr_glDepthRange)(CLclampd zNear, CLclampd zFar);
+	typedef void (CL_GLFUNC *ptr_glDisable)(CLenum cap);
+	typedef void (CL_GLFUNC *ptr_glDisableClientState)(CLenum array);
+	typedef void (CL_GLFUNC *ptr_glDrawArrays)(CLenum mode, CLint first, CLsizei count);
+	typedef void (CL_GLFUNC *ptr_glDrawBuffer)(CLenum mode);
+	typedef void (CL_GLFUNC *ptr_glDrawElements)(CLenum mode, CLsizei count, CLenum type, const CLvoid *indices);
+	typedef void (CL_GLFUNC *ptr_glDrawPixels)(CLsizei width, CLsizei height, CLenum format, CLenum type, const CLvoid *pixels);
+	typedef void (CL_GLFUNC *ptr_glEdgeFlag)(CLboolean flag);
+	typedef void (CL_GLFUNC *ptr_glEdgeFlagPointer)(CLsizei stride, const CLvoid *pointer);
+	typedef void (CL_GLFUNC *ptr_glEdgeFlagv)(const CLboolean *flag);
+	typedef void (CL_GLFUNC *ptr_glEnable)(CLenum cap);
+	typedef void (CL_GLFUNC *ptr_glEnableClientState)(CLenum array);
+	typedef void (CL_GLFUNC *ptr_glEnd)(void);
+	typedef void (CL_GLFUNC *ptr_glEndList)(void);
+	typedef void (CL_GLFUNC *ptr_glEvalCoord1d)(CLdouble u);
+	typedef void (CL_GLFUNC *ptr_glEvalCoord1dv)(const CLdouble *u);
+	typedef void (CL_GLFUNC *ptr_glEvalCoord1f)(CLfloat u);
+	typedef void (CL_GLFUNC *ptr_glEvalCoord1fv)(const CLfloat *u);
+	typedef void (CL_GLFUNC *ptr_glEvalCoord2d)(CLdouble u, CLdouble v);
+	typedef void (CL_GLFUNC *ptr_glEvalCoord2dv)(const CLdouble *u);
+	typedef void (CL_GLFUNC *ptr_glEvalCoord2f)(CLfloat u, CLfloat v);
+	typedef void (CL_GLFUNC *ptr_glEvalCoord2fv)(const CLfloat *u);
+	typedef void (CL_GLFUNC *ptr_glEvalMesh1)(CLenum mode, CLint i1, CLint i2);
+	typedef void (CL_GLFUNC *ptr_glEvalMesh2)(CLenum mode, CLint i1, CLint i2, CLint j1, CLint j2);
+	typedef void (CL_GLFUNC *ptr_glEvalPoint1)(CLint i);
+	typedef void (CL_GLFUNC *ptr_glEvalPoint2)(CLint i, CLint j);
+	typedef void (CL_GLFUNC *ptr_glFeedbackBuffer)(CLsizei size, CLenum type, CLfloat *buffer);
+	typedef void (CL_GLFUNC *ptr_glFinish)(void);
+	typedef void (CL_GLFUNC *ptr_glFlush)(void);
+	typedef void (CL_GLFUNC *ptr_glFogf)(CLenum pname, CLfloat param);
+	typedef void (CL_GLFUNC *ptr_glFogfv)(CLenum pname, const CLfloat *params);
+	typedef void (CL_GLFUNC *ptr_glFogi)(CLenum pname, CLint param);
+	typedef void (CL_GLFUNC *ptr_glFogiv)(CLenum pname, const CLint *params);
+	typedef void (CL_GLFUNC *ptr_glFrontFace)(CLenum mode);
+	typedef void (CL_GLFUNC *ptr_glFrustum)(CLdouble left, CLdouble right, CLdouble bottom, CLdouble top, CLdouble zNear, CLdouble zFar);
+	typedef CLuint (CL_GLFUNC *ptr_glGenLists)(CLsizei range);
+	typedef void (CL_GLFUNC *ptr_glGenTextures)(CLsizei n, CLuint *textures);
+	typedef void (CL_GLFUNC *ptr_glGetBooleanv)(CLenum pname, CLboolean *params);
+	typedef void (CL_GLFUNC *ptr_glGetClipPlane)(CLenum plane, CLdouble *equation);
+	typedef void (CL_GLFUNC *ptr_glGetDoublev)(CLenum pname, CLdouble *params);
+	typedef CLenum (CL_GLFUNC *ptr_glGetError)(void);
+	typedef void (CL_GLFUNC *ptr_glGetFloatv)(CLenum pname, CLfloat *params);
+	typedef void (CL_GLFUNC *ptr_glGetIntegerv)(CLenum pname, CLint *params);
+	typedef void (CL_GLFUNC *ptr_glGetLightfv)(CLenum light, CLenum pname, CLfloat *params);
+	typedef void (CL_GLFUNC *ptr_glGetLightiv)(CLenum light, CLenum pname, CLint *params);
+	typedef void (CL_GLFUNC *ptr_glGetMapdv)(CLenum target, CLenum query, CLdouble *v);
+	typedef void (CL_GLFUNC *ptr_glGetMapfv)(CLenum target, CLenum query, CLfloat *v);
+	typedef void (CL_GLFUNC *ptr_glGetMapiv)(CLenum target, CLenum query, CLint *v);
+	typedef void (CL_GLFUNC *ptr_glGetMaterialfv)(CLenum face, CLenum pname, CLfloat *params);
+	typedef void (CL_GLFUNC *ptr_glGetMaterialiv)(CLenum face, CLenum pname, CLint *params);
+	typedef void (CL_GLFUNC *ptr_glGetPixelMapfv)(CLenum map, CLfloat *values);
+	typedef void (CL_GLFUNC *ptr_glGetPixelMapuiv)(CLenum map, CLuint *values);
+	typedef void (CL_GLFUNC *ptr_glGetPixelMapusv)(CLenum map, CLushort *values);
+	typedef void (CL_GLFUNC *ptr_glGetPointerv)(CLenum pname, CLvoid* *params);
+	typedef void (CL_GLFUNC *ptr_glGetPolygonStipple)(CLubyte *mask);
+	typedef const CLubyte *(CL_GLFUNC *ptr_glGetString)(CLenum name);
+	typedef void (CL_GLFUNC *ptr_glGetTexEnvfv)(CLenum target, CLenum pname, CLfloat *params);
+	typedef void (CL_GLFUNC *ptr_glGetTexEnviv)(CLenum target, CLenum pname, CLint *params);
+	typedef void (CL_GLFUNC *ptr_glGetTexGendv)(CLenum coord, CLenum pname, CLdouble *params);
+	typedef void (CL_GLFUNC *ptr_glGetTexGenfv)(CLenum coord, CLenum pname, CLfloat *params);
+	typedef void (CL_GLFUNC *ptr_glGetTexGeniv)(CLenum coord, CLenum pname, CLint *params);
+	typedef void (CL_GLFUNC *ptr_glGetTexImage)(CLenum target, CLint level, CLenum format, CLenum type, CLvoid *pixels);
+	typedef void (CL_GLFUNC *ptr_glGetTexLevelParameterfv)(CLenum target, CLint level, CLenum pname, CLfloat *params);
+	typedef void (CL_GLFUNC *ptr_glGetTexLevelParameteriv)(CLenum target, CLint level, CLenum pname, CLint *params);
+	typedef void (CL_GLFUNC *ptr_glGetTexParameterfv)(CLenum target, CLenum pname, CLfloat *params);
+	typedef void (CL_GLFUNC *ptr_glGetTexParameteriv)(CLenum target, CLenum pname, CLint *params);
+	typedef void (CL_GLFUNC *ptr_glHint)(CLenum target, CLenum mode);
+	typedef void (CL_GLFUNC *ptr_glIndexMask)(CLuint mask);
+	typedef void (CL_GLFUNC *ptr_glIndexPointer)(CLenum type, CLsizei stride, const CLvoid *pointer);
+	typedef void (CL_GLFUNC *ptr_glIndexd)(CLdouble c);
+	typedef void (CL_GLFUNC *ptr_glIndexdv)(const CLdouble *c);
+	typedef void (CL_GLFUNC *ptr_glIndexf)(CLfloat c);
+	typedef void (CL_GLFUNC *ptr_glIndexfv)(const CLfloat *c);
+	typedef void (CL_GLFUNC *ptr_glIndexi)(CLint c);
+	typedef void (CL_GLFUNC *ptr_glIndexiv)(const CLint *c);
+	typedef void (CL_GLFUNC *ptr_glIndexs)(CLshort c);
+	typedef void (CL_GLFUNC *ptr_glIndexsv)(const CLshort *c);
+	typedef void (CL_GLFUNC *ptr_glIndexub)(CLubyte c);
+	typedef void (CL_GLFUNC *ptr_glIndexubv)(const CLubyte *c);
+	typedef void (CL_GLFUNC *ptr_glInitNames)(void);
+	typedef void (CL_GLFUNC *ptr_glInterleavedArrays)(CLenum format, CLsizei stride, const CLvoid *pointer);
+	typedef CLboolean (CL_GLFUNC *ptr_glIsEnabled)(CLenum cap);
+	typedef CLboolean (CL_GLFUNC *ptr_glIsList)(CLuint list);
+	typedef CLboolean (CL_GLFUNC *ptr_glIsTexture)(CLuint texture);
+	typedef void (CL_GLFUNC *ptr_glLightModelf)(CLenum pname, CLfloat param);
+	typedef void (CL_GLFUNC *ptr_glLightModelfv)(CLenum pname, const CLfloat *params);
+	typedef void (CL_GLFUNC *ptr_glLightModeli)(CLenum pname, CLint param);
+	typedef void (CL_GLFUNC *ptr_glLightModeliv)(CLenum pname, const CLint *params);
+	typedef void (CL_GLFUNC *ptr_glLightf)(CLenum light, CLenum pname, CLfloat param);
+	typedef void (CL_GLFUNC *ptr_glLightfv)(CLenum light, CLenum pname, const CLfloat *params);
+	typedef void (CL_GLFUNC *ptr_glLighti)(CLenum light, CLenum pname, CLint param);
+	typedef void (CL_GLFUNC *ptr_glLightiv)(CLenum light, CLenum pname, const CLint *params);
+	typedef void (CL_GLFUNC *ptr_glLineStipple)(CLint factor, CLushort pattern);
+	typedef void (CL_GLFUNC *ptr_glLineWidth)(CLfloat width);
+	typedef void (CL_GLFUNC *ptr_glListBase)(CLuint base);
+	typedef void (CL_GLFUNC *ptr_glLoadIdentity)(void);
+	typedef void (CL_GLFUNC *ptr_glLoadMatrixd)(const CLdouble *m);
+	typedef void (CL_GLFUNC *ptr_glLoadMatrixf)(const CLfloat *m);
+	typedef void (CL_GLFUNC *ptr_glLoadName)(CLuint name);
+	typedef void (CL_GLFUNC *ptr_glLogicOp)(CLenum opcode);
+	typedef void (CL_GLFUNC *ptr_glMap1d)(CLenum target, CLdouble u1, CLdouble u2, CLint stride, CLint order, const CLdouble *points);
+	typedef void (CL_GLFUNC *ptr_glMap1f)(CLenum target, CLfloat u1, CLfloat u2, CLint stride, CLint order, const CLfloat *points);
+	typedef void (CL_GLFUNC *ptr_glMap2d)(CLenum target, CLdouble u1, CLdouble u2, CLint ustride, CLint uorder, CLdouble v1, CLdouble v2, CLint vstride, CLint vorder, const CLdouble *points);
+	typedef void (CL_GLFUNC *ptr_glMap2f)(CLenum target, CLfloat u1, CLfloat u2, CLint ustride, CLint uorder, CLfloat v1, CLfloat v2, CLint vstride, CLint vorder, const CLfloat *points);
+	typedef void (CL_GLFUNC *ptr_glMapGrid1d)(CLint un, CLdouble u1, CLdouble u2);
+	typedef void (CL_GLFUNC *ptr_glMapGrid1f)(CLint un, CLfloat u1, CLfloat u2);
+	typedef void (CL_GLFUNC *ptr_glMapGrid2d)(CLint un, CLdouble u1, CLdouble u2, CLint vn, CLdouble v1, CLdouble v2);
+	typedef void (CL_GLFUNC *ptr_glMapGrid2f)(CLint un, CLfloat u1, CLfloat u2, CLint vn, CLfloat v1, CLfloat v2);
+	typedef void (CL_GLFUNC *ptr_glMaterialf)(CLenum face, CLenum pname, CLfloat param);
+	typedef void (CL_GLFUNC *ptr_glMaterialfv)(CLenum face, CLenum pname, const CLfloat *params);
+	typedef void (CL_GLFUNC *ptr_glMateriali)(CLenum face, CLenum pname, CLint param);
+	typedef void (CL_GLFUNC *ptr_glMaterialiv)(CLenum face, CLenum pname, const CLint *params);
+	typedef void (CL_GLFUNC *ptr_glMatrixMode)(CLenum mode);
+	typedef void (CL_GLFUNC *ptr_glMultMatrixd)(const CLdouble *m);
+	typedef void (CL_GLFUNC *ptr_glMultMatrixf)(const CLfloat *m);
+	typedef void (CL_GLFUNC *ptr_glNewList)(CLuint list, CLenum mode);
+	typedef void (CL_GLFUNC *ptr_glNormal3b)(CLbyte nx, CLbyte ny, CLbyte nz);
+	typedef void (CL_GLFUNC *ptr_glNormal3bv)(const CLbyte *v);
+	typedef void (CL_GLFUNC *ptr_glNormal3d)(CLdouble nx, CLdouble ny, CLdouble nz);
+	typedef void (CL_GLFUNC *ptr_glNormal3dv)(const CLdouble *v);
+	typedef void (CL_GLFUNC *ptr_glNormal3f)(CLfloat nx, CLfloat ny, CLfloat nz);
+	typedef void (CL_GLFUNC *ptr_glNormal3fv)(const CLfloat *v);
+	typedef void (CL_GLFUNC *ptr_glNormal3i)(CLint nx, CLint ny, CLint nz);
+	typedef void (CL_GLFUNC *ptr_glNormal3iv)(const CLint *v);
+	typedef void (CL_GLFUNC *ptr_glNormal3s)(CLshort nx, CLshort ny, CLshort nz);
+	typedef void (CL_GLFUNC *ptr_glNormal3sv)(const CLshort *v);
+	typedef void (CL_GLFUNC *ptr_glNormalPointer)(CLenum type, CLsizei stride, const CLvoid *pointer);
+	typedef void (CL_GLFUNC *ptr_glOrtho)(CLdouble left, CLdouble right, CLdouble bottom, CLdouble top, CLdouble zNear, CLdouble zFar);
+	typedef void (CL_GLFUNC *ptr_glPassThrough)(CLfloat token);
+	typedef void (CL_GLFUNC *ptr_glPixelMapfv)(CLenum map, CLint mapsize, const CLfloat *values);
+	typedef void (CL_GLFUNC *ptr_glPixelMapuiv)(CLenum map, CLint mapsize, const CLuint *values);
+	typedef void (CL_GLFUNC *ptr_glPixelMapusv)(CLenum map, CLint mapsize, const CLushort *values);
+	typedef void (CL_GLFUNC *ptr_glPixelStoref)(CLenum pname, CLfloat param);
+	typedef void (CL_GLFUNC *ptr_glPixelStorei)(CLenum pname, CLint param);
+	typedef void (CL_GLFUNC *ptr_glPixelTransferf)(CLenum pname, CLfloat param);
+	typedef void (CL_GLFUNC *ptr_glPixelTransferi)(CLenum pname, CLint param);
+	typedef void (CL_GLFUNC *ptr_glPixelZoom)(CLfloat xfactor, CLfloat yfactor);
+	typedef void (CL_GLFUNC *ptr_glPointSize)(CLfloat size);
+	typedef void (CL_GLFUNC *ptr_glPolygonMode)(CLenum face, CLenum mode);
+	typedef void (CL_GLFUNC *ptr_glPolygonOffset)(CLfloat factor, CLfloat units);
+	typedef void (CL_GLFUNC *ptr_glPolygonStipple)(const CLubyte *mask);
+	typedef void (CL_GLFUNC *ptr_glPopAttrib)(void);
+	typedef void (CL_GLFUNC *ptr_glPopClientAttrib)(void);
+	typedef void (CL_GLFUNC *ptr_glPopMatrix)(void);
+	typedef void (CL_GLFUNC *ptr_glPopName)(void);
+	typedef void (CL_GLFUNC *ptr_glPrioritizeTextures)(CLsizei n, const CLuint *textures, const CLclampf *priorities);
+	typedef void (CL_GLFUNC *ptr_glPushAttrib)(CLbitfield mask);
+	typedef void (CL_GLFUNC *ptr_glPushClientAttrib)(CLbitfield mask);
+	typedef void (CL_GLFUNC *ptr_glPushMatrix)(void);
+	typedef void (CL_GLFUNC *ptr_glPushName)(CLuint name);
+	typedef void (CL_GLFUNC *ptr_glRasterPos2d)(CLdouble x, CLdouble y);
+	typedef void (CL_GLFUNC *ptr_glRasterPos2dv)(const CLdouble *v);
+	typedef void (CL_GLFUNC *ptr_glRasterPos2f)(CLfloat x, CLfloat y);
+	typedef void (CL_GLFUNC *ptr_glRasterPos2fv)(const CLfloat *v);
+	typedef void (CL_GLFUNC *ptr_glRasterPos2i)(CLint x, CLint y);
+	typedef void (CL_GLFUNC *ptr_glRasterPos2iv)(const CLint *v);
+	typedef void (CL_GLFUNC *ptr_glRasterPos2s)(CLshort x, CLshort y);
+	typedef void (CL_GLFUNC *ptr_glRasterPos2sv)(const CLshort *v);
+	typedef void (CL_GLFUNC *ptr_glRasterPos3d)(CLdouble x, CLdouble y, CLdouble z);
+	typedef void (CL_GLFUNC *ptr_glRasterPos3dv)(const CLdouble *v);
+	typedef void (CL_GLFUNC *ptr_glRasterPos3f)(CLfloat x, CLfloat y, CLfloat z);
+	typedef void (CL_GLFUNC *ptr_glRasterPos3fv)(const CLfloat *v);
+	typedef void (CL_GLFUNC *ptr_glRasterPos3i)(CLint x, CLint y, CLint z);
+	typedef void (CL_GLFUNC *ptr_glRasterPos3iv)(const CLint *v);
+	typedef void (CL_GLFUNC *ptr_glRasterPos3s)(CLshort x, CLshort y, CLshort z);
+	typedef void (CL_GLFUNC *ptr_glRasterPos3sv)(const CLshort *v);
+	typedef void (CL_GLFUNC *ptr_glRasterPos4d)(CLdouble x, CLdouble y, CLdouble z, CLdouble w);
+	typedef void (CL_GLFUNC *ptr_glRasterPos4dv)(const CLdouble *v);
+	typedef void (CL_GLFUNC *ptr_glRasterPos4f)(CLfloat x, CLfloat y, CLfloat z, CLfloat w);
+	typedef void (CL_GLFUNC *ptr_glRasterPos4fv)(const CLfloat *v);
+	typedef void (CL_GLFUNC *ptr_glRasterPos4i)(CLint x, CLint y, CLint z, CLint w);
+	typedef void (CL_GLFUNC *ptr_glRasterPos4iv)(const CLint *v);
+	typedef void (CL_GLFUNC *ptr_glRasterPos4s)(CLshort x, CLshort y, CLshort z, CLshort w);
+	typedef void (CL_GLFUNC *ptr_glRasterPos4sv)(const CLshort *v);
+	typedef void (CL_GLFUNC *ptr_glReadBuffer)(CLenum mode);
+	typedef void (CL_GLFUNC *ptr_glReadPixels)(CLint x, CLint y, CLsizei width, CLsizei height, CLenum format, CLenum type, CLvoid *pixels);
+	typedef void (CL_GLFUNC *ptr_glRectd)(CLdouble x1, CLdouble y1, CLdouble x2, CLdouble y2);
+	typedef void (CL_GLFUNC *ptr_glRectdv)(const CLdouble *v1, const CLdouble *v2);
+	typedef void (CL_GLFUNC *ptr_glRectf)(CLfloat x1, CLfloat y1, CLfloat x2, CLfloat y2);
+	typedef void (CL_GLFUNC *ptr_glRectfv)(const CLfloat *v1, const CLfloat *v2);
+	typedef void (CL_GLFUNC *ptr_glRecti)(CLint x1, CLint y1, CLint x2, CLint y2);
+	typedef void (CL_GLFUNC *ptr_glRectiv)(const CLint *v1, const CLint *v2);
+	typedef void (CL_GLFUNC *ptr_glRects)(CLshort x1, CLshort y1, CLshort x2, CLshort y2);
+	typedef void (CL_GLFUNC *ptr_glRectsv)(const CLshort *v1, const CLshort *v2);
+	typedef CLint (CL_GLFUNC *ptr_glRenderMode)(CLenum mode);
+	typedef void (CL_GLFUNC *ptr_glRotated)(CLdouble angle, CLdouble x, CLdouble y, CLdouble z);
+	typedef void (CL_GLFUNC *ptr_glRotatef)(CLfloat angle, CLfloat x, CLfloat y, CLfloat z);
+	typedef void (CL_GLFUNC *ptr_glScaled)(CLdouble x, CLdouble y, CLdouble z);
+	typedef void (CL_GLFUNC *ptr_glScalef)(CLfloat x, CLfloat y, CLfloat z);
+	typedef void (CL_GLFUNC *ptr_glScissor)(CLint x, CLint y, CLsizei width, CLsizei height);
+	typedef void (CL_GLFUNC *ptr_glSelectBuffer)(CLsizei size, CLuint *buffer);
+	typedef void (CL_GLFUNC *ptr_glShadeModel)(CLenum mode);
+	typedef void (CL_GLFUNC *ptr_glStencilFunc)(CLenum func, CLint ref, CLuint mask);
+	typedef void (CL_GLFUNC *ptr_glStencilMask)(CLuint mask);
+	typedef void (CL_GLFUNC *ptr_glStencilOp)(CLenum fail, CLenum zfail, CLenum zpass);
+	typedef void (CL_GLFUNC *ptr_glTexCoord1d)(CLdouble s);
+	typedef void (CL_GLFUNC *ptr_glTexCoord1dv)(const CLdouble *v);
+	typedef void (CL_GLFUNC *ptr_glTexCoord1f)(CLfloat s);
+	typedef void (CL_GLFUNC *ptr_glTexCoord1fv)(const CLfloat *v);
+	typedef void (CL_GLFUNC *ptr_glTexCoord1i)(CLint s);
+	typedef void (CL_GLFUNC *ptr_glTexCoord1iv)(const CLint *v);
+	typedef void (CL_GLFUNC *ptr_glTexCoord1s)(CLshort s);
+	typedef void (CL_GLFUNC *ptr_glTexCoord1sv)(const CLshort *v);
+	typedef void (CL_GLFUNC *ptr_glTexCoord2d)(CLdouble s, CLdouble t);
+	typedef void (CL_GLFUNC *ptr_glTexCoord2dv)(const CLdouble *v);
+	typedef void (CL_GLFUNC *ptr_glTexCoord2f)(CLfloat s, CLfloat t);
+	typedef void (CL_GLFUNC *ptr_glTexCoord2fv)(const CLfloat *v);
+	typedef void (CL_GLFUNC *ptr_glTexCoord2i)(CLint s, CLint t);
+	typedef void (CL_GLFUNC *ptr_glTexCoord2iv)(const CLint *v);
+	typedef void (CL_GLFUNC *ptr_glTexCoord2s)(CLshort s, CLshort t);
+	typedef void (CL_GLFUNC *ptr_glTexCoord2sv)(const CLshort *v);
+	typedef void (CL_GLFUNC *ptr_glTexCoord3d)(CLdouble s, CLdouble t, CLdouble r);
+	typedef void (CL_GLFUNC *ptr_glTexCoord3dv)(const CLdouble *v);
+	typedef void (CL_GLFUNC *ptr_glTexCoord3f)(CLfloat s, CLfloat t, CLfloat r);
+	typedef void (CL_GLFUNC *ptr_glTexCoord3fv)(const CLfloat *v);
+	typedef void (CL_GLFUNC *ptr_glTexCoord3i)(CLint s, CLint t, CLint r);
+	typedef void (CL_GLFUNC *ptr_glTexCoord3iv)(const CLint *v);
+	typedef void (CL_GLFUNC *ptr_glTexCoord3s)(CLshort s, CLshort t, CLshort r);
+	typedef void (CL_GLFUNC *ptr_glTexCoord3sv)(const CLshort *v);
+	typedef void (CL_GLFUNC *ptr_glTexCoord4d)(CLdouble s, CLdouble t, CLdouble r, CLdouble q);
+	typedef void (CL_GLFUNC *ptr_glTexCoord4dv)(const CLdouble *v);
+	typedef void (CL_GLFUNC *ptr_glTexCoord4f)(CLfloat s, CLfloat t, CLfloat r, CLfloat q);
+	typedef void (CL_GLFUNC *ptr_glTexCoord4fv)(const CLfloat *v);
+	typedef void (CL_GLFUNC *ptr_glTexCoord4i)(CLint s, CLint t, CLint r, CLint q);
+	typedef void (CL_GLFUNC *ptr_glTexCoord4iv)(const CLint *v);
+	typedef void (CL_GLFUNC *ptr_glTexCoord4s)(CLshort s, CLshort t, CLshort r, CLshort q);
+	typedef void (CL_GLFUNC *ptr_glTexCoord4sv)(const CLshort *v);
+	typedef void (CL_GLFUNC *ptr_glTexCoordPointer)(CLint size, CLenum type, CLsizei stride, const CLvoid *pointer);
+	typedef void (CL_GLFUNC *ptr_glTexEnvf)(CLenum target, CLenum pname, CLfloat param);
+	typedef void (CL_GLFUNC *ptr_glTexEnvfv)(CLenum target, CLenum pname, const CLfloat *params);
+	typedef void (CL_GLFUNC *ptr_glTexEnvi)(CLenum target, CLenum pname, CLint param);
+	typedef void (CL_GLFUNC *ptr_glTexEnviv)(CLenum target, CLenum pname, const CLint *params);
+	typedef void (CL_GLFUNC *ptr_glTexGend)(CLenum coord, CLenum pname, CLdouble param);
+	typedef void (CL_GLFUNC *ptr_glTexGendv)(CLenum coord, CLenum pname, const CLdouble *params);
+	typedef void (CL_GLFUNC *ptr_glTexGenf)(CLenum coord, CLenum pname, CLfloat param);
+	typedef void (CL_GLFUNC *ptr_glTexGenfv)(CLenum coord, CLenum pname, const CLfloat *params);
+	typedef void (CL_GLFUNC *ptr_glTexGeni)(CLenum coord, CLenum pname, CLint param);
+	typedef void (CL_GLFUNC *ptr_glTexGeniv)(CLenum coord, CLenum pname, const CLint *params);
+	typedef void (CL_GLFUNC *ptr_glTexImage1D)(CLenum target, CLint level, CLint internalformat, CLsizei width, CLint border, CLenum format, CLenum type, const CLvoid *pixels);
+	typedef void (CL_GLFUNC *ptr_glTexImage2D)(CLenum target, CLint level, CLint internalformat, CLsizei width, CLsizei height, CLint border, CLenum format, CLenum type, const CLvoid *pixels);
+	typedef void (CL_GLFUNC *ptr_glTexParameterf)(CLenum target, CLenum pname, CLfloat param);
+	typedef void (CL_GLFUNC *ptr_glTexParameterfv)(CLenum target, CLenum pname, const CLfloat *params);
+	typedef void (CL_GLFUNC *ptr_glTexParameteri)(CLenum target, CLenum pname, CLint param);
+	typedef void (CL_GLFUNC *ptr_glTexParameteriv)(CLenum target, CLenum pname, const CLint *params);
+	typedef void (CL_GLFUNC *ptr_glTexSubImage1D)(CLenum target, CLint level, CLint xoffset, CLsizei width, CLenum format, CLenum type, const CLvoid *pixels);
+	typedef void (CL_GLFUNC *ptr_glTexSubImage2D)(CLenum target, CLint level, CLint xoffset, CLint yoffset, CLsizei width, CLsizei height, CLenum format, CLenum type, const CLvoid *pixels);
+	typedef void (CL_GLFUNC *ptr_glTranslated)(CLdouble x, CLdouble y, CLdouble z);
+	typedef void (CL_GLFUNC *ptr_glTranslatef)(CLfloat x, CLfloat y, CLfloat z);
+	typedef void (CL_GLFUNC *ptr_glVertex2d)(CLdouble x, CLdouble y);
+	typedef void (CL_GLFUNC *ptr_glVertex2dv)(const CLdouble *v);
+	typedef void (CL_GLFUNC *ptr_glVertex2f)(CLfloat x, CLfloat y);
+	typedef void (CL_GLFUNC *ptr_glVertex2fv)(const CLfloat *v);
+	typedef void (CL_GLFUNC *ptr_glVertex2i)(CLint x, CLint y);
+	typedef void (CL_GLFUNC *ptr_glVertex2iv)(const CLint *v);
+	typedef void (CL_GLFUNC *ptr_glVertex2s)(CLshort x, CLshort y);
+	typedef void (CL_GLFUNC *ptr_glVertex2sv)(const CLshort *v);
+	typedef void (CL_GLFUNC *ptr_glVertex3d)(CLdouble x, CLdouble y, CLdouble z);
+	typedef void (CL_GLFUNC *ptr_glVertex3dv)(const CLdouble *v);
+	typedef void (CL_GLFUNC *ptr_glVertex3f)(CLfloat x, CLfloat y, CLfloat z);
+	typedef void (CL_GLFUNC *ptr_glVertex3fv)(const CLfloat *v);
+	typedef void (CL_GLFUNC *ptr_glVertex3i)(CLint x, CLint y, CLint z);
+	typedef void (CL_GLFUNC *ptr_glVertex3iv)(const CLint *v);
+	typedef void (CL_GLFUNC *ptr_glVertex3s)(CLshort x, CLshort y, CLshort z);
+	typedef void (CL_GLFUNC *ptr_glVertex3sv)(const CLshort *v);
+	typedef void (CL_GLFUNC *ptr_glVertex4d)(CLdouble x, CLdouble y, CLdouble z, CLdouble w);
+	typedef void (CL_GLFUNC *ptr_glVertex4dv)(const CLdouble *v);
+	typedef void (CL_GLFUNC *ptr_glVertex4f)(CLfloat x, CLfloat y, CLfloat z, CLfloat w);
+	typedef void (CL_GLFUNC *ptr_glVertex4fv)(const CLfloat *v);
+	typedef void (CL_GLFUNC *ptr_glVertex4i)(CLint x, CLint y, CLint z, CLint w);
+	typedef void (CL_GLFUNC *ptr_glVertex4iv)(const CLint *v);
+	typedef void (CL_GLFUNC *ptr_glVertex4s)(CLshort x, CLshort y, CLshort z, CLshort w);
+	typedef void (CL_GLFUNC *ptr_glVertex4sv)(const CLshort *v);
+	typedef void (CL_GLFUNC *ptr_glVertexPointer)(CLint size, CLenum type, CLsizei stride, const CLvoid *pointer);
+	typedef void (CL_GLFUNC *ptr_glViewport)(CLint x, CLint y, CLsizei width, CLsizei height);
+
+	typedef void (CL_GLFUNC *ptr_glDrawRangeElementsEXT)(CLenum mode, CLuint start, CLuint end, CLsizei count, CLenum type, const CLvoid *indices);
+	typedef void (CL_GLFUNC *ptr_glTexImage3DEXT)(CLenum target, CLint level, CLenum internalformat, CLsizei width, CLsizei height, CLsizei depth, CLint border, CLenum format, CLenum type, const CLvoid* pixels);
+	typedef void (CL_GLFUNC *ptr_glTexSubImage3DEXT)(CLenum target, CLint level, CLint xoffset, CLint yoffset, CLint zoffset, CLsizei width, CLsizei height, CLsizei depth, CLenum format, CLenum type, const CLvoid *pixels);
+	typedef void (CL_GLFUNC *ptr_glCopyTexSubImage3DEXT)(CLenum target, CLint level, CLint xoffset, CLint yoffset, CLint zoffset, CLint x, CLint y, CLsizei width, CLsizei height);
+	typedef void (CL_GLFUNC *ptr_glColorTableSGI)(CLenum target, CLenum internalformat, CLsizei width, CLenum format, CLenum type, const CLvoid* table);
+	typedef void (CL_GLFUNC *ptr_glCopyColorTableSGI)(CLenum target, CLenum internalformat, CLint x, CLint y, CLsizei width);
+	typedef void (CL_GLFUNC *ptr_glColorTableParameterivSGI)(CLenum target, CLenum pname, const CLint* params);
+	typedef void (CL_GLFUNC *ptr_glColorTableParameterfvSGI)(CLenum target, CLenum pname, const CLfloat* params);
+	typedef void (CL_GLFUNC *ptr_glGetColorTableSGI)(CLenum target, CLenum format, CLenum type, CLvoid* table);
+	typedef void (CL_GLFUNC *ptr_glGetColorTableParameterivSGI)(CLenum target, CLenum pname, CLint* params);
+	typedef void (CL_GLFUNC *ptr_glGetColorTableParameterfvSGI)(CLenum target, CLenum pname, CLfloat* params);
+	typedef void (CL_GLFUNC *ptr_glColorSubTableEXT)(CLenum target, CLsizei start, CLsizei count, CLenum format, CLenum type, const CLvoid *data);
+	typedef void (CL_GLFUNC *ptr_glCopyColorSubTableEXT)(CLenum target, CLsizei start, CLint x, CLint y, CLsizei width);
+	typedef void (CL_GLFUNC *ptr_glConvolutionFilter1DEXT)(CLenum target, CLenum internalformat, CLsizei width, CLenum format, CLenum type, const CLvoid* image);
+	typedef void (CL_GLFUNC *ptr_glConvolutionFilter2DEXT)(CLenum target, CLenum internalformat, CLsizei width, CLsizei height, CLenum format, CLenum type, const CLvoid* image);
+	typedef void (CL_GLFUNC *ptr_glCopyConvolutionFilter1DEXT)(CLenum target, CLenum internalformat, CLint x, CLint y, CLsizei width);
+	typedef void (CL_GLFUNC *ptr_glCopyConvolutionFilter2DEXT)(CLenum target, CLenum internalformat, CLint x, CLint y, CLsizei width, CLsizei height);
+	typedef void (CL_GLFUNC *ptr_glGetConvolutionFilterEXT)(CLenum target, CLenum format, CLenum type, CLvoid* image);
+	typedef void (CL_GLFUNC *ptr_glSeparableFilter2DEXT)(CLenum target, CLenum internalformat, CLsizei width, CLsizei height, CLenum format, CLenum type, const CLvoid* row, const CLvoid* column);
+	typedef void (CL_GLFUNC *ptr_glGetSeparableFilterEXT)(CLenum target, CLenum format, CLenum type, CLvoid* row, CLvoid* column, CLvoid* span);
+	typedef void (CL_GLFUNC *ptr_glConvolutionParameteriEXT)(CLenum target, CLenum pname, CLint param);
+	typedef void (CL_GLFUNC *ptr_glConvolutionParameterivEXT)(CLenum target, CLenum pname, const CLint* params);
+	typedef void (CL_GLFUNC *ptr_glConvolutionParameterfEXT)(CLenum target, CLenum pname, CLfloat param);
+	typedef void (CL_GLFUNC *ptr_glConvolutionParameterfvEXT)(CLenum target, CLenum pname, const CLfloat* params);
+	typedef void (CL_GLFUNC *ptr_glGetConvolutionParameterivEXT)(CLenum target, CLenum pname, CLint* params);
+	typedef void (CL_GLFUNC *ptr_glGetConvolutionParameterfvEXT)(CLenum target, CLenum pname, CLfloat* params);
+	typedef void (CL_GLFUNC *ptr_glHistogramEXT)(CLenum target, CLsizei width, CLenum internalformat, CLboolean sink);
+	typedef void (CL_GLFUNC *ptr_glResetHistogramEXT)(CLenum target);
+	typedef void (CL_GLFUNC *ptr_glGetHistogramEXT)(CLenum target, CLboolean reset, CLenum format, CLenum type, CLvoid* values);
+	typedef void (CL_GLFUNC *ptr_glGetHistogramParameterivEXT)(CLenum target, CLenum pname, CLint* params);
+	typedef void (CL_GLFUNC *ptr_glGetHistogramParameterfvEXT)(CLenum target, CLenum pname, CLfloat* params);
+	typedef void (CL_GLFUNC *ptr_glMinmaxEXT)(CLenum target, CLenum internalformat, CLboolean sink);
+	typedef void (CL_GLFUNC *ptr_glResetMinmaxEXT)(CLenum target);
+	typedef void (CL_GLFUNC *ptr_glGetMinmaxEXT)(CLenum target, CLboolean reset, CLenum format, CLenum type, CLvoid* values);
+	typedef void (CL_GLFUNC *ptr_glGetMinmaxParameterivEXT)(CLenum target, CLenum pname, CLint* params);
+	typedef void (CL_GLFUNC *ptr_glGetMinmaxParameterfvEXT)(CLenum target, CLenum pname, CLfloat* params);
+	typedef void (CL_GLFUNC *ptr_glBlendColorEXT)(CLclampf red, CLclampf green, CLclampf blue, CLclampf alpha);
+	typedef void (CL_GLFUNC *ptr_glBlendEquationEXT)(CLenum mode);
+	typedef CLvoid (CL_GLFUNC *ptr_glActiveTextureARB)(CLenum);
+	typedef CLvoid (CL_GLFUNC *ptr_glClientActiveTextureARB)(CLenum);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord1dARB)(CLenum, CLdouble);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord1dvARB)(CLenum, CLdouble const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord1fARB)(CLenum, CLfloat);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord1fvARB)(CLenum, CLfloat const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord1iARB)(CLenum, CLint);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord1ivARB)(CLenum, CLint const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord1sARB)(CLenum, CLshort);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord1svARB)(CLenum, CLshort const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord2dARB)(CLenum, CLdouble, CLdouble);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord2dvARB)(CLenum, CLdouble const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord2fARB)(CLenum, CLfloat, CLfloat);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord2fvARB)(CLenum, CLfloat const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord2iARB)(CLenum, CLint, CLint);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord2ivARB)(CLenum, CLint const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord2sARB)(CLenum, CLshort, CLshort);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord2svARB)(CLenum, CLshort const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord3dARB)(CLenum, CLdouble, CLdouble, CLdouble);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord3dvARB)(CLenum, CLdouble const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord3fARB)(CLenum, CLfloat, CLfloat, CLfloat);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord3fvARB)(CLenum, CLfloat const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord3iARB)(CLenum, CLint, CLint, CLint);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord3ivARB)(CLenum, CLint const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord3sARB)(CLenum, CLshort, CLshort, CLshort);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord3svARB)(CLenum, CLshort const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord4dARB)(CLenum, CLdouble, CLdouble, CLdouble, CLdouble);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord4dvARB)(CLenum, CLdouble const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord4fARB)(CLenum, CLfloat, CLfloat, CLfloat, CLfloat);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord4fvARB)(CLenum, CLfloat const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord4iARB)(CLenum, CLint, CLint, CLint, CLint);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord4ivARB)(CLenum, CLint const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord4sARB)(CLenum, CLshort, CLshort, CLshort, CLshort);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiTexCoord4svARB)(CLenum, CLshort const *);
+
+	typedef CLvoid (CL_GLFUNC *ptr_glCompressedTexImage1DARB)(CLenum, CLint, CLenum, CLsizei, CLint, CLsizei, CLvoid const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glCompressedTexImage2DARB)(CLenum, CLint, CLenum, CLsizei, CLsizei, CLint, CLsizei, CLvoid const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glCompressedTexImage3DARB)(CLenum, CLint, CLenum, CLsizei, CLsizei, CLsizei, CLint, CLsizei, CLvoid const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glCompressedTexSubImage1DARB)(CLenum, CLint, CLint, CLsizei, CLenum, CLsizei, CLvoid const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glCompressedTexSubImage2DARB)(CLenum, CLint, CLint, CLint, CLsizei, CLsizei, CLenum, CLsizei, CLvoid const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glCompressedTexSubImage3DARB)(CLenum, CLint, CLint, CLint, CLint, CLsizei, CLsizei, CLsizei, CLenum, CLsizei, CLvoid const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glGetCompressedTexImageARB)(CLenum, CLint, CLvoid *);
+	typedef CLvoid (CL_GLFUNC *ptr_glSampleCoverageARB)(CLclampf, CLboolean);
+	typedef CLvoid (CL_GLFUNC *ptr_glLoadTransposeMatrixdARB)(CLdouble const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glLoadTransposeMatrixfARB)(CLfloat const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultTransposeMatrixdARB)(CLdouble const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultTransposeMatrixfARB)(CLfloat const *);
+
+	typedef CLvoid (CL_GLFUNC *ptr_glFogCoorddEXT)(CLdouble);
+	typedef CLvoid (CL_GLFUNC *ptr_glFogCoorddvEXT)(CLdouble const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glFogCoordfEXT)(CLfloat);
+	typedef CLvoid (CL_GLFUNC *ptr_glFogCoordfvEXT)(CLfloat const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glFogCoordPointerEXT)(CLenum, CLsizei, CLvoid const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiDrawArraysEXT)(CLenum, CLint *, CLsizei *, CLsizei);
+	typedef CLvoid (CL_GLFUNC *ptr_glMultiDrawElementsEXT)(CLenum, CLsizei const *, CLenum, CLvoid const * *, CLsizei);
+	typedef CLvoid (CL_GLFUNC *ptr_glPointParameterfARB)(CLenum, CLfloat);
+	typedef CLvoid (CL_GLFUNC *ptr_glPointParameterfvARB)(CLenum, CLfloat const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glSecondaryColor3bEXT)(CLbyte, CLbyte, CLbyte);
+	typedef CLvoid (CL_GLFUNC *ptr_glSecondaryColor3bvEXT)(CLbyte const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glSecondaryColor3dEXT)(CLdouble, CLdouble, CLdouble);
+	typedef CLvoid (CL_GLFUNC *ptr_glSecondaryColor3dvEXT)(CLdouble const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glSecondaryColor3fEXT)(CLfloat, CLfloat, CLfloat);
+	typedef CLvoid (CL_GLFUNC *ptr_glSecondaryColor3fvEXT)(CLfloat const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glSecondaryColor3iEXT)(CLint, CLint, CLint);
+	typedef CLvoid (CL_GLFUNC *ptr_glSecondaryColor3ivEXT)(CLint const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glSecondaryColor3sEXT)(CLshort, CLshort, CLshort);
+	typedef CLvoid (CL_GLFUNC *ptr_glSecondaryColor3svEXT)(CLshort const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glSecondaryColor3ubEXT)(CLubyte, CLubyte, CLubyte);
+	typedef CLvoid (CL_GLFUNC *ptr_glSecondaryColor3ubvEXT)(CLubyte const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glSecondaryColor3uiEXT)(CLuint, CLuint, CLuint);
+	typedef CLvoid (CL_GLFUNC *ptr_glSecondaryColor3uivEXT)(CLuint const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glSecondaryColor3usEXT)(CLushort, CLushort, CLushort);
+	typedef CLvoid (CL_GLFUNC *ptr_glSecondaryColor3usvEXT)(CLushort const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glSecondaryColorPointerEXT)(CLint, CLenum, CLsizei, CLvoid const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glBlendFuncSeparateEXT)(CLenum, CLenum, CLenum, CLenum);
+	typedef CLvoid (CL_GLFUNC *ptr_glWindowPos2dARB)(CLdouble, CLdouble);
+	typedef CLvoid (CL_GLFUNC *ptr_glWindowPos2dvARB)(CLdouble const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glWindowPos2fARB)(CLfloat, CLfloat);
+	typedef CLvoid (CL_GLFUNC *ptr_glWindowPos2fvARB)(CLfloat const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glWindowPos2iARB)(CLint, CLint);
+	typedef CLvoid (CL_GLFUNC *ptr_glWindowPos2ivARB)(CLint const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glWindowPos2sARB)(CLshort, CLshort);
+	typedef CLvoid (CL_GLFUNC *ptr_glWindowPos2svARB)(CLshort const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glWindowPos3dARB)(CLdouble, CLdouble, CLdouble);
+	typedef CLvoid (CL_GLFUNC *ptr_glWindowPos3dvARB)(CLdouble const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glWindowPos3fARB)(CLfloat, CLfloat, CLfloat);
+	typedef CLvoid (CL_GLFUNC *ptr_glWindowPos3fvARB)(CLfloat const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glWindowPos3iARB)(CLint, CLint, CLint);
+	typedef CLvoid (CL_GLFUNC *ptr_glWindowPos3ivARB)(CLint const *);
+	typedef CLvoid (CL_GLFUNC *ptr_glWindowPos3sARB)(CLshort, CLshort, CLshort);
+	typedef CLvoid (CL_GLFUNC *ptr_glWindowPos3svARB)(CLshort const *);
+
+	typedef CLvoid (CL_GLFUNC *ptr_glBindBufferARB)(CLenum target, CLuint buffer);
+	typedef CLvoid (CL_GLFUNC *ptr_glDeleteBuffersARB)(CLsizei n, const CLuint *buffers);
+	typedef CLvoid (CL_GLFUNC *ptr_glGenBuffersARB)(CLsizei n, CLuint *buffers);
+	typedef CLboolean (CL_GLFUNC *ptr_glIsBufferARB)(CLuint buffer);
+	typedef CLvoid (CL_GLFUNC *ptr_glBufferDataARB)(CLenum target, CLsizeiptr size, const CLvoid *data, CLenum usage);
+	typedef CLvoid (CL_GLFUNC *ptr_glBufferSubDataARB)(CLenum target, CLintptr offset, CLsizeiptr size, const CLvoid *data);
+	typedef CLvoid (CL_GLFUNC *ptr_glGetBufferSubDataARB)(CLenum target, CLintptr offset, CLsizeiptr size, CLvoid *data);
+	typedef CLvoid (CL_GLFUNC *ptr_glMapBufferARB)(CLenum target, CLenum access);
+	typedef CLboolean (CL_GLFUNC *ptr_glUnmapBufferARB)(CLenum target);
+	typedef CLvoid (CL_GLFUNC *ptr_glGetBufferParameterivARB)(CLenum target, CLenum pname, CLint *params);
+	typedef CLvoid (CL_GLFUNC *ptr_glGetBufferPointervARB)(CLenum target, CLenum pname, CLvoid **params);
+	typedef CLvoid (CL_GLFUNC *ptr_glGenQueriesARB)(CLsizei n, CLuint *ids);
+	typedef CLvoid (CL_GLFUNC *ptr_glDeleteQueriesARB)(CLsizei n, const CLuint *ids);
+	typedef CLboolean (CL_GLFUNC *ptr_glIsQueryARB)(CLuint id);
+	typedef CLvoid (CL_GLFUNC *ptr_glBeginQueryARB)(CLenum target, CLuint id);
+	typedef CLvoid (CL_GLFUNC *ptr_glEndQueryARB)(CLenum target);
+	typedef CLvoid (CL_GLFUNC *ptr_glGetQueryivARB)(CLenum target, CLenum pname, CLint *params);
+	typedef CLvoid (CL_GLFUNC *ptr_glGetQueryObjectivARB)(CLuint id, CLenum pname, CLint *params);
+	typedef CLvoid (CL_GLFUNC *ptr_glGetQueryObjectuivARB)(CLuint id, CLenum pname, CLuint *params);
+
+	typedef CLvoid (CL_GLFUNC *ptr_glDeleteObjectARB)(CLuint obj);
+	typedef CLuint (CL_GLFUNC *ptr_glGetHandleARB)(CLenum pname);
+	typedef CLvoid (CL_GLFUNC *ptr_glDetachObjectARB)(CLuint containerObj, CLuint attachedObj);
+	typedef CLuint (CL_GLFUNC *ptr_glCreateShaderObjectARB )(CLenum shaderType);
+	typedef CLvoid (CL_GLFUNC *ptr_glShaderSourceARB)(CLuint shaderObj, CLsizei count, const CLchar* *string, const CLint *length);
+	typedef CLvoid (CL_GLFUNC *ptr_glCompileShaderARB)(CLuint shaderObj);
+	typedef CLuint (CL_GLFUNC *ptr_glCreateProgramObjectARB)(CLvoid);
+	typedef CLvoid (CL_GLFUNC *ptr_glAttachObjectARB)(CLuint containerObj, CLuint attachedObj);
+	typedef CLvoid (CL_GLFUNC *ptr_glLinkProgramARB)(CLuint programObj);
+	typedef CLvoid (CL_GLFUNC *ptr_glUseProgramObjectARB)(CLuint programObj);
+	typedef CLvoid (CL_GLFUNC *ptr_glValidateProgramARB)(CLuint programObj);
+	typedef CLvoid (CL_GLFUNC *ptr_glUniform1fARB)(CLint location, CLfloat v0);
+	typedef CLvoid (CL_GLFUNC *ptr_glUniform2fARB)(CLint location, CLfloat v0, CLfloat v1);
+	typedef CLvoid (CL_GLFUNC *ptr_glUniform3fARB)(CLint location, CLfloat v0, CLfloat v1, CLfloat v2);
+	typedef CLvoid (CL_GLFUNC *ptr_glUniform4fARB)(CLint location, CLfloat v0, CLfloat v1, CLfloat v2, CLfloat v3);
+	typedef CLvoid (CL_GLFUNC *ptr_glUniform1iARB)(CLint location, CLint v0);
+	typedef CLvoid (CL_GLFUNC *ptr_glUniform2iARB)(CLint location, CLint v0, CLint v1);
+	typedef CLvoid (CL_GLFUNC *ptr_glUniform3iARB)(CLint location, CLint v0, CLint v1, CLint v2);
+	typedef CLvoid (CL_GLFUNC *ptr_glUniform4iARB)(CLint location, CLint v0, CLint v1, CLint v2, CLint v3);
+	typedef CLvoid (CL_GLFUNC *ptr_glUniform1fvARB)(CLint location, CLsizei count, const CLfloat *value);
+	typedef CLvoid (CL_GLFUNC *ptr_glUniform2fvARB)(CLint location, CLsizei count, const CLfloat *value);
+	typedef CLvoid (CL_GLFUNC *ptr_glUniform3fvARB)(CLint location, CLsizei count, const CLfloat *value);
+	typedef CLvoid (CL_GLFUNC *ptr_glUniform4fvARB)(CLint location, CLsizei count, const CLfloat *value);
+	typedef CLvoid (CL_GLFUNC *ptr_glUniform1ivARB)(CLint location, CLsizei count, const CLint *value);
+	typedef CLvoid (CL_GLFUNC *ptr_glUniform2ivARB)(CLint location, CLsizei count, const CLint *value);
+	typedef CLvoid (CL_GLFUNC *ptr_glUniform3ivARB)(CLint location, CLsizei count, const CLint *value);
+	typedef CLvoid (CL_GLFUNC *ptr_glUniform4ivARB)(CLint location, CLsizei count, const CLint *value);
+	typedef CLvoid (CL_GLFUNC *ptr_glUniformMatrix2fvARB)(CLint location, CLsizei count, CLboolean transpose, const CLfloat *value);
+	typedef CLvoid (CL_GLFUNC *ptr_glUniformMatrix3fvARB)(CLint location, CLsizei count, CLboolean transpose, const CLfloat *value);
+	typedef CLvoid (CL_GLFUNC *ptr_glUniformMatrix4fvARB)(CLint location, CLsizei count, CLboolean transpose, const CLfloat *value);
+	typedef CLvoid (CL_GLFUNC *ptr_glGetObjectParameterfvARB)(CLuint obj, CLenum pname, CLfloat *params);
+	typedef CLvoid (CL_GLFUNC *ptr_glGetObjectParameterivARB)(CLuint obj, CLenum pname, CLint *params);
+	typedef CLvoid (CL_GLFUNC *ptr_glGetInfoLogARB)(CLuint obj, CLsizei maxLength, CLsizei *length, CLchar *infoLog);
+	typedef CLvoid (CL_GLFUNC *ptr_glGetAttachedObjectsARB)(CLuint containerObj, CLsizei maxCount, CLsizei *count, CLuint *obj);
+	typedef CLint (CL_GLFUNC *ptr_glGetUniformLocationARB)(CLuint programObj, const CLchar *name);
+	typedef CLvoid (CL_GLFUNC *ptr_glGetActiveUniformARB)(CLuint programObj, CLuint index, CLsizei maxLength, CLsizei *length, CLsizei *size, CLenum *type, CLchar *name);
+	typedef CLvoid (CL_GLFUNC *ptr_glGetUniformfvARB)(CLuint programObj, CLint location, CLfloat *params);
+	typedef CLvoid (CL_GLFUNC *ptr_glGetUniformivARB)(CLuint programObj, CLint location, CLint *params);
+	typedef CLvoid (CL_GLFUNC *ptr_glGetShaderSourceARB)(CLuint obj, CLsizei maxLength, CLsizei *length, CLchar *source);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib1fARB)(CLuint index, CLfloat v0);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib1sARB)(CLuint index, CLshort v0);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib1dARB)(CLuint index, CLdouble v0);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib2fARB)(CLuint index, CLfloat v0, CLfloat v1);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib2sARB)(CLuint index, CLshort v0, CLshort v1);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib2dARB)(CLuint index, CLdouble v0, CLdouble v1);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib3fARB)(CLuint index, CLfloat v0, CLfloat v1, CLfloat v2);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib3sARB)(CLuint index, CLshort v0, CLshort v1, CLshort v2);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib3dARB)(CLuint index, CLdouble v0, CLdouble v1, CLdouble v2);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib4fARB)(CLuint index, CLfloat v0, CLfloat v1, CLfloat v2, CLfloat v3);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib4sARB)(CLuint index, CLshort v0, CLshort v1, CLshort v2, CLshort v3);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib4dARB)(CLuint index, CLdouble v0, CLdouble v1, CLdouble v2, CLdouble v3);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib4NubARB)(CLuint index, CLubyte x, CLubyte y, CLubyte z, CLubyte w);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib1fvARB)(CLuint index, const CLfloat *v);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib1svARB)(CLuint index, const CLshort *v);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib1dvARB)(CLuint index, const CLdouble *v);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib2fvARB)(CLuint index, const CLfloat *v);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib2svARB)(CLuint index, const CLshort *v);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib2dvARB)(CLuint index, const CLdouble *v);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib3fvARB)(CLuint index, const CLfloat *v);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib3svARB)(CLuint index, const CLshort *v);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib3dvARB)(CLuint index, const CLdouble *v);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib4fvARB)(CLuint index, const CLfloat *v);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib4svARB)(CLuint index, const CLshort *v);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib4dvARB)(CLuint index, const CLdouble *v);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib4ivARB)(CLuint index, const CLint *v);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib4bvARB)(CLuint index, const CLbyte *v);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib4ubvARB)(CLuint index, const CLubyte *v);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib4usvARB)(CLuint index, const CLushort *v);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib4uivARB)(CLuint index, const CLuint *v);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib4NbvARB)(CLuint index, const CLbyte *v);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib4NsvARB)(CLuint index, const CLshort *v);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib4NivARB)(CLuint index, const CLint *v);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib4NubvARB)(CLuint index, const CLubyte *v);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib4NusvARB)(CLuint index, const CLushort *v);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttrib4NuivARB)(CLuint index, const CLuint *v);
+	typedef CLvoid (CL_GLFUNC *ptr_glVertexAttribPointerARB)(CLuint index, CLint size, CLenum type, CLboolean normalized, CLsizei stride, const CLvoid *pointer);
+	typedef CLvoid (CL_GLFUNC *ptr_glEnableVertexAttribArrayARB)(CLuint index);
+	typedef CLvoid (CL_GLFUNC *ptr_glDisableVertexAttribArrayARB)(CLuint index);
+	typedef CLvoid (CL_GLFUNC *ptr_glBindAttribLocationARB)(CLuint programObj, CLuint index, const char *name);
+	typedef CLvoid (CL_GLFUNC *ptr_glGetActiveAttribARB)(CLuint programObj, CLuint index, CLsizei maxLength, CLsizei *length, CLint *size, CLenum *type, char *name);
+	typedef CLint (CL_GLFUNC *ptr_glGetAttribLocationARB)(CLuint programObj, const char *name);
+	typedef CLvoid (CL_GLFUNC *ptr_glGetVertexAttribdvARB)(CLuint index, CLenum pname, CLdouble *params);
+	typedef CLvoid (CL_GLFUNC *ptr_glGetVertexAttribfvARB)(CLuint index, CLenum pname, CLfloat *params);
+	typedef CLvoid (CL_GLFUNC *ptr_glGetVertexAttribivARB)(CLuint index, CLenum pname, CLint *params);
+	typedef CLvoid (CL_GLFUNC *ptr_glGetVertexAttribPointervARB)(CLuint index, CLenum pname, CLvoid **pointer);
+	typedef CLvoid (CL_GLFUNC *ptr_glDrawBuffersARB)(CLsizei n, const CLenum *bufs);
+	typedef CLvoid (CL_GLFUNC *ptr_glStencilFuncSeparateATI)(CLenum frontfunc, CLenum backfunc, CLint ref, CLuint mask);
+	typedef CLvoid (CL_GLFUNC *ptr_glStencilOpSeparateATI)(CLenum face, CLenum sfail, CLenum dpfail, CLenum dppass);
+	typedef CLvoid (CL_GLFUNC *ptr_glActiveStencilFaceEXT)(CLenum face);
+
+//! Functions:
+public:
+	//: glAccum binding
+	ptr_glAccum accum;
+
+	//: glAplhaFunc binding
+	ptr_glAlphaFunc alphaFunc;
+
+	//: glAreTexturesResident binding
+	ptr_glAreTexturesResident areTexturesResident;
+
+	//: glArrayElement binding
+	ptr_glArrayElement arrayElement;
+
+	//: glBegin binding
+	ptr_glBegin begin;
+
+	//: glBindTexture binding
+	ptr_glBindTexture bindTexture;
+
+	//: glBitmap binding
+	ptr_glBitmap bitmap;
+
+	//: glBlendFunc binding
+	ptr_glBlendFunc blendFunc;
+
+	//: glCallList binding
+	ptr_glCallList callList;
+
+	//: glCallLists binding
+	ptr_glCallLists callLists;
+
+	//: glClear binding
+	ptr_glClear clear;
+
+	//: glClearAccum binding
+	ptr_glClearAccum clearAccum;
+
+	//: glClearColor binding
+	ptr_glClearColor clearColor;
+
+	//: glClearDepth binding
+	ptr_glClearDepth clearDepth;
+
+	//: glClearIndex binding
+	ptr_glClearIndex clearIndex;
+
+	//: glClearStencil binding
+	ptr_glClearStencil clearStencil;
+
+	//: glClipPlane binding
+	ptr_glClipPlane clipPlane;
+
+	//: glColor3b binding
+	ptr_glColor3b color3b;
+
+	//: glColor3bv binding
+	ptr_glColor3bv color3bv;
+
+	//: glColor3d binding
+	ptr_glColor3d color3d;
+
+	//: glColor3dv binding
+	ptr_glColor3dv color3dv;
+
+	//: glColor3f binding
+	ptr_glColor3f color3f;
+
+	//: glColor3fv binding
+	ptr_glColor3fv color3fv;
+
+	//: glColor3i binding
+	ptr_glColor3i color3i;
+
+	//: glColor3iv binding
+	ptr_glColor3iv color3iv;
+
+	//: glColor3s binding
+	ptr_glColor3s color3s;
+
+	//: glColor3sv binding
+	ptr_glColor3sv color3sv;
+
+	//: glColor3ub binding
+	ptr_glColor3ub color3ub;
+
+	//: glColor3ubv binding
+	ptr_glColor3ubv color3ubv;
+
+	//: glColor3ui binding
+	ptr_glColor3ui color3ui;
+
+	//: glColor3uiv binding
+	ptr_glColor3uiv color3uiv;
+
+	//: glColor3us binding
+	ptr_glColor3us color3us;
+
+	//: glColor3usv binding
+	ptr_glColor3usv color3usv;
+
+	//: glColor4b binding
+	ptr_glColor4b color4b;
+
+	//: glColor4bv binding
+	ptr_glColor4bv color4bv;
+
+	//: glColor4d binding
+	ptr_glColor4d color4d;
+
+	//: glColor4dv binding
+	ptr_glColor4dv color4dv;
+
+	//: glColor4f binding
+	ptr_glColor4f color4f;
+
+	//: glColor4fv binding
+	ptr_glColor4fv color4fv;
+
+	//: glColor4i binding
+	ptr_glColor4i color4i;
+
+	//: glColor4iv binding
+	ptr_glColor4iv color4iv;
+
+	//: glColor4s binding
+	ptr_glColor4s color4s;
+
+	//: glColor4sv binding
+	ptr_glColor4sv color4sv;
+
+	//: glColor4ub binding
+	ptr_glColor4ub color4ub;
+
+	//: glColor4ubv binding
+	ptr_glColor4ubv color4ubv;
+
+	//: glColor4ui binding
+	ptr_glColor4ui color4ui;
+
+	//: glColor4uiv binding
+	ptr_glColor4uiv color4uiv;
+
+	//: glColor4us binding
+	ptr_glColor4us color4us;
+
+	//: glColor4usv binding
+	ptr_glColor4usv color4usv;
+
+	//: glColorMask binding
+	ptr_glColorMask colorMask;
+
+	//: glColorMaterial binding
+	ptr_glColorMaterial colorMaterial;
+
+	//: glColorPointer binding
+	ptr_glColorPointer colorPointer;
+
+	//: glCopyPixels binding
+	ptr_glCopyPixels copyPixels;
+
+	//: glCopyTexImage1D binding
+	ptr_glCopyTexImage1D copyTexImage1D;
+
+	//: glCopyTexImage2D binding
+	ptr_glCopyTexImage2D copyTexImage2D;
+
+	//: glCopyTexSubImage1D binding
+	ptr_glCopyTexSubImage1D copyTexSubImage1D;
+
+	//: glCopyTexSubImage2D binding
+	ptr_glCopyTexSubImage2D copyTexSubImage2D;
+
+	//: glCullFace binding
+	ptr_glCullFace cullFace;
+
+	//: glDeleteLists binding
+	ptr_glDeleteLists deleteLists;
+
+	//: glDeleteTextures binding
+	ptr_glDeleteTextures deleteTextures;
+
+	//: glDepthFunc binding
+	ptr_glDepthFunc depthFunc;
+
+	//: glDepthMask binding
+	ptr_glDepthMask depthMask;
+
+	//: glDepthRange binding
+	ptr_glDepthRange depthRange;
+
+	//: glDisable binding
+	ptr_glDisable disable;
+
+	//: glDisableClientState binding
+	ptr_glDisableClientState disableClientState;
+
+	//: glDrawArrays binding
+	ptr_glDrawArrays drawArrays;
+
+	//: glDrawBuffer binding
+	ptr_glDrawBuffer drawBuffer;
+
+	//: glDrawElements binding
+	ptr_glDrawElements drawElements;
+
+	//: glDrawPixels binding
+	ptr_glDrawPixels drawPixels;
+
+	//: glEdgeFlag binding
+	ptr_glEdgeFlag edgeFlag;
+
+	//: glEdgeFlagPointer binding
+	ptr_glEdgeFlagPointer edgeFlagPointer;
+
+	//: glEdgeFlagv binding
+	ptr_glEdgeFlagv edgeFlagv;
+
+	//: glEnable binding
+	ptr_glEnable enable;
+
+	//: glEnableClientState binding
+	ptr_glEnableClientState enableClientState;
+
+	//: glEnd binding
+	ptr_glEnd end;
+
+	//: glEndList binding
+	ptr_glEndList endList;
+
+	//: glEvalCoord1d binding
+	ptr_glEvalCoord1d evalCoord1d;
+
+	//: glEvalCoord1dv binding
+	ptr_glEvalCoord1dv evalCoord1dv;
+
+	//: glEvalCoord1f binding
+	ptr_glEvalCoord1f evalCoord1f;
+
+	//: glEvalCoord1fv binding
+	ptr_glEvalCoord1fv evalCoord1fv;
+
+	//: glEvalCoord2d binding
+	ptr_glEvalCoord2d evalCoord2d;
+
+	//: glEvalCoord2dv binding
+	ptr_glEvalCoord2dv evalCoord2dv;
+
+	//: glEvalCoord2f binding
+	ptr_glEvalCoord2f evalCoord2f;
+
+	//: glEvalCoord2fv binding
+	ptr_glEvalCoord2fv evalCoord2fv;
+
+	//: glEvalMesh1 binding
+	ptr_glEvalMesh1 evalMesh1;
+
+	//: glEvalMesh2 binding
+	ptr_glEvalMesh2 evalMesh2;
+
+	//: glEvalPoint1 binding
+	ptr_glEvalPoint1 evalPoint1;
+
+	//: glEvalPoint2 binding
+	ptr_glEvalPoint2 evalPoint2;
+
+	//: glFeedbackBuffer binding
+	ptr_glFeedbackBuffer feedbackBuffer;
+
+	//: glFinish binding
+	ptr_glFinish finish;
+
+	//: glFlush binding
+	ptr_glFlush flush;
+
+	//: glFogf binding
+	ptr_glFogf fogf;
+
+	//: glFogfv binding
+	ptr_glFogfv fogfv;
+
+	//: glFogi binding
+	ptr_glFogi fogi;
+
+	//: glFogiv binding
+	ptr_glFogiv fogiv;
+
+	//: glFrontFace binding
+	ptr_glFrontFace frontFace;
+
+	//: glFrustum binding
+	ptr_glFrustum frustum;
+
+	//: glGenLists binding
+	ptr_glGenLists genLists;
+
+	//: glGenTextures binding
+	ptr_glGenTextures genTextures;
+
+	//: glGetBooleanv binding
+	ptr_glGetBooleanv getBooleanv;
+
+	//: glGetClipPlane binding
+	ptr_glGetClipPlane getClipPlane;
+
+	//: glGetDoublev binding
+	ptr_glGetDoublev getDoublev;
+
+	//: glGetError binding
+	ptr_glGetError getError;
+
+	//: glGetFloatv binding
+	ptr_glGetFloatv getFloatv;
+
+	//: glGetIntegerv binding
+	ptr_glGetIntegerv getIntegerv;
+
+	//: glGetLightfv binding
+	ptr_glGetLightfv getLightfv;
+
+	//: glGetLightiv binding
+	ptr_glGetLightiv getLightiv;
+
+	//: glGetMapdv binding
+	ptr_glGetMapdv getMapdv;
+
+	//: glGetMapfv binding
+	ptr_glGetMapfv getMapfv;
+
+	//: glGetMapiv binding
+	ptr_glGetMapiv getMapiv;
+
+	//: glGetMaterialfv binding
+	ptr_glGetMaterialfv getMaterialfv;
+
+	//: glGetMaterialiv binding
+	ptr_glGetMaterialiv getMaterialiv;
+
+	//: glGetPixelMapfv binding
+	ptr_glGetPixelMapfv getPixelMapfv;
+
+	//: glGetPixelMapuiv binding
+	ptr_glGetPixelMapuiv getPixelMapuiv;
+
+	//: glGetPixelMapusv binding
+	ptr_glGetPixelMapusv getPixelMapusv;
+
+	//: glGetPointerv binding
+	ptr_glGetPointerv getPointerv;
+
+	//: glGetPolygonStipple binding
+	ptr_glGetPolygonStipple getPolygonStipple;
+
+	//: glGetString binding
+	ptr_glGetString getString;
+
+	//: glGetTexEnvfv binding
+	ptr_glGetTexEnvfv getTexEnvfv;
+
+	//: glGetTexEnviv binding
+	ptr_glGetTexEnviv getTexEnviv;
+
+	//: glGetTexGendv binding
+	ptr_glGetTexGendv getTexGendv;
+
+	//: glGetTexGenfv binding
+	ptr_glGetTexGenfv getTexGenfv;
+
+	//: glGetTexGeniv binding
+	ptr_glGetTexGeniv getTexGeniv;
+
+	//: glGetTexImage binding
+	ptr_glGetTexImage getTexImage;
+
+	//: glGetTexLevelParameterfv binding
+	ptr_glGetTexLevelParameterfv getTexLevelParameterfv;
+
+	//: glGetTexLevelParameteriv binding
+	ptr_glGetTexLevelParameteriv getTexLevelParameteriv;
+
+	//: glGetTexParameterfv binding
+	ptr_glGetTexParameterfv getTexParameterfv;
+
+	//: glGetTexParameteriv binding
+	ptr_glGetTexParameteriv getTexParameteriv;
+
+	//: glHint binding
+	ptr_glHint hint;
+
+	//: glIndexMask binding
+	ptr_glIndexMask indexMask;
+
+	//: glIndexPointer binding
+	ptr_glIndexPointer indexPointer;
+
+	//: glIndexd binding
+	ptr_glIndexd indexd;
+
+	//: glIndexdv binding
+	ptr_glIndexdv indexdv;
+
+	//: glIndexf binding
+	ptr_glIndexf indexf;
+
+	//: glIndexfv binding
+	ptr_glIndexfv indexfv;
+
+	//: glIndexi binding
+	ptr_glIndexi indexi;
+
+	//: glIndexiv binding
+	ptr_glIndexiv indexiv;
+
+	//: glIndexs binding
+	ptr_glIndexs indexs;
+
+	//: glIndexsv binding
+	ptr_glIndexsv indexsv;
+
+	//: glIndexub binding
+	ptr_glIndexub indexub;
+
+	//: glIndexubv binding
+	ptr_glIndexubv indexubv;
+
+	//: glInitNames binding
+	ptr_glInitNames initNames;
+
+	//: glInterleavedArrays binding
+	ptr_glInterleavedArrays interleavedArrays;
+
+	//: glIsEnabled binding
+	ptr_glIsEnabled isEnabled;
+
+	//: glIsList binding
+	ptr_glIsList isList;
+
+	//: glIsTexture binding
+	ptr_glIsTexture isTexture;
+
+	//: glLightModelf binding
+	ptr_glLightModelf lightModelf;
+
+	//: glLightModelfv binding
+	ptr_glLightModelfv lightModelfv;
+
+	//: glLightModeli binding
+	ptr_glLightModeli lightModeli;
+
+	//: glLightModeliv binding
+	ptr_glLightModeliv lightModeliv;
+
+	//: glLightf binding
+	ptr_glLightf lightf;
+
+	//: glLightfv binding
+	ptr_glLightfv lightfv;
+
+	//: glLighti binding
+	ptr_glLighti lighti;
+
+	//: glLightiv binding
+	ptr_glLightiv lightiv;
+
+	//: glLineStipple binding
+	ptr_glLineStipple lineStipple;
+
+	//: glLineWidth binding
+	ptr_glLineWidth lineWidth;
+
+	//: glListBase binding
+	ptr_glListBase listBase;
+
+	//: glLoadIdentity binding
+	ptr_glLoadIdentity loadIdentity;
+
+	//: glLoadMatrixd binding
+	ptr_glLoadMatrixd loadMatrixd;
+
+	//: glLoadMatrixf binding
+	ptr_glLoadMatrixf loadMatrixf;
+
+	//: glLoadName binding
+	ptr_glLoadName loadName;
+
+	//: glLogicOp binding
+	ptr_glLogicOp logicOp;
+
+	//: glMap1d binding
+	ptr_glMap1d map1d;
+
+	//: glMap1f binding
+	ptr_glMap1f map1f;
+
+	//: glMap2d binding
+	ptr_glMap2d map2d;
+
+	//: glMap2f binding
+	ptr_glMap2f map2f;
+
+	//: glMapGrid1d binding
+	ptr_glMapGrid1d mapGrid1d;
+
+	//: glMapGrid1f binding
+	ptr_glMapGrid1f mapGrid1f;
+
+	//: glMapGrid2d binding
+	ptr_glMapGrid2d mapGrid2d;
+
+	//: glMapGrid2f binding
+	ptr_glMapGrid2f mapGrid2f;
+
+	//: glMaterialf binding
+	ptr_glMaterialf materialf;
+
+	//: glMaterialfv binding
+	ptr_glMaterialfv materialfv;
+
+	//: glMateriali binding
+	ptr_glMateriali materiali;
+
+	//: glMaterialiv binding
+	ptr_glMaterialiv materialiv;
+
+	//: glMatrixMode binding
+	ptr_glMatrixMode matrixMode;
+
+	//: glMultMatrixd binding
+	ptr_glMultMatrixd multMatrixd;
+
+	//: glMultMatrixf binding
+	ptr_glMultMatrixf multMatrixf;
+
+	//: glNewList binding
+	ptr_glNewList newList;
+
+	//: glNormal3b binding
+	ptr_glNormal3b normal3b;
+
+	//: glNormal3bv binding
+	ptr_glNormal3bv normal3bv;
+
+	//: glNormal3d binding
+	ptr_glNormal3d normal3d;
+
+	//: glNormal3dv binding
+	ptr_glNormal3dv normal3dv;
+
+	//: glNormal3f binding
+	ptr_glNormal3f normal3f;
+
+	//: glNormal3fv binding
+	ptr_glNormal3fv normal3fv;
+
+	//: glNormal3i binding
+	ptr_glNormal3i normal3i;
+
+	//: glNormal3iv binding
+	ptr_glNormal3iv normal3iv;
+
+	//: glNormal3s binding
+	ptr_glNormal3s normal3s;
+
+	//: glNormal3sv binding
+	ptr_glNormal3sv normal3sv;
+
+	//: glNormalPointer binding
+	ptr_glNormalPointer normalPointer;
+
+	//: glOrtho binding
+	ptr_glOrtho ortho;
+
+	//: glPassThrough binding
+	ptr_glPassThrough passThrough;
+
+	//: glPixelMapfv binding
+	ptr_glPixelMapfv pixelMapfv;
+
+	//: glPixelMapuiv binding
+	ptr_glPixelMapuiv pixelMapuiv;
+
+	//: glPixelMapusv binding
+	ptr_glPixelMapusv pixelMapusv;
+
+	//: glPixelStoref binding
+	ptr_glPixelStoref pixelStoref;
+
+	//: glPixelStorei binding
+	ptr_glPixelStorei pixelStorei;
+
+	//: glPixelTransferf binding
+	ptr_glPixelTransferf pixelTransferf;
+
+	//: glPixelTransferi binding
+	ptr_glPixelTransferi pixelTransferi;
+
+	//: glPixelZoom binding
+	ptr_glPixelZoom pixelZoom;
+
+	//: glPointSize binding
+	ptr_glPointSize pointSize;
+
+	//: glPolygonMode binding
+	ptr_glPolygonMode polygonMode;
+
+	//: glPolygonOffset binding
+	ptr_glPolygonOffset polygonOffset;
+
+	//: glPolygonStipple binding
+	ptr_glPolygonStipple polygonStipple;
+
+	//: glPopAttrib binding
+	ptr_glPopAttrib popAttrib;
+
+	//: glPopClientAttrib binding
+	ptr_glPopClientAttrib popClientAttrib;
+
+	//: glPopMatrix binding
+	ptr_glPopMatrix popMatrix;
+
+	//: glPopName binding
+	ptr_glPopName popName;
+
+	//: glPrioritizeTextures binding
+	ptr_glPrioritizeTextures prioritizeTextures;
+
+	//: glPushAttrib binding
+	ptr_glPushAttrib pushAttrib;
+
+	//: glPushClientAttrib binding
+	ptr_glPushClientAttrib pushClientAttrib;
+
+	//: glPushMatrix binding
+	ptr_glPushMatrix pushMatrix;
+
+	//: glPushName binding
+	ptr_glPushName pushName;
+
+	//: glRasterPos2d binding
+	ptr_glRasterPos2d rasterPos2d;
+
+	//: glRasterPos2dv binding
+	ptr_glRasterPos2dv rasterPos2dv;
+
+	//: glRasterPos2f binding
+	ptr_glRasterPos2f rasterPos2f;
+
+	//: glRasterPos2fv binding
+	ptr_glRasterPos2fv rasterPos2fv;
+
+	//: glRasterPos2i binding
+	ptr_glRasterPos2i rasterPos2i;
+
+	//: glRasterPos2iv binding
+	ptr_glRasterPos2iv rasterPos2iv;
+
+	//: glRasterPos2s binding
+	ptr_glRasterPos2s rasterPos2s;
+
+	//: glRasterPos2sv binding
+	ptr_glRasterPos2sv rasterPos2sv;
+
+	//: glRasterPos3d binding
+	ptr_glRasterPos3d rasterPos3d;
+
+	//: glRasterPos3dv binding
+	ptr_glRasterPos3dv rasterPos3dv;
+
+	//: glRasterPos3f binding
+	ptr_glRasterPos3f rasterPos3f;
+
+	//: glRasterPos3fv binding
+	ptr_glRasterPos3fv rasterPos3fv;
+
+	//: glRasterPos3i binding
+	ptr_glRasterPos3i rasterPos3i;
+
+	//: glRasterPos3iv binding
+	ptr_glRasterPos3iv rasterPos3iv;
+
+	//: glRasterPos3s binding
+	ptr_glRasterPos3s rasterPos3s;
+
+	//: glRasterPos3sv binding
+	ptr_glRasterPos3sv rasterPos3sv;
+
+	//: glRasterPos4d binding
+	ptr_glRasterPos4d rasterPos4d;
+
+	//: glRasterPos4dv binding
+	ptr_glRasterPos4dv rasterPos4dv;
+
+	//: glRasterPos4f binding
+	ptr_glRasterPos4f rasterPos4f;
+
+	//: glRasterPos4fv binding
+	ptr_glRasterPos4fv rasterPos4fv;
+
+	//: glRasterPos4i binding
+	ptr_glRasterPos4i rasterPos4i;
+
+	//: glRasterPos4iv binding
+	ptr_glRasterPos4iv rasterPos4iv;
+
+	//: glRasterPos4s binding
+	ptr_glRasterPos4s rasterPos4s;
+
+	//: glRasterPos4sv binding
+	ptr_glRasterPos4sv rasterPos4sv;
+
+	//: glReadBuffer binding
+	ptr_glReadBuffer readBuffer;
+
+	//: glReadPixels binding
+	ptr_glReadPixels readPixels;
+
+	//: glRectd binding
+	ptr_glRectd rectd;
+
+	//: glRectdv binding
+	ptr_glRectdv rectdv;
+
+	//: glRectf binding
+	ptr_glRectf rectf;
+
+	//: glRectfv binding
+	ptr_glRectfv rectfv;
+
+	//: glRecti binding
+	ptr_glRecti recti;
+
+	//: glRectiv binding
+	ptr_glRectiv rectiv;
+
+	//: glRects binding
+	ptr_glRects rects;
+
+	//: glRectsv binding
+	ptr_glRectsv rectsv;
+
+	//: glRenderMode binding
+	ptr_glRenderMode renderMode;
+
+	//: glRotated binding
+	ptr_glRotated rotated;
+
+	//: glRotatef binding
+	ptr_glRotatef rotatef;
+
+	//: glScaled binding
+	ptr_glScaled scaled;
+
+	//: glScalef binding
+	ptr_glScalef scalef;
+
+	//: glScissor binding
+	ptr_glScissor scissor;
+
+	//: glSelectBuffer binding
+	ptr_glSelectBuffer selectBuffer;
+
+	//: glShadeModel binding
+	ptr_glShadeModel shadeModel;
+
+	//: glStencilFunc binding
+	ptr_glStencilFunc stencilFunc;
+
+	//: glStencilMask binding
+	ptr_glStencilMask stencilMask;
+
+	//: glStencilOp binding
+	ptr_glStencilOp stencilOp;
+
+	//: glTexCoord1d binding
+	ptr_glTexCoord1d texCoord1d;
+
+	//: glTexCoord1dv binding
+	ptr_glTexCoord1dv texCoord1dv;
+
+	//: glTexCoord1f binding
+	ptr_glTexCoord1f texCoord1f;
+
+	//: glTexCoord1fv binding
+	ptr_glTexCoord1fv texCoord1fv;
+
+	//: glTexCoord1i binding
+	ptr_glTexCoord1i texCoord1i;
+
+	//: glTexCoord1iv binding
+	ptr_glTexCoord1iv texCoord1iv;
+
+	//: glTexCoord1s binding
+	ptr_glTexCoord1s texCoord1s;
+
+	//: glTexCoord1sv binding
+	ptr_glTexCoord1sv texCoord1sv;
+
+	//: glTexCoord2d binding
+	ptr_glTexCoord2d texCoord2d;
+
+	//: glTexCoord2dv binding
+	ptr_glTexCoord2dv texCoord2dv;
+
+	//: glTexCoord2f binding
+	ptr_glTexCoord2f texCoord2f;
+
+	//: glTexCoord2fv binding
+	ptr_glTexCoord2fv texCoord2fv;
+
+	//: glTexCoord2i binding
+	ptr_glTexCoord2i texCoord2i;
+
+	//: glTexCoord2iv binding
+	ptr_glTexCoord2iv texCoord2iv;
+
+	//: glTexCoord2s binding
+	ptr_glTexCoord2s texCoord2s;
+
+	//: glTexCoord2sv binding
+	ptr_glTexCoord2sv texCoord2sv;
+
+	//: glTexCoord3d binding
+	ptr_glTexCoord3d texCoord3d;
+
+	//: glTexCoord3dv binding
+	ptr_glTexCoord3dv texCoord3dv;
+
+	//: glTexCoord3f binding
+	ptr_glTexCoord3f texCoord3f;
+
+	//: glTexCoord3fv binding
+	ptr_glTexCoord3fv texCoord3fv;
+
+	//: glTexCoord3i binding
+	ptr_glTexCoord3i texCoord3i;
+
+	//: glTexCoord3iv binding
+	ptr_glTexCoord3iv texCoord3iv;
+
+	//: glTexCoord3s binding
+	ptr_glTexCoord3s texCoord3s;
+
+	//: glTexCoord3sv binding
+	ptr_glTexCoord3sv texCoord3sv;
+
+	//: glTexCoord4d binding
+	ptr_glTexCoord4d texCoord4d;
+
+	//: glTexCoord4dv binding
+	ptr_glTexCoord4dv texCoord4dv;
+
+	//: glTexCoord4f binding
+	ptr_glTexCoord4f texCoord4f;
+
+	//: glTexCoord4fv binding
+	ptr_glTexCoord4fv texCoord4fv;
+
+	//: glTexCoord4i binding
+	ptr_glTexCoord4i texCoord4i;
+
+	//: glTexCoord4iv binding
+	ptr_glTexCoord4iv texCoord4iv;
+
+	//: glTexCoord4s binding
+	ptr_glTexCoord4s texCoord4s;
+
+	//: glTexCoord4sv binding
+	ptr_glTexCoord4sv texCoord4sv;
+
+	//: glTexCoordPointer binding
+	ptr_glTexCoordPointer texCoordPointer;
+
+	//: glTexEnvf binding
+	ptr_glTexEnvf texEnvf;
+
+	//: glTexEnvfv binding
+	ptr_glTexEnvfv texEnvfv;
+
+	//: glTexEnvi binding
+	ptr_glTexEnvi texEnvi;
+
+	//: glTexEnviv binding
+	ptr_glTexEnviv texEnviv;
+
+	//: glTexGend binding
+	ptr_glTexGend texGend;
+
+	//: glTexGendv binding
+	ptr_glTexGendv texGendv;
+
+	//: glTexGenf binding
+	ptr_glTexGenf texGenf;
+
+	//: glTexGenfv binding
+	ptr_glTexGenfv texGenfv;
+
+	//: glTexGeni binding
+	ptr_glTexGeni texGeni;
+
+	//: glTexGeniv binding
+	ptr_glTexGeniv texGeniv;
+
+	//: glTexImage1D binding
+	ptr_glTexImage1D texImage1D;
+
+	//: glTexImage2D binding
+	ptr_glTexImage2D texImage2D;
+
+	//: glTexParameterf binding
+	ptr_glTexParameterf texParameterf;
+
+	//: glTexParameterfv binding
+	ptr_glTexParameterfv texParameterfv;
+
+	//: glTexParameteri binding
+	ptr_glTexParameteri texParameteri;
+
+	//: glTexParameteriv binding
+	ptr_glTexParameteriv texParameteriv;
+
+	//: glTexSubImage1D binding
+	ptr_glTexSubImage1D texSubImage1D;
+
+	//: glTexSubImage2D binding
+	ptr_glTexSubImage2D texSubImage2D;
+
+	//: glTranslated binding
+	ptr_glTranslated translated;
+
+	//: glTranslatef binding
+	ptr_glTranslatef translatef;
+
+	//: glVertex2d binding
+	ptr_glVertex2d vertex2d;
+
+	//: glVertex2dv binding
+	ptr_glVertex2dv vertex2dv;
+
+	//: glVertex2f binding
+	ptr_glVertex2f vertex2f;
+
+	//: glVertex2fv binding
+	ptr_glVertex2fv vertex2fv;
+
+	//: glVertex2i binding
+	ptr_glVertex2i vertex2i;
+
+	//: glVertex2iv binding
+	ptr_glVertex2iv vertex2iv;
+
+	//: glVertex2s binding
+	ptr_glVertex2s vertex2s;
+
+	//: glVertex2sv binding
+	ptr_glVertex2sv vertex2sv;
+
+	//: glVertex3d binding
+	ptr_glVertex3d vertex3d;
+
+	//: glVertex3dv binding
+	ptr_glVertex3dv vertex3dv;
+
+	//: glVertex3f binding
+	ptr_glVertex3f vertex3f;
+
+	//: glVertex3fv binding
+	ptr_glVertex3fv vertex3fv;
+
+	//: glVertex3i binding
+	ptr_glVertex3i vertex3i;
+
+	//: glVertex3iv binding
+	ptr_glVertex3iv vertex3iv;
+
+	//: glVertex3s binding
+	ptr_glVertex3s vertex3s;
+
+	//: glVertex3sv binding
+	ptr_glVertex3sv vertex3sv;
+
+	//: glVertex4d binding
+	ptr_glVertex4d vertex4d;
+
+	//: glVertex4dv binding
+	ptr_glVertex4dv vertex4dv;
+
+	//: glVertex4f binding
+	ptr_glVertex4f vertex4f;
+
+	//: glVertex4fv binding
+	ptr_glVertex4fv vertex4fv;
+
+	//: glVertex4i binding
+	ptr_glVertex4i vertex4i;
+
+	//: glVertex4iv binding
+	ptr_glVertex4iv vertex4iv;
+
+	//: glVertex4s binding
+	ptr_glVertex4s vertex4s;
+
+	//: glVertex4sv binding
+	ptr_glVertex4sv vertex4sv;
+
+	//: glVertexPointer binding
+	ptr_glVertexPointer vertexPointer;
+
+	//: glViewport binding
+	ptr_glViewport viewport;
+
+	//: glDrawRangeElements binding (OpenGL 1.2, EXT_draw_range_elements)
+	ptr_glDrawRangeElementsEXT drawRangeElements;
+
+	//: glTexImage3D binding (OpenGL 1.2, EXT_texture3D)
+	ptr_glTexImage3DEXT texImage3D;
+
+	//: glTexSubImage3D binding (OpenGL 1.2, EXT_texture3D)
+	ptr_glTexSubImage3DEXT texSubImage3D;
+
+	//: glCopyTexSubImage3D binding (OpenGL 1.2, EXT_texture3D)
+	ptr_glCopyTexSubImage3DEXT copyTexSubImage3D;
+
+	//: glColorTable (OpenGL 1.2 Imaging subset, EXT_color_table, SGI_color_table)
+	ptr_glColorTableSGI colorTable;
+
+	//: glCopyColorTable (OpenGL 1.2 Imaging subset, EXT_color_table, SGI_color_table)
+	ptr_glCopyColorTableSGI copyColorTable;
+
+	//: glColorTableParameteriv (OpenGL 1.2 Imaging subset, EXT_color_table, SGI_color_table)
+	ptr_glColorTableParameterivSGI colorTableParameteriv;
+
+	//: glColorTableParameterfv (OpenGL 1.2 Imaging subset, EXT_color_table, SGI_color_table)
+	ptr_glColorTableParameterfvSGI colorTableParameterfv;
+
+	//: glGetColorTable (OpenGL 1.2 Imaging subset, EXT_color_table, SGI_color_table)
+	ptr_glGetColorTableSGI getColorTable;
+
+	//: glGetColorTableParameteriv (OpenGL 1.2 Imaging subset, EXT_color_table, SGI_color_table)
+	ptr_glGetColorTableParameterivSGI getColorTableParameteriv;
+
+	//: glGetColorTableParameterfv (OpenGL 1.2 Imaging subset, EXT_color_table, SGI_color_table)
+	ptr_glGetColorTableParameterfvSGI getColorTableParameterfv;
+
+	//: glColorSubTable (OpenGL 1.2 Imaging subset, EXT_color_subtable)
+	ptr_glColorSubTableEXT colorSubTable;
+
+	//: glCopyColorSubTable (OpenGL 1.2 Imaging subset, EXT_color_subtable)
+	ptr_glCopyColorSubTableEXT copyColorSubTable;
+
+	//: glConvolutionFilter1D (OpenGL 1.2 Imaging subset, EXT_convolution)
+	ptr_glConvolutionFilter1DEXT convolutionFilter1D;
+
+	//: glConvolutionFilter2D (OpenGL 1.2 Imaging subset, EXT_convolution)
+	ptr_glConvolutionFilter2DEXT convolutionFilter2D;
+
+	//: glCopyConvolutionFilter1D (OpenGL 1.2 Imaging subset, EXT_convolution)
+	ptr_glCopyConvolutionFilter1DEXT copyConvolutionFilter1D;
+
+	//: glCopyConvolutionFilter2D (OpenGL 1.2 Imaging subset, EXT_convolution)
+	ptr_glCopyConvolutionFilter2DEXT copyConvolutionFilter2D;
+
+	//: glGetConvolutionFilter (OpenGL 1.2 Imaging subset, EXT_convolution)
+	ptr_glGetConvolutionFilterEXT getConvolutionFilter;
+
+	//: glSeparableFilter2D (OpenGL 1.2 Imaging subset, EXT_convolution)
+	ptr_glSeparableFilter2DEXT separableFilter2D;
+
+	//: glGetSeparableFilter (OpenGL 1.2 Imaging subset, EXT_convolution)
+	ptr_glGetSeparableFilterEXT getSeparableFilter;
+
+	//: glConvolutionParameteri (OpenGL 1.2 Imaging subset, EXT_convolution)
+	ptr_glConvolutionParameteriEXT convolutionParameteri;
+
+	//: glConvolutionParameterv (OpenGL 1.2 Imaging subset, EXT_convolution)
+	ptr_glConvolutionParameterivEXT convolutionParameteriv;
+
+	//: glConvolutionParameterf (OpenGL 1.2 Imaging subset, EXT_convolution)
+	ptr_glConvolutionParameterfEXT convolutionParameterf;
+
+	//: glConvolutionParameterfv (OpenGL 1.2 Imaging subset, EXT_convolution)
+	ptr_glConvolutionParameterfvEXT convolutionParameterfv;
+
+	//: glGetConvolutionParameteriv (OpenGL 1.2 Imaging subset, EXT_convolution)
+	ptr_glGetConvolutionParameterivEXT getConvolutionParameteriv;
+
+	//: glGetConvolutionParameterfv (OpenGL 1.2 Imaging subset, EXT_convolution)
+	ptr_glGetConvolutionParameterfvEXT getConvolutionParameterfv;
+
+	//: glHistogram (OpenGL 1.2 Imaging subset, EXT_histogram)
+	ptr_glHistogramEXT histogram;
+
+	//: glResetHistogram (OpenGL 1.2 Imaging subset, EXT_histogram)
+	ptr_glResetHistogramEXT resetHistogram;
+
+	//: glGetHistogram (OpenGL 1.2 Imaging subset, EXT_histogram)
+	ptr_glGetHistogramEXT getHistogram;
+
+	//: glHistogramParameteriv (OpenGL 1.2 Imaging subset, EXT_histogram)
+	ptr_glGetHistogramParameterivEXT getHistogramParameteriv;
+
+	//: glHistogramParameterfv (OpenGL 1.2 Imaging subset, EXT_histogram)
+	ptr_glGetHistogramParameterfvEXT getHistogramParameterfv;
+
+	//: glMinmax (OpenGL 1.2 Imaging subset, EXT_histogram)
+	ptr_glMinmaxEXT minmax;
+
+	//: glResetMinmax (OpenGL 1.2 Imaging subset, EXT_histogram)
+	ptr_glResetMinmaxEXT resetMinmax;
+
+	//: glGetMinmax (OpenGL 1.2 Imaging subset, EXT_histogram)
+	ptr_glGetMinmaxEXT getMinmax;
+
+	//: glGetMinmaxParameteriv (OpenGL 1.2 Imaging subset, EXT_histogram)
+	ptr_glGetMinmaxParameterivEXT getMinmaxParameteriv;
+
+	//: glGetMinmaxParameterfv (OpenGL 1.2 Imaging subset, EXT_histogram)
+	ptr_glGetMinmaxParameterfvEXT getMinmaxParameterfv;
+
+	//: glBlendColor (OpenGL 1.2 Imaging subset, OpenGL 1.4, EXT_blend_color)
+	ptr_glBlendColorEXT blendColor;
+
+	//: glBlendEquation (OpenGL 1.2 Imaging subset, EXT_blend_minmax)
+	ptr_glBlendEquationEXT blendEquation;
+
+	//: glActiveTexture (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glActiveTextureARB activeTexture;
+
+	//: glClientActiveTexture (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glClientActiveTextureARB clientActiveTexture;
+
+	//: glMultiTexCoord1d (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord1dARB multiTexCoord1d;
+
+	//: glMultiTexCoord1dv (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord1dvARB multiTexCoord1dv;
+
+	//: glMultiTexCoord1f (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord1fARB multiTexCoord1f;
+
+	//: glMultiTexCoord1fv (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord1fvARB multiTexCoord1fv;
+
+	//: glMultiTexCoord1i (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord1iARB multiTexCoord1i;
+
+	//: glMultiTexCoord1iv (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord1ivARB multiTexCoord1iv;
+
+	//: glMultiTexCoord1s (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord1sARB multiTexCoord1s;
+
+	//: glMultiTexCoord1sv (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord1svARB multiTexCoord1sv;
+
+	//: glMultiTexCoord2d (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord2dARB multiTexCoord2d;
+
+	//: glMultiTexCoord2dv (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord2dvARB multiTexCoord2dv;
+
+	//: glMultiTexCoord2f (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord2fARB multiTexCoord2f;
+
+	//: glMultiTexCoord2fv (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord2fvARB multiTexCoord2fv;
+
+	//: glMultiTexCoord2i (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord2iARB multiTexCoord2i;
+
+	//: glMultiTexCoord2iv (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord2ivARB multiTexCoord2iv;
+
+	//: glMultiTexCoord2s (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord2sARB multiTexCoord2s;
+
+	//: glMultiTexCoord2sv (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord2svARB multiTexCoord2sv;
+
+	//: glMultiTexCoord3d (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord3dARB multiTexCoord3d;
+
+	//: glMultiTexCoord3dv (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord3dvARB multiTexCoord3dv;
+
+	//: glMultiTexCoord3f (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord3fARB multiTexCoord3f;
+
+	//: glMultiTexCoord3fv (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord3fvARB multiTexCoord3fv;
+
+	//: glMultiTexCoord3i (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord3iARB multiTexCoord3i;
+
+	//: glMultiTexCoord3iv (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord3ivARB multiTexCoord3iv;
+
+	//: glMultiTexCoord3s (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord3sARB multiTexCoord3s;
+
+	//: glMultiTexCoord3sv (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord3svARB multiTexCoord3sv;
+
+	//: glMultiTexCoord4d (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord4dARB multiTexCoord4d;
+
+	//: glMultiTexCoord4dv (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord4dvARB multiTexCoord4dv;
+
+	//: glMultiTexCoord4f (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord4fARB multiTexCoord4f;
+
+	//: glMultiTexCoord4fv (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord4fvARB multiTexCoord4fv;
+
+	//: glMultiTexCoord4i (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord4iARB multiTexCoord4i;
+
+	//: glMultiTexCoord4iv (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord4ivARB multiTexCoord4iv;
+
+	//: glMultiTexCoord4s (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord4sARB multiTexCoord4s;
+
+	//: glMultiTexCoord4sv (OpenGL 1.2.1, ARB_multitexture)
+	ptr_glMultiTexCoord4svARB multiTexCoord4sv;
+
+	//: glCompressedTexImage1D (OpenGL 1.3, ARB_texture_compression)
+	ptr_glCompressedTexImage1DARB compressedTexImage1D;
+
+	//: glCompressedTexImage2D (OpenGL 1.3, ARB_texture_compression)
+	ptr_glCompressedTexImage2DARB compressedTexImage2D;
+
+	//: glCompressedTexImage3D (OpenGL 1.3, ARB_texture_compression)
+	ptr_glCompressedTexImage3DARB compressedTexImage3D;
+
+	//: glCompressedTexSubImage1D (OpenGL 1.3, ARB_texture_compression)
+	ptr_glCompressedTexSubImage1DARB compressedTexSubImage1D;
+
+	//: glCompressedTexSubImage2D (OpenGL 1.3, ARB_texture_compression)
+	ptr_glCompressedTexSubImage2DARB compressedTexSubImage2D;
+
+	//: glCompressedTexSubImage3D (OpenGL 1.3, ARB_texture_compression)
+	ptr_glCompressedTexSubImage3DARB compressedTexSubImage3D;
+
+	//: glGetCompressedTexImage (OpenGL 1.3, ARB_texture_compression)
+	ptr_glGetCompressedTexImageARB getCompressedTexImage;
+
+	//: glSampleCoverage (OpenGL 1.3, ARB_multisample)
+	ptr_glSampleCoverageARB sampleCoverage;
+
+	//: glLoadTransposeMatrixd (OpenGL 1.3, ARB_transpose_matrix)
+	ptr_glLoadTransposeMatrixdARB glLoadTransposeMatrixd;
+
+	//: glLoadTransposeMatrixf (OpenGL 1.3, ARB_transpose_matrix)
+	ptr_glLoadTransposeMatrixfARB glLoadTransposeMatrixf;
+
+	//: glMultTransposeMatrixd (OpenGL 1.3, ARB_transpose_matrix)
+	ptr_glMultTransposeMatrixdARB glMultTransposeMatrixd;
+
+	//: glMultTransposeMatrixf (OpenGL 1.3, ARB_transpose_matrix)
+	ptr_glMultTransposeMatrixfARB glMultTransposeMatrixf;
+
+	//: glFogCoordd (OpenGL 1.4, EXT_fog_coord)
+	ptr_glFogCoorddEXT fogCoordd;
+
+	//: glFogCoorddv (OpenGL 1.4, EXT_fog_coord)
+	ptr_glFogCoorddvEXT fogCoorddv;
+
+	//: glFogCoordf (OpenGL 1.4, EXT_fog_coord)
+	ptr_glFogCoordfEXT fogCoordf;
+
+	//: glFogCoordfv (OpenGL 1.4, EXT_fog_coord)
+	ptr_glFogCoordfvEXT fogCoordfv;
+
+	//: glFogCoordPointer (OpenGL 1.4, EXT_fog_coord)
+	ptr_glFogCoordPointerEXT fogCoordPointer;
+
+	//: glMultiDrawArrays (OpenGL 1.4, EXT_multi_draw_arrays)
+	ptr_glMultiDrawArraysEXT multiDrawArrays;
+
+	//: glMultiDrawElements (OpenGL 1.4, EXT_multi_draw_arrays)
+	ptr_glMultiDrawElementsEXT multiDrawElementsEXT;
+
+	//: glPointParameterf (OpenGL 1.4, ARB_point_parameters)
+	ptr_glPointParameterfARB pointParameterf;
+
+	//: glPointParameterfv (OpenGL 1.4, ARB_point_parameters)
+	ptr_glPointParameterfvARB pointParameterfv;
+
+	//: glSecondaryColor3b (OpenGL 1.4, EXT_secondary_color)
+	ptr_glSecondaryColor3bEXT secondaryColor3b;
+
+	//: glSecondaryColor3bv (OpenGL 1.4, EXT_secondary_color)
+	ptr_glSecondaryColor3bvEXT secondaryColor3bv;
+
+	//: glSecondaryColor3d (OpenGL 1.4, EXT_secondary_color)
+	ptr_glSecondaryColor3dEXT secondaryColor3d;
+
+	//: glSecondaryColor3dv (OpenGL 1.4, EXT_secondary_color)
+	ptr_glSecondaryColor3dvEXT secondaryColor3dv;
+
+	//: glSecondaryColor3f (OpenGL 1.4, EXT_secondary_color)
+	ptr_glSecondaryColor3fEXT secondaryColor3f;
+
+	//: glSecondaryColor3fv (OpenGL 1.4, EXT_secondary_color)
+	ptr_glSecondaryColor3fvEXT secondaryColor3fv;
+
+	//: glSecondaryColor3i (OpenGL 1.4, EXT_secondary_color)
+	ptr_glSecondaryColor3iEXT secondaryColor3i;
+
+	//: glSecondaryColor3iv (OpenGL 1.4, EXT_secondary_color)
+	ptr_glSecondaryColor3ivEXT secondaryColor3iv;
+
+	//: glSecondaryColor3s (OpenGL 1.4, EXT_secondary_color)
+	ptr_glSecondaryColor3sEXT secondaryColor3s;
+
+	//: glSecondaryColor3sv (OpenGL 1.4, EXT_secondary_color)
+	ptr_glSecondaryColor3svEXT secondaryColor3sv;
+
+	//: glSecondaryColor3ub (OpenGL 1.4, EXT_secondary_color)
+	ptr_glSecondaryColor3ubEXT secondaryColor3ub;
+
+	//: glSecondaryColor3ubv (OpenGL 1.4, EXT_secondary_color)
+	ptr_glSecondaryColor3ubvEXT secondaryColor3ubv;
+
+	//: glSecondaryColor3ui (OpenGL 1.4, EXT_secondary_color)
+	ptr_glSecondaryColor3uiEXT secondaryColor3ui;
+
+	//: glSecondaryColor3uiv (OpenGL 1.4, EXT_secondary_color)
+	ptr_glSecondaryColor3uivEXT secondaryColor3uiv;
+
+	//: glSecondaryColor3us (OpenGL 1.4, EXT_secondary_color)
+	ptr_glSecondaryColor3usEXT secondaryColor3us;
+
+	//: glSecondaryColor3usv (OpenGL 1.4, EXT_secondary_color)
+	ptr_glSecondaryColor3usvEXT secondaryColor3usv;
+
+	//: glSecondaryColorPointer (OpenGL 1.4, EXT_secondary_color)
+	ptr_glSecondaryColorPointerEXT secondaryColorPointer;
+
+	//: glBlendFuncSeparate (OpenGL 1.4, EXT_blend_func_separate)
+	ptr_glBlendFuncSeparateEXT blendFuncSeparate;
+
+	//: glWindowPos2d (OpenGL 1.4, ARB_window_pos)
+	ptr_glWindowPos2dARB windowPos2d;
+
+	//: glWindowPos2dv (OpenGL 1.4, ARB_window_pos)
+	ptr_glWindowPos2dvARB windowPos2dv;
+
+	//: glWindowPos2f (OpenGL 1.4, ARB_window_pos)
+	ptr_glWindowPos2fARB windowPos2f;
+
+	//: glWindowPos2fv (OpenGL 1.4, ARB_window_pos)
+	ptr_glWindowPos2fvARB windowPos2fv;
+
+	//: glWindowPos2i (OpenGL 1.4, ARB_window_pos)
+	ptr_glWindowPos2iARB windowPos2i;
+
+	//: glWindowPos2iv (OpenGL 1.4, ARB_window_pos)
+	ptr_glWindowPos2ivARB windowPos2iv;
+
+	//: glWindowPos2s (OpenGL 1.4, ARB_window_pos)
+	ptr_glWindowPos2sARB windowPos2s;
+
+	//: glWindowPos2sv (OpenGL 1.4, ARB_window_pos)
+	ptr_glWindowPos2svARB windowPos2sv;
+
+	//: glWindowPos3d (OpenGL 1.4, ARB_window_pos)
+	ptr_glWindowPos3dARB windowPos3d;
+
+	//: glWindowPos3dv (OpenGL 1.4, ARB_window_pos)
+	ptr_glWindowPos3dvARB windowPos3dv;
+
+	//: glWindowPos3f (OpenGL 1.4, ARB_window_pos)
+	ptr_glWindowPos3fARB windowPos3f;
+
+	//: glWindowPos3fv (OpenGL 1.4, ARB_window_pos)
+	ptr_glWindowPos3fvARB windowPos3fv;
+
+	//: glWindowPos3i (OpenGL 1.4, ARB_window_pos)
+	ptr_glWindowPos3iARB windowPos3i;
+
+	//: glWindowPos3iv (OpenGL 1.4, ARB_window_pos)
+	ptr_glWindowPos3ivARB windowPos3iv;
+
+	//: glWindowPos3s (OpenGL 1.4, ARB_window_pos)
+	ptr_glWindowPos3sARB windowPos3s;
+
+	//: glWindowPos3sv (OpenGL 1.4, ARB_window_pos)
+	ptr_glWindowPos3svARB windowPos3sv;
+
+	//: glBindBuffer (OpenGL 1.5, ARB_vertex_buffer_object)
+	ptr_glBindBufferARB bindBuffer;
+
+	//: glDeleteBuffers (OpenGL 1.5, ARB_vertex_buffer_object)
+	ptr_glDeleteBuffersARB deleteBuffers;
+
+	//: glGenBuffers (OpenGL 1.5, ARB_vertex_buffer_object)
+	ptr_glGenBuffersARB genBuffers;
+
+	//: glIsBuffer (OpenGL 1.5, ARB_vertex_buffer_object)
+	ptr_glIsBufferARB isBuffer;
+
+	//: glBufferData (OpenGL 1.5, ARB_vertex_buffer_object)
+	ptr_glBufferDataARB bufferData;
+
+	//: glBufferData (OpenGL 1.5, ARB_vertex_buffer_object)
+	ptr_glBufferSubDataARB bufferSubData;
+
+	//: glBufferSubData (OpenGL 1.5, ARB_vertex_buffer_object)
+	ptr_glGetBufferSubDataARB getBufferSubData;
+
+	//: glMapBuffer (OpenGL 1.5, ARB_vertex_buffer_object)
+	ptr_glMapBufferARB mapBuffer;
+
+	//: glUnmapBuffer (OpenGL 1.5, ARB_vertex_buffer_object)
+	ptr_glUnmapBufferARB unmapBuffer;
+	
+	//: glGetBufferParameteriv (OpenGL 1.5, ARB_vertex_buffer_object)
+	ptr_glGetBufferParameterivARB getBufferParameteriv;
+	
+	//: glGetBufferPointerv (OpenGL 1.5, ARB_vertex_buffer_object)
+	ptr_glGetBufferPointervARB getBufferPointerv;
+	
+	//: glGenQueries (OpenGL 1.5, ARB_occlusion_query)
+	ptr_glGenQueriesARB genQueries;
+
+	//: glDeleteQueries (OpenGL 1.5, ARB_occlusion_query)
+	ptr_glDeleteQueriesARB deleteQueries;
+
+	//: glIsQuery (OpenGL 1.5, ARB_occlusion_query)
+	ptr_glIsQueryARB isQuery;
+
+	//: glBeginQuery (OpenGL 1.5, ARB_occlusion_query)
+	ptr_glBeginQueryARB beginQuery;
+
+	//: glEndQuery (OpenGL 1.5, ARB_occlusion_query)
+	ptr_glEndQueryARB endQuery;
+
+	//: glGetQueryiv (OpenGL 1.5, ARB_occlusion_query)
+	ptr_glGetQueryivARB getQueryiv;
+
+	//: glGetQueryObjectiv (OpenGL 1.5, ARB_occlusion_query)
+	ptr_glGetQueryObjectivARB getQueryObjectiv;
+
+	//: glGenQueryObjectuiv (OpenGL 1.5, ARB_occlusion_query)
+	ptr_glGetQueryObjectuivARB getQueryObjectuiv;
+
+	//: glDeleteShader (OpenGL 2.0, ARB_shader_objects)
+	ptr_glDeleteObjectARB deleteShader;
+
+	//: glDeleteProgram (OpenGL 2.0, ARB_shader_objects)
+	ptr_glDeleteObjectARB deleteProgram;
+
+	//: glGetHandle (OpenGL 2.0, ARB_shader_objects)
+	ptr_glGetHandleARB getHandle;
+
+	//: glDetachObject (OpenGL 2.0, ARB_shader_objects)
+	ptr_glDetachObjectARB detachShader;
+
+	//: glCreateShader (OpenGL 2.0, ARB_shader_objects)
+	ptr_glCreateShaderObjectARB createShader;
+
+	//: glShaderSource (OpenGL 2.0, ARB_shader_objects)
+	ptr_glShaderSourceARB shaderSource;
+
+	//: glCompileShader (OpenGL 2.0, ARB_shader_objects)
+	ptr_glCompileShaderARB compileShader;
+
+	//: glCreateProgramObject (OpenGL 2.0, ARB_shader_objects)
+	ptr_glCreateProgramObjectARB createProgram;
+
+	//: glAttachObject (OpenGL 2.0, ARB_shader_objects)
+	ptr_glAttachObjectARB attachShader;
+
+	//: glLinkProgram (OpenGL 2.0, ARB_shader_objects)
+	ptr_glLinkProgramARB linkProgram;
+
+	//: glUseProgramObject (OpenGL 2.0, ARB_shader_objects)
+	ptr_glUseProgramObjectARB useProgram;
+
+	//: glValidateProgram (OpenGL 2.0, ARB_shader_objects)
+	ptr_glValidateProgramARB validateProgram;
+
+	//: glUniform1f (OpenGL 2.0, ARB_shader_objects)
+	ptr_glUniform1fARB uniform1f;
+
+	//: glUniform2f (OpenGL 2.0, ARB_shader_objects)
+	ptr_glUniform2fARB uniform2f;
+
+	//: glUniform3f (OpenGL 2.0, ARB_shader_objects)
+	ptr_glUniform3fARB uniform3f;
+
+	//: glUniform4f (OpenGL 2.0, ARB_shader_objects)
+	ptr_glUniform4fARB uniform4f;
+
+	//: glUniform1i (OpenGL 2.0, ARB_shader_objects)
+	ptr_glUniform1iARB uniform1i;
+
+	//: glUniform2i (OpenGL 2.0, ARB_shader_objects)
+	ptr_glUniform2iARB uniform2i;
+
+	//: glUniform3i (OpenGL 2.0, ARB_shader_objects)
+	ptr_glUniform3iARB uniform3i;
+
+	//: glUniform4i (OpenGL 2.0, ARB_shader_objects)
+	ptr_glUniform4iARB uniform4i;
+
+	//: glUniform1fv (OpenGL 2.0, ARB_shader_objects)
+	ptr_glUniform1fvARB uniform1fv;
+
+	//: glUniform2fv (OpenGL 2.0, ARB_shader_objects)
+	ptr_glUniform2fvARB uniform2fv;
+
+	//: glUniform3fv (OpenGL 2.0, ARB_shader_objects)
+	ptr_glUniform3fvARB uniform3fv;
+
+	//: glUniform4fv (OpenGL 2.0, ARB_shader_objects)
+	ptr_glUniform4fvARB uniform4fv;
+
+	//: glUniform1iv (OpenGL 2.0, ARB_shader_objects)
+	ptr_glUniform1ivARB uniform1iv;
+
+	//: glUniform2iv (OpenGL 2.0, ARB_shader_objects)
+	ptr_glUniform2ivARB uniform2iv;
+
+	//: glUniform3iv (OpenGL 2.0, ARB_shader_objects)
+	ptr_glUniform3ivARB uniform3iv;
+
+	//: glUniform4iv (OpenGL 2.0, ARB_shader_objects)
+	ptr_glUniform4ivARB uniform4iv;
+
+	//: glUniformMatrix2fv (OpenGL 2.0, ARB_shader_objects)
+	ptr_glUniformMatrix2fvARB uniformMatrix2fv;
+
+	//: glUniformMatrix3fv (OpenGL 2.0, ARB_shader_objects)
+	ptr_glUniformMatrix3fvARB uniformMatrix3fv;
+
+	//: glUniformMatrix4fv (OpenGL 2.0, ARB_shader_objects)
+	ptr_glUniformMatrix4fvARB uniformMatrix4fv;
+
+	//: glGetProgramfv (OpenGL 2.0, ARB_shader_objects)
+	ptr_glGetObjectParameterfvARB getProgramfv;
+
+	//: glGetProgramiv (OpenGL 2.0, ARB_shader_objects)
+	ptr_glGetObjectParameterivARB getProgramiv;
+
+	//: glGetShaderfv (OpenGL 2.0, ARB_shader_objects)
+	ptr_glGetObjectParameterfvARB getShaderfv;
+
+	//: glGetShaderiv (OpenGL 2.0, ARB_shader_objects)
+	ptr_glGetObjectParameterivARB getShaderiv;
+
+	//: glGetShaderInfoLog (OpenGL 2.0, ARB_shader_objects)
+	ptr_glGetInfoLogARB getShaderInfoLog;
+
+	//: glGetProgramInfoLog (OpenGL 2.0, ARB_shader_objects)
+	ptr_glGetInfoLogARB getProgramInfoLog;
+
+	//: glGetAttachedObjects (OpenGL 2.0, ARB_shader_objects)
+	ptr_glGetAttachedObjectsARB getAttachedShaders;
+
+	//: glGetUniformLocation (OpenGL 2.0, ARB_shader_objects)
+	ptr_glGetUniformLocationARB getUniformLocation;
+
+	//: glGetActiveUniform (OpenGL 2.0, ARB_shader_objects)
+	ptr_glGetActiveUniformARB getActiveUniform;
+
+	//: glGetUniformfv (OpenGL 2.0, ARB_shader_objects)
+	ptr_glGetUniformfvARB getUniformfv;
+
+	//: glGetUniformiv (OpenGL 2.0, ARB_shader_objects)
+	ptr_glGetUniformivARB getUniformiv;
+
+	//: glGetShaderSource (OpenGL 2.0, ARB_shader_objects)
+	ptr_glGetShaderSourceARB getShaderSource;
+
+	//: glVertexAttrib1f (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib1fARB vertexAttrib1f;
+
+	//: glVertexAttrib1s (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib1sARB vertexAttrib1s;
+
+	//: glVertexAttrib1d (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib1dARB vertexAttrib1d;
+
+	//: glVertexAttrib2f (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib2fARB vertexAttrib2f;
+
+	//: glVertexAttrib2s (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib2sARB vertexAttrib2s;
+
+	//: glVertexAttrib2d (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib2dARB vertexAttrib2d;
+
+	//: glVertexAttrib3f (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib3fARB vertexAttrib3f;
+
+	//: glVertexAttrib3s (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib3sARB vertexAttrib3s;
+
+	//: glVertexAttrib3d (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib3dARB vertexAttrib3d;
+
+	//: glVertexAttrib4f (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib4fARB vertexAttrib4f;
+
+	//: glVertexAttrib4s (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib4sARB vertexAttrib4s;
+
+	//: glVertexAttrib4d (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib4dARB vertexAttrib4d;
+
+	//: glVertexAttrib4Nub (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib4NubARB vertexAttrib4Nub;
+
+	//: glVertexAttrib1fv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib1fvARB vertexAttrib1fv;
+
+	//: glVertexAttrib1sv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib1svARB vertexAttrib1sv;
+
+	//: glVertexAttrib1dv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib1dvARB vertexAttrib1dv;
+
+	//: glVertexAttrib2fv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib2fvARB vertexAttrib2fv;
+
+	//: glVertexAttrib2sv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib2svARB vertexAttrib2sv;
+
+	//: glVertexAttrib2dv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib2dvARB vertexAttrib2dv;
+
+	//: glVertexAttrib3fv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib3fvARB vertexAttrib3fv;
+
+	//: glVertexAttrib3sv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib3svARB vertexAttrib3sv;
+
+	//: glVertexAttrib3dv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib3dvARB vertexAttrib3dv;
+
+	//: glVertexAttrib4fv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib4fvARB vertexAttrib4fv;
+
+	//: glVertexAttrib4sv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib4svARB vertexAttrib4sv;
+
+	//: glVertexAttrib4dv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib4dvARB vertexAttrib4dv;
+
+	//: glVertexAttrib4iv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib4ivARB vertexAttrib4iv;
+
+	//: glVertexAttrib4bv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib4bvARB vertexAttrib4bv;
+
+	//: glVertexAttrib4ubv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib4ubvARB vertexAttrib4ubv;
+
+	//: glVertexAttrib4usv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib4usvARB vertexAttrib4usv;
+
+	//: glVertexAttrib4uiv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib4uivARB vertexAttrib4uiv;
+
+	//: glVertexAttrib4Nbv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib4NbvARB vertexAttrib4Nbv;
+
+	//: glVertexAttrib4Nsv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib4NsvARB vertexAttrib4Nsv;
+
+	//: glVertexAttrib4Niv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib4NivARB vertexAttrib4Niv;
+
+	//: glVertexAttrib4Nubv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib4NubvARB vertexAttrib4Nubv;
+
+	//: glVertexAttrib4Nusv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib4NusvARB vertexAttrib4Nusv;
+
+	//: glVertexAttrib4Nuiv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttrib4NuivARB vertexAttrib4Nuiv;
+
+	//: glVertexAttribPointer (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glVertexAttribPointerARB vertexAttribPointer;
+
+	//: glEnableVertexAttribArray (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glEnableVertexAttribArrayARB enableVertexAttribArray;
+
+	//: glDisableVertexAttribArray (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glDisableVertexAttribArrayARB disableVertexAttribArray;
+
+	//: glBindAttribLocation (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glBindAttribLocationARB bindAttribLocation;
+
+	//: glGetActiveAttrib (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glGetActiveAttribARB getActiveAttrib;
+
+	//: glGetAttribLocation (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glGetAttribLocationARB getAttribLocation;
+
+	//: glGetVertexAttribdv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glGetVertexAttribdvARB getVertexAttribdv;
+
+	//: glGetVertexAttribfv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glGetVertexAttribfvARB getVertexAttribfv;
+
+	//: glGetVertexAttribiv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glGetVertexAttribivARB getVertexAttribiv;
+
+	//: glGetVertexAttribPointerv (OpenGL 2.0, ARB_vertex_shader)
+	ptr_glGetVertexAttribPointervARB getVertexAttribPointerv;
+
+	//: glDrawBuffers (OpenGL 2.0, ARB_draw_buffers)
+	ptr_glDrawBuffersARB drawBuffers;
+
+	//: glStencilFuncSeparate (OpenGL 2.0, ATI_separate_stencil)
+	ptr_glStencilFuncSeparateATI stencilFuncSeparate;
+
+	//: glStencilOpSeparate (OpenGL 2.0, ATI_separate_stencil)
+	ptr_glStencilOpSeparateATI stencilOpSeparate;
+
+	//: glActiveStencilFace (EXT_stencil_two_side)
+	ptr_glActiveStencilFaceEXT activeStencilFaceEXT;
+};
+
+#define clAccum CL_OpenGL::functions-&gt;accum
+#define clAlphaFunc CL_OpenGL::functions-&gt;alphaFunc
+#define clAreTexturesResident CL_OpenGL::functions-&gt;areTexturesResident
+#define clArrayElement CL_OpenGL::functions-&gt;arrayElement
+#define clBegin CL_OpenGL::functions-&gt;begin
+#define clBindTexture CL_OpenGL::functions-&gt;bindTexture
+#define clBitmap CL_OpenGL::functions-&gt;bitmap
+#define clBlendFunc CL_OpenGL::functions-&gt;blendFunc
+#define clCallList CL_OpenGL::functions-&gt;callList
+#define clCallLists CL_OpenGL::functions-&gt;callLists
+#define clClear CL_OpenGL::functions-&gt;clear
+#define clClearAccum CL_OpenGL::functions-&gt;clearAccum
+#define clClearColor CL_OpenGL::functions-&gt;clearColor
+#define clClearDepth CL_OpenGL::functions-&gt;clearDepth
+#define clClearIndex CL_OpenGL::functions-&gt;clearIndex
+#define clClearStencil CL_OpenGL::functions-&gt;clearStencil
+#define clClipPlane CL_OpenGL::functions-&gt;clipPlane
+#define clColor3b CL_OpenGL::functions-&gt;color3b
+#define clColor3bv CL_OpenGL::functions-&gt;color3bv
+#define clColor3d CL_OpenGL::functions-&gt;color3d
+#define clColor3dv CL_OpenGL::functions-&gt;color3dv
+#define clColor3f CL_OpenGL::functions-&gt;color3f
+#define clColor3fv CL_OpenGL::functions-&gt;color3fv
+#define clColor3i CL_OpenGL::functions-&gt;color3i
+#define clColor3iv CL_OpenGL::functions-&gt;color3iv
+#define clColor3s CL_OpenGL::functions-&gt;color3s
+#define clColor3sv CL_OpenGL::functions-&gt;color3sv
+#define clColor3ub CL_OpenGL::functions-&gt;color3ub
+#define clColor3ubv CL_OpenGL::functions-&gt;color3ubv
+#define clColor3ui CL_OpenGL::functions-&gt;color3ui
+#define clColor3uiv CL_OpenGL::functions-&gt;color3uiv
+#define clColor3us CL_OpenGL::functions-&gt;color3us
+#define clColor3usv CL_OpenGL::functions-&gt;color3usv
+#define clColor4b CL_OpenGL::functions-&gt;color4b
+#define clColor4bv CL_OpenGL::functions-&gt;color4bv
+#define clColor4d CL_OpenGL::functions-&gt;color4d
+#define clColor4dv CL_OpenGL::functions-&gt;color4dv
+#define clColor4f CL_OpenGL::functions-&gt;color4f
+#define clColor4fv CL_OpenGL::functions-&gt;color4fv
+#define clColor4i CL_OpenGL::functions-&gt;color4i
+#define clColor4iv CL_OpenGL::functions-&gt;color4iv
+#define clColor4s CL_OpenGL::functions-&gt;color4s
+#define clColor4sv CL_OpenGL::functions-&gt;color4sv
+#define clColor4ub CL_OpenGL::functions-&gt;color4ub
+#define clColor4ubv CL_OpenGL::functions-&gt;color4ubv
+#define clColor4ui CL_OpenGL::functions-&gt;color4ui
+#define clColor4uiv CL_OpenGL::functions-&gt;color4uiv
+#define clColor4us CL_OpenGL::functions-&gt;color4us
+#define clColor4usv CL_OpenGL::functions-&gt;color4usv
+#define clColorMask CL_OpenGL::functions-&gt;colorMask
+#define clColorMaterial CL_OpenGL::functions-&gt;colorMaterial
+#define clColorPointer CL_OpenGL::functions-&gt;colorPointer
+#define clCopyPixels CL_OpenGL::functions-&gt;copyPixels
+#define clCopyTexImage1D CL_OpenGL::functions-&gt;copyTexImage1D
+#define clCopyTexImage2D CL_OpenGL::functions-&gt;copyTexImage2D
+#define clCopyTexSubImage1D CL_OpenGL::functions-&gt;copyTexSubImage1D
+#define clCopyTexSubImage2D CL_OpenGL::functions-&gt;copyTexSubImage2D
+#define clCopyTexSubImage3D CL_OpenGL::functions-&gt;copyTexSubImage3D
+#define clCullFace CL_OpenGL::functions-&gt;cullFace
+#define clDeleteLists CL_OpenGL::functions-&gt;deleteLists
+#define clDeleteTextures CL_OpenGL::functions-&gt;deleteTextures
+#define clDepthFunc CL_OpenGL::functions-&gt;depthFunc
+#define clDepthMask CL_OpenGL::functions-&gt;depthMask
+#define clDepthRange CL_OpenGL::functions-&gt;depthRange
+#define clDisable CL_OpenGL::functions-&gt;disable
+#define clDisableClientState CL_OpenGL::functions-&gt;disableClientState
+#define clDrawArrays CL_OpenGL::functions-&gt;drawArrays
+#define clDrawBuffer CL_OpenGL::functions-&gt;drawBuffer
+#define clDrawElements CL_OpenGL::functions-&gt;drawElements
+#define clDrawPixels CL_OpenGL::functions-&gt;drawPixels
+#define clEdgeFlag CL_OpenGL::functions-&gt;edgeFlag
+#define clEdgeFlagPointer CL_OpenGL::functions-&gt;edgeFlagPointer
+#define clEdgeFlagv CL_OpenGL::functions-&gt;edgeFlagv
+#define clEnable CL_OpenGL::functions-&gt;enable
+#define clEnableClientState CL_OpenGL::functions-&gt;enableClientState
+#define clEnd CL_OpenGL::functions-&gt;end
+#define clEndList CL_OpenGL::functions-&gt;endList
+#define clEvalCoord1d CL_OpenGL::functions-&gt;evalCoord1d
+#define clEvalCoord1dv CL_OpenGL::functions-&gt;evalCoord1dv
+#define clEvalCoord1f CL_OpenGL::functions-&gt;evalCoord1f
+#define clEvalCoord1fv CL_OpenGL::functions-&gt;evalCoord1fv
+#define clEvalCoord2d CL_OpenGL::functions-&gt;evalCoord2d
+#define clEvalCoord2dv CL_OpenGL::functions-&gt;evalCoord2dv
+#define clEvalCoord2f CL_OpenGL::functions-&gt;evalCoord2f
+#define clEvalCoord2fv CL_OpenGL::functions-&gt;evalCoord2fv
+#define clEvalMesh1 CL_OpenGL::functions-&gt;evalMesh1
+#define clEvalMesh2 CL_OpenGL::functions-&gt;evalMesh2
+#define clEvalPoint1 CL_OpenGL::functions-&gt;evalPoint1
+#define clEvalPoint2 CL_OpenGL::functions-&gt;evalPoint2
+#define clFeedbackBuffer CL_OpenGL::functions-&gt;feedbackBuffer
+#define clFinish CL_OpenGL::functions-&gt;finish
+#define clFlush CL_OpenGL::functions-&gt;flush
+#define clFogf CL_OpenGL::functions-&gt;fogf
+#define clFogfv CL_OpenGL::functions-&gt;fogfv
+#define clFogi CL_OpenGL::functions-&gt;fogi
+#define clFogiv CL_OpenGL::functions-&gt;fogiv
+#define clFrontFace CL_OpenGL::functions-&gt;frontFace
+#define clFrustum CL_OpenGL::functions-&gt;frustum
+#define clGenLists CL_OpenGL::functions-&gt;genLists
+#define clGenTextures CL_OpenGL::functions-&gt;genTextures
+#define clGetBooleanv CL_OpenGL::functions-&gt;getBooleanv
+#define clGetClipPlane CL_OpenGL::functions-&gt;getClipPlane
+#define clGetDoublev CL_OpenGL::functions-&gt;getDoublev
+#define clGetError CL_OpenGL::functions-&gt;getError
+#define clGetFloatv CL_OpenGL::functions-&gt;getFloatv
+#define clGetIntegerv CL_OpenGL::functions-&gt;getIntegerv
+#define clGetLightfv CL_OpenGL::functions-&gt;getLightfv
+#define clGetLightiv CL_OpenGL::functions-&gt;getLightiv
+#define clGetMapdv CL_OpenGL::functions-&gt;getMapdv
+#define clGetMapfv CL_OpenGL::functions-&gt;getMapfv
+#define clGetMapiv CL_OpenGL::functions-&gt;getMapiv
+#define clGetMaterialfv CL_OpenGL::functions-&gt;getMaterialfv
+#define clGetMaterialiv CL_OpenGL::functions-&gt;getMaterialiv
+#define clGetPixelMapfv CL_OpenGL::functions-&gt;getPixelMapfv
+#define clGetPixelMapuiv CL_OpenGL::functions-&gt;getPixelMapuiv
+#define clGetPixelMapusv CL_OpenGL::functions-&gt;getPixelMapusv
+#define clGetPointerv CL_OpenGL::functions-&gt;getPointerv
+#define clGetPolygonStipple CL_OpenGL::functions-&gt;getPolygonStipple
+#define clGetString CL_OpenGL::functions-&gt;getString
+#define clGetTexEnvfv CL_OpenGL::functions-&gt;getTexEnvfv
+#define clGetTexEnviv CL_OpenGL::functions-&gt;getTexEnviv
+#define clGetTexGendv CL_OpenGL::functions-&gt;getTexGendv
+#define clGetTexGenfv CL_OpenGL::functions-&gt;getTexGenfv
+#define clGetTexGeniv CL_OpenGL::functions-&gt;getTexGeniv
+#define clGetTexImage CL_OpenGL::functions-&gt;getTexImage
+#define clGetTexLevelParameterfv CL_OpenGL::functions-&gt;getTexLevelParameterfv
+#define clGetTexLevelParameteriv CL_OpenGL::functions-&gt;getTexLevelParameteriv
+#define clGetTexParameterfv CL_OpenGL::functions-&gt;getTexParameterfv
+#define clGetTexParameteriv CL_OpenGL::functions-&gt;getTexParameteriv
+#define clHint CL_OpenGL::functions-&gt;hint
+#define clIndexMask CL_OpenGL::functions-&gt;indexMask
+#define clIndexPointer CL_OpenGL::functions-&gt;indexPointer
+#define clIndexd CL_OpenGL::functions-&gt;indexd
+#define clIndexdv CL_OpenGL::functions-&gt;indexdv
+#define clIndexf CL_OpenGL::functions-&gt;indexf
+#define clIndexfv CL_OpenGL::functions-&gt;indexfv
+#define clIndexi CL_OpenGL::functions-&gt;indexi
+#define clIndexiv CL_OpenGL::functions-&gt;indexiv
+#define clIndexs CL_OpenGL::functions-&gt;indexs
+#define clIndexsv CL_OpenGL::functions-&gt;indexsv
+#define clIndexub CL_OpenGL::functions-&gt;indexub
+#define clIndexubv CL_OpenGL::functions-&gt;indexubv
+#define clInitNames CL_OpenGL::functions-&gt;initNames
+#define clInterleavedArrays CL_OpenGL::functions-&gt;interleavedArrays
+#define clIsEnabled CL_OpenGL::functions-&gt;isEnabled
+#define clIsList CL_OpenGL::functions-&gt;isList
+#define clIsTexture CL_OpenGL::functions-&gt;isTexture
+#define clLightModelf CL_OpenGL::functions-&gt;lightModelf
+#define clLightModelfv CL_OpenGL::functions-&gt;lightModelfv
+#define clLightModeli CL_OpenGL::functions-&gt;lightModeli
+#define clLightModeliv CL_OpenGL::functions-&gt;lightModeliv
+#define clLightf CL_OpenGL::functions-&gt;lightf
+#define clLightfv CL_OpenGL::functions-&gt;lightfv
+#define clLighti CL_OpenGL::functions-&gt;lighti
+#define clLightiv CL_OpenGL::functions-&gt;lightiv
+#define clLineStipple CL_OpenGL::functions-&gt;lineStipple
+#define clLineWidth CL_OpenGL::functions-&gt;lineWidth
+#define clListBase CL_OpenGL::functions-&gt;listBase
+#define clLoadIdentity CL_OpenGL::functions-&gt;loadIdentity
+#define clLoadMatrixd CL_OpenGL::functions-&gt;loadMatrixd
+#define clLoadMatrixf CL_OpenGL::functions-&gt;loadMatrixf
+#define clLoadName CL_OpenGL::functions-&gt;loadName
+#define clLogicOp CL_OpenGL::functions-&gt;logicOp
+#define clMap1d CL_OpenGL::functions-&gt;map1d
+#define clMap1f CL_OpenGL::functions-&gt;map1f
+#define clMap2d CL_OpenGL::functions-&gt;map2d
+#define clMap2f CL_OpenGL::functions-&gt;map2f
+#define clMapGrid1d CL_OpenGL::functions-&gt;mapGrid1d
+#define clMapGrid1f CL_OpenGL::functions-&gt;mapGrid1f
+#define clMapGrid2d CL_OpenGL::functions-&gt;mapGrid2d
+#define clMapGrid2f CL_OpenGL::functions-&gt;mapGrid2f
+#define clMaterialf CL_OpenGL::functions-&gt;materialf
+#define clMaterialfv CL_OpenGL::functions-&gt;materialfv
+#define clMateriali CL_OpenGL::functions-&gt;materiali
+#define clMaterialiv CL_OpenGL::functions-&gt;materialiv
+#define clMatrixMode CL_OpenGL::functions-&gt;matrixMode
+#define clMultMatrixd CL_OpenGL::functions-&gt;multMatrixd
+#define clMultMatrixf CL_OpenGL::functions-&gt;multMatrixf
+#define clNewList CL_OpenGL::functions-&gt;newList
+#define clNormal3b CL_OpenGL::functions-&gt;normal3b
+#define clNormal3bv CL_OpenGL::functions-&gt;normal3bv
+#define clNormal3d CL_OpenGL::functions-&gt;normal3d
+#define clNormal3dv CL_OpenGL::functions-&gt;normal3dv
+#define clNormal3f CL_OpenGL::functions-&gt;normal3f
+#define clNormal3fv CL_OpenGL::functions-&gt;normal3fv
+#define clNormal3i CL_OpenGL::functions-&gt;normal3i
+#define clNormal3iv CL_OpenGL::functions-&gt;normal3iv
+#define clNormal3s CL_OpenGL::functions-&gt;normal3s
+#define clNormal3sv CL_OpenGL::functions-&gt;normal3sv
+#define clNormalPointer CL_OpenGL::functions-&gt;normalPointer
+#define clOrtho CL_OpenGL::functions-&gt;ortho
+#define clPassThrough CL_OpenGL::functions-&gt;passThrough
+#define clPixelMapfv CL_OpenGL::functions-&gt;pixelMapfv
+#define clPixelMapuiv CL_OpenGL::functions-&gt;pixelMapuiv
+#define clPixelMapusv CL_OpenGL::functions-&gt;pixelMapusv
+#define clPixelStoref CL_OpenGL::functions-&gt;pixelStoref
+#define clPixelStorei CL_OpenGL::functions-&gt;pixelStorei
+#define clPixelTransferf CL_OpenGL::functions-&gt;pixelTransferf
+#define clPixelTransferi CL_OpenGL::functions-&gt;pixelTransferi
+#define clPixelZoom CL_OpenGL::functions-&gt;pixelZoom
+#define clPointSize CL_OpenGL::functions-&gt;pointSize
+#define clPolygonMode CL_OpenGL::functions-&gt;polygonMode
+#define clPolygonOffset CL_OpenGL::functions-&gt;polygonOffset
+#define clPolygonStipple CL_OpenGL::functions-&gt;polygonStipple
+#define clPopAttrib CL_OpenGL::functions-&gt;popAttrib
+#define clPopClientAttrib CL_OpenGL::functions-&gt;popClientAttrib
+#define clPopMatrix CL_OpenGL::functions-&gt;popMatrix
+#define clPopName CL_OpenGL::functions-&gt;popName
+#define clPrioritizeTextures CL_OpenGL::functions-&gt;prioritizeTextures
+#define clPushAttrib CL_OpenGL::functions-&gt;pushAttrib
+#define clPushClientAttrib CL_OpenGL::functions-&gt;pushClientAttrib
+#define clPushMatrix CL_OpenGL::functions-&gt;pushMatrix
+#define clPushName CL_OpenGL::functions-&gt;pushName
+#define clRasterPos2d CL_OpenGL::functions-&gt;rasterPos2d
+#define clRasterPos2dv CL_OpenGL::functions-&gt;rasterPos2dv
+#define clRasterPos2f CL_OpenGL::functions-&gt;rasterPos2f
+#define clRasterPos2fv CL_OpenGL::functions-&gt;rasterPos2fv
+#define clRasterPos2i CL_OpenGL::functions-&gt;rasterPos2i
+#define clRasterPos2iv CL_OpenGL::functions-&gt;rasterPos2iv
+#define clRasterPos2s CL_OpenGL::functions-&gt;rasterPos2s
+#define clRasterPos2sv CL_OpenGL::functions-&gt;rasterPos2sv
+#define clRasterPos3d CL_OpenGL::functions-&gt;rasterPos3d
+#define clRasterPos3dv CL_OpenGL::functions-&gt;rasterPos3dv
+#define clRasterPos3f CL_OpenGL::functions-&gt;rasterPos3f
+#define clRasterPos3fv CL_OpenGL::functions-&gt;rasterPos3fv
+#define clRasterPos3i CL_OpenGL::functions-&gt;rasterPos3i
+#define clRasterPos3iv CL_OpenGL::functions-&gt;rasterPos3iv
+#define clRasterPos3s CL_OpenGL::functions-&gt;rasterPos3s
+#define clRasterPos3sv CL_OpenGL::functions-&gt;rasterPos3sv
+#define clRasterPos4d CL_OpenGL::functions-&gt;rasterPos4d
+#define clRasterPos4dv CL_OpenGL::functions-&gt;rasterPos4dv
+#define clRasterPos4f CL_OpenGL::functions-&gt;rasterPos4f
+#define clRasterPos4fv CL_OpenGL::functions-&gt;rasterPos4fv
+#define clRasterPos4i CL_OpenGL::functions-&gt;rasterPos4i
+#define clRasterPos4iv CL_OpenGL::functions-&gt;rasterPos4iv
+#define clRasterPos4s CL_OpenGL::functions-&gt;rasterPos4s
+#define clRasterPos4sv CL_OpenGL::functions-&gt;rasterPos4sv
+#define clReadBuffer CL_OpenGL::functions-&gt;readBuffer
+#define clReadPixels CL_OpenGL::functions-&gt;readPixels
+#define clRectd CL_OpenGL::functions-&gt;rectd
+#define clRectdv CL_OpenGL::functions-&gt;rectdv
+#define clRectf CL_OpenGL::functions-&gt;rectf
+#define clRectfv CL_OpenGL::functions-&gt;rectfv
+#define clRecti CL_OpenGL::functions-&gt;recti
+#define clRectiv CL_OpenGL::functions-&gt;rectiv
+#define clRects CL_OpenGL::functions-&gt;rects
+#define clRectsv CL_OpenGL::functions-&gt;rectsv
+#define clRenderMode CL_OpenGL::functions-&gt;renderMode
+#define clRotated CL_OpenGL::functions-&gt;rotated
+#define clRotatef CL_OpenGL::functions-&gt;rotatef
+#define clScaled CL_OpenGL::functions-&gt;scaled
+#define clScalef CL_OpenGL::functions-&gt;scalef
+#define clScissor CL_OpenGL::functions-&gt;scissor
+#define clSelectBuffer CL_OpenGL::functions-&gt;selectBuffer
+#define clShadeModel CL_OpenGL::functions-&gt;shadeModel
+#define clStencilFunc CL_OpenGL::functions-&gt;stencilFunc
+#define clStencilMask CL_OpenGL::functions-&gt;stencilMask
+#define clStencilOp CL_OpenGL::functions-&gt;stencilOp
+#define clTexCoord1d CL_OpenGL::functions-&gt;texCoord1d
+#define clTexCoord1dv CL_OpenGL::functions-&gt;texCoord1dv
+#define clTexCoord1f CL_OpenGL::functions-&gt;texCoord1f
+#define clTexCoord1fv CL_OpenGL::functions-&gt;texCoord1fv
+#define clTexCoord1i CL_OpenGL::functions-&gt;texCoord1i
+#define clTexCoord1iv CL_OpenGL::functions-&gt;texCoord1iv
+#define clTexCoord1s CL_OpenGL::functions-&gt;texCoord1s
+#define clTexCoord1sv CL_OpenGL::functions-&gt;texCoord1sv
+#define clTexCoord2d CL_OpenGL::functions-&gt;texCoord2d
+#define clTexCoord2dv CL_OpenGL::functions-&gt;texCoord2dv
+#define clTexCoord2f CL_OpenGL::functions-&gt;texCoord2f
+#define clTexCoord2fv CL_OpenGL::functions-&gt;texCoord2fv
+#define clTexCoord2i CL_OpenGL::functions-&gt;texCoord2i
+#define clTexCoord2iv CL_OpenGL::functions-&gt;texCoord2iv
+#define clTexCoord2s CL_OpenGL::functions-&gt;texCoord2s
+#define clTexCoord2sv CL_OpenGL::functions-&gt;texCoord2sv
+#define clTexCoord3d CL_OpenGL::functions-&gt;texCoord3d
+#define clTexCoord3dv CL_OpenGL::functions-&gt;texCoord3dv
+#define clTexCoord3f CL_OpenGL::functions-&gt;texCoord3f
+#define clTexCoord3fv CL_OpenGL::functions-&gt;texCoord3fv
+#define clTexCoord3i CL_OpenGL::functions-&gt;texCoord3i
+#define clTexCoord3iv CL_OpenGL::functions-&gt;texCoord3iv
+#define clTexCoord3s CL_OpenGL::functions-&gt;texCoord3s
+#define clTexCoord3sv CL_OpenGL::functions-&gt;texCoord3sv
+#define clTexCoord4d CL_OpenGL::functions-&gt;texCoord4d
+#define clTexCoord4dv CL_OpenGL::functions-&gt;texCoord4dv
+#define clTexCoord4f CL_OpenGL::functions-&gt;texCoord4f
+#define clTexCoord4fv CL_OpenGL::functions-&gt;texCoord4fv
+#define clTexCoord4i CL_OpenGL::functions-&gt;texCoord4i
+#define clTexCoord4iv CL_OpenGL::functions-&gt;texCoord4iv
+#define clTexCoord4s CL_OpenGL::functions-&gt;texCoord4s
+#define clTexCoord4sv CL_OpenGL::functions-&gt;texCoord4sv
+#define clTexCoordPointer CL_OpenGL::functions-&gt;texCoordPointer
+#define clTexEnvf CL_OpenGL::functions-&gt;texEnvf
+#define clTexEnvfv CL_OpenGL::functions-&gt;texEnvfv
+#define clTexEnvi CL_OpenGL::functions-&gt;texEnvi
+#define clTexEnviv CL_OpenGL::functions-&gt;texEnviv
+#define clTexGend CL_OpenGL::functions-&gt;texGend
+#define clTexGendv CL_OpenGL::functions-&gt;texGendv
+#define clTexGenf CL_OpenGL::functions-&gt;texGenf
+#define clTexGenfv CL_OpenGL::functions-&gt;texGenfv
+#define clTexGeni CL_OpenGL::functions-&gt;texGeni
+#define clTexGeniv CL_OpenGL::functions-&gt;texGeniv
+#define clTexImage1D CL_OpenGL::functions-&gt;texImage1D
+#define clTexImage2D CL_OpenGL::functions-&gt;texImage2D
+#define clTexParameterf CL_OpenGL::functions-&gt;texParameterf
+#define clTexParameterfv CL_OpenGL::functions-&gt;texParameterfv
+#define clTexParameteri CL_OpenGL::functions-&gt;texParameteri
+#define clTexParameteriv CL_OpenGL::functions-&gt;texParameteriv
+#define clTexSubImage1D CL_OpenGL::functions-&gt;texSubImage1D
+#define clTexSubImage2D CL_OpenGL::functions-&gt;texSubImage2D
+#define clTexSubImage3D CL_OpenGL::functions-&gt;texSubImage3D
+#define clTranslated CL_OpenGL::functions-&gt;translated
+#define clTranslatef CL_OpenGL::functions-&gt;translatef
+#define clVertex2d CL_OpenGL::functions-&gt;vertex2d
+#define clVertex2dv CL_OpenGL::functions-&gt;vertex2dv
+#define clVertex2f CL_OpenGL::functions-&gt;vertex2f
+#define clVertex2fv CL_OpenGL::functions-&gt;vertex2fv
+#define clVertex2i CL_OpenGL::functions-&gt;vertex2i
+#define clVertex2iv CL_OpenGL::functions-&gt;vertex2iv
+#define clVertex2s CL_OpenGL::functions-&gt;vertex2s
+#define clVertex2sv CL_OpenGL::functions-&gt;vertex2sv
+#define clVertex3d CL_OpenGL::functions-&gt;vertex3d
+#define clVertex3dv CL_OpenGL::functions-&gt;vertex3dv
+#define clVertex3f CL_OpenGL::functions-&gt;vertex3f
+#define clVertex3fv CL_OpenGL::functions-&gt;vertex3fv
+#define clVertex3i CL_OpenGL::functions-&gt;vertex3i
+#define clVertex3iv CL_OpenGL::functions-&gt;vertex3iv
+#define clVertex3s CL_OpenGL::functions-&gt;vertex3s
+#define clVertex3sv CL_OpenGL::functions-&gt;vertex3sv
+#define clVertex4d CL_OpenGL::functions-&gt;vertex4d
+#define clVertex4dv CL_OpenGL::functions-&gt;vertex4dv
+#define clVertex4f CL_OpenGL::functions-&gt;vertex4f
+#define clVertex4fv CL_OpenGL::functions-&gt;vertex4fv
+#define clVertex4i CL_OpenGL::functions-&gt;vertex4i
+#define clVertex4iv CL_OpenGL::functions-&gt;vertex4iv
+#define clVertex4s CL_OpenGL::functions-&gt;vertex4s
+#define clVertex4sv CL_OpenGL::functions-&gt;vertex4sv
+#define clVertexPointer CL_OpenGL::functions-&gt;vertexPointer
+#define clViewport CL_OpenGL::functions-&gt;viewport
+#define clDrawRangeElements CL_OpenGL::functions-&gt;drawRangeElements
+#define clTexImage3D CL_OpenGL::functions-&gt;texImage3D
+#define clColorTable CL_OpenGL::functions-&gt;colorTable
+#define clCopyColorTable CL_OpenGL::functions-&gt;copyColorTable
+#define clColorTableParameteriv CL_OpenGL::functions-&gt;colorTableParameteriv
+#define clColorTableParameterfv CL_OpenGL::functions-&gt;colorTableParameterfv
+#define clGetColorTable CL_OpenGL::functions-&gt;getColorTable
+#define clGetColorTableParameteriv CL_OpenGL::functions-&gt;getColorTableParameteriv
+#define clGetColorTableParameterfv CL_OpenGL::functions-&gt;getColorTableParameterfv
+#define clColorSubTable CL_OpenGL::functions-&gt;colorSubTable
+#define clCopyColorSubTable CL_OpenGL::functions-&gt;copyColorSubTable
+#define clConvolutionFilter1D CL_OpenGL::functions-&gt;convolutionFilter1D
+#define clConvolutionFilter2D CL_OpenGL::functions-&gt;convolutionFilter2D
+#define clCopyConvolutionFilter1D CL_OpenGL::functions-&gt;copyConvolutionFilter1D
+#define clCopyConvolutionFilter2D CL_OpenGL::functions-&gt;copyConvolutionFilter2D
+#define clGetConvolutionFilter CL_OpenGL::functions-&gt;getConvolutionFilter
+#define clSeparableFilter2D CL_OpenGL::functions-&gt;separableFilter2D
+#define clGetSeparableFilter CL_OpenGL::functions-&gt;getSeparableFilter
+#define clConvolutionParameteri CL_OpenGL::functions-&gt;convolutionParameteri
+#define clConvolutionParameteriv CL_OpenGL::functions-&gt;convolutionParameteriv
+#define clConvolutionParameterf CL_OpenGL::functions-&gt;convolutionParameterf
+#define clConvolutionParameterfv CL_OpenGL::functions-&gt;convolutionParameterfv
+#define clGetConvolutionParameteriv CL_OpenGL::functions-&gt;getConvolutionParameteriv
+#define clGetConvolutionParameterfv CL_OpenGL::functions-&gt;getConvolutionParameterfv
+#define clHistogram CL_OpenGL::functions-&gt;histogram
+#define clResetHistogram CL_OpenGL::functions-&gt;resetHistogram
+#define clGetHistogram CL_OpenGL::functions-&gt;getHistogram
+#define clGetHistogramParameteriv CL_OpenGL::functions-&gt;getHistogramParameteriv
+#define clGetHistogramParameterfv CL_OpenGL::functions-&gt;getHistogramParameterfv
+#define clMinmax CL_OpenGL::functions-&gt;minmax
+#define clResetMinmax CL_OpenGL::functions-&gt;resetMinmax
+#define clGetMinmax CL_OpenGL::functions-&gt;getMinmax
+#define clGetMinmaxParameteriv CL_OpenGL::functions-&gt;getMinmaxParameteriv
+#define clGetMinmaxParameterfv CL_OpenGL::functions-&gt;getMinmaxParameterfv
+#define clBlendColor CL_OpenGL::functions-&gt;blendColor
+#define clBlendEquation CL_OpenGL::functions-&gt;blendEquation
+#define clActiveTexture CL_OpenGL::functions-&gt;activeTexture
+#define clClientActiveTexture CL_OpenGL::functions-&gt;clientActiveTexture
+#define clMultiTexCoord1d CL_OpenGL::functions-&gt;multiTexCoord1d
+#define clMultiTexCoord1dv CL_OpenGL::functions-&gt;multiTexCoord1dv
+#define clMultiTexCoord1f CL_OpenGL::functions-&gt;multiTexCoord1f
+#define clMultiTexCoord1fv CL_OpenGL::functions-&gt;multiTexCoord1fv
+#define clMultiTexCoord1i CL_OpenGL::functions-&gt;multiTexCoord1i
+#define clMultiTexCoord1iv CL_OpenGL::functions-&gt;multiTexCoord1iv
+#define clMultiTexCoord1s CL_OpenGL::functions-&gt;multiTexCoord1s
+#define clMultiTexCoord1sv CL_OpenGL::functions-&gt;multiTexCoord1sv
+#define clMultiTexCoord2d CL_OpenGL::functions-&gt;multiTexCoord2d
+#define clMultiTexCoord2dv CL_OpenGL::functions-&gt;multiTexCoord2dv
+#define clMultiTexCoord2f CL_OpenGL::functions-&gt;multiTexCoord2f
+#define clMultiTexCoord2fv CL_OpenGL::functions-&gt;multiTexCoord2fv
+#define clMultiTexCoord2i CL_OpenGL::functions-&gt;multiTexCoord2i
+#define clMultiTexCoord2iv CL_OpenGL::functions-&gt;multiTexCoord2iv
+#define clMultiTexCoord2s CL_OpenGL::functions-&gt;multiTexCoord2s
+#define clMultiTexCoord2sv CL_OpenGL::functions-&gt;multiTexCoord2sv
+#define clMultiTexCoord3d CL_OpenGL::functions-&gt;multiTexCoord3d
+#define clMultiTexCoord3dv CL_OpenGL::functions-&gt;multiTexCoord3dv
+#define clMultiTexCoord3f CL_OpenGL::functions-&gt;multiTexCoord3f
+#define clMultiTexCoord3fv CL_OpenGL::functions-&gt;multiTexCoord3fv
+#define clMultiTexCoord3i CL_OpenGL::functions-&gt;multiTexCoord3i
+#define clMultiTexCoord3iv CL_OpenGL::functions-&gt;multiTexCoord3iv
+#define clMultiTexCoord3s CL_OpenGL::functions-&gt;multiTexCoord3s
+#define clMultiTexCoord3sv CL_OpenGL::functions-&gt;multiTexCoord3sv
+#define clMultiTexCoord4d CL_OpenGL::functions-&gt;multiTexCoord4d
+#define clMultiTexCoord4dv CL_OpenGL::functions-&gt;multiTexCoord4dv
+#define clMultiTexCoord4f CL_OpenGL::functions-&gt;multiTexCoord4f
+#define clMultiTexCoord4fv CL_OpenGL::functions-&gt;multiTexCoord4fv
+#define clMultiTexCoord4i CL_OpenGL::functions-&gt;multiTexCoord4i
+#define clMultiTexCoord4iv CL_OpenGL::functions-&gt;multiTexCoord4iv
+#define clMultiTexCoord4s CL_OpenGL::functions-&gt;multiTexCoord4s
+#define clMultiTexCoord4sv CL_OpenGL::functions-&gt;multiTexCoord4sv
+#define clCompressedTexImage1D CL_OpenGL::functions-&gt;compressedTexImage1D
+#define clCompressedTexImage2D CL_OpenGL::functions-&gt;compressedTexImage2D
+#define clCompressedTexImage3D CL_OpenGL::functions-&gt;compressedTexImage3D
+#define clCompressedTexSubImage1D CL_OpenGL::functions-&gt;compressedTexSubImage1D
+#define clCompressedTexSubImage2D CL_OpenGL::functions-&gt;compressedTexSubImage2D
+#define clCompressedTexSubImage3D CL_OpenGL::functions-&gt;compressedTexSubImage3D
+#define clGetCompressedTexImage CL_OpenGL::functions-&gt;getCompressedTexImage
+#define clSampleCoverage CL_OpenGL::functions-&gt;sampleCoverage
+#define clLoadTransposeMatrixd CL_OpenGL::functions-&gt;glLoadTransposeMatrixd
+#define clLoadTransposeMatrixf CL_OpenGL::functions-&gt;glLoadTransposeMatrixf
+#define clMultTransposeMatrixd CL_OpenGL::functions-&gt;glMultTransposeMatrixd
+#define clMultTransposeMatrixf CL_OpenGL::functions-&gt;glMultTransposeMatrixf
+#define clFogCoordd CL_OpenGL::functions-&gt;fogCoordd
+#define clFogCoorddv CL_OpenGL::functions-&gt;fogCoorddv
+#define clFogCoordf CL_OpenGL::functions-&gt;fogCoordf
+#define clFogCoordfv CL_OpenGL::functions-&gt;fogCoordfv
+#define clFogCoordPointer CL_OpenGL::functions-&gt;fogCoordPointer
+#define clMultiDrawArrays CL_OpenGL::functions-&gt;multiDrawArrays
+#define clMultiDrawElements CL_OpenGL::functions-&gt;multiDrawElementsEXT
+#define clPointParameterf CL_OpenGL::functions-&gt;pointParameterf
+#define clPointParameterfv CL_OpenGL::functions-&gt;pointParameterfv
+#define clSecondaryColor3b CL_OpenGL::functions-&gt;secondaryColor3b
+#define clSecondaryColor3bv CL_OpenGL::functions-&gt;secondaryColor3bv
+#define clSecondaryColor3d CL_OpenGL::functions-&gt;secondaryColor3d
+#define clSecondaryColor3dv CL_OpenGL::functions-&gt;secondaryColor3dv
+#define clSecondaryColor3f CL_OpenGL::functions-&gt;secondaryColor3f
+#define clSecondaryColor3fv CL_OpenGL::functions-&gt;secondaryColor3fv
+#define clSecondaryColor3i CL_OpenGL::functions-&gt;secondaryColor3i
+#define clSecondaryColor3iv CL_OpenGL::functions-&gt;secondaryColor3iv
+#define clSecondaryColor3s CL_OpenGL::functions-&gt;secondaryColor3s
+#define clSecondaryColor3sv CL_OpenGL::functions-&gt;secondaryColor3sv
+#define clSecondaryColor3ub CL_OpenGL::functions-&gt;secondaryColor3ub
+#define clSecondaryColor3ubv CL_OpenGL::functions-&gt;secondaryColor3ubv
+#define clSecondaryColor3ui CL_OpenGL::functions-&gt;secondaryColor3ui
+#define clSecondaryColor3uiv CL_OpenGL::functions-&gt;secondaryColor3uiv
+#define clSecondaryColor3us CL_OpenGL::functions-&gt;secondaryColor3us
+#define clSecondaryColor3usv CL_OpenGL::functions-&gt;secondaryColor3usv
+#define clSecondaryColorPointer CL_OpenGL::functions-&gt;secondaryColorPointer
+#define clBlendFuncSeparate CL_OpenGL::functions-&gt;blendFuncSeparate
+#define clWindowPos2d CL_OpenGL::functions-&gt;windowPos2d
+#define clWindowPos2dv CL_OpenGL::functions-&gt;windowPos2dv
+#define clWindowPos2f CL_OpenGL::functions-&gt;windowPos2f
+#define clWindowPos2fv CL_OpenGL::functions-&gt;windowPos2fv
+#define clWindowPos2i CL_OpenGL::functions-&gt;windowPos2i
+#define clWindowPos2iv CL_OpenGL::functions-&gt;windowPos2iv
+#define clWindowPos2s CL_OpenGL::functions-&gt;windowPos2s
+#define clWindowPos2sv CL_OpenGL::functions-&gt;windowPos2sv
+#define clWindowPos3d CL_OpenGL::functions-&gt;windowPos3d
+#define clWindowPos3dv CL_OpenGL::functions-&gt;windowPos3dv
+#define clWindowPos3f CL_OpenGL::functions-&gt;windowPos3f
+#define clWindowPos3fv CL_OpenGL::functions-&gt;windowPos3fv
+#define clWindowPos3i CL_OpenGL::functions-&gt;windowPos3i
+#define clWindowPos3iv CL_OpenGL::functions-&gt;windowPos3iv
+#define clWindowPos3s CL_OpenGL::functions-&gt;windowPos3s
+#define clWindowPos3sv CL_OpenGL::functions-&gt;windowPos3sv
+#define clBindBuffer CL_OpenGL::functions-&gt;bindBuffer
+#define clDeleteBuffers CL_OpenGL::functions-&gt;deleteBuffers
+#define clGenBuffers CL_OpenGL::functions-&gt;genBuffers
+#define clIsBuffer CL_OpenGL::functions-&gt;isBuffer
+#define clBufferData CL_OpenGL::functions-&gt;bufferData
+#define clBufferSubData CL_OpenGL::functions-&gt;bufferSubData
+#define clGetBufferSubData CL_OpenGL::functions-&gt;getBufferSubData
+#define clMapBuffer CL_OpenGL::functions-&gt;mapBuffer
+#define clUnmapBuffer CL_OpenGL::functions-&gt;unmapBuffer
+#define clGetBufferParameteriv CL_OpenGL::functions-&gt;getBufferParameteriv
+#define clGetBufferPointerv CL_OpenGL::functions-&gt;getBufferPointerv
+#define clGenQueries CL_OpenGL::functions-&gt;genQueries
+#define clDeleteQueries CL_OpenGL::functions-&gt;deleteQueries
+#define clIsQuery CL_OpenGL::functions-&gt;isQuery
+#define clBeginQuery CL_OpenGL::functions-&gt;beginQuery
+#define clEndQuery CL_OpenGL::functions-&gt;endQuery
+#define clGetQueryiv CL_OpenGL::functions-&gt;getQueryiv
+#define clGetQueryObjectiv CL_OpenGL::functions-&gt;getQueryObjectiv
+#define clGenQueryObjectuiv CL_OpenGL::functions-&gt;getQueryObjectuiv
+#define clDeleteShader CL_OpenGL::functions-&gt;deleteShader
+#define clDeleteProgram CL_OpenGL::functions-&gt;deleteProgram
+#define clGetHandle CL_OpenGL::functions-&gt;getHandle
+#define clDetachShader CL_OpenGL::functions-&gt;detachShader
+#define clCreateShader CL_OpenGL::functions-&gt;createShader
+#define clShaderSource CL_OpenGL::functions-&gt;shaderSource
+#define clCompileShader CL_OpenGL::functions-&gt;compileShader
+#define clCreateProgram CL_OpenGL::functions-&gt;createProgram
+#define clAttachShader CL_OpenGL::functions-&gt;attachShader
+#define clLinkProgram CL_OpenGL::functions-&gt;linkProgram
+#define clUseProgram CL_OpenGL::functions-&gt;useProgram
+#define clValidateProgram CL_OpenGL::functions-&gt;validateProgram
+#define clUniform1f CL_OpenGL::functions-&gt;uniform1f
+#define clUniform2f CL_OpenGL::functions-&gt;uniform2f
+#define clUniform3f CL_OpenGL::functions-&gt;uniform3f
+#define clUniform4f CL_OpenGL::functions-&gt;uniform4f
+#define clUniform1i CL_OpenGL::functions-&gt;uniform1i
+#define clUniform2i CL_OpenGL::functions-&gt;uniform2i
+#define clUniform3i CL_OpenGL::functions-&gt;uniform3i
+#define clUniform4i CL_OpenGL::functions-&gt;uniform4i
+#define clUniform1fv CL_OpenGL::functions-&gt;uniform1fv
+#define clUniform2fv CL_OpenGL::functions-&gt;uniform2fv
+#define clUniform3fv CL_OpenGL::functions-&gt;uniform3fv
+#define clUniform4fv CL_OpenGL::functions-&gt;uniform4fv
+#define clUniform1iv CL_OpenGL::functions-&gt;uniform1iv
+#define clUniform2iv CL_OpenGL::functions-&gt;uniform2iv
+#define clUniform3iv CL_OpenGL::functions-&gt;uniform3iv
+#define clUniform4iv CL_OpenGL::functions-&gt;uniform4iv
+#define clUniformMatrix2fv CL_OpenGL::functions-&gt;uniformMatrix2fv
+#define clUniformMatrix3fv CL_OpenGL::functions-&gt;uniformMatrix3fv
+#define clUniformMatrix4fv CL_OpenGL::functions-&gt;uniformMatrix4fv
+#define clGetProgramfv CL_OpenGL::functions-&gt;getProgramfv
+#define clGetProgramiv CL_OpenGL::functions-&gt;getProgramiv
+#define clGetShaderfv CL_OpenGL::functions-&gt;getShaderfv
+#define clGetShaderiv CL_OpenGL::functions-&gt;getShaderiv
+#define clGetShaderInfoLog CL_OpenGL::functions-&gt;getShaderInfoLog
+#define clGetProgramInfoLog CL_OpenGL::functions-&gt;getProgramInfoLog
+#define clGetAttachedShaders CL_OpenGL::functions-&gt;getAttachedShaders
+#define clGetUniformLocation CL_OpenGL::functions-&gt;getUniformLocation
+#define clGetActiveUniform CL_OpenGL::functions-&gt;getActiveUniform
+#define clGetUniformfv CL_OpenGL::functions-&gt;getUniformfv
+#define clGetUniformiv CL_OpenGL::functions-&gt;getUniformiv
+#define clGetShaderSource CL_OpenGL::functions-&gt;getShaderSource
+#define clVertexAttrib1f CL_OpenGL::functions-&gt;vertexAttrib1f
+#define clVertexAttrib1s CL_OpenGL::functions-&gt;vertexAttrib1s
+#define clVertexAttrib1d CL_OpenGL::functions-&gt;vertexAttrib1d
+#define clVertexAttrib2f CL_OpenGL::functions-&gt;vertexAttrib2f
+#define clVertexAttrib2s CL_OpenGL::functions-&gt;vertexAttrib2s
+#define clVertexAttrib2d CL_OpenGL::functions-&gt;vertexAttrib2d
+#define clVertexAttrib3f CL_OpenGL::functions-&gt;vertexAttrib3f
+#define clVertexAttrib3s CL_OpenGL::functions-&gt;vertexAttrib3s
+#define clVertexAttrib3d CL_OpenGL::functions-&gt;vertexAttrib3d
+#define clVertexAttrib4f CL_OpenGL::functions-&gt;vertexAttrib4f
+#define clVertexAttrib4s CL_OpenGL::functions-&gt;vertexAttrib4s
+#define clVertexAttrib4d CL_OpenGL::functions-&gt;vertexAttrib4d
+#define clVertexAttrib4Nub CL_OpenGL::functions-&gt;vertexAttrib4Nub
+#define clVertexAttrib1fv CL_OpenGL::functions-&gt;vertexAttrib1fv
+#define clVertexAttrib1sv CL_OpenGL::functions-&gt;vertexAttrib1sv
+#define clVertexAttrib1dv CL_OpenGL::functions-&gt;vertexAttrib1dv
+#define clVertexAttrib2fv CL_OpenGL::functions-&gt;vertexAttrib2fv
+#define clVertexAttrib2sv CL_OpenGL::functions-&gt;vertexAttrib2sv
+#define clVertexAttrib2dv CL_OpenGL::functions-&gt;vertexAttrib2dv
+#define clVertexAttrib3fv CL_OpenGL::functions-&gt;vertexAttrib3fv
+#define clVertexAttrib3sv CL_OpenGL::functions-&gt;vertexAttrib3sv
+#define clVertexAttrib3dv CL_OpenGL::functions-&gt;vertexAttrib3dv
+#define clVertexAttrib4fv CL_OpenGL::functions-&gt;vertexAttrib4fv
+#define clVertexAttrib4sv CL_OpenGL::functions-&gt;vertexAttrib4sv
+#define clVertexAttrib4dv CL_OpenGL::functions-&gt;vertexAttrib4dv
+#define clVertexAttrib4iv CL_OpenGL::functions-&gt;vertexAttrib4iv
+#define clVertexAttrib4bv CL_OpenGL::functions-&gt;vertexAttrib4bv
+#define clVertexAttrib4ubv CL_OpenGL::functions-&gt;vertexAttrib4ubv
+#define clVertexAttrib4usv CL_OpenGL::functions-&gt;vertexAttrib4usv
+#define clVertexAttrib4uiv CL_OpenGL::functions-&gt;vertexAttrib4uiv
+#define clVertexAttrib4Nbv CL_OpenGL::functions-&gt;vertexAttrib4Nbv
+#define clVertexAttrib4Nsv CL_OpenGL::functions-&gt;vertexAttrib4Nsv
+#define clVertexAttrib4Niv CL_OpenGL::functions-&gt;vertexAttrib4Niv
+#define clVertexAttrib4Nubv CL_OpenGL::functions-&gt;vertexAttrib4Nubv
+#define clVertexAttrib4Nusv CL_OpenGL::functions-&gt;vertexAttrib4Nusv
+#define clVertexAttrib4Nuiv CL_OpenGL::functions-&gt;vertexAttrib4Nuiv
+#define clVertexAttribPointer CL_OpenGL::functions-&gt;vertexAttribPointer
+#define clEnableVertexAttribArray CL_OpenGL::functions-&gt;enableVertexAttribArray
+#define clDisableVertexAttribArray CL_OpenGL::functions-&gt;disableVertexAttribArray
+#define clBindAttribLocation CL_OpenGL::functions-&gt;bindAttribLocation
+#define clGetActiveAttrib CL_OpenGL::functions-&gt;getActiveAttrib
+#define clGetAttribLocation CL_OpenGL::functions-&gt;getAttribLocation
+#define clGetVertexAttribdv CL_OpenGL::functions-&gt;getVertexAttribdv
+#define clGetVertexAttribfv CL_OpenGL::functions-&gt;getVertexAttribfv
+#define clGetVertexAttribiv CL_OpenGL::functions-&gt;getVertexAttribiv
+#define clGetVertexAttribPointerv CL_OpenGL::functions-&gt;getVertexAttribPointerv
+#define clDrawBuffers CL_OpenGL::functions-&gt;drawBuffers
+#define clStencilFuncSeparate CL_OpenGL::functions-&gt;stencilFuncSeparate
+#define clStencilOpSeparate CL_OpenGL::functions-&gt;stencilOpSeparate
+
+#endif

Added: trunk/clanlib/API/GL/program_attribute.h
===================================================================
--- trunk/clanlib/API/GL/program_attribute.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GL/program_attribute.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,89 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGL=&quot;Display 3D&quot;
+//! header=gl.h
+
+#ifndef header_program_attribute
+#define header_program_attribute
+
+#ifdef CL_API_DLL
+#ifdef CL_GL_EXPORT
+#define CL_API_GL __declspec(dllexport)
+#else
+#define CL_API_GL __declspec(dllimport)
+#endif
+#else
+#define CL_API_GL
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Core/System/sharedptr.h&quot;
+#include &lt;string&gt;
+
+class CL_ProgramAttribute_Generic;
+
+//: OpenGL program object attribute.
+class CL_API_GL CL_ProgramAttribute
+{
+//! Construction:
+public:
+	//: Constructs a program attribute.
+	//param name: Name of attribute.
+	//param size: Attribute size.
+	//param type: OpenGL attribute type.
+	CL_ProgramAttribute();
+	
+	CL_ProgramAttribute(const std::string &amp;name, int size, int type);
+	
+	~CL_ProgramAttribute();
+
+//! Attributes:
+public:
+	//: Get attribute name.
+	const std::string &amp;get_name() const;
+
+	//: Get attribute size.
+	int get_size() const;
+
+	//: Get attribute OpenGL type.
+	int get_type() const;
+
+//! Operations:
+public:
+
+//! Implementation:
+private:
+	CL_SharedPtr&lt;CL_ProgramAttribute_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/GL/program_object.h
===================================================================
--- trunk/clanlib/API/GL/program_object.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GL/program_object.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,178 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGL=&quot;Display 3D&quot;
+//! header=gl.h
+
+#ifndef header_program_object
+#define header_program_object
+
+#ifdef CL_API_DLL
+#ifdef CL_GL_EXPORT
+#define CL_API_GL __declspec(dllexport)
+#else
+#define CL_API_GL __declspec(dllimport)
+#endif
+#else
+#define CL_API_GL
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Core/System/sharedptr.h&quot;
+#include &lt;string&gt;
+#include &lt;vector&gt;
+
+class CL_ResourceManager;
+class CL_ShaderObject;
+class CL_ProgramAttribute;
+class CL_ProgramUniform;
+class CL_ProgramObject_Generic;
+
+//: OpenGL Program Object
+//- &lt;p&gt;The shader objects that are to be used by programmable stages of
+//- OpenGL are collected together to form a program object. CL_ProgramObject
+//- is ClanLib's C++ interface to OpenGL program objects.&lt;/p&gt;
+//- &lt;p&gt;To construct a program object programatically, the procedure is
+//- as follows:&lt;/p&gt;
+//- &lt;pre&gt;
+//- CL_ShaderObject vertex_shader(cl_shadertype_vertex, vertex_glsl_sourcecode);
+//- CL_ShaderObject fragment_shader(cl_shadertype_fragment, fragment_glsl_sourcecode);
+//- CL_ProgramObject program;
+//- program.attach(vertex_shader);
+//- program.attach(fragment_shader);
+//- program.link();
+//- &lt;/pre&gt;
+//- &lt;p&gt;For more information about program objects, see the OpenGL 2.0
+//- specification at &lt;a href=&quot;<A HREF="http://www.opengl.org">http://www.opengl.org</A>&quot;&gt;www.opengl.org&lt;/a&gt;. Documentation
+//- about the OpenGL Shader Language (GLSL) is also available from www.opengl.org.&lt;/p&gt;
+class CL_API_GL CL_ProgramObject
+{
+//! Construction:
+public:
+	//: Construct OpenGL program object.
+	//param resource_id: Name of probject object resource.
+	//param resources: Resource Manager providing resource.
+	CL_ProgramObject();
+	
+	CL_ProgramObject(const std::string &amp;resource_id, CL_ResourceManager *resources);
+	
+	virtual ~CL_ProgramObject();
+
+//! Attributes:
+public:
+	//: Returns the OpenGL program object handle.
+	unsigned int get_handle() const;
+
+	//: Returns true if the link succeeded.
+	bool get_link_status() const;
+	
+	//: Returns true if validation succeeded.
+	bool get_validate_status() const;
+
+	//: Returns the shaders attached to the program object.	
+	std::vector&lt;CL_ShaderObject&gt; get_shaders() const;
+
+	//: Returns the current info log for the program object.
+	std::string get_info_log() const;
+	
+	//: Returns the count of active attributes.
+	int get_attribute_count() const;
+	
+	//: Returns the active attributes.
+	std::vector&lt;CL_ProgramAttribute&gt; get_attributes() const;
+	
+	//: Returns the location of a named active attribute.
+	int get_attribute_location(const std::string &amp;name) const;
+	
+	//: Returns the count of active uniform variables.
+	int get_uniform_count() const;
+
+	//: Returns true if the uniform variable is present in the program.
+	//param name: uniform variable name
+	//param type: CL_FLOAT, CL_FLOAT_VEC2, CL_FLOAT_VEC3, CL_FLOAT_VEC4, CL_INT, CL_INT_VEC2, CL_INT_VEC3, CL_INT_VEC4, CL_BOOL, CL_BOOL_VEC2, CL_BOOL_VEC3, CL_BOOL_VEC4, CL_FLOAT_MAT2, CL_FLOAT_MAT3, CL_FLOAT_MAT4, CL_SAMPLER_1D, CL_SAMPLER_2D, CL_SAMPLER_3D, CL_SAMPLER_CUBE, CL_SAMPLER_1D SHADOW or CL_SAMPLER_2D_SHADOW
+	bool has_uniform(const std::string &amp;name, int type) const;
+
+	//: Returns a list of the active uniforms.
+	std::vector&lt;CL_ProgramUniform&gt; get_uniforms() const;
+
+	//: Returns the location of a named uniform variable.
+	int get_uniform_location(const std::string &amp;name) const;
+	
+//! Operations:
+public:
+	//: Add shader to program object.
+	void attach(const CL_ShaderObject &amp;obj);
+
+	//: Remove shader from program object.
+	void detach(const CL_ShaderObject &amp;obj);
+
+	//: Bind attribute to specific location.
+	//- &lt;p&gt;This function must be called before linking.&lt;/p&gt;
+	void bind_attribute_location(int index, const std::string &amp;name);
+
+	//: Link program.
+	//- &lt;p&gt;If the linking fails, get_link_status() will return false and
+	//- get_info_log() will return the link log.&lt;/p&gt;
+	void link();
+
+	//: Validate program.
+	//- &lt;p&gt;If the validation fails, get_validate_status() will return
+	//- false and get_info_log() will return the validation log.&lt;/p&gt;
+	void validate();
+
+	//: Start using the shader.
+	void use();
+
+	//: Stop using the shader.
+	void disable();
+
+	//: Set uniform variable(s).
+	void set_uniform(const std::string &amp;name, int);
+	void set_uniform(const std::string &amp;name, int, int);
+	void set_uniform(const std::string &amp;name, int, int, int);
+	void set_uniform(const std::string &amp;name, int, int, int, int);
+	void set_uniform(const std::string &amp;name, int size, int count, int *data);
+	void set_uniform(const std::string &amp;name, float);
+	void set_uniform(const std::string &amp;name, float, float);
+	void set_uniform(const std::string &amp;name, float, float, float);
+	void set_uniform(const std::string &amp;name, float, float, float, float);
+	void set_uniform(const std::string &amp;name, int size, int count, float *data);
+
+	//: Set uniform matrices.
+	void set_uniform_matrix(const std::string &amp;name, int size, int count, bool transpose, float *data);
+
+//! Implementation:
+private:
+	CL_SharedPtr&lt;CL_ProgramObject_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/GL/program_uniform.h
===================================================================
--- trunk/clanlib/API/GL/program_uniform.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GL/program_uniform.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,63 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    Harry Storbacka
+*/
+
+//! clanGL=&quot;Display 3D&quot;
+//! header=gl.h
+
+#ifndef header_program_uniform
+#define header_program_uniform
+
+#ifdef CL_API_DLL
+#ifdef CL_GL_EXPORT
+#define CL_API_GL __declspec(dllexport)
+#else
+#define CL_API_GL __declspec(dllimport)
+#endif
+#else
+#define CL_API_GL
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+
+//: OpenGL program object uniform variable information.
+class CL_API_GL CL_ProgramUniform
+{
+public:
+	CL_ProgramUniform(const std::string &amp;name, int size, int type);
+
+	std::string name;
+	int size;
+	int type;
+};
+
+#endif

Added: trunk/clanlib/API/GL/setupgl.h
===================================================================
--- trunk/clanlib/API/GL/setupgl.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GL/setupgl.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,73 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGL=&quot;System&quot;
+//! header=gl.h
+
+#ifndef header_setupgl
+#define header_setupgl
+
+#ifdef CL_API_DLL
+#ifdef CL_GL_EXPORT
+#define CL_API_GL __declspec(dllexport)
+#else
+#define CL_API_GL __declspec(dllimport)
+#endif
+#else
+#define CL_API_GL
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+//: ClanGL initialization functions.
+//- !group=GL/System!
+//- !header=gl.h!
+class CL_API_GL CL_SetupGL
+{
+//! Construction:
+public:
+	//: Initializes clanGL.
+	//- &lt;p&gt;Constructing a CL_SetupGL object is equalent to calling CL_SetupGL::init().&lt;/p&gt;
+	//- &lt;p&gt;When the CL_SetupGL instance is destroyed, CL_SetupGL::deinit() is called.&lt;/p&gt;
+	CL_SetupGL(bool register_resources_only = false);
+
+	~CL_SetupGL();
+
+//! Operations:
+public:
+	//: Initialize the clanGL library.
+	static void init(bool register_resources_only = false);
+	
+	//: Deinitialize the clanGL library.
+	static void deinit();
+};
+
+#endif

Added: trunk/clanlib/API/GL/shader_object.h
===================================================================
--- trunk/clanlib/API/GL/shader_object.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GL/shader_object.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,117 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGL=&quot;Display 3D&quot;
+//! header=gl.h
+
+#ifndef header_shader_object
+#define header_shader_object
+
+#ifdef CL_API_DLL
+#ifdef CL_GL_EXPORT
+#define CL_API_GL __declspec(dllexport)
+#else
+#define CL_API_GL __declspec(dllimport)
+#endif
+#else
+#define CL_API_GL
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Core/System/sharedptr.h&quot;
+#include &lt;string&gt;
+#include &lt;vector&gt;
+
+class CL_ResourceManager;
+class CL_ShaderObject_Generic;
+
+//: OpenGL Shader Type
+enum CL_ShaderType
+{
+	cl_shadertype_vertex,
+	cl_shadertype_fragment
+};
+
+//: OpenGL Shader Object
+//- &lt;p&gt;The source code that makes up a program that gets executed by one of
+//- the programmable stages is encapsulated in one or more shader
+//- objects. Shader objects are attached to a program objects to form a
+//- programmable setup. CL_ShaderObject is ClanLib's C++ interface to OpenGL
+//- shader objects.&lt;/p&gt;
+class CL_API_GL CL_ShaderObject
+{
+//! Construction:
+public:
+	//: Constructs an OpenGL shader.
+	//param type: Shader type. Can be cl_shadertype_vertex or cl_shadertype_fragment.
+	//param source: Shader source code, in OpenGL Shader Language (GLSL).
+	//param sources: Shader source code as list of strings.
+	//param resource_id: Name of shader object resource.
+	//param resources: Resource Manager providing resource.
+	CL_ShaderObject(CL_ShaderType type);
+
+	CL_ShaderObject(CL_ShaderType type, const std::string &amp;source);
+	
+	CL_ShaderObject(CL_ShaderType type, const std::vector&lt;std::string&gt; &amp;sources);
+	
+	CL_ShaderObject(const std::string &amp;resource_id, CL_ResourceManager *resources);
+	
+	virtual ~CL_ShaderObject();
+
+//! Attributes:
+public:
+	//: Returns the OpenGL shader handle.
+	unsigned int get_handle() const;
+	
+	//: Returns true if compile succeeded.
+	bool get_compile_status() const;
+
+	//: Gets the shader type.
+	CL_ShaderType get_shader_type() const;
+
+	//: Get shader object's info log.
+	std::string get_info_log() const;
+
+	//: Get shader source code.
+	std::string get_shader_source() const;
+	
+//! Operations:
+public:
+	//: Handle assignment operator.
+	bool operator==(const CL_ShaderObject &amp;other) const;
+
+//! Implementation:
+private:
+	CL_SharedPtr&lt;CL_ShaderObject_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/GL/texture.h
===================================================================
--- trunk/clanlib/API/GL/texture.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GL/texture.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,588 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGL=&quot;Display 3D&quot;
+//! header=gl.h
+
+#ifndef header_texture
+#define header_texture
+
+#ifdef CL_API_DLL
+#ifdef CL_GL_EXPORT
+#define CL_API_GL __declspec(dllexport)
+#else
+#define CL_API_GL __declspec(dllimport)
+#endif
+#else
+#define CL_API_GL
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Core/System/sharedptr.h&quot;
+
+enum CL_TextureWrapMode
+{
+	cl_wrap_clamp,
+	cl_wrap_clamp_to_edge,
+	cl_wrap_clamp_to_border,
+	cl_wrap_repeat,
+	cl_wrap_mirrored_repeat
+};
+
+enum CL_TextureFilter
+{
+	cl_filter_nearest,
+	cl_filter_linear,
+	cl_filter_nearest_mipmap_nearest,
+	cl_filter_nearest_mipmap_linear,
+	cl_filter_linear_mipmap_nearest,
+	cl_filter_linear_mipmap_linear
+};
+
+enum CL_TextureDepthMode
+{
+	cl_depthmode_luminance,
+	cl_depthmode_intensity,
+	cl_depthmode_alpha
+};
+
+enum CL_TextureCompareMode
+{
+	cl_comparemode_none,
+	cl_comparemode_compare_r_to_texture
+};
+
+enum CL_TextureCompareFunction
+{
+	cl_comparefunc_lequal,
+	cl_comparefunc_gequal,
+	cl_comparefunc_less,
+	cl_comparefunc_greater,
+	cl_comparefunc_equal,
+	cl_comparefunc_notequal,
+	cl_comparefunc_always,
+	cl_comparefunc_never
+};
+
+class CL_Color;
+class CL_PixelFormat;
+class CL_PixelBuffer;
+class CL_Rect;
+class CL_Point;
+class CL_Size;
+class CL_GraphicContext;
+class CL_Texture_Generic;
+
+//: OpenGL texture container.
+//- &lt;p&gt;This class is ClanLib's C++ interface to an OpenGL texture.&lt;/p&gt;
+class CL_API_GL CL_Texture
+{
+//! Construction:
+public:
+	//: Construct a texture object.
+	//param target_gl: OpenGL texture target. Can be CL_TEXTURE_1D, CL_TEXTURE_2D, CL_TEXTURE_3D or CL_TEXTURE_CUBE_MAP.
+	//param image: Initial image to upload as level-of-detail 0.
+	//param autogenerate_mipmap: If true, enables mipmap autogeneration before uploading image.
+	//param border: Border width of texture.
+	//param format: Internal texture format of texture.
+	CL_Texture();
+
+	CL_Texture(int target_gl);
+
+	CL_Texture(
+		int target_gl,
+		CL_PixelBuffer &amp;image,
+		bool autogenerate_mipmaps = false,
+		int border = 0,
+		int format = 0);
+	
+	CL_Texture(
+		int target_gl,
+		int format,
+		int width,
+		int height = 1,
+		int depth = 1,
+		int border = 0,
+		int level = 0);
+	
+	~CL_Texture();
+
+//! Attributes:
+public:
+	//: Returns the OpenGL texture handle.
+	int get_handle();
+
+	//: Get the texture target as OpenGL constant.
+	int get_target_gl();
+
+	//: Get the internal texture format as OpenGL constant.
+	int get_format_gl();
+
+	//: Get the texture width.
+	//param level: Mipmap level to get width for.
+	int get_width(int level);
+
+	//: Get the texture height.
+	//param level: Mipmap level to get height for.
+	int get_height(int level);
+
+	//: Get the texture depth.
+	int get_depth();
+
+	//: Get the texture border size.
+	int get_border();
+
+	//: Retrieve image data from texture.
+	CL_PixelBuffer get_pixeldata(int level = 0);
+
+	CL_PixelBuffer get_pixeldata(CL_PixelFormat &amp;format, int level = 0);
+
+	CL_PixelBuffer get_pixeldata(const CL_Rect &amp;rect, int level = 0);
+
+	CL_PixelBuffer get_pixeldata(CL_PixelFormat &amp;format, const CL_Rect &amp;rect, int level = 0);
+
+	//: Get the minimum level of detail.
+	float get_min_lod() const;
+
+	//: Get the maximum level of detail.
+	float get_max_lod() const;
+
+	//: Get the level of detail bias constant.
+	float get_lod_bias() const;
+
+	//: Get the texture base level.
+	int get_base_level() const;
+
+	//: Get the texture max level.
+	int get_max_level() const;
+
+	//: Get if automatic mipmap generation is enabled.
+	bool get_generate_mipmap() const;
+
+	//: Get the texture wrap mode for the s coordinate.
+	CL_TextureWrapMode get_wrap_mode_s() const;
+
+	//: Get the texture wrap mode for the s coordinate as OpenGL constant.
+	int get_wrap_mode_s_gl() const;
+
+	//: Get the texture wrap mode for the t coordinate.
+	CL_TextureWrapMode get_wrap_mode_t() const;
+
+	//: Get the texture wrap mode for the t coordinate as OpenGL constant.
+	int get_wrap_mode_t_gl() const;
+
+	//: Get the texture wrap mode for the r coordinate.
+	CL_TextureWrapMode get_wrap_mode_r() const;
+
+	//: Get the texture wrap mode for the r coordinate as OpenGL constant.
+	int get_wrap_mode_r_gl() const;
+
+	//: Get the texture minification filter.
+	CL_TextureFilter get_min_filter() const;
+
+	//: Get the texture minification filter as OpenGL constant.
+	int get_min_filter_gl() const;
+
+	//: Get the texture magnification filter.
+	CL_TextureFilter get_mag_filter() const;
+
+	//: Get the texture magnification filter as OpenGL constant.
+	int get_mag_filter_gl() const;
+
+	//: Get the texture border color.
+	CL_Color get_border_color() const;
+
+	//: Get the texture priority.
+	float get_priority() const;
+	
+	//: Returns true if texture is resident in texture memory.
+	bool is_resident() const;
+
+	//: Get the texture depth mode.
+	CL_TextureDepthMode get_depth_mode() const;
+
+	//: Get the texture depth mode as OpenGL constant.
+	int get_depth_mode_gl() const;
+
+	//: Get the texture compare mode.
+	CL_TextureCompareMode get_compare_mode() const;
+
+	//: Get the texture compare mode as OpenGL constant.
+	int get_compare_mode_gl() const;
+
+	//: Get the texture compare function.
+	CL_TextureCompareFunction get_compare_function() const;
+
+	//: Get the texture compare function as OpenGL constant.
+	int get_compare_function_gl() const;
+
+//! Operations:
+public:
+	//: Bind texture on current active CL_OpenGLState.
+	void bind();
+
+	//: Set texture size, without uploading any image data.
+	void set_size(
+		int format,
+		int width,
+		int height = 1,
+		int depth = 1,
+		int border = 0,
+		int level = 0);
+
+	//: Upload image to texture.
+	//param image: Image to upload.
+	//param level: Mipmap level-of-detail number.
+	//param border: Border width of texture.
+	//param format: Internal texture format of texture.
+	void set_image(
+		CL_PixelBuffer &amp;image,
+		int level = 0,
+		int border = 0,
+		int format = 0);
+
+	//: Upload cube map.
+	void set_cube_map(
+		CL_PixelBuffer &amp;cube_map_positive_x,
+		CL_PixelBuffer &amp;cube_map_negative_x,
+		CL_PixelBuffer &amp;cube_map_positive_y,
+		CL_PixelBuffer &amp;cube_map_negative_y,
+		CL_PixelBuffer &amp;cube_map_positive_z,
+		CL_PixelBuffer &amp;cube_map_negative_z,
+		int level = 0,
+		int border = 0,
+		int format = 0);
+
+	//: Upload 3D image to texture with OpenGL constants.
+	void set_image3d_gl(
+		int gl_target,
+		int gl_level,
+		int gl_internal_format,
+		int gl_width,
+		int gl_height,
+		int gl_depth,
+		int gl_border,
+		int gl_format,
+		int gl_type = 0,
+		void *gl_data = 0);
+
+	//: Upload 2D image to texture with OpenGL constants.
+	void set_image2d_gl(
+		int gl_target,
+		int gl_level,
+		int gl_internal_format,
+		int gl_width,
+		int gl_height,
+		int gl_border,
+		int gl_format,
+		int gl_type = 0,
+		void *gl_data = 0);
+		
+	//: Upload 1D image to texture with OpenGL constants.
+	void set_image1d_gl(
+		int gl_target,
+		int gl_level,
+		int gl_internal_format,
+		int gl_width,
+		int gl_border,
+		int gl_format,
+		int gl_type = 0,
+		void *gl_data = 0);
+
+	//: Upload image to sub texture.
+	//param image: Image to upload.
+	//param level: Mipmap level-of-detail number.
+	void set_subimage(
+		int x,
+		int y,
+		CL_PixelBuffer &amp;image,
+		int level = 0);
+
+	void set_subimage(
+		const CL_Point &amp;point,
+		CL_PixelBuffer &amp;image,
+		int level = 0);
+
+	//: Upload 3D sub image to texture with OpenGL constants.
+	void set_subimage3d_gl(
+		int gl_target,
+		int gl_level,
+		int gl_xoffset,
+		int gl_yoffset,
+		int gl_zoffset,
+		int gl_width,
+		int gl_height,
+		int gl_depth,
+		int gl_format,
+		int gl_type,
+		void *gl_data);
+
+	//: Upload 2D sub image to texture with OpenGL constants.
+	void set_subimage2d_gl(
+		int gl_target,
+		int gl_level,
+		int gl_xoffset,
+		int gl_yoffset,
+		int gl_width,
+		int gl_height,
+		int gl_format,
+		int gl_type,
+		void *gl_data);
+		
+	//: Upload 1D sub image to texture with OpenGL constants.
+	void set_subimage1d_gl(
+		int gl_target,
+		int gl_level,
+		int gl_xoffset,
+		int gl_width,
+		int gl_format,
+		int gl_type,
+		void *gl_data);
+
+	//: Copy image data from a graphic context.
+	void copy_image(
+		int level,
+		int border = 0,
+		int format = 0,
+		CL_GraphicContext *gc = 0);
+
+	void copy_image(
+		int x,
+		int y,
+		int width,
+		int height,
+		int level = 0,
+		int border = 0,
+		int format = 0,
+		CL_GraphicContext *gc = 0);
+	
+	void copy_image(
+		const CL_Rect &amp;pos,
+		int level = 0,
+		int border = 0,
+		int format = 0,
+		CL_GraphicContext *gc = 0);
+
+	//: Copy 2D image data from a graphic context with OpenGL constants.
+	void copy_image2d_gl(
+		int gl_target,
+		int gl_level,
+		int gl_internal_format,
+		int gl_x,
+		int gl_y,
+		int gl_width,
+		int gl_height,
+		int gl_border = 0,
+		CL_GraphicContext *gc = 0);
+	
+	//: Copy 1D image data from a graphic context with OpenGL constants.
+	void copy_image1d_gl(
+		int gl_target,
+		int gl_level,
+		int gl_internal_format,
+		int gl_x,
+		int gl_y,
+		int gl_width,
+		int gl_border,
+		CL_GraphicContext *gc = 0);
+
+	//: Copy sub image data from a graphic context.
+	void copy_subimage(
+		int offset_x,
+		int offset_y,
+		int level,
+		CL_GraphicContext *gc = 0);
+
+	void copy_subimage(
+		int offset_x,
+		int offset_y,
+		int x,
+		int y,
+		int width,
+		int height,
+		int level = 0,
+		CL_GraphicContext *gc = 0);
+	
+	void copy_subimage(
+		const CL_Point &amp;offset,
+		const CL_Rect &amp;pos,
+		int level = 0,
+		CL_GraphicContext *gc = 0);
+
+	//: Copy 3D sub image data from a graphic context with OpenGL constants.
+	void copy_subimage3d_gl(
+		int gl_target,
+		int gl_level,
+		int gl_xoffset,
+		int gl_yoffset,
+		int gl_zoffset,
+		int gl_x,
+		int gl_y,
+		int gl_width,
+		int gl_height,
+		CL_GraphicContext *gc = 0);
+
+	//: Copy 2D sub image data from a graphic context with OpenGL constants.
+	void copy_subimage2d_gl(
+		int gl_target,
+		int gl_level,
+		int gl_xoffset,
+		int gl_yoffset,
+		int gl_x,
+		int gl_y,
+		int gl_width,
+		int gl_height,
+		CL_GraphicContext *gc = 0);
+	
+	//: Copy 1D sub image data from a graphic context with OpenGL constants.
+	void copy_subimage1d_gl(
+		int gl_target,
+		int gl_level,
+		int gl_xoffset,
+		int gl_internal_format,
+		int gl_x,
+		int gl_y,
+		int gl_width,
+		CL_GraphicContext *gc = 0);
+
+	//: Set the minimum level of detail texture parameter.
+	void set_min_lod(float min_lod);
+
+	//: Set the maximum level of detail texture parameter.
+	void set_max_lod(float max_lod);
+
+	//: Sets the level of detail bias constant.
+	void set_lod_bias(float lod_bias);
+
+	//: Sets the texture base level texture parameter.
+	void set_base_level(int base_level);
+
+	//: Sets the texture max level texture parameter.
+	void set_max_level(int max_level);
+
+	//: Enables or disables automatic mipmap generation when uploading image data.
+	void set_generate_mipmap(bool generate_mipmap = true);
+
+	//: Set the texture wrapping mode.
+	void set_wrap_mode(
+		CL_TextureWrapMode wrap_s,
+		CL_TextureWrapMode wrap_t,
+		CL_TextureWrapMode wrap_r);
+	
+	void set_wrap_mode(
+		CL_TextureWrapMode wrap_s,
+		CL_TextureWrapMode wrap_t);
+
+	void set_wrap_mode(
+		CL_TextureWrapMode wrap_s);
+
+	//: Set the texture wrapping mode with OpenGL constants.
+	void set_wrap_mode_gl(
+		int gl_wrap_s,
+		int gl_wrap_t,
+		int gl_wrap_r);
+
+	void set_wrap_mode_gl(
+		int gl_wrap_s,
+		int gl_wrap_t);
+
+	void set_wrap_mode_gl(
+		int gl_wrap_s);
+
+	//: Set the minification filter.
+	void set_min_filter(CL_TextureFilter filter);
+
+	//: Set the minification filter with an OpenGL constant.
+	void set_min_filter_gl(int filter);
+
+	//: Set the magnification filter.
+	void set_mag_filter(CL_TextureFilter filter);
+
+	//: Set the magnification filter with an OpenGL constant.
+	void set_mag_filter_gl(int filter);
+
+	//: Set texture border color.
+	void set_border_color(float red, float green, float blue, float alpha);
+
+	void set_border_color(const CL_Color &amp;color);
+
+	//: Set texture priority.
+	void set_priority(float priority);
+
+	//: Set the depth texture mode parameter.
+	void set_depth_mode(CL_TextureDepthMode depth_mode);
+
+	//: Set the depth texture mode with an OpenGL constant.
+	void set_depth_mode_gl(int depth_mode);
+
+	//: Sets the texture compare mode and compare function texture parameters.
+	void set_texture_compare(CL_TextureCompareMode mode, CL_TextureCompareFunction func);
+
+	//: Sets the texture compare mode and function with an OpenGL constant.
+	void set_texture_compare_gl(int mode, int func);
+
+	//: Returns wrap mode as OpenGL constant.
+	static int wrap_mode_to_gl(CL_TextureWrapMode wrap);
+
+	//: Returns OpenGL constant as wrap mode.
+	static CL_TextureWrapMode gl_to_wrap_mode(int gl_wrap);
+
+	//: Converts CL_TextureFilter enum to OpenGL constant.	
+	static int filter_to_gl(CL_TextureFilter filter);
+
+	//: Converts OpenGL constant to CL_Texturefilter enum.
+	static CL_TextureFilter gl_to_filter(int gl_filter);
+	
+	//: Converts CL_TextureDepthMode enum to OpenGL constant.
+	static int depth_mode_to_gl(CL_TextureDepthMode depth_mode);
+	
+	//: Converts OpenGL constant to CL_TextureDepthMode enum.
+	static CL_TextureDepthMode gl_to_depth_mode(int gl_depth_mode);
+	
+	//: Converts CL_TextureCompareMode enum to OpenGL constant.
+	static int compare_mode_to_gl(CL_TextureCompareMode mode);
+	
+	//: Converts OpenGL constant to CL_TextureCompareMode enum.
+	static CL_TextureCompareMode gl_to_compare_mode(int gl_mode);
+	
+	//: Converts CL_TextureCompareFunction to OpenGL constant.
+	static int compare_function_to_gl(CL_TextureCompareFunction func);
+
+	//: Converts OpenGL constant to CL_TextureCompareFunction.
+	static CL_TextureCompareFunction gl_to_compare_function(int gl_func);
+
+//! Implementation:
+private:
+	CL_SharedPtr&lt;CL_Texture_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/GL/texture_unit.h
===================================================================
--- trunk/clanlib/API/GL/texture_unit.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GL/texture_unit.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,256 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGL=&quot;Display 3D&quot;
+//! header=gl.h
+
+#ifndef header_texture_unit
+#define header_texture_unit
+
+#ifdef CL_API_DLL
+#ifdef CL_GL_EXPORT
+#define CL_API_GL __declspec(dllexport)
+#else
+#define CL_API_GL __declspec(dllimport)
+#endif
+#else
+#define CL_API_GL
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Core/System/sharedptr.h&quot;
+
+class CL_TextureUnit_Generic;
+
+enum CL_TextureUnitMode
+{
+	cl_unitmode_replace,
+	cl_unitmode_modulate,
+	cl_unitmode_decal,
+	cl_unitmode_blend,
+	cl_unitmode_add,
+	cl_unitmode_combine
+};
+
+enum CL_TextureUnitRGBMode
+{
+	cl_combinemode_rgb_replace,
+	cl_combinemode_rgb_modulate,
+	cl_combinemode_rgb_add,
+	cl_combinemode_rgb_add_signed,
+	cl_combinemode_rgb_interpolate,
+	cl_combinemode_rgb_subtract,
+	cl_combinemode_rgb_dot3_rgb,
+	cl_combinemode_rgb_dot3_rgba
+};
+
+enum CL_TextureUnitAlphaMode
+{
+	cl_combinemode_alpha_replace,
+	cl_combinemode_alpha_modulate,
+	cl_combinemode_alpha_add,
+	cl_combinemode_alpha_add_signed,
+	cl_combinemode_alpha_interpolate,
+	cl_combinemode_alpha_subtract
+};
+
+enum CL_TextureUnitSource
+{
+	cl_source_texture,
+	cl_source_texture0,
+	cl_source_texture1,
+	cl_source_texture2,
+	cl_source_texture3,
+	cl_source_texture4,
+	cl_source_texture5,
+	cl_source_texture6,
+	cl_source_texture7,
+	cl_source_texture8,
+	cl_source_texture9,
+	cl_source_texture10,
+	cl_source_texture11,
+	cl_source_texture12,
+	cl_source_texture13,
+	cl_source_texture14,
+	cl_source_texture15,
+	cl_source_constant,
+	cl_source_primary_color,
+	cl_source_previous
+};
+
+enum CL_TextureUnitRGBOperand
+{
+	cl_rgb_operand_src_color,
+	cl_rgb_operand_one_minus_src_color,
+	cl_rgb_operand_src_alpha,
+	cl_rgb_operand_one_minus_src_alpha
+};
+
+enum CL_TextureUnitAlphaOperand
+{
+	cl_rgb_operand_src_alpha,
+	cl_rgb_operand_one_minus_src_alpha
+};
+
+class CL_Color;
+
+//: glTexEnv container.
+class CL_API_GL CL_TextureUnit
+{
+//! Construction:
+public:
+	//: Constructs a texture unit.
+	CL_TextureUnit();
+
+	~CL_TextureUnit();
+
+//! Attributes:
+public:
+	//: Returns the texture level of detail bias for texture unit.
+	float get_lod_bias() const;
+
+	//: Returns the constant color for texture unit.
+	CL_Color get_color() const;
+
+	void get_color(float &amp;red, float &amp;green, float &amp;blue, float &amp;alpha) const;
+
+	void get_color(float color[4]) const;
+
+	//: Returns the texture function for texture unit.
+	CL_TextureUnitMode get_mode() const;
+
+	//: Returns the texture function as an OpenGL constant.
+	int get_mode_gl() const;
+
+	//: Returns the RGB combine texture function.
+	//- &lt;p&gt;The RGB combine texture function is only used when the mode is cl_unitmode_combine.&lt;/p&gt;
+	CL_TextureUnitRGBMode get_combine_rgb_mode() const;
+
+	//: Returns the RGB combine texture function as OpenGL constant.
+	//- &lt;p&gt;The RGB combine texture function is only used when the mode is cl_unitmode_combine.&lt;/p&gt;
+	int get_combine_rgb_mode_gl() const;
+
+	//: Returns the alpha combine texture function.
+	//- &lt;p&gt;The alpha combine texture function is only used when the mode is cl_unitmode_combine.&lt;/p&gt;
+	CL_TextureUnitAlphaMode get_combine_alpha_mode() const;
+
+	//: Returns the alpha combine texture function as OpenGL constant.
+	//- &lt;p&gt;The alpha combine texture function is only used when the mode is cl_unitmode_combine.&lt;/p&gt;
+	int get_combine_alpha_mode_gl() const;
+
+	//: Returns the color source for the RGB combine function's specified argument.
+	CL_TextureUnitSource get_combine_arg_src_rgb(int arg) const;
+
+	//: Returns the color source for the RGB combine function's specified argument as OpenGL constant.
+	int get_combine_arg_src_rgb_gl(int arg) const;
+
+	//: Returns the operand for the RGB combine function's specified argument.
+	CL_TextureUnitRGBOperand get_combine_arg_operand_rgb(int arg) const;
+
+	//: Returns the operand for the alpha combine function's specified argument as OpenGL constant.
+	int get_combine_arg_operand_rgb_gl(int arg) const;
+
+	//: Returns the alpha source for the alpha combine function's specified argument.
+	CL_TextureUnitSource get_combine_arg_src_alpha(int arg) const;
+
+	//: Returns the alpha source for the alpha combine function's specified argument as OpenGL constant.
+	int get_combine_arg_src_alpha_gl(int arg) const;
+
+	//: Returns the operand for the alpha combine function's specified argument.
+	CL_TextureUnitAlphaOperand get_combine_arg_operand_alpha(int arg) const;
+
+	//: Returns the operand for the alpha combine function's specified argument as OpenGL constant.
+	int get_combine_arg_operand_alpha_gl(int arg) const;
+
+//! Operations:
+public:
+	//: Sets the texture level of detail bias for texture unit.
+	void set_lod_bias(float bias);
+
+	//: Sets the constant color for texture unit.
+	void set_color(const CL_Color &amp;color);
+
+	void set_color(float red, float green, float blue, float alpha);
+
+	void set_color(float color[4]);
+
+	//: Sets the texture function for texture unit.
+	void set_mode(CL_TextureUnitMode mode);
+
+	//: Sets the texture function for texture unit with an OpenGL constant.
+	void set_mode_gl(int mode);
+
+	//: Sets the RGB and alpha combine texture functions.
+	//- &lt;p&gt;The combine texture functions are only used when the mode is cl_unitmode_combine.&lt;/p&gt;
+	void set_combine_mode(CL_TextureUnitRGBMode rgb_mode, CL_TextureUnitAlphaMode alpha_mode);
+
+	//: Sets the RGB and alpha combine texture functions with an OpenGL constant.
+	//- &lt;p&gt;The combine texture functions are only used when the mode is cl_unitmode_combine.&lt;/p&gt;
+	void set_combine_mode_gl(int rgb_mode, int alpha_mode);
+
+	//: Sets an arguement for the RGB and alpha combine texture functions.
+	void set_combine_arg(
+		int arg,
+		CL_TextureUnitSource src_rgb,
+		CL_TextureUnitRGBOperand operand_rgb,
+		CL_TextureUnitSource src_alpha,
+		CL_TextureUnitAlphaOperand operand_alpha);
+
+	//: Sets an arguement for the RGB and alpha combine texture functions using OpenGL constants.
+	void set_combine_arg_gl(
+		int arg,
+		int src_rgb,
+		int operand_rgb,
+		int src_alpha,
+		int operand_alpha);
+
+	//: Sets an arguement for the RGB combine texture function.
+	void set_combine_rgb_arg(int arg, CL_TextureUnitSource src_rgb, CL_TextureUnitRGBOperand operand_rgb);
+
+	//: Sets an arguement for the RGB combine texture function with an OpenGL constant.
+	void set_combine_rgb_arg_gl(int arg, int src_rgb, int operand_rgb);
+
+	//: Sets an arguement for the alpha combine texture function.
+	void set_combine_alpha_arg(int arg, CL_TextureUnitSource src_alpha, CL_TextureUnitAlphaOperand operand_alpha);
+
+	//: Sets an arguement for the alpha combine texture function with an OpenGL constant.
+	void set_combine_alpha_arg_gl(int arg, int src_alpha, int operand_alpha);
+
+	//: Send the texture unit configuration to OpenGL.
+	void setup_unit(int unit);
+
+//! Implementation:
+private:
+	CL_SharedPtr&lt;CL_TextureUnit_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/GL/viewpoint.h
===================================================================
--- trunk/clanlib/API/GL/viewpoint.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GL/viewpoint.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,128 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGL=&quot;Display 3D&quot;
+//! header=gl.h
+
+#ifndef header_viewpoint
+#define header_viewpoint
+
+#ifdef CL_API_DLL
+#ifdef CL_GL_EXPORT
+#define CL_API_GL __declspec(dllexport)
+#else
+#define CL_API_GL __declspec(dllimport)
+#endif
+#else
+#define CL_API_GL
+#endif
+
+#include &quot;../Core/Math/cl_vector.h&quot;
+
+//: CL_Viewpoint object.
+//- !group=GL/Display 3D!
+//- !header=gl.h!
+//- &lt;p&gt;A viewpoint represents a position and viewing direction in 3D.&lt;/p&gt;
+class CL_API_GL CL_Viewpoint
+{
+//! Construction:
+public:
+	//: Constructs a viewpoint.
+	//param pos: Position of viewpoint.
+	//param dir: Viewing direction of viewpoint.
+	//param up: Up direction of viewpoint.
+	CL_Viewpoint();
+
+	CL_Viewpoint(
+		const CL_Vector &amp;pos,
+		const CL_Vector &amp;dir,
+		const CL_Vector &amp;up);
+
+//! Attributes:
+public:
+	//: Position of viewpoint.
+	CL_Vector pos;
+	
+	//: Viewing direction of viewpoint.
+	CL_Vector dir;
+
+	//: Up direction of viewpoint.
+	CL_Vector up;
+
+//! Operations:
+public:
+	//: Translates viewpoint position.
+	void translate(float mov_x, float mov_y, float mov_z);
+
+	//: Sets the viewpoint position.
+	void set(float pos_x, float pos_y, float pos_z);
+
+	//: Moves the viewpoint from its local point of view.
+	//- &lt;p&gt;Moving in local coordinates means that it is moved according to its
+	//- current viewing direction, where the z axis is in the facing direction,
+	//- and the y axis is in the up direction.&lt;/p&gt;
+	void translate_local(float mov_x, float mov_y, float mov_z);
+
+	//: Rotates the viewpoint from its local point view.
+	//- &lt;p&gt;Rotating in local coordinates means that it is rotated according to its
+	//- current viewing direction, where the z axis is in the facing direction,
+	//- and the y axis is in the up direction.&lt;/p&gt;
+	void rotate_local(double angle, double rot_x, double rot_y, double rot_z);
+
+	//: Setup OpenGL model view matrix to use local viewpoint coordinates.
+	//- &lt;p&gt;Calling this function causes CL_Viewpoint to do the following:&lt;/p&gt;
+	//- &lt;ul&gt;
+	//- &lt;li&gt;glMatrixMode(GL_MODELVIEW)&lt;/li&gt;
+	//- &lt;li&gt;glPushMatrix()&lt;/li&gt;
+	//- &lt;li&gt;glMultMatrix(world2local_transform)&lt;/li&gt;
+	//- &lt;/ul&gt;
+	//- &lt;p&gt;world2local_transform is a coordinate switch matrix, that convert local
+	//- coordinates for a model to be positioned in the world at the viewpoint's
+	//- position and viewing direction.&lt;/p&gt;
+	//- &lt;p&gt;It is required that leave_local() is to be called, when the local
+	//- coordinate space model view is no longer needed.&lt;/p&gt;
+	void enter_local() const;
+
+	//: Restores the OpenGL model view matrix prior to a call to enter_local().
+	void leave_local() const;
+
+	//: Converts a direction vector from world into local coordinates.
+	CL_Vector make_local_direction(const CL_Vector &amp;v) const;
+
+	//: Sets up the model view matrix to look from this viewpoint.
+	//- &lt;p&gt;Calling this function causes CL_Viewpoint to do the following:&lt;/p&gt;
+	//- &lt;ul&gt;
+	//- &lt;li&gt;glMatrixMode(GL_MODELVIEW)&lt;/li&gt;
+	//- &lt;li&gt;glLoadIdentity()&lt;/li&gt;
+	//- &lt;li&gt;gluLookAt(pos, pos+dir, up)&lt;/li&gt;
+	//- &lt;/ul&gt;
+	void setup_modelview() const;
+};
+
+#endif

Added: trunk/clanlib/API/GUI/button.h
===================================================================
--- trunk/clanlib/API/GUI/button.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/button.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,157 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Controls&quot;
+//! header=gui.h
+
+#ifndef header_button
+#define header_button
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;component.h&quot;
+
+class CL_Surface;
+class CL_Button_Generic;
+
+//: Button component
+//- !group=GUI/Controls!
+//- !header=gui.h!
+class CL_API_GUI CL_Button : public CL_Component
+{
+//! Construction:
+public:
+	//: Button Constructor
+	CL_Button(
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: Button Constructor
+	CL_Button(
+		const std::string &amp;text,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: Button Constructor
+	CL_Button(
+		const CL_Point &amp;pos,
+		const std::string &amp;text,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: Button Constructor
+	CL_Button(
+		const CL_Rect &amp;pos,
+		const std::string &amp;text,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: Button Constructor
+	CL_Button(
+		const CL_Rect &amp;pos,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: Button Constructor
+	CL_Button(
+		const CL_Point &amp;pos,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: Button Destructor
+	virtual ~CL_Button();
+
+//! Attributes:
+public:
+	//: Returns the button text.
+	const std::string &amp;get_text() const;
+
+	//: Returns true if the button is a toggle button.
+	bool is_toggle_button() const;
+
+	//: Returns true if the button state is down, or false if it is raised.
+	bool is_down() const;
+
+	//: Returns true if the button is visually pressed down, or false if it is raised.
+	//: This can be used by theme, to get immediate state of the button.
+	bool is_drawn_down() const;
+
+//! Operations:
+public:
+	//: Sets the button text.
+	void set_text(const std::string &amp;text);
+
+	//: If toggle is true, pressing the button toggles it between an On and and Off state. 
+	//: If toggle is false, pressing the button causes an action, then the button returns to the unpressed state. 
+	void set_toggle_mode(bool toggle = true);
+
+	//: Sets the state of the button to pressed down if enable is true or to standing up if enable is false. 
+	//: No signals are not emitted by this function. 
+	void set_down(bool enable = true);
+
+	//: Toggle the button.
+	//: The toggled() signal are emitted by this function.
+	void toggle();
+
+//! Signals:
+public:
+	//: This signal is emitted whenever a toggle button changes status.
+	//param bool on: Is true if the button is on, or false otherwise.
+	CL_Signal_v1&lt;bool&gt; &amp;sig_toggled();
+
+	//: This signal is emitted when the button is activated (i.e. first pressed down and then released when the mouse cursor is inside the button).
+	CL_Signal_v0 &amp;sig_clicked();
+	
+	//: This signal is emitted when the button is pressed down. 
+	//: In most cases, you want to use sig_clicked() instead.
+	CL_Signal_v0 &amp;sig_pressed();
+
+	//: This signal is emitted when the button is released.
+	//: In most cases, you want to use sig_clicked() instead.
+	CL_Signal_v0 &amp;sig_released();
+
+//! Implementation:
+private:
+	CL_Button(const CL_Button &amp;copy) : CL_Component(NULL, NULL) { return; } // disallow copy construction.
+	CL_Button_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/GUI/checkbox.h
===================================================================
--- trunk/clanlib/API/GUI/checkbox.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/checkbox.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,95 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Controls&quot;
+//! header=gui.h
+
+#ifndef header_checkbox
+#define header_checkbox
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;button.h&quot;
+
+//: CheckBox component
+//- !group=GUI/Controls!
+//- !header=gui.h!
+class CL_API_GUI CL_CheckBox : public CL_Button
+{
+//! Construction:
+public:
+	//: CheckBox constructor
+	CL_CheckBox(
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: CheckBox constructor
+	CL_CheckBox(
+		const CL_Point &amp;pos,
+		const std::string &amp;text,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: CheckBox constructor
+	CL_CheckBox(
+		const std::string &amp;text,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: CheckBox destructor
+	virtual ~CL_CheckBox();
+
+//! Attributes:
+public:
+	//: Returns true if the checkbox is checked, or false if it is not checked.
+	bool is_checked() const;
+
+//! Operations:
+public:
+	//: Checks the checkbox if check is true, or unchecks it if check is false. 
+	void set_checked(bool check = true);
+
+//! Implementation:
+private:
+	CL_CheckBox(const CL_CheckBox &amp;copy) : CL_Button(NULL, NULL) { return; } // disallow copy construction.
+};  
+
+#endif

Added: trunk/clanlib/API/GUI/component.h
===================================================================
--- trunk/clanlib/API/GUI/component.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/component.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,465 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Framework&quot;
+//! header=gui.h
+
+#ifndef header_component
+#define header_component
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+
+#include &quot;../signals.h&quot;
+#include &quot;../Core/Math/rect.h&quot;
+#include &quot;../Core/Math/point.h&quot;
+#include &quot;../Display/input_event.h&quot;
+#include &quot;component_style.h&quot;
+
+//: Layout policies for CL_Component.
+//- !group=GUI/Framework!
+//- !header=gui.h!
+enum CL_LayoutPolicy
+{
+	layout_minimum,
+	layout_expanding
+};
+
+class CL_GUIManager;
+class CL_InputDevice;
+class CL_StyleManager;
+class CL_ComponentStyle;
+class CL_DomElement;
+class CL_Component_Generic;
+class CL_ComponentManager;
+class CL_Layout;
+
+//: Component base class.
+//- !group=GUI/Framework!
+//- !header=gui.h!
+//- &lt;p&gt;The component class is the base class for any component/widget/control (or
+//- whatever you call it :)) in the GUI system. It is responsible for painting
+//- the component, painting of any child components of it, and it receives the
+//- input for a component.&lt;/p&gt;
+class CL_API_GUI CL_Component
+{
+//! Construction:
+public:
+	//: Component Constructor
+	CL_Component(
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: Component Constructor
+	CL_Component(
+		const CL_Rect &amp;pos,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: Component Destructor
+	virtual ~CL_Component();
+
+//! Attributes:
+public:
+	//: Returns the client area of the component.
+	CL_Component *get_client_area() const;
+
+	//: Returns the parent component, or NULL if none.
+	CL_Component *get_parent() const;
+
+	//: Returns the root parent.
+	CL_Component *get_root_parent();
+
+	//: Returns the GUI manager that this component is attached to, or NULL if none.
+	CL_GUIManager *get_gui_manager() const;
+
+	//: Returns the style manager used by this component.
+	CL_StyleManager *get_style_manager() const;
+
+	//: Returns the width of the component.
+	int get_width() const;
+
+	//: Returns the height of the component.
+	int get_height() const;
+
+	//: Returns the components x position in screen coordinates.
+	int get_screen_x() const;
+
+	//: Returns the components y position in screen coordinates.
+	int get_screen_y() const;
+
+	//: Returns the components x position in client coordinates.
+	int get_client_x() const;
+
+	//: Returns the components y position in client coordinates.
+	int get_client_y() const;
+
+	//: Returns the components position in screen coordinates.
+	CL_Rect get_screen_rect() const;
+
+	//: Returns the rect with coordinates converted from client to screen
+	CL_Rect client_to_screen(const CL_Rect &amp; rect);
+
+	//: Returns the point with coordinates converted from client to screen
+	CL_Point client_to_screen(const CL_Point &amp; point);
+
+	//: Returns the rect with coordinates converted from screen to client
+	CL_Rect screen_to_client(const CL_Rect &amp; rect);
+
+	//: Returns the point with coordinates converted from screen to client
+	CL_Point screen_to_client(const CL_Point &amp; point);
+
+	//: Returns the position of this component.
+	const CL_Rect &amp;get_position() const;
+
+	//: Returns the position of this component after extending the rect to fit all children as well
+	CL_Rect get_position_with_children();
+
+	//: Get the minimum size of the component.
+	CL_Size get_minimum_size() const;
+
+	//: Get the maximum size of the component.
+	CL_Size get_maximum_size() const;
+
+	//: Get the preferred size of the component.
+	CL_Size get_preferred_size() const;
+
+	//: Returns the vertical size policy of the component.
+	const CL_LayoutPolicy &amp;get_vertical_policy() const;
+
+	//: Returns the horizontal size policy of the component.
+	const CL_LayoutPolicy &amp;get_horizontal_policy() const;
+
+	//: returns the layout for this component.
+	const CL_Layout &amp;get_layout() const;
+
+	//: Returns true if event passing is enabled.
+	bool get_event_passing() const;
+
+	//: Returns true if the passed component is a child of this component.
+	bool has_child(CL_Component *component) const;
+
+	//: Returns the list of child components.
+	const std::list&lt;CL_Component *&gt; &amp;get_children() const;
+
+	//: Returns the bounding rectangle of the component's children.
+	CL_Rect get_children_rect() const;
+
+	//: Returns the component at (pos_x, pos_y).
+	//- &lt;p&gt;This functions searches for children recursively.
+	//- NULL is returned if the point is outside the component.
+	//- The component itself is returned if the component has no child at the specified point.&lt;/p&gt;
+	CL_Component *get_component_at(int pos_x, int pos_y);
+
+	//: Returns the component that currently has the focus.
+	CL_Component *get_focus() const;
+
+	//: Returns true if component has the focus.
+	bool has_focus() const;
+
+	//: Returns true if the component can be focused.
+	bool is_focusable() const;
+	
+	//: Returns true if the mouse is currently highlighting the component.
+	bool has_mouse_over() const;
+
+	//: Returns true if component is visible.
+	//- &lt;p&gt;Is check_parents is true, it will check the state of the parents, and only return true
+	//- if all parents are visible.&lt;/p&gt;
+	bool is_visible(bool check_parents = true) const;
+
+	//: Returns true if component accepts user input.
+	//- &lt;p&gt;Is check_parents is true, it will check the state of the parents, and only return true
+	//- if all parents are enabled.&lt;/p&gt;
+	bool is_enabled(bool check_parents = true) const;
+
+	//: Returns true if component has mouse captured.
+	bool is_mouse_captured() const;
+
+	//: Returns the tab id of the component.
+	int get_tab_id() const;
+
+	//: Returns the component style.
+	CL_ComponentStyle *get_style() const;
+
+	//: Returns true if component is in modal state.
+	bool is_modal() const;
+	
+	//: Returns true if component have parents which on top of gui_manager modal stack.
+	//- &lt;p&gt;Note, only &quot;top&quot; of modal stack.&lt;/p&gt;
+	bool has_modal_parent() const;
+
+	//: Returns true if the topmost flag is set.
+	bool is_topmost() const;
+
+//! Operations:
+public:
+	//: Set the tab id of the component.
+	void set_tab_id(int id);
+
+	//: Sets the position (relative to its parent) and size of this component.
+	void set_position(const CL_Rect &amp;new_pos);
+
+	//: Sets the position of this component (relative to its parent).
+	void set_position(int new_x, int new_y);
+
+	//: Sets the size of this component.
+	void set_size(int new_width, int new_height);
+
+	//: Changes the width of the component.
+	void set_width(int width);
+
+	//: Changes the height of the component.
+	void set_height(int height);
+
+	//: Set the minimum size of the component.
+	void set_minimum_size(const CL_Size &amp;size);
+
+	//: Set the maximum size of the component.
+	void set_maximum_size(const CL_Size &amp;size);
+
+	//: Set the preferred size of the component.
+	void set_preferred_size(const CL_Size &amp;size);
+
+	//: Set the vertical size policy of the component.
+	void set_vertical_policy(const CL_LayoutPolicy &amp;policy);
+
+	//: Set the horizontal size policy of the component.
+	void set_horizontal_policy(const CL_LayoutPolicy &amp;policy);
+
+	//: Set the layout for this component.
+	void set_layout(const CL_Layout &amp;layout);
+
+	//: Enables/disables the event passing to parent.
+	void set_event_passing(bool enable = true);
+
+	//: Sets the parent of this component.
+	void set_parent(CL_Component *parent);
+
+	//: Sets the GUI manager this component is attached to.
+	void set_gui_manager(CL_GUIManager *gui);
+
+	//: Changes the visibility flag.
+	void show(bool show = true);
+
+	//: Enable/disable user input.
+	void enable(bool enable = true);
+
+	//: Enable/disable the ability to focus component.
+	void set_focusable(bool focusable = true);
+	
+	//: Give focus to this component.
+	void set_focus();
+
+	//: Raises this component to the top of the parent component's stack. 
+	//- &lt;p&gt;If the topmost flag is set, it will get draw before any other components. If the flag
+	//- is not set, it will be draw before any other components that do not have the topmost flag
+	//- set.&lt;/p&gt;
+	void raise();
+
+	//: Lowers this component to the bottom of the parent component's stack.
+	//- &lt;p&gt;If the topmost flag is set, it will get draw after any other components with the topmost
+	//- flag set, but before any components with the flag cleared.&lt;/p&gt;
+	void lower();
+
+	//: Capture the mouse on the currently attached GUI manager. All mouse input
+	//: will be directed to this component until release_mouse() is called.
+	void capture_mouse();
+
+	//: Releases the mouse capture.
+	void release_mouse();
+
+	//: Asks the GUI to repaint itself.
+	//- &lt;p&gt;This function doesn't redraw the GUI immidiately. Instead it raises the 
+	//- update event trigger in the CL_GUIManager parent.&lt;/p&gt;
+	void update();
+
+	//: Calls sig_begin_paint(), then sig_paint(), and finally sig_end_paint().
+	void paint();
+
+	//: Run the component as a modal component until quit() is called.
+	void run();
+
+	//: Quit the modal loop of the component.
+	void quit();
+
+	//: &quot;Closes&quot; this component.
+	//: Hides and detaches component from parent.
+	void close();
+
+	//: Adds the specified component as a children to this component.
+	//- &lt;p&gt;If 'delete_child' is true, the child will be deleted when the component is deleted.&lt;/p&gt;
+	void add_child(CL_Component *child, bool delete_child = false);
+
+	//: Removes the specified child from the component.
+	void remove_child(CL_Component *child);
+
+	//: Sets a component style to the component.
+	//- &lt;p&gt;If 'delete_style' is true, the style will be deleted when the component is deleted.&lt;/p&gt;
+	void set_style(CL_ComponentStyle *style, bool delete_style = true);
+
+	//: Calculate a default size.
+	void find_preferred_size();
+
+	//: Returns the component with the specified tab ID.
+	CL_Component *find_tab_id(int tab_id);
+
+	//: Set the client area of the component. Not used by user - only by other components.
+	void set_client_area(CL_Component *component);
+
+	//: Sets or clears the topmost flag.
+	//- &lt;p&gt;Components with the topmost flag set are shown above components with it cleared.&lt;/p&gt;
+	void set_topmost_flag(bool topmost);
+
+	//: Enables automatic clipping when drawing component.
+	void set_clipping(bool enable);
+
+//! Signals:
+public:
+	//: Update component with a new set of component options.
+	CL_Signal_v1&lt;const CL_DomElement &amp;&gt; &amp;sig_set_options();
+
+	//: Draws the component. Must be called in a
+	//: begin_paint() / end_paint() session.
+	CL_Signal_v0 &amp;sig_paint();
+
+	//: Called prior to component drawing. Sets up a cliprect and translocates
+	//: coordinates accordingly to this component.
+	CL_Signal_v0 &amp;sig_begin_paint();
+
+	//: Called after component drawing, and draws all the children.
+	CL_Signal_v0 &amp;sig_paint_children();
+
+	//: Cleans up when component drawing is finished (cleans up cliprects and
+	//: translocation stuff).
+	CL_Signal_v0 &amp;sig_end_paint();
+
+	//: Called when any inputdevice button is pressed (keyboard, mouse, joystick, etc).
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;sig_input_down();
+
+	//: Called when any inputdevice button is released (keyboard, mouse, joystick, etc)
+	CL_Signal_v1&lt; const CL_InputEvent &amp;&gt; &amp;sig_input_up();
+
+	//: Called when a key is pressed on keyboard.
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;sig_key_down();
+
+	//: Called when a key is released on keyboard.
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;sig_key_up();
+
+	//: Called when a mousebutton is clicked.
+	//: The CL_InputEvent contains the coordinates and which button was pressed
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;sig_mouse_down();
+
+	//: Called when a mousebutton is released.
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;sig_mouse_up();
+
+	//: Called when a mousebutton is doubleclicked.
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;sig_mouse_dblclk();
+
+	//: Called when the mouse is moved.
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;sig_mouse_move();
+
+	//: Called when mouse enters the component area.
+	CL_Signal_v0 &amp;sig_mouse_enter();
+
+	//: Called when mouse leaves the component area.
+	CL_Signal_v0 &amp;sig_mouse_leave();
+
+	//: Called when component gains focus.
+	CL_Signal_v0 &amp;sig_got_focus();
+
+	//: Called when component lose focus.
+	CL_Signal_v0 &amp;sig_lost_focus();
+
+	//: Called when component is closed.
+	CL_Signal_v0 &amp;sig_close();
+	
+	//: Called when component is resized.
+	//: The two parameters are the OLD width and height of the component.
+	CL_Signal_v2&lt;int, int&gt; &amp;sig_resize();
+
+	//: Called when component is moved.
+	//: The two parameters are the OLD positions of the component.
+	CL_Signal_v2&lt;int, int&gt; &amp;sig_move();
+
+	//: Called when a child component is about to be added to the component.
+	CL_Signal_v1&lt;CL_Component *&gt; &amp;sig_child_before_add();
+
+	//: Called when a child component is added to the component.
+	CL_Signal_v1&lt;CL_Component *&gt; &amp;sig_child_add();
+
+	//: Called when a child component is about to be removed from the component.
+	CL_Signal_v1&lt;CL_Component *&gt; &amp;sig_child_before_remove();
+	
+	//: Called when a child component is removed from the component.
+	CL_Signal_v1&lt;CL_Component *&gt; &amp;sig_child_remove();
+
+	//: Called when needing to convert parent coordinates into coordinates used by this component.
+	//- &lt;p&gt;This is used in 3D guis to convert from screen coordinates to gui coordinates.
+	//- (project the screen cordinates down on the plane that the gui is laying on)&lt;/p&gt;
+	CL_Signal_v2&lt;int &amp;, int &amp;&gt; &amp;sig_transform_coords();
+	
+	//: Called when needing to find the minimum size of the component.
+	//: Normally used by the styles.
+	CL_Signal_v1&lt;CL_Size &amp;&gt; &amp;sig_get_minimum_size();
+
+	//: Called when needing to find the maximum size of the component.
+	//: Normally used by the styles.
+	CL_Signal_v1&lt;CL_Size &amp;&gt; &amp;sig_get_maximum_size();
+
+	//: Called when needing to find the preferred size of the component.
+	//: Normally used by the styles.
+	CL_Signal_v1&lt;CL_Size &amp;&gt; &amp;sig_get_preferred_size();
+
+private:
+	void delete_child (CL_Component *child);
+
+//! Implementation:
+protected:
+	CL_Component_Generic *impl;
+
+	friend class CL_Component_Generic;
+	friend class CL_GUIManager_Generic;
+	friend class CL_ComponentManager_Generic;
+};
+
+#endif

Added: trunk/clanlib/API/GUI/component_manager.h
===================================================================
--- trunk/clanlib/API/GUI/component_manager.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/component_manager.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,139 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Framework&quot;
+//! header=gui.h
+
+#ifndef header_component_manager
+#define header_component_manager
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;component.h&quot;
+#include &quot;component_type.h&quot;
+#include &quot;../Core/System/error.h&quot;
+#include &quot;../Core/System/sharedptr.h&quot;
+
+#include &lt;string&gt;
+#include &lt;map&gt;
+
+class CL_StyleManager;
+class CL_ResourceManager;
+class CL_InputSourceProvider;
+class CL_DomDocument;
+class CL_DomElement;
+class CL_ComponentType;
+class CL_ComponentManager_Generic;
+
+//: Manages components loaded from a gui definition file.
+//- !group=GUI/Framework!
+//- !header=gui.h!
+//- &lt;p&gt;The component manager is responsible for loading a set of components from a gui definition
+//- file (for an example of such a file, have a look at the login_view in the CTalk example).
+//- After a successful construction of a component manager, it is possible get pointers to
+//- components defined in the definition file, thus making it easy to seperate component layout
+//- from the user interface logic.&lt;/p&gt;
+class CL_API_GUI CL_ComponentManager
+{
+//! Construction:
+public:
+	//: Constructs a component manager.
+	//param resource_id: Resource identifier used to load gui definition.
+	//param res_manager: Resource manager for the resource identifier.
+	//param style: Style manager to create components with. If set to null it will use the style from the parent component.
+	//param parent: Parent component of top components in gui definition.
+	//param filename: File to load gui definition from.
+	//param input_provider: Input source provider to use. If set to null it will use the default file provider.
+	//param delete_provider: If true the input source provider will be deleted after use.
+	//param document: XML Document to load components from.
+	//param element: Element to use as the top level components element.
+	//- &lt;p&gt;If no resource manager or style is specified, it inherits style manager and
+	//- resources from parent component.&lt;/p&gt;
+	CL_ComponentManager(
+		const std::string &amp;resource_id,
+		CL_ResourceManager *res_manager,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	CL_ComponentManager(
+		const std::string &amp;filename,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL,
+		CL_InputSourceProvider *input_provider = NULL,
+		bool delete_provider = false);
+
+	CL_ComponentManager(
+		const CL_DomDocument &amp;document,
+		const CL_DomElement &amp;element,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL); 
+
+	CL_ComponentManager(const CL_ComponentManager &amp;copy);
+	
+	//: Component manager destructor.
+	virtual ~CL_ComponentManager();
+
+//! Attributes:
+public:
+	//: Returns the component identified by the specified name in the gui definition file.
+	//- &lt;p&gt;If the component is not found, a CL_Error exception is thrown.&lt;/p&gt;
+	CL_Component *get_component(const std::string &amp;name) const;
+
+	//: Get component identifed by the specified name in the gui definition file.
+	//- &lt;p&gt;If the component is not of the correct type, a CL_Error exception is thrown.&lt;/p&gt;
+	template&lt;class Comp&gt;
+	void get_component(const std::string &amp;name, Comp **component) const
+	{
+		*component = dynamic_cast&lt;Comp*&gt;(get_component(name.c_str()));
+		if (*component == 0) cl_throw_error(&quot;Wrong component type!&quot;);
+	}
+
+	CL_StyleManager *get_style_manager() const;
+
+//! Operations:
+public:
+
+//! Implementation:
+private:
+	CL_SharedPtr&lt;CL_ComponentManager_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/GUI/component_move_handler.h
===================================================================
--- trunk/clanlib/API/GUI/component_move_handler.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/component_move_handler.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,76 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Framework&quot;
+//! header=gui.h
+
+#ifndef header_component_move_handler
+#define header_component_move_handler
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;component.h&quot;
+
+class CL_Rect;
+class CL_ComponentMoveHandler_Generic;
+
+//: Component Move Handler Class
+//- !group=GUI/Framework!
+//- !header=gui.h!
+class CL_API_GUI CL_ComponentMoveHandler : public CL_Component
+{
+//! Construction:
+public:
+	//: Constructor
+	CL_ComponentMoveHandler(CL_Component *owner);
+
+	//: Constructor
+	CL_ComponentMoveHandler(const CL_Rect &amp;move_area, CL_Component *owner);
+
+	//: Destructor
+	virtual ~CL_ComponentMoveHandler();
+
+//! Implementation:
+private:
+	CL_ComponentMoveHandler_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/GUI/component_resize_handler.h
===================================================================
--- trunk/clanlib/API/GUI/component_resize_handler.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/component_resize_handler.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,76 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Framework&quot;
+//! header=gui.h
+
+#ifndef header_component_resize_handler
+#define header_component_resize_handler
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;component.h&quot;
+
+class CL_Rect;
+class CL_ComponentResizeHandler_Generic;
+
+//: Component Resize Handler
+//- !group=GUI/Framework!
+//- !header=gui.h!
+class CL_API_GUI CL_ComponentResizeHandler : public CL_Component
+{
+//! Construction:
+public:
+	//: Constructor
+	CL_ComponentResizeHandler(CL_Component *owner);
+
+	//: Constructor
+	CL_ComponentResizeHandler(const CL_Rect &amp;resize_area, CL_Component *owner);
+
+	//: Destructor
+	virtual ~CL_ComponentResizeHandler();
+
+//! Implementation:
+private:
+	CL_ComponentResizeHandler_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/GUI/component_style.h
===================================================================
--- trunk/clanlib/API/GUI/component_style.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/component_style.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,79 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Framework&quot;
+//! header=gui.h
+
+#ifndef header_component_style
+#define header_component_style
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+class CL_Component;
+
+//: Component Style interface.
+//- !group=GUI/Framework!
+//- !header=gui.h!
+//- &lt;p&gt;The component style class is part of the style customization system of the
+//- GUI. Each 'style' for a component is implemented by inheriating
+//- CL_ComponentStyle and then attaching it to the component it is responsible
+//- of visualizing.&lt;/p&gt;
+//- &lt;p&gt;When a component is constructed, it will contact its CL_StyleManager and
+//- ask it to attach the component styles for its style to the component.
+//- The general principle in the component style system is that a inheriated
+//- CL_ComponentStyle object will hook itself into signals in the component it
+//- is visualizing, thus keeping a kind of document/view relationship with its
+//- component.&lt;/p&gt;
+//- &lt;p&gt;For source examples of how this is done, have a look at the GUIGL example.&lt;/p&gt;
+class CL_ComponentStyle
+{
+//! Construction:
+public:
+	//: Construct a component style.
+	CL_ComponentStyle(CL_Component *component) : comp(component) { return; }
+
+	//: Destructor.
+	virtual ~CL_ComponentStyle() { return; }
+
+//! Attributes:
+public:
+	//: Returns the component that is being styled.
+	CL_Component *get_component() { return comp; }
+
+	//: Returns the component that is being styled.
+	const CL_Component *get_component() const { return comp; }
+
+//! Implementation:
+private:
+	CL_Component *comp;
+};
+
+#endif

Added: trunk/clanlib/API/GUI/component_type.h
===================================================================
--- trunk/clanlib/API/GUI/component_type.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/component_type.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,138 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Framework&quot;
+//! header=gui.h
+
+#ifndef header_component_type
+#define header_component_type
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Core/System/clanstring.h&quot;
+#include &lt;set&gt;
+#include &lt;string&gt;
+#include &lt;map&gt;
+
+class CL_Component;
+class CL_StyleManager;
+class CL_ComponentType_Generic;
+
+//: Component Type.
+//- !group=GUI/Framework!
+//- !header=gui.h!
+class CL_API_GUI CL_ComponentType
+{
+//! Construction:
+public:
+	//: Component Type Constructor
+	CL_ComponentType();
+
+	//: Component Type Destructor
+	virtual ~CL_ComponentType();
+
+//! Enums:
+public:
+	enum EDatatype
+	{
+		STRING,
+		BOOL,
+		NUMBER
+	};
+
+//! Attributes:
+public:
+	struct SOptionType
+	{
+		EDatatype type;
+
+		std::string default_value;
+	};
+
+	//: List of known component types.
+	static std::map&lt;std::string, CL_ComponentType *&gt; component_types;
+
+	//: Options for component type.
+	const std::map&lt;std::string, SOptionType&gt; &amp;get_options() const;
+
+	//: Has option
+	bool has_option(const std::string &amp;option_name) const;
+
+	EDatatype get_data_type(const std::string &amp;option_name) const;
+
+	std::string get_default_value(const std::string &amp;option_name) const;
+
+	const std::string &amp;get_class_name() const;
+
+	static EDatatype get_data_type(const std::string &amp;type, const std::string &amp;option_name);
+
+	static std::string get_default_value(const std::string &amp;type, const std::string &amp;option_name);
+
+	static const std::string &amp;get_class_name(const std::string &amp;type);
+
+//! Operations:
+public:
+	//: Sets an option's datatype and default value.
+	void set_option(const std::string &amp;name, EDatatype datatype, const std::string &amp;value);
+
+	//: Sets the class name (ie &quot;CL_Button&quot;) of a component type.
+	void set_class_name(const std::string &amp;class_name);
+
+	//: Creates a component of type 'component_type_name'.
+	//- &lt;p&gt;If no such component type exists, a CL_Error is thrown. The method
+	//- invokes the specific component type's
+	//- virtual 'create_component' method with the passed arguments.&lt;/p&gt;
+	static CL_Component *create_component(
+		const std::string &amp;type,
+		CL_Component *parent,
+		CL_StyleManager *style);
+
+	//: Create component.
+	virtual CL_Component *create_component(
+		CL_Component *parent,
+		CL_StyleManager *style) = 0;
+
+// !Implementation:
+private:
+	CL_ComponentType_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/GUI/deck.h
===================================================================
--- trunk/clanlib/API/GUI/deck.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/deck.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,103 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Framework&quot;
+//! header=gui.h
+
+#ifndef header_deck
+#define header_deck
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;component.h&quot;
+#include &lt;map&gt;
+
+class CL_Deck_Generic;
+
+//: Deck
+//- !group=GUI/Framework!
+//- !header=gui.h!
+//- &lt;p&gt;Deck is a component manager that acts like a tab system.
+//- It is used to group a list of components and show only one at a time.&lt;/p&gt;
+class CL_API_GUI CL_Deck
+{
+//! Construction:
+public:
+	//: Deck Constructor
+	CL_Deck();
+
+	//: Deck Destructor
+	~CL_Deck();
+
+//! Attributes:
+public:
+	//: Returns the component identified by the specified name.
+	//- &lt;p&gt;If the component is not found, a CL_Error exception is thrown.&lt;/p&gt;
+	CL_Component *get_component(const std::string &amp;name);
+
+	//: Returns the current visible component.
+	//- &lt;p&gt;If no component has yet been added, NULL will be returned.&lt;/p&gt;
+	CL_Component *get_visible();
+
+	//: Returns the stored component map.
+	std::map&lt;std::string, CL_Component *&gt; &amp;get_map();
+
+//! Operations:
+public:
+	//: Add a component.
+	//- &lt;p&gt;If the component name exist, the previous added component will be replaced.&lt;/p&gt;
+	void add(const std::string &amp;name, CL_Component *component);
+
+	//: Swap visible component.
+	//- &lt;p&gt;If the component is not found, a CL_Error exception is thrown.&lt;/p&gt;
+	void swap(const std::string &amp;name);
+
+	//: Remove a component.
+	//- &lt;p&gt;If the component is not found, a CL_Error exception is thrown.&lt;/p&gt;
+	void remove(const std::string &amp;name);
+
+//! Implementation:
+private:
+	CL_Deck_Generic *impl;
+
+};
+
+#endif

Added: trunk/clanlib/API/GUI/filedialog.h
===================================================================
--- trunk/clanlib/API/GUI/filedialog.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/filedialog.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,176 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Controls&quot;
+//! header=gui.h
+
+#ifndef header_file_dialog
+#define header_file_dialog
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;window.h&quot;
+
+class CL_FileDialog_Generic;
+
+//: File dialog component
+//- !group=GUI/Controls!
+//- !header=gui.h!
+class CL_API_GUI CL_FileDialog : public CL_Window
+{
+public:
+	//: Behavior of dialog
+	enum Behavior
+	{
+		quit_always = 1,
+		quit_file_selected = 2
+	};
+	//: Button pressed
+	enum ButtonPressed
+	{
+		button_none = 0,
+		button_ok = 1,
+		button_cancel = 2
+	}; 
+//! Construction:
+public:
+	//: File dialog constructor
+	CL_FileDialog(
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: File dialog constructor
+	CL_FileDialog(
+		const std::string &amp;title,
+		const std::string &amp;file,
+		const std::string &amp;filter,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: File dialog destructor
+	virtual ~CL_FileDialog();
+
+	//: Open
+	static const std::string open(
+		CL_Component *parent);
+
+	//: Open
+	static const std::string open(
+		const std::string &amp;file,
+		const std::string &amp;filter,
+		CL_Component *parent);
+
+	//: Save
+	static const std::string save(
+		CL_Component *parent);
+
+	//: Save
+	static const std::string save(
+		const std::string &amp;file,
+		const std::string &amp;filter,
+		CL_Component *parent);
+
+//! Attributes:
+public:
+
+	//: Return  pressed button
+	const ButtonPressed &amp;get_pressed_button(void) const; 
+
+	//: Returns the selected file name. 
+	const std::string &amp;get_file() const;
+
+	//: Returns the filter which the user has chosen in the file dialog.
+	const std::string &amp;get_filter() const;
+
+	//: Returns the active directory in the file dialog.
+	const std::string &amp;get_dir() const;
+
+	//: Returns the active directory path in the file dialog. 
+	const std::string &amp;get_path() const;
+
+	//: Returns true if hidden files are shown in the filedialog, else false.
+	bool is_hidden_files_visible() const;
+
+//! Operations:
+public:
+	//: Set behavior of dialog
+	//- &lt;p&gt;If behavior is quit_file_selected and user press Ok, dialog will quit 
+	//- only if any file is selected. If user press Cancel, dialog will quit.
+	//- If behavior is quit_always, and any button was pressed, dialog will quit&lt;/p&gt;
+	void set_behavior(Behavior behavior);
+
+	//: Sets the default selection to filename.
+	//- &lt;p&gt;If filename is absolute, set_dir() is also called.&lt;/p&gt;
+	void set_file(const std::string &amp;filename);
+
+	//: Sets a directory path for the file dialog. 
+	void set_dir(const std::string &amp;dir);
+
+	//: Sets the filter to filter.
+	void set_filter(const std::string &amp;filter);
+
+	//: If enable is true, hidden files are shown in the filedialog, else no hidden files are shown. 
+	void show_hidden_files(bool enable = true);
+
+	//: Re-reads the active directory in the file dialog. 
+	//- &lt;p&gt;It is seldom necessary to call this function.
+	//- It is provided in case the directory contents change and you want to refresh the directory listbox.&lt;/p&gt;
+	void refresh();
+
+//! Signals:
+public:
+	//: This signal is emitted when the user highlights a file. 
+	CL_Signal_v1&lt;const std::string &amp;&gt; &amp;sig_file_highlighted();
+
+	//: This signal is emitted when the user selects a file. 
+	CL_Signal_v1&lt;const std::string &amp;&gt; &amp;sig_file_selected();
+
+	//: This signal is emitted when the user has selected a new directory. 
+	CL_Signal_v1&lt;const std::string &amp;&gt; &amp;sig_dir_entered();
+
+//! Implementation:
+private:
+// TODO: Fix this copy constructor
+//	CL_FileDialog(const CL_FileDialog &amp;copy) : CL_Component(NULL, NULL) { return; } // disallow copy construction.
+	CL_FileDialog_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/GUI/frame.h
===================================================================
--- trunk/clanlib/API/GUI/frame.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/frame.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,91 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Controls&quot;
+//! header=gui.h
+
+#ifndef header_frame
+#define header_frame
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;component.h&quot;
+
+class CL_Frame_Generic;
+
+//: Frame component
+//- !group=GUI/Controls!
+//- !header=gui.h!
+class CL_API_GUI CL_Frame : public CL_Component
+{
+//! Construction:
+public:
+	//: Frame Constructor
+	CL_Frame(
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: Frame Constructor
+	CL_Frame(
+		const CL_Rect &amp;pos,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: Frame Destructor
+	virtual ~CL_Frame();
+
+//! Attributes:
+public:
+	//: Is fill enabled
+	bool is_fill_enabled() const;
+
+//! Operations:
+public:
+	//: Enable Fill
+	void enable_fill(bool enabled = true);
+
+//! Implementation:
+private:
+	CL_Frame(const CL_Frame &amp;copy) : CL_Component(NULL, NULL) { return; } // disallow copy construction.
+	CL_Frame_Generic *impl;
+};  
+
+#endif

Added: trunk/clanlib/API/GUI/gui_manager.h
===================================================================
--- trunk/clanlib/API/GUI/gui_manager.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/gui_manager.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,144 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Framework&quot;
+//! header=gui.h
+
+#ifndef header_gui_manager
+#define header_gui_manager
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;stddef.h&gt;
+
+#include &quot;component.h&quot;
+
+class CL_ComponentManager;
+class CL_StyleManager;
+class CL_EventTrigger;
+class CL_GUIManager_Generic;
+class CL_Component_Generic;
+
+//: Root component.
+//- !group=GUI/Framework!
+//- !header=gui.h!
+//- &lt;p&gt;The GUI manager component is the 'root component' of any GUI system. It
+//- is responsible channeling input and output from the general clanlib display
+//- API and into the GUI system.&lt;/p&gt;
+//- &lt;p&gt;The GUI manager must to be the top-level component in any component tree.&lt;/p&gt;
+//- &lt;p&gt;Modal dialog interfaces in clanGUI is archived by constructing a GUI manager
+//- with a parent component. This will disable the input of the previous GUI, but
+//- will keep calling its painting signals.&lt;/p&gt;
+class CL_API_GUI CL_GUIManager : public CL_Component
+{
+//! Construction:
+public:
+	//: GUI Manager Constructor
+	CL_GUIManager(CL_StyleManager *style);
+
+	//: GUI Manager Destructor
+	virtual ~CL_GUIManager();
+
+//! Attributes:
+public:
+	//: Returns the currently focused component.
+	CL_Component *get_focus() const;
+
+	//: Returns the currently captured component.
+	CL_Component *get_capture() const;
+
+	//: Returns true if input is enabled.
+	bool is_input_enabled() const;
+	
+	//: Return component on top of modal stack or NULL if none
+	CL_Component * get_modal_component() const;
+
+	//: Returns the event trigger for the gui manager.
+	CL_EventTrigger *get_update_trigger();
+
+	//: Returns true if gui manager is currently shutting down
+	bool is_shutting_down() const;
+
+//! Operations:
+public:
+	//: Sets the focus component of the gui.
+	void set_focus(CL_Component *component);
+
+	//: Draws the GUI once.
+	void show();
+
+	//: Runs the GUI message pump continuosly.
+	//- &lt;p&gt;This function runs the GUI mesage pump continously until CL_GUIManager::quit() is called.
+	//- It will redraw the screen and user events to components as they occour.&lt;/p&gt;
+	//param modal_component: This parameter indicates if input events should only occour from a certain
+	//param modal_component: component or beneath in the component tree. This is used to start modal
+	//param modal_component: message pumps in the system, where you can only interface with a popup or
+	//param modal_component: similar.
+	void run(CL_Component *modal_component = 0);
+
+	//: Break run loop.
+	void quit();
+
+	//: Tells the GUI to start accepting input.
+	void enable_input();
+	
+	//: Tells the GUI to stop accepting input.
+	void disable_input();
+
+	//: Sets the GUI in capture mode. [should we move this out of API space? -- mbn]
+	void gui_capture_mouse(CL_Component *component);
+
+	//: Takes GUI out of capture mode. [should we move this out of API space? -- mbn]
+	void gui_release_mouse();
+
+//! Signals:
+public:
+	//: Called when a new component get the focus
+	CL_Signal_v1&lt;CL_Component *&gt; &amp;sig_focus_changed();
+	
+//! Implementation:
+private:
+	CL_GUIManager_Generic *impl;
+
+	friend class CL_Component_Generic;
+};
+
+#endif

Added: trunk/clanlib/API/GUI/image.h
===================================================================
--- trunk/clanlib/API/GUI/image.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/image.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,140 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Controls&quot;
+//! header=gui.h
+
+#ifndef header_image
+#define header_image
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;component.h&quot;
+
+class CL_Surface;
+class CL_Image_Generic;
+
+//: Image component
+//- !group=GUI/Controls!
+//- !header=gui.h!
+class CL_API_GUI CL_Image : public CL_Component
+{
+//! Enums:
+public:
+	//: Mode enums
+	enum Mode
+	{
+		normal,
+		center,
+		stretch,
+		tile
+	};
+
+//! Construction:
+public:
+	//: Image Constructor
+	CL_Image(
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: Image Constructor
+	CL_Image(
+		CL_Surface *surface,
+		bool delete_surface,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: Image Constructor
+	CL_Image(
+		const CL_Rect &amp;pos,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: Image Constructor
+	CL_Image(
+		const CL_Rect &amp;pos,
+		CL_Surface *surface,
+		bool delete_surface,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: Image Constructor
+	CL_Image(
+		const CL_Point &amp;pos,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: Image Constructor
+	CL_Image(
+		const CL_Point &amp;pos,
+		CL_Surface *surface,
+		bool delete_surface,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: Image Destructor
+	virtual ~CL_Image();
+
+//! Attributes:
+public:
+	//: Returns the surface.
+	CL_Surface *get_surface() const;
+
+	//: Returns the current display mode.
+	Mode get_mode() const;
+
+//! Operations:
+public:
+	//: Sets the surface.
+	void set_surface(CL_Surface *surface, bool delete_surface = false);
+
+	//: Sets the display mode.
+	void set_mode(Mode mode);
+
+//! Implementation:
+private:
+	Mode mode;
+
+	CL_Image(const CL_Image &amp;copy) : CL_Component(NULL, NULL) { return; } // disallow copy construction.
+	CL_Image_Generic *impl;
+};  
+
+#endif

Added: trunk/clanlib/API/GUI/inputbox.h
===================================================================
--- trunk/clanlib/API/GUI/inputbox.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/inputbox.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,221 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Controls&quot;
+//! header=gui.h
+
+#ifndef header_inputbox
+#define header_inputbox
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;component.h&quot;
+
+class CL_InputBox_Generic;
+
+//: Inputbox component
+//- !group=GUI/Controls!
+//- !header=gui.h!
+class CL_API_GUI CL_InputBox : public CL_Component
+{
+//! Construction:
+public:
+	//: InputBox Constructor
+	CL_InputBox(
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: InputBox Constructor
+	CL_InputBox(
+		const std::string &amp;text,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: InputBox Constructor
+	CL_InputBox(
+		const CL_Rect &amp;pos,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: InputBox Constructor
+	CL_InputBox(
+		const CL_Rect &amp;pos,
+		const std::string &amp;text,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: InputBox Destructor
+	virtual ~CL_InputBox();
+
+//! Attributes:
+public:
+	//: Returns the inputfield text.
+	const std::string &amp;get_text() const;
+
+	//: Returns the length of the inputfield text.
+	int get_length() const;
+
+	//: Returns the marked text from the inputfield.
+	std::string get_marked_text() const;
+
+	//: Returns true if part of the text has been marked by the user.
+	bool has_marked_text() const;
+
+	//: Returns the position where the selection starts.
+	int get_selection_start() const;
+
+	//: Returns the length of current selection.
+	int get_selection_length() const;
+
+	//: Returns the maximum permitted length of the text.
+	//- &lt;p&gt;0 means it has no maximum length requirement.&lt;/p&gt;
+	int get_max_length() const;
+
+	//: Returns true if password mode is enabled, false othewise.
+	bool in_password_mode() const;
+
+	//: Returns whether the inputfield is read-only. 
+	bool is_read_only() const;
+
+	//: Returns the current cursor position.
+	int get_cursor_position() const;
+
+	//: Returns true if the contents has been edited.
+	bool is_edited() const;
+
+//! Operations:
+public:
+	//: Sets the line edit text to text, clears the selection and moves the cursor to the end of the line.
+	//- &lt;p&gt;If necessary the text is truncated to get_max_length().&lt;/p&gt;
+	void set_text(const std::string &amp;text);
+
+	//: Sets the line edit contents to a plain text containing the printed value of num.
+	void set_text(int number);
+
+	//: Sets the line edit contents to a plain text containing the printed value of num.
+	void set_text(double number);
+
+	//: Set the maximum length of the text in the editor.
+	//- &lt;p&gt;Use 0 to have no maximum length requirement.&lt;/p&gt;
+	void set_max_length(int length);
+
+	//: If enable is true, display asterisks instead of the characters actually entered.
+	void set_password_mode(bool enable = true);
+
+	//: Enables or disables read-only mode.
+	void set_read_only(bool enable = true);
+	
+	//: Selects all text, and moves the cursor to the end.
+	void select_all();
+
+	//: Deselects all text (i.e. removes marking) and leaves the cursor at the current position. 
+	void deselect();
+
+	//: Sets the marked area at start and be length characters long. 
+	void set_selection(int start, int length);
+
+	//: Sets the cursor position to pos. 
+	void set_cursor_position(int pos);
+
+	//: Syntactic sugar for set_text(&quot;&quot;).
+	void clear();
+
+	//: Deletes the character to the left of the text cursor and moves the cursor one position to the left.
+	//- &lt;p&gt;If a text has been marked, the cursor will be put at the beginning of the marked text
+	//- and the marked text will be removed.&lt;/p&gt;
+	void backspace();
+
+	//: Deletes the character on the right side of the text cursor.
+	//- &lt;p&gt;If a text has been marked, the cursor will be put at the beginning of the marked text and the marked
+	//- text will be removed.&lt;/p&gt;
+	void del();
+
+	//: Cut the selected text if any.
+	void cut();
+
+	//: Moves the cursor position.
+	//- &lt;p&gt;If delta is positive, the cursor is moved forward.
+	//- If delta is negative, the cursor is moved backward.
+	//- If mark is true, the text is marked.&lt;/p&gt;
+	void move_cursor(int delta, bool mark = false);
+
+	//: Moves the cursor by word.
+	//- &lt;p&gt;If delta is positive, the cursor is moved forward.
+	//- If delta is negative, the cursor is moved backward.
+	//- If mark is true, the text is marked.&lt;/p&gt;
+	void move_cursor_word(int delta, bool mark = false);
+
+	//: Moves the text cursor to the left end of the line.
+	//- &lt;p&gt;If mark is true, text will be marked towards the first position
+	//- If mark is false, any marked text will be unmarked if the cursor is moved.&lt;/p&gt;
+	void home(bool mark = false);
+
+	//: Moves the text cursor to the right end of the line.
+	//- &lt;p&gt;If mark is true, text will be marked towards the last position
+	//- If mark is false, any marked text will be unmarked if the cursor is moved. &lt;/p&gt;
+	void end(bool mark = false);
+
+	//: Sets the edited flag to on. 
+	//- &lt;p&gt;The edited flag is changed to true whenever the user changes its contents. &lt;/p&gt;
+	void set_edited(bool on = true);
+
+//! Signals:
+public:
+	//: This signal is emitted whenever text is changed in the inputfield.
+	//param const std::string &amp;: Contains the new string.
+	CL_Signal_v1&lt;const std::string &amp;&gt; &amp;sig_changed();
+
+	//: This signal is emitted when enter is pressed in the inputfield.
+	CL_Signal_v0 &amp;sig_return_pressed();
+
+	//: This signal is emitted whenever some character is changed/added/removed, cursor moved etc.
+	CL_Signal_v0 &amp;sig_activity();
+
+	//: This signal is emitted after user enter some character, but before it added, to allow user to accept/decline it.
+	CL_Signal_v2&lt;char &amp;, bool &amp;&gt; &amp;sig_validate_character();
+
+//! Implementation:
+private:
+	CL_InputBox(const CL_InputBox &amp;copy) : CL_Component(NULL, NULL) { return; } // disallow copy construction.
+	CL_InputBox_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/GUI/inputdialog.h
===================================================================
--- trunk/clanlib/API/GUI/inputdialog.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/inputdialog.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,106 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Controls&quot;
+//! header=gui.h
+
+#ifndef header_inputdialog
+#define header_inputdialog
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;window.h&quot;
+
+class CL_InputDialog_Generic;
+class CL_InputBox;
+class CL_CheckBox;
+class CL_Button;
+
+//: CL_InputDialog component
+//- !group=GUI/Controls!
+//- !header=gui.h!
+class CL_API_GUI CL_InputDialog : public CL_Window
+{
+//! Construction:
+public:
+	//: CL_InputDialog constructor
+	CL_InputDialog(
+		const std::string &amp;title,
+		const std::string &amp;button1,
+		const std::string &amp;button2,
+		const std::string &amp;button3,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+	
+	//: CL_InputDialog destructor
+	virtual ~CL_InputDialog();
+
+//! Operations:
+public:
+	//: Add inputbox with label to dialog.
+	//: The inputbox is deleted by the InputDialog when destroyed.
+	CL_InputBox *add_input_box(
+		const std::string &amp;label = &quot;&quot;,
+		const std::string &amp;default_value = &quot;&quot;,
+		int inputbox_width = 100);
+
+	//: Add checkbox with label to dialog.
+	//: The checkbox is deleted by the InputDialog when destroyed.
+	CL_CheckBox *add_check_box(
+		const std::string &amp;text = &quot;&quot;,
+		bool checked = false,
+		int check_box_width = 100);
+
+	//: Get the pointer to one of the built in buttons (ok/cancel/etc) to further customize it
+	//: 0 based.  Returns NULL if no button exists at that index
+	CL_Button * get_button(int button);
+
+	//: Returns the number of the button that was used to close the dialog.
+	int get_result_button();
+
+//! Implementation:
+private:
+	CL_InputDialog(const CL_InputDialog &amp;copy) : CL_Window((CL_Component*)NULL, NULL) { return; } // disallow copy construction.
+
+	CL_InputDialog_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/GUI/label.h
===================================================================
--- trunk/clanlib/API/GUI/label.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/label.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,138 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Controls&quot;
+//! header=gui.h
+
+#ifndef header_label
+#define header_label
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;component.h&quot;
+#include &quot;../Core/Math/origin.h&quot;
+#include &quot;../Display/font.h&quot;
+
+class CL_Label_Generic;
+
+//: Label component
+//- !group=GUI/Controls!
+//- !header=gui.h!
+class CL_API_GUI CL_Label : public CL_Component
+{
+//! Construction:
+public:
+	//: Label Constructor
+	CL_Label(
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: Label Constructor
+	CL_Label(
+		const std::string &amp;text,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: Label Constructor
+	CL_Label(
+		const CL_Point &amp;pos,
+		const std::string &amp;text,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: Label Constructor
+	CL_Label(
+		const CL_Rect &amp;pos,
+		const std::string &amp;text,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: Label Destructor
+	virtual ~CL_Label();
+
+//! Attributes:
+public:
+	//: Returns the labeltext.
+	const std::string &amp;get_text() const;
+
+	//: Returns the alignment setting.
+	//: See set_alignment() for more info.
+	CL_Origin get_alignment() const;
+	
+	//: Returns the font the label uses.
+	CL_Font* get_font();
+
+//! Operations:
+public:
+	//: Sets the labeltext.
+	void set_text(const std::string &amp;text);
+
+	//: Sets the label contents to a plain text containing the printed value of num.
+	void set_text(int number);
+
+	//: Sets the label contents to a plain text containing the printed value of num.
+	void set_text(double number);
+
+	//: Clears any label contents. Equivalent with setText(&quot;&quot;).
+	void clear();
+
+	//: Sets the alignment of the label contents
+	void set_alignment(CL_Origin alignment);
+	
+	//: Sets the font of the label.
+	void set_font(const CL_Font&amp; f);
+	
+
+//! Signals:
+public:
+	//: Called after font is changed.
+	CL_Signal_v0 &amp;sig_font_change();
+
+//! Implementation:
+private:
+	void init(const std::string &amp;text);
+
+	CL_Label(const CL_Label &amp;copy) : CL_Component(NULL, NULL) { return; } // disallow copy construction.
+	CL_Label_Generic *impl;
+	
+};  
+
+#endif

Added: trunk/clanlib/API/GUI/layout.h
===================================================================
--- trunk/clanlib/API/GUI/layout.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/layout.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,108 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Framework&quot;
+//! header=gui.h
+
+#ifndef header_layout
+#define header_layout
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#include &quot;../Core/System/sharedptr.h&quot;
+
+class CL_Component;
+class CL_Layout_Generic;
+class CL_Rect;
+
+//: Layout types for CL_Layout.
+//- !group=GUI/Framework!
+//- !header=gui.h!
+enum CL_LayoutType
+{
+	layout_vertical,
+	layout_horizontal,
+	layout_grid
+};
+
+//: Layout management class.
+//- !group=GUI/Framework!
+//- !header=gui.h!
+class CL_API_GUI CL_Layout
+{
+//! Construction:
+public:
+	CL_Layout();
+
+	CL_Layout(const CL_Layout &amp;copy);
+
+	CL_Layout(CL_LayoutType type);
+
+	virtual ~CL_Layout();
+
+//! Operations:
+public:
+	void set_grid_columns(int columns);
+
+	void set_margin(int margin);
+
+	void set_spacing(int spacing);
+
+	void add_component(CL_Component *component);
+
+	void add_component(int index, CL_Component *component);
+
+	void add_component(int col, int row, CL_Component *component, int span=1);
+
+	void add_layout(const CL_Layout &amp;layout);
+
+	void add_layout(int index, const CL_Layout &amp;layout);
+
+	void add_layout(int col, int row, const CL_Layout &amp;layout, int span=1);
+
+	void remove_component(CL_Component *component);
+
+	void remove_layout(CL_Layout *layout);
+
+	void set_position(const CL_Rect &amp;pos);
+
+//! Implementation:
+private:
+	CL_SharedPtr&lt;CL_Layout_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/GUI/listbox.h
===================================================================
--- trunk/clanlib/API/GUI/listbox.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/listbox.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,205 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Controls&quot;
+//! header=gui.h
+
+#ifndef header_listbox
+#define header_listbox
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;component.h&quot;
+#include &quot;listitem.h&quot;
+
+class CL_ListBox_Generic;
+
+//: Listbox component
+//- !group=GUI/Controls!
+//- !header=gui.h!
+class CL_API_GUI CL_ListBox : public CL_Component
+{
+//! Construction:
+public:
+	//: Listbox constructor
+	CL_ListBox(
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+	
+	//: Listbox constructor
+	CL_ListBox(
+		const CL_Rect &amp;pos,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: Listbox destructor
+	virtual ~CL_ListBox();
+
+//! Attributes:
+public:
+	//: Returns the number of items in the list box. 
+	int get_count() const;
+
+	//: Returns items in the list.
+	std::vector&lt;CL_ListItem *&gt; &amp;get_items() const;
+
+	//: Returns selected items as strings.
+ 	std::vector&lt;std::string&gt; get_selected_items() const;
+
+	//: Returns the text of the current item.
+	//- &lt;p&gt;Returns &quot;&quot; if item not found. Best to use on single-selection lists, as it will only
+	//- return the first selected item.&lt;/p&gt;
+	const std::string &amp;get_current_text() const;
+
+	//: Returns an item.
+	//- &lt;p&gt;Returns NULL if item was not found.&lt;/p&gt;S
+	CL_ListItem *get_item(int index) const;
+
+	//: Returns an item index by screen coordinates, or -1 for if no item is found
+	int get_item(const CL_Point &amp;pt);
+
+	//: Returns the text for an item.
+	const std::string &amp;get_text(int index) const;
+	
+	//: Returns the index of the current item of the listbox, or -1 if no item has been selected. 
+	int get_current_item() const;
+
+	//: Returns true if item index is selected. Returns false if it is not selected or if there is an error.
+	bool is_selected(int index) const;
+
+	//: Returns true if the listbox is in multiselection mode.
+	bool is_multi_selection() const;
+
+	//: Returns the height of one item.
+	int get_item_height() const;
+
+	//: Returns the index of the item at the top of the screen.
+	int get_top_item() const;
+
+//! Operations:
+public:
+	//: Inserts a listitem into the list at index. 
+	//- &lt;p&gt;If index is negative, text is inserted at the end of the list.
+	//- Returns the index of the text&lt;/p&gt;
+	int insert_item(CL_ListItem *item, int index = -1, bool delete_item = false);
+
+	//: Inserts text into the list at index. 
+	//- &lt;p&gt;If index is negative, text is inserted at the end of the list.
+	//- Returns the index of the text&lt;/p&gt;
+	int insert_item(const std::string &amp;text, int index = -1);
+
+	//: Removes and deletes the item at position index.
+	//- &lt;p&gt;If index is equal to get_current_item(), a new item gets highlighted and the sig_highlighted() signal is emitted.&lt;/p&gt;
+	void remove_item(int index);
+
+	//: Replaces the item at position index with new item. 
+	void change_item(CL_ListItem *item, int index);
+
+	//: Replaces the item at position index with text. 
+	void change_item(const std::string &amp;text, int index);
+
+	//: Sets the highlighted item to the item index.
+	//- &lt;p&gt;The highlighting is moved and the listbox scrolled as necessary. &lt;/p&gt;
+	void set_current_item(int index);
+
+	//: Selects item at index if select is true, or unselects it if select is false.
+	//- &lt;p&gt;If the listbox is a single-selection listbox and and select is true, set_current_item() is called. 
+	//- If the listbox is a single-selection listbox and and select is false, clear_selection()
+	//- is called if index is the currently selected item. &lt;/p&gt;
+	void set_selected(int index, bool select);
+
+	//: Deselects current selected item.
+	void clear_selection();
+
+	//: If select is true, all items get selected, else all get unselected.
+	//: This works only in Multi selection mode.
+	void select_all(bool select = true);
+
+	//: Inverts the selection.
+	//: Works only in Multi selection mode.
+	void invert_selection();
+
+	//: Sets the listbox to multiselection if enable is true,
+	//: single selection otherwise.
+	void set_multi_selection(bool enable = true);
+
+	//: Sets the height of each item.
+	void set_item_height(int height);
+
+	//: Scrolls the list box so the item at position index in the list is displayed in the top row of the listbox. 
+	void set_top_item(int index);
+
+	//: Sorts the items in ascending order, if ascending is true, or descending otherwise. 
+	void sort(bool ascending = true);
+
+	//: Deletes all items in the list. 
+	void clear();
+
+//! Signals:
+public:
+	//: This signal is emitted when the user highlights a new current item.
+	//- &lt;p&gt;The argument is the index of the new item, which is already current.&lt;/p&gt;
+	CL_Signal_v1&lt;int&gt; &amp;sig_highlighted();
+
+	//: This signal is emitted when the user double clicks, presses space or return on an item.
+	//- &lt;p&gt;The argument is the index of the item.&lt;/p&gt;
+	CL_Signal_v1&lt;int&gt; &amp;sig_activated();
+
+	//: This signal is emitted when the selection set of a listbox changes.
+	CL_Signal_v0 &amp;sig_selection_changed();
+
+	//: This signal is emitted when a new item is added to the listbox.
+	CL_Signal_v1&lt;int&gt; &amp;sig_item_added();
+
+	//: This signal is emitted when an item is removed from the listbox.
+	CL_Signal_v1&lt;int&gt; &amp;sig_item_removed();
+	
+	//: This signal is emitted when the listbox is cleared.
+	CL_Signal_v0 &amp;sig_clear();
+
+//! Implementation:
+private:
+	CL_ListBox(const CL_ListBox &amp;copy) : CL_Component(NULL, NULL) { return; } // disallow copy construction.
+
+	CL_ListBox_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/GUI/listitem.h
===================================================================
--- trunk/clanlib/API/GUI/listitem.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/listitem.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,88 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Framework&quot;
+//! header=gui.h
+
+#ifndef header_listbox_item
+#define header_listbox_item
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+
+//: List item class.
+//- !group=GUI/Controls!
+//- !header=gui.h!
+class CL_API_GUI CL_ListItem
+{
+public:
+	CL_ListItem() : selected(false), delete_item(false) {}
+	virtual ~CL_ListItem(){}
+
+	bool operator&lt; ( const CL_ListItem &amp;item ) const
+	{
+		return this-&gt;less_than(item);
+	}
+
+	bool operator== ( const CL_ListItem &amp;item ) const
+	{
+		return this-&gt;equal(item);
+	}
+
+protected:
+	virtual bool less_than(const CL_ListItem &amp; item) const
+	{
+		return str &lt; item.str;
+	}
+	virtual bool equal(const CL_ListItem &amp; item) const
+	{
+		return str == item.str;
+	}
+
+public:
+	std::string str;
+	bool selected;
+	bool delete_item;
+	int user_data;
+};
+
+#endif

Added: trunk/clanlib/API/GUI/menu.h
===================================================================
--- trunk/clanlib/API/GUI/menu.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/menu.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,231 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Controls&quot;
+//! header=gui.h
+
+#ifndef header_menu
+#define header_menu
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;component.h&quot;
+#include &quot;../Core/Math/point.h&quot;
+
+class CL_MenuNode;
+class CL_Menu_Generic;
+class CL_MenuItem;
+
+//: Menu component
+//- !group=GUI/Controls!
+//- !header=gui.h!
+class CL_API_GUI CL_Menu : public CL_Component
+{
+//! Construction:
+public:
+	//: CL_Menu Constructor
+	CL_Menu(
+		const CL_Point &amp;pos,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL,
+		bool vertical=false);
+
+	//: CL_Menu Constructor
+	//: This places the menu at (0, 0).
+	CL_Menu(
+		CL_Component *parent,
+		CL_StyleManager *style = NULL,
+		bool vertical=false);
+
+	//: CL_Menu Constructor
+	CL_Menu(
+		const CL_Rect &amp;rect,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL,
+		bool vertical=false);
+
+	//: CL_Menu Constructor
+	CL_Menu(
+		CL_MenuNode *parent_node,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL );
+	
+	//: CL_Menu Destructor
+	virtual ~CL_Menu();
+
+//! Attributes:
+public:
+	//: Returns true if the menu is open
+	bool is_open();
+
+	//: Returns true if the menu is vertical, false if horizontal
+	bool is_vertical();
+
+	//: Returns true if the root menu collapses when a click outside the menus takes place.
+	//: Ignored by non-root menus.
+	bool is_root_collapsing();
+
+	//: Returns true if menu resized automatically when its parent is resized.
+	bool is_auto_resize();
+
+	//: Returns true if the mouse cursor is on top of the menu
+	bool has_mouse_over();
+
+	//: Returns true if the mouse cursor is in a open submenu of the menu
+	bool has_mouse_in_submenus();
+
+	//: Returns the parent node of this menu.
+	CL_MenuNode *get_parent_node();
+	
+	//: Returns the top level parent of the menu tree.
+	CL_Menu *get_root_menu();
+
+	//: Returns a list containing the CL_MenuNode's in this menu.
+	std::list&lt;CL_MenuNode*&gt; &amp;get_node_list();
+
+	//: Returns the total height of items in a menu
+	int get_items_height();
+
+	//: Returns the total width of items in a menu
+	int get_items_width();
+
+	//: Returns true if the menus submenus need to be clicked to open.
+	//: By default they open on mouse enter for vertical menus and
+	//: on click with horizontal menus when it doesn't have focus.
+	bool is_click_to_open();
+
+	//: Returns a pointer to the menu in the path given, or 0 if no such menu exsists.
+	//param std::string name : name of the menu to get, Ex: &quot;View/Zoom&quot;
+	CL_Menu *get_menu(const std::string &amp;name);
+
+	//: Returns a pointer to the menu node in the path given, or 0 if no such menu exsists.
+	//param std::string name : name of the menu node to get, Ex: &quot;View/Zoom/1:1&quot;
+	CL_MenuNode *get_node(const std::string &amp;name);
+
+	//: Returns a pointer to the menu item (CL_Component*) in the path given, or 0 if no such menu item exsists.
+	//param std::string name : name of the menu item to get, Ex: &quot;View/Zoom/1:1&quot;
+	CL_Component *get_item(const std::string &amp;name);
+
+//! Signals:
+public:
+	//: This signal is emitted when a repositioning of the menus is requsted.
+	//param int x : x position of topleft of the menu
+	//param int y : y position of topleft of the menu
+	CL_Signal_v2&lt;int,int&gt; &amp;sig_reposition();
+	
+//! Operations:
+public:
+	//: Calculates a position and size for the menu, using code in the GUI theme.
+	void reposition();
+
+	//: Calculates a position and size for the menu, using code in the GUI theme.
+	//param int x : x position of topleft of the menu
+	//param int y : y position of topleft of the menu	
+	void reposition(int,int);
+
+	//: Makes the menu resize automatically when its parent is resized
+	void set_auto_resize(bool value);
+
+	//: Makes the menu vertical (true) or horizontal (false).
+	void set_vertical(bool vertical);
+
+	//: Set weather the root menu should collapse when a click outside the menus takes place.
+	//: Ignored by non-root menus.
+	void set_root_collapsing(bool collapse);
+
+	//: Add a CL_MenuNode to the menu.
+	void add_node(CL_MenuNode *node);
+	
+	//: Remove a CL_MenuNode from the menu.
+	void remove_node(CL_MenuNode *node);
+
+	//: Set the parent node of this menu.
+	void set_parent_node(CL_MenuNode *);
+	
+	//: Open the menu.
+	void open();
+
+	//: Close the menu.
+	void collapse();
+
+	//: Close all submenus of the menu.
+	void collapse_submenus();
+
+	//: Set the opening mode of submenus to open on click (true) or open on mouse over (false)
+	void set_click_to_open(bool click);
+
+	//: Convenience function for easy creation of menus.
+	//: Creates needed menus, items and nodes automatically
+	//param std::string path : path and name of the menu node to create. Ex. &quot;File/Open&quot;
+	//param std::string labels : labels to give menu items. Ex. &quot;Fil/Aben&quot;. If empty, the path is used for labels.
+	CL_Menu *create_menu( const std::string &amp;path, const std::string &amp;labels=std::string());
+	
+	//: Convenience function for easy creation of menus.
+	//: Creates needed menus, items and nodes automatically
+	//param std::string path : path of the menu node to create. Ex. &quot;File/Open&quot;
+	//param std::string labels : labels to give menu items. Ex. &quot;Fil/Aben&quot;. If empty, the path is used for labels.
+	CL_MenuNode *create_node( const std::string &amp;path, const std::string &amp;labels=std::string());
+
+	//: Convenience function for easy creation of menus.
+	//: Creates needed menus, items and nodes automatically
+	//: Returns the parent node of the created item.
+	//param std::string path : path the menu item to create. Ex. &quot;File/Open&quot;
+	//param std::string labels : labels of the menu items to create. Ex. &quot;Fil/Aben&quot;
+	CL_MenuNode *create_item( const std::string &amp;path, const std::string &amp;labels=std::string());
+
+	//: Convenience function for easy creation of menus.
+	//: Creates a toggling menu item in the specified path.
+	//: Returns the parent node of the created item.
+	//param std::string path : path the menu item to create. Ex. &quot;File/Open&quot;
+	//param std::string labels : labels of the menu items to create. Ex. &quot;Fil/Aben&quot;
+	CL_MenuNode *create_toggle_item( const std::string &amp;path, const std::string &amp;labels=std::string());
+
+//! Implementation:
+private:
+	CL_Menu(const CL_Menu &amp;copy) : CL_Component(0,0) { return; } // disallow copy construction.
+	
+	CL_Menu_Generic *impl;
+
+	friend class CL_Menu_Generic;
+	friend class CL_MenuNode_Generic;
+};
+
+#endif

Added: trunk/clanlib/API/GUI/menu_item.h
===================================================================
--- trunk/clanlib/API/GUI/menu_item.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/menu_item.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,117 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Controls&quot;
+//! header=gui.h
+
+#ifndef header_menu_item
+#define header_menu_item
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;component.h&quot;
+
+class CL_MenuItem_Generic;
+class CL_Surface;
+
+//: Label component
+//- !group=GUI/Controls!
+//- !header=gui.h!
+class CL_API_GUI CL_MenuItem : public CL_Component
+{
+//! Construction:
+public:
+	//: MenuItem Constructor
+	CL_MenuItem(
+		const std::string &amp;text,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: MenuItem Destructor
+	virtual ~CL_MenuItem();
+
+//! Attributes:
+public:
+	//: Returns the menu item text.
+	const std::string &amp;get_text() const;
+
+	//: Returns true if the menu item can have an icon.
+	bool use_icon() const;
+	
+	//: Returns true if the menu item is in toggle mode, otherwise false.
+	bool is_toggling() const;
+
+	//: Returns true if the menu item is selected
+	bool is_selected() const;
+
+//! Operations:
+public:
+	//: Sets the item to toggle mode (true) or normal mode (false). Default is false.
+	void set_toggling(bool toggle);
+
+	//: Sets the item to toggle mode (true) or normal mode (false). Default is false.
+	void set_use_icon(bool use_icon);
+
+	//: Sets the menu items selected status, if in toggle mode.
+	void set_selected(bool selected);
+
+	//: Sets the menu item text.
+	void set_text(const std::string &amp;text);
+
+	//: Sets the menu item contents to a plain text containing the printed value of num.
+	void set_text(int number);
+
+	//: Sets the menu item contents to a plain text containing the printed value of num.
+	void set_text(double number);
+
+	//: Clears any menu item text. Equivalent with set_text(&quot;&quot;).
+	void clear();
+
+//! Implementation:
+private:
+	void init(const std::string &amp;text);
+
+	CL_MenuItem(const CL_MenuItem &amp;copy) : CL_Component(NULL, NULL) { return; } // disallow copy construction.
+	
+	CL_MenuItem_Generic *impl;
+};  
+
+#endif

Added: trunk/clanlib/API/GUI/menu_node.h
===================================================================
--- trunk/clanlib/API/GUI/menu_node.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/menu_node.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,136 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Controls&quot;
+//! header=gui.h
+
+#ifndef header_menu_node
+#define header_menu_node
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../GUI/component.h&quot;
+
+class CL_Menu;
+class CL_MenuNode_Generic;
+
+//: MenuNode component
+//- !group=GUI/Controls!
+//- !header=gui.h!
+class CL_API_GUI CL_MenuNode : public CL_Component
+{
+//! Construction:
+public:
+	//: CL_MenuNode Constructor
+	CL_MenuNode(
+		CL_Menu *parent_menu,
+		CL_StyleManager *style = NULL);
+
+	//: CL_MenuNode destructor
+	virtual ~CL_MenuNode();
+
+//! Attributes:
+public:
+	//: Returns a pointer to the CL_Component which is this MenuNodes MenuItem.
+	CL_Component *get_data();
+	
+	//: Returns true if the mouse is in the submenus of this node.
+	bool has_mouse_in_submenus();
+	
+	//: Returns true if the mouse is on this component or it's MenuItem
+	//: This overrides CL_Component's has_mouse_over()
+	bool has_mouse_over();
+	
+	//: Returns true if the node has a submenu.
+	bool has_submenu();
+
+	//: Returns true if the node has an open submenu.
+	bool has_open_submenu();
+	
+	//: Returns the nodes submenu, or NULL if the node has no submenu.
+	CL_Menu *get_submenu();
+	
+	//: Returns the nodes parent menu.
+	CL_Menu *get_parent_menu();
+
+	//: Returns the name of the menu node. 
+	//: A menu nodes name forms a part of the path used by the CL_Menu::get_&lt;menu/node/item&gt;(std::string path) functions.
+	std::string get_name();
+
+//! Operations:
+public:
+	//: Set the nodes submenu.
+	void set_submenu(CL_Menu *menu);
+
+	//: Set the nodes parent menu.
+	void set_parent_menu(CL_Menu *menu);
+
+	//: Set whether the menus should collapse when an node is clicked
+	void set_close_on_click(bool close);
+	
+	//: Close the nodes submenu.
+	void collapse();
+
+	//: Open the nodes submenu.
+	void open_submenu();
+
+	//: Start the repositioning of the nodes submenus.
+	void reposition_submenus();
+
+	//: Set the name of the node. This forms a part of the path used in adressing menu components.
+	void set_name(std::string);
+
+//! Signals:
+public:
+	//: Emitted when repositioning of the menus is requested.
+	CL_Signal_v0 &amp;sig_reposition();
+
+	//: Emitted when a menu node is clicked.
+	CL_Signal_v0 &amp;sig_clicked();
+
+//! Implementation:
+private:
+	CL_MenuNode(const CL_MenuNode &amp;copy) : CL_Component(NULL, NULL) { return; } // disallow copy construction.
+
+	CL_MenuNode_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/GUI/messagebox.h
===================================================================
--- trunk/clanlib/API/GUI/messagebox.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/messagebox.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,108 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Controls&quot;
+//! header=gui.h
+
+#ifndef header_messagebox
+#define header_messagebox
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;window.h&quot;
+
+class CL_MessageBox_Generic;
+
+//: MessageBox component
+//- !group=GUI/Controls!
+//- !header=gui.h!
+class CL_API_GUI CL_MessageBox : public CL_Window
+{
+//! Construction:
+public:
+	//: MessageBox constructor
+	CL_MessageBox(
+		const std::string &amp;title,
+		const std::string &amp;text,
+		const std::string &amp;button1,
+		const std::string &amp;button2,
+		const std::string &amp;button3,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: MessageBox destructor
+	virtual ~CL_MessageBox();
+
+	//: Creates a messagebox.
+	//: Returns the button clicked, starting at index 0.
+	static int info(
+		const std::string &amp;text,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	static int info(
+		const std::string &amp;title,
+		const std::string &amp;text,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	static int info(
+		const std::string &amp;title,
+		const std::string &amp;text,
+		const std::string &amp;button1,
+		const std::string &amp;button2,
+		const std::string &amp;button3,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+//! Attributes:
+public:
+	//: Returns the index of the button clicked.
+	int get_result_button() const;
+
+//! Implementation:
+private:
+	CL_MessageBox(const CL_MessageBox &amp;copy) : CL_Window((CL_Component*)NULL, NULL) { return; } // disallow copy construction.
+
+	CL_MessageBox_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/GUI/progressbar.h
===================================================================
--- trunk/clanlib/API/GUI/progressbar.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/progressbar.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,118 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Controls&quot;
+//! header=gui.h
+
+#ifndef header_progressbar
+#define header_progressbar
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;component.h&quot;
+
+class CL_DomElement;
+class CL_Rect;
+class CL_ProgressBar_Generic;
+
+//: ProgressBar component
+//- !group=GUI/Controls!
+//- !header=gui.h!
+class CL_API_GUI CL_ProgressBar : public CL_Component
+{
+//! Construction:
+public:
+	//: ProgressBar Constructor
+	CL_ProgressBar(
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: ProgressBar Constructor
+	CL_ProgressBar(
+		int steps,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: ProgressBar Constructor
+	CL_ProgressBar(
+		const CL_Rect &amp;pos,
+		int steps,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: ProgressBar Destructor
+	virtual ~CL_ProgressBar();
+
+//! Attributes:
+public:
+	//: Returns the total number of steps.
+	int get_steps() const;
+
+	//: Returns the current amount of progress.
+	int get_progress() const;
+
+	//: Returns the current amount of progress in percentage.
+	float get_percentage() const;
+
+//! Operations:
+public:
+	//: Sets the total number of steps to total_steps. 
+	void set_steps(int total_steps);
+
+	//: Sets the current amount of progress of the total number of steps. 
+	void set_progress(int progress);
+
+	//: Progresses the bar with steps.
+	void increase(int steps = 1);
+
+	//: Reset the progress bar. The progress bar `rewinds'. 
+	void reset();
+
+//! Signals:
+public:
+
+//! Implementation:
+private:
+	CL_ProgressBar(const CL_ProgressBar &amp;copy) : CL_Component(NULL, NULL) { return; } // disallow copy construction.
+	CL_ProgressBar_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/GUI/radiobutton.h
===================================================================
--- trunk/clanlib/API/GUI/radiobutton.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/radiobutton.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,95 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Controls&quot;
+//! header=gui.h
+
+#ifndef header_radiobutton
+#define header_radiobutton
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;button.h&quot;
+
+//: CheckBox component
+//- !group=GUI/Controls!
+//- !header=gui.h!
+class CL_API_GUI CL_RadioButton : public CL_Button
+{
+//! Construction:
+public:
+	//: RadioButton constructor
+	CL_RadioButton(
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: RadioButton constructor
+	CL_RadioButton(
+		const CL_Point &amp;pos,
+		const std::string &amp;text,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: RadioButton constructor
+	CL_RadioButton(
+		const std::string &amp;text,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: RadioButton destructor
+	virtual ~CL_RadioButton();
+
+//! Attributes:
+public:
+	//: Returns true if the radiobutton is checked, or false if it is not checked.
+	bool is_checked() const;
+
+//! Operations:
+public:
+	//: Checks the radiobutton if check is true, or unchecks it if check is false. 
+	void set_checked(bool check);
+
+//! Implementation:
+private:
+	CL_RadioButton(const CL_RadioButton &amp;copy) : CL_Button(NULL, NULL) { return; } // disallow copy construction.
+};  
+
+#endif

Added: trunk/clanlib/API/GUI/radiogroup.h
===================================================================
--- trunk/clanlib/API/GUI/radiogroup.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/radiogroup.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,102 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Controls&quot;
+//! header=gui.h
+
+#ifndef header_radiogroup
+#define header_radiogroup
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../signals.h&quot;
+#include &lt;vector&gt;
+
+class CL_RadioGroup_Generic;
+class CL_RadioButton;
+
+//: RadioGroup
+//- !group=GUI/Controls!
+//- !header=gui.h!
+class CL_API_GUI CL_RadioGroup
+{
+//! Construction:
+public:
+	//: RadioGroup Constructor
+	CL_RadioGroup();
+
+	//: RadioGroup Destructor
+	~CL_RadioGroup();
+
+//! Attributes:
+public:
+	//: Returns the amount of buttons added to the group.
+	int get_count() const;
+	
+	//: Returns the selected button if any, NULL otherwise.
+	CL_RadioButton *get_toggled() const;
+
+	//: Returns all buttons in the group.
+	const std::vector&lt;CL_RadioButton *&gt; &amp;get_buttons() const;
+	
+//! Operations:
+public:
+	//: Adds a component into the group.
+	void add(CL_RadioButton *button, bool delete_component = false);
+	
+	//: Removes a component from the group.
+	void remove(CL_RadioButton *button);
+	
+	//: Sets a radiobutton active (and unchecks any other).
+	void set_checked(CL_RadioButton *button);
+	
+//! Signals:
+public:
+	//: This signal is emitted when the radio selection is changed.
+	CL_Signal_v1&lt;CL_RadioButton *&gt; &amp;sig_selection_changed();
+
+//! Implementation:
+private:
+	CL_RadioGroup(const CL_RadioGroup &amp;copy) { return; } // disallow copy construction.
+	CL_RadioGroup_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/GUI/scrollbar.h
===================================================================
--- trunk/clanlib/API/GUI/scrollbar.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/scrollbar.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,209 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Controls&quot;
+//! header=gui.h
+
+#ifndef header_scrollbar
+#define header_scrollbar
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;component.h&quot;
+
+class CL_Button;
+class CL_DomElement;
+class CL_Rect;
+class CL_ScrollBar_Generic;
+
+//: ScrollBar component
+//- !group=GUI/Controls!
+//- !header=gui.h!
+class CL_API_GUI CL_ScrollBar : public CL_Component
+{
+//! Construction:
+public:
+	//: ScrollBar Constructor
+	CL_ScrollBar(
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: ScrollBar Constructor
+	//param Orientation: false: Vertical scrollbar, true: Hortizonal scrollbar
+	CL_ScrollBar(
+		int min,
+		int max,
+		bool orientation,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: ScrollBar Constructor
+	//param Orientation: false: Vertical scrollbar, true: Hortizonal scrollbar
+	CL_ScrollBar(
+		bool orientation,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: ScrollBar Constructor
+	//param Orientation: false: Vertical scrollbar, true: Hortizonal scrollbar
+	CL_ScrollBar(
+		const CL_Rect &amp;pos,
+		int min,
+		int max,
+		bool orientation,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: ScrollBar Constructor
+	//param Orientation: false: Vertical scrollbar, true: Hortizonal scrollbar
+	CL_ScrollBar(
+		const CL_Rect &amp;pos,
+		bool orientation,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: ScrollBar Destructor
+	virtual ~CL_ScrollBar();
+
+//! Attributes:
+public:
+	//: Returns the orientation of the scroll bar.
+	//return: true if scrollbar is vertical, false otherwise.
+	bool is_vertical() const;
+
+	//: Returns true if tracking is enabled, or false if tracking is disabled. 
+	//: Tracking is initially enabled. See set_tracking for more info on tracking.
+	bool is_tracking() const;
+
+	//: Returns the current min value.
+	int get_min_value() const;
+
+	//: Returns the current max value.
+	int get_max_value() const;
+
+	//: Returns the range (delta max-min).
+	int get_range() const;
+
+	//: Returns the current range control value. 
+	int get_value() const;
+
+	//: Returns true if the user has clicked the mouse on the slider and is currently dragging it, or false if not. 
+	bool is_dragging_slider() const;
+	
+	//: Returns true if this is a fixed length slider, false otherwise.
+	bool is_fixed_length_slider() const;
+
+	//: Returns the scroll bar slider rectangle. 
+	CL_Rect &amp;get_slider_rect() const;
+
+	//: Returns the minimum size of the slider.
+	//: Only usable in variable-length sliders.
+	int get_min_slider_length() const;
+
+//! Operations:
+public:
+	//: Sets the length-mode of the slider.
+	//- &lt;p&gt;If enable is true, the slider is constant in size. (See set_slider_length()).
+	//- If enable is false, the slider is resized automatically based on the range.&lt;/p&gt;
+	void set_fixed_length_mode(bool enabel = true);
+
+	//: Sets the current size of the slider.
+	//: Only usable in fixed-length sliders.
+	void set_slider_length(int length);
+
+	//: Sets the minimum size of the slider.
+	//: Only usable in variable-length sliders.
+	void set_min_slider_length(int length);
+
+	//: Sets the scroll bar orientation to vertical if enable is true, horizontal otherwise.
+	void set_vertical(bool enable = true);
+
+	//: Enables scroll bar tracking if enable is true, or disables tracking if enable is false. 
+	//- &lt;p&gt;If tracking is enabled (the default), the scroll bar emits the
+	//- sig_value_changed() signal while the slider is being dragged. If tracking is
+	//- disabled, the scroll bar emits the sig_value_changed() only when the user
+	//- releases the mouse button after moving the slider.&lt;/p&gt;
+	void set_tracking(bool enable = true);
+
+	//: Sets the range between min_value and max_value. 
+	//: If max_value is smaller than min_value, max_value is set to min_value.
+	void set_range(int min_value, int max_value);
+
+	//: Sets the range to start from value. 
+	//: If current maximum value is less than the minvalue, maxvalue is set to minvalue.
+	void set_min_value(int value);
+
+	//: Sets the range to end at value. 
+	//: If current maximum value is less than the minvalue, maxvalue is set to minvalue.
+	void set_max_value(int value);
+
+	//: Sets the range controls value to value and forces it to be within the legal range. 
+	void set_value(int value);
+
+	//: Increases current value with step.
+	void increase(int step = 1);
+
+	//: Decreases current value with step.
+	void decrease(int step = 1);
+
+//! Signals:
+public:
+	//: This signal is emitted when the scroll bar value has changed, with the new scroll bar value as an argument. 
+	//: See set_tracking() for specifics on this signal.
+	CL_Signal_v1&lt;int&gt; &amp;sig_value_changed();
+
+	//: This signal is emitted when the user presses the slider with the mouse. 
+	CL_Signal_v0 &amp;sig_slider_pressed();
+
+	//: This signal is emitted when the slider is moved by the user, with the new scroll bar value as an argument. 
+	//: This signal is emitted even when tracking is turned off. 
+	CL_Signal_v1&lt;int&gt; &amp;sig_slider_moved();
+
+	//: This signal is emitted when the user releases the slider with the mouse. 
+	CL_Signal_v0 &amp;sig_slider_released();
+
+//! Implementation:
+private:
+	CL_ScrollBar(const CL_ScrollBar &amp;copy) : CL_Component(NULL, NULL) { return; } // disallow copy construction.
+	CL_ScrollBar_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/GUI/setupgui.h
===================================================================
--- trunk/clanlib/API/GUI/setupgui.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/setupgui.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,73 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;System&quot;
+//! header=gui.h
+
+#ifndef header_setupgui
+#define header_setupgui
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+//: Setup GUI Class
+//- !group=GUI/System!
+//- !header=gui.h!
+class CL_API_GUI CL_SetupGUI
+{
+//! Construction:
+public:
+	//: Initializes clanGUI.
+	//- &lt;p&gt;Constructing a CL_SetupGUI object is equalent to calling CL_SetupGUI::init().&lt;/p&gt;
+	//- &lt;p&gt;When the CL_SetupGUI instance is destroyed, CL_SetupGUI::deinit() is called.&lt;/p&gt;
+	CL_SetupGUI(bool register_resources_only = false);
+
+	~CL_SetupGUI();
+
+//! Operations:
+public:
+	//: Init the GUI.
+	static void init(bool register_resources_only = false);
+
+	//: Deinit the GUI.
+	static void deinit();
+};
+
+#endif

Added: trunk/clanlib/API/GUI/stylemanager.h
===================================================================
--- trunk/clanlib/API/GUI/stylemanager.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/stylemanager.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,104 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Framework&quot;
+//! header=gui.h
+
+#ifndef header_stylemanager
+#define header_stylemanager
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+
+class CL_DomElement;
+class CL_Component;
+class CL_ResourceManager;
+class CL_StyleManager_Generic;
+
+//: Manages the overall style of the system.
+//- !group=GUI/Framework!
+//- !header=gui.h!
+//- &lt;p&gt;The style manager is responsible of attaching CL_ComponentStyle objects to
+//- CL_Component objects.&lt;/p&gt;
+//- &lt;p&gt;When a component is constructed, it will contact its style manager's
+//- connect_styles() function. The style manager will then construct and attach
+//- component styles to the component.&lt;/p&gt;
+//- &lt;p&gt;The style manager also works as a 'component factory' for the component
+//- manager. By using create_component(), it is possible to create a component
+//- based on a name and component options describing it.&lt;/p&gt;
+class CL_API_GUI CL_StyleManager
+{
+//! Construction:
+public:
+	//: Construct a style manager using the specified resources.
+	CL_StyleManager(CL_ResourceManager *resources);
+
+	//: Destructor.
+	virtual ~CL_StyleManager();
+
+//! Attributes:
+public:
+	//: Returns style manager's resources.
+	CL_ResourceManager *get_resources();
+
+//! Overrideables:
+public:
+	//: Create a component based on a type name.
+	virtual CL_Component *create_component(
+		const std::string &amp;type,
+		CL_Component *parent);
+
+	//: Connect component styles to component.
+	//: The 'type' parameter indicates what type the component is.
+	virtual void connect_styles(
+		const std::string &amp;type,
+		CL_Component *owner)=0;
+
+//! Implementation:
+private:
+	// Disallow copy contruction of style managers.
+	CL_StyleManager(const CL_StyleManager &amp;copy) { return; }
+	
+	CL_StyleManager_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/GUI/treeitem.h
===================================================================
--- trunk/clanlib/API/GUI/treeitem.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/treeitem.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,129 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Controls&quot;
+//! header=gui.h
+
+#ifndef header_treeitem
+#define header_treeitem
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;component.h&quot;
+
+class CL_TreeItem_Generic;
+class CL_TreeNode;
+class CL_Surface;
+class CL_CheckBox;
+
+//: TreeView_Item component
+//- !group=GUI/Controls!
+//- !header=gui.h!
+class CL_API_GUI CL_TreeItem : public CL_Component
+{
+//! Construction:
+public:
+	//: TreeView Item Constructor
+	CL_TreeItem(
+		CL_TreeNode *node,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: TreeView Item Destructor
+	virtual ~CL_TreeItem();
+
+//! Attributes:
+public:
+	//: Returns the item text for a specified column.
+	//return: The item text.
+	const std::string &amp;get_text(int column = 0) const;
+
+	//: Returns the item component for a specified column.
+	//return: The item component.
+	CL_Component *get_component(int column = 0) const;
+
+	//: Returns the TreeView node this component is used in.
+	CL_TreeNode *get_node() const;
+
+	//: Return the icon.
+	CL_Surface *get_icon() const;
+
+	//: Get the margin between the start of the item and start of the text.
+	int get_text_margin(void) const;
+
+	//: Return the height.
+	int get_custom_height() const;
+
+//! Operations:
+public:
+	//: Sets the text for a specified column.
+	//param text: The column text.
+	void set_text(int column, const std::string &amp;text);
+
+	//: Adds a checkbox to a specified column.
+	CL_CheckBox *set_checkbox(int column, const std::string &amp;text = std::string());
+
+	//: Adds a component for a specified column.
+	void set_component(int column, CL_Component *component);
+
+	//: Sets the items icon.
+	//- &lt;p&gt;If 'delete_surface' is true, the surface will be deleted when the component is deleted.&lt;/p&gt;
+	void set_icon(CL_Surface *surface, bool delete_surface = false);
+
+	//: Set the margin between the start of the item and start of the text.
+	//: Use this to set a margin if you have no icon on this item, but on others.
+	void set_text_margin(int margin);
+
+	//: Sets the height.
+	void set_custom_height(int height);
+
+//! Signals:
+public:
+	//: This signal is emitted when the item is clicked on.
+	CL_Signal_v0 &amp;sig_clicked();
+
+//! Implementation:
+private:
+	CL_TreeItem(const CL_TreeItem &amp;copy) : CL_Component(NULL, NULL) { return; } // disallow copy construction.
+	CL_TreeItem_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/GUI/treenode.h
===================================================================
--- trunk/clanlib/API/GUI/treenode.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/treenode.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,197 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Controls&quot;
+//! header=gui.h
+
+#ifndef header_treenode
+#define header_treenode
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Core/Math/point.h&quot;
+#include &lt;string&gt;
+
+class CL_TreeItem;
+class CL_TreeView;
+class CL_TreeNode_Generic;
+class CL_Component;
+
+//: TreeView node
+//- !group=GUI/Controls!
+//- !header=gui.h!
+class CL_API_GUI CL_TreeNode
+{
+//! Construction:
+public:
+	//: The treenode constructor.
+	//- &lt;p&gt;Not to be constructed by user - use insert_item() instead, which
+	//- creates a CL_TreeNode.&lt;/p&gt;
+	CL_TreeNode(CL_TreeNode *parent, CL_TreeView *root_tree);
+	
+	virtual ~CL_TreeNode();
+
+//! Attributes:
+public:
+	//: Returns true if node is selectable.
+	bool is_selectable() const;
+
+	//: Returns true if node is collapsable.
+	bool is_collapsable() const;
+
+	//: Returns true if node is selected.
+	bool is_selected() const;
+	
+	//: Return true if node is collapsed.
+	bool is_collapsed() const;
+
+	//: Return true if node has sub-items.
+	bool has_children() const;
+
+	//: Returns true if node is root item.
+	bool is_root() const;
+
+	//: Returns the current selected item.
+	//: Note: This searches children as well.
+	CL_TreeNode *get_current_item() const;
+
+	//: Returns the attaches userdata, if any.
+	void *get_userdata() const;
+
+	//: Returns the CL_Component this node uses.
+	CL_Component *get_component() const;
+
+	//: Returns the CL_TreeView this node belongs to.
+	CL_TreeView *get_treeview() const;
+
+	//: Returns the parent node.
+	CL_TreeNode *get_parent() const;
+
+	//: Returns the depth of this node. Root node starts at 1.
+	int get_depth() const;
+
+	//: Returns the x offset the component is located at.
+	//: Used by themes to align columns correctly.
+	int get_placement_offset() const;
+
+	//: Returns the height of all opened items.
+	int get_items_height() const;
+
+//! Operations:
+public:
+	//: Inserts a child item. 
+	CL_TreeItem *insert_item(
+		const std::string &amp;label1, 
+		const std::string &amp;label2 = std::string(),
+		const std::string &amp;label3 = std::string(),
+		const std::string &amp;label4 = std::string(),
+		const std::string &amp;label5 = std::string(),
+		const std::string &amp;label6 = std::string(),
+		const std::string &amp;label7 = std::string(),
+		const std::string &amp;label8 = std::string());
+
+	//: Inserts a child item. 
+	//: It takes ownership of the components, and deletes them on shutdown.
+	CL_TreeNode *insert_item(
+		CL_Component *component1, 
+		CL_Component *component2 = NULL, 
+		CL_Component *component3 = NULL, 
+		CL_Component *component4 = NULL, 
+		CL_Component *component5 = NULL, 
+		CL_Component *component6 = NULL, 
+		CL_Component *component7 = NULL, 
+		CL_Component *component8 = NULL);
+
+	//: Removes an item from tree.
+	//: Note that it searches children as well for the item.
+	//: Returns true if item was found and deleted.
+	bool remove_item(CL_TreeNode *node);
+
+	//: Sets/changes a new component for the node.
+	//: It takes ownership of the component, and deletes it on shutdown.
+	void set_component(CL_Component *component);
+
+	//: Collapse this node.
+	void set_collapsed(bool collapse = true);
+	
+	//: Set the tree to collapsable or not.
+	//: If set to false, item will never be collapsable by the user.
+	void set_collapsable(bool enable = true);
+	
+	//: Set the tree to selectable or not.
+	//: If set to false, item will never be selectable by the user.
+	void set_selectable(bool enable = true);
+
+	//: Select this node.
+	void set_selected(bool select = true);
+
+	//: Select any of the children nodes.
+	void set_selected(CL_TreeNode *node, bool select = true);
+
+	//: Deselects current selected item.
+	void clear_selection();
+
+	//: Inverts the selection.
+	//: Works only in Multi selection mode.
+	void invert_selection();
+
+	//: Deletes all items in the tree.
+	void clear();
+
+	//: Attaches userdata to node.
+	void set_userdata(void *data);
+
+	//: Set the x offset the component is located at.
+	//: Used by themes to align columns correctly.
+	void set_placement_offset(int offset);
+
+void draw_nodes(CL_Point &amp;point);
+
+//! Implementation:
+private:
+	CL_TreeNode(const CL_TreeNode &amp;copy) { return; } // disallow copy construction.
+	CL_TreeNode_Generic *impl;
+
+	friend class CL_TreeView_Generic;
+	friend class CL_TreeNode_Generic;
+};
+
+#endif

Added: trunk/clanlib/API/GUI/treeview.h
===================================================================
--- trunk/clanlib/API/GUI/treeview.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/treeview.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,151 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Controls&quot;
+//! header=gui.h
+
+#ifndef header_treeview
+#define header_treeview
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;component.h&quot;
+#include &quot;treenode.h&quot;
+
+class CL_TreeView_Generic;
+
+//: TreeView component
+//- !group=GUI/Controls!
+//- !header=gui.h!
+class CL_API_GUI CL_TreeView : public CL_Component, public CL_TreeNode
+{
+//! Construction:
+public:
+	//: TreeView Constructor
+	CL_TreeView(
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+	
+	//: TreeView Constructor
+	CL_TreeView(
+		const CL_Rect &amp;pos,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: TreeView Destructor
+	virtual ~CL_TreeView();
+
+//! Attributes:
+public:
+	//: Returns the column count.
+	int get_column_count() const;
+
+	//: Returns the column width at index.
+	//: Index starts at 0.
+	int get_column_width(int index) const;
+
+	//: Returns the column name at index.
+	//: Index starts at 0.
+	const std::string &amp;get_column_name(int index) const;
+
+	//: Returns if root decoration is visible or not.
+	bool is_root_decoration_visible() const;
+
+	//: Returns if header is visible or not.
+	bool is_header_visible() const;
+
+//! Operations:
+public:
+	//: Add a column.
+	int add_column(const std::string &amp;name, int width);
+
+	//: Show or hide root decoration for items.
+	void show_root_decoration(bool enable = true);
+
+	//: Show or hide columns.
+	void show_header(bool enable = true);
+
+//! Signals:
+public:
+	//: This signal is emitted when the selection set of a tree changes.
+	CL_Signal_v1&lt;const CL_TreeNode &amp;&gt; &amp;sig_selection_changed();
+
+	//: This signal is emitted when an item is clicked / selected.
+	CL_Signal_v1&lt;const CL_TreeNode &amp;&gt; &amp;sig_item_clicked();
+
+	//: This signal is emitted when a new item is added to the treeview.
+	CL_Signal_v1&lt;const CL_TreeNode &amp;&gt; &amp;sig_item_added();
+
+	//: This signal is emitted when an item is removed from the treeview.
+	CL_Signal_v1&lt;const CL_TreeNode &amp;&gt; &amp;sig_item_removed();
+	
+	//: This signal is emitted when an item is collapsed.
+	CL_Signal_v1&lt;const CL_TreeNode &amp;&gt; &amp;sig_item_collapsed();
+
+	//: This signal is emitted when an item is collapsed.
+	CL_Signal_v1&lt;const CL_TreeNode &amp;&gt; &amp;sig_item_expanded();
+	
+	//: This signal is emitted when a new column is added to the treeview.
+	CL_Signal_v1&lt;int&gt; &amp;sig_column_added();
+
+	//: This signal is emitted when an column is removed from the treeview.
+	CL_Signal_v1&lt;int&gt; &amp;sig_column_removed();
+	
+	//: This signal is emitted when the treeview is cleared.
+	CL_Signal_v0 &amp;sig_clear();
+
+	//: Draws the node (used by styles).
+	CL_Signal_v2&lt;CL_TreeNode *, CL_Point &amp;&gt; &amp;sig_paint_node();
+
+//! Implementation:
+protected:
+	friend class CL_TreeNode_Generic;
+	void add_node_to_delete_list(CL_TreeNode *pNode);
+	void clear_delete_list();
+	std::list&lt;CL_TreeNode *&gt; node_delete_list;
+
+private:
+	
+	CL_TreeView(const CL_TreeView &amp;copy) : CL_Component(NULL, NULL), CL_TreeNode(NULL, NULL) { return; } // disallow copy construction.
+	CL_TreeView_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/GUI/window.h
===================================================================
--- trunk/clanlib/API/GUI/window.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUI/window.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,145 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    Kenneth Gangst&#248;
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Controls&quot;
+//! header=gui.h
+
+#ifndef header_window
+#define header_window
+
+#ifdef CL_API_DLL
+#ifdef CL_GUI_EXPORT
+#define CL_API_GUI __declspec(dllexport)
+#else
+#define CL_API_GUI __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUI
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;component.h&quot;
+
+class CL_Window_Generic;
+
+//: Window component
+//- !group=GUI/Controls!
+//- !header=gui.h!
+class CL_API_GUI CL_Window : public CL_Component
+{
+//! Enums:
+public:
+	//: Button enums
+	enum TitlebarButtons
+	{
+		no_buttons = 0,
+		close_button = 1,
+		maximize_button = 2,
+		minimize_button = 4,
+		help_button = 8
+	};
+
+//! Construction:
+public:
+	//: Creates a window.
+	CL_Window(
+		int button_enum, 
+		CL_Component *parent, 
+		CL_StyleManager *style = NULL);
+
+	CL_Window(
+		const std::string &amp;title,
+		int button_enum, 
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	CL_Window(
+		const CL_Rect &amp;pos,
+		const std::string &amp;title,
+		int button_enum, 
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	CL_Window(
+		CL_Component *parent, 
+		CL_StyleManager *style = NULL);
+
+	CL_Window(
+		const std::string &amp;title,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	CL_Window(
+		const CL_Rect &amp;pos,
+		const std::string &amp;title,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+
+	//: Window destructor
+	virtual ~CL_Window();
+
+//! Attributes:
+public:
+	//: Returns the window title.
+	const std::string &amp;get_title() const;
+
+	//: Returns the titlebar button enum.
+	TitlebarButtons get_titlebar_buttons_enum() const;
+
+//! Operations:
+public:
+	//: Sets the window title.
+	//param text: An std::string with the new title
+	void set_title(const std::string &amp;text);
+
+//! Signals:
+public:
+	//: This signal is emitted when the close button on the titlebar is activated
+	CL_Signal_v0 &amp;sig_close_button_clicked();
+
+	//: This signal is emitted when the minimize button on the titlebar is activated
+	CL_Signal_v0 &amp;sig_minimize_button_clicked();
+
+	//: This signal is emitted when the maximize button on the titlebar is activated
+	CL_Signal_v0 &amp;sig_maximize_button_clicked();
+
+	//: This signal is emitted when the help button on the titlebar is activated
+	CL_Signal_v0 &amp;sig_help_button_clicked();
+
+//! Implementation:
+private:
+	CL_Window(const CL_Window &amp;copy) : CL_Component(NULL, NULL) { return; } // disallow copy construction.
+	CL_Window_Generic *impl;
+};  
+
+#endif

Added: trunk/clanlib/API/GUIStyleSilver/button_silver.h
===================================================================
--- trunk/clanlib/API/GUIStyleSilver/button_silver.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUIStyleSilver/button_silver.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,147 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    Kenneth Gangst&#248;
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Style: Silver&quot;
+//! header=guistylesilver.h
+
+#ifndef header_button_silver
+#define header_button_silver
+
+#ifdef CL_API_DLL
+#ifdef CL_GUISTYLESILVER_EXPORT
+#define CL_API_GUISTYLESILVER __declspec(dllexport)
+#else
+#define CL_API_GUISTYLESILVER __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUISTYLESILVER
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../GUI/button.h&quot;
+#include &quot;../GUI/component_style.h&quot;
+
+class CL_Font;
+class CL_Surface;
+class CL_StyleManager_Silver;
+
+//: Button default style.
+//- !group=GUI/Style: Silver!
+//- !header=guistylesilver.h!
+//- &lt;p&gt;Script attributes:&lt;/p&gt;
+//- &lt;ul&gt;
+//- &lt;li&gt;surface_up: The surface used when button is in the up-state. [String]&lt;/li&gt;
+//- &lt;li&gt;surface_down: The surface used when button is in the down-state. [String]&lt;/li&gt;
+//- &lt;li&gt;surface_disabled: The surface used when button is disabled. [String]&lt;/li&gt;
+//- &lt;li&gt;surface_highlighted: The surface used when button is highlighted. [String]&lt;/li&gt;
+//- &lt;li&gt;font: The font used to draw the label. [String]&lt;/li&gt;
+//- &lt;li&gt;font_disabled: The font used to draw the label in disabled mode. [String]&lt;/li&gt;
+//- &lt;/ul&gt;
+//- &lt;p&gt;Note that it inherits the attributes of CL_Button and CL_Component as well.&lt;/p&gt;
+class CL_API_GUISTYLESILVER CL_Button_Silver : public CL_ComponentStyle
+{
+//! Construction:
+public:
+	//: Constructor
+	CL_Button_Silver(
+		CL_Button *button,
+		CL_StyleManager_Silver *style);
+
+	//: Destructor
+	virtual ~CL_Button_Silver();
+
+//! Operations:
+public:
+	//: Sets the font used to draw the label.
+	//- &lt;p&gt;If 'delete_font' is true, the font will be deleted when the component is deleted.&lt;/p&gt;
+	void set_font(CL_Font *font, bool delete_font = false);
+
+	//: Sets the font used to draw the label in disabled mode.
+	//- &lt;p&gt;If 'delete_font' is true, the font will be deleted when the component is deleted.&lt;/p&gt;
+	void set_font_disabled(CL_Font *font, bool delete_font = false);
+	
+	//: Sets the surface used when button is in the up-state.
+	//- &lt;p&gt;If 'delete_surface' is true, the surface will be deleted when the component is deleted.&lt;/p&gt;
+	void set_surface_up(CL_Surface *surface, bool delete_surface = false);
+
+	//: Set the surface used when button is in the down-state.
+	//- &lt;p&gt;If 'delete_surface' is true, the surface will be deleted when the component is deleted.&lt;/p&gt;
+	void set_surface_down(CL_Surface *surface, bool delete_surface = false);
+
+	//: Sets the surface used when button is highlighted.
+	//- &lt;p&gt;If 'delete_surface' is true, the surface will be deleted when the component is deleted.&lt;/p&gt;
+	void set_surface_highlighted(CL_Surface *surface, bool delete_surface = false);
+
+	//: Sets the surface used when button is disabled.
+	//- &lt;p&gt;If 'delete_surface' is true, the surface will be deleted when the component is deleted.&lt;/p&gt;
+	void set_surface_disabled(CL_Surface *surface, bool delete_surface = false);
+
+	//: Selects if the surfaces should be drawn alone, or with the normal frames.
+	void set_surface_draw_only(bool enable = true);
+
+//! Implementation:
+private:
+	void on_set_options(const CL_DomElement &amp;options);
+	CL_Slot slot_set_options;
+
+	void on_paint();
+	CL_Slot slot_paint;
+
+	void on_get_preferred_size(CL_Size &amp;size);
+	CL_Slot slot_get_preferred_size;
+
+	CL_Button *button;
+	
+	CL_StyleManager_Silver *style;
+	CL_ResourceManager *resources;
+
+	CL_Font *font;
+	CL_Font *font_disabled;
+
+	bool delete_font;
+	bool delete_font_disabled;
+	
+	CL_Surface *sur_up;
+	CL_Surface *sur_down;
+	CL_Surface *sur_highlighted;
+	CL_Surface *sur_disabled;
+
+	bool draw_only_surfaces;
+
+	bool delete_sur_up;
+	bool delete_sur_down;
+	bool delete_sur_highlighted;
+	bool delete_sur_disabled;
+};
+
+#endif

Added: trunk/clanlib/API/GUIStyleSilver/checkbox_silver.h
===================================================================
--- trunk/clanlib/API/GUIStyleSilver/checkbox_silver.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUIStyleSilver/checkbox_silver.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,144 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Style: Silver&quot;
+//! header=guistylesilver.h
+
+#ifndef header_checkbox_silver
+#define header_checkbox_silver
+
+#ifdef CL_API_DLL
+#ifdef CL_GUISTYLESILVER_EXPORT
+#define CL_API_GUISTYLESILVER __declspec(dllexport)
+#else
+#define CL_API_GUISTYLESILVER __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUISTYLESILVER
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../GUI/checkbox.h&quot;
+#include &quot;../GUI/component_style.h&quot;
+#include &quot;checkbox_silver.h&quot;
+
+class CL_Font;
+class CL_Surface;
+class CL_StyleManager_Silver;
+
+//: CheckBox default style.
+//- !group=GUI/Style: Silver!
+//- !header=guistylesilver.h!
+//- &lt;p&gt;Script attributes:&lt;/p&gt;
+//- &lt;ul&gt;
+//- &lt;li&gt;surface_checked: The surface used when button is checked. [String]&lt;/li&gt;
+//- &lt;li&gt;surface_unchecked: The surface used when button is unchecked. [String]&lt;/li&gt;
+//- &lt;li&gt;surface_checked_disabled: The surface used when button is checked, but disabled. [String]&lt;/li&gt;
+//- &lt;li&gt;surface_unchecked_disabled: The surface used when button is unchecked and disabled. [String]&lt;/li&gt;
+//- &lt;li&gt;font: The font used to draw the label. [String]&lt;/li&gt;
+//- &lt;/ul&gt;
+//- &lt;p&gt;Note that it inherits the attributes of CL_CheckBox, CL_Button and CL_Component as well.&lt;/p&gt;
+class CL_API_GUISTYLESILVER CL_CheckBox_Silver : public CL_ComponentStyle
+{
+//! Construction:
+public:
+	//: Constructor
+	CL_CheckBox_Silver(
+		CL_CheckBox *checkbox,
+		CL_StyleManager_Silver *style);
+		
+	//: Destructor
+	virtual ~CL_CheckBox_Silver();
+
+//! Attributes:
+public:
+
+//! Operations:
+public:
+	//: Sets the font used to draw the label.
+	//- &lt;p&gt;If 'delete_font' is true, the font will be deleted when the component is deleted.&lt;/p&gt;
+	void set_font(CL_Font *font, bool delete_font = false);
+
+	//: Sets the font used to draw the label in disabled mode.
+	//- &lt;p&gt;If 'delete_font' is true, the font will be deleted when the component is deleted.&lt;/p&gt;
+	void set_font_disabled(CL_Font *font, bool delete_font = false);
+
+	//: Sets the surface used when button is in the up-state.
+	//- &lt;p&gt;If 'delete_surface' is true, the surface will be deleted when the component is deleted.&lt;/p&gt;
+	void set_surface_checked(CL_Surface *surface, bool delete_surface = false);
+
+	//: Set the surface used when button is in the down-state.
+	//- &lt;p&gt;If 'delete_surface' is true, the surface will be deleted when the component is deleted.&lt;/p&gt;
+	void set_surface_unchecked(CL_Surface *surface, bool delete_surface = false);
+
+	//: Sets the surface used when button is highlighted.
+	//- &lt;p&gt;If 'delete_surface' is true, the surface will be deleted when the component is deleted.&lt;/p&gt;
+	void set_surface_checked_disabled(CL_Surface *surface, bool delete_surface = false);
+
+	//: Sets the surface used when button is disabled.
+	//- &lt;p&gt;If 'delete_surface' is true, the surface will be deleted when the component is deleted.&lt;/p&gt;
+	void set_surface_unchecked_disabled(CL_Surface *surface, bool delete_surface = false);
+
+//! Implementation:
+private:
+	void on_set_options(const CL_DomElement &amp;options);
+	CL_Slot slot_set_options;
+
+	void on_get_preferred_size(CL_Size &amp;size);
+	CL_Slot slot_get_preferred_size;
+
+	void on_paint(CL_SlotParent_v0 &amp;super);
+	CL_Slot slot_paint;
+
+	CL_CheckBox *checkbox;
+
+	CL_StyleManager_Silver *style;
+	CL_ResourceManager *resources;
+	
+	CL_Font *font;
+	CL_Font *font_disabled;
+	bool delete_font;
+	bool delete_font_disabled;
+
+	CL_Surface *sur_checked;
+	CL_Surface *sur_unchecked;
+	CL_Surface *sur_checked_disabled;
+	CL_Surface *sur_unchecked_disabled;
+
+	bool delete_sur_checked;
+	bool delete_sur_unchecked;
+	bool delete_sur_checked_disabled;
+	bool delete_sur_unchecked_disabled;
+};
+
+#endif
+

Added: trunk/clanlib/API/GUIStyleSilver/frame_silver.h
===================================================================
--- trunk/clanlib/API/GUIStyleSilver/frame_silver.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUIStyleSilver/frame_silver.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,95 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Style: Silver&quot;
+//! header=guistylesilver.h
+
+#ifndef header_frame_silver
+#define header_frame_silver
+
+#ifdef CL_API_DLL
+#ifdef CL_GUISTYLESILVER_EXPORT
+#define CL_API_GUISTYLESILVER __declspec(dllexport)
+#else
+#define CL_API_GUISTYLESILVER __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUISTYLESILVER
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../GUI/frame.h&quot;
+#include &quot;../GUI/component_style.h&quot;
+
+class CL_Surface;
+class CL_StyleManager_Silver;
+
+//: Frame default style.
+//- !group=GUI/Style: Silver!
+//- !header=guistylesilver.h!
+class CL_API_GUISTYLESILVER CL_Frame_Silver : public CL_ComponentStyle
+{
+//! Construction:
+public:
+	//: Constructor
+	CL_Frame_Silver(
+		CL_Frame *frame, 
+		CL_StyleManager_Silver *style);
+
+	//: Destructor
+	virtual ~CL_Frame_Silver();
+
+//! Implementation:
+private:
+	CL_Slot slot_set_options;
+	CL_Slot slot_paint;
+	CL_Slot slot_resize;
+
+	void on_set_options(const CL_DomElement &amp;options);
+	void on_paint();
+	void on_resize(int old_width, int old_height);
+
+	CL_Frame *frame;
+
+	enum Mode
+	{
+		center,
+		stretch,
+		tile
+	} mode;
+	
+	CL_StyleManager_Silver *style;
+	CL_ResourceManager *resources;
+	CL_Surface *sur_surface;
+};
+
+#endif

Added: trunk/clanlib/API/GUIStyleSilver/image_silver.h
===================================================================
--- trunk/clanlib/API/GUIStyleSilver/image_silver.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUIStyleSilver/image_silver.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,84 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Style: Silver&quot;
+//! header=guistylesilver.h
+
+#ifndef header_image_silver
+#define header_image_silver
+
+#ifdef CL_API_DLL
+#ifdef CL_GUISTYLESILVER_EXPORT
+#define CL_API_GUISTYLESILVER __declspec(dllexport)
+#else
+#define CL_API_GUISTYLESILVER __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUISTYLESILVER
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../GUI/image.h&quot;
+#include &quot;../GUI/component_style.h&quot;
+
+class CL_Surface;
+class CL_StyleManager_Silver;
+
+//: Image default style.
+//- !group=GUI/Style: Silver!
+//- !header=guistylesilver.h!
+class CL_API_GUISTYLESILVER CL_Image_Silver : public CL_ComponentStyle
+{
+//! Construction:
+public:
+	//: Constructor
+	CL_Image_Silver(
+		CL_Image *image, 
+		CL_StyleManager_Silver *style);
+
+	//: Destructor
+	virtual ~CL_Image_Silver() {}
+
+//! Implementation:
+private:
+	CL_Slot slot_paint;
+	CL_Slot slot_get_preferred_size;
+
+	void on_paint();
+	void on_get_preferred_size(CL_Size &amp;size);
+
+	CL_Image *image;
+
+	CL_ResourceManager *resources;
+};
+
+#endif

Added: trunk/clanlib/API/GUIStyleSilver/inputbox_silver.h
===================================================================
--- trunk/clanlib/API/GUIStyleSilver/inputbox_silver.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUIStyleSilver/inputbox_silver.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,103 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Style: Silver&quot;
+//! header=guistylesilver.h
+
+#ifndef header_inputbox_silver
+#define header_inputbox_silver
+
+#ifdef CL_API_DLL
+#ifdef CL_GUISTYLESILVER_EXPORT
+#define CL_API_GUISTYLESILVER __declspec(dllexport)
+#else
+#define CL_API_GUISTYLESILVER __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUISTYLESILVER
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../GUI/inputbox.h&quot;
+#include &quot;../GUI/component_style.h&quot;
+
+class CL_Font;
+class CL_StyleManager_Silver;
+
+//: InputBox default style.
+//- !group=GUI/Style: Silver!
+//- !header=guistylesilver.h!
+class CL_API_GUISTYLESILVER CL_InputBox_Silver : public CL_ComponentStyle
+{
+//! Construction:
+public:
+	//: Constructor
+	CL_InputBox_Silver(
+		CL_InputBox *inputbox,
+		CL_StyleManager_Silver *style);
+	
+	//: Destructor
+	virtual ~CL_InputBox_Silver();
+
+//! Operations:
+public:
+	//: Sets the size of the border around inputbox.
+	void set_border_size(int size);
+
+//! Implementation:
+private:
+	CL_Slot slot_paint;
+	void on_paint();
+
+	CL_Slot slot_activity;
+	void on_activity();
+	CL_Slot slot_get_preferred_size;
+	void on_get_preferred_size(CL_Size &amp;size);
+
+	CL_InputBox *inputbox;
+
+	CL_StyleManager_Silver *style;
+	CL_ResourceManager *resources;
+	CL_Font *font;
+	CL_Font *font_disabled;
+
+	int character_offset;
+
+	bool show_cursor;
+	unsigned int cursor_blink_time;
+
+	int border_size;
+	
+//	int get_mouse_position(int x, int y);
+};
+
+#endif

Added: trunk/clanlib/API/GUIStyleSilver/label_silver.h
===================================================================
--- trunk/clanlib/API/GUIStyleSilver/label_silver.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUIStyleSilver/label_silver.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,87 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Style: Silver&quot;
+//! header=guistylesilver.h
+
+#ifndef header_label_silver
+#define header_label_silver
+
+#ifdef CL_API_DLL
+#ifdef CL_GUISTYLESILVER_EXPORT
+#define CL_API_GUISTYLESILVER __declspec(dllexport)
+#else
+#define CL_API_GUISTYLESILVER __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUISTYLESILVER
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../GUI/label.h&quot;
+#include &quot;../GUI/component_style.h&quot;
+
+class CL_StyleManager_Silver;
+class CL_Font;
+
+//: Label default style.
+//- !group=GUI/Style: Silver!
+//- !header=guistylesilver.h!
+class CL_API_GUISTYLESILVER CL_Label_Silver : public CL_ComponentStyle
+{
+//! Construction:
+public:
+	//: Constructor
+	CL_Label_Silver(
+		CL_Label *label,
+		CL_StyleManager_Silver *style);
+
+	//: Destructor
+	virtual ~CL_Label_Silver();
+
+//! Implementation:
+private:
+	CL_Slot slot_paint;
+	CL_Slot slot_get_preferred_size;
+	CL_Slot slot_font_change;
+
+	void on_paint();
+	void on_get_preferred_size(CL_Size &amp;size);
+	void on_font_change();
+
+	CL_Label *label;
+	
+	CL_ResourceManager *resources;
+	CL_Font *font;
+};
+
+#endif

Added: trunk/clanlib/API/GUIStyleSilver/listbox_silver.h
===================================================================
--- trunk/clanlib/API/GUIStyleSilver/listbox_silver.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUIStyleSilver/listbox_silver.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,98 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Style: Silver&quot;
+//! header=guistylesilver.h
+
+#ifndef header_listbox_silver
+#define header_listbox_silver
+
+#ifdef CL_API_DLL
+#ifdef CL_GUISTYLESILVER_EXPORT
+#define CL_API_GUISTYLESILVER __declspec(dllexport)
+#else
+#define CL_API_GUISTYLESILVER __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUISTYLESILVER
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../GUI/listbox.h&quot;
+#include &quot;../GUI/component_style.h&quot;
+
+class CL_StyleManager_Silver;
+class CL_Font;
+class CL_ScrollBar;
+
+//: ListBox default style.
+//- !group=GUI/Style: Silver!
+//- !header=guistylesilver.h!
+class CL_API_GUISTYLESILVER CL_ListBox_Silver : public CL_ComponentStyle
+{
+//! Construction:
+public:
+	//: Constructor
+	CL_ListBox_Silver(
+		CL_ListBox *listbox,
+		CL_StyleManager_Silver *style);
+	
+	//: Destructor
+	virtual ~CL_ListBox_Silver();
+
+//! Implementation:
+private:
+	CL_SlotContainer slots;
+	
+	void on_mouse_down(const CL_InputEvent &amp;key);
+	void on_set_options(const CL_DomElement &amp;options);
+	void on_scroll_change(int new_offset);
+	void on_resize(int old_width, int old_height);
+	void on_paint_background();
+	void on_paint_listbox();
+	void on_item_added(int index);
+	void on_item_removed(int index);
+	void on_clear();
+	
+	void update_scrollbar(bool resize);
+
+	CL_ListBox *listbox;
+
+	CL_ScrollBar *scrollbar;
+	bool visible_scrollbar;
+
+	CL_StyleManager_Silver *style;
+	CL_ResourceManager *resources;
+	CL_Font *font;
+};
+
+#endif

Added: trunk/clanlib/API/GUIStyleSilver/menu_item_silver.h
===================================================================
--- trunk/clanlib/API/GUIStyleSilver/menu_item_silver.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUIStyleSilver/menu_item_silver.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,104 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Style: Silver&quot;
+//! header=guistylesilver.h
+
+#ifndef header_menu_item_silver
+#define header_menu_item_silver
+
+#ifdef CL_API_DLL
+#ifdef CL_GUISTYLESILVER_EXPORT
+#define CL_API_GUISTYLESILVER __declspec(dllexport)
+#else
+#define CL_API_GUISTYLESILVER __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUISTYLESILVER
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../GUI/menu_item.h&quot;
+#include &quot;../GUI/component_style.h&quot;
+
+class CL_StyleManager_Silver;
+class CL_Font;
+
+//: MenuItem default style.
+//- !group=GUI/Style: Silver!
+//- !header=guistylesilver.h!
+class CL_API_GUISTYLESILVER CL_MenuItem_Silver : public CL_ComponentStyle
+{
+//! Construction:
+public:
+	//: Constructor
+	CL_MenuItem_Silver(
+		CL_MenuItem *label,
+		CL_StyleManager_Silver *style);
+
+	//: Destructor
+	virtual ~CL_MenuItem_Silver();
+
+//! Operations:
+public:
+	//: Sets the menu items icon
+	//- &lt;p&gt;If 'delete_surface' is true, the surface will be deleted when the component is deleted.&lt;/p&gt;
+	void set_icon(CL_Surface *surface, bool delete_surface = false);
+
+//! Implementation:
+private:
+	void on_paint();
+
+	void on_get_preferred_size(CL_Size &amp;size);
+
+	CL_Slot slot_paint;
+
+	CL_Slot slot_get_preferred_size;
+
+	CL_MenuItem *menu_item;
+	
+	CL_ResourceManager *resources;
+
+	CL_Font *font;
+
+	CL_Font *font_disabled;
+
+	CL_Surface *sur_icon;
+
+	CL_Surface *sur_checked;
+
+	CL_Surface *sur_unchecked;
+
+	bool delete_sur_icon;
+};
+
+#endif

Added: trunk/clanlib/API/GUIStyleSilver/menu_node_silver.h
===================================================================
--- trunk/clanlib/API/GUIStyleSilver/menu_node_silver.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUIStyleSilver/menu_node_silver.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,97 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Style: Silver&quot;
+//! header=guistylesilver.h
+
+#ifndef header_menu_node_silver
+#define header_menu_node_silver
+
+#ifdef CL_API_DLL
+#ifdef CL_GUISTYLESILVER_EXPORT
+#define CL_API_GUISTYLESILVER __declspec(dllexport)
+#else
+#define CL_API_GUISTYLESILVER __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUISTYLESILVER
+#endif
+
+//#include &quot;../core.h&quot;
+//#include &quot;../gui.h&quot;
+
+#include &quot;../GUI/menu_node.h&quot;
+#include &quot;../GUI/component_style.h&quot;
+
+class CL_StyleManager_Silver;
+class CL_Surface;
+
+//: MenuNode default style.
+//- !group=GUI/Style: Silver!
+//- !header=guistylesilver.h!
+class CL_API_GUISTYLESILVER CL_MenuNode_Silver : public CL_ComponentStyle
+{
+//! Construction:
+public:
+	//: Constructor
+	CL_MenuNode_Silver(
+		CL_MenuNode *node,
+		CL_StyleManager_Silver *style);
+
+	//: Destructor
+	virtual ~CL_MenuNode_Silver();
+
+//! Implementation:
+private:
+	void on_set_options(const CL_DomElement &amp;options);
+
+	void on_paint();
+
+	void on_pressed();
+
+	void on_released();
+
+	void on_reposition();
+
+	void on_get_preferred_size(CL_Size &amp;size);
+
+	CL_SlotContainer slots;
+
+	CL_MenuNode *node;
+	
+	CL_StyleManager_Silver *style;
+
+	CL_ResourceManager *resources;
+
+	CL_Surface *arrow;
+	
+	bool down;
+};
+
+#endif

Added: trunk/clanlib/API/GUIStyleSilver/menu_silver.h
===================================================================
--- trunk/clanlib/API/GUIStyleSilver/menu_silver.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUIStyleSilver/menu_silver.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,86 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Style: Silver&quot;
+//! header=guistylesilver.h
+
+#ifndef header_menu_silver
+#define header_menu_silver
+
+#ifdef CL_API_DLL
+#ifdef CL_GUISTYLESILVER_EXPORT
+#define CL_API_GUISTYLESILVER __declspec(dllexport)
+#else
+#define CL_API_GUISTYLESILVER __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUISTYLESILVER
+#endif
+
+#include &quot;../GUI/menu.h&quot;
+#include &quot;../GUI/component_style.h&quot;
+
+class CL_StyleManager_Silver;
+class CL_Menu;
+
+//: Menu default style.
+//- !group=GUI/Style: Silver!
+//- !header=guistylesilver.h!
+class CL_API_GUISTYLESILVER CL_Menu_Silver : public CL_ComponentStyle
+{
+//! Construction:
+public:
+	//: Constructor
+	CL_Menu_Silver(
+		CL_Menu *menu,
+		CL_StyleManager_Silver *style);
+
+	//: Destructor
+	virtual ~CL_Menu_Silver();
+
+//! Implementation:
+private:
+	void on_set_options(const CL_DomElement &amp;options);
+
+	void on_paint();
+
+	void on_reposition(int,int);
+
+	void on_parent_resize(int,int);
+
+	CL_SlotContainer slots;
+
+	CL_Menu *menu;
+	
+	CL_StyleManager_Silver *style;
+	
+	bool repositioned;
+};
+
+#endif

Added: trunk/clanlib/API/GUIStyleSilver/progressbar_silver.h
===================================================================
--- trunk/clanlib/API/GUIStyleSilver/progressbar_silver.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUIStyleSilver/progressbar_silver.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,85 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Style: Silver&quot;
+//! header=guistylesilver.h
+
+#ifndef header_progressbar_silver
+#define header_progressbar_silver
+
+#ifdef CL_API_DLL
+#ifdef CL_GUISTYLESILVER_EXPORT
+#define CL_API_GUISTYLESILVER __declspec(dllexport)
+#else
+#define CL_API_GUISTYLESILVER __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUISTYLESILVER
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../GUI/progressbar.h&quot;
+#include &quot;../GUI/component_style.h&quot;
+
+class CL_StyleManager_Silver;
+class CL_ResourceManager;
+
+//: ProgressBar default style.
+//- !group=GUI/Style: Silver!
+//- !header=guistylesilver.h!
+class CL_API_GUISTYLESILVER CL_ProgressBar_Silver : public CL_ComponentStyle
+{
+//! Construction:
+public:
+	//: Constructor
+	CL_ProgressBar_Silver(
+		CL_ProgressBar *progressbar,
+		CL_StyleManager_Silver *style);
+	
+	//: Destructor
+	virtual ~CL_ProgressBar_Silver() {};
+
+//! Implementation:
+private:
+	void on_paint();
+
+	CL_Slot slot_paint;
+
+	CL_StyleManager_Silver *style;
+	CL_ProgressBar *progressbar;
+
+	CL_Surface *sur_foreground;
+	CL_Surface *sur_background;
+};
+
+#endif
+

Added: trunk/clanlib/API/GUIStyleSilver/radiobutton_silver.h
===================================================================
--- trunk/clanlib/API/GUIStyleSilver/radiobutton_silver.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUIStyleSilver/radiobutton_silver.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,93 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Style: Silver&quot;
+//! header=guistylesilver.h
+
+#ifndef header_radiobutton_silver
+#define header_radiobutton_silver
+
+#ifdef CL_API_DLL
+#ifdef CL_GUISTYLESILVER_EXPORT
+#define CL_API_GUISTYLESILVER __declspec(dllexport)
+#else
+#define CL_API_GUISTYLESILVER __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUISTYLESILVER
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../GUI/radiobutton.h&quot;
+#include &quot;../GUI/component_style.h&quot;
+
+class CL_Font;
+class CL_Surface;
+class CL_StyleManager_Silver;
+
+//: RadioButton default style.
+//- !group=GUI/Style: Silver!
+//- !header=guistylesilver.h!
+class CL_API_GUISTYLESILVER CL_RadioButton_Silver : public CL_ComponentStyle
+{
+//! Construction:
+public:
+	//: Constructor
+	CL_RadioButton_Silver(
+		CL_RadioButton *radiobutton,
+		CL_StyleManager_Silver *style);
+		
+	//: Desstructor
+	virtual ~CL_RadioButton_Silver();
+
+//! Implementation:
+private:
+	void on_get_preferred_size(CL_Size &amp;size);
+	CL_Slot slot_get_preferred_size;
+
+	void on_paint(CL_SlotParent_v0 &amp;super);
+	CL_Slot slot_paint;
+
+	CL_RadioButton *radiobutton;
+
+	CL_StyleManager_Silver *style;
+	CL_ResourceManager *resources;
+	
+	CL_Font *font;
+	CL_Surface *sur_checked;
+	CL_Surface *sur_unchecked;
+	CL_Surface *sur_checked_disabled;
+	CL_Surface *sur_unchecked_disabled;
+};
+
+#endif
+

Added: trunk/clanlib/API/GUIStyleSilver/scrollbar_silver.h
===================================================================
--- trunk/clanlib/API/GUIStyleSilver/scrollbar_silver.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUIStyleSilver/scrollbar_silver.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,98 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    Kenneth Gangst&#248;
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Style: Silver&quot;
+//! header=guistylesilver.h
+
+#ifndef header_scrollbar_silver
+#define header_scrollbar_silver
+
+#ifdef CL_API_DLL
+#ifdef CL_GUISTYLESILVER_EXPORT
+#define CL_API_GUISTYLESILVER __declspec(dllexport)
+#else
+#define CL_API_GUISTYLESILVER __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUISTYLESILVER
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Core/System/timer.h&quot;
+#include &quot;../GUI/scrollbar.h&quot;
+#include &quot;../GUI/component_style.h&quot;
+
+class CL_ResourceManager;
+class CL_Surface;
+class CL_StyleManager_Silver;
+
+//: ScrollBar default style.
+//- !group=GUI/Style: Silver!
+//- !header=guistylesilver.h!
+class CL_API_GUISTYLESILVER CL_ScrollBar_Silver : public CL_ComponentStyle
+{
+//! Construction:
+public:
+	//: Constructor
+	CL_ScrollBar_Silver(
+		CL_ScrollBar *scrollbar,
+		CL_StyleManager_Silver *style);
+	
+	//: Destructor
+	virtual ~CL_ScrollBar_Silver();
+
+//! Implementation:
+private:
+	void start_scroll(int delta);
+	void stop_scroll();
+
+	void on_paint();
+	void on_timer_scroll();
+	void on_resize(int old_width, int old_height);
+	void on_set_options(const CL_DomElement &amp;options);
+
+	CL_SlotContainer slots;
+
+	CL_Timer timer_scroll;
+	int scroll_delta;
+
+	CL_ScrollBar *scrollbar;
+	
+	CL_Button *button_increase;
+	CL_Button *button_decrease;
+
+	CL_StyleManager_Silver *style;
+};
+
+#endif
+

Added: trunk/clanlib/API/GUIStyleSilver/stylemanager_silver.h
===================================================================
--- trunk/clanlib/API/GUIStyleSilver/stylemanager_silver.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUIStyleSilver/stylemanager_silver.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,90 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Style: Silver&quot;
+//! header=guistylesilver.h
+
+#ifndef header_stylemanager_silver
+#define header_stylemanager_silver
+
+#ifdef CL_API_DLL
+#ifdef CL_GUISTYLESILVER_EXPORT
+#define CL_API_GUISTYLESILVER __declspec(dllexport)
+#else
+#define CL_API_GUISTYLESILVER __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUISTYLESILVER
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../GUI/stylemanager.h&quot;
+
+class CL_ResourceManager;
+class CL_Component;
+class CL_Rect;
+class CL_Color;
+
+//: Style manager that uses the default clanlib gui style.
+//- !group=GUI/Style: Silver!
+//- !header=guistylesilver.h!
+class CL_API_GUISTYLESILVER CL_StyleManager_Silver : public CL_StyleManager
+{
+//! Construction:
+public:
+	//: Construct a default style manager using the specified resources.
+	CL_StyleManager_Silver(CL_ResourceManager *resources);
+
+	//: Destructor.
+	virtual ~CL_StyleManager_Silver();
+
+//! Attributes:
+public:
+	
+//! Operations:
+public:
+
+//! Overrideables:
+public:
+	//: Connect component styles to component.
+	//: The 'type' parameter indicates what type the component is.
+	virtual void connect_styles(
+		const std::string &amp;type,
+		CL_Component *component);
+
+//! Implementation:
+private:
+	// Disallow copy contruction of style managers.
+	CL_StyleManager_Silver(const CL_StyleManager_Silver &amp;copy) : CL_StyleManager(0) { return; }
+};
+
+#endif

Added: trunk/clanlib/API/GUIStyleSilver/treeitem_silver.h
===================================================================
--- trunk/clanlib/API/GUIStyleSilver/treeitem_silver.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUIStyleSilver/treeitem_silver.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,87 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Style: Silver&quot;
+//! header=guistylesilver.h
+
+#ifndef header_treeitem_silver
+#define header_treeitem_silver
+
+#ifdef CL_API_DLL
+#ifdef CL_GUISTYLESILVER_EXPORT
+#define CL_API_GUISTYLESILVER __declspec(dllexport)
+#else
+#define CL_API_GUISTYLESILVER __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUISTYLESILVER
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../GUI/treeitem.h&quot;
+#include &quot;../GUI/component_style.h&quot;
+
+class CL_Font;
+class CL_Surface;
+class CL_StyleManager_Silver;
+
+//: Theme class for CL_TreeItem for Silver theme.
+//- !group=GUI/Style: Silver!
+//- !header=guistylesilver.h!
+class CL_API_GUISTYLESILVER CL_TreeItem_Silver : public CL_ComponentStyle
+{
+//! Construction:
+public:
+	//: Constructor
+	CL_TreeItem_Silver(
+		CL_TreeItem *item,
+		CL_StyleManager_Silver *style);
+
+	//: Destructor
+	virtual ~CL_TreeItem_Silver();
+
+//! Implementation:
+private:
+	void on_paint();
+	void on_get_preferred_size(CL_Size &amp;size);
+
+	CL_Slot slot_paint;
+	CL_Slot slot_get_preferred_size;
+
+	CL_TreeItem *item;
+
+	CL_Font *font;
+
+	CL_StyleManager_Silver *style;
+};
+
+#endif

Added: trunk/clanlib/API/GUIStyleSilver/treeview_silver.h
===================================================================
--- trunk/clanlib/API/GUIStyleSilver/treeview_silver.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUIStyleSilver/treeview_silver.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,99 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Style: Silver&quot;
+//! header=guistylesilver.h
+
+#ifndef header_treeview_silver
+#define header_treeview_silver
+
+#ifdef CL_API_DLL
+#ifdef CL_GUISTYLESILVER_EXPORT
+#define CL_API_GUISTYLESILVER __declspec(dllexport)
+#else
+#define CL_API_GUISTYLESILVER __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUISTYLESILVER
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../GUI/treeview.h&quot;
+#include &quot;../GUI/component_style.h&quot;
+
+class CL_StyleManager_Silver;
+class CL_Font;
+class CL_ScrollBar;
+
+//: Theme class for CL_TreeView for Silver theme.
+//- !group=GUI/Style: Silver!
+//- !header=guistylesilver.h!
+class CL_API_GUISTYLESILVER CL_TreeView_Silver : public CL_ComponentStyle
+{
+public:
+	CL_TreeView_Silver(
+		CL_TreeView *listbox,
+		CL_StyleManager_Silver *style);
+	
+	virtual ~CL_TreeView_Silver();
+
+private:
+	CL_SlotContainer slots;
+
+	void on_resize(int old_width, int old_height);
+
+	void on_paint();
+	void on_paint_header();
+	void on_paint_client();
+	void on_paint_node(CL_TreeNode *node, CL_Point &amp;point);
+
+	void on_mouse_down(const CL_InputEvent &amp;key);
+	void on_item_changed(const CL_TreeNode &amp;node);
+	void on_column_added(int index);
+	void on_column_removed(int index);
+	void on_clear();
+
+	void update_scrollbar(bool resize);
+
+	CL_TreeView *treeview;
+
+	CL_ScrollBar *scrollbar;
+	bool visible_scrollbar;
+
+	CL_Component *header_area;
+	
+	CL_Font *font;
+
+	CL_StyleManager_Silver *style;
+};
+
+#endif

Added: trunk/clanlib/API/GUIStyleSilver/window_silver.h
===================================================================
--- trunk/clanlib/API/GUIStyleSilver/window_silver.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/GUIStyleSilver/window_silver.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,115 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    Kenneth Gangst&#248;
+**    (if your name is missing here, please add it)
+*/
+
+//! clanGUI=&quot;Style: Silver&quot;
+//! header=guistylesilver.h
+
+#ifndef header_window_silver
+#define header_window_silver
+
+#ifdef CL_API_DLL
+#ifdef CL_GUISTYLESILVER_EXPORT
+#define CL_API_GUISTYLESILVER __declspec(dllexport)
+#else
+#define CL_API_GUISTYLESILVER __declspec(dllimport)
+#endif
+#else
+#define CL_API_GUISTYLESILVER
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../GUI/window.h&quot;
+#include &quot;../GUI/button.h&quot;
+#include &quot;../GUI/component_style.h&quot;
+#include &quot;../GUI/component_move_handler.h&quot;
+#include &quot;../GUI/component_resize_handler.h&quot;
+
+class CL_StyleManager_Silver;
+class CL_Font;
+
+//: Window default style.
+//- !group=GUI/Style: Silver!
+//- !header=guistylesilver.h!
+//- &lt;p&gt;Script attributes:&lt;/p&gt;
+//- &lt;ul&gt;
+//- &lt;li&gt;font: The font used to draw the caption. [String]&lt;/li&gt;
+//- &lt;/ul&gt;
+//- &lt;p&gt;Note that it inherits the attributes of CL_Window and CL_Component as well.&lt;/p&gt;
+class CL_API_GUISTYLESILVER CL_Window_Silver : public CL_ComponentStyle
+{
+//! Construction:
+public:
+	//: Constructor
+	CL_Window_Silver(
+		CL_Window *window,
+		CL_StyleManager_Silver *style);
+
+	//: Destructor
+	virtual ~CL_Window_Silver();
+
+//! Implementation:
+private:
+	CL_SlotContainer slots;
+
+	void on_paint();
+	void on_resize(int old_width, int old_height);
+	void on_close_button_clicked();
+	void on_maximize_button_clicked();
+	void on_minimize_button_clicked();
+	void on_help_button_clicked();
+	
+	CL_Button *add_titlebar_button(
+		const std::string &amp;resource_normal, 
+		const std::string &amp;resource_down, 
+		const std::string &amp;resource_disabled,
+		CL_ResourceManager *resources);
+
+	CL_Window *window;
+
+	CL_Button *button_close;
+	CL_Button *button_maximize;
+	CL_Button *button_minimize;
+	CL_Button *button_help;
+
+	CL_ComponentMoveHandler *move_handler;
+	CL_ComponentResizeHandler *resize_handler;
+
+	CL_StyleManager_Silver *style;
+	
+	CL_Font *font;
+	CL_Font *font_disabled;
+
+	int titlebar_height;
+};
+
+#endif

Added: trunk/clanlib/API/Makefile.am
===================================================================
--- trunk/clanlib/API/Makefile.am	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Makefile.am	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,364 @@
+clanSDL_includes = \
+        sdl.h \
+	SDL/setupsdl.h
+
+clanGL_includes = \
+        gl.h \
+	GL/opengl_window.h \
+	GL/opengl_window_description.h \
+	GL/opengl_surface.h \
+	GL/setupgl.h \
+	GL/opengl.h \
+	GL/opengl_state.h \
+	GL/opengl_state_data.h \
+	GL/viewpoint.h \
+	GL/light_source.h \
+	GL/shader_object.h \
+	GL/program_object.h \
+	GL/program_uniform.h \
+	GL/program_attribute.h \
+	GL/opengl_wrap.h \
+        GL/texture.h
+
+clanSmallJPEG_includes = smalljpeg.h SmallJPEG/jpgd_provider.h
+
+clanTTF_includes = TTF/setupttf.h ttf.h
+
+clanMikMod_includes = \
+	mikmod.h \
+	MikMod/setupmikmod.h \
+        MikMod/soundprovider_mikmod.h
+
+clanSignals_includes = \
+	signals.h \
+	Signals/slotbuffer_v0.h \
+	Signals/slotbuffer_v1.h \
+	Signals/slot_container.h \
+	Signals/signal.h \
+	Signals/signal_v0.h \
+	Signals/signal_v1.h \
+	Signals/signal_v2.h \
+	Signals/signal_v3.h \
+	Signals/signal_v4.h \
+	Signals/signal_v5.h \
+	Signals/slot_generic.h \
+	Signals/slot.h \
+	Signals/slot_v0.h \
+	Signals/slot_v1.h \
+	Signals/slot_v2.h \
+	Signals/slot_v3.h \
+	Signals/slot_v4.h \
+	Signals/slot_v5.h
+
+clanApp_includes = application.h Application/clanapp.h
+
+clanNetwork_includes = \
+	network.h \
+	Network/setupnetwork.h \
+	Network/IRC/irc_connection.h \
+	Network/IRC/irc_numerics.h \
+	Network/IRC/dcc_download.h \
+	Network/NetSession/inputsource_netpacket.h \
+	Network/NetSession/netstream.h \
+	Network/NetSession/netgroup.h \
+	Network/NetSession/netsession.h \
+	Network/NetSession/outputsource_netstream.h \
+	Network/NetSession/netpacket.h \
+	Network/NetSession/outputsource_netpacket.h \
+	Network/NetSession/inputsource_netstream.h \
+	Network/NetSession/netcomputer.h \
+	Network/Socket/outputsource_socket.h \
+	Network/Socket/inputsource_socket.h \
+	Network/Socket/ip_address.h \
+	Network/Socket/socket.h \
+	Network/NetObjects/netobject_server.h \
+	Network/NetObjects/netobject_controller.h \
+	Network/NetObjects/netobject_client.h \
+	Network/NetVariables/netvariables.h
+
+clanVoice_includes = \
+	voice.h \
+	Voice/voice_encoder.h \
+	Voice/voice_server.h \
+	Voice/voice_decoder.h \
+	Voice/voice_codec.h \
+	Voice/voice_client.h
+
+clanGUI_includes = \
+	gui.h \
+	GUI/treeitem.h \
+	GUI/component_move_handler.h \
+	GUI/treenode.h \
+	GUI/progressbar.h \
+	GUI/component.h \
+	GUI/component_manager.h \
+	GUI/layout.h \
+	GUI/label.h \
+	GUI/treeview.h \
+	GUI/filedialog.h \
+	GUI/radiobutton.h \
+	GUI/component_resize_handler.h \
+	GUI/listitem.h \
+	GUI/frame.h \
+	GUI/gui_manager.h \
+	GUI/scrollbar.h \
+	GUI/window.h \
+	GUI/checkbox.h \
+	GUI/listbox.h \
+	GUI/component_type.h \
+	GUI/setupgui.h \
+	GUI/stylemanager.h \
+	GUI/button.h \
+	GUI/image.h \
+	GUI/messagebox.h \
+	GUI/radiogroup.h \
+	GUI/component_style.h \
+	GUI/inputbox.h \
+	GUI/inputdialog.h \
+	GUI/menu.h \
+	GUI/menu_node.h \
+	GUI/menu_item.h \
+	GUI/deck.h
+
+clanGUIStyleBoring_includes = \
+        guistyleboring.h \
+        GUIStyleBoring/stylemanager_boring.h \
+        GUIStyleBoring/button_boring.h \
+        GUIStyleBoring/checkbox_boring.h \
+        GUIStyleBoring/frame_boring.h \
+        GUIStyleBoring/image_boring.h \
+        GUIStyleBoring/inputbox_boring.h \
+        GUIStyleBoring/label_boring.h \
+        GUIStyleBoring/listbox_boring.h \
+        GUIStyleBoring/progressbar_boring.h \
+        GUIStyleBoring/radiobutton_boring.h \
+        GUIStyleBoring/scrollbar_boring.h \
+        GUIStyleBoring/window_boring.h \
+	GUIStyleBoring/menu_boring.h \
+	GUIStyleBoring/menu_node_boring.h \
+	GUIStyleBoring/menu_item_boring.h
+
+clanGUIStyleSilver_includes = \
+	guistylesilver.h \
+	GUIStyleSilver/button_silver.h \
+	GUIStyleSilver/checkbox_silver.h \
+	GUIStyleSilver/frame_silver.h \
+	GUIStyleSilver/image_silver.h \
+	GUIStyleSilver/inputbox_silver.h \
+	GUIStyleSilver/label_silver.h \
+	GUIStyleSilver/listbox_silver.h \
+	GUIStyleSilver/menu_item_silver.h \
+	GUIStyleSilver/menu_node_silver.h \
+	GUIStyleSilver/menu_silver.h \
+	GUIStyleSilver/progressbar_silver.h \
+	GUIStyleSilver/radiobutton_silver.h \
+	GUIStyleSilver/scrollbar_silver.h \
+	GUIStyleSilver/stylemanager_silver.h \
+	GUIStyleSilver/treeitem_silver.h \
+	GUIStyleSilver/treeview_silver.h \
+	GUIStyleSilver/window_silver.h
+
+clanSound_includes = \
+	sound.h \
+	Sound/SoundFilters/echofilter.h \
+	Sound/SoundFilters/fadefilter.h \
+	Sound/SoundFilters/inverse_echofilter.h \
+	Sound/setupsound.h \
+	Sound/sound.h \
+	Sound/soundbuffer.h \
+	Sound/soundbuffer_session.h \
+	Sound/soundfilter.h \
+	Sound/soundformat.h \
+	Sound/SoundProviders/soundprovider_factory.h \
+	Sound/SoundProviders/soundprovider_type.h \
+	Sound/SoundProviders/soundprovider_type_register.h \
+	Sound/SoundProviders/soundprovider_raw.h \
+	Sound/SoundProviders/soundprovider_wave.h \
+	Sound/SoundProviders/soundprovider_recorder.h \
+	Sound/cd_drive.h \
+	Sound/soundoutput.h \
+	Sound/soundoutput_description.h \
+	Sound/soundprovider.h \
+	Sound/soundprovider_session.h
+
+
+clanCore_includes = \
+	core.h \
+	Core/core_iostream.h \
+	Core/Math/matrix4x4.h \
+	Core/Math/cl_vector.h \
+	Core/Math/circle.h \
+	Core/Math/vector2.inl \
+	Core/Math/math.h \
+	Core/Math/line_math.h \
+	Core/Math/triangle_math.h \
+	Core/Math/pointset_math.h \
+	Core/Math/rect.h \
+	Core/Math/quad.h \
+	Core/Math/size.h \
+	Core/Math/vector2.h \
+	Core/Math/point.h \
+	Core/Math/origin.h \
+	Core/Math/number_pool.h \
+	Core/Math/delauney_triangulator.h \
+	Core/Math/outline_triangulator.h \
+	Core/IOData/datatypes.h \
+	Core/IOData/outputsource_memory.h \
+	Core/IOData/outputsource_provider.h \
+	Core/IOData/inputsource_provider.h \
+	Core/IOData/inputsource_memory.h \
+	Core/IOData/cl_endian.h \
+	Core/IOData/directory_scanner.h \
+	Core/IOData/directory.h \
+	Core/IOData/outputsource_file.h \
+	Core/IOData/outputsource_zipped.h \
+	Core/IOData/inputsource.h \
+	Core/IOData/inputsource_provider_file.h \
+	Core/IOData/inputsource_file.h \
+	Core/IOData/inputsource_zipped.h \
+	Core/IOData/outputsource.h \
+	Core/IOData/zip_archive.h \
+	Core/IOData/zip_file_entry.h \
+	Core/System/command_line.h \
+	Core/System/event_listener.h \
+	Core/System/threadfunc_v0.h \
+	Core/System/threadfunc_v1.h \
+	Core/System/threadfunc_v2.h \
+	Core/System/event_trigger.h \
+	Core/System/console_window.h \
+	Core/System/keep_alive.h \
+	Core/System/log.h \
+	Core/System/crash_reporter.h \
+	Core/System/call_stack.h \
+	Core/System/clanstring.h \
+	Core/System/setupcore.h \
+	Core/System/error.h \
+	Core/System/timer.h \
+	Core/System/mutex.h \
+	Core/System/system.h \
+	Core/System/thread.h \
+	Core/System/cl_assert.h \
+	Core/System/log.h \
+	Core/System/cl_library.h \
+	Core/System/clonable.h \
+	Core/System/lazycopyptr.h \
+	Core/System/owningptr.h \
+	Core/System/sharedptr.h \
+	Core/System/weakptr.h \
+	Core/System/mutexsharedptr.h \
+	Core/System/mutexweakptr.h \
+	Core/Resources/resource.h \
+	Core/Resources/resourcetype_boolean.h \
+	Core/Resources/resourcetype_integer.h \
+	Core/Resources/resourcetype_float.h \
+	Core/Resources/resourcetype_string.h \
+	Core/Resources/resource_manager.h \
+	Core/Resources/resourcetype_raw.h \
+	Core/Resources/resourcedata.h \
+	Core/XML/dom_attr.h \
+	Core/XML/dom_cdata_section.h \
+	Core/XML/dom_character_data.h \
+	Core/XML/dom_comment.h \
+	Core/XML/dom_document.h \
+	Core/XML/dom_document_fragment.h \
+	Core/XML/dom_document_type.h \
+	Core/XML/dom_element.h \
+	Core/XML/dom_entity.h \
+	Core/XML/dom_entity_reference.h \
+	Core/XML/dom_exception.h \
+	Core/XML/dom_implementation.h \
+	Core/XML/dom_named_node_map.h \
+	Core/XML/dom_node.h \
+	Core/XML/dom_node_list.h \
+	Core/XML/dom_notation.h \
+	Core/XML/dom_processing_instruction.h \
+	Core/XML/dom_text.h \
+	Core/XML/xml_token.h \
+	Core/XML/xml_tokenizer.h \
+	Core/XML/xml_writer.h
+
+clanDisplay_includes = \
+	display.h \
+	Display/display_iostream.h \
+	Display/pixel_buffer.h \
+	Display/color.h \
+	Display/gradient.h \
+	Display/palette.h \
+	Display/display.h \
+	Display/display_mode.h \
+	Display/display_window_description.h \
+	Display/frameratecounter.h \
+	Display/keyboard.h \
+	Display/key_binding.h \
+	Display/keys.h \
+	Display/input_device.h \
+	Display/input_event.h \
+	Display/input_buffer.h \
+	Display/input_button.h \
+	Display/input_context.h \
+	Display/joystick.h \
+	Display/mouse.h \
+	Display/sprite.h \
+	Display/sprite_packer.h \
+	Display/graphic_context.h \
+	Display/display_window.h \
+	Display/setupdisplay.h \
+	Display/font.h \
+	Display/Providers/provider_type.h \
+	Display/Providers/dc_buffer.h \
+	Display/Providers/pcx_provider.h \
+	Display/Providers/png_provider.h \
+	Display/Providers/provider_factory.h \
+	Display/Providers/provider_type_register.h \
+	Display/Providers/jpeg_provider.h \
+	Display/Providers/targa_provider.h \
+	Display/surface.h \
+	Display/canvas.h \
+	Display/pixel_format.h \
+	Display/pixel_format_type.h \
+	Display/sprite_description.h \
+	Display/rle_surface.h \
+	Display/blend_func.h \
+	Display/stencil_func.h \
+	Display/text_styler.h \
+	Display/glyph_buffer.h \
+	Display/Collision/collision_outline.h \
+	Display/Collision/contour.h \
+	Display/Collision/outline_accuracy.h \
+	Display/Collision/outline_circle.h \
+	Display/Collision/outline_math.h \
+	Display/Collision/outline_provider.h \
+	Display/Collision/outline_provider_bitmap.h \
+	Display/Collision/outline_provider_file.h
+
+clanJavaScript_includes = \
+	javascript.h \
+	JavaScript/js_classfactory.h \
+	JavaScript/js_runtime.h \
+	JavaScript/js_config.h \
+	JavaScript/js_error.h \
+	JavaScript/js_object.h \
+	JavaScript/js_value.h \
+	JavaScript/js_arguments.h \
+	JavaScript/js_context.h
+
+clanVorbis_includes = \
+	vorbis.h \
+	Vorbis/setupvorbis.h \
+	Vorbis/soundprovider_vorbis.h
+
+ClanLibincludedir=$(includedir)/<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">ClanLib- at LT_RELEASE</A>@/ClanLib
+nobase_ClanLibinclude_HEADERS = @ClanLib_API_Modules@
+
+# All available headers are listed here (for 'make dist' and such)
+EXTRA_HEADERS = \
+	$(clanGL_includes) $(clanCore_includes) $(clanTTF_includes) \
+        $(clanApp_includes) \
+	$(clanDisplay_includes) $(clanMikMod_includes) \
+	$(clanNetwork_includes) \
+	$(clanSignals_includes) $(clanVoice_includes) \
+	$(clanGUI_includes) $(clanSound_includes) $(clanJavaScript_includes) \
+	$(clanVorbis_includes) $(clanGUIStyleSilver_includes) $(clanGUIStyleBoring_includes) \
+	efence.h
+
+# EOF #

Added: trunk/clanlib/API/MikMod/setupmikmod.h
===================================================================
--- trunk/clanlib/API/MikMod/setupmikmod.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/MikMod/setupmikmod.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,73 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanMikMod=&quot;System&quot;
+//! header=mikmod.h
+
+#ifndef header_setupmikmod
+#define header_setupmikmod
+
+#ifdef CL_API_DLL
+#ifdef CL_MIKMOD_EXPORT
+#define CL_API_MIKMOD __declspec(dllexport)
+#else
+#define CL_API_MIKMOD __declspec(dllimport)
+#endif
+#else
+#define CL_API_MIKMOD
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+//: ClanMikMod initialization.
+//- !group=MikMod/System!
+//- !header=mikmod.h!
+class CL_API_MIKMOD CL_SetupMikMod
+{
+//! Construction:
+public:
+	//: Initializes clanMikMod.
+	//- &lt;p&gt;Constructing a CL_SetupMikMod object is equalent to calling CL_SetupMikMod::init().&lt;/p&gt;
+	//- &lt;p&gt;When the CL_SetupMikMod instance is destroyed, CL_SetupMikMod::deinit() is called.&lt;/p&gt;
+	CL_SetupMikMod(bool register_resources_only = false);
+
+	~CL_SetupMikMod();
+
+//! Operations:
+public:
+	//: Call this function in init_modules() to use clanMikMod.
+	static void init(bool register_resources_only = false);
+
+	//: Call this function in deinit_modules().
+	static void deinit();
+};
+
+#endif

Added: trunk/clanlib/API/MikMod/soundprovider_mikmod.h
===================================================================
--- trunk/clanlib/API/MikMod/soundprovider_mikmod.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/MikMod/soundprovider_mikmod.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,90 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanMikMod=&quot;Sound Providers&quot;
+//! header=mikmod.h
+
+#ifndef header_sound_provider_mikmod
+#define header_sound_provider_mikmod
+
+#ifdef CL_API_DLL
+#ifdef CL_MIKMOD_EXPORT
+#define CL_API_MIKMOD __declspec(dllexport)
+#else
+#define CL_API_MIKMOD __declspec(dllimport)
+#endif
+#else
+#define CL_API_MIKMOD
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Sound/soundprovider.h&quot;
+#include &lt;string&gt;
+
+class CL_InputSourceProvider;
+class CL_SoundProvider_MikMod_Generic;
+
+//: Module format (.mod, .s3m, .xm, etc) sound provider.
+//- !group=MikMod/Sound Providers!
+//- !header=mikmod.h!
+class CL_API_MIKMOD CL_SoundProvider_MikMod : public CL_SoundProvider
+{
+//! Construction:
+public:
+	//: Constructs a sound provider based on a MikMod compatible module file.
+	//param filename: Filename of module file.
+	//param provider: Input source provider used to retrieve module file.
+	//param stream: If true, will stream from disk. If false, will load it to memory.
+	CL_SoundProvider_MikMod(
+		const std::string &amp;filename,
+		CL_InputSourceProvider *provider = 0,
+		bool stream = false);
+
+	virtual ~CL_SoundProvider_MikMod();
+
+//! Operations:
+public:
+	//: Called by CL_SoundBuffer when a new session starts.
+	//return: The soundbuffer session to be attached to the newly started session.
+	virtual CL_SoundProvider_Session *begin_session();
+
+	//: Called by CL_SoundBuffer when a session has finished. After this call,
+	//- &lt;p&gt;CL_SoundBuffer will not access the session anymore. It can safely be deleted
+	//- here (and in most cases should be delete here).&lt;/p&gt;
+	virtual void end_session(CL_SoundProvider_Session *session);
+
+//! Implementation:
+private:
+	CL_SoundProvider_MikMod_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Network/IRC/dcc_download.h
===================================================================
--- trunk/clanlib/API/Network/IRC/dcc_download.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Network/IRC/dcc_download.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,128 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanNetwork=&quot;Internet Relay Chat&quot;
+//! header=network.h
+
+#ifndef header_dcc_download
+#define header_dcc_download
+
+#ifdef CL_API_DLL
+#ifdef CL_NETWORK_EXPORT
+#define CL_API_NETWORK __declspec(dllexport)
+#else
+#define CL_API_NETWORK __declspec(dllimport)
+#endif
+#else
+#define CL_API_NETWORK
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../../signals.h&quot;
+#include &lt;string&gt;
+
+class CL_DCCDownload_Generic;
+class CL_OutputSourceProvider;
+
+//: IRC DCC download session object.
+//- !group=Network/Internet Relay Chat!
+//- !header=network.h!
+//- &lt;p&gt;This class connects to an IRC client listening for an incoming DCC
+//- connection and then downloads the file offered. Should be used in
+//- response to a DCC SEND CTCP command.&lt;/p&gt;
+class CL_API_NETWORK CL_DCCDownload
+{
+//! Construction:
+public:
+	//: Constructs a new DCC download session.
+	CL_DCCDownload();
+	
+	CL_DCCDownload(const CL_DCCDownload &amp;copy);
+
+	CL_DCCDownload(
+		const std::string &amp;server,
+		const std::string &amp;port,
+		const std::string &amp;filename,
+		int total_size = 0,
+		CL_OutputSourceProvider *output = 0,
+		bool delete_provider = false);
+	
+	virtual ~CL_DCCDownload();
+	
+//! Attributes:
+public:
+	// cannot use &quot;Status&quot; due to brain dead Xlib header #define'ing it to an &quot;int&quot;
+	enum DCCStatus
+	{
+		//: Connecting to DCC server.
+		connecting,
+		
+		//: Currently downloading.
+		downloading,
+		
+		//: Connection was lost to DCC server.
+		connection_lost,
+		
+		//: Download was completed.
+		finished
+	};
+
+	//: Returns the number of bytes transfered so far.
+	int get_bytes_transfered();
+	
+	//: Returns the total size of file.
+	//- &lt;p&gt;If the total size is unknown, it returns 0.&lt;/p&gt;
+	int get_total_size();
+	
+	//: Returns the current status of the download.
+	DCCStatus get_status();
+
+	//: sig_connection_lost(error_message)
+	CL_Signal_v1&lt;const std::string &amp;&gt; &amp;sig_connection_lost();
+
+	//: sig_download_complete()
+	CL_Signal_v0 &amp;sig_download_complete();
+
+//! Operations:
+public:
+	//: Copy assignment operator.
+	CL_DCCDownload &amp;operator =(const CL_DCCDownload &amp;copy);
+
+	//: Attemp to reconnect and resume download.
+	void reconnect();
+
+//! Implementation:
+private:
+	CL_DCCDownload_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Network/IRC/irc_connection.h
===================================================================
--- trunk/clanlib/API/Network/IRC/irc_connection.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Network/IRC/irc_connection.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,373 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanNetwork=&quot;Internet Relay Chat&quot;
+//! header=network.h
+
+#ifndef header_irc_connection
+#define header_irc_connection
+
+#ifdef CL_API_DLL
+#ifdef CL_NETWORK_EXPORT
+#define CL_API_NETWORK __declspec(dllexport)
+#else
+#define CL_API_NETWORK __declspec(dllimport)
+#endif
+#else
+#define CL_API_NETWORK
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning (disable:4786)
+#endif
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &lt;list&gt;
+#include &lt;queue&gt;
+
+#include &quot;../../signals.h&quot;
+#include &quot;irc_numerics.h&quot;
+
+class CL_IRCConnection_Generic;
+
+//: IRC Connection class.
+//- !group=Network/Internet Relay Chat!
+//- !header=network.h!
+//- &lt;p&gt;The CL_IRCConnection class represents a socket connection to an IRC
+//- server. Upon construction it will connect to the server+port given and
+//- then parse each line written by the IRC server. Each time
+//- CL_System::keep_alive() is called, the CL_IRCConnection will emit the
+//- signals for those commands received.&lt;/p&gt;
+//- &lt;p&gt;Most IRC networks will expect the connecting IRC client to first send
+//- a &quot;nick&quot; command and then a &quot;user&quot; command, as part of the logon
+//- process. CL_IRCConnection will not do this, so the general logon
+//- procedure looks somewhat like this:&lt;/p&gt;
+//- &lt;pre&gt;
+//- CL_IRCConnection connection(&quot;irc.freenode.net&quot;, &quot;6667&quot;);
+//- connection.send_nick(&quot;MyNick&quot;);
+//- connection.send_user(&quot;username&quot;, &quot;our.hostname&quot;, &quot;irc.freenode.net&quot;, &quot;User Name&quot;);
+//- &lt;/pre&gt;
+//- &lt;p&gt;IRC servers will occationally send a &quot;ping&quot; line, which have to be
+//- replied with a &quot;pong&quot; command. If this isn't done within some server
+//- specific timeout, the IRC network will disconnect the client.
+//- CL_IRCConnection will also not do this automatically, so its important
+//- you at least hook up the ping slot, to a function looking like this:&lt;/p&gt;
+//- &lt;pre&gt;
+//- void on_ping(const std::string &amp;daemon1, const std::string &amp;daemon2)
+//- { connection.send_pong(daemon1, daemon2); }
+//- &lt;/pre&gt;
+class CL_API_NETWORK CL_IRCConnection
+{
+//! Construction:
+public:
+	//: Constructs a CL_IRCConnection and connects a server.
+	//param server: IRC server host name. Ie. &quot;irc.freenode.net&quot;.
+	//param port: IRC server port. Defaults to &quot;6667&quot;.
+	CL_IRCConnection();
+
+	CL_IRCConnection(const std::string &amp;server, const std::string &amp;port = &quot;6667&quot;);
+	
+	CL_IRCConnection(const CL_IRCConnection &amp;copy);
+
+	~CL_IRCConnection();
+	
+//! Attributes:
+public:
+	//: Returns our current nick name.
+	const std::string &amp;get_nick() const;
+
+	//: Returns the username passed to send_user.
+	const std::string &amp;get_username() const;
+
+	//: Returns hostname passed to send_user.
+	const std::string &amp;get_hostname() const;
+
+	//: Returns server name passed to send_user.
+	const std::string &amp;get_servername() const;
+
+	//: Returns the real name passed to send_user.
+	const std::string &amp;get_realname() const;
+
+//! Operations:
+public:
+	CL_IRCConnection &amp;operator =(const CL_IRCConnection &amp;copy);
+
+	//: Send command to IRC server.
+	//param prefix: Sender prefix.
+	//param command: IRC command.
+	//param params: List of parameters for IRC command.
+	//- &lt;p&gt;This is the low-level IRC send command. Useful if you need to
+	//- send a command not supported by the other higher level send
+	//- functions.&lt;/p&gt;
+	void send_command(const std::string &amp;prefix, const std::string &amp;command, const std::vector&lt;std::string&gt; &amp;params);
+
+	//: Send password.
+	//param password: Password parameter to send with &quot;pass&quot; command.
+	//- &lt;p&gt;Sends a &quot;pass&quot; command to IRC server.&lt;/p&gt;
+	void send_pass(const std::string &amp;password);
+
+	//: Send nick.
+	//param nick: Nick name to use.
+	//param hopcount: Can't remember. Check the RFC. :-)
+	//- &lt;p&gt;Sets or changes your nick.&lt;/p&gt;
+	void send_nick(const std::string &amp;nick, int hopcount = -1);
+
+	//: Send user login/identify command.
+	//param username: Client username.
+	//param hostname: Client hostname.
+	//param servername: Hostname of IRC server.
+	//param realname: Real name of client user.
+	//- &lt;p&gt;This command identifies the IRC client to the IRC network.
+	//- Each of the parameters passsed will be used to create your fully
+	//- qualified prefix on the network.&lt;/p&gt;
+	void send_user(const std::string &amp;username, const std::string &amp;hostname, const std::string &amp;servername, const std::string &amp;realname);
+
+	//: Send operator login command
+	//param user: Operator login name.
+	//param password: Operator password.
+	void send_oper(const std::string &amp;user, const std::string &amp;password);
+
+	//: Send quit command.	
+	void send_quit(const std::string &amp;quitmessage = &quot;&quot;);
+	
+	//: Send join channel command.
+	//param channel: Channel to join, ie. &quot;#clanlib&quot;
+	//param key: Channel key, if any.
+	//param channels: List of channels to join.
+	//param keys: List of channel keys.
+	void send_join(const std::string &amp;channel, const std::string &amp;key = &quot;&quot;);
+	
+	void send_join(const std::list&lt;std::string&gt; &amp;channels, const std::list&lt;std::string&gt; &amp;keys);
+
+	//: Send part channel command.
+	//param channel: Channel to leave.
+	//param reason: Reason for leaving.
+	//param channels: List of channels to leave.
+	void send_part(const std::string &amp;channel, const std::string &amp;reason = &quot;&quot;);
+
+	void send_part(const std::list&lt;std::string&gt; &amp;channels, const std::string &amp;reason = &quot;&quot;);
+
+	//: Send set mode command.
+	//param target: Channel or nick mode change apply to.
+	//param mode: Mode change to perform, ie. &quot;+o&quot;.
+	//param args: Arguements to mode command.
+	void send_mode(const std::string &amp;target, const std::string &amp;mode, const std::vector&lt;std::string&gt; &amp;args);
+
+	//: Set/Get topic on channel.
+	//param channel: Channel name.
+	//param topic: New topic to be set.
+	//- &lt;p&gt;If no topic is specified, this will make the IRC server send
+	//- back what the topic is on a given channel.&lt;/p&gt;
+	void send_topic(const std::string &amp;channel, const std::string &amp;topic);
+	
+	void send_topic(const std::string &amp;channel);
+
+	//: List nicks on channel(s).
+	//param channel: Channel to list.
+	void send_names(const std::string &amp;channel = &quot;&quot;);
+	
+	void send_names(const std::list&lt;std::string&gt; &amp;channels);
+
+	//: Send list of channels.
+	//param channel: Channel name substring to match.
+	//param server: Server to limit results from.
+	void send_list(const std::string &amp;channel = &quot;&quot;, const std::string &amp;server = &quot;&quot;);
+	
+	void send_list(const std::list&lt;std::string&gt; &amp;channels, const std::string &amp;server = &quot;&quot;);
+
+	//: Send channel join invitation.
+	//param nickname: Nick to receive invitation.
+	//param channel: Channel being invited to.
+	void send_invite(const std::string &amp;nickname, const std::string &amp;channel);
+
+	//: Send kick command	
+	void send_kick(const std::string &amp;channel, const std::string &amp;user, const std::string &amp;comment = &quot;&quot;);
+	
+	void send_kick(const std::list&lt;std::string&gt; &amp;channels, const std::list&lt;std::string&gt; &amp;users, const std::string &amp;comment = &quot;&quot;);
+
+	//: Send version command.
+	void send_version(const std::string &amp;server = &quot;&quot;);
+
+	//: Send statistics command.
+	void send_stats(const std::string &amp;query = &quot;&quot;, const std::string &amp;server = &quot;&quot;);
+
+	//: Send links command.	
+	void send_links(const std::string &amp;remote_server = &quot;&quot;, const std::string &amp;server_mask = &quot;&quot;);
+	
+	//: Send time command.
+	void send_time(const std::string &amp;server = &quot;&quot;);
+
+	//: Send connect command.
+	void send_connect(const std::string &amp;target_server, int port = 0, const std::string &amp;remote_server = &quot;&quot;);
+	
+	//: Send trace command.
+	void send_trace(const std::string &amp;server = 0);
+	
+	//: Send admin command.
+	void send_admin(const std::string &amp;server = 0);
+
+	//: Send info command.	
+	void send_info(const std::string &amp;server = 0);
+	
+	//: Send channel message or private message.
+	//param reciver: Channel or nick to receive message.
+	//param text: Message to send.
+	void send_privmsg(const std::string &amp;receiver, const std::string &amp;text);
+	
+	void send_privmsg(const std::list&lt;std::string&gt; &amp;receivers, const std::string &amp;text);
+
+	//: Send Client To Client Protocol (CTCP) message.
+	//param reciver: Channel or nick to receive message.
+	//param command: CTCP command.
+	//param data: CTCP data.
+	void send_privmsg_ctcp(const std::string &amp;receiver, const std::string &amp;command, const std::string &amp;data);
+
+	void send_privmsg_ctcp(std::list&lt;std::string&gt; &amp;receivers, const std::string &amp;command, const std::string &amp;data);
+
+	//: Send notice message.
+	//param nickname: Nick to receive notice.
+	//param text: Notice to send.
+	void send_notice(const std::string &amp;nickname, const std::string &amp;text);
+
+	//: Send Client To Client Protocol (CTCP) notice.
+	//param nickname: Nick to receive notice.
+	//param command: CTCP command.
+	//param data: CTCP data.
+	void send_notice_ctcp(const std::string &amp;nickname, const std::string &amp;command, const std::string &amp;data);
+
+	//: Send who command.
+	//param name: Nick to retrieve information about.
+	//param oper: If set to true, use IRC operator rights.
+	void send_who(const std::string &amp;name, bool oper = false);
+
+	//: Send whois command.
+	//param nickmask: Nick to retrieve information about
+	//param server: Server to query.
+	void send_whois(const std::string &amp;nickmask);
+	
+	void send_whois(const std::string &amp;server, const std::string &amp;nickmask);
+	
+	void send_whois(const std::list&lt;std::string&gt; &amp;nickmasks);
+	
+	void send_whois(const std::string &amp;server, const std::list&lt;std::string&gt; &amp;nickmasks);
+
+	//: Send whowas command.
+	//param nickname: Nick to retrieve information about
+	//param count: Amount of users with that nick to get information about.	
+	//param server: Server to query.
+	void send_whowas(const std::string &amp;nickname, int count = 0, const std::string &amp;server = &quot;&quot;);
+
+	//: Send kill command.
+	//param nickname: Nick to kill.
+	//param comment: Reason given for killing nick.
+	void send_kill(const std::string &amp;nickname, const std::string &amp;comment);
+
+	//: Send ping command
+	//param server: Server to send to.
+	//param server2: Server to relay through.
+	void send_ping(const std::string &amp;server, const std::string &amp;server2 = &quot;&quot;);
+
+	//: Send pong command
+	//param daemon: Server that sent ping command.
+	//param daemon2: Server ping command was relayed through.
+	void send_pong(const std::string &amp;daemon, const std::string &amp;daemon2 = &quot;&quot;);
+
+	//: Extracts nick part of a fully qualified IRC prefix.
+	static std::string extract_nick(const std::string &amp;str);
+
+	//: Extracts user part of a fully qualified IRC prefix.
+	static std::string extract_user(const std::string &amp;str);
+
+	//: Extracts address part of a fully qualified IRC prefix.
+	static std::string extract_address(const std::string &amp;str);
+
+//! Signals:
+public:
+	//: sig_socket_error(error_message)
+	CL_Signal_v1&lt;const std::string &amp;&gt; &amp;sig_socket_error();
+
+	//: sig_command_received(prefix, command, params)
+	CL_Signal_v3&lt;const std::string &amp;, const std::string &amp;, const std::vector&lt;std::string&gt; &amp;&gt; &amp;sig_command_received();
+
+	//: sig_unknown_command_received(prefix, command, params)
+	CL_Signal_v3&lt;const std::string &amp;, const std::string &amp;, const std::vector&lt;std::string&gt; &amp;&gt; &amp;sig_unknown_command_received();
+
+	//: sig_numeric_reply(prefix, code, params)
+	CL_Signal_v3&lt;const std::string &amp;, int, const std::vector&lt;std::string&gt; &amp;&gt; &amp;sig_numeric_reply();
+	
+	//: sig_name_reply(self, channel, users)
+	CL_Signal_v3&lt;const std::string &amp;, const std::string &amp;, const std::vector&lt;std::string&gt; &amp;&gt; &amp;sig_name_reply();
+
+	//: sig_nick(old_nick, new_nick)
+	CL_Signal_v2&lt;const std::string &amp;, const std::string &amp;&gt; &amp;sig_nick();
+
+	//: sig_join(nick, channel)
+	CL_Signal_v2&lt;const std::string &amp;, const std::string &amp;&gt; &amp;sig_join();
+	
+	//: sig_part(nick, channel, reason)
+	CL_Signal_v3&lt;const std::string &amp;, const std::string &amp;, const std::string &amp;&gt; &amp;sig_part();
+	
+	//: sig_mode(prefix, receiver, mode, params)
+	CL_Signal_v4&lt;const std::string &amp;, const std::string &amp;, const std::string &amp;, const std::vector&lt;std::string&gt; &amp;&gt; &amp;sig_mode();
+
+	//: sig_topic(prefix, channel, topic)
+	CL_Signal_v3&lt;const std::string &amp;, const std::string &amp;, const std::string &amp;&gt; &amp;sig_topic();
+	
+	//: sig_invite(prefix, nick, channel)
+	CL_Signal_v3&lt;const std::string &amp;, const std::string &amp;, const std::string &amp;&gt; &amp;sig_invite();
+
+	//: sig_kick(prefix, chan, user, comment)
+	CL_Signal_v4&lt;const std::string &amp;, const std::string &amp;, const std::string &amp;, const std::string &amp;&gt; &amp;sig_kick();
+
+	//: sig_privmsg(prefix, receiver, text)
+	CL_Signal_v3&lt;const std::string &amp;, const std::string &amp;, const std::string &amp;&gt; &amp;sig_privmsg();
+
+	//: sig_notice(prefix, receiver, text)
+	CL_Signal_v3&lt;const std::string &amp;, const std::string &amp;, const std::string &amp;&gt; &amp;sig_notice();
+
+	//: sig_privmsg_ctcp(prefix, receiver, command, data)
+	CL_Signal_v4&lt;const std::string &amp;, const std::string &amp;, const std::string &amp;, const std::string &amp;&gt; &amp;sig_privmsg_ctcp();
+
+	//: sig_notice_ctcp(prefix, receiver, command, data)
+	CL_Signal_v4&lt;const std::string &amp;, const std::string &amp;, const std::string &amp;, const std::string &amp;&gt; &amp;sig_notice_ctcp();
+
+	//: sig_ping(daemon1, daemon2)
+	CL_Signal_v2&lt;const std::string &amp;, const std::string &amp;&gt; &amp;sig_ping();
+
+//! Implementation:
+private:
+	CL_IRCConnection_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Network/IRC/irc_numerics.h
===================================================================
--- trunk/clanlib/API/Network/IRC/irc_numerics.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Network/IRC/irc_numerics.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,313 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef irc_numerics
+#define irc_numerics
+
+/*
+	E=EFnet hybrid-6rc4
+	I=IRCnet 2.10.3
+	i=IRCnet, reserved according to Undernet (sic) numerics headers
+	U=Undernet u2.10.07
+	D=DALnet bahamut 1.4.8
+*/
+
+enum CL_IRCNumerics
+{
+	RPL_WELCOME = 1, // IEUD
+	RPL_YOURHOST = 2, // IEUD
+	RPL_CREATED = 3, // IEUD
+	RPL_MYINFO = 4, // IEUD
+	RPL_BOUNCE = 5, // I
+	RPL_MAP = 5, // U
+	RPL_PROTOCTL = 5, // D
+	RPL_MAPMORE = 6, // U
+	RPL_MAPEND = 7, // U
+	RPL_SNOMASK = 8, // U
+	RPL_STATMEMTOT = 9, // U
+	RPL_STATMEM = 010, // U
+	RPL_YOURCOOKIE = 014, // i
+	RPL_TRACELINK = 200, // IEUD
+	RPL_TRACECONNECTING = 201, // IEUD
+	RPL_TRACEHANDSHAKE = 202, // IEUD
+	RPL_TRACEUNKNOWN = 203, // IEUD
+	RPL_TRACEOPERATOR = 204, // IEUD
+	RPL_TRACEUSER = 205, // IEUD
+	RPL_TRACESERVER = 206, // IEUD
+	RPL_TRACESERVICE = 207, // IEU
+	RPL_TRACENEWTYPE = 208, // IEUD
+	RPL_TRACECLASS = 209, // IEUD
+	RPL_TRACERECONNECT = 210, // I
+	RPL_STATSLINKINFO = 211, // IEUD
+	RPL_STATSCOMMANDS = 212, // IEUD
+	RPL_STATSCLINE = 213, // IEUD
+	RPL_STATSNLINE = 214, // IEUD
+	RPL_STATSILINE = 215, // IEUD
+	RPL_STATSKLINE = 216, // IEUD
+	RPL_STATSQLINE = 217, // IED
+	RPL_STATSPLINE_U = 217, // U
+	RPL_STATSYLINE = 218, // IEUD
+	RPL_ENDOFSTATS = 219, // IEUD
+	RPL_STATSPLINE_E = 220, // E
+	RPL_UMODEIS = 221, // IEUD
+	RPL_STATSBLINE_ED = 222, // ED
+	RPL_STATSELINE = 223, // ED
+	RPL_STATSFLINE = 224, // ED
+	RPL_STATSDLINE_E = 225, // E
+	RPL_STATSZLINE = 225, // D
+	RPL_STATSCOUNT = 226, // D
+	RPL_STATSGLINE_D = 227, // D
+	RPL_SERVICEINFO = 231, // IU
+	RPL_ENDOFSERVICES = 232, // IU
+	RPL_SERVICE = 233, // IU
+	RPL_SERVLIST = 234, // IEUD
+	RPL_SERVLISTEND = 235, // IEUD
+	RPL_STATSIAUTH = 239, // I
+	RPL_STATSVLINE = 240, // I
+	RPL_STATSLLINE = 241, // IEUD
+	RPL_STATSUPTIME = 242, // IEUD
+	RPL_STATSOLINE = 243, // IEUD
+	RPL_STATSHLINE = 244, // IEUD
+	RPL_STATSSLINE = 245, // IEuD
+	RPL_STATSPING = 246, // I
+	RPL_STATSTLINE = 246, // U
+	RPL_STATSULINE_D = 246, // D
+	RPL_STATSBLINE_I = 247, // I
+	RPL_STATSGLINE_U = 247, // U
+	RPL_STATSXLINE = 247, // E
+	RPL_STATSDEFINE = 248, // I
+	RPL_STATSULINE_EU = 248, // EU
+	RPL_STATSDEBUG = 249, // IEUD
+	RPL_STATSDLINE_I = 250, // I
+	RPL_STATSCONN = 250, // EUD
+	RPL_LUSERCLIENT = 251, // IEUD
+	RPL_LUSEROP = 252, // IEUD
+	RPL_LUSERUNKNOWN = 253, // IEUD
+	RPL_LUSERCHANNELS = 254, // IEUD
+	RPL_LUSERME = 255, // IEUD
+	RPL_ADMINME = 256, // IEUD
+	RPL_ADMINLOC1 = 257, // IEUD
+	RPL_ADMINLOC2 = 258, // IEUD
+	RPL_ADMINEMAIL = 259, // IEUD
+	RPL_TRACELOG = 261, // IEUD
+	RPL_TRACEEND = 262, // I
+	RPL_ENDOFTRACE = 262, // ED
+	RPL_TRACEPING = 262, // U
+	RPL_TRYAGAIN = 263, // I
+	RPL_LOAD2HI = 263, // ED
+	RPL_LOCALUSERS = 265, // ED
+	RPL_GLOBALUSERS = 266, // ED
+	RPL_SILELIST = 271, // UD
+	RPL_ENDOFSILELIST = 272, // UD
+	RPL_STATSDELTA = 274, // i
+	RPL_STATSDLINE = 275, // UD
+	RPL_GLIST = 280, // U
+	RPL_ENDOFGLIST = 281, // U
+	RPL_HELPHDR = 290, // D
+	RPL_HELPOP = 291, // D
+	RPL_HELPTLR = 292, // D
+	RPL_HELPHLP = 293, // D
+	RPL_HELPFWD = 294, // D
+	RPL_HELPIGN = 295, // D
+	RPL_NONE = 300, // IEUD
+	RPL_AWAY = 301, // IEUD
+	RPL_USERHOST = 302, // IEUD
+	RPL_ISON = 303, // IEUD
+	RPL_TEXT = 304, // IEUD
+	RPL_UNAWAY = 305, // IEUD
+	RPL_NOWAWAY = 306, // IEUD
+	RPL_USERIP = 307, // U
+	RPL_WHOISREGNICK = 307, // D
+	RPL_WHOISADMIN = 308, // D
+	RPL_WHOISSADMIN = 309, // D
+	RPL_WHOISSVCMSG = 310, // D
+	RPL_WHOISUSER = 311, // IEUD
+	RPL_WHOISSERVER = 312, // IEUD
+	RPL_WHOISOPERATOR = 313, // IEUD
+	RPL_WHOWASUSER = 314, // IEUD
+	RPL_ENDOFWHO = 315, // IEUD
+	RPL_WHOISCHANOP = 316, // IED
+	RPL_WHOISIDLE = 317, // IEUD
+	RPL_ENDOFWHOIS = 318, // IEUD
+	RPL_WHOISCHANNELS = 319, // IEUD
+	RPL_LISTSTART = 321, // IEUD
+	RPL_LIST = 322, // IEUD
+	RPL_LISTEND = 323, // IEUD
+	RPL_CHANNELMODEIS = 324, // IEUD
+	RPL_UNIQOPIS = 325, // I
+	RPL_NOCHANPASS = 326, // i
+	RPL_CHPASSUNKNOWN = 327, // i
+	RPL_CREATIONTIME = 329, // EUD
+	RPL_NOTOPIC = 331, // IEUD
+	RPL_TOPIC = 332, // IEUD
+	RPL_TOPICWHOTIME = 333, // EUD
+	RPL_LISTUSAGE = 334, // U
+	RPL_COMMANDSYNTAX = 334, // D
+	RPL_CHANPASSOK = 338, // i
+	RPL_BADCHANPASS = 339, // i
+	RPL_INVITING = 341, // IEUD
+	RPL_SUMMONING = 342, // IED
+	RPL_INVITELIST = 346, // I
+	RPL_ENDOFINVITELIST = 347, // I
+	RPL_EXCEPTLIST = 348, // IE
+	RPL_ENDOFEXCEPTLIST = 349, // IE
+	RPL_VERSION = 351, // IEUD
+	RPL_WHOREPLY = 352, // IEUD
+	RPL_NAMREPLY = 353, // IEUD
+	RPL_WHOSPCRPL = 354, // U
+	RPL_KILLDONE = 361, // IEUD
+	RPL_CLOSING = 362, // IEUD
+	RPL_CLOSEEND = 363, // IEUD
+	RPL_LINKS = 364, // IEUD
+	RPL_ENDOFLINKS = 365, // IEUD
+	RPL_ENDOFNAMES = 366, // IEUD
+	RPL_BANLIST = 367, // IEUD
+	RPL_ENDOFBANLIST = 368, // IEUD
+	RPL_ENDOFWHOWAS = 369, // IEUD
+	RPL_INFO = 371, // IEUD
+	RPL_MOTD = 372, // IEUD
+	RPL_INFOSTART = 373, // IEUD
+	RPL_ENDOFINFO = 374, // IEUD
+	RPL_MOTDSTART = 375, // IEUD
+	RPL_ENDOFMOTD = 376, // IEUD
+	RPL_YOUREOPER = 381, // IEUD
+	RPL_REHASHING = 382, // IEUD
+	RPL_YOURESERVICE = 383, // ID
+	RPL_MYPORTIS = 384, // IEUD
+	RPL_NOTOPERANYMORE = 385, // IEUD
+	RPL_TIME = 391, // IEUD
+	RPL_USERSSTART = 392, // IED
+	RPL_USERS = 393, // IED
+	RPL_ENDOFUSERS = 394, // IED
+	RPL_NOUSERS = 395, // IED
+	ERR_NOSUCHNICK = 401, // IEUD
+	ERR_NOSUCHSERVER = 402, // IEUD
+	ERR_NOSUCHCHANNEL = 403, // IEUD
+	ERR_CANNOTSENDTOCHAN = 404, // IEUD
+	ERR_TOOMANYCHANNELS = 405, // IEUD
+	ERR_WASNOSUCHNICK = 406, // IEUD
+	ERR_TOOMANYTARGETS = 407, // IEUD
+	ERR_NOSUCHSERVICE = 408, // I
+	ERR_NOCOLORSONCHAN = 408, // D
+	ERR_NOORIGIN = 409, // IEUD
+	ERR_NORECIPIENT = 411, // IEUD
+	ERR_NOTEXTTOSEND = 412, // IEUD
+	ERR_NOTOPLEVEL = 413, // IEUD
+	ERR_WILDTOPLEVEL = 414, // IEUD
+	ERR_BADMASK = 415, // I
+	ERR_TOOMANYMATCHES = 416, // I
+	ERR_QUERYTOOLONG = 416, // U
+	ERR_UNKNOWNCOMMAND = 421, // IEUD
+	ERR_NOMOTD = 422, // IEUD
+	ERR_NOADMININFO = 423, // IEUD
+	ERR_FILEERROR = 424, // IED
+	ERR_TOOMANYAWAY = 429, // D
+	ERR_NONICKNAMEGIVEN = 431, // IEUD
+	ERR_ERRONEUSNICKNAME = 432, // IEUD
+	ERR_NICKNAMEINUSE = 433, // IEUD
+	ERR_SERVICENAMEINUSE = 434, // ID
+	ERR_SERVICECONFUSED = 435, // I
+	ERR_BANONCHAN = 435, // D
+	ERR_NICKCOLLISION = 436, // IEUD
+	ERR_UNAVAILRESOURCE = 437, // IE
+	ERR_BANNICKCHANGE = 437, // UD
+	ERR_DEAD = 438, // I
+	ERR_NICKTOOFAST = 438, // U
+	ERR_NCHANGETOOFAST = 438, // D
+	ERR_TARGETTOOFAST = 439, // UD
+	ERR_SERVICESDOWN = 440, // D
+	ERR_USERNOTINCHANNEL = 441, // IEUD
+	ERR_NOTONCHANNEL = 442, // IEUD
+	ERR_USERONCHANNEL = 443, // IEUD
+	ERR_NOLOGIN = 444, // IED
+	ERR_SUMMONDISABLED = 445, // IED
+	ERR_USERSDISABLED = 446, // IED
+	ERR_NOTREGISTERED = 451, // IEUD
+	ERR_IDCOLLISION = 452, // i
+	ERR_NICKLOST = 453, // i
+	ERR_HOSTILENAME = 455, // D
+	ERR_NEEDMOREPARAMS = 461, // IEUD
+	ERR_ALREADYREGISTRED = 462, // IEUD
+	ERR_NOPERMFORHOST = 463, // IEUD
+	ERR_PASSWDMISMATCH = 464, // IEUD
+	ERR_YOUREBANNEDCREEP = 465, // IEUD
+	ERR_YOUWILLBEBANNED = 466, // IEUD
+	ERR_KEYSET = 467, // IEUD
+	ERR_INVALIDUSERNAME = 468, // U
+	ERR_ONLYSERVERSCANCHANGE = 468, // D
+	ERR_CHANNELISFULL = 471, // IEUD
+	ERR_UNKNOWNMODE = 472, // IEUD
+	ERR_INVITEONLYCHAN = 473, // IEUD
+	ERR_BANNEDFROMCHAN = 474, // IEUD
+	ERR_BADCHANNELKEY = 475, // IEUD
+	ERR_BADCHANMASK = 476, // IEUD
+	ERR_MODELESS = 477, // E
+	ERR_NOCHANMODES = 477, // I
+	ERR_NEEDREGGEDNICK = 477, // D
+	ERR_BANLISTFULL = 478, // IEUD
+	ERR_BADCHANNAME = 479, // ED
+	ERR_NOPRIVILEGES = 481, // IEUD
+	ERR_CHANOPRIVSNEEDED = 482, // IEUD
+	ERR_CANTKILLSERVER = 483, // EUD
+	ERR_DESYNC = 484, // ED
+	ERR_ISCHANSERVICE = 484, // U
+	ERR_UNIQOPPRIVSNEEDED = 485, // I
+	ERR_CHANTOORECENT = 487, // i
+	ERR_TSLESSCHAN = 488, // i
+	ERR_VOICENEEDED = 489, // U
+	ERR_NOOPERHOST = 491, // IEUD
+	ERR_NOSERVICEHOST = 492, // I
+	ERR_UMODEUNKNOWNFLAG = 501, // IEUD
+	ERR_USERSDONTMATCH = 502, // IEUD
+	ERR_GHOSTEDCLIENT = 503, // ED
+	ERR_LAST_ERR_MSG = 504, // ED
+	ERR_SILELISTFULL = 511, // UD
+	ERR_NOSUCHGLINE = 512, // U
+	ERR_TOOMANYWATCH = 512, // D
+	ERR_BADPING = 513, // U
+	ERR_TOOMANYDCC = 514, // D
+	ERR_LISTSYNTAX = 521, // D
+	ERR_WHOSYNTAX = 522, // D
+	ERR_WHOLIMEXCEED = 523, // D
+	RPL_LOGON = 600, // D
+	RPL_LOGOFF = 601, // D
+	RPL_WATCHOFF = 602, // D
+	RPL_WATCHSTAT = 603, // D
+	RPL_NOWON = 604, // D
+	RPL_NOWOFF = 605, // D
+	RPL_WATCHLIST = 606, // D
+	RPL_ENDOFWATCHLIST = 607, // D
+	RPL_DCCSTATUS = 617, // D
+	RPL_DCCLIST = 618, // D
+	RPL_ENDOFDCCLIST = 619, // D
+	RPL_DCCINFO = 620, // D
+	ERR_NUMERIC_ERR = 999 // D
+};
+
+#endif

Added: trunk/clanlib/API/Network/NetObjects/netobject_client.h
===================================================================
--- trunk/clanlib/API/Network/NetObjects/netobject_client.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Network/NetObjects/netobject_client.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,104 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanNetwork=&quot;NetObjects&quot;
+//! header=network.h
+
+#ifndef header_netobject_client
+#define header_netobject_client
+
+#ifdef CL_API_DLL
+#ifdef CL_NETWORK_EXPORT
+#define CL_API_NETWORK __declspec(dllexport)
+#else
+#define CL_API_NETWORK __declspec(dllimport)
+#endif
+#else
+#define CL_API_NETWORK
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning(disable : 4786)
+#endif
+
+#include &lt;string&gt;
+#include &quot;../../signals.h&quot;
+
+class CL_NetObject_Client_Generic;
+class CL_NetPacket;
+class CL_NetObject_Controller_Generic;
+class CL_NetComputer;
+
+//: Network replication object, client version.
+//- !group=Network/NetObjects!
+//- !header=network.h!
+//- &lt;p&gt;The netobject is a message dispatcher for objects being replicated over the network.&lt;/p&gt;
+//- &lt;p&gt;It provides an easy system for a server object to send messages to replicated clients
+//- on remote computers, as well as getting answers back.&lt;/p&gt;
+class CL_API_NETWORK CL_NetObject_Client
+{
+//! Construction:
+public:
+	//: NetObject client constructor.
+	CL_NetObject_Client(int obj_id, const CL_NetComputer &amp;server, CL_NetObject_Controller_Generic *controller);
+
+	//: Copy constructor.
+	CL_NetObject_Client(const CL_NetObject_Client &amp;copy);
+
+	//: NetObject destructor.
+	virtual ~CL_NetObject_Client();
+
+//! Attributes:
+public:
+	//: Returns the netobject handle that identifies it over the network.
+	int get_obj_id() const;
+
+	//: Returns the netcomputer handle to the server of this object.
+	CL_NetComputer &amp;get_server() const;
+
+//! Operations:
+public:
+	//: Send a message to the server object.
+	void send(int msg_type, const CL_NetPacket &amp;message, bool reliable = true);
+
+//! Signals:
+public:
+	//: Signal emitted when receiving messages of the specified type from the server.
+	CL_Signal_v1&lt;CL_NetPacket &amp;&gt; &amp;sig_received_message(int msg_type);
+
+//! Implementation:
+private:
+	CL_NetObject_Client_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Network/NetObjects/netobject_controller.h
===================================================================
--- trunk/clanlib/API/Network/NetObjects/netobject_controller.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Network/NetObjects/netobject_controller.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,107 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanNetwork=&quot;NetObjects&quot;
+//! header=network.h
+
+#ifndef header_netobject_controller
+#define header_netobject_controller
+
+#ifdef CL_API_DLL
+#ifdef CL_NETWORK_EXPORT
+#define CL_API_NETWORK __declspec(dllexport)
+#else
+#define CL_API_NETWORK __declspec(dllimport)
+#endif
+#else
+#define CL_API_NETWORK
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning(disable : 4786)
+#endif
+
+#include &lt;string&gt;
+#include &quot;../../signals.h&quot;
+#include &quot;../NetSession/netcomputer.h&quot;
+#include &quot;../NetSession/netpacket.h&quot;
+
+class CL_NetObject_Controller_Generic;
+class CL_NetGroup;
+class CL_NetObject_Client;
+
+//: Network object replication channel.
+//- !group=Network/NetObjects!
+//- !header=network.h!
+//- &lt;p&gt;Manages a netchannel with netobject replication data. It dispatches incoming
+//- messages to the correct netobject.&lt;/p&gt;
+class CL_API_NETWORK CL_NetObject_Controller
+{
+//! Construction:
+public:
+	//: Constructs a netobject controller.
+	CL_NetObject_Controller(class CL_NetSession *netsession, const std::string &amp;channel);
+
+	//: Copy constructor.
+	CL_NetObject_Controller(const CL_NetObject_Controller &amp;copy);
+
+	//: NetObject Controller destructor.
+	virtual ~CL_NetObject_Controller();
+
+//! Attributes:
+public:
+
+//! Operations:
+public:
+	// Copy assignment operator.
+	CL_NetObject_Controller &amp;operator =(const CL_NetObject_Controller &amp;copy);
+
+//! Signals:
+public:
+	//: Signal that is called whenever the netobject channel receives a message for a netobject
+	//: it doesnt know. The application should hook a slot into this signal and determine what
+	//: to do with the message.
+	//- &lt;p&gt;CL_Signal_v3&lt;netobject, msgtype, message&gt;.&lt;/p&gt;
+	//- &lt;p&gt;Signal parameters:
+	//- CL_NetObject &amp;netobj_handle - Handle identifying the netobject created.
+	//- int msg_type - Message type of the message (the msg_type param used to send it with netobj.send()).
+	//- CL_NetPacket &amp;message - The message itself.&lt;/p&gt;
+	CL_Signal_v3&lt;CL_NetObject_Client &amp;, int, CL_NetPacket &amp;&gt; &amp;sig_create_object();
+
+//! Implementation:
+public:
+	//: NetObjectController implementation.
+	CL_NetObject_Controller_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Network/NetObjects/netobject_server.h
===================================================================
--- trunk/clanlib/API/Network/NetObjects/netobject_server.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Network/NetObjects/netobject_server.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,106 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanNetwork=&quot;NetObjects&quot;
+//! header=network.h
+
+#ifndef header_netobject_server
+#define header_netobject_server
+
+#ifdef CL_API_DLL
+#ifdef CL_NETWORK_EXPORT
+#define CL_API_NETWORK __declspec(dllexport)
+#else
+#define CL_API_NETWORK __declspec(dllimport)
+#endif
+#else
+#define CL_API_NETWORK
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning(disable : 4786)
+#endif
+
+#include &lt;string&gt;
+#include &quot;../../signals.h&quot;
+
+class CL_NetObject_Server_Generic;
+class CL_NetPacket;
+class CL_NetObject_Controller;
+class CL_NetComputer;
+class CL_NetGroup;
+
+//: Network replication object, server version.
+//- !group=Network/NetObjects!
+//- !header=network.h!
+//- &lt;p&gt;The netobject is a message dispatcher for objects being replicated over the network.&lt;/p&gt;
+//- &lt;p&gt;It provides an easy system for a server object to send messages to replicated clients
+//- on remote computers, as well as getting answers back.&lt;/p&gt;
+class CL_API_NETWORK CL_NetObject_Server
+{
+//! Construction:
+public:
+	//: Construct a new netobject, assigning it an unique handle that identifies it over the
+	//: network.
+	CL_NetObject_Server(CL_NetObject_Controller *controller);
+
+	//: Copy constructor.
+	CL_NetObject_Server(const CL_NetObject_Server &amp;copy);
+
+	//: NetObject destructor.
+	virtual ~CL_NetObject_Server();
+
+//! Attributes:
+public:
+	//: Returns the netobject handle that identifies it over the network.
+	int get_obj_id() const;
+
+//! Operations:
+public:
+	//: Send a message to client objects.
+	void send(CL_NetGroup &amp;group, int msg_type, const CL_NetPacket &amp;message, bool reliable = true);
+
+	//: Send a message to client object.
+	void send(CL_NetComputer &amp;computer, int msg_type, const CL_NetPacket &amp;message, bool reliable = true);
+
+//! Signals:
+public:
+	//: Signal emitted when receiving messages of the specified type from a client.
+	CL_Signal_v2&lt;CL_NetComputer &amp;, CL_NetPacket &amp;&gt; &amp;sig_received_message(int msg_type);
+
+//! Implementation:
+private:
+	CL_NetObject_Server_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Network/NetSession/inputsource_netpacket.h
===================================================================
--- trunk/clanlib/API/Network/NetSession/inputsource_netpacket.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Network/NetSession/inputsource_netpacket.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,116 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanNetwork=&quot;NetSessions&quot;
+//! header=network.h
+
+#ifndef header_inputsource_netpacket
+#define header_inputsource_netpacket
+
+#ifdef CL_API_DLL
+#ifdef CL_NETWORK_EXPORT
+#define CL_API_NETWORK __declspec(dllexport)
+#else
+#define CL_API_NETWORK __declspec(dllimport)
+#endif
+#else
+#define CL_API_NETWORK
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../../Core/IOData/inputsource.h&quot;
+
+class CL_NetPacket;
+class CL_InputSource_NetPacket_Generic;
+
+//: InputSource NetPacket Class
+//- !group=Network/NetSessions!
+//- !header=network.h!
+class CL_API_NETWORK CL_InputSource_NetPacket : public CL_InputSource
+{
+//! Construction:
+public:
+	//: InputSource NetPacket Constructor
+	CL_InputSource_NetPacket(const CL_NetPacket &amp;netpacket);
+
+	virtual ~CL_InputSource_NetPacket();
+
+//! Attributes:
+public:
+	//: Returns current position in input source.
+	//return: Current position in input source.
+	virtual int tell() const;
+
+	//: Returns the size of the input source
+	//return: Size of the input source.
+	virtual int size() const;
+
+//! Operations:
+public:
+	//: Reads larger amounts of data (no endian and 64 bit conversion).
+	//param data: Points to an array where the read data is stored.
+	//param size: Number of bytes to read.
+	//return: Num bytes actually read.
+	virtual int read(void *data, int size);
+	
+	//: Opens the input source. By default, it is open.
+	virtual void open();
+	
+	//: Closes the input source.
+	virtual void close();
+
+	//: Make a copy of the current inputsource, standing at the same position.
+	//return: The copy of the input source.
+	virtual CL_InputSource *clone() const;
+
+	//: Seeks to the specified position in the input source.
+	//param pos: Position relative to 'seek_type'.
+	//param seek_type: Defines what the 'pos' is relative to. Can be either seek_set, seek_cur og seek_end.
+	virtual void seek(int pos, SeekEnum seek_type);
+
+	//: Pushes the current input source position. The position can be restored again with pop_position.
+	virtual void push_position();
+	
+	//: Pops a previous pushed input source position (returns to the position).
+	virtual void pop_position();
+
+//! Implementation:
+private:
+	friend class CL_NetPacket;
+
+	// Constructor used to initialize internal CL_NetPacket member variable.
+	CL_InputSource_NetPacket();
+
+	CL_InputSource_NetPacket_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Network/NetSession/inputsource_netstream.h
===================================================================
--- trunk/clanlib/API/Network/NetSession/inputsource_netstream.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Network/NetSession/inputsource_netstream.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,117 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanNetwork=&quot;NetSessions&quot;
+//! header=network.h
+
+#ifndef header_inputsource_netstream
+#define header_inputsource_netstream
+
+#ifdef CL_API_DLL
+#ifdef CL_NETWORK_EXPORT
+#define CL_API_NETWORK __declspec(dllexport)
+#else
+#define CL_API_NETWORK __declspec(dllimport)
+#endif
+#else
+#define CL_API_NETWORK
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../../Core/IOData/inputsource.h&quot;
+
+class CL_NetStream;
+class CL_NetStream_Generic;
+
+//: InputSource NetStream Class
+//- !group=Network/NetSessions!
+//- !header=network.h!
+class CL_API_NETWORK CL_InputSource_NetStream : public CL_InputSource
+{
+//! Construction:
+public:
+	//: InputSource Netstream Constructor
+	CL_InputSource_NetStream(const CL_NetStream &amp;netstream);
+
+	virtual ~CL_InputSource_NetStream();
+
+//! Attributes:
+public:
+	//: Returns current position in input source.
+	//return: Current position in input source.
+	virtual int tell() const;
+
+	//: Returns the size of the input source
+	//return: Size of the input source.
+	virtual int size() const;
+
+//! Operations:
+public:
+	//: Reads larger amounts of data (no endian and 64 bit conversion).
+	//param data: Points to an array where the read data is stored.
+	//param size: Number of bytes to read.
+	//return: Num bytes actually read.
+	virtual int read(void *data, int size);
+	
+	//: Opens the input source. By default, it is open.
+	virtual void open();
+	
+	//: Closes the input source.
+	virtual void close();
+
+	//: Make a copy of the current inputsource, standing at the same position.
+	//return: The copy of the input source.
+	virtual CL_InputSource *clone() const;
+
+	//: Seeks to the specified position in the input source.
+	//param pos: Position relative to 'seek_type'.
+	//param seek_type: Defines what the 'pos' is relative to. Can be either seek_set, seek_cur og seek_end.
+	virtual void seek(int pos, SeekEnum seek_type);
+
+	//: Pushes the current input source position. The position can be restored again with pop_position.
+	virtual void push_position();
+	
+	//: Pops a previous pushed input source position (returns to the position).
+	virtual void pop_position();
+
+//! Implementation:
+private:
+	friend class CL_NetStream;
+
+	// Constructor used to initialize internal CL_NetStream member variable.
+	CL_InputSource_NetStream() { netstream = 0; ref_count_netstream = false; }
+
+	CL_NetStream_Generic *netstream;
+	bool ref_count_netstream;
+};
+
+#endif

Added: trunk/clanlib/API/Network/NetSession/netcomputer.h
===================================================================
--- trunk/clanlib/API/Network/NetSession/netcomputer.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Network/NetSession/netcomputer.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,114 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanNetwork=&quot;NetSessions&quot;
+//! header=network.h
+
+#ifndef header_netcomputer
+#define header_netcomputer
+
+#ifdef CL_API_DLL
+#ifdef CL_NETWORK_EXPORT
+#define CL_API_NETWORK __declspec(dllexport)
+#else
+#define CL_API_NETWORK __declspec(dllimport)
+#endif
+#else
+#define CL_API_NETWORK
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Socket/ip_address.h&quot;
+#include &quot;netsession.h&quot;
+
+class CL_NetComputer_Generic;
+
+//: Class representing a computer in a network game.
+//- !group=Network/NetSessions!
+//- !header=network.h!
+class CL_API_NETWORK CL_NetComputer
+{
+//! Construction:
+public:
+	//: Creates a netcomputer object.
+	CL_NetComputer();
+
+	CL_NetComputer(const CL_NetComputer &amp;copy);
+
+	//: Net Computer Destructor.
+	virtual ~CL_NetComputer();
+
+//! Attributes:
+public:
+	//: Returns the IP address (in network byte order) of the computer.
+	CL_IPAddress get_address() const;
+
+	//: Returns the netsession that the computer is attached to.
+	CL_NetSession get_session();
+
+	//: Returns true if computer is disconnected.
+	bool is_disconnected() const;
+
+	//: Returns the disconnect reason.
+	const std::string &amp;get_disconnect_reason() const;
+
+	//: Returns true if objects are the same.
+	bool operator == (const CL_NetComputer &amp;other_instance) const;
+
+	//: Returns true if the other netcomputer is less.
+	//- &lt;p&gt;This is used for sorting purposes (eg. if you use a std::map&lt;CL_NetComputer, Player&gt;).&lt;/p&gt;
+	bool operator &lt; (const CL_NetComputer &amp;other_instance) const;
+
+	//: Returns true if the other netcomputer is greater.
+	//- &lt;p&gt;This is used for sorting purposes (eg. if you use a std::map&lt;CL_NetComputer, Player&gt;).&lt;/p&gt;
+	bool operator &gt; (const CL_NetComputer &amp;other_instance) const;
+
+//! Operations:
+public:
+	//: Disconnects the computer from server.
+	void disconnect(std::string reason = (std::string)&quot;No reason given&quot;);
+
+	//: Send packet to the specified channel.
+	//- &lt;p&gt;set reliable to false to send with udp.&lt;/p&gt;
+	void send(const std::string &amp;packet_channel, const CL_NetPacket &amp;packet, bool reliable = true);
+
+	//: Copy Operator.
+	CL_NetComputer &amp;operator = (const CL_NetComputer &amp;other_instance);
+
+//! Implementation:
+public:
+	CL_NetComputer(class CL_NetComputer_Generic *impl);
+
+	CL_NetComputer_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Network/NetSession/netgroup.h
===================================================================
--- trunk/clanlib/API/Network/NetSession/netgroup.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Network/NetSession/netgroup.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,81 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanNetwork=&quot;NetSessions&quot;
+//! header=network.h
+
+#ifndef header_netgroup
+#define header_netgroup
+
+#ifdef CL_API_DLL
+#ifdef CL_NETWORK_EXPORT
+#define CL_API_NETWORK __declspec(dllexport)
+#else
+#define CL_API_NETWORK __declspec(dllimport)
+#endif
+#else
+#define CL_API_NETWORK
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;list&gt;
+#include &quot;netcomputer.h&quot;
+
+//: Represents a group of computers.
+//- !group=Network/NetSessions!
+//- !header=network.h!
+class CL_API_NETWORK CL_NetGroup : public std::list&lt;CL_NetComputer&gt;
+{
+//! Construction:
+public:
+	//: Constructs a group.
+	//param computer: Add this computer to group.
+	//param group: Add this group of computers to the group.
+	CL_NetGroup();
+
+	CL_NetGroup(const CL_NetComputer &amp;computer);
+
+	CL_NetGroup(const std::list&lt;CL_NetComputer&gt; &amp;group);
+
+//! Operations:
+public:
+	//: Send packet to all the computers in the group.
+	void send(const std::string &amp;packet_channel, const CL_NetPacket &amp;packet, bool reliable = true);
+
+	//: Disconnects all computers in the group.
+	void disconnect();
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/API/Network/NetSession/netpacket.h
===================================================================
--- trunk/clanlib/API/Network/NetSession/netpacket.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Network/NetSession/netpacket.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,111 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanNetwork=&quot;NetSessions&quot;
+//! header=network.h
+
+#ifndef header_netpacket
+#define header_netpacket
+
+#ifdef CL_API_DLL
+#ifdef CL_NETWORK_EXPORT
+#define CL_API_NETWORK __declspec(dllexport)
+#else
+#define CL_API_NETWORK __declspec(dllimport)
+#endif
+#else
+#define CL_API_NETWORK
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;inputsource_netpacket.h&quot;
+#include &quot;outputsource_netpacket.h&quot;
+#include &lt;string&gt;
+#include &lt;list&gt;
+
+class CL_NetComputer;
+class CL_NetPacket_Generic;
+
+//: Net packet class.
+//- !group=Network/NetSessions!
+//- !header=network.h!
+class CL_API_NETWORK CL_NetPacket
+{
+//! Construction:
+public:
+	//: Constructs a packet.
+	//param data, size: Initial data for packet.
+	CL_NetPacket();
+
+	CL_NetPacket(const void *data, int size);
+
+	CL_NetPacket(const std::string &amp;data);
+
+	CL_NetPacket(const CL_NetPacket &amp;copy);
+
+	// Destructor.
+	~CL_NetPacket();
+
+//! Attributes:
+public:
+	//: Returns a pointer to netpacket data.
+	unsigned char *get_data();
+
+	const unsigned char *get_data() const;
+
+	//: Return size of netpacket data.
+	int get_size() const;
+
+	//: Input source interface for netpacket.
+	CL_InputSource_NetPacket input;
+
+	//: Output source interface for netpacket.
+	CL_OutputSource_NetPacket output;
+
+//! Operations:
+public:
+	//: Resize data. Does not destroy the old data in the packet.
+	void resize(int new_size);
+
+	// Copy assignment operator.
+	CL_NetPacket &amp;operator =(const CL_NetPacket &amp;copy);
+
+//! Implementation:
+private:
+	friend class CL_InputSource_NetPacket;
+	friend class CL_OutputSource_NetPacket;
+	friend class CL_NetComputer;
+
+	CL_NetPacket_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Network/NetSession/netsession.h
===================================================================
--- trunk/clanlib/API/Network/NetSession/netsession.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Network/NetSession/netsession.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,131 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanNetwork=&quot;NetSessions&quot;
+//! header=network.h
+
+#ifndef header_netsession
+#define header_netsession
+
+#ifdef CL_API_DLL
+#ifdef CL_NETWORK_EXPORT
+#define CL_API_NETWORK __declspec(dllexport)
+#else
+#define CL_API_NETWORK __declspec(dllimport)
+#endif
+#else
+#define CL_API_NETWORK
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../../signals.h&quot;
+#include &lt;string&gt;
+class CL_NetStream;
+class CL_NetPacket;
+class CL_NetComputer;
+class CL_NetSession_Generic;
+class CL_IPAddress;
+class CL_NetGroup;
+
+//: Net session class.
+//- !group=Network/NetSessions!
+//- !header=network.h!
+class CL_API_NETWORK CL_NetSession
+{
+//! Construction:
+public:
+	//: Constructs a netsession.
+	//param app_id: Application identifier. This must match any remote
+	//param app_id: netsession connecting to/from this netsession.
+	CL_NetSession(const std::string &amp;app_id);
+
+	CL_NetSession(const CL_NetSession &amp;copy);
+
+	virtual ~CL_NetSession();
+
+//! Attributes:
+public:
+	//: Returns a list of all computers connected.
+	CL_NetGroup &amp;get_all();
+
+//! Operations:
+public:
+	//: Start listening for connections.
+	void start_listen(const std::string &amp;listen_port);
+
+	//: Stop listening for connections and disconnect everyone.
+	void stop_listen();
+
+	//: Connect to remote netsession.
+	CL_NetComputer connect(const CL_IPAddress &amp;address);
+
+	//: Connect to remote netsession asyncronously.
+	//- &lt;p&gt;The DNS lookup and connect is done in a worker thread, thus not
+	//- blocking the calling thread. If the connection fails,
+	//- CL_NetSession::sig_disconnected() is emitted.&lt;/p&gt;
+	CL_NetComputer connect_async(const std::string &amp;hostname, const std::string &amp;port);
+
+	//: Enable or disable debug output.
+	//- &lt;p&gt;This will output the netchannels each netpacket arrive in.&lt;/p&gt;
+	void show_debug(bool enable = true);
+
+//! Signals:
+public:
+	//: Signal invoked when a computer connects to the netsession server.
+	CL_Signal_v1&lt;CL_NetComputer &amp;&gt; &amp;sig_computer_connected();
+
+	//: Signal invoked when a computer re-connects to the netsession server.
+	//- &lt;p&gt;This happens when a CL_NetComputer instance has still not been destroyed
+	//- since its last connect (allows you to recognize players dropping out, so
+	//- they dont loose their score when they reconnect).&lt;/p&gt;
+	CL_Signal_v1&lt;CL_NetComputer &amp;&gt; &amp;sig_computer_reconnected();
+
+	//: Signal invoked when a computer disconnects from the netsession server.
+	CL_Signal_v1&lt;CL_NetComputer &amp;&gt; &amp;sig_computer_disconnected();
+
+	//: Signal invoked when someone makes a connection to the specified
+	//: netstream.
+	CL_Signal_v1&lt;CL_NetStream &amp;&gt; &amp;sig_netstream_connect(const std::string &amp;netstream);
+
+	//: Signal invoked when someone sends a netpacket to the specified packet channel.
+	CL_Signal_v2&lt;CL_NetPacket &amp;, CL_NetComputer &amp;&gt; &amp;sig_netpacket_receive(const std::string &amp;packet_channel);
+
+//! Implementation:
+public:
+	CL_NetSession(CL_NetSession_Generic *impl);
+private:
+	CL_NetSession_Generic *impl;
+
+	friend class CL_NetStream;
+};
+
+#endif

Added: trunk/clanlib/API/Network/NetSession/netstream.h
===================================================================
--- trunk/clanlib/API/Network/NetSession/netstream.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Network/NetSession/netstream.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,116 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanNetwork=&quot;NetSessions&quot;
+//! header=network.h
+
+#ifndef header_netstream
+#define header_netstream
+
+#ifdef CL_API_DLL
+#ifdef CL_NETWORK_EXPORT
+#define CL_API_NETWORK __declspec(dllexport)
+#else
+#define CL_API_NETWORK __declspec(dllimport)
+#endif
+#else
+#define CL_API_NETWORK
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning(disable : 4786)
+#endif
+
+#include &quot;inputsource_netstream.h&quot;
+#include &quot;outputsource_netstream.h&quot;
+#include &lt;string&gt;
+
+class CL_NetSession;
+class CL_NetComputer;
+class CL_EventTrigger;
+class CL_NetStream_Generic;
+
+//: Net stream class.
+//- !group=Network/NetSessions!
+//- !header=network.h!
+class CL_API_NETWORK CL_NetStream
+{
+//! Construction:
+public:
+	//: Connects to a remote netstream.
+	//param stream_channel: Channel identifier establishing connection to.
+	//param dest: Remote computer on which to connect.
+	CL_NetStream(
+		const std::string &amp;stream_channel,
+		CL_NetComputer &amp;dest);
+
+	CL_NetStream(const CL_NetStream &amp;copy);
+
+	virtual ~CL_NetStream();
+
+//! Attributes:
+public:
+	//: Input source interface for netstream.
+	CL_InputSource_NetStream input;
+
+	//: Output source interface for netstream.
+	CL_OutputSource_NetStream output;
+
+	//: Event trigger for reading.
+	CL_EventTrigger *get_read_trigger();
+
+	//: Event trigger for writing.
+	CL_EventTrigger *get_write_trigger();
+
+	//: Get remote computer
+	CL_NetComputer get_computer();
+
+//! Operations:
+public:
+	//: Copy constructor.
+	CL_NetStream &amp;operator =(const CL_NetStream &amp;copy);
+
+	//: Send data onto stream.
+	int send(const void *data, int size);
+
+	//: Receive data from stream.
+	int recv(void *data, int size);
+
+//! Implementation:
+public:
+	CL_NetStream(CL_NetStream_Generic *impl);
+
+	CL_NetStream_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Network/NetSession/outputsource_netpacket.h
===================================================================
--- trunk/clanlib/API/Network/NetSession/outputsource_netpacket.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Network/NetSession/outputsource_netpacket.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,105 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanNetwork=&quot;NetSessions&quot;
+//! header=network.h
+
+#ifndef header_outputsource_netpacket
+#define header_outputsource_netpacket
+
+#ifdef CL_API_DLL
+#ifdef CL_NETWORK_EXPORT
+#define CL_API_NETWORK __declspec(dllexport)
+#else
+#define CL_API_NETWORK __declspec(dllimport)
+#endif
+#else
+#define CL_API_NETWORK
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../../Core/IOData/outputsource.h&quot;
+
+class CL_NetPacket;
+class CL_OutputSource_NetPacket_Generic;
+
+//: Output Source NetPacket Class.
+//- !group=Network/NetSessions!
+//- !header=network.h!
+class CL_API_NETWORK CL_OutputSource_NetPacket : public CL_OutputSource
+{
+//! Construction:
+public:
+	//: Output Source NetPacket Constructor.
+	CL_OutputSource_NetPacket(const CL_NetPacket &amp;netpacket);
+
+	virtual ~CL_OutputSource_NetPacket();
+
+//! Attributes:
+public:
+	//: Returns current position in output source.
+	//return: Current position in source.
+	virtual int tell() const;
+
+	//: Returns the size of the output source
+	//return: Size of the output source.
+	virtual int size() const;
+
+//! Operations:
+public:
+	//: Writes larger amounts of data (no endian and 64 bit conversion):
+	//param data: Points to the array from which to write.
+	//param size: Number of bytes to write.
+	//return: Num bytes actually written.
+	virtual int write(const void *data, int size);
+	
+	//: Opens the output source. By default, it is open.
+	virtual void open();
+	
+	//: Closes the output source.
+	virtual void close();
+
+	//: Make a copy of the current outputsource, standing at the same position.
+	//return: The copy of the output source.
+	virtual CL_OutputSource *clone();
+
+//! Implementation:
+private:
+	friend class CL_NetPacket;
+
+	// Constructor used to initialize internal CL_NetPacket member variable.
+	CL_OutputSource_NetPacket();
+
+	CL_OutputSource_NetPacket_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Network/NetSession/outputsource_netstream.h
===================================================================
--- trunk/clanlib/API/Network/NetSession/outputsource_netstream.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Network/NetSession/outputsource_netstream.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,106 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanNetwork=&quot;NetSessions&quot;
+//! header=network.h
+
+#ifndef header_outputsource_netstream
+#define header_outputsource_netstream
+
+#ifdef CL_API_DLL
+#ifdef CL_NETWORK_EXPORT
+#define CL_API_NETWORK __declspec(dllexport)
+#else
+#define CL_API_NETWORK __declspec(dllimport)
+#endif
+#else
+#define CL_API_NETWORK
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../../Core/IOData/outputsource.h&quot;
+
+class CL_NetStream;
+class CL_NetStream_Generic;
+
+//: Output Source NetStream Class.
+//- !group=Network/NetSessions!
+//- !header=network.h!
+class CL_API_NETWORK CL_OutputSource_NetStream : public CL_OutputSource
+{
+//! Construction:
+public:
+	//: Output Source NetStream Constructor.
+	CL_OutputSource_NetStream(const CL_NetStream &amp;netstream);
+
+	virtual ~CL_OutputSource_NetStream();
+
+//! Attributes:
+public:
+	//: Returns current position in output source.
+	//return: Current position in source.
+	virtual int tell() const;
+
+	//: Returns the size of the output source.
+	//return: Size of the output source.
+	virtual int size() const;
+
+//! Operations:
+public:
+	//: Writes larger amounts of data (no endian and 64 bit conversion).
+	//param data: Points to the array from which to write.
+	//param size: Number of bytes to write.
+	//return: Num bytes actually written.
+	virtual int write(const void *data, int size);
+	
+	//: Opens the output source. By default, it is open.
+	virtual void open();
+	
+	//: Closes the output source.
+	virtual void close();
+
+	//: Make a copy of the current outputsource, standing at the same position.
+	//return: The copy of the output source.
+	virtual CL_OutputSource *clone();
+
+//! Implementation:
+private:
+	friend class CL_NetStream;
+
+	// Constructor used to initialize internal CL_NetStream member variable.
+	CL_OutputSource_NetStream() { netstream = 0; ref_count_netstream = false; }
+
+	CL_NetStream_Generic *netstream;
+	bool ref_count_netstream;
+};
+
+#endif

Added: trunk/clanlib/API/Network/NetVariables/netvariables.h
===================================================================
--- trunk/clanlib/API/Network/NetVariables/netvariables.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Network/NetVariables/netvariables.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,114 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanNetwork=&quot;NetObjects&quot;
+//! header=network.h
+
+#ifndef header_netvariables
+#define header_netvariables
+
+#ifdef CL_API_DLL
+#ifdef CL_NETWORK_EXPORT
+#define CL_API_NETWORK __declspec(dllexport)
+#else
+#define CL_API_NETWORK __declspec(dllimport)
+#endif
+#else
+#define CL_API_NETWORK
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+class CL_NetVariables_Generic;
+class CL_InputSource;
+class CL_OutputSource;
+
+//: Easy serialization of a data structure.
+//- !group=Network/NetObjects!
+//- !header=network.h!
+//- &lt;p&gt;The netvariables class is used to read a set of variables from an object,
+//- and write them structured, in network byte order, to an output source.&lt;/p&gt;
+//-
+//- &lt;p&gt;The Netvariables interface can also read the data again, and produce 'diff'
+//- packages where it only write variables that have changed since last write.&lt;/p&gt;
+class CL_API_NETWORK CL_NetVariables
+{
+//! Construction:
+public:
+	//: Construct a netvariables object.
+	CL_NetVariables();
+
+	//: Net Variables Destructor
+	virtual ~CL_NetVariables();
+
+//! Attributes:
+
+	//: Returns true if the variables have changed since last save.
+	bool is_different();
+
+//! Operations:
+
+	//: Add booleans to the data structure.
+	void add_bool(bool *var, int array = 1);
+
+	//: Add integers to the data structure.
+	void add_int(int *var, int array = 1);
+
+	//: Add shorts to the data structure.
+	void add_short(short *var, int array = 1);
+
+	//: Add floats to the data structure.
+	void add_float(float *var, int array = 1);
+
+	//: Add doubles to the data structure.
+	void add_double(double *var, int array = 1);
+
+	//: Add structures to the data structure.
+	void add_vars(CL_NetVariables *variables, int array = 1);
+
+	//: Write all variables in the data structure to the output source.
+	void save_all(class CL_OutputSource *msg);
+
+	//: Read all variables in the data structure from the input source.
+	void load_all(class CL_InputSource *msg);
+
+	//: Write all variables that have changed since last save.
+	void save_diff(class CL_OutputSource *msg);
+
+	//: Read a diff produced with save_diff from the input source.
+	void load_diff(class CL_InputSource *msg);
+
+//! Implementation:
+public:
+	CL_NetVariables_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Network/Socket/inputsource_socket.h
===================================================================
--- trunk/clanlib/API/Network/Socket/inputsource_socket.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Network/Socket/inputsource_socket.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,117 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanNetwork=&quot;Sockets&quot;
+//! header=network.h
+
+#ifndef header_inputsource_socket
+#define header_inputsource_socket
+
+#ifdef CL_API_DLL
+#ifdef CL_NETWORK_EXPORT
+#define CL_API_NETWORK __declspec(dllexport)
+#else
+#define CL_API_NETWORK __declspec(dllimport)
+#endif
+#else
+#define CL_API_NETWORK
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../../Core/IOData/inputsource.h&quot;
+
+class CL_Socket;
+class CL_Socket_Generic;
+
+//: InputSource Socket Class
+//- !group=Network/Sockets!
+//- !header=network.h!
+class CL_API_NETWORK CL_InputSource_Socket : public CL_InputSource
+{
+//! Construction:
+public:
+	//: InputSource Socket Constructor.
+	CL_InputSource_Socket(const CL_Socket &amp;socket);
+
+	virtual ~CL_InputSource_Socket();
+
+//! Attributes:
+public:
+	//: Returns current position in input source.
+	//return: Current position in input source.
+	virtual int tell() const;
+
+	//: Returns the size of the input source
+	//return: Size of the input source.
+	virtual int size() const;
+
+//! Operations:
+public:
+	//: Reads larger amounts of data (no endian and 64 bit conversion).
+	//param data: Points to an array where the read data is stored.
+	//param size: Number of bytes to read.
+	//return: Num bytes actually read.
+	virtual int read(void *data, int size);
+	
+	//: Opens the input source. By default, it is open.
+	virtual void open();
+	
+	//: Closes the input source.
+	virtual void close();
+
+	//: Make a copy of the current inputsource, standing at the same position.
+	//return: The copy of the input source.
+	virtual CL_InputSource *clone() const;
+
+	//: Seeks to the specified position in the input source.
+	//param pos: Position relative to 'seek_type'.
+	//param seek_type: Defines what the 'pos' is relative to. Can be either seek_set, seek_cur og seek_end.
+	virtual void seek(int pos, SeekEnum seek_type);
+
+	//: Pushes the current input source position. The position can be restored again with pop_position.
+	virtual void push_position();
+	
+	//: Pops a previous pushed input source position (returns to the position).
+	virtual void pop_position();
+
+//! Implementation:
+private:
+	friend class CL_Socket;
+
+	// Constructor used to initialize internal CL_Socket member variable.
+	CL_InputSource_Socket() { socket = 0; ref_count_socket = false; }
+
+	CL_Socket_Generic *socket;
+	bool ref_count_socket;
+};
+
+#endif

Added: trunk/clanlib/API/Network/Socket/ip_address.h
===================================================================
--- trunk/clanlib/API/Network/Socket/ip_address.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Network/Socket/ip_address.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,128 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanNetwork=&quot;Sockets&quot;
+//! header=network.h
+
+#ifndef header_ip_address
+#define header_ip_address
+
+#ifdef CL_API_DLL
+#ifdef CL_NETWORK_EXPORT
+#define CL_API_NETWORK __declspec(dllexport)
+#else
+#define CL_API_NETWORK __declspec(dllimport)
+#endif
+#else
+#define CL_API_NETWORK
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+
+class CL_IPAddress_Generic;
+
+//: Socket name; container class for an IP address and port.
+//- !group=Network/Sockets!
+//- !header=network.h!
+class CL_API_NETWORK CL_IPAddress
+{
+//! Construction:
+public:
+	//: Constructs an IP address using INADDR_ANY and port 0.
+	CL_IPAddress();
+
+	//: Constructs an IP address using INADDR_ANY and the specified port.
+	CL_IPAddress(const std::string &amp;port);
+
+	//: Construct an IP address using the hostname and the port.
+	CL_IPAddress(const std::string &amp;hostname, const std::string &amp;port);
+
+	//: Copy constructor.
+	CL_IPAddress(const CL_IPAddress &amp;copy);
+
+//! Attributes:
+public:
+	//: Returns the internal addrinfo struct
+	void get_addrinfo(int type, struct sockaddr &amp;addr, int &amp;len, int domain) const;
+
+	//: Returns the IP address as a string.
+	std::string get_address() const;
+
+	//: Returns the IP port as a string.
+	std::string get_port() const;
+
+	//: Returns true if objects are the same.
+	bool operator == (const CL_IPAddress &amp;other_instance) const;
+
+	//: Returns true if the other address is less.
+	//- &lt;p&gt;This is used for sorting
+	//- purposes (eg. if you use a std::map&lt;CL_IPAddress, CL_Socket&gt;), and sorts
+	//- the address based on lowest IP number address.&lt;/p&gt;
+	bool operator &lt; (const CL_IPAddress &amp;other_instance) const;
+
+	//: Returns true if the other address is greater.
+	//- &lt;p&gt;This is used for sorting
+	//- purposes (eg. if you use a std::map&lt;CL_IPAddress, CL_Socket&gt;), and sorts
+	//- the address based on lowest IP number address.&lt;/p&gt;
+	bool operator &gt; (const CL_IPAddress &amp;other_instance) const;
+
+//! Operations:
+public:
+
+	//: Set the IP address using a hostname and port.
+	//param hostname: Can be an IPv4 dotted-quad, hostname or a valid IPv6 address.
+	//param port: Port number.
+	void set_address(const std::string &amp;hostname, const std::string &amp;port);
+
+	//: Set the IP port.  Note, this will reset the hostname to the default value of any host.
+	void set_port(const std::string &amp;port);
+
+	//: Do a DNS lookup on the IP address.
+	std::string dns_lookup() const;
+	
+	//: Check to see if the address has an IPv4 mapping
+	//: is_ipv4() and is_ipv6() are not mutally exclusive
+	//: An address can have both IPv4 and IPv6 mappings
+	bool is_ipv4() const;
+	
+	//: Check to see if the address has an IPv6 mapping
+	//: is_ipv4() and is_ipv6() are not mutally exclusive
+	//: An address can have both IPv4 and IPv6 mappings
+	bool is_ipv6() const;
+
+//! Implementation:
+private:
+	CL_IPAddress_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Network/Socket/outputsource_socket.h
===================================================================
--- trunk/clanlib/API/Network/Socket/outputsource_socket.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Network/Socket/outputsource_socket.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,106 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanNetwork=&quot;Sockets&quot;
+//! header=network.h
+
+#ifndef header_outputsource_socket
+#define header_outputsource_socket
+
+#ifdef CL_API_DLL
+#ifdef CL_NETWORK_EXPORT
+#define CL_API_NETWORK __declspec(dllexport)
+#else
+#define CL_API_NETWORK __declspec(dllimport)
+#endif
+#else
+#define CL_API_NETWORK
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../../Core/IOData/outputsource.h&quot;
+
+class CL_Socket;
+class CL_Socket_Generic;
+
+//: Output Source Socket Class.
+//- !group=Network/Sockets!
+//- !header=network.h!
+class CL_API_NETWORK CL_OutputSource_Socket : public CL_OutputSource
+{
+//! Construction:
+public:
+	//: Output Source Socket Constructor
+	CL_OutputSource_Socket(const CL_Socket &amp;socket);
+
+	virtual ~CL_OutputSource_Socket();
+
+//! Attributes:
+public:
+	//: Returns current position in output source.
+	//return: Current position in source.
+	virtual int tell() const;
+
+	//: Returns the size of the output source
+	//return: Size of the output source.
+	virtual int size() const;
+
+//! Operations:
+public:
+	//: Writes larger amounts of data (no endian and 64 bit conversion).
+	//param data: Points to the array from which to write.
+	//param size: Number of bytes to write.
+	//return: Num bytes actually written.
+	virtual int write(const void *data, int size);
+	
+	//: Opens the output source. By default, it is open.
+	virtual void open();
+	
+	//: Closes the output source.
+	virtual void close();
+
+	//: Make a copy of the current outputsource, standing at the same position.
+	//return: The copy of the output source.
+	virtual CL_OutputSource *clone();
+
+//! Implementation:
+private:
+	friend class CL_Socket;
+
+	// Constructor used to initialize internal CL_Socket member variable.
+	CL_OutputSource_Socket() { socket = 0; ref_count_socket = false; }
+
+	CL_Socket_Generic *socket;
+	bool ref_count_socket;
+};
+
+#endif

Added: trunk/clanlib/API/Network/Socket/socket.h
===================================================================
--- trunk/clanlib/API/Network/Socket/socket.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Network/Socket/socket.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,203 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanNetwork=&quot;Sockets&quot;
+//! header=network.h
+
+#ifndef header_socket
+#define header_socket
+
+#ifdef CL_API_DLL
+#ifdef CL_NETWORK_EXPORT
+#define CL_API_NETWORK __declspec(dllexport)
+#else
+#define CL_API_NETWORK __declspec(dllimport)
+#endif
+#else
+#define CL_API_NETWORK
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../../signals.h&quot;
+#include &quot;ip_address.h&quot;
+#include &quot;inputsource_socket.h&quot;
+#include &quot;outputsource_socket.h&quot;
+
+class CL_EventTrigger;
+class CL_Socket_Generic;
+
+//: This is the lowlevel raw socket interface in clanlib.
+//- !group=Network/Sockets!
+//- !header=network.h!
+class CL_API_NETWORK CL_Socket
+{
+public:
+	//: Type enum
+	enum Type
+	{
+		tcp,
+		udp
+	};
+
+	//: ShutdownHow enum
+	enum ShutdownHow
+	{
+		shutdown_receive,
+		shutdown_send
+	};
+	
+	//: Which protocol to use
+	enum Protocol
+	{
+		ipv4,
+		ipv6
+	};
+
+//! Construction:
+public:
+	//: Constructs a null socket.
+	CL_Socket();
+
+	//: Constructs an attached socket.
+	CL_Socket(int socket);
+
+	//: Constructs a new socket using the specified protocol type.
+	CL_Socket(Type type, Protocol proto = ipv4);
+
+	//: Copy constructor.
+	CL_Socket(const CL_Socket &amp;copy);
+
+	//: Socket destructor
+	virtual ~CL_Socket();
+
+//! Attributes:
+public:
+	//: Input source that operates on the socket.
+	CL_InputSource_Socket input;
+
+	//: Output source that operates on the socket.
+	CL_OutputSource_Socket output;
+
+	//: Returns the raw socket handle (for use with the lowlevel socket functions).
+	int get_socket() const;
+
+	//: Returns the maximum size of a message for message-oriented socket types (CL_Socket::udp).
+	int get_max_msg_size() const;
+
+	//: Returns an event trigger that triggers when socket has data ready to be read.
+	CL_EventTrigger *get_read_trigger() const;
+
+	//: Returns an event trigger that triggers when socket is ready for additional data.
+	CL_EventTrigger *get_write_trigger() const;
+
+	//: Returns an event trigger that triggers when an exception occurs on the socket.
+	CL_EventTrigger *get_exception_trigger() const;
+
+	//: Returns the socket name.
+	CL_IPAddress get_source_address() const;
+
+	//: Returns the name of the destination socket we are connected to.
+	CL_IPAddress get_dest_address() const;
+
+	//: Returns the list of broadcast addresses available to this socket. Works for UDP on IPv4 only.
+	std::list&lt;CL_IPAddress&gt; get_broadcast_addresses(const std::string&amp;) const;
+
+//! Operations:
+public:
+	//: Copy operator.
+	CL_Socket &amp;operator =(const CL_Socket &amp;other);
+
+	//: Sets the socket blocking mode.
+	void set_nonblocking(bool nonblocking = true);
+
+	//: If enabled, don't delay send to coalesce packets.
+	void set_nodelay(bool nodelay = true);
+
+	//: If enabled, do broadcasting. Works for UDP on IPv4 only
+	void set_broadcasting(bool broadcasting = true);
+
+	//: Writes data to socket. Returns the amount that was written.
+	int send(const void *data, int size);
+
+	//: Writes data to socket, using the specified destination host.
+	int send(const void *data, int size, const CL_IPAddress &amp;dest);
+
+	//: Writes data to socket. Returns the amount that was written.
+	int send(const std::string &amp;string);
+
+	//: Push data back into the received data buffer.
+	void push(const std::string &amp;string);
+
+	//: Reads data from the socket. Returns the amount that was read.
+	int recv(void *data, int size);
+
+	//: Reads data from the socket, storing the from address in the passed parameter.
+	int recv(void *data, int size, CL_IPAddress &amp;from);
+
+	//: Initiate a connection on the socket.
+	void connect(const CL_IPAddress &amp;address);
+
+	//: Shut down part of full-duplex connection.
+	void shutdown(ShutdownHow how);
+
+	//: Bind the socket to the specified address.
+	void bind(const CL_IPAddress &amp;address);
+
+	//: Listen for connections on the socket.
+	void listen(int backlog);
+
+	//: Accept a connection on the socket.
+	CL_Socket accept();
+
+//! Signals:
+public:
+	//: This signal is invoked when the socket has data ready to be read.
+	CL_Signal_v0 &amp;sig_read_triggered();
+
+	//: This signal is invoked when the socket has data ready to be written.
+	CL_Signal_v0 &amp;sig_write_triggered();
+
+	//: This signal is invoked when an exception occurred on the socket.
+	CL_Signal_v0 &amp;sig_exception_triggered();
+	
+	//: This signal is invoked when the remote side drops the connection, either through timeout 
+	//: or explicit shutdown
+	CL_Signal_v0 &amp;sig_disconnected();
+
+//! Implementation:
+public:
+	CL_Socket(class CL_Socket_Generic *impl);
+	CL_Socket_Generic *impl;
+	Type proto;
+};
+
+#endif

Added: trunk/clanlib/API/Network/setupnetwork.h
===================================================================
--- trunk/clanlib/API/Network/setupnetwork.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Network/setupnetwork.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,73 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanNetwork=&quot;System&quot;
+//! header=network.h
+
+#ifndef header_setupnetwork
+#define header_setupnetwork
+
+#ifdef CL_API_DLL
+#ifdef CL_NETWORK_EXPORT
+#define CL_API_NETWORK __declspec(dllexport)
+#else
+#define CL_API_NETWORK __declspec(dllimport)
+#endif
+#else
+#define CL_API_NETWORK
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+//: Initialization class for clanNetwork.
+//- !group=Network/System!
+//- !header=network.h!
+class CL_API_NETWORK CL_SetupNetwork
+{
+//! Construction:
+public:
+	//: Initializes clanNetwork.
+	//- &lt;p&gt;Constructing a CL_SetupNetwork object is equalent to calling CL_SetupNetwork::init().&lt;/p&gt;
+	//- &lt;p&gt;When the CL_SetupNetwork instance is destroyed, CL_SetupNetwork::deinit() is called.&lt;/p&gt;
+	CL_SetupNetwork(bool register_resources_only = false);
+
+	~CL_SetupNetwork();
+
+//! Operations:
+public:
+	//: Initialize network.
+	static void init(bool register_resources_only = false);
+
+	//: Deinitialize network.
+	static void deinit();
+};
+
+#endif

Added: trunk/clanlib/API/SDL/setupsdl.h
===================================================================
--- trunk/clanlib/API/SDL/setupsdl.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/SDL/setupsdl.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,73 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSDL=&quot;System&quot;
+//! header=sdl.h
+
+#ifndef header_setupsdl
+#define header_setupsdl
+
+#ifdef CL_API_DLL
+#ifdef CL_SDL_EXPORT
+#define CL_API_SDL __declspec(dllexport)
+#else
+#define CL_API_SDL __declspec(dllimport)
+#endif
+#else
+#define CL_API_SDL
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+//: ClanSDL initialization functions.
+//- !group=SDL/System!
+//- !header=sdl.h!
+class CL_API_SDL CL_SetupSDL
+{
+//! Construction:
+public:
+	//: Initializes clanSDL.
+	//- &lt;p&gt;Constructing a CL_SetupSDL object is equalent to calling CL_SetupSDL::init().&lt;/p&gt;
+	//- &lt;p&gt;When the CL_SetupSDL instance is destroyed, CL_SetupSDL::deinit() is called.&lt;/p&gt;
+	CL_SetupSDL(bool register_resources_only = false);
+
+	~CL_SetupSDL();
+
+//! Operations:
+public:
+	//: Initialize the clanSDL library.
+	static void init(bool register_resources_only = false);
+	
+	//: Deinitialize the clanSDL library.
+	static void deinit();
+};
+
+#endif

Added: trunk/clanlib/API/Signals/signal.h
===================================================================
--- trunk/clanlib/API/Signals/signal.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Signals/signal.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,55 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef header_signal
+#define header_signal
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+class CL_Slot;
+
+//: Parent class for all signal types.
+class CL_Signal
+{
+//! Construction:
+public:
+	virtual ~CL_Signal() { return; }
+
+//! Operations:
+public:
+	//: Disconnect
+	virtual void disconnect(CL_Slot &amp;disconnect_slot)=0;
+};
+
+#endif

Added: trunk/clanlib/API/Signals/signal_v0.h
===================================================================
--- trunk/clanlib/API/Signals/signal_v0.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Signals/signal_v0.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,279 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef header_signal_v0
+#define header_signal_v0
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning ( disable : 4786 )
+#pragma warning ( disable : 4355 ) // warning C4355: 'this' : used in base member initializer list
+#endif
+
+#include &quot;signal.h&quot;
+#include &quot;slot.h&quot;
+#include &quot;slot_v0.h&quot;
+#include &lt;list&gt;
+#include &lt;algorithm&gt;
+
+//: CL Signal v0 class
+//- !group=Signal/System!
+//- !header=signals.h!
+class CL_Signal_v0 : public CL_Signal
+{
+public:
+	typedef CL_Slot_v0 *Slot;
+	typedef std::list&lt;Slot&gt;::iterator SlotIterator;
+
+	class CL_Signal_v0_Generic
+	{
+	public:
+		CL_Signal_v0_Generic(CL_Signal_v0 *owner) : in_call(false), deleted(false), in_call_remove_slots(0), owner(owner) { return; }
+
+		~CL_Signal_v0_Generic()
+		{
+			for (SlotIterator slot_it = slots.begin(); slot_it != slots.end(); slot_it++)
+			{
+				Slot slot = *slot_it;
+				slot-&gt;release_signal_ref(owner);
+			}
+		}
+
+		bool in_call, deleted;
+		std::list&lt;SlotIterator&gt; *in_call_remove_slots;
+		std::list&lt;Slot&gt; slots;
+		CL_Signal_v0 *owner;
+	};
+
+//! Construction:
+public:
+	//: CL Signal v0 constructor
+	CL_Signal_v0() : impl(new CL_Signal_v0_Generic(this))
+	{
+	}
+
+	CL_Signal_v0(const CL_Signal_v0 &amp;copy) : CL_Signal(copy), impl(new CL_Signal_v0_Generic(this))
+	{
+		impl-&gt;slots = copy.impl-&gt;slots;
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+			slot-&gt;add_signal_ref(this);
+		}
+	}
+
+	//: CL Signal v0 destructor
+	~CL_Signal_v0()
+	{
+		if (impl-&gt;in_call) impl-&gt;deleted = true;
+		else delete impl;
+	}
+
+//! Operations:
+public:
+	CL_Signal_v0 &amp;operator =(const CL_Signal_v0 &amp;copy)
+	{
+		if (impl-&gt;in_call) impl-&gt;deleted = true;
+		else delete impl;
+
+		impl = new CL_Signal_v0_Generic(this);
+		impl-&gt;slots = copy.impl-&gt;slots;
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+			slot-&gt;add_signal_ref(this);
+		}
+		return *this;
+	}
+
+	//: Operator
+	void operator() ()
+	{
+		call();
+	}
+
+	//: Call
+	void call()
+	{
+		CL_Signal_v0_Generic *data = impl;
+		data-&gt;in_call = true;
+
+		std::list&lt;SlotIterator&gt; remove_slots;
+		try
+		{
+			data-&gt;in_call_remove_slots = &amp;remove_slots;
+
+			// call slots connected to signal:
+			CL_SlotParent_v0 super(data-&gt;slots.begin(), data-&gt;slots.end());
+			super();
+		}
+		catch(...)
+		{
+			catch_final(data, remove_slots);
+			throw;
+		}
+
+		catch_final(data, remove_slots);
+	}
+
+	//: Connect slot.
+	CL_Slot connect(Slot slot)
+	{
+		slot-&gt;add_signal_ref(this);
+		impl-&gt;slots.push_front(slot);
+		return CL_Slot(slot);
+	}
+
+	//: Connect callback function slot.
+	CL_Slot connect(void (*callback)())
+	{
+		return connect(new CL_FunctionSlot_v0(callback, 0));
+	}
+
+	//: Connect virtual callback function slot.
+	CL_Slot connect_virtual(void (*virtual_callback)(CL_SlotParent_v0 &amp;))
+	{
+		return connect(new CL_FunctionSlot_v0(0, virtual_callback));
+	}
+
+	//: Connect functor slot.
+	template&lt;class Functor&gt;
+	CL_Slot connect_functor(const Functor &amp;functor)
+	{
+		return connect(new CL_FunctorSlot_v0&lt;Functor&gt;(functor));
+	}
+
+	//: Connect virtual functor slot.
+	template&lt;class Functor&gt;
+	CL_Slot connect_functor_virtual(const Functor &amp;functor)
+	{
+		return connect(new CL_FunctorVirtualSlot_v0&lt;Functor&gt;(functor));
+	}
+
+	//: Connect member function slot.
+	template &lt;class CallbackClass&gt;
+	CL_Slot connect(CallbackClass *cb_class, void (CallbackClass::*callback)())
+	{
+		return connect(new CL_MethodSlot_v0&lt;CallbackClass&gt;(cb_class, callback, 0));
+	}
+
+	//: Connect virtual member function slot.
+	template &lt;class CallbackClass&gt;
+	CL_Slot connect_virtual(CallbackClass *cb_class, void (CallbackClass::*virtual_callback)(CL_SlotParent_v0 &amp;))
+	{
+		return connect(new CL_MethodSlot_v0&lt;CallbackClass&gt;(cb_class, 0, virtual_callback));
+	}
+
+	//: Connect member function with user data slot.
+	template &lt;class CallbackClass, class UserData&gt;
+	CL_Slot connect(
+		CallbackClass *cb_class,
+		void (CallbackClass::*callback)(UserData),
+		UserData user_data)
+	{
+		return connect(new CL_UserDataMethodSlot_v0&lt;CallbackClass, UserData&gt;(cb_class, callback, 0, user_data));
+	}
+
+	//: Create virtual member function with user data slot.
+	template &lt;class CallbackClass, class UserData&gt;
+	CL_Slot connect_virtual(
+		CallbackClass *cb_class,
+		void (CallbackClass::*virtual_callback)(CL_SlotParent_v0 &amp;, UserData),
+		UserData user_data)
+	{
+		return connect(new CL_UserDataMethodSlot_v0&lt;CallbackClass, UserData&gt;(cb_class, 0, virtual_callback, user_data));
+	}
+
+	//: Disconnect
+	void disconnect(CL_Slot &amp;disconnect_slot)
+	{
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end();)
+		{
+			Slot slot = *slot_it;
+			if (disconnect_slot.impl == slot)
+			{
+				if (impl-&gt;in_call)
+				{
+					impl-&gt;in_call_remove_slots-&gt;push_back(slot_it);
+					++slot_it;
+				}
+				else
+				{
+					slot-&gt;release_signal_ref(this);
+					slot_it = impl-&gt;slots.erase(slot_it);
+				}
+			}
+			else
+				++slot_it;
+		}
+	}
+
+//! Implementation:
+private:
+	void catch_final(CL_Signal_v0_Generic *data, std::list&lt;SlotIterator&gt; &amp;remove_slots)
+	{
+		data-&gt;in_call_remove_slots = 0;
+
+		// find slots to be removed:
+		for (SlotIterator slot_it = data-&gt;slots.begin(); slot_it != data-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+
+			// skip slot if it has no more references left in application.
+			// (make it pending for removal)
+			if (slot-&gt;get_slot_ref() == 0 &amp;&amp; slot-&gt;is_persistent() == false)
+			{
+				if (std::find(remove_slots.begin(), remove_slots.end(), slot_it)==remove_slots.end())
+					remove_slots.push_back(slot_it);
+			}
+		}
+
+		// remove all slots no longer connected to any CL_Slot.
+		std::list&lt;SlotIterator&gt;::iterator remove_it;
+		for (remove_it = remove_slots.begin(); remove_it != remove_slots.end(); remove_it++)
+		{
+			Slot slot = **remove_it;
+			slot-&gt;release_signal_ref(this);
+			data-&gt;slots.erase(*remove_it);
+		}
+
+		data-&gt;in_call = false;
+		if (data-&gt;deleted) delete data;
+	}
+
+	CL_Signal_v0_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Signals/signal_v1.h
===================================================================
--- trunk/clanlib/API/Signals/signal_v1.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Signals/signal_v1.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,257 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef header_signal_v1
+#define header_signal_v1
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning ( disable : 4786 )
+#pragma warning ( disable : 4355 ) // warning C4355: 'this' : used in base member initializer list
+#endif
+
+#include &quot;signal.h&quot;
+#include &quot;slot.h&quot;
+#include &quot;slot_v1.h&quot;
+#include &lt;list&gt;
+#include &lt;algorithm&gt;
+
+//: CL Signal V1 class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1&gt;
+class CL_Signal_v1 : public CL_Signal
+{
+public:
+	typedef CL_Slot_v1&lt;PARAM1&gt; *Slot;
+	typedef typename std::list&lt;Slot&gt;::iterator SlotIterator;
+
+	class CL_Signal_v1_Generic
+	{
+	public:
+		CL_Signal_v1_Generic(CL_Signal_v1 *owner) : in_call(false), deleted(false), in_call_remove_slots(0), owner(owner) { return; }
+
+		~CL_Signal_v1_Generic()
+		{
+			for (SlotIterator slot_it = slots.begin(); slot_it != slots.end(); slot_it++)
+			{
+				Slot slot = *slot_it;
+				slot-&gt;release_signal_ref(owner);
+			}
+		}
+
+		bool in_call, deleted;
+		std::list&lt;SlotIterator&gt; *in_call_remove_slots;
+		std::list&lt;Slot&gt; slots;
+		CL_Signal_v1 *owner;
+	};
+
+//! Construction:
+public:
+	//: CL Signal V1 constructor
+	CL_Signal_v1() : impl(new CL_Signal_v1_Generic(this))
+	{
+	}
+
+	CL_Signal_v1(const CL_Signal_v1 &amp;copy) : CL_Signal(copy), impl(new CL_Signal_v1_Generic(this))
+	{
+		impl-&gt;slots = copy.impl-&gt;slots;
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+			slot-&gt;add_signal_ref(this);
+		}
+	}
+
+	//: CL Signal V1 destructor
+	~CL_Signal_v1()
+	{
+		if (impl-&gt;in_call) impl-&gt;deleted = true;
+		else delete impl;
+	}
+
+//! Attributes:
+public:
+	bool has_slots_connected() const
+	{
+		return !impl-&gt;slots.empty();
+	}
+
+//! Operations:
+public:
+	CL_Signal_v1 &amp;operator =(const CL_Signal_v1 &amp;copy)
+	{
+		if (impl-&gt;in_call) impl-&gt;deleted = true;
+		else delete impl;
+
+		impl = new CL_Signal_v1_Generic(this);
+		impl-&gt;slots = copy.impl-&gt;slots;
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+			slot-&gt;add_signal_ref(this);
+		}
+		return *this;
+	}
+
+	//: Operator
+	void operator() (PARAM1 param1)
+	{
+		call(param1);
+	}
+
+	//: Call
+	void call(PARAM1 param1)
+	{
+		CL_Signal_v1_Generic *data = impl;
+		data-&gt;in_call = true;
+
+		std::list&lt;SlotIterator&gt; remove_slots;
+		try
+		{
+			data-&gt;in_call_remove_slots = &amp;remove_slots;
+			
+			// call slots connected to signal:
+			for (SlotIterator slot_it = data-&gt;slots.begin(); slot_it != data-&gt;slots.end(); slot_it++)
+			{
+				Slot slot = *slot_it;
+
+				// skip slot if it has no more references left in application.
+				// (make it pending for removal)
+				if (slot-&gt;get_slot_ref() == 0 &amp;&amp; slot-&gt;is_persistent() == false)
+				{
+					if (std::find(remove_slots.begin(), remove_slots.end(), slot_it)==remove_slots.end())
+						remove_slots.push_back(slot_it);
+				}
+				
+				slot-&gt;call(param1);
+				if (data-&gt;deleted) break;
+			}
+		}
+		catch (...)
+		{
+			catch_final(data, remove_slots);
+			throw;
+		}
+		catch_final(data, remove_slots);
+	}
+
+	//: Connect slot.
+	CL_Slot connect(Slot slot)
+	{
+		slot-&gt;add_signal_ref(this);
+		impl-&gt;slots.push_back(slot);
+		return CL_Slot(slot);
+	}
+
+	//: Connect callback function slot.
+	CL_Slot connect(void (*callback)(PARAM1))
+	{
+		return connect(new CL_FunctionSlot_v1&lt;PARAM1&gt;(callback));
+	}
+
+	//: Connect functor slot.
+	template&lt;class Functor&gt;
+	CL_Slot connect_functor(const Functor &amp;functor)
+	{
+		return connect(new CL_FunctorSlot_v1&lt;Functor, PARAM1&gt;(functor));
+	}
+
+	//: Connect member function slot.
+	template &lt;class CallbackClass&gt;
+	CL_Slot connect(
+		CallbackClass *cb_class,
+		void (CallbackClass::*callback)(PARAM1))
+	{
+		return connect(new CL_MethodSlot_v1&lt;CallbackClass, PARAM1&gt;(cb_class, callback));
+	}
+
+	//: Connect member function with user data slot.
+	template &lt;class CallbackClass, class UserData&gt;
+	CL_Slot connect(
+		CallbackClass *cb_class,
+		void (CallbackClass::*callback)(PARAM1, UserData),
+		UserData user_data)
+	{
+		return connect(new CL_UserDataMethodSlot_v1&lt;CallbackClass, PARAM1, UserData&gt;(cb_class, callback, user_data));
+	}
+
+	//: Disconnect
+	void disconnect(CL_Slot &amp;disconnect_slot)
+	{
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end();)
+		{
+			Slot slot = *slot_it;
+			if (disconnect_slot.impl == slot)
+			{
+				if (impl-&gt;in_call)
+				{
+					impl-&gt;in_call_remove_slots-&gt;push_back(slot_it);
+					++slot_it;
+				}
+				else
+				{
+					slot-&gt;release_signal_ref(this);
+					slot_it = impl-&gt;slots.erase(slot_it);
+				}
+			}
+			else
+				++slot_it;
+		}
+	}
+
+//! Implementation:
+private:
+	void catch_final(CL_Signal_v1_Generic *data, std::list&lt;SlotIterator&gt; &amp;remove_slots)
+	{
+		data-&gt;in_call_remove_slots = 0;
+
+		// remove all slots no longer connected to any CL_Slot.
+		typename std::list&lt;SlotIterator&gt;::iterator remove_it;
+		for (remove_it = remove_slots.begin(); remove_it != remove_slots.end(); remove_it++)
+		{
+			Slot slot = **remove_it;
+			slot-&gt;release_signal_ref(this);
+			data-&gt;slots.erase(*remove_it);
+		}
+
+		data-&gt;in_call = false;
+		if (data-&gt;deleted) delete data;
+	}
+
+	CL_Signal_v1_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Signals/signal_v2.h
===================================================================
--- trunk/clanlib/API/Signals/signal_v2.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Signals/signal_v2.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,256 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef header_signal_v2
+#define header_signal_v2
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning ( disable : 4786 )
+#pragma warning ( disable : 4355 ) // warning C4355: 'this' : used in base member initializer list
+#endif
+
+#include &quot;signal.h&quot;
+#include &quot;slot.h&quot;
+#include &quot;slot_v2.h&quot;
+#include &lt;list&gt;
+
+//: Signal V2 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1, class PARAM2&gt;
+class CL_Signal_v2 : public CL_Signal
+{
+public:
+	typedef CL_Slot_v2&lt;PARAM1, PARAM2&gt; *Slot;
+	typedef typename std::list&lt;Slot&gt;::iterator SlotIterator;
+
+	class CL_Signal_v2_Generic
+	{
+	public:
+		CL_Signal_v2_Generic(CL_Signal_v2 *owner) : in_call(false), deleted(false), in_call_remove_slots(0), owner(owner) { return; }
+
+		~CL_Signal_v2_Generic()
+		{
+			for (SlotIterator slot_it = slots.begin(); slot_it != slots.end(); slot_it++)
+			{
+				Slot slot = *slot_it;
+				slot-&gt;release_signal_ref(owner);
+			}
+		}
+
+		bool in_call, deleted;
+		std::list&lt;SlotIterator&gt; *in_call_remove_slots;
+		std::list&lt;Slot&gt; slots;
+		CL_Signal_v2 *owner;
+	};
+
+//! Construction:
+public:
+	//: Signal V2 Constructor
+	CL_Signal_v2() : impl(new CL_Signal_v2_Generic(this))
+	{
+	}
+
+	CL_Signal_v2(const CL_Signal_v2 &amp;copy) : CL_Signal(copy), impl(new CL_Signal_v2_Generic(this))
+	{
+		impl-&gt;slots = copy.impl-&gt;slots;
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+			slot-&gt;add_signal_ref(this);
+		}
+	}
+
+	//: Signal V2 Destructor
+	~CL_Signal_v2()
+	{
+		if (impl-&gt;in_call) impl-&gt;deleted = true;
+		else delete impl;
+	}
+
+//! Attributes:
+public:
+	bool has_slots_connected() const
+	{
+		return !impl-&gt;slots.empty();
+	}
+
+//! Operations:
+public:
+	CL_Signal_v2 &amp;operator =(const CL_Signal_v2 &amp;copy)
+	{
+		if (impl-&gt;in_call) impl-&gt;deleted = true;
+		else delete impl;
+
+		impl = new CL_Signal_v2_Generic(this);
+		impl-&gt;slots = copy.impl-&gt;slots;
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+			slot-&gt;add_signal_ref(this);
+		}
+		return *this;
+	}
+
+	//: Operator
+	void operator() (PARAM1 param1, PARAM2 param2)
+	{
+		call(param1, param2);
+	}
+
+	//: Call
+	void call(PARAM1 param1, PARAM2 param2)
+	{
+		CL_Signal_v2_Generic *data = impl;
+		data-&gt;in_call = true;
+
+		std::list&lt;SlotIterator&gt; remove_slots;
+		try
+		{
+			data-&gt;in_call_remove_slots = &amp;remove_slots;
+
+			// call slots connected to signal:
+			for (SlotIterator slot_it = data-&gt;slots.begin(); slot_it != data-&gt;slots.end(); slot_it++)
+			{
+				Slot slot = *slot_it;
+	
+				// skip slot if it has no more references left in application.
+				// (make it pending for removal)
+				if (slot-&gt;get_slot_ref() == 0 &amp;&amp; slot-&gt;is_persistent() == false)
+				{
+					if (std::find(remove_slots.begin(), remove_slots.end(), slot_it)==remove_slots.end())
+						remove_slots.push_back(slot_it);
+				}
+			
+				slot-&gt;call(param1, param2);
+				if (data-&gt;deleted) break;
+			}
+		}
+		catch (...)
+		{
+			catch_final(data, remove_slots);
+			throw;
+		}
+		catch_final(data, remove_slots);
+	}
+
+	//: Connect slot.
+	CL_Slot connect(Slot slot)
+	{
+		slot-&gt;add_signal_ref(this);
+		impl-&gt;slots.push_back(slot);
+		return CL_Slot(slot);
+	}
+
+	//: Connect callback function slot.
+	CL_Slot connect(void (*callback)(PARAM1, PARAM2))
+	{
+		return connect(new CL_FunctionSlot_v2&lt;PARAM1, PARAM2&gt;(callback));
+	}
+
+	//: Connect functor slot.
+	template&lt;class Functor&gt;
+	CL_Slot connect_functor(const Functor &amp;functor)
+	{
+		return connect(new CL_FunctorSlot_v2&lt;Functor, PARAM1, PARAM2&gt;(functor));
+	}
+
+	//: Connect member function slot.
+	template &lt;class CallbackClass&gt;
+	CL_Slot connect(
+		CallbackClass *cb_class,
+		void (CallbackClass::*callback)(PARAM1, PARAM2))
+	{
+		return connect(new CL_MethodSlot_v2&lt;CallbackClass, PARAM1, PARAM2&gt;(cb_class, callback));
+	}
+
+	//: Connect member function with user data slot.
+	template &lt;class CallbackClass, class UserData&gt;
+	CL_Slot connect(
+		CallbackClass *cb_class,
+		void (CallbackClass::*callback)(PARAM1, PARAM2, UserData),
+		UserData user_data)
+	{
+		return connect(new CL_UserDataMethodSlot_v2&lt;CallbackClass, PARAM1, PARAM2, UserData&gt;(cb_class, callback, user_data));
+	}
+
+	//: Disconnect
+	void disconnect(CL_Slot &amp;disconnect_slot)
+	{
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end();)
+		{
+			Slot slot = *slot_it;
+			if (disconnect_slot.impl == slot)
+			{
+				if (impl-&gt;in_call)
+				{
+					impl-&gt;in_call_remove_slots-&gt;push_back(slot_it);
+					++slot_it;
+				}
+				else
+				{
+					slot-&gt;release_signal_ref(this);
+					slot_it = impl-&gt;slots.erase(slot_it);
+				}
+			}
+			else
+				++slot_it;
+		}
+	}
+
+//! Implementation:
+private:
+	void catch_final(CL_Signal_v2_Generic *data, std::list&lt;SlotIterator&gt; &amp;remove_slots)
+	{
+		data-&gt;in_call_remove_slots = 0;
+
+		// remove all slots no longer connected to any CL_Slot.
+		typename std::list&lt;SlotIterator&gt;::iterator remove_it;
+		for (remove_it = remove_slots.begin(); remove_it != remove_slots.end(); remove_it++)
+		{
+			Slot slot = **remove_it;
+			slot-&gt;release_signal_ref(this);
+			data-&gt;slots.erase(*remove_it);
+		}
+
+		data-&gt;in_call = false;
+		if (data-&gt;deleted) delete data;
+	}
+
+	CL_Signal_v2_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Signals/signal_v3.h
===================================================================
--- trunk/clanlib/API/Signals/signal_v3.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Signals/signal_v3.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,256 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef header_signal_v3
+#define header_signal_v3
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning ( disable : 4786 )
+#pragma warning ( disable : 4355 ) // warning C4355: 'this' : used in base member initializer list
+#endif
+
+#include &quot;signal.h&quot;
+#include &quot;slot.h&quot;
+#include &quot;slot_v3.h&quot;
+#include &lt;list&gt;
+
+//: Signal V3 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1, class PARAM2, class PARAM3&gt;
+class CL_Signal_v3 : public CL_Signal
+{
+public:
+	typedef CL_Slot_v3&lt;PARAM1, PARAM2, PARAM3&gt; *Slot;
+	typedef typename std::list&lt;Slot&gt;::iterator SlotIterator;
+
+	class CL_Signal_v3_Generic
+	{
+	public:
+		CL_Signal_v3_Generic(CL_Signal_v3 *owner) : in_call(false), deleted(false), in_call_remove_slots(0), owner(owner) { return; }
+
+		~CL_Signal_v3_Generic()
+		{
+			for (SlotIterator slot_it = slots.begin(); slot_it != slots.end(); slot_it++)
+			{
+				Slot slot = *slot_it;
+				slot-&gt;release_signal_ref(this-&gt;owner);
+			}
+		}
+
+		bool in_call, deleted;
+		std::list&lt;SlotIterator&gt; *in_call_remove_slots;
+		std::list&lt;Slot&gt; slots;
+		CL_Signal_v3 *owner;
+	};
+
+//! Construction:
+public:
+	//: Signal V3 Constructor
+	CL_Signal_v3() : impl(new CL_Signal_v3_Generic(this))
+	{
+	}
+
+	CL_Signal_v3(const CL_Signal_v3 &amp;copy) : CL_Signal(copy), impl(new CL_Signal_v3_Generic(this))
+	{
+		impl-&gt;slots = copy.impl-&gt;slots;
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+			slot-&gt;add_signal_ref(this-&gt;owner);
+		}
+	}
+
+	//: Signal V3 Destructor
+	~CL_Signal_v3()
+	{
+		if (impl-&gt;in_call) impl-&gt;deleted = true;
+		else delete impl;
+	}
+
+//! Attributes:
+public:
+	bool has_slots_connected() const
+	{
+		return !impl-&gt;slots.empty();
+	}
+
+//! Operations:
+public:
+	CL_Signal_v3 &amp;operator =(const CL_Signal_v3 &amp;copy)
+	{
+		if (impl-&gt;in_call) impl-&gt;deleted = true;
+		else delete impl;
+
+		impl = new CL_Signal_v3_Generic(this);
+		impl-&gt;slots = copy.impl-&gt;slots;
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+			slot-&gt;add_signal_ref(this);
+		}
+		return *this;
+	}
+
+	//: Operator
+	void operator() (PARAM1 param1, PARAM2 param2, PARAM3 param3)
+	{
+		call(param1, param2, param3);
+	}
+
+	//: Call
+	void call(PARAM1 param1, PARAM2 param2, PARAM3 param3)
+	{
+		CL_Signal_v3_Generic *data = impl;
+		data-&gt;in_call = true;
+
+		std::list&lt;SlotIterator&gt; remove_slots;
+		try
+		{
+			data-&gt;in_call_remove_slots = &amp;remove_slots;
+
+			// call slots connected to signal:
+			for (SlotIterator slot_it = data-&gt;slots.begin(); slot_it != data-&gt;slots.end(); slot_it++)
+			{
+				Slot slot = *slot_it;
+
+				// skip slot if it has no more references left in application.
+				// (make it pending for removal)
+				if (slot-&gt;get_slot_ref() == 0 &amp;&amp; slot-&gt;is_persistent() == false)
+				{
+					if (std::find(remove_slots.begin(), remove_slots.end(), slot_it)==remove_slots.end())
+						remove_slots.push_back(slot_it);
+				}
+			
+				slot-&gt;call(param1, param2, param3);
+				if (data-&gt;deleted) break;
+			}
+		}
+		catch (...)
+		{
+			catch_final(data, remove_slots);
+			throw;
+		}
+		catch_final(data, remove_slots);
+	}
+
+	//: Connect slot.
+	CL_Slot connect(Slot slot)
+	{
+		slot-&gt;add_signal_ref(this);
+		impl-&gt;slots.push_back(slot);
+		return CL_Slot(slot);
+	}
+
+	//: Connect callback function slot.
+	CL_Slot connect(void (*callback)(PARAM1, PARAM2, PARAM3))
+	{
+		return connect(new CL_FunctionSlot_v3&lt;PARAM1,PARAM2,PARAM3&gt;(callback));
+	}
+
+	//: Connect functor slot.
+	template&lt;class Functor&gt;
+	CL_Slot connect_functor(const Functor &amp;functor)
+	{
+		return connect(new CL_FunctorSlot_v3&lt;Functor, PARAM1, PARAM2, PARAM3&gt;(functor));
+	}
+
+	//: Connect member function slot.
+	template &lt;class CallbackClass&gt;
+	CL_Slot connect(
+		CallbackClass *cb_class,
+		void (CallbackClass::*callback)(PARAM1, PARAM2, PARAM3))
+	{
+		return connect(new CL_MethodSlot_v3&lt;CallbackClass, PARAM1, PARAM2, PARAM3&gt;(cb_class, callback));
+	}
+
+	//: Connect member function with user data slot.
+	template &lt;class CallbackClass, class UserData&gt;
+	CL_Slot connect(
+		CallbackClass *cb_class,
+		void (CallbackClass::*callback)(PARAM1, PARAM2, PARAM3, UserData),
+		UserData user_data)
+	{
+		return connect(new CL_UserDataMethodSlot_v3&lt;CallbackClass, PARAM1, PARAM2, PARAM3, UserData&gt;(cb_class, callback, user_data));
+	}
+
+	//: Disconnect
+	void disconnect(CL_Slot &amp;disconnect_slot)
+	{
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end();)
+		{
+			Slot slot = *slot_it;
+			if (disconnect_slot.impl == slot)
+			{
+				if (impl-&gt;in_call)
+				{
+					impl-&gt;in_call_remove_slots-&gt;push_back(slot_it);
+					++slot_it;
+				}
+				else
+				{
+					slot-&gt;release_signal_ref(this);
+					slot_it = impl-&gt;slots.erase(slot_it);
+				}
+			}
+			else
+				++slot_it;
+		}
+	}
+
+//! Implementation:
+private:
+	void catch_final(CL_Signal_v3_Generic *data, std::list&lt;SlotIterator&gt; &amp;remove_slots)
+	{
+		data-&gt;in_call_remove_slots = 0;
+
+		// remove all slots no longer connected to any CL_Slot.
+		typename std::list&lt;SlotIterator&gt;::iterator remove_it;
+		for (remove_it = remove_slots.begin(); remove_it != remove_slots.end(); remove_it++)
+		{
+			Slot slot = **remove_it;
+			slot-&gt;release_signal_ref(this);
+			data-&gt;slots.erase(*remove_it);
+		}
+
+		data-&gt;in_call = false;
+		if (data-&gt;deleted) delete data;
+	}
+
+	CL_Signal_v3_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Signals/signal_v4.h
===================================================================
--- trunk/clanlib/API/Signals/signal_v4.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Signals/signal_v4.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,256 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef header_signal_v4
+#define header_signal_v4
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning ( disable : 4786 )
+#pragma warning ( disable : 4355 ) // warning C4355: 'this' : used in base member initializer list
+#endif
+
+#include &quot;signal.h&quot;
+#include &quot;slot.h&quot;
+#include &quot;slot_v4.h&quot;
+#include &lt;list&gt;
+
+//: Signal V4 class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1, class PARAM2, class PARAM3, class PARAM4&gt;
+class CL_Signal_v4 : public CL_Signal
+{
+public:
+	typedef CL_Slot_v4&lt;PARAM1, PARAM2, PARAM3, PARAM4&gt; *Slot;
+	typedef typename std::list&lt;Slot&gt;::iterator SlotIterator;
+
+	class CL_Signal_v4_Generic
+	{
+	public:
+		CL_Signal_v4_Generic(CL_Signal_v4 *owner) : in_call(false), deleted(false), in_call_remove_slots(0), owner(owner) { return; }
+
+		~CL_Signal_v4_Generic()
+		{
+			for (SlotIterator slot_it = slots.begin(); slot_it != slots.end(); slot_it++)
+			{
+				Slot slot = *slot_it;
+				slot-&gt;release_signal_ref(owner);
+			}
+		}
+
+		bool in_call, deleted;
+		std::list&lt;SlotIterator&gt; *in_call_remove_slots;
+		std::list&lt;Slot&gt; slots;
+		CL_Signal_v4 *owner;
+	};
+
+//! Construction:
+public:
+	//: Signal V4 constructor
+	CL_Signal_v4() : impl(new CL_Signal_v4_Generic(this))
+	{
+	}
+
+	CL_Signal_v4(const CL_Signal_v4 &amp;copy) : CL_Signal(copy), impl(new CL_Signal_v4_Generic(this))
+	{
+		impl-&gt;slots = copy.impl-&gt;slots;
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+			slot-&gt;add_signal_ref(this);
+		}
+	}
+
+	//: Signal V4 destructor
+	~CL_Signal_v4()
+	{
+		if (impl-&gt;in_call) impl-&gt;deleted = true;
+		else delete impl;
+	}
+
+//! Attributes:
+public:
+	bool has_slots_connected() const
+	{
+		return !impl-&gt;slots.empty();
+	}
+
+//! Operations:
+public:
+	CL_Signal_v4 &amp;operator =(const CL_Signal_v4 &amp;copy)
+	{
+		if (impl-&gt;in_call) impl-&gt;deleted = true;
+		else delete impl;
+
+		impl = new CL_Signal_v4_Generic(this);
+		impl-&gt;slots = copy.impl-&gt;slots;
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+			slot-&gt;add_signal_ref(this);
+		}
+		return *this;
+	}
+
+	//: Opererator
+	void operator() (PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4)
+	{
+		call(param1, param2, param3, param4);
+	}
+
+	//: Call
+	void call(PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4)
+	{
+		CL_Signal_v4_Generic *data = impl;
+		data-&gt;in_call = true;
+
+		std::list&lt;SlotIterator&gt; remove_slots;
+		try
+		{
+			data-&gt;in_call_remove_slots = &amp;remove_slots;
+
+			// call slots connected to signal:
+			for (SlotIterator slot_it = data-&gt;slots.begin(); slot_it != data-&gt;slots.end(); slot_it++)
+			{
+				Slot slot = *slot_it;
+
+				// skip slot if it has no more references left in application.
+				// (make it pending for removal)
+				if (slot-&gt;get_slot_ref() == 0 &amp;&amp; slot-&gt;is_persistent() == false)
+				{
+					if (std::find(remove_slots.begin(), remove_slots.end(), slot_it)==remove_slots.end())
+						remove_slots.push_back(slot_it);
+				}
+			
+				slot-&gt;call(param1, param2, param3, param4);
+				if (data-&gt;deleted) break;
+			}
+		}
+		catch (...)
+		{
+			catch_final(data, remove_slots);
+			throw;
+		}
+		catch_final(data, remove_slots);
+	}
+
+	//: Connect slot.
+	CL_Slot connect(Slot slot)
+	{
+		slot-&gt;add_signal_ref(this);
+		impl-&gt;slots.push_back(slot);
+		return CL_Slot(slot);
+	}
+
+	//: Connect callback function slot.
+	CL_Slot connect(void (*callback)(PARAM1, PARAM2, PARAM3, PARAM4))
+	{
+		return connect(new CL_FunctionSlot_v4&lt;PARAM1,PARAM2,PARAM3,PARAM4&gt;(callback));
+	}
+
+	//: Connect functor slot.
+	template&lt;class Functor&gt;
+	CL_Slot connect_functor(const Functor &amp;functor)
+	{
+		return connect(new CL_FunctorSlot_v4&lt;Functor, PARAM1, PARAM2, PARAM3, PARAM4&gt;(functor));
+	}
+
+	//: Connect member function slot.
+	template &lt;class CallbackClass&gt;
+	CL_Slot connect(
+		CallbackClass *cb_class,
+		void (CallbackClass::*callback)(PARAM1, PARAM2, PARAM3, PARAM4))
+	{
+		return connect(new CL_MethodSlot_v4&lt;CallbackClass, PARAM1, PARAM2, PARAM3, PARAM4&gt;(cb_class, callback));
+	}
+
+	//: Connect member function with user data slot.
+	template &lt;class CallbackClass, class UserData&gt;
+	CL_Slot connect(
+		CallbackClass *cb_class,
+		void (CallbackClass::*callback)(PARAM1, PARAM2, PARAM3, PARAM4, UserData),
+		UserData user_data)
+	{
+		return connect(new CL_UserDataMethodSlot_v4&lt;CallbackClass, PARAM1, PARAM2, PARAM3, PARAM4, UserData&gt;(cb_class, callback, user_data));
+	}
+
+	//: Disconnect
+	void disconnect(CL_Slot &amp;disconnect_slot)
+	{
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end();)
+		{
+			Slot slot = *slot_it;
+			if (disconnect_slot.impl == slot)
+			{
+				if (impl-&gt;in_call)
+				{
+					impl-&gt;in_call_remove_slots-&gt;push_back(slot_it);
+					++slot_it;
+				}
+				else
+				{
+					slot-&gt;release_signal_ref(this);
+					slot_it = impl-&gt;slots.erase(slot_it);
+				}
+			}
+			else
+				++slot_it;
+		}
+	}
+
+//! Implementation:
+private:
+	void catch_final(CL_Signal_v4_Generic *data, std::list&lt;SlotIterator&gt; &amp;remove_slots)
+	{
+		data-&gt;in_call_remove_slots = 0;
+
+		// remove all slots no longer connected to any CL_Slot.
+		typename std::list&lt;SlotIterator&gt;::iterator remove_it;
+		for (remove_it = remove_slots.begin(); remove_it != remove_slots.end(); remove_it++)
+		{
+			Slot slot = **remove_it;
+			slot-&gt;release_signal_ref(this);
+			data-&gt;slots.erase(*remove_it);
+		}
+
+		data-&gt;in_call = false;
+		if (data-&gt;deleted) delete data;
+	}
+
+	CL_Signal_v4_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Signals/signal_v5.h
===================================================================
--- trunk/clanlib/API/Signals/signal_v5.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Signals/signal_v5.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,256 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef header_signal_v5
+#define header_signal_v5
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning ( disable : 4786 )
+#pragma warning ( disable : 4355 ) // warning C4355: 'this' : used in base member initializer list
+#endif
+
+#include &quot;signal.h&quot;
+#include &quot;slot.h&quot;
+#include &quot;slot_v5.h&quot;
+#include &lt;list&gt;
+
+//: Signal V5 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1, class PARAM2, class PARAM3, class PARAM4, class PARAM5&gt;
+class CL_Signal_v5 : public CL_Signal
+{
+public:
+	typedef CL_Slot_v5&lt;PARAM1, PARAM2, PARAM3, PARAM4, PARAM5&gt; *Slot;
+	typedef typename std::list&lt;Slot&gt;::iterator SlotIterator;
+
+	class CL_Signal_v5_Generic
+	{
+	public:
+		CL_Signal_v5_Generic(CL_Signal_v5 *owner) : in_call(false), deleted(false), in_call_remove_slots(0), owner(owner) { return; }
+
+		~CL_Signal_v5_Generic()
+		{
+			for (SlotIterator slot_it = slots.begin(); slot_it != slots.end(); slot_it++)
+			{
+				Slot slot = *slot_it;
+				slot-&gt;release_signal_ref(owner);
+			}
+		}
+
+		bool in_call, deleted;
+		std::list&lt;SlotIterator&gt; *in_call_remove_slots;
+		std::list&lt;Slot&gt; slots;
+		CL_Signal_v5 *owner;
+	};
+
+//! Construction:
+public:
+	//: Signal V5 Constructor
+	CL_Signal_v5() : impl(new CL_Signal_v5_Generic(this))
+	{
+	}
+
+	CL_Signal_v5(const CL_Signal_v5 &amp;copy) : CL_Signal(copy), impl(new CL_Signal_v5_Generic(this))
+	{
+		impl-&gt;slots = copy.impl-&gt;slots;
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+			slot-&gt;add_signal_ref(this);
+		}
+	}
+
+	//: Signal V5 Destructor
+	~CL_Signal_v5()
+	{
+		if (impl-&gt;in_call) impl-&gt;deleted = true;
+		else delete impl;
+	}
+
+//! Attributes:
+public:
+	bool has_slots_connected() const
+	{
+		return !impl-&gt;slots.empty();
+	}
+
+//! Operations:
+public:
+	CL_Signal_v5 &amp;operator =(const CL_Signal_v5 &amp;copy)
+	{
+		if (impl-&gt;in_call) impl-&gt;deleted = true;
+		else delete impl;
+
+		impl = new CL_Signal_v5_Generic(this);
+		impl-&gt;slots = copy.impl-&gt;slots;
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end(); slot_it++)
+		{
+			Slot slot = *slot_it;
+			slot-&gt;add_signal_ref(this);
+		}
+		return *this;
+	}
+
+	//: Operator
+	void operator() (PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4, PARAM5 param5)
+	{
+		call(param1, param2, param3, param4, param5);
+	}
+
+	//: Call
+	void call(PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4, PARAM5 param5)
+	{
+		CL_Signal_v5_Generic *data = impl;
+		data-&gt;in_call = true;
+
+		std::list&lt;SlotIterator&gt; remove_slots;
+		try
+		{
+			data-&gt;in_call_remove_slots = &amp;remove_slots;
+
+			// call slots connected to signal:
+			for (SlotIterator slot_it = data-&gt;slots.begin(); slot_it != data-&gt;slots.end(); slot_it++)
+			{
+				Slot slot = *slot_it;
+
+				// skip slot if it has no more references left in application.
+				// (make it pending for removal)
+				if (slot-&gt;get_slot_ref() == 0 &amp;&amp; slot-&gt;is_persistent() == false)
+				{
+					if (std::find(remove_slots.begin(), remove_slots.end(), slot_it)==remove_slots.end())
+						remove_slots.push_back(slot_it);
+				}
+			
+				slot-&gt;call(param1, param2, param3, param4, param5);
+				if (data-&gt;deleted) break;
+			}
+		}
+		catch (...)
+		{
+			catch_final(data, remove_slots);
+			throw;
+		}
+		catch_final(data, remove_slots);
+	}
+
+	//: Connect slot.
+	CL_Slot connect(Slot slot)
+	{
+		slot-&gt;add_signal_ref(this);
+		impl-&gt;slots.push_back(slot);
+		return CL_Slot(slot);
+	}
+
+	//: Connect callback function slot.
+	CL_Slot connect(void (*callback)(PARAM1, PARAM2, PARAM3, PARAM4, PARAM5))
+	{
+		return connect(new CL_FunctionSlot_v5&lt;PARAM1,PARAM2,PARAM3,PARAM4,PARAM5&gt;(callback));
+	}
+
+	//: Connect functor slot.
+	template&lt;class Functor&gt;
+	CL_Slot connect_functor(const Functor &amp;functor)
+	{
+		return connect(new CL_FunctorSlot_v5&lt;Functor, PARAM1, PARAM2, PARAM3, PARAM4, PARAM5&gt;(functor));
+	}
+
+	//: Connect member function slot.
+	template &lt;class CallbackClass&gt;
+	CL_Slot connect(
+		CallbackClass *cb_class,
+		void (CallbackClass::*callback)(PARAM1, PARAM2, PARAM3, PARAM4, PARAM5))
+	{
+		return connect(new CL_MethodSlot_v5&lt;CallbackClass, PARAM1, PARAM2, PARAM3, PARAM4, PARAM5&gt;(cb_class, callback));
+	}
+
+	//: Connect member function with user data slot.
+	template &lt;class CallbackClass, class UserData&gt;
+	CL_Slot connect(
+		CallbackClass *cb_class,
+		void (CallbackClass::*callback)(PARAM1, PARAM2, PARAM3, PARAM4, PARAM5, UserData),
+		UserData user_data)
+	{
+		return connect(new CL_UserDataMethodSlot_v5&lt;CallbackClass, PARAM1, PARAM2, PARAM3, PARAM4, PARAM5, UserData&gt;(cb_class, callback, user_data));
+	}
+
+	//: Disconnect
+	void disconnect(CL_Slot &amp;disconnect_slot)
+	{
+		for (SlotIterator slot_it = impl-&gt;slots.begin(); slot_it != impl-&gt;slots.end();)
+		{
+			Slot slot = *slot_it;
+			if (disconnect_slot.impl == slot)
+			{
+				if (impl-&gt;in_call)
+				{
+					impl-&gt;in_call_remove_slots-&gt;push_back(slot_it);
+					++slot_it;
+				}
+				else
+				{
+					slot-&gt;release_signal_ref(this);
+					slot_it = impl-&gt;slots.erase(slot_it);
+				}
+			}
+			else
+				++slot_it;
+		}
+	}
+
+//! Implementation:
+private:
+	void catch_final(CL_Signal_v5_Generic *data, std::list&lt;SlotIterator&gt; &amp;remove_slots)
+	{
+		data-&gt;in_call_remove_slots = 0;
+
+		// remove all slots no longer connected to any CL_Slot.
+		typename std::list&lt;SlotIterator&gt;::iterator remove_it;
+		for (remove_it = remove_slots.begin(); remove_it != remove_slots.end(); remove_it++)
+		{
+			Slot slot = **remove_it;
+			slot-&gt;release_signal_ref(this);
+			data-&gt;slots.erase(*remove_it);
+		}
+
+		data-&gt;in_call = false;
+		if (data-&gt;deleted) delete data;
+	}
+
+	CL_Signal_v5_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Signals/slot.h
===================================================================
--- trunk/clanlib/API/Signals/slot.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Signals/slot.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,100 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef header_slot
+#define header_slot
+
+#ifdef CL_API_DLL
+#ifdef CL_SIGNALS_EXPORT
+#define CL_API_SIGNALS __declspec(dllexport)
+#else
+#define CL_API_SIGNALS __declspec(dllimport)
+#endif
+#else
+#define CL_API_SIGNALS
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+class CL_Slot_Generic;
+
+//: Slot class
+//- !group=Signal/System!
+//- !header=signals.h!
+class CL_API_SIGNALS CL_Slot
+{
+//! Construction:
+public:
+	//: Create an unconnected slot.
+	CL_Slot();
+
+	//: Copy a slot.
+	CL_Slot(const CL_Slot &amp;copy);
+
+	//: Slot destructor
+	~CL_Slot();
+
+//! Attributes:
+public:
+	//: Returns the number of CL_Slot references still pointing at this slot.
+	int get_slot_ref() const;
+
+	//: Returns the number of signals this slot is connected to.
+	int get_signal_ref() const;
+
+	//: Returns true if slot is persistent.
+	//- &lt;p&gt;If the slot is persistent, it will remain connected to
+	//- signals even when all references to CL_Slot are gone.&lt;/p&gt;
+	bool is_persistent() const;
+
+//! Operations:
+public:
+	//: Slot copy operator
+	void operator =(const CL_Slot &amp;copy);
+
+	//: Sets the persistent flag.
+	//- &lt;p&gt;If the slot is persistent, it will remain connected to
+	//- signals even when all references to CL_Slot are gone.&lt;/p&gt;
+	void set_persistent(bool flag = true);
+
+//! Implementation:
+public:
+	//: Slot constructor
+	CL_Slot(CL_Slot_Generic *impl);
+
+	//: Slot Generic Implementation
+	CL_Slot_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Signals/slot_container.h
===================================================================
--- trunk/clanlib/API/Signals/slot_container.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Signals/slot_container.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,173 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef header_slot_container
+#define header_slot_container
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;slot.h&quot;
+#include &quot;signal_v0.h&quot;
+#include &quot;signal_v1.h&quot;
+#include &quot;signal_v2.h&quot;
+#include &quot;signal_v3.h&quot;
+#include &quot;signal_v4.h&quot;
+#include &quot;signal_v5.h&quot;
+#include &lt;list&gt;
+
+//: Slot Generic Container
+//- !group=Signal/System!
+//- !header=signals.h!
+//- &lt;p&gt;Convience signal/slot connector class.&lt;/p&gt;
+//- &lt;p&gt;The slot container class is a convience class. It simplifies the
+//- connection between signals and slots by keeping all connections made
+//- until the entire class is destroyed. This saves the developer from having
+//- to keep a CL_Slot reference around for each connection needed.&lt;/p&gt;
+//- &lt;p&gt;In order to use this class, simply make it a member variable and call
+//- connect_signal() for each function you want hooked up.&lt;/p&gt;
+//- &lt;p&gt;See the login_view.cpp/h in the CTalk example for an example of how to use
+//- this class.&lt;/p&gt;
+class CL_SlotContainer
+{
+public:
+//! Operations:
+	//: Connect a slot to a CL_Signal_v0 signal.
+	template&lt;class SigClass&gt;
+	void connect(SigClass &amp;sig, void (*func)())
+	{
+		slots.push_back(sig.connect(func));
+	}
+
+	//: Connect a slot to a CL_Signal_v0 signal.
+	template&lt;class SigClass, class Class&gt;
+	void connect(SigClass &amp;sig, Class *self, void(Class::*func)())
+	{
+		slots.push_back(sig.connect(self, func));
+	}
+
+	//: Connect a slot to a CL_Signal_v0 signal with an user data parameter
+	//: passed along.
+	template&lt;class SigClass, class Class, class UserData&gt;
+	void connect(SigClass &amp;sig, Class *self, void(Class::*func)(UserData), UserData user_data)
+	{
+		slots.push_back(sig.connect(self, func, user_data));
+	}
+
+	//: Connect a slot to a CL_Signal_v1 signal.
+	template&lt;class SigClass, class Class, class Param1&gt;
+	void connect(SigClass &amp;sig, Class *self, void(Class::*func)(Param1))
+	{
+		slots.push_back(sig.connect(self, func));
+	}
+
+	//: Connect a slot to a CL_Signal_v1 signal with an user data parameter
+	//: passed along.
+	template&lt;class SigClass, class Class, class Param1, class UserData&gt;
+	void connect(SigClass &amp;sig, Class *self, void(Class::*func)(Param1, UserData), UserData user_data)
+	{
+		slots.push_back(sig.connect(self, func, user_data));
+	}
+
+	//: Connect a slot to a CL_Signal_v2 signal.
+	template&lt;class SigClass, class Class, class Param1, class Param2&gt;
+	void connect(SigClass &amp;sig, Class *self, void(Class::*func)(Param1, Param2))
+	{
+		slots.push_back(sig.connect(self, func));
+	}
+
+	//: Connect a slot to a CL_Signal_v2 signal with an user data parameter
+	//: passed along.
+	template&lt;class SigClass, class Class, class Param1, class Param2, class UserData&gt;
+	void connect(SigClass &amp;sig, Class *self, void(Class::*func)(Param1, Param2, UserData), UserData user_data)
+	{
+		slots.push_back(sig.connect(self, func, user_data));
+	}
+
+	//: Connect a slot to a CL_Signal_v3 signal.
+	template&lt;class SigClass, class Class, class Param1, class Param2, class Param3&gt;
+	void connect(SigClass &amp;sig, Class *self, void(Class::*func)(Param1, Param2, Param3))
+	{
+		slots.push_back(sig.connect(self, func));
+	}
+
+	//: Connect a slot to a CL_Signal_v3 signal with an user data parameter
+	//: passed along.
+	template&lt;class SigClass, class Class, class Param1, class Param2, class Param3, class UserData&gt;
+	void connect(SigClass &amp;sig, Class *self, void(Class::*func)(Param1, Param2, Param3, UserData), UserData user_data)
+	{
+		slots.push_back(sig.connect(self, func, user_data));
+	}
+
+	//: Connect a slot to a CL_Signal_v4 signal.
+	template&lt;class SigClass, class Class, class Param1, class Param2, class Param3, class Param4&gt;
+	void connect(SigClass &amp;sig, Class *self, void(Class::*func)(Param1, Param2, Param3, Param4))
+	{
+		slots.push_back(sig.connect(self, func));
+	}
+
+	//: Connect a slot to a CL_Signal_v4 signal with an user data parameter
+	//: passed along.
+	template&lt;class SigClass, class Class, class Param1, class Param2, class Param3, class Param4, class UserData&gt;
+	void connect(SigClass &amp;sig, Class *self, void(Class::*func)(Param1, Param2, Param3, Param4, UserData user_data), UserData user_data)
+	{
+		slots.push_back(sig.connect(self, func, user_data));
+	}
+
+	//: Connect a slot to a CL_Signal_v5 signal.
+	template&lt;class SigClass, class Class, class Param1, class Param2, class Param3, class Param4, class Param5&gt;
+	void connect(SigClass &amp;sig, Class *self, void(Class::*func)(Param1, Param2, Param3, Param4, Param5))
+	{
+		slots.push_back(sig.connect(self, func));
+	}
+
+	//: Connect a slot to a CL_Signal_v5 signal with an user data parameter
+	//: passed along.
+	template&lt;class SigClass, class Class, class Param1, class Param2, class Param3, class Param4, class Param5, class UserData&gt;
+	void connect(SigClass &amp;sig, Class *self, void(Class::*func)(Param1, Param2, Param3, Param4, Param5, UserData user_data), UserData user_data)
+	{
+		slots.push_back(sig.connect(self, func, user_data));
+	}
+
+	//: Connect a functor slot to a signal.
+	template&lt;class SigClass, class Functor&gt;
+	void connect_functor(SigClass &amp;sig, const Functor &amp;functor)
+	{
+		slots.push_back(sig.connect_functor(functor));
+	}
+
+private:
+	std::list&lt;CL_Slot&gt; slots;
+};
+
+#endif

Added: trunk/clanlib/API/Signals/slot_generic.h
===================================================================
--- trunk/clanlib/API/Signals/slot_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Signals/slot_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,113 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef header_slot_generic
+#define header_slot_generic
+
+#ifdef CL_API_DLL
+#ifdef CL_SIGNALS_EXPORT
+#define CL_API_SIGNALS __declspec(dllexport)
+#else
+#define CL_API_SIGNALS __declspec(dllimport)
+#endif
+#else
+#define CL_API_SIGNALS
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;list&gt;
+#include &quot;signal.h&quot;
+
+class CL_Slot;
+
+//: Slot Generic Class
+//- !group=Signal/System!
+//- !header=signals.h!
+class CL_API_SIGNALS CL_Slot_Generic
+{
+//! Construction:
+public:
+	//: Slot Generic Constructor
+	CL_Slot_Generic();
+
+	//: Slot Generic Destructor
+	virtual ~CL_Slot_Generic();
+
+//! Attributes:
+public:
+	//: Get slot ref
+	int get_slot_ref() const;
+
+	//: Get signal ref
+	int get_signal_ref() const;
+
+	//: Returns true if persistent.
+	//- &lt;p&gt;If the slot is persistent, it will remain connected to
+	//- signals even when all references to CL_Slot are gone.&lt;/p&gt;
+	bool is_persistent() const;
+
+//! Operations:
+public:
+	//: Add slot ref
+	void add_slot_ref();
+
+	//: Release slot ref
+	void release_slot_ref();
+
+	//: Add signal ref
+	void add_signal_ref(CL_Signal *signal);
+
+	//: Release signal ref
+	void release_signal_ref(CL_Signal *signal);
+
+	//: Sets the persistent flag.
+	//- &lt;p&gt;If the slot is persistent, it will remain connected to
+	//- signals even when all references to CL_Slot are gone.&lt;/p&gt;
+	void set_persistent(bool flag = true);
+
+//! Implementation:
+private:
+	void check_delete();
+
+	bool persistent;
+
+	int slot_ref_count;
+
+	int signal_ref_count;
+
+	std::list&lt;CL_Signal *&gt; connected_signals;
+};
+
+#endif

Added: trunk/clanlib/API/Signals/slot_v0.h
===================================================================
--- trunk/clanlib/API/Signals/slot_v0.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Signals/slot_v0.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,216 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef header_slot_v0
+#define header_slot_v0
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;slot_generic.h&quot;
+#include &lt;list&gt;
+
+//: Slot V0 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+class CL_Slot_v0 : public CL_Slot_Generic
+{
+public:
+	//: Call
+	virtual void call(class CL_SlotParent_v0 &amp;super)=0;
+};
+
+//: Slot Parent V0 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+class CL_SlotParent_v0
+{
+public:
+	typedef CL_Slot_v0 *Slot;
+	typedef std::list&lt;Slot&gt;::iterator SlotIterator;
+
+//! Construction:
+public:
+	
+	//: Slot Parent V0 Constructor
+	CL_SlotParent_v0(const SlotIterator &amp;pos, const SlotIterator &amp;end)
+	: pos(pos), end(end)
+	{
+	}
+
+//! Operations:
+public:
+	//: Operator
+	void operator() ()
+	{
+		if (pos == end) return;
+
+		SlotIterator next = pos;
+		next++;
+
+		if ((*pos)-&gt;get_slot_ref() &gt; 0)
+		{
+			CL_SlotParent_v0 super(next, end);
+			(*pos)-&gt;call(super);
+		}
+	}
+
+//! Implementation:
+private:
+	SlotIterator pos, end;
+};
+
+//: FunctionSlot V0 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+class CL_FunctionSlot_v0 : public CL_Slot_v0
+{
+public:
+	typedef void (*Callback)();
+	typedef void (*VirtualCallback)(CL_SlotParent_v0 &amp;);
+
+	//: FunctionSlot V0 Constructor
+	CL_FunctionSlot_v0(Callback callback, VirtualCallback virtual_callback)
+	: callback(callback), virtual_callback(virtual_callback) { return; }
+
+	//: Call
+	virtual void call(CL_SlotParent_v0 &amp;super)
+	{
+		if (callback) { super(); callback(); }
+		else virtual_callback(super);
+	}
+
+private:
+	Callback callback;
+	VirtualCallback virtual_callback;
+};
+
+//: FunctorSlot V0 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template&lt;class Functor&gt;
+class CL_FunctorSlot_v0 : public CL_Slot_v0
+{
+public:
+	//: FunctorSlot V0 Constructor
+	CL_FunctorSlot_v0(const Functor &amp;functor)
+	: functor(functor) { return; }
+
+	//: Call
+	virtual void call(CL_SlotParent_v0 &amp;super)
+	{
+		super();
+		functor();
+	}
+
+private:
+	Functor functor;
+};
+
+//: FunctorSlot V0 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template&lt;class Functor&gt;
+class CL_FunctorVirtualSlot_v0 : public CL_Slot_v0
+{
+public:
+	//: FunctorVirtualSlot V0 Constructor
+	CL_FunctorVirtualSlot_v0(const Functor &amp;functor)
+	: functor(functor) { return; }
+
+	//: Call
+	virtual void call(CL_SlotParent_v0 &amp;super)
+	{
+		functor(super);
+	}
+
+private:
+	Functor functor;
+};
+
+//: Method Slot V0 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class CallbackClass&gt;
+class CL_MethodSlot_v0 : public CL_Slot_v0
+{
+public:
+	typedef void (CallbackClass::*Callback)();
+	typedef void (CallbackClass::*VirtualCallback)(CL_SlotParent_v0 &amp;);
+
+	//: Method Slot V0 Constructor
+	CL_MethodSlot_v0(CallbackClass *cb_class, Callback callback, VirtualCallback virtual_callback)
+	: cb_class(cb_class), callback(callback), virtual_callback(virtual_callback) { return; }
+
+	//: Call
+	virtual void call(CL_SlotParent_v0 &amp;super)
+	{
+		if (callback) { super(); (cb_class-&gt;*callback)(); }
+		else (cb_class-&gt;*virtual_callback)(super);
+	}
+
+private:
+	CallbackClass *cb_class;
+	Callback callback;
+	VirtualCallback virtual_callback;
+};
+
+//: User Data Methane Slot V0 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class CallbackClass, class UserData&gt;
+class CL_UserDataMethodSlot_v0 : public CL_Slot_v0
+{
+public:
+	typedef void (CallbackClass::*Callback)(UserData);
+	typedef void (CallbackClass::*VirtualCallback)(CL_SlotParent_v0 &amp;, UserData);
+
+	//: User Data Methane Slot V0 Constructor
+	CL_UserDataMethodSlot_v0(CallbackClass *cb_class, Callback callback, VirtualCallback virtual_callback, UserData user_data)
+	: cb_class(cb_class), callback(callback), virtual_callback(virtual_callback), user_data(user_data) { return; }
+
+	//: Call
+	virtual void call(CL_SlotParent_v0 &amp;super)
+	{
+		if (callback) { super(); (cb_class-&gt;*callback)(user_data); }
+		else (cb_class-&gt;*virtual_callback)(super, user_data);
+	}
+
+private:
+	CallbackClass *cb_class;
+	Callback callback;
+	VirtualCallback virtual_callback;
+	UserData user_data;
+};
+
+#endif

Added: trunk/clanlib/API/Signals/slot_v1.h
===================================================================
--- trunk/clanlib/API/Signals/slot_v1.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Signals/slot_v1.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,133 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef header_slot_v1
+#define header_slot_v1
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;slot_generic.h&quot;
+
+//: Slot V1 class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1&gt;
+class CL_Slot_v1 : public CL_Slot_Generic
+{
+public:
+	//: Call
+	virtual void call(PARAM1 param1)=0;
+};
+
+//: Funtion Slot V1 class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1&gt;
+class CL_FunctionSlot_v1 : public CL_Slot_v1&lt;PARAM1&gt;
+{
+public:
+	typedef void (*Callback)(PARAM1);
+
+	//: Funtion Slot V1 constructor
+	CL_FunctionSlot_v1(Callback callback) : callback(callback) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1) { callback(param1); }
+
+private:
+	Callback callback;
+};
+
+//: FunctorSlot V1 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template&lt;class Functor, class PARAM1&gt;
+class CL_FunctorSlot_v1 : public CL_Slot_v1&lt;PARAM1&gt;
+{
+public:
+	//: FunctorSlot V1 Constructor
+	CL_FunctorSlot_v1(const Functor &amp;functor)
+	: functor(functor) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1) { functor(param1); }
+
+private:
+	Functor functor;
+};
+
+//: Method Slot V1
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class CallbackClass, class PARAM1&gt;
+class CL_MethodSlot_v1 : public CL_Slot_v1&lt;PARAM1&gt;
+{
+public:
+	typedef void (CallbackClass::*Callback)(PARAM1);
+
+	//: Method Slot V1 constructor
+	CL_MethodSlot_v1(CallbackClass *cb_class, Callback callback)
+	: cb_class(cb_class), callback(callback) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1) { (cb_class-&gt;*callback)(param1); }
+
+private:
+	CallbackClass *cb_class;
+	Callback callback;
+};
+
+//: User Data Method Slot V1 class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class CallbackClass, class PARAM1, class UserData&gt;
+class CL_UserDataMethodSlot_v1 : public CL_Slot_v1&lt;PARAM1&gt;
+{
+public:
+	typedef void (CallbackClass::*Callback)(PARAM1, UserData);
+
+	//: User Data Method Slot V1 constructor
+	CL_UserDataMethodSlot_v1(CallbackClass *cb_class, Callback callback, UserData user_data)
+	: cb_class(cb_class), callback(callback), user_data(user_data) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1) { (cb_class-&gt;*callback)(param1, user_data); }
+
+private:
+	CallbackClass *cb_class;
+	Callback callback;
+	UserData user_data;
+};
+
+#endif

Added: trunk/clanlib/API/Signals/slot_v2.h
===================================================================
--- trunk/clanlib/API/Signals/slot_v2.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Signals/slot_v2.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,133 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef header_slot_v2
+#define header_slot_v2
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;slot_generic.h&quot;
+
+//: Slot V2 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1, class PARAM2&gt;
+class CL_Slot_v2 : public CL_Slot_Generic
+{
+public:
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2)=0;
+};
+
+//: FunctionSlot V2 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1, class PARAM2&gt;
+class CL_FunctionSlot_v2 : public CL_Slot_v2&lt;PARAM1, PARAM2&gt;
+{
+public:
+	typedef void (*Callback)(PARAM1, PARAM2);
+
+	//: FunctionSlot V2 Constructor
+	CL_FunctionSlot_v2(Callback callback) : callback(callback) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2) { callback(param1, param2); }
+
+private:
+	Callback callback;
+};
+
+//: FunctorSlot V2 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template&lt;class Functor, class PARAM1, class PARAM2&gt;
+class CL_FunctorSlot_v2 : public CL_Slot_v2&lt;PARAM1, PARAM2&gt;
+{
+public:
+	//: FunctorSlot V2 Constructor
+	CL_FunctorSlot_v2(const Functor &amp;functor)
+	: functor(functor) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2) { functor(param1, param2); }
+
+private:
+	Functor functor;
+};
+
+//: Methane Slot V2 class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class CallbackClass, class PARAM1, class PARAM2&gt;
+class CL_MethodSlot_v2 : public CL_Slot_v2&lt;PARAM1, PARAM2&gt;
+{
+public:
+	typedef void (CallbackClass::*Callback)(PARAM1, PARAM2);
+
+	//: Methane Slot V2 constructor
+	CL_MethodSlot_v2(CallbackClass *cb_class, Callback callback)
+	: cb_class(cb_class), callback(callback) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2) { (cb_class-&gt;*callback)(param1, param2); }
+
+private:
+	CallbackClass *cb_class;
+	Callback callback;
+};
+
+//: User Data Methane Slot V2 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class CallbackClass, class PARAM1, class PARAM2, class UserData&gt;
+class CL_UserDataMethodSlot_v2 : public CL_Slot_v2&lt;PARAM1, PARAM2&gt;
+{
+public:
+	typedef void (CallbackClass::*Callback)(PARAM1, PARAM2, UserData);
+
+	//: User Data Methane Slot V2 Constructor
+	CL_UserDataMethodSlot_v2(CallbackClass *cb_class, Callback callback, UserData user_data)
+	: cb_class(cb_class), callback(callback), user_data(user_data) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2) { (cb_class-&gt;*callback)(param1, param2, user_data); }
+
+private:
+	CallbackClass *cb_class;
+	Callback callback;
+	UserData user_data;
+};
+
+#endif

Added: trunk/clanlib/API/Signals/slot_v3.h
===================================================================
--- trunk/clanlib/API/Signals/slot_v3.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Signals/slot_v3.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,133 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef header_slot_v3
+#define header_slot_v3
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;slot_generic.h&quot;
+
+//: Slot V3 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1, class PARAM2, class PARAM3&gt;
+class CL_Slot_v3 : public CL_Slot_Generic
+{
+public:
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3)=0;
+};
+
+//: FunctionSlot V3 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1, class PARAM2, class PARAM3&gt;
+class CL_FunctionSlot_v3 : public CL_Slot_v3&lt;PARAM1, PARAM2, PARAM3&gt;
+{
+public:
+	typedef void (*Callback)(PARAM1, PARAM2, PARAM3);
+
+	//: FunctionSlot V3 Constructor
+	CL_FunctionSlot_v3(Callback callback) : callback(callback) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3) { callback(param1, param2, param3); }
+
+private:
+	Callback callback;
+};
+
+//: FunctorSlot V3 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template&lt;class Functor, class PARAM1, class PARAM2, class PARAM3&gt;
+class CL_FunctorSlot_v3 : public CL_Slot_v3&lt;PARAM1, PARAM2, PARAM3&gt;
+{
+public:
+	//: FunctorSlot V3 Constructor
+	CL_FunctorSlot_v3(const Functor &amp;functor)
+	: functor(functor) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3) { functor(param1, param2, param3); }
+
+private:
+	Functor functor;
+};
+
+//: Methane Slot V3 class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class CallbackClass, class PARAM1, class PARAM2, class PARAM3&gt;
+class CL_MethodSlot_v3 : public CL_Slot_v3&lt;PARAM1, PARAM2, PARAM3&gt;
+{
+public:
+	typedef void (CallbackClass::*Callback)(PARAM1, PARAM2, PARAM3);
+
+	//: Methane Slot V3 constructor
+	CL_MethodSlot_v3(CallbackClass *cb_class, Callback callback)
+	: cb_class(cb_class), callback(callback) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3) { (cb_class-&gt;*callback)(param1, param2, param3); }
+
+private:
+	CallbackClass *cb_class;
+	Callback callback;
+};
+
+//: User Data Methane Slot V3 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class CallbackClass, class PARAM1, class PARAM2, class PARAM3, class UserData&gt;
+class CL_UserDataMethodSlot_v3 : public CL_Slot_v3&lt;PARAM1, PARAM2, PARAM3&gt;
+{
+public:
+	typedef void (CallbackClass::*Callback)(PARAM1, PARAM2, PARAM3, UserData);
+
+	//: User Data Methane Slot V3 Constructor
+	CL_UserDataMethodSlot_v3(CallbackClass *cb_class, Callback callback, UserData user_data)
+	: cb_class(cb_class), callback(callback), user_data(user_data) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3) { (cb_class-&gt;*callback)(param1, param2, param3, user_data); }
+
+private:
+	CallbackClass *cb_class;
+	Callback callback;
+	UserData user_data;
+};
+
+#endif

Added: trunk/clanlib/API/Signals/slot_v4.h
===================================================================
--- trunk/clanlib/API/Signals/slot_v4.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Signals/slot_v4.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,133 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef header_slot_v4
+#define header_slot_v4
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;slot_generic.h&quot;
+
+//: Slot V4 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1, class PARAM2, class PARAM3, class PARAM4&gt;
+class CL_Slot_v4 : public CL_Slot_Generic
+{
+public:
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4)=0;
+};
+
+//: FunctionSlot V4 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1, class PARAM2, class PARAM3, class PARAM4&gt;
+class CL_FunctionSlot_v4 : public CL_Slot_v4&lt;PARAM1, PARAM2, PARAM3, PARAM4&gt;
+{
+public:
+	typedef void (*Callback)(PARAM1, PARAM2, PARAM3, PARAM4);
+
+	//: FunctionSlot V4 Constructor
+	CL_FunctionSlot_v4(Callback callback) : callback(callback) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4) { callback(param1, param2, param3, param4); }
+
+private:
+	Callback callback;
+};
+
+//: FunctorSlot V4 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template&lt;class Functor, class PARAM1, class PARAM2, class PARAM3, class PARAM4&gt;
+class CL_FunctorSlot_v4 : public CL_Slot_v4&lt;PARAM1, PARAM2, PARAM3, PARAM4&gt;
+{
+public:
+	//: FunctorSlot V4 Constructor
+	CL_FunctorSlot_v4(const Functor &amp;functor)
+	: functor(functor) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4) { functor(param1, param2, param3, param4); }
+
+private:
+	Functor functor;
+};
+
+//: Methane Slot V4 class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class CallbackClass, class PARAM1, class PARAM2, class PARAM3, class PARAM4&gt;
+class CL_MethodSlot_v4 : public CL_Slot_v4&lt;PARAM1, PARAM2, PARAM3, PARAM4&gt;
+{
+public:
+	typedef void (CallbackClass::*Callback)(PARAM1, PARAM2, PARAM3, PARAM4);
+
+	//: Methane Slot V4 constructor
+	CL_MethodSlot_v4(CallbackClass *cb_class, Callback callback)
+	: cb_class(cb_class), callback(callback) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4) { (cb_class-&gt;*callback)(param1, param2, param3, param4); }
+
+private:
+	CallbackClass *cb_class;
+	Callback callback;
+};
+
+//: User Data Methane Slot V4 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class CallbackClass, class PARAM1, class PARAM2, class PARAM3, class PARAM4, class UserData&gt;
+class CL_UserDataMethodSlot_v4 : public CL_Slot_v4&lt;PARAM1, PARAM2, PARAM3, PARAM4&gt;
+{
+public:
+	typedef void (CallbackClass::*Callback)(PARAM1, PARAM2, PARAM3, PARAM4, UserData);
+
+	//: User Data Methane Slot V4 Constructor
+	CL_UserDataMethodSlot_v4(CallbackClass *cb_class, Callback callback, UserData user_data)
+	: cb_class(cb_class), callback(callback), user_data(user_data) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4) { (cb_class-&gt;*callback)(param1, param2, param3, param4, user_data); }
+
+private:
+	CallbackClass *cb_class;
+	Callback callback;
+	UserData user_data;
+};
+
+#endif

Added: trunk/clanlib/API/Signals/slot_v5.h
===================================================================
--- trunk/clanlib/API/Signals/slot_v5.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Signals/slot_v5.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,133 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef header_slot_v5
+#define header_slot_v5
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;slot_generic.h&quot;
+
+//: Slot V5 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1, class PARAM2, class PARAM3, class PARAM4, class PARAM5&gt;
+class CL_Slot_v5 : public CL_Slot_Generic
+{
+public:
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4, PARAM5 param5)=0;
+};
+
+//: FunctionSlot V5 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1, class PARAM2, class PARAM3, class PARAM4, class PARAM5&gt;
+class CL_FunctionSlot_v5 : public CL_Slot_v5&lt;PARAM1, PARAM2, PARAM3, PARAM4, PARAM5&gt;
+{
+public:
+	typedef void (*Callback)(PARAM1, PARAM2, PARAM3, PARAM4, PARAM5);
+
+	//: FunctionSlot V5 Constructor
+	CL_FunctionSlot_v5(Callback callback) : callback(callback) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4, PARAM5 param5) { callback(param1, param2, param3, param4, param5); }
+
+private:
+	Callback callback;
+};
+
+//: FunctorSlot V5 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template&lt;class Functor, class PARAM1, class PARAM2, class PARAM3, class PARAM4, class PARAM5&gt;
+class CL_FunctorSlot_v5 : public CL_Slot_v5&lt;PARAM1, PARAM2, PARAM3, PARAM4, PARAM5&gt;
+{
+public:
+	//: FunctorSlot V5 Constructor
+	CL_FunctorSlot_v5(const Functor &amp;functor)
+	: functor(functor) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4, PARAM5 param5) { functor(param1, param2, param3, param4, param5); }
+
+private:
+	Functor functor;
+};
+
+//: Methane Slot V5 class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class CallbackClass, class PARAM1, class PARAM2, class PARAM3, class PARAM4, class PARAM5&gt;
+class CL_MethodSlot_v5 : public CL_Slot_v5&lt;PARAM1, PARAM2, PARAM3, PARAM4, PARAM5&gt;
+{
+public:
+	typedef void (CallbackClass::*Callback)(PARAM1, PARAM2, PARAM3, PARAM4, PARAM5);
+
+	//: Methane Slot V5 constructor
+	CL_MethodSlot_v5(CallbackClass *cb_class, Callback callback)
+	: cb_class(cb_class), callback(callback) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4, PARAM5 param5) { (cb_class-&gt;*callback)(param1, param2, param3, param4, param5); }
+
+private:
+	CallbackClass *cb_class;
+	Callback callback;
+};
+
+//: User Data Methane Slot V5 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class CallbackClass, class PARAM1, class PARAM2, class PARAM3, class PARAM4, class PARAM5, class UserData&gt;
+class CL_UserDataMethodSlot_v5 : public CL_Slot_v5&lt;PARAM1, PARAM2, PARAM3, PARAM4, PARAM5&gt;
+{
+public:
+	typedef void (CallbackClass::*Callback)(PARAM1, PARAM2, PARAM3, PARAM4, PARAM5, UserData);
+
+	//: User Data Methane Slot V5 Constructor
+	CL_UserDataMethodSlot_v5(CallbackClass *cb_class, Callback callback, UserData user_data)
+	: cb_class(cb_class), callback(callback), user_data(user_data) { return; }
+
+	//: Call
+	virtual void call(PARAM1 param1, PARAM2 param2, PARAM3 param3, PARAM4 param4, PARAM5 param5) { (cb_class-&gt;*callback)(param1, param2, param3, param4, param5, user_data); }
+
+private:
+	CallbackClass *cb_class;
+	Callback callback;
+	UserData user_data;
+};
+
+#endif

Added: trunk/clanlib/API/Signals/slotbuffer_v0.h
===================================================================
--- trunk/clanlib/API/Signals/slotbuffer_v0.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Signals/slotbuffer_v0.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,99 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef header_slotbuffer_v0
+#define header_slotbuffer_v0
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;signal_v0.h&quot;
+
+//: Slot Buffer V0 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+class CL_SlotBuffer_v0
+{
+//! Construction:
+public:
+	//: Slot Buffer V0 Constructor
+	CL_SlotBuffer_v0() : count(0)
+	{
+	}
+
+	//: Slot Buffer V0 Constructor
+	CL_SlotBuffer_v0(CL_Signal_v0 &amp;signal) : count(0)
+	{
+		connect(signal);
+	}
+
+//! Attributes:
+public:
+	//: Bool
+	operator bool()
+	{
+		return count &gt; 0;
+	}
+
+	//: Size
+	int size()
+	{
+		return count;
+	}
+
+//! Operations:
+public:
+	//: Connect
+	void connect(CL_Signal_v0 &amp;signal)
+	{
+		slot = signal.connect(this, &amp;CL_SlotBuffer_v0::callback);
+	}
+
+	//: Disconnect
+	void disconnect(CL_Signal_v0 &amp;signal)
+	{
+		signal.disconnect(slot);
+	}
+
+//! Implementation:
+private:
+	void callback()
+	{
+		count++;
+	}
+
+	CL_Slot slot;
+	int count;
+};
+
+#endif

Added: trunk/clanlib/API/Signals/slotbuffer_v1.h
===================================================================
--- trunk/clanlib/API/Signals/slotbuffer_v1.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Signals/slotbuffer_v1.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,118 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSignal=&quot;System&quot;
+//! header=signals.h
+
+#ifndef header_slotbuffer_v1
+#define header_slotbuffer_v1
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;vector&gt;
+#include &quot;slot.h&quot;
+
+template &lt;class PARAM1&gt; class CL_Signal_v1;
+
+//: SlotBuffer V1 Class
+//- !group=Signal/System!
+//- !header=signals.h!
+template &lt;class PARAM1&gt;
+class CL_SlotBuffer_v1
+{
+public:
+	struct Params
+	{
+		PARAM1 p1;
+	};
+
+//! Construction:
+public:
+	//: Slot Buffer V1 Constructor
+	CL_SlotBuffer_v1()
+	{
+	}
+
+	//: Slot Buffer V1 Constructor
+	CL_SlotBuffer_v1(CL_Signal_v1&lt;PARAM1&gt; &amp;signal)
+	{
+		connect(signal);
+	}
+
+//! Attributes:
+public:
+	//: Bool
+	operator bool()
+	{
+		return !params.empty();
+	}
+
+	//: Size
+	int size()
+	{
+		return params.size();
+	}
+
+	//: Operator
+	Params &amp;operator[](int index)
+	{
+		return params[index];
+	}
+
+//! Operations:
+public:
+	//: Connect
+	void connect(CL_Signal_v1&lt;PARAM1&gt; &amp;signal)
+	{
+		slot = signal.connect(this, &amp;CL_SlotBuffer_v1::callback);
+	}
+
+	//: Disconnect
+	void disconnect(CL_Signal_v1&lt;PARAM1&gt; &amp;signal)
+	{
+		signal.disconnect(slot);
+	}
+
+//! Implementation:
+private:
+	void callback(PARAM1 p1)
+	{
+		Params p;
+		p.p1 = p1;
+
+		params.push_back(p);
+	}
+
+	std::vector&lt;Params&gt; params;
+	CL_Slot slot;
+};
+
+#endif

Added: trunk/clanlib/API/Sound/SoundFilters/echofilter.h
===================================================================
--- trunk/clanlib/API/Sound/SoundFilters/echofilter.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Sound/SoundFilters/echofilter.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,78 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSound=&quot;Filters&quot;
+//! header=sound.h
+
+#ifndef header_echofilter
+#define header_echofilter
+
+#ifdef CL_API_DLL
+#ifdef CL_SOUND_EXPORT
+#define CL_API_SOUND __declspec(dllexport)
+#else
+#define CL_API_SOUND __declspec(dllimport)
+#endif
+#else
+#define CL_API_SOUND
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../soundfilter.h&quot;
+
+class CL_EchoFilter_Generic;
+
+//: Echo Filter Class
+//- !group=Sound/Filters!
+//- !header=sound.h!
+class CL_API_SOUND CL_EchoFilter : public CL_SoundFilter
+{
+//! Construction:
+public:
+	//: Echo Filter Constructor
+	CL_EchoFilter(int buffer_size = 32*1024, int shift_factor = 2);
+
+	//: Echo Filter Destructor
+	virtual ~CL_EchoFilter();
+
+//! Operations:
+public:
+	//: Filter
+	virtual void filter(int **sample_data, int num_samples, int channels);
+
+//! Implementation:
+private:
+	CL_EchoFilter(const CL_EchoFilter &amp;copy) { return; } // disallow copy construction.
+	CL_EchoFilter_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Sound/SoundFilters/fadefilter.h
===================================================================
--- trunk/clanlib/API/Sound/SoundFilters/fadefilter.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Sound/SoundFilters/fadefilter.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,91 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSound=&quot;Filters&quot;
+//! header=sound.h
+
+#ifndef header_fadefilter
+#define header_fadefilter
+
+#ifdef CL_API_DLL
+#ifdef CL_SOUND_EXPORT
+#define CL_API_SOUND __declspec(dllexport)
+#else
+#define CL_API_SOUND __declspec(dllimport)
+#endif
+#else
+#define CL_API_SOUND
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../soundfilter.h&quot;
+
+class CL_FadeFilter_Generic;
+
+//: Fade Filter Class
+//- !group=Sound/Filters!
+//- !header=sound.h!
+class CL_API_SOUND CL_FadeFilter : public CL_SoundFilter
+{
+//! Construction:
+public:
+	//: Fade Filter Constructor
+	CL_FadeFilter(float initial_volume);
+
+	//: Fade Filter Destructor
+	virtual ~CL_FadeFilter();
+
+//! Attributes:
+public:
+	//: Returns the current volume of the fade filter, from 0.0f (no volume) to 1.0f (full volume).
+	float get_volume() const;
+
+//! Operations:
+public:
+	//: Sets the volume instant.
+	void set_volume(float new_volume);
+	
+	//: Fade to volume, from 0.0f (no volume) to 1.0f (full volume).
+	void fade_to_volume(float new_volume, int duration = 1000);
+
+//! Overridables:
+protected:
+	virtual void filter(int **sample_data, int num_samples, int channels);
+
+//! Implementation:
+private:
+	CL_FadeFilter(const CL_FadeFilter &amp;copy) { return; } // disallow copy construction.
+
+	CL_FadeFilter_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Sound/SoundFilters/inverse_echofilter.h
===================================================================
--- trunk/clanlib/API/Sound/SoundFilters/inverse_echofilter.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Sound/SoundFilters/inverse_echofilter.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,78 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSound=&quot;Filters&quot;
+//! header=sound.h
+
+#ifndef header_inverse_echofilter
+#define header_inverse_echofilter
+
+#ifdef CL_API_DLL
+#ifdef CL_SOUND_EXPORT
+#define CL_API_SOUND __declspec(dllexport)
+#else
+#define CL_API_SOUND __declspec(dllimport)
+#endif
+#else
+#define CL_API_SOUND
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../soundfilter.h&quot;
+
+class CL_InverseEchoFilter_Generic;
+
+//: Inverse Echo Filter Class
+//- !group=Sound/Filters!
+//- !header=sound.h!
+class CL_API_SOUND CL_InverseEchoFilter : public CL_SoundFilter
+{
+//! Construction:
+public:
+	//: Inverse Echo Filter Constructor
+	CL_InverseEchoFilter(int buffer_size = 64*1024);
+
+	//: Inverse Echo Filter Destructor
+	virtual ~CL_InverseEchoFilter();
+
+//! Operations:
+public:
+	//: Filter
+	virtual void filter(int **sample_data, int num_samples, int channels);
+
+//! Implementation:
+private:
+	CL_InverseEchoFilter(const CL_InverseEchoFilter &amp;copy) { return; } // disallow copy construction.
+	CL_InverseEchoFilter_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Sound/SoundProviders/soundprovider_factory.h
===================================================================
--- trunk/clanlib/API/Sound/SoundProviders/soundprovider_factory.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Sound/SoundProviders/soundprovider_factory.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,83 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSound=&quot;Sound Providers&quot;
+//! header=sound.h
+
+#ifndef header_soundprovider_factory
+#define header_soundprovider_factory
+
+#ifdef CL_API_DLL
+#ifdef CL_SOUND_EXPORT
+#define CL_API_SOUND __declspec(dllexport)
+#else
+#define CL_API_SOUND __declspec(dllimport)
+#endif
+#else
+#define CL_API_SOUND
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;map&gt;
+#include &lt;string&gt;
+
+class CL_SoundProvider;
+class CL_InputSourceProvider;
+class CL_SoundProviderType;
+
+//: Sound Provider Factor class.
+//- !group=Sound/Sound Providers!
+//- !header=sound.h!
+class CL_API_SOUND CL_SoundProviderFactory
+{
+//! Attributes:
+public:
+	//: Map of the class factories for each sound provider type.
+	static std::map&lt;std::string, CL_SoundProviderType *&gt; types;
+
+//! Operations:
+public:
+	//: Loads an sample file from 'filename', using the provider
+	//: identified by 'type'.
+	//- &lt;p&gt;If the type is an empty string, it
+	//- uses the extension of the filename to determine what type
+	//- it is.&lt;/p&gt;
+	//- &lt;p&gt;The input provider will be used as a the source for filename,
+	//- if specified.&lt;/p&gt;
+	static CL_SoundProvider *load(
+		const std::string &amp;filename,
+		bool streamed = false,
+		const std::string &amp;type = &quot;&quot;,
+		CL_InputSourceProvider *input_provider = 0);
+};
+
+#endif

Added: trunk/clanlib/API/Sound/SoundProviders/soundprovider_raw.h
===================================================================
--- trunk/clanlib/API/Sound/SoundProviders/soundprovider_raw.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Sound/SoundProviders/soundprovider_raw.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,92 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSound=&quot;Sound Providers&quot;
+//! header=sound.h
+
+#ifndef header_sound_provider_raw
+#define header_sound_provider_raw
+
+#ifdef CL_API_DLL
+#ifdef CL_SOUND_EXPORT
+#define CL_API_SOUND __declspec(dllexport)
+#else
+#define CL_API_SOUND __declspec(dllimport)
+#endif
+#else
+#define CL_API_SOUND
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../soundprovider.h&quot;
+
+class CL_SoundProvider_Raw_Generic;
+
+//: Sound provider in a raw PCM format (no header in file).
+//- !group=Sound/Sound Providers!
+//- !header=sound.h!
+class CL_API_SOUND CL_SoundProvider_Raw : public CL_SoundProvider
+{
+//! Construction:
+public:
+	//: Constructs a sound provider based on some raw PCM data.
+	//param sound_data: Raw PCM data.
+	//param num_samples: Number of samples to be read out of sound_data.
+	//param bytes_per_sample: The size of a sample in bytes. This is 2 for 16 bit, and 1 for 8 bit.
+	//param stereo: True if sound is stereo (two channels).
+	//param frequency: Playback frequency for sample data.
+	CL_SoundProvider_Raw(
+		void *sound_data,
+		int num_samples,
+		int bytes_per_sample,
+		bool stereo,
+		int frequency = 22050);
+
+	virtual ~CL_SoundProvider_Raw();
+
+//! Operations:
+public:
+	//: Called by CL_SoundBuffer when a new session starts.
+	//return: The soundbuffer session to be attached to the newly started session.
+	virtual CL_SoundProvider_Session *begin_session();
+
+	//: Called by CL_SoundBuffer when a session has finished. After this call,
+	//- &lt;p&gt;CL_SoundBuffer will not access the session anymore. It can safely be deleted
+	//- here (and in most cases should be delete here).&lt;/p&gt;
+	virtual void end_session(CL_SoundProvider_Session *session);
+
+//! Implementation:
+private:
+	CL_SoundProvider_Raw_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Sound/SoundProviders/soundprovider_recorder.h
===================================================================
--- trunk/clanlib/API/Sound/SoundProviders/soundprovider_recorder.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Sound/SoundProviders/soundprovider_recorder.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,84 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSound=&quot;Sound Providers&quot;
+//! header=sound.h
+
+#ifndef header_sound_provider_recorder
+#define header_sound_provider_recorder
+
+#ifdef CL_API_DLL
+#ifdef CL_SOUND_EXPORT
+#define CL_API_SOUND __declspec(dllexport)
+#else
+#define CL_API_SOUND __declspec(dllimport)
+#endif
+#else
+#define CL_API_SOUND
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../soundprovider.h&quot;
+
+class CL_SoundProvider_Recorder_Generic;
+
+//: Sound provider getting data from a recording device (microphone)
+//- !group=Sound/Sound Providers!
+//- !header=sound.h!
+class CL_API_SOUND CL_SoundProvider_Recorder : public CL_SoundProvider
+{
+//! Construction:
+public:
+	//: Constructs a sound provider getting data from a recording device.
+	//param frequency: Recording frequency for sample data.
+	CL_SoundProvider_Recorder(
+		int frequency = 22050);
+
+	virtual ~CL_SoundProvider_Recorder();
+
+//! Operations:
+public:
+	//: Called by CL_SoundBuffer when a new session starts.
+	//return: The soundbuffer session to be attached to the newly started session.
+	virtual CL_SoundProvider_Session *begin_session();
+
+	//: Called by CL_SoundBuffer when a session has finished. After this call,
+	//- &lt;p&gt;CL_SoundBuffer will not access the session anymore. It can safely be deleted
+	//- here (and in most cases should be delete here).&lt;/p&gt;
+	virtual void end_session(CL_SoundProvider_Session *session);
+
+//! Implementation:
+private:
+	CL_SoundProvider_Recorder_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Sound/SoundProviders/soundprovider_type.h
===================================================================
--- trunk/clanlib/API/Sound/SoundProviders/soundprovider_type.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Sound/SoundProviders/soundprovider_type.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,80 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSound=&quot;Sound Providers&quot;
+//! header=sound.h
+
+#ifndef header_soundprovider_type
+#define header_soundprovider_type
+
+#ifdef CL_API_DLL
+#ifdef CL_SOUND_EXPORT
+#define CL_API_SOUND __declspec(dllexport)
+#else
+#define CL_API_SOUND __declspec(dllimport)
+#endif
+#else
+#define CL_API_SOUND
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+
+class CL_SoundProvider;
+class CL_InputSourceProvider;
+
+//: Sound provider type
+//- !group=Sound/Sound Providers!
+//- !header=sound.h!
+class CL_API_SOUND CL_SoundProviderType
+{
+//! Construction:
+public:
+	//: Registers a sound provider type in the CL_SoundProviderFactory.
+	CL_SoundProviderType(const std::string &amp;type);
+
+	//: Unregisters a sound provider type in the CL_SoundProviderFactory.
+	virtual ~CL_SoundProviderType();
+
+//! Operations:
+public:
+	//: Called to load with this sound provider type.
+	virtual CL_SoundProvider *load(
+		const std::string &amp;filename,
+		CL_InputSourceProvider *input_provider,
+		bool streamed) = 0;
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/API/Sound/SoundProviders/soundprovider_type_register.h
===================================================================
--- trunk/clanlib/API/Sound/SoundProviders/soundprovider_type_register.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Sound/SoundProviders/soundprovider_type_register.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,67 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSound=&quot;Sound Providers&quot;
+//! header=sound.h
+
+#ifndef header_soundprovider_type_register
+#define header_soundprovider_type_register
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;soundprovider_type.h&quot;
+
+//: Class template to register a sound provider type.
+//- !group=Sound/Sound Providers!
+//- !header=sound.h!
+template&lt;class SoundProviderClass&gt;
+class CL_SoundProviderType_Register : public CL_SoundProviderType
+{
+//! Construction:
+public:
+	//: Registers sound provider type in the CL_SoundProviderFactory.
+	CL_SoundProviderType_Register(const std::string &amp;type) : CL_SoundProviderType(type)
+	{
+	}
+
+//! Operations:
+public:
+	//: Called to load static with this sound provider type.
+	virtual CL_SoundProvider *load(
+		const std::string &amp;filename,
+		CL_InputSourceProvider *input_provider,
+		bool stream)
+	{
+		return new SoundProviderClass(filename, input_provider, stream);
+	}
+};
+
+#endif

Added: trunk/clanlib/API/Sound/SoundProviders/soundprovider_wave.h
===================================================================
--- trunk/clanlib/API/Sound/SoundProviders/soundprovider_wave.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Sound/SoundProviders/soundprovider_wave.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,90 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSound=&quot;Sound Providers&quot;
+//! header=sound.h
+
+#ifndef header_sound_provider_wave
+#define header_sound_provider_wave
+
+#ifdef CL_API_DLL
+#ifdef CL_SOUND_EXPORT
+#define CL_API_SOUND __declspec(dllexport)
+#else
+#define CL_API_SOUND __declspec(dllimport)
+#endif
+#else
+#define CL_API_SOUND
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../soundprovider.h&quot;
+#include &lt;string&gt;
+
+class CL_InputSourceProvider;
+class CL_SoundProvider_Wave_Generic;
+
+//: Windows WAVE sample format (.wav) sound provider.
+//- !group=Sound/Sound Providers!
+//- !header=sound.h!
+class CL_API_SOUND CL_SoundProvider_Wave : public CL_SoundProvider
+{
+//! Construction:
+public:
+	//: Constructs a sound provider based on a Windows wave (.wav) file.
+	//param filename: Filename of wave file.
+	//param provider: Input source provider used to retrieve wave file.
+	//param stream: If true, will stream from disk. If false, will load it to memory.
+	CL_SoundProvider_Wave(
+		const std::string &amp;filename,
+		CL_InputSourceProvider *provider = 0,
+		bool stream = false);
+
+	virtual ~CL_SoundProvider_Wave();
+
+//! Operations:
+public:
+	//: Called by CL_SoundBuffer when a new session starts.
+	//return: The soundbuffer session to be attached to the newly started session.
+	virtual CL_SoundProvider_Session *begin_session();
+
+	//: Called by CL_SoundBuffer when a session has finished. After this call,
+	//- &lt;p&gt;CL_SoundBuffer will not access the session anymore. It can safely be deleted
+	//- here (and in most cases should be delete here).&lt;/p&gt;
+	virtual void end_session(CL_SoundProvider_Session *session);
+
+//! Implementation:
+private:
+	CL_SoundProvider_Wave_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Sound/cd_drive.h
===================================================================
--- trunk/clanlib/API/Sound/cd_drive.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Sound/cd_drive.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,123 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSound=&quot;CD Audio&quot;
+//! header=sound.h
+
+#ifndef header_cd_drive
+#define header_cd_drive
+
+#ifdef CL_API_DLL
+#ifdef CL_SOUND_EXPORT
+#define CL_API_SOUND __declspec(dllexport)
+#else
+#define CL_API_SOUND __declspec(dllimport)
+#endif
+#else
+#define CL_API_SOUND
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Core/System/sharedptr.h&quot;
+#include &lt;string&gt;
+#include &lt;vector&gt;
+
+class CL_CDDrive_Generic;
+
+//: CD drive audio interface.
+//- !group=Sound/CD Audio!
+//- !header=sound.h!
+//- &lt;p&gt;Use this class to control the CDROM drive in your computer.&lt;/p&gt;
+class CL_API_SOUND CL_CDDrive
+{
+//! Construction:
+public:
+	//: Constructs a CD drive object.
+	CL_CDDrive();
+
+	CL_CDDrive(const CL_CDDrive &amp;copy);
+
+	virtual ~CL_CDDrive();
+
+//! Attributes:
+public:
+	//: Returns the amount of CD drives available on the system.
+	static std::vector&lt;CL_CDDrive&gt; &amp;get_drives();
+
+	//: Get the path of the CD drive.
+	std::string get_drive_path();
+
+	//: Get the name of the CD.
+	std::string get_cd_name();
+
+	//: Get the number of tracks available on the cd.
+	int get_num_tracks();
+
+	//: Returns true if the CD drive is playing.
+	bool is_playing();
+	
+	//: Returns the current track.
+	int get_cur_track();
+
+	//: Returns the current frame on the track.
+	int get_cur_frame();
+
+//! Operations:
+public:
+	//: Play from track 'track' til track 'end_track'.
+	//param track: Begin track.
+	//param end_track: End track.
+	bool play_tracks(int track, int end_track=0);
+
+	//: Play from frame 'frame' to 'end_frame'.
+	//param frame: Begin frame.
+	//param end_frame: End frame.
+	bool play_frames(int frame, int end_frame=0);
+
+	//: Play track 'track'. Returns true if successful.
+	bool play_track(int track);
+
+	//: Stop playing.
+	void stop();
+
+	//: Pause the playback.
+	void pause();
+
+	//: Resume the playback.
+	void resume();
+
+//! Implementation:
+private:
+	CL_SharedPtr&lt;CL_CDDrive_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/Sound/setupsound.h
===================================================================
--- trunk/clanlib/API/Sound/setupsound.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Sound/setupsound.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,73 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSound=&quot;System&quot;
+//! header=sound.h
+
+#ifndef header_setupsound
+#define header_setupsound
+
+#ifdef CL_API_DLL
+#ifdef CL_SOUND_EXPORT
+#define CL_API_SOUND __declspec(dllexport)
+#else
+#define CL_API_SOUND __declspec(dllimport)
+#endif
+#else
+#define CL_API_SOUND
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+//: ClanSound initialization functions.
+//- !group=Sound/System!
+//- !header=sound.h!
+class CL_API_SOUND CL_SetupSound
+{
+//! Construction:
+public:
+	//: Initializes clanSound.
+	//- &lt;p&gt;Constructing a CL_SetupSound object is equalent to calling CL_SetupSound::init().&lt;/p&gt;
+	//- &lt;p&gt;When the CL_SetupSound instance is destroyed, CL_SetupSound::deinit() is called.&lt;/p&gt;
+	CL_SetupSound(bool register_resources_only = false);
+
+	~CL_SetupSound();
+
+//! Operations:
+public:
+	//: Initialize the clanSound library.
+	static void init(bool register_resources_only = false);
+	
+	//: Deinitialize the clanSound library.
+	static void deinit();
+};
+
+#endif

Added: trunk/clanlib/API/Sound/sound.h
===================================================================
--- trunk/clanlib/API/Sound/sound.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Sound/sound.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,81 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSound=&quot;Audio Mixing&quot;
+//! header=sound.h
+
+#ifndef header_sound
+#define header_sound
+
+#ifdef CL_API_DLL
+#ifdef CL_SOUND_EXPORT
+#define CL_API_SOUND __declspec(dllexport)
+#else
+#define CL_API_SOUND __declspec(dllimport)
+#endif
+#else
+#define CL_API_SOUND
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+
+class CL_SoundOutput;
+
+class CL_API_SOUND CL_Sound
+//: Sound interface in ClanLib.
+//- !group=Sound/Audio Mixing!
+//- !header=sound.h!
+//- &lt;p&gt;All the functions that share name with those in CL_SoundOutput have the
+//- same functionality. The only difference is, that the ones CL_Sound
+//- operate on a selected sound output. This saves the trouble of passing around
+//- a pointer to the sound output, when only a single one is used anyway.&lt;/p&gt;
+//also: CL_SoundOutput - Sound Output interface class.
+//also: CL_SoundBuffer - Sample class in ClanLib.
+{
+//! Selected CL_SoundOutput accessors:
+public:
+	//: Returns the name of the current sound output:
+	static const std::string &amp;get_name();
+
+	//: Returns the mixing frequency of the current sound output.
+	static int get_mixing_frequency();
+
+	//: Returns the current selected sound output.
+	static CL_SoundOutput *get_current_output();
+
+	//: Change the current selected sound output.
+	//param output: The new current selected sound output.
+	static void select_output(CL_SoundOutput *output);
+};
+
+#endif

Added: trunk/clanlib/API/Sound/soundbuffer.h
===================================================================
--- trunk/clanlib/API/Sound/soundbuffer.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Sound/soundbuffer.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,167 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSound=&quot;Audio Mixing&quot;
+//! header=sound.h
+
+#ifndef header_soundbuffer
+#define header_soundbuffer
+
+#ifdef CL_API_DLL
+#ifdef CL_SOUND_EXPORT
+#define CL_API_SOUND __declspec(dllexport)
+#else
+#define CL_API_SOUND __declspec(dllimport)
+#endif
+#else
+#define CL_API_SOUND
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Core/System/mutexsharedptr.h&quot;
+#include &quot;../Core/Resources/resource.h&quot;
+#include &quot;soundbuffer_session.h&quot;
+
+class CL_ResourceManager;
+class CL_SoundOutput;
+class CL_SoundProvider;
+class CL_SoundBuffer_Session;
+class CL_SoundFilter;
+class CL_SoundBuffer_Generic;
+
+class CL_API_SOUND CL_SoundBuffer
+//: Sample interface in ClanLib.
+//- !group=Sound/Audio Mixing!
+//- !header=sound.h!
+//- &lt;p&gt;The CL_SoundBuffer class represents a sample in ClanLib. It can
+//- either be static or streamed. The soundbuffer gets its sample data from
+//- a soundprovider, that is passed during construction.&lt;/p&gt;
+//also: CL_SoundProvider
+//also: CL_SoundProvider_Session
+//also: CL_SoundBuffer_Session
+{
+//! Construction:
+public:
+	//: Construct sound buffer.
+	//- &lt;p&gt;A sound buffer can be constructed either as static or
+	//- streamed. If the sound buffer is loaded from resources, the
+	//- buffer type is determined by the resource option 'stream'
+	//- associated with the resource.&lt;/p&gt;
+	//-
+	//- &lt;p&gt;CL_SoundBuffer's internals are reference counted, so the copy
+	//- constructor will create a new soundbuffer object which shares
+	//- the same buffer as the original one. This means that if the copy
+	//- is modified, the original is affected as well.&lt;/p&gt;
+	//-
+	//- &lt;p&gt;If &lt;i&gt;delete_provider&lt;/i&gt; is true, the provider will be
+	//- deleted when the soundbuffer is deleted.&lt;/p&gt;
+	
+	CL_SoundBuffer();
+	
+	CL_SoundBuffer(
+		const std::string &amp;res_id,
+		CL_ResourceManager *manager);
+
+	CL_SoundBuffer(
+		CL_SoundProvider *provider,
+		bool delete_provider = false);
+
+	CL_SoundBuffer(
+		const std::string &amp;filename,
+		bool streamed = false,
+		const std::string &amp;format = &quot;&quot;);
+
+	CL_SoundBuffer(const CL_SoundBuffer &amp;copy);
+
+	virtual ~CL_SoundBuffer();
+
+//! Attributes:
+public:
+	//: Returns the sound provider to be used for playback.
+	CL_SoundProvider *get_sound_provider() const;
+
+	//: Returns the start/default volume used when the buffer is played.
+	float get_volume() const;
+
+	//: Returns the default panning position when the buffer is played.
+	float get_pan() const;
+
+	//: Returns true if an instance of this soundbuffer is playing
+	bool is_playing() const;
+
+//! Operations:
+public:
+	//: Copy assignment operator.
+	CL_SoundBuffer &amp;operator =(const CL_SoundBuffer &amp;copy);
+
+	//: Sets the volume of the sound buffer in a relative measure (0-&gt;1)
+	//- &lt;p&gt;A value of 0 will effectively mute the sound (although it will
+	//- still be sampled), and a value of 1 will set the volume to &quot;max&quot;.&lt;/p&gt;
+	//param new_volume: New volume of sound buffer. 
+	void set_volume(float new_volume);
+
+	//: Sets the panning of the sound buffer played in measures from -1 -&gt; 1
+	//- &lt;p&gt;Setting the pan with a value of -1 will pan the sound buffer to the
+	//- extreme left (left speaker only), 1 will pan the sound buffer to the
+	//- extreme right (right speaker only).&lt;/p&gt;
+	//param new_pan: New pan of the sound buffer played.
+	void set_pan(float new_pan);
+
+	//: Adds the sound filter to the sound buffer.
+	//param filter: Sound filter to pass sound through.
+	//param delete_filter: If true, the filter will be deleted when the sound output is destroyed.
+	void add_filter(CL_SoundFilter *filter, bool delete_filter = false);
+
+	//: Remove the sound filter from the sound buffer.
+	void remove_filter(CL_SoundFilter *filter);
+
+	//: Stops any sessions playing this soundbuffer
+	void stop();
+
+	//: Plays the soundbuffer on the specified soundcard.
+	//param output: Sound output to be used - NULL means use the current selected sound output (CL_Sound::get_selected_output().
+	//return: The playback session.
+	CL_SoundBuffer_Session play(bool looping = false, CL_SoundOutput *output = 0);
+
+	//: Prepares the soundbuffer for playback on the specified soundcard.
+	//param output: Sound output to be used - NULL means use the current selected sound output (CL_Sound::get_selected_output().
+	//return: The playback session.
+	CL_SoundBuffer_Session prepare(bool looping = false, CL_SoundOutput *output = 0);
+
+//! Implementation:
+private:
+	CL_Resource resource;
+
+	CL_MutexSharedPtr&lt;CL_SoundBuffer_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/Sound/soundbuffer_session.h
===================================================================
--- trunk/clanlib/API/Sound/soundbuffer_session.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Sound/soundbuffer_session.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,172 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSound=&quot;Audio Mixing&quot;
+//! header=sound.h
+
+#ifndef header_soundbuffer_session
+#define header_soundbuffer_session
+
+#ifdef CL_API_DLL
+#ifdef CL_SOUND_EXPORT
+#define CL_API_SOUND __declspec(dllexport)
+#else
+#define CL_API_SOUND __declspec(dllimport)
+#endif
+#else
+#define CL_API_SOUND
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Core/System/mutexsharedptr.h&quot;
+
+class CL_SoundCard;
+class CL_SoundFilter;
+class CL_SoundBuffer;
+class CL_SoundBuffer_Session_Generic;
+
+class CL_API_SOUND CL_SoundBuffer_Session
+//: CL_SoundBuffer_Session provides control over a playing soundeffect.
+//- !group=Sound/Audio Mixing!
+//- !header=sound.h!
+//- &lt;p&gt;Whenever a soundbuffer is played, it returns a CL_SoundBuffer_Session
+//- class, which can be used to control the sound (its volume, pitch, 
+//- pan, position). It can also be used to retrigger the sound
+//- or to stop it.&lt;/p&gt;
+{
+//! Construction:
+public:
+	//: Creates a soundbuffer session.
+	CL_SoundBuffer_Session();
+
+	CL_SoundBuffer_Session(const CL_SoundBuffer_Session &amp;copy);
+
+	virtual ~CL_SoundBuffer_Session();
+
+//! Attributes:
+public:
+	//: Returns the current sample position of the playback.
+	int get_position() const;
+	
+	//: Returns the sample position relative to the full length.
+	//- &lt;p&gt;The value returned will be between 0 and 1, where 0
+	//- means the session is at the beginning, and 1
+	//- means that the soundeffect has reached the end.&lt;/p&gt;
+	float get_position_relative() const;
+
+	//: Returns the total length (in samples) of the sound buffer played.
+	//- &lt;p&gt;Value returned will be -1 if the length is unknown (in
+	//- case of non-static soundeffects like streamed sound)&lt;/p&gt;
+	int get_length() const;
+
+	//: Returns the frequency of the session.
+	int get_frequency() const;
+
+	//: Returns the linear relative volume of the soundeffect.
+	//- &lt;p&gt;0 means the soundeffect is muted, 1 means the soundeffect
+	//- is playing at &quot;max&quot; volume.&lt;/p&gt;
+	float get_volume() const;
+	
+	//: Returns the current pan (in a measure from -1 -&gt; 1).
+	//- &lt;p&gt;-1 means the soundeffect is only playing in the left speaker, 
+	//- and 1 means the soundeffect is only playing in the right speaker.&lt;/p&gt;
+	float get_pan() const;
+
+	//: Returns true if the session is playing
+	bool is_playing();
+
+//! Operations:
+public:
+	//: Sets the session position to 'new_pos'.
+	//- &lt;p&gt;The new position of the session.&lt;/p&gt;
+	//return: Returns true if operation completed succesfully.
+	bool set_position(int new_pos);
+
+	//: Sets the relative position of the session.
+	//- &lt;p&gt;Value must be between 0 and 1, where 0 sets the 
+	//- session to the beginning, and 1 sets it
+	//- to the end of the sound buffer.&lt;/p&gt;
+	//param new_pos: New relative position.
+	//return: Returns true if operation completed succesfully.
+	bool set_position_relative(float new_pos);
+	
+	//: Sets the frequency of the session.
+	//param new_freq: New frequency of session.
+	//return: Returns true, if the operation completed succesfully.
+	bool set_frequency(int new_freq);
+	
+	//: Sets the volume of the session in a relative measure (0-&gt;1)
+	//- &lt;p&gt;A value of 0 will effectively mute the sound (although it will
+	//- still be sampled), and a value of 1 will set the volume to &quot;max&quot;.&lt;/p&gt;
+	//param new_volume: New volume of session. 
+	//return: Returns true if the operation completed succesfully.
+	void set_volume(float new_volume);
+
+	//: Sets the panning of the session played in measures from -1 -&gt; 1
+	//- &lt;p&gt;Setting the pan with a value of -1 will pan the session to the
+	//- extreme left (left speaker only), 1 will pan the session to the
+	//- extreme right (right speaker only).&lt;/p&gt;
+	//param new_pan: New pan of the session played.
+	//return: Returns true if the operation completed sucecsfully.
+	void set_pan(float new_pan);
+
+	//: Starts playback of the session.
+	void play();
+
+	//: Stops playback of the session.
+	void stop();
+
+	//: Rewinds the session so playback will start from the beginning.
+	void rewind() { set_position(0); }
+
+	//: Determines whether this session should loop
+	//param loop: true if session should loop, false otherwise
+	void set_looping(bool loop);
+	
+	//: Adds the sound filter to the session. See CL_SoundFilter for details.
+	//param filter: Sound filter to pass sound through.
+	//param delete_filter: If true, the filter will be deleted when the session is destroyed
+	void add_filter(CL_SoundFilter *filter, bool delete_filter = false);
+
+	//: Remove the sound filter from the session. See CL_SoundFilter for details.
+	void remove_filter(CL_SoundFilter *filter);
+
+//! Implementation:
+private:
+	CL_SoundBuffer_Session(const CL_MutexSharedPtr&lt;CL_SoundBuffer_Session_Generic&gt; &amp;impl);
+
+	CL_MutexSharedPtr&lt;CL_SoundBuffer_Session_Generic&gt; impl;
+
+	friend class CL_SoundBuffer;
+};
+
+#endif

Added: trunk/clanlib/API/Sound/soundfilter.h
===================================================================
--- trunk/clanlib/API/Sound/soundfilter.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Sound/soundfilter.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,85 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSound=&quot;Audio Mixing&quot;
+//! header=sound.h
+
+#ifndef header_soundfilter
+#define header_soundfilter
+
+#ifdef CL_API_DLL
+#ifdef CL_SOUND_EXPORT
+#define CL_API_SOUND __declspec(dllexport)
+#else
+#define CL_API_SOUND __declspec(dllimport)
+#endif
+#else
+#define CL_API_SOUND
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+class CL_SoundFilter_Generic;
+
+//: Sound Filter Class
+//- !group=Sound/Audio Mixing!
+//- !header=sound.h!
+class CL_API_SOUND CL_SoundFilter
+{
+//! Construction:
+public:
+	//: Sound filter constructor.
+	CL_SoundFilter();
+
+	CL_SoundFilter(const CL_SoundFilter &amp;copy);
+
+	//: Sound Filter Destructor
+	virtual ~CL_SoundFilter();
+	
+//! Operations:
+public:
+	//: Copy assignment operator.
+	CL_SoundFilter &amp;operator =(const CL_SoundFilter &amp;copy);
+
+//! Overridables:
+	//: Filter callback.
+	//- &lt;p&gt;All sound data is passed through this function,
+	//- which modifies the sample data accordingly to the function of the
+	//- filter.&lt;/p&gt;
+	//- &lt;p&gt;The format of the sample data is always 16 bit stereo. &lt;/p&gt;
+	virtual void filter(int **sample_data, int num_samples, int channels)=0;
+
+//! Implementation:
+public:
+	CL_SoundFilter_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Sound/soundformat.h
===================================================================
--- trunk/clanlib/API/Sound/soundformat.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Sound/soundformat.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,49 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSound=&quot;Audio Mixing&quot;
+//! header=sound.h
+
+#ifndef header_soundformat
+#define header_soundformat
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+//: Sound Format Enums
+//- !group=Sound/Audio Mixing!
+//- !header=sound.h!
+enum CL_SoundFormat
+{
+	sf_8bit_signed,
+	sf_16bit_signed
+};
+
+#endif

Added: trunk/clanlib/API/Sound/soundoutput.h
===================================================================
--- trunk/clanlib/API/Sound/soundoutput.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Sound/soundoutput.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,120 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSound=&quot;Audio Mixing&quot;
+//! header=sound.h
+
+#ifndef header_soundoutput
+#define header_soundoutput
+
+#ifdef CL_API_DLL
+#ifdef CL_SOUND_EXPORT
+#define CL_API_SOUND __declspec(dllexport)
+#else
+#define CL_API_SOUND __declspec(dllimport)
+#endif
+#else
+#define CL_API_SOUND
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+
+class CL_SoundFilter;
+class CL_SoundBuffer;
+class CL_SoundOutput_Description;
+class CL_SoundOutput_Generic;
+
+//: SoundOutput interface in ClanLib.
+//- !group=Sound/Audio Mixing!
+//- !header=sound.h!
+//- &lt;p&gt;CL_SoundOutput is the interface to a sound output device. It is used to
+//- control the main mixer volume and other global settings.&lt;/p&gt;
+class CL_API_SOUND CL_SoundOutput
+{
+//! Construction:
+public:
+	//: Constructs a sound output object.
+	CL_SoundOutput();
+
+	CL_SoundOutput(int mixing_frequency);
+
+	CL_SoundOutput(const CL_SoundOutput_Description &amp;desc);
+
+	CL_SoundOutput(const CL_SoundOutput &amp;copy);
+
+	virtual ~CL_SoundOutput();
+
+//! Attributes:
+public:
+	//: Name of the output device.
+	const std::string &amp;get_name() const;
+
+	//: Returns the mixing frequency for the sound output device.
+	int get_mixing_frequency() const;
+
+	//: Returns the main volume of the sound output.
+	float get_global_volume() const;
+
+	//: Returns the main panning position of the sound output.
+	float get_global_pan() const;
+
+//! Operations:
+public:
+	//: Copy assignment operator.
+	CL_SoundOutput &amp;operator =(const CL_SoundOutput &amp;copy);
+
+	//: Stops all sample playbacks on the sound output.
+	void stop_all();
+	
+	//: Sets the main/mixer volume on the sound output.
+	void set_global_volume(float volume);
+
+	//: Sets the main panning position on the sound output.
+	void set_global_pan(float pan);
+
+	//: Adds the sound filter to the sound output.
+	//param filter: Sound filter to pass sound through.
+	//param delete_filter: If true, the filter will be deleted when the sound output is destroyed.
+	void add_filter(CL_SoundFilter *filter, bool delete_filter = false);
+
+	//: Remove the sound filter from the session.
+	void remove_filter(CL_SoundFilter *filter);
+
+//! Implementation:
+private:
+	CL_SoundOutput_Generic *impl;
+
+	friend class CL_SoundBuffer;
+};
+
+#endif

Added: trunk/clanlib/API/Sound/soundoutput_description.h
===================================================================
--- trunk/clanlib/API/Sound/soundoutput_description.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Sound/soundoutput_description.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,84 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSound=&quot;Audio Mixing&quot;
+//! header=sound.h
+
+#ifndef header_soundoutput_description
+#define header_soundoutput_description
+
+#ifdef CL_API_DLL
+#ifdef CL_SOUND_EXPORT
+#define CL_API_SOUND __declspec(dllexport)
+#else
+#define CL_API_SOUND __declspec(dllimport)
+#endif
+#else
+#define CL_API_SOUND
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+class CL_SoundOutput_Description_Generic;
+
+//: Sound output description class.
+//- !group=Sound/Audio Mixing!
+//- !header=sound.h!
+class CL_API_SOUND CL_SoundOutput_Description
+{
+//! Construction:
+public:
+	//: Constructs a sound output description.
+	CL_SoundOutput_Description();
+
+	CL_SoundOutput_Description(const CL_SoundOutput_Description &amp;copy);
+
+	~CL_SoundOutput_Description();
+
+//! Attributes:
+public:
+	//: Returns the mixing frequency for the sound output device.
+	int get_mixing_frequency() const;
+
+//! Operations:
+public:
+	//: Copy assignment operator.
+	CL_SoundOutput_Description &amp;operator =(const CL_SoundOutput_Description &amp;copy);
+
+	//: Sets the mixing frequency for the sound output device.
+	void set_mixing_frequency(int frequency);
+
+//! Implementation:
+private:
+	CL_SoundOutput_Description_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/Sound/soundprovider.h
===================================================================
--- trunk/clanlib/API/Sound/soundprovider.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Sound/soundprovider.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,86 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSound=&quot;Audio Mixing&quot;
+//! header=sound.h
+
+#ifndef header_soundprovider
+#define header_soundprovider
+
+#ifdef CL_API_DLL
+#ifdef CL_SOUND_EXPORT
+#define CL_API_SOUND __declspec(dllexport)
+#else
+#define CL_API_SOUND __declspec(dllimport)
+#endif
+#else
+#define CL_API_SOUND
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Core/System/mutexsharedptr.h&quot;
+
+class CL_SoundProvider_Session;
+class CL_SoundProvider_Generic;
+
+//: Sound provider.
+//- !group=Sound/Audio Mixing!
+//- !header=sound.h!
+//- &lt;p&gt;Interface to sound sources. Used by the CL_SoundBuffer class to
+//- start and stop playback.&lt;/p&gt;
+class CL_API_SOUND CL_SoundProvider
+{
+//! Construction:
+public:
+	CL_SoundProvider();
+
+	CL_SoundProvider(const CL_SoundProvider &amp;copy);
+
+	virtual ~CL_SoundProvider();
+
+//! Operations:
+public:
+	//: Called by CL_SoundBuffer when a new session starts.
+	//return: The soundbuffer session to be attached to the newly started session.
+	virtual CL_SoundProvider_Session *begin_session() = 0;
+
+	//: Called by CL_SoundBuffer when a session has finished. After this call,
+	//- &lt;p&gt;CL_SoundBuffer will not access the session anymore. It can safely be deleted
+	//- here (and in most cases should be delete here).&lt;/p&gt;
+	virtual void end_session(CL_SoundProvider_Session *session) = 0;
+
+//! Implementation:
+private:
+	CL_MutexSharedPtr&lt;CL_SoundProvider_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/Sound/soundprovider_session.h
===================================================================
--- trunk/clanlib/API/Sound/soundprovider_session.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Sound/soundprovider_session.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,122 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanSound=&quot;Audio Mixing&quot;
+//! header=sound.h
+
+#ifndef header_soundprovider_session
+#define header_soundprovider_session
+
+#ifdef CL_API_DLL
+#ifdef CL_SOUND_EXPORT
+#define CL_API_SOUND __declspec(dllexport)
+#else
+#define CL_API_SOUND __declspec(dllimport)
+#endif
+#else
+#define CL_API_SOUND
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Core/System/mutexsharedptr.h&quot;
+#include &quot;soundformat.h&quot;
+
+class CL_SoundProvider_Session_Generic;
+
+//: Sound provider playback session.
+//- !group=Sound/Audio Mixing!
+//- !header=sound.h!
+//- &lt;p&gt;Interface used by ClanLib during playback of sound providers.&lt;/p&gt;
+class CL_API_SOUND CL_SoundProvider_Session
+{
+//! Construction:
+public:
+	CL_SoundProvider_Session();
+
+	CL_SoundProvider_Session(const CL_SoundProvider_Session &amp;copy);
+
+	virtual ~CL_SoundProvider_Session();
+
+//! Attributes:
+public:
+	//: Returns the number of samples in the soundbuffer.
+	virtual int get_num_samples() const = 0;
+
+	//: Returns the playback frequency of the input data.
+	//return: Playback frequency.
+	virtual int get_frequency() const = 0;
+
+	//: Returns the current position in the playback stream.
+	virtual int get_position() const = 0;
+
+	//: Returns the playback sample format.
+	//return: The playback Sample format.
+	virtual CL_SoundFormat get_format() const = 0;
+
+	//: Returns the number of channels filled when get_data is called.
+	virtual int get_num_channels() const = 0;
+
+//! Operations:
+public:
+	//: Enable/disable session looping.
+	//- &lt;p&gt;If this function returns false (default), the clanSound mixer will manually
+	//- try to simulate looping by setting the position to 0 when eof is encountered.&lt;/p&gt;
+	virtual bool set_looping(bool loop) { return false; }
+
+	//: Returns true if no more input data is available.
+	//return: True if end of input data. False otherwise.
+	virtual bool eof() const = 0;
+	
+	//: Stops the current stream.
+	virtual void stop() = 0;
+
+	//: Start/continue playing of the stream.
+	//return: True for success. False otherwise.
+	virtual bool play() = 0;
+		
+	//: Sets the position within the current stream.
+	//param pos: Position to seek to.
+	//return: True for success. False otherwise.
+	virtual bool set_position(int pos) = 0;
+	
+	//: Called when a playback session needs more sample data.
+	//param data_ptr: Points to a buffer that should be filled with sample data.
+	//param data_requested: Samples of data requested.
+	//return: Number of samples actually filled with sample data.
+	virtual int get_data(void **data_ptr, int data_requested) = 0;
+
+//! Implementation:
+private:
+	CL_MutexSharedPtr&lt;CL_SoundProvider_Session_Generic&gt; impl;
+};
+
+#endif

Added: trunk/clanlib/API/Vorbis/setupvorbis.h
===================================================================
--- trunk/clanlib/API/Vorbis/setupvorbis.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Vorbis/setupvorbis.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,73 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanVorbis=&quot;System&quot;
+//! header=vorbis.h
+
+#ifndef header_setupvorbis
+#define header_setupvorbis
+
+#ifdef CL_API_DLL
+#ifdef CL_VORBIS_EXPORT
+#define CL_API_VORBIS __declspec(dllexport)
+#else
+#define CL_API_VORBIS __declspec(dllimport)
+#endif
+#else
+#define CL_API_VORBIS
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+//: ClanVorbis initialization functions
+//- !group=Vorbis/System!
+//- !header=vorbis.h!
+class CL_API_VORBIS CL_SetupVorbis
+{
+//! Construction:
+public:
+	//: Initializes clanVorbis.
+	//- &lt;p&gt;Constructing a CL_SetupVorbis object is equalent to calling CL_SetupVorbis::init().&lt;/p&gt;
+	//- &lt;p&gt;When the CL_SetupVorbis instance is destroyed, CL_SetupVorbis::deinit() is called.&lt;/p&gt;
+	CL_SetupVorbis(bool register_resources_only = false);
+
+	~CL_SetupVorbis();
+
+//! Operations:
+public:
+	//: Initialize the Vorbis library
+	static void init(bool register_resources_only = false);
+
+	//: Deinitialize the Vorbis library
+	static void deinit();
+};
+
+#endif

Added: trunk/clanlib/API/Vorbis/soundprovider_vorbis.h
===================================================================
--- trunk/clanlib/API/Vorbis/soundprovider_vorbis.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/Vorbis/soundprovider_vorbis.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,90 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanVorbis=&quot;Sound Providers&quot;
+//! header=vorbis.h
+
+#ifndef header_sound_provider_vorbis
+#define header_sound_provider_vorbis
+
+#ifdef CL_API_DLL
+#ifdef CL_VORBIS_EXPORT
+#define CL_API_VORBIS __declspec(dllexport)
+#else
+#define CL_API_VORBIS __declspec(dllimport)
+#endif
+#else
+#define CL_API_VORBIS
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Sound/soundprovider.h&quot;
+#include &lt;string&gt;
+
+class CL_InputSourceProvider;
+class CL_SoundProvider_Vorbis_Generic;
+
+//: Module format (.mod, .s3m, .xm, etc) sound provider.
+//- !group=Vorbis/Sound Providers!
+//- !header=vorbis.h!
+class CL_API_VORBIS CL_SoundProvider_Vorbis : public CL_SoundProvider
+{
+//! Construction:
+public:
+	//: Constructs a sound provider based on an ogg vorbis (.ogg) file.
+	//param filename: Filename of module file.
+	//param provider: Input source provider used to retrieve module file.
+	//param stream: If true, will stream from disk. If false, will load it to memory.
+	CL_SoundProvider_Vorbis(
+		const std::string &amp;filename,
+		CL_InputSourceProvider *provider = 0,
+		bool stream = false);
+
+	virtual ~CL_SoundProvider_Vorbis();
+
+//! Operations:
+public:
+	//: Called by CL_SoundBuffer when a new session starts.
+	//return: The soundbuffer session to be attached to the newly started session.
+	virtual CL_SoundProvider_Session *begin_session();
+
+	//: Called by CL_SoundBuffer when a session has finished. After this call,
+	//- &lt;p&gt;CL_SoundBuffer will not access the session anymore. It can safely be deleted
+	//- here (and in most cases should be delete here).&lt;/p&gt;
+	virtual void end_session(CL_SoundProvider_Session *session);
+
+//! Implementation:
+private:
+	CL_SoundProvider_Vorbis_Generic *impl;
+};
+
+#endif

Added: trunk/clanlib/API/application.h
===================================================================
--- trunk/clanlib/API/application.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/application.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,52 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//: &lt;p&gt;Application bootstrapping library. When booting your application,
+//: you can either use the low level, platform dependent approach in clanCore,
+//: or you can use the CL_ClanApplication interface in clanApp.&lt;/p&gt;
+//! Global=App
+
+#ifndef header_application
+#define header_application
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;Application/clanapp.h&quot;
+
+#if defined (_MSC_VER)
+#if !defined (_DEBUG)
+#pragma comment(lib, &quot;clanApp-static-mt.lib&quot;)
+#else
+#pragma comment(lib, &quot;clanApp-static-mt-debug.lib&quot;)
+#endif
+#endif
+
+#endif

Added: trunk/clanlib/API/core.h
===================================================================
--- trunk/clanlib/API/core.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/core.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,155 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//: &lt;p&gt;This is the heart of ClanLib. The core library contain the glue that
+//: binds all other clanlib libraries together. It contain general platform
+//: independence classes and functions. It also setup the keep alive pump and
+//: other fundamental attributes of ClanLib.&lt;/p&gt;
+//! Global=Core
+
+#ifndef header_core
+#define header_core
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#define CL_VERSION(x,y,z)	( (x &lt;&lt; 16) | (y &lt;&lt; 8) | (z) )
+#define CL_CURRENT_VERSION	CL_VERSION(0,8,0)
+#define CL_VERSION_STRING &quot;0.8.0&quot;
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4786)
+#endif
+
+#ifdef __BORLANDC__
+#define BORLAND
+#endif
+
+#include &quot;Core/core_iostream.h&quot;
+#include &quot;Core/System/cl_assert.h&quot;
+#include &quot;Core/System/command_line.h&quot;
+#include &quot;Core/System/setupcore.h&quot;
+#include &quot;Core/System/keep_alive.h&quot;
+#include &quot;Core/System/system.h&quot;
+#include &quot;Core/System/error.h&quot;
+#include &quot;Core/System/thread.h&quot;
+#include &quot;Core/System/threadfunc_v0.h&quot;
+#include &quot;Core/System/threadfunc_v1.h&quot;
+#include &quot;Core/System/threadfunc_v2.h&quot;
+#include &quot;Core/System/mutex.h&quot;
+#include &quot;Core/System/clanstring.h&quot;
+#include &quot;Core/System/timer.h&quot;
+#include &quot;Core/System/event_listener.h&quot;
+#include &quot;Core/System/event_trigger.h&quot;
+#include &quot;Core/System/console_window.h&quot;
+#include &quot;Core/System/log.h&quot;
+#include &quot;Core/System/cl_library.h&quot;
+#include &quot;Core/System/crash_reporter.h&quot;
+#include &quot;Core/System/call_stack.h&quot;
+#include &quot;Core/System/clonable.h&quot;
+#include &quot;Core/System/lazycopyptr.h&quot;
+#include &quot;Core/System/owningptr.h&quot;
+#include &quot;Core/System/sharedptr.h&quot;
+#include &quot;Core/System/weakptr.h&quot;
+#include &quot;Core/System/mutexsharedptr.h&quot;
+#include &quot;Core/System/mutexweakptr.h&quot;
+
+#include &quot;Core/IOData/datatypes.h&quot;
+#include &quot;Core/IOData/cl_endian.h&quot;
+#include &quot;Core/IOData/inputsource.h&quot;
+#include &quot;Core/IOData/inputsource_file.h&quot;
+#include &quot;Core/IOData/inputsource_memory.h&quot;
+#include &quot;Core/IOData/inputsource_provider.h&quot;
+#include &quot;Core/IOData/inputsource_provider_file.h&quot;
+#include &quot;Core/IOData/outputsource.h&quot;
+#include &quot;Core/IOData/outputsource_file.h&quot;
+#include &quot;Core/IOData/outputsource_memory.h&quot;
+#include &quot;Core/IOData/outputsource_provider.h&quot;
+#include &quot;Core/IOData/directory_scanner.h&quot;
+#include &quot;Core/IOData/directory.h&quot;
+#include &quot;Core/IOData/zip_archive.h&quot;
+#include &quot;Core/IOData/zip_file_entry.h&quot;
+
+#include &quot;Core/Resources/resource_manager.h&quot;
+#include &quot;Core/Resources/resource.h&quot;
+#include &quot;Core/Resources/resourcetype_boolean.h&quot;
+#include &quot;Core/Resources/resourcetype_integer.h&quot;
+#include &quot;Core/Resources/resourcetype_float.h&quot;
+#include &quot;Core/Resources/resourcetype_string.h&quot;
+#include &quot;Core/Resources/resourcetype_raw.h&quot;
+
+#include &quot;Core/Math/matrix4x4.h&quot;
+#include &quot;Core/Math/cl_vector.h&quot;
+#include &quot;Core/Math/vector2.h&quot;
+#include &quot;Core/Math/math.h&quot;
+#include &quot;Core/Math/line_math.h&quot;
+#include &quot;Core/Math/triangle_math.h&quot;
+#include &quot;Core/Math/rect.h&quot;
+#include &quot;Core/Math/quad.h&quot;
+#include &quot;Core/Math/size.h&quot;
+#include &quot;Core/Math/point.h&quot;
+#include &quot;Core/Math/number_pool.h&quot;
+#include &quot;Core/Math/delauney_triangulator.h&quot;
+#include &quot;Core/Math/outline_triangulator.h&quot;
+
+#include &quot;Core/XML/xml_token.h&quot;
+#include &quot;Core/XML/xml_tokenizer.h&quot;
+#include &quot;Core/XML/xml_writer.h&quot;
+#include &quot;Core/XML/dom_attr.h&quot;
+#include &quot;Core/XML/dom_cdata_section.h&quot;
+#include &quot;Core/XML/dom_character_data.h&quot;
+#include &quot;Core/XML/dom_comment.h&quot;
+#include &quot;Core/XML/dom_document.h&quot;
+#include &quot;Core/XML/dom_document_fragment.h&quot;
+#include &quot;Core/XML/dom_document_type.h&quot;
+#include &quot;Core/XML/dom_element.h&quot;
+#include &quot;Core/XML/dom_entity.h&quot;
+#include &quot;Core/XML/dom_entity_reference.h&quot;
+#include &quot;Core/XML/dom_exception.h&quot;
+#include &quot;Core/XML/dom_implementation.h&quot;
+#include &quot;Core/XML/dom_named_node_map.h&quot;
+#include &quot;Core/XML/dom_node.h&quot;
+#include &quot;Core/XML/dom_node_list.h&quot;
+#include &quot;Core/XML/dom_notation.h&quot;
+#include &quot;Core/XML/dom_processing_instruction.h&quot;
+#include &quot;Core/XML/dom_text.h&quot;
+
+#if defined (_MSC_VER)
+#if !defined (_DEBUG)
+#pragma comment(lib, &quot;clanCore-static-mt.lib&quot;)
+#pragma comment(lib, &quot;zlib-static-mt.lib&quot;)
+#else
+#pragma comment(lib, &quot;clanCore-static-mt-debug.lib&quot;)
+#pragma comment(lib, &quot;zlib-static-mt-debug.lib&quot;)
+#endif
+
+#endif
+
+#endif

Added: trunk/clanlib/API/display.h
===================================================================
--- trunk/clanlib/API/display.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/display.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,99 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//: &lt;p&gt;ClanLib display and input library. This provide you with 2D display
+//: support, and the input devices attached to that display.&lt;/p&gt;
+//! Global=Display
+
+#ifndef header_display_include
+#define header_display_include
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;Display/blend_func.h&quot;
+#include &quot;Display/color.h&quot;
+#include &quot;Display/display.h&quot;
+#include &quot;Display/display_iostream.h&quot;
+#include &quot;Display/display_mode.h&quot;
+#include &quot;Display/display_window.h&quot;
+#include &quot;Display/display_window_description.h&quot;
+#include &quot;Display/font.h&quot;
+#include &quot;Display/frameratecounter.h&quot;
+#include &quot;Display/glyph_buffer.h&quot;
+#include &quot;Display/gradient.h&quot;
+#include &quot;Display/graphic_context.h&quot;
+#include &quot;Display/input_buffer.h&quot;
+#include &quot;Display/input_button.h&quot;
+#include &quot;Display/input_context.h&quot;
+#include &quot;Display/input_device.h&quot;
+#include &quot;Display/input_event.h&quot;
+#include &quot;Display/joystick.h&quot;
+#include &quot;Display/key_binding.h&quot;
+#include &quot;Display/keyboard.h&quot;
+#include &quot;Display/keys.h&quot;
+#include &quot;Display/mouse.h&quot;
+#include &quot;Display/palette.h&quot;
+#include &quot;Display/pixel_buffer.h&quot;
+#include &quot;Display/pixel_format.h&quot;
+#include &quot;Display/pixel_format_type.h&quot;
+#include &quot;Display/rle_surface.h&quot;
+#include &quot;Display/setupdisplay.h&quot;
+#include &quot;Display/sprite.h&quot;
+#include &quot;Display/sprite_description.h&quot;
+#include &quot;Display/sprite_packer.h&quot;
+#include &quot;Display/surface.h&quot;
+#include &quot;Display/canvas.h&quot;
+#include &quot;Display/text_styler.h&quot;
+#include &quot;Display/Providers/jpeg_provider.h&quot;
+#include &quot;Display/Providers/pcx_provider.h&quot;
+#include &quot;Display/Providers/png_provider.h&quot;
+#include &quot;Display/Providers/targa_provider.h&quot;
+#include &quot;Display/Providers/provider_factory.h&quot;
+#include &quot;Display/Providers/provider_type.h&quot;
+#include &quot;Display/Collision/collision_outline.h&quot;
+#include &quot;Display/Collision/outline_accuracy.h&quot;
+
+#if defined (_MSC_VER)
+#if !defined (_DEBUG)
+#pragma comment(lib, &quot;clanDisplay-static-mt.lib&quot;)
+#pragma comment(lib, &quot;libjpeg-static-mt.lib&quot;)
+#pragma comment(lib, &quot;libpng-static-mt.lib&quot;)
+#else
+#pragma comment(lib, &quot;libjpeg-static-mt-debug.lib&quot;)
+#pragma comment(lib, &quot;clanDisplay-static-mt-debug.lib&quot;)
+#pragma comment(lib, &quot;libpng-static-mt-debug.lib&quot;)
+#endif
+#pragma comment(lib, &quot;winmm.lib&quot;)
+#pragma comment(lib, &quot;dinput.lib&quot;)
+#pragma comment(lib, &quot;dxguid.lib&quot;)
+#endif
+
+#endif

Added: trunk/clanlib/API/efence.h
===================================================================
--- trunk/clanlib/API/efence.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/efence.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,62 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**
+**  Electric fence, C++ enable code.
+**
+**  If you need to test for buffer overruns, add -lefence to your linking
+**  and include this header in one of your sourcefiles.
+*/
+
+#ifndef header_efence
+#define header_efence
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifndef WIN32
+
+#include &lt;stdlib.h&gt;
+
+void *operator new(size_t size)
+{
+	return malloc(size);
+}
+
+void operator delete(void *ptr)
+{
+	free(ptr);
+}
+
+void operator delete[](void *ptr)
+{
+	free(ptr);
+}
+
+#endif
+
+#endif

Added: trunk/clanlib/API/gl.h
===================================================================
--- trunk/clanlib/API/gl.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/gl.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,83 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//: &lt;p&gt;ClanLib OpenGL support. Contains OpenGL binding code and 3D helper
+//: frameworks.&lt;/p&gt;
+//! Global=GL
+
+#ifndef header_gl
+#define header_gl
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+	#pragma warning (disable:4786)
+#endif
+
+#ifdef WIN32
+	#include &lt;windows.h&gt;
+#endif
+
+#ifdef __APPLE__
+#include &lt;OpenGL/gl.h&gt;
+#include &lt;OpenGL/glu.h&gt;
+#else
+#include &lt;GL/gl.h&gt;
+#include &lt;GL/glu.h&gt;
+#endif
+
+#include &quot;GL/setupgl.h&quot;
+#include &quot;GL/opengl.h&quot;
+#include &quot;GL/opengl_window.h&quot;
+#include &quot;GL/opengl_window_description.h&quot;
+#include &quot;GL/opengl_surface.h&quot;
+#include &quot;GL/opengl_state.h&quot;
+#include &quot;GL/opengl_state_data.h&quot;
+#include &quot;GL/opengl_wrap.h&quot;
+#include &quot;GL/viewpoint.h&quot;
+#include &quot;GL/light_source.h&quot;
+#include &quot;GL/shader_object.h&quot;
+#include &quot;GL/program_object.h&quot;
+#include &quot;GL/program_uniform.h&quot;
+#include &quot;GL/program_attribute.h&quot;
+#include &quot;GL/texture.h&quot;
+
+#if defined (_MSC_VER)
+#if !defined (_DEBUG)
+#pragma comment(lib, &quot;clanGL-static-mt.lib&quot;)
+#else
+#pragma comment(lib, &quot;clanGL-static-mt-debug.lib&quot;)
+#endif
+#pragma comment(lib, &quot;OpenGL32.lib&quot;)
+#pragma comment(lib, &quot;GLU32.lib&quot;)
+#endif
+
+#endif

Added: trunk/clanlib/API/gui.h
===================================================================
--- trunk/clanlib/API/gui.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/gui.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,97 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//: &lt;p&gt;Graphical User Interface API. Provides a themeable and very flexible GUI
+//: framework.&lt;/p&gt;
+//! Global=GUI
+
+#ifndef header_gui
+#define header_gui
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4786)
+#endif
+
+// Framework
+#include &quot;GUI/component.h&quot;
+#include &quot;GUI/component_manager.h&quot;
+#include &quot;GUI/component_type.h&quot;
+#include &quot;GUI/component_move_handler.h&quot;
+#include &quot;GUI/component_resize_handler.h&quot;
+#include &quot;GUI/component_style.h&quot;
+#include &quot;GUI/gui_manager.h&quot;
+#include &quot;GUI/setupgui.h&quot;
+#include &quot;GUI/stylemanager.h&quot;
+#include &quot;GUI/layout.h&quot;
+#include &quot;GUI/deck.h&quot;
+
+// Components
+#include &quot;GUI/button.h&quot;
+#include &quot;GUI/checkbox.h&quot;
+#include &quot;GUI/frame.h&quot;
+#include &quot;GUI/image.h&quot;
+#include &quot;GUI/inputbox.h&quot;
+#include &quot;GUI/label.h&quot;
+#include &quot;GUI/listbox.h&quot;
+#include &quot;GUI/listitem.h&quot;
+#include &quot;GUI/progressbar.h&quot;
+#include &quot;GUI/radiobutton.h&quot;
+#include &quot;GUI/radiogroup.h&quot;
+#include &quot;GUI/scrollbar.h&quot;
+#include &quot;GUI/treeview.h&quot;
+#include &quot;GUI/treeitem.h&quot;
+#include &quot;GUI/treenode.h&quot;
+#include &quot;GUI/window.h&quot;
+#include &quot;GUI/menu.h&quot;
+#include &quot;GUI/menu_node.h&quot;
+#include &quot;GUI/menu_item.h&quot;
+
+// Dialogs
+#include &quot;GUI/messagebox.h&quot;
+#include &quot;GUI/filedialog.h&quot;
+#include &quot;GUI/inputdialog.h&quot;
+
+#if defined (_MSC_VER)
+#if !defined (CL_GUI_EXPORT)		
+// Test CL_GUI_EXPORT to prevent recursive linker refs
+// see menu.cpp, menu_generic.cpp, menu_node_generic.h 
+// for the offending #includes
+#if !defined (_DEBUG)
+#pragma comment(lib, &quot;clanGUI-static-mt.lib&quot;)
+#else
+#pragma comment(lib, &quot;clanGUI-static-mt-debug.lib&quot;)
+#endif
+#endif
+#endif
+
+#endif

Added: trunk/clanlib/API/guistylesilver.h
===================================================================
--- trunk/clanlib/API/guistylesilver.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/guistylesilver.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,75 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//: &lt;p&gt;Graphical User Interface API. Provides a themeable and very flexible GUI
+//: framework.&lt;/p&gt;
+//! Global=GUI
+
+#ifndef header_guistylesilver
+#define header_guistylesilver
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4786)
+#endif
+
+#include &quot;GUIStyleSilver/stylemanager_silver.h&quot;
+#include &quot;GUIStyleSilver/button_silver.h&quot;
+#include &quot;GUIStyleSilver/checkbox_silver.h&quot;
+#include &quot;GUIStyleSilver/frame_silver.h&quot;
+#include &quot;GUIStyleSilver/image_silver.h&quot;
+#include &quot;GUIStyleSilver/inputbox_silver.h&quot;
+#include &quot;GUIStyleSilver/label_silver.h&quot;
+#include &quot;GUIStyleSilver/listbox_silver.h&quot;
+#include &quot;GUIStyleSilver/progressbar_silver.h&quot;
+#include &quot;GUIStyleSilver/radiobutton_silver.h&quot;
+#include &quot;GUIStyleSilver/scrollbar_silver.h&quot;
+#include &quot;GUIStyleSilver/window_silver.h&quot;
+#include &quot;GUIStyleSilver/menu_silver.h&quot;
+#include &quot;GUIStyleSilver/menu_node_silver.h&quot;
+#include &quot;GUIStyleSilver/menu_item_silver.h&quot;
+#include &quot;GUIStyleSilver/treeview_silver.h&quot;
+#include &quot;GUIStyleSilver/treeitem_silver.h&quot;
+
+#if defined (_MSC_VER)
+#if !defined (CL_GUISTYLESILVER_EXPORT)
+// Test CL_GUISTYLESILVER_EXPORT to prevent recursive linker refs
+// see notes in clanGUI/gui.h
+#if !defined (_DEBUG)
+#pragma comment(lib, &quot;clanGUIStyleSilver-static-mt.lib&quot;)
+#else
+#pragma comment(lib, &quot;clanGUIStyleSilver-static-mt-debug.lib&quot;)
+#endif
+#endif
+#endif
+
+#endif

Added: trunk/clanlib/API/mikmod.h
===================================================================
--- trunk/clanlib/API/mikmod.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/mikmod.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,58 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//: &lt;p&gt;MikMod module playback support. Supports all the module formats of
+//: MikMod, which includes MOD, XM, S3M, IT and more.&lt;/p&gt;
+//! Global=MikMod
+
+#ifndef header_mikmod
+#define header_mikmod
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef WIN32
+#pragma warning( disable : 4786)
+#endif
+
+#include &quot;MikMod/setupmikmod.h&quot;
+#include &quot;MikMod/soundprovider_mikmod.h&quot;
+
+#if defined (_MSC_VER)
+#if !defined (_DEBUG)
+#pragma comment(lib, &quot;clanMikMod-static-mt.lib&quot;)
+#pragma comment(lib, &quot;mikmod-static-mt.lib&quot;)
+#else
+#pragma comment(lib, &quot;clanMikMod-static-mt-debug.lib&quot;)
+#pragma comment(lib, &quot;mikmod-static-mt-debug.lib&quot;)
+#endif
+#endif
+
+#endif

Added: trunk/clanlib/API/network.h
===================================================================
--- trunk/clanlib/API/network.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/network.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,81 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//: &lt;p&gt;Enables network communication.  Includes low-lever socket access as well
+//: as higher-level network objects.&lt;/p&gt;
+//! Global=Network
+
+#ifndef header_network_api
+#define header_network_api
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef WIN32
+#pragma warning( disable : 4786)
+#endif
+
+#include &quot;Network/IRC/irc_connection.h&quot;
+#include &quot;Network/IRC/irc_numerics.h&quot;
+#include &quot;Network/IRC/dcc_download.h&quot;
+
+#include &quot;Network/NetVariables/netvariables.h&quot;
+
+#include &quot;Network/NetObjects/netobject_client.h&quot;
+#include &quot;Network/NetObjects/netobject_controller.h&quot;
+#include &quot;Network/NetObjects/netobject_server.h&quot;
+
+#include &quot;Network/NetSession/inputsource_netpacket.h&quot;
+#include &quot;Network/NetSession/inputsource_netstream.h&quot;
+#include &quot;Network/NetSession/netcomputer.h&quot;
+#include &quot;Network/NetSession/netgroup.h&quot;
+#include &quot;Network/NetSession/netpacket.h&quot;
+#include &quot;Network/NetSession/netsession.h&quot;
+#include &quot;Network/NetSession/netstream.h&quot;
+#include &quot;Network/NetSession/outputsource_netpacket.h&quot;
+#include &quot;Network/NetSession/outputsource_netstream.h&quot;
+
+#include &quot;Network/Socket/inputsource_socket.h&quot;
+#include &quot;Network/Socket/ip_address.h&quot;
+#include &quot;Network/Socket/outputsource_socket.h&quot;
+#include &quot;Network/Socket/socket.h&quot;
+
+#include &quot;Network/setupnetwork.h&quot;
+
+#if defined (_MSC_VER)
+#if !defined (_DEBUG)
+#pragma comment(lib, &quot;clanNetwork-static-mt.lib&quot;)
+#else
+#pragma comment(lib, &quot;clanNetwork-static-mt-debug.lib&quot;)
+#endif
+#pragma comment(lib, &quot;ws2_32.lib&quot;)
+#endif
+
+#endif

Added: trunk/clanlib/API/sdl.h
===================================================================
--- trunk/clanlib/API/sdl.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/sdl.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,60 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//: &lt;p&gt;ClanLib SDL support. Contains SDL binding code and SDL integration
+//: frameworks.&lt;/p&gt;
+//! Global=SDL
+
+#ifndef header_sdl
+#define header_sdl
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef WIN32
+	#pragma warning (disable:4786)
+	#include &lt;windows.h&gt;
+#endif
+
+#include &quot;SDL/setupsdl.h&quot;
+
+#if defined (_MSC_VER)
+#if !defined (_DEBUG)
+#pragma comment(lib, &quot;clanSDL-static-mt.lib&quot;)
+#pragma comment(lib, &quot;SDL-static-mt.lib&quot;)
+#pragma comment(lib, &quot;sdlgfx-static-mt.lib&quot;)
+#else
+#pragma comment(lib, &quot;clanSDL-static-mt-debug.lib&quot;)
+#pragma comment(lib, &quot;SDL-static-mt-debug.lib&quot;)
+#pragma comment(lib, &quot;sdlgfx-static-mt-debug.lib&quot;)
+#endif
+#endif
+
+#endif

Added: trunk/clanlib/API/signals.h
===================================================================
--- trunk/clanlib/API/signals.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/signals.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,67 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//: &lt;p&gt;ClanLib signal system. Signals is an other word for callback functions. A
+//: C++ signal library provides a typecast clean interface to allow for
+//: callbacks to be called, without doing nasty pointer casts all the time. You
+//: can use this library totally independent of the rest of clanlib, if you
+//: want (as soon as you've learned about signals, you will love them - trust me).&lt;/p&gt;
+//! Global=Signal
+
+#ifndef header_signals
+#define header_signals
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4786)
+#endif
+
+#include &quot;Signals/slot.h&quot;
+#include &quot;Signals/signal_v0.h&quot;
+#include &quot;Signals/signal_v1.h&quot;
+#include &quot;Signals/signal_v2.h&quot;
+#include &quot;Signals/signal_v3.h&quot;
+#include &quot;Signals/signal_v4.h&quot;
+#include &quot;Signals/signal_v5.h&quot;
+#include &quot;Signals/slotbuffer_v0.h&quot;
+#include &quot;Signals/slotbuffer_v1.h&quot;
+#include &quot;Signals/slot_container.h&quot;
+
+#if defined (_MSC_VER)
+#if !defined (_DEBUG)
+#pragma comment(lib, &quot;clanSignals-static-mt.lib&quot;)
+#else
+#pragma comment(lib, &quot;clanSignals-static-mt-debug.lib&quot;)
+#endif
+#endif
+
+#endif

Added: trunk/clanlib/API/sound.h
===================================================================
--- trunk/clanlib/API/sound.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/sound.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,76 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//: &lt;p&gt;Sound support. If you want sound in your application, you defiantly
+//: want to link to this library.&lt;/p&gt;
+//! Global=Sound
+
+#ifndef header_sound_api
+#define header_sound_api
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4786)
+#endif
+
+#include &quot;Sound/setupsound.h&quot;
+#include &quot;Sound/sound.h&quot;
+#include &quot;Sound/soundoutput.h&quot;
+#include &quot;Sound/soundoutput_description.h&quot;
+#include &quot;Sound/soundformat.h&quot;
+#include &quot;Sound/soundprovider.h&quot;
+#include &quot;Sound/soundprovider_session.h&quot;
+#include &quot;Sound/soundbuffer.h&quot;
+#include &quot;Sound/soundbuffer_session.h&quot;
+#include &quot;Sound/soundfilter.h&quot;
+#include &quot;Sound/cd_drive.h&quot;
+
+#include &quot;Sound/SoundProviders/soundprovider_wave.h&quot;
+#include &quot;Sound/SoundProviders/soundprovider_raw.h&quot;
+#include &quot;Sound/SoundProviders/soundprovider_recorder.h&quot;
+
+#include &quot;Sound/SoundFilters/echofilter.h&quot;
+#include &quot;Sound/SoundFilters/inverse_echofilter.h&quot;
+#include &quot;Sound/SoundFilters/fadefilter.h&quot;
+
+#if defined (_MSC_VER)
+#if !defined (_DEBUG)
+#pragma comment(lib, &quot;clanSound-static-mt.lib&quot;)
+#else
+#pragma comment(lib, &quot;clanSound-static-mt-debug.lib&quot;)
+#endif
+#pragma comment(lib, &quot;dsound.lib&quot;)
+#pragma comment(lib, &quot;dxguid.lib&quot;)
+#pragma comment(lib, &quot;winmm.lib&quot;)
+#endif
+
+#endif

Added: trunk/clanlib/API/vorbis.h
===================================================================
--- trunk/clanlib/API/vorbis.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/API/vorbis.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,62 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//: &lt;p&gt;Ogg Vorbis playback. With this library, you can play music with the same
+//: quality as todays mp3, but with a completely open sound format (mp3 is
+//: patented by some greedy companies that want money for each mp3 you use in a
+//: commercial product).&lt;/p&gt;
+//! Global=Vorbis
+
+#ifndef header_vorbis
+#define header_vorbis
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4786)
+#endif
+
+#include &quot;Vorbis/soundprovider_vorbis.h&quot;
+#include &quot;Vorbis/setupvorbis.h&quot;
+
+#if defined (_MSC_VER)
+#if !defined (_DEBUG)
+#pragma comment(lib, &quot;clanVorbis-static-mt.lib&quot;)
+#pragma comment(lib, &quot;libvorbis-static-mt.lib&quot;)
+#pragma comment(lib, &quot;libogg-static-mt.lib&quot;)
+#else
+#pragma comment(lib, &quot;clanVorbis-static-mt-debug.lib&quot;)
+#pragma comment(lib, &quot;libvorbis-static-mt-debug.lib&quot;)
+#pragma comment(lib, &quot;libogg-static-mt-debug.lib&quot;)
+#endif
+#endif
+
+#endif

Added: trunk/clanlib/Application/MacOS/clanapp.cpp
===================================================================
--- trunk/clanlib/Application/MacOS/clanapp.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Application/MacOS/clanapp.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,75 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+*/
+
+#include &lt;cstdlib&gt;
+#include &lt;iostream&gt;
+#include &quot;API/Core/System/setupcore.h&quot;
+#include &quot;API/Application/clanapp.h&quot;
+#include &lt;Carbon/carbon.h&gt;
+
+int main(int argc, char **argv)
+{
+	
+	if (CL_ClanApplication::app == NULL)
+	{
+		std::cout &lt;&lt; &quot;ClanLib: No global CL_ClanApplication instance!!!&quot; &lt;&lt; std::endl;
+		return 255;
+	}
+	
+	// this code will set the startup working directory to the
+	// application bundle's Resources folder instead of whatever it was, (which
+	// is usually set to something somewhat unhelpful by default).  -- SMH nov 01 2005 
+	// (converted to be here from inputsource_file.cpp -- mrfun may 18 2006)
+	
+	char cwd[PATH_MAX+2];
+	CFURLRef ref = CFBundleCopyResourcesDirectoryURL(CFBundleGetMainBundle());
+	if (ref &amp;&amp; CFURLGetFileSystemRepresentation(ref, true, (UInt8*)cwd, PATH_MAX))
+	{
+		CFRelease(ref);
+		chdir(cwd); //move to this apps Resources folder
+	}
+	
+	CL_SetupCore::init();
+
+	int retval = CL_ClanApplication::app-&gt;main(argc, argv);
+	CL_SetupCore::deinit();
+
+	return retval;
+}
+
+CL_ClanApplication *CL_ClanApplication::app = NULL;
+
+CL_ClanApplication::CL_ClanApplication()
+{
+	CL_ClanApplication::app = this;
+}
+
+CL_ClanApplication::~CL_ClanApplication()
+{
+	CL_ClanApplication::app = NULL;
+}

Added: trunk/clanlib/Application/Makefile.am
===================================================================
--- trunk/clanlib/Application/Makefile.am	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Application/Makefile.am	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,13 @@
+lib_LTLIBRARIES = libclanApp.la
+
+if WIN32
+libclanApp_la_SOURCES = Win32/clanapp.cpp
+else
+libclanApp_la_SOURCES = Unix/clanapp.cpp
+endif
+
+libclanApp_la_LDFLAGS = \
+  -release $(LT_RELEASE) \
+  -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE)
+
+# EOF #

Added: trunk/clanlib/Application/Unix/clanapp.cpp
===================================================================
--- trunk/clanlib/Application/Unix/clanapp.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Application/Unix/clanapp.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,67 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &lt;cstdlib&gt;
+#include &lt;iostream&gt;
+#include &quot;API/Core/System/setupcore.h&quot;
+#include &quot;API/Application/clanapp.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// main:
+
+int main(int argc, char **argv)
+{
+	if (CL_ClanApplication::app == NULL)
+	{
+		std::cout &lt;&lt; &quot;ClanLib: No global CL_ClanApplication instance!!!&quot; &lt;&lt; std::endl;
+		return 255;
+	}
+
+	CL_SetupCore::init();
+	int retval = CL_ClanApplication::app-&gt;main(argc, argv);
+	CL_SetupCore::deinit();
+
+	return retval;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ClanApplication:
+
+CL_ClanApplication *CL_ClanApplication::app = NULL;
+
+CL_ClanApplication::CL_ClanApplication()
+{
+	CL_ClanApplication::app = this;
+}
+
+CL_ClanApplication::~CL_ClanApplication()
+{
+	CL_ClanApplication::app = NULL;
+}

Added: trunk/clanlib/Application/Win32/clanapp.cpp
===================================================================
--- trunk/clanlib/Application/Win32/clanapp.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Application/Win32/clanapp.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,160 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &lt;ctype.h&gt;
+#include &lt;windows.h&gt;
+#include &lt;vector&gt;
+#include &quot;API/Core/System/setupcore.h&quot;
+#include &quot;API/Core/System/crash_reporter.h&quot;
+#include &quot;API/Application/clanapp.h&quot;
+
+#ifdef _MSC_VER
+#include &lt;crtdbg.h&gt;
+#endif
+
+static void calc_commandline(int *argc, char ***argv);
+
+/////////////////////////////////////////////////////////////////////////////
+// WinMain:
+
+int WINAPI WinMain(
+	HINSTANCE hInstance,
+	HINSTANCE hPrevInstance,
+	LPSTR lpCmdLine,
+	int nCmdShow)
+{
+	int retval;
+	int argc;
+	char **argv;
+
+#if defined(_DEBUG) &amp;&amp; defined(_MSC_VER)
+	// Visual C++ memoryleak debugging. By setting the _CRTDBG_LEAK_CHECK_DF
+	// flag, we produce a memory leak dump at exit in the visual c++ debug output
+	// window.
+//	int flag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
+//	flag |= _CRTDBG_LEAK_CHECK_DF;
+//	_CrtSetDbgFlag(flag);
+#endif
+
+	// Did the game developer remember to create one global application
+	// interface?
+	if (CL_ClanApplication::app == NULL)
+	{
+		MessageBox(NULL, &quot;No program instance found&quot;, &quot;ClanLib/Win32&quot;, 32);
+		return 0;
+	}
+
+#ifndef _DEBUG
+	// Create minidumps when not in debug mode.
+	CL_CrashReporter crash_reporter;
+#endif
+
+	// Get commandline arguments.
+	calc_commandline(&amp;argc, &amp;argv);
+
+	// Initialize clanlib and call clanapp main:
+	CL_SetupCore::set_instance(hInstance);
+	CL_SetupCore::init();
+	retval = CL_ClanApplication::app-&gt;main(argc, argv);
+	CL_SetupCore::deinit();
+
+	// calc_commandline() doesn't clean up after itself. tsk tsk:
+	delete[] argv;
+
+	return retval;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// calc_commandline:
+
+static void calc_commandline(int *argc, char ***argv)
+{
+	char *command_line = GetCommandLine();
+	static std::vector&lt;char *&gt; pos;
+	bool new_arg = true;
+
+	for (;*command_line;command_line++) 
+	{
+		if (*command_line == '&quot;')
+		{
+			new_arg = true;
+			command_line++;
+			char *start_arg = command_line;
+			for (;*command_line &amp;&amp; *command_line!='&quot;';command_line++)
+			{
+				if (!isspace(*command_line)) new_arg = false;
+			}
+			if (new_arg == false) pos.push_back(start_arg);
+			if (*command_line == '&quot;') *command_line = 0;
+			else if (*command_line == 0) break;
+			command_line++;
+			if (*command_line == 0) break;
+			new_arg = true;
+		}
+		
+		if (new_arg &amp;&amp; !isspace(*command_line))
+		{
+			new_arg = false;
+			pos.push_back(command_line);
+		}
+		else if (!new_arg &amp;&amp; isspace(*command_line))
+		{
+			new_arg = true;
+			*command_line = 0;
+		}
+	}
+	int num_words = pos.size();
+
+	char **words = new char*[num_words + 1];
+
+	int i;
+	for (i=0; i&lt;num_words; i++)
+	{
+		words[i] = pos[i];
+	}
+	words[i] = NULL;
+
+	*argc = num_words;
+	*argv = words;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ClanApplication:
+
+CL_ClanApplication *CL_ClanApplication::app = NULL;
+
+CL_ClanApplication::CL_ClanApplication()
+{
+	CL_ClanApplication::app = this;
+}
+
+CL_ClanApplication::~CL_ClanApplication()
+{
+	CL_ClanApplication::app = NULL;
+}

Added: trunk/clanlib/ClanLib
===================================================================
--- trunk/clanlib/ClanLib	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/ClanLib	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1 @@
+link API/
\ No newline at end of file


Property changes on: trunk/clanlib/ClanLib
___________________________________________________________________
Name: svn:special
   + *

Added: trunk/clanlib/Core/IOData/Generic/datafile_inputprovider.cpp
===================================================================
--- trunk/clanlib/Core/IOData/Generic/datafile_inputprovider.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/Generic/datafile_inputprovider.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,346 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;datafile_inputprovider.h&quot;
+#include &quot;API/Core/System/cl_assert.h&quot;
+
+#ifndef WIN32
+#include &lt;unistd.h&gt;
+#else
+#include &lt;io.h&gt;
+#endif
+
+#include &lt;fcntl.h&gt;
+
+#ifdef WIN32
+	#define OPENFLAGS O_RDONLY|O_BINARY
+#else
+	#define OPENFLAGS O_RDONLY
+#endif
+
+char datafile_id[]=&quot;ClanSoft datafile version 4.0&quot;;
+
+CL_InputSourceProvider *CL_InputSourceProvider::create_datafile_provider(const std::string &amp;filename)
+{
+	return new CL_InputSourceProvider_Datafile(filename);
+}
+
+CL_InputSourceProvider_Datafile::CL_InputSourceProvider_Datafile(const std::string &amp;_datafile) : resource_cache(NULL), datafile_handle(-1)
+{
+	datafile = _datafile;
+	open();
+	load_resource_ids();
+}
+
+CL_InputSourceProvider_Datafile::CL_InputSourceProvider_Datafile(CL_InputSourceProvider_Datafile *other)
+{
+	datafile = other-&gt;datafile;
+	resource_cache = other-&gt;resource_cache;
+	resource_cache-&gt;addref();
+	datafile_handle = dup(other-&gt;datafile_handle);
+}
+
+CL_InputSourceProvider_Datafile::~CL_InputSourceProvider_Datafile()
+{
+	if (resource_cache != NULL) 
+		resource_cache-&gt;release();
+	if (datafile_handle != -1)
+		::close(datafile_handle);
+}
+
+CL_InputSource *CL_InputSourceProvider_Datafile::open_source(const std::string &amp;filename)
+{
+	if (datafile_handle == -1)
+		open();
+
+	return new CL_InputSource_Datafile(filename, this);
+}
+
+CL_InputSourceProvider *CL_InputSourceProvider_Datafile::clone()
+{
+	return new CL_InputSourceProvider_Datafile(this);
+}
+
+void CL_InputSourceProvider_Datafile::open()
+{
+	datafile_handle = ::open(datafile.c_str(), OPENFLAGS);
+
+	if (datafile_handle == -1)
+	{
+		std::string err = std::string(&quot;Could not open datafile &quot;) + datafile;
+		throw CL_Error(err);
+	}
+
+	int id_len = strlen(datafile_id);
+
+	char *temp = new char[id_len+1];
+
+	::read(datafile_handle, temp, id_len);
+
+	temp[id_len] = 0;
+
+	if (strcmp(temp, datafile_id) != 0)
+	{
+		::close(datafile_handle);
+		datafile_handle = -1;
+		delete[] temp;
+
+		throw CL_Error(&quot;Invalid datafile format&quot;);
+	}
+
+	delete[] temp;
+}
+
+void CL_InputSourceProvider_Datafile::load_resource_ids()
+{
+	resource_cache = new IndexLocationCache;
+
+	lseek(datafile_handle, strlen(datafile_id), SEEK_SET);	// Skip file ID
+	int index_pos;
+	::read(datafile_handle, &amp;index_pos, sizeof(int));
+	lseek(datafile_handle, index_pos, SEEK_SET);
+
+	int num_indexes = 0;
+	::read(datafile_handle, &amp;num_indexes, sizeof(int));
+	for (int i=0; i&lt;num_indexes; i++)
+	{
+		short length;
+		::read(datafile_handle, &amp;length,sizeof(short));
+
+		char *objname = new char[length];
+		int objpos;
+		int objsize;
+
+		::read(datafile_handle, objname, length);
+		::read(datafile_handle, &amp;objpos, sizeof(int));
+		::read(datafile_handle, &amp;objsize, sizeof(int));
+
+		resource_cache-&gt;insert(objname, objpos, objsize);
+
+		delete[] objname;
+	}
+}
+
+std::string CL_InputSourceProvider_Datafile::get_pathname(const std::string &amp;filename)
+{
+	return filename;
+}
+
+CL_InputSourceProvider *CL_InputSourceProvider_Datafile::create_relative(const std::string &amp;path)
+{
+	return clone();
+}
+
+
+/**************************
+	CL_InputSource_Datafile
+**************************/
+
+CL_InputSource_Datafile::CL_InputSource_Datafile(
+	const std::string &amp;filename,
+	CL_InputSourceProvider_Datafile *provider) : filename(filename), provider(provider), index_open(0)
+{
+	open();
+}
+
+CL_InputSource_Datafile::CL_InputSource_Datafile(const CL_InputSource_Datafile *source)
+{
+	filename = source-&gt;filename;
+	provider = source-&gt;provider;
+	index_open = 0;
+
+	open();
+}
+
+CL_InputSource_Datafile::~CL_InputSource_Datafile()
+{
+	close();
+}
+
+int CL_InputSource_Datafile::read(void *addr, int size)
+{
+	if (compressed)
+	{
+		int svar = gzread(gzfile, addr, size);
+		seek_pos += svar;
+		return svar;
+	}
+	else
+	{
+		if (seek_pos + size &gt; objsize) size = objsize - seek_pos;
+		int svar = ::read(datafile_handle, addr, size);
+		seek_pos += svar;
+		return svar;
+	}
+}
+
+void CL_InputSource_Datafile::open()
+{
+	if (index_open)
+		close();
+
+	int pos, size;
+	if (provider-&gt;lookup_resource(filename, pos, size))
+	{
+		datafile_handle = dup(provider-&gt;get_handle());
+		lseek(datafile_handle, pos, SEEK_SET);
+
+		size--;
+		::read(datafile_handle, &amp;compressed, sizeof(char));
+
+		if (compressed) gzfile = gzdopen(datafile_handle, &quot;rb&quot;);
+		index_open = 1;
+		seek_pos = 0;
+		objsize = size;
+		index_pos = pos+1;
+	}
+	else
+	{
+		std::string err(&quot;ClanLib: Couldn't find datafile index: &quot;);
+		err += std::string(filename);
+		throw CL_Error(err);
+	}
+}
+
+void CL_InputSource_Datafile::close()
+{
+	if (index_open == 0) return;
+
+	index_open=0;
+	if (compressed) gzclose(gzfile);
+	else ::close(datafile_handle);
+}
+
+CL_InputSource *CL_InputSource_Datafile::clone() const
+{
+	return new CL_InputSource_Datafile(this);
+}
+
+int CL_InputSource_Datafile::tell() const
+{
+	return seek_pos;
+}
+
+void CL_InputSource_Datafile::seek(int pos, SeekEnum seek_type)
+{
+	if (compressed)
+	{
+		if (seek_type == seek_cur)
+		{
+			if (pos &gt; 0)
+			{
+				char *temp = new char[pos];
+				read(temp, pos);
+				delete temp;
+			}
+			else if (pos &lt; 0)
+			{
+				seek(tell()+pos, seek_set);
+			}
+			return;
+		}
+		else if (seek_type == seek_set)
+		{
+			int cur_pos = tell();
+			if (pos &gt;= cur_pos)
+			{
+				seek(pos - cur_pos, seek_cur);
+				return;
+			}
+ 			else if (pos&gt;=0)
+ 			{
+ 				/*
+ 				 * OK, now we have to go backwards. Since there's no
+ 				 * easy way to do it (think about compressed datafiles)
+ 				 * we close and then open the datafile. This way we are
+ 				 * back to position 0, and can proceed to a standard
+ 				 * forward seek. OK this is a  performance killer 
+ 				 * method, but it's better than nothing...
+ 				 */
+ 				close();
+ 				open();
+ 				seek(pos, seek_cur);
+ 				return;
+ 			}
+  		}
+  
+		throw CL_Error(&quot;ClanLib: seek() in datafiles called with an invalid position&quot;);
+	}
+	else
+	{
+		if (seek_type == seek_set)
+		{
+			lseek(datafile_handle, index_pos+pos, SEEK_SET);
+		}
+		else if (seek_type == seek_cur)
+		{
+			lseek(datafile_handle, pos, SEEK_CUR);
+		}
+		else if (seek_type == seek_end)
+		{
+			lseek(datafile_handle, index_pos+objsize+pos, SEEK_SET);
+		}
+	}
+}
+
+int CL_InputSource_Datafile::size() const
+{
+	return objsize;
+}
+
+void CL_InputSource_Datafile::push_position()
+{
+	CL_Zipped_Position indexpos;
+
+	indexpos.gzfile = gzfile;
+//	indexpos.datafile_pos = lseek(datafile_handle, 0, SEEK_CUR);
+	indexpos.seek_pos = seek_pos;
+
+	index_stack.push(indexpos);
+
+	index_open=0;
+}
+
+void CL_InputSource_Datafile::pop_position()
+{
+//	if (index_open != 0) close_index();
+//	index_open = 1;
+
+	CL_Zipped_Position pushed_index = index_stack.top();
+	index_stack.pop();
+	
+	gzfile = pushed_index.gzfile;
+//	lseek(datafile_handle, pushed_index.datafile_pos, SEEK_SET);
+	seek_pos = pushed_index.seek_pos;
+
+	if (!compressed) seek(seek_pos, seek_set);
+}
+
+

Added: trunk/clanlib/Core/IOData/Generic/datafile_inputprovider.h
===================================================================
--- trunk/clanlib/Core/IOData/Generic/datafile_inputprovider.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/Generic/datafile_inputprovider.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,162 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_datafile_inputprovider
+#define header_datafile_inputprovider
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;map&gt;
+#include &lt;utility&gt;
+#include &lt;zlib.h&gt;
+
+#include &quot;API/Core/IOData/inputsource.h&quot;
+#include &quot;API/Core/IOData/inputsource_provider.h&quot;
+
+#include &lt;stack&gt;
+
+class CL_Zipped_Position
+{
+public:
+	gzFile gzfile;
+	int datafile_pos;
+	int seek_pos;
+};
+
+class CL_InputSourceProvider_Datafile;
+
+class CL_InputSource_Datafile : public CL_InputSource
+{
+protected:
+	std::string filename;
+	CL_InputSourceProvider_Datafile *provider;
+
+	int objsize;
+	gzFile gzfile;
+	int datafile_handle;
+	int index_open;
+	char compressed;
+	int index_pos;
+
+	std::stack&lt;CL_Zipped_Position&gt; index_stack;
+	
+	int seek_pos;
+
+public:
+	CL_InputSource_Datafile(const std::string &amp;filename, CL_InputSourceProvider_Datafile *provider);
+	CL_InputSource_Datafile(const CL_InputSource_Datafile *source);
+	virtual ~CL_InputSource_Datafile();
+
+	//: read larger amounts of data (no endian and 64 bit conversion):
+	//return: num bytes actually read
+	virtual int read(void *data, int size);
+
+	virtual void open();
+	virtual void close();
+
+	//: Make a copy of the current InputSource, standing at the same position.
+	virtual CL_InputSource *clone() const;
+
+	//: Returns current position in input source
+	virtual int tell() const;
+	virtual void seek(int pos, SeekEnum seek_type);
+
+	//: Returns the size of the input source
+	virtual int size() const;
+
+	virtual void push_position();
+	virtual void pop_position();
+};
+
+class CL_InputSourceProvider_Datafile : public CL_InputSourceProvider
+{
+public:
+	CL_InputSourceProvider_Datafile(const std::string &amp;datafile);
+	CL_InputSourceProvider_Datafile(CL_InputSourceProvider_Datafile *datafile);
+	virtual ~CL_InputSourceProvider_Datafile();
+
+	virtual CL_InputSource *open_source(const std::string &amp;filename);
+	virtual CL_InputSourceProvider *clone();
+	virtual std::string get_pathname(const std::string &amp;filename);
+	virtual CL_InputSourceProvider *create_relative(const std::string &amp;path);
+
+	int get_handle() const { return datafile_handle; }
+	bool lookup_resource(const std::string &amp;resource_id, int &amp;pos, int &amp;size) const
+	{
+		return resource_cache-&gt;lookup(resource_id, pos, size);
+	}
+
+protected:
+	class IndexLocationCache
+	{
+	public:
+		IndexLocationCache() : refcount(1) { ; }
+
+		void addref() { refcount++; }
+		void release()
+		{
+			refcount--;
+			if (!refcount) delete this;
+		}
+
+		bool lookup(const std::string &amp;resource_id, int &amp;data_pos, int &amp;data_size) const
+		{
+			std::map&lt;std::string, std::pair&lt;int, int&gt; &gt;::const_iterator it = cache.find(resource_id);
+			if (it == cache.end())
+				return false;
+
+			data_pos = (*it).second.first;
+			data_size = (*it).second.second;
+
+			return true;
+		}
+
+		void insert(const std::string &amp;resource_id, int data_pos, int data_size)
+		{
+			cache.insert(
+				std::make_pair&lt;std::string const, std::pair&lt;int, int&gt; &gt;(
+				resource_id,
+				std::make_pair&lt;int,int&gt;(data_pos, data_size)));
+		}
+
+	private:
+		int refcount;
+		std::map&lt;std::string, std::pair&lt;int, int&gt; &gt; cache;
+	};
+	IndexLocationCache *resource_cache;
+
+	std::string datafile;
+	int datafile_handle;
+	void open();
+	void load_resource_ids();
+};
+
+#endif

Added: trunk/clanlib/Core/IOData/Generic/directory.cpp
===================================================================
--- trunk/clanlib/Core/IOData/Generic/directory.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/Generic/directory.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,221 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/IOData/directory.h&quot;
+#include &quot;API/Core/IOData/directory_scanner.h&quot;
+
+#ifndef WIN32
+#include &lt;unistd.h&gt;
+#include &lt;stdio.h&gt;
+#ifndef MAX_PATH
+#define MAX_PATH PATH_MAX
+#endif
+#else
+#include &lt;direct.h&gt;
+#ifndef chdir
+#define _chdir chdir
+#endif
+#ifndef MAX_PATH
+#define _MAX_PATH MAX_PATH
+#endif
+#endif
+
+#ifdef __BORLANDC__
+#include &lt;dir.h&gt;
+#endif
+
+#include &lt;sys/stat.h&gt;
+#include &lt;sys/types.h&gt;
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations
+
+bool CL_Directory::create(const std::string &amp;dir_name)
+{
+	if (dir_name.empty())
+		return false;
+
+	// this will be a full path
+	std::string full_path; 	// calculate the full path
+
+	#ifdef WIN32
+		DWORD buff_len = ::GetFullPathName(dir_name.c_str(), 0, 0, 0);
+
+		if (buff_len == 0)
+			// can't calculate, return bad status
+			return false;
+		else
+		{
+			char * buffer = new char[buff_len + 1];
+			char * buffer_ptr_to_filename = 0;
+			// Obtaining full path
+			buff_len = ::GetFullPathName(dir_name.c_str(), buff_len, buffer, &amp;buffer_ptr_to_filename);
+			if (buff_len == 0)
+			{
+				delete[] buffer;			
+				// can't obtain full path, return bad status
+				return false;
+			}
+		
+			// ok, save it
+			full_path = buffer;
+			delete[] buffer;			
+		}
+	#else
+		// TODO: add here Linux version of GetFullPathName
+		full_path = dir_name;
+	#endif
+
+#ifdef WIN32
+		return ::CreateDirectory(full_path.c_str(), NULL) != 0;
+#else
+		return ::mkdir(full_path.c_str(), 0755) == 0;
+#endif
+}
+
+bool CL_Directory::remove(const std::string &amp;dir_name, bool delete_files, bool delete_sub_directories)
+{
+	if (dir_name.empty())
+		return false;
+
+	// this will be a full path
+	std::string full_path;
+
+	// calculate the full path
+	#ifdef WIN32
+		DWORD buff_len = ::GetFullPathName(dir_name.c_str(), 0, 0, 0);
+
+		if (buff_len == 0)
+			// can't calculate, return bad status
+			return false;
+		else
+		{
+			char * buffer = new char[buff_len + 1];
+			char * buffer_ptr_to_filename = 0;
+			// Obtaining full path
+			buff_len = ::GetFullPathName(dir_name.c_str(), buff_len, buffer, &amp;buffer_ptr_to_filename);
+			if (buff_len == 0)
+			{
+				// can't obtaing full path, return bad status
+				delete[] buffer;			
+				return false;
+			}
+		
+			// ok, save it
+			full_path = buffer;
+			delete[] buffer;			
+
+		}
+	#else
+		// TODO: add here Linux version of GetFullPathName
+		full_path = dir_name;
+	#endif
+
+	// This scope needed for deleting directiory at end of function,
+	// because scanner lock current dir :(
+	{
+		CL_DirectoryScanner scanner;
+
+		if (!scanner.scan(full_path))
+			// can't even start scaning
+			return false;
+
+		// FIXME: probably bug in directory_scanner, it return &quot;&quot;
+		// for first file :(
+		if (scanner.next())
+		while(1)
+		{
+			// If found sub_directory, try remove it,
+			// also checking for &quot;.&quot; and &quot;..&quot;, because they are unremovable
+			if (scanner.is_directory() &amp;&amp; delete_sub_directories &amp;&amp;
+				scanner.get_name() != &quot;.&quot; &amp;&amp; scanner.get_name() != &quot;..&quot;)
+			{
+				// FIXME: directory_scanner lock directory, so it can't be
+				// removed, this is workaround
+				std::string sub_dir_path = scanner.get_pathname();
+				bool scann_successfull = scanner.next();
+
+				// delete files in sub_directory
+				if (!CL_Directory::remove(sub_dir_path.c_str(),
+							  delete_files,
+							  delete_sub_directories))
+					return false;
+
+				if (!scann_successfull)
+					break;
+				else
+					continue;
+			}
+			else
+			{
+				// Check for deleting file (or whatever is not directory),
+				// if this is allowed
+				if (delete_files &amp;&amp; !scanner.is_directory())
+				{
+					// delete a file
+					#ifdef WIN32
+						if (::DeleteFile(scanner.get_pathname().c_str()) == 0)
+							return false;
+					#else
+						if (::remove(scanner.get_pathname().c_str()) != 0)
+							return false;
+					#endif
+					if (!scanner.next())
+						break;
+				}
+				// This is for &quot;.&quot; and &quot;..&quot;
+				else
+				{
+					if (!scanner.next())
+						break;
+				}
+			}
+		}
+	}
+	// Finaly remove the directory (or sub_directory if in recursion)
+	#ifdef WIN32
+		return ::RemoveDirectory(full_path.c_str()) != 0;
+	#else
+		return ::rmdir(full_path.c_str()) == 0;
+	#endif
+}
+
+bool CL_Directory::change_to(const std::string &amp;dir_name)
+{
+	return chdir(dir_name.c_str()) == 0;
+}
+
+std::string CL_Directory::get_current()
+{
+	char cwd_buffer[MAX_PATH];
+	if (getcwd(cwd_buffer, MAX_PATH) == NULL)
+		throw CL_Error(&quot;Working dir is more than legal length !&quot;);
+	return cwd_buffer;
+}

Added: trunk/clanlib/Core/IOData/Generic/directory_scanner.cpp
===================================================================
--- trunk/clanlib/Core/IOData/Generic/directory_scanner.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/Generic/directory_scanner.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,119 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/System/cl_assert.h&quot;
+#include &quot;API/Core/IOData/directory_scanner.h&quot;
+#include &quot;directory_scanner_generic.h&quot;
+
+#ifdef WIN32
+#include &quot;../Win32/directory_scanner_win32.h&quot;
+#else
+#include &quot;../Unix/directory_scanner_unix.h&quot;
+#endif
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DirectoryScanner construction:
+
+CL_DirectoryScanner::CL_DirectoryScanner()
+{
+#ifdef WIN32
+	impl = new CL_DirectoryScanner_Win32();
+#else
+	impl = new CL_DirectoryScanner_Unix();
+#endif
+}
+
+CL_DirectoryScanner::CL_DirectoryScanner(const CL_DirectoryScanner &amp;copy) : impl(copy.impl)
+{
+}
+
+CL_DirectoryScanner::~CL_DirectoryScanner()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DirectoryScanner attributes:
+
+bool CL_DirectoryScanner::scan(const std::string&amp; pathname) 
+{
+	return impl-&gt;scan (pathname);
+}
+
+bool CL_DirectoryScanner::scan(const std::string&amp; pathname, const std::string&amp; pattern)
+{
+	return impl-&gt;scan (pathname, pattern);
+}
+
+std::string CL_DirectoryScanner::get_directory_path()
+{
+	return impl-&gt;get_directory_path();
+}
+
+int CL_DirectoryScanner::get_size()
+{
+	return impl-&gt;get_size();
+}
+
+std::string CL_DirectoryScanner::get_name()
+{
+	return impl-&gt;get_name();
+}
+	
+std::string CL_DirectoryScanner::get_pathname()
+{
+	return impl-&gt;get_pathname();
+}
+	
+bool CL_DirectoryScanner::is_directory()
+{
+	return impl-&gt;is_directory();
+}
+
+bool CL_DirectoryScanner::is_hidden()
+{
+	return impl-&gt;is_hidden();
+}     
+
+bool CL_DirectoryScanner::is_readable()
+{
+	return impl-&gt;is_readable();
+}
+
+ bool CL_DirectoryScanner::is_writable()
+{
+	return impl-&gt;is_writable();
+}
+/////////////////////////////////////////////////////////////////////////////
+// CL_DirectoryScanner operations:
+
+bool CL_DirectoryScanner::next() 
+{ 
+	return impl-&gt;next(); 
+}

Added: trunk/clanlib/Core/IOData/Generic/directory_scanner_generic.h
===================================================================
--- trunk/clanlib/Core/IOData/Generic/directory_scanner_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/Generic/directory_scanner_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,88 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_directory_scanner_generic
+#define header_directory_scanner_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+
+class CL_DirectoryScanner_Generic
+{
+//! Construction:
+public:
+	CL_DirectoryScanner_Generic() { return; }
+
+	virtual ~CL_DirectoryScanner_Generic() { return; }
+	
+//! Attributes:
+public:
+	virtual bool scan (const std::string&amp; pathname) =0;
+
+	virtual bool scan (const std::string&amp; pathname, const std::string&amp; pattern) =0;
+
+	//: Returns the path of the directory being scanned.
+	virtual std::string get_directory_path() = 0;
+
+	//: Returns the name of the current found file.
+	virtual std::string get_name() = 0;
+
+	//: Returns the size of the current found file.
+	virtual int get_size() = 0;
+
+	//: Returns the name of the current found file, including the directory path.
+	virtual std::string get_pathname() = 0;
+	
+	//: Returns true if filename is a directory.
+	virtual bool is_directory() = 0;
+
+	//: Returns true if filename is hidden.
+	virtual bool is_hidden() = 0;
+
+	//: Returns true if file is readable by current user.
+	virtual bool is_readable() = 0;
+
+	//: Returns true if file is writable by current user.
+	virtual bool is_writable() = 0;
+
+	// todo: add other attributes of a file.
+
+//! Operations:
+public:
+	//: Find next file in directory scan. Returns false if no more files was found.
+	virtual bool next() = 0;
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/Core/IOData/Generic/endianess.cpp
===================================================================
--- trunk/clanlib/Core/IOData/Generic/endianess.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/Generic/endianess.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,62 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+
+#include &quot;API/Core/IOData/cl_endian.h&quot;
+
+void CL_Endian::swap(void *data, int type_size, int total_times)
+{
+	if (type_size == 1) return;
+
+	unsigned char *d = (unsigned char *) data;
+
+	for (int j=0; j&lt;total_times; j++)
+	{
+		for (int i=0; i&lt;type_size/2; i++)
+		{
+			unsigned char a = d[i];
+			d[i] = d[type_size-1-i];
+			d[type_size-1-i] = a;
+		}
+		
+		d += type_size;
+	}
+}
+
+bool CL_Endian::is_system_big()
+{
+	const int i = 1;
+	return !(*(char *)(&amp;i));
+}
+
+bool CL_Endian::is_system_64bit()
+{
+	return (sizeof(int*) == 8);
+}

Added: trunk/clanlib/Core/IOData/Generic/inputsource.cpp
===================================================================
--- trunk/clanlib/Core/IOData/Generic/inputsource.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/Generic/inputsource.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,301 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/IOData/inputsource.h&quot;
+#include &quot;API/Core/IOData/cl_endian.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputSource operations:
+
+void CL_InputSource::set_system_mode()
+{
+	little_endian_mode = !CL_Endian::is_system_big();
+}
+
+void CL_InputSource::set_big_endian_mode()
+{
+	little_endian_mode = false;
+}
+
+void CL_InputSource::set_little_endian_mode()
+{
+	little_endian_mode = true;
+}
+
+cl_int64 CL_InputSource::read_int64()
+{
+	cl_int64 answer;
+	if (read(&amp;answer, sizeof(cl_int64)) != sizeof(cl_int64)) throw CL_Error(&quot;CL_InputSource_Datafile::read_int64() failed&quot;);
+	if (little_endian_mode)
+	{
+		SWAP_IF_BIG(answer);
+	}
+	else
+	{
+		SWAP_IF_LITTLE(answer);
+	}
+	return answer;
+}
+
+cl_uint64 CL_InputSource::read_uint64()
+{
+	cl_uint64 answer;
+	if (read(&amp;answer, sizeof(cl_uint64)) != sizeof(cl_uint64)) throw CL_Error(&quot;CL_InputSource_Datafile::read_uint64() failed&quot;);
+	if (little_endian_mode)
+	{
+		SWAP_IF_BIG(answer);
+	}
+	else
+	{
+		SWAP_IF_LITTLE(answer);
+	}
+	return answer;
+}
+
+cl_int32 CL_InputSource::read_int32()
+{
+	cl_int32 answer;
+	if (read(&amp;answer, sizeof(cl_int32)) != sizeof(cl_int32)) throw CL_Error(&quot;CL_InputSource_Datafile::read_int32() failed&quot;);
+	if (little_endian_mode)
+	{
+		SWAP_IF_BIG(answer);
+	}
+	else
+	{
+		SWAP_IF_LITTLE(answer);
+	}
+	return answer;
+}
+
+cl_uint32 CL_InputSource::read_uint32()
+{
+	cl_uint32 answer;
+	if (read(&amp;answer, sizeof(cl_uint32)) != sizeof(cl_uint32)) throw CL_Error(&quot;CL_InputSource_Datafile::read_uint32() failed&quot;);
+	if (little_endian_mode)
+	{
+		SWAP_IF_BIG(answer);
+	}
+	else
+	{
+		SWAP_IF_LITTLE(answer);
+	}
+	return answer;
+}
+
+cl_int16 CL_InputSource::read_int16()
+{
+	cl_int16 answer;
+	if (read(&amp;answer, sizeof(cl_int16)) != sizeof(cl_int16)) throw CL_Error(&quot;CL_InputSource_Datafile::read_int16() failed&quot;);
+	if (little_endian_mode)
+	{
+		SWAP_IF_BIG(answer);
+	}
+	else
+	{
+		SWAP_IF_LITTLE(answer);
+	}
+	return answer;
+}
+
+cl_uint16 CL_InputSource::read_uint16()
+{
+	cl_uint16 answer;
+	if (read(&amp;answer, sizeof(cl_uint16)) != sizeof(cl_uint16)) throw CL_Error(&quot;CL_InputSource_Datafile::read_uint16() failed&quot;);
+	if (little_endian_mode)
+	{
+		SWAP_IF_BIG(answer);
+	}
+	else
+	{
+		SWAP_IF_LITTLE(answer);
+	}
+	return answer;
+}
+
+cl_int8 CL_InputSource::read_int8()
+{
+	cl_int8 answer;
+	if (read(&amp;answer, sizeof(cl_int8)) != sizeof(cl_int8)) throw CL_Error(&quot;CL_InputSource_Datafile::read_int8() failed&quot;);
+	if (little_endian_mode)
+	{
+		SWAP_IF_BIG(answer);
+	}
+	else
+	{
+		SWAP_IF_LITTLE(answer);
+	}
+	return answer;
+}
+
+cl_uint8 CL_InputSource::read_uint8()
+{
+	cl_uint8 answer;
+	if (read(&amp;answer, sizeof(cl_uint8)) != sizeof(cl_uint8)) throw CL_Error(&quot;CL_InputSource_Datafile::read_uint8() failed&quot;);
+	if (little_endian_mode)
+	{
+		SWAP_IF_BIG(answer);
+	}
+	else
+	{
+		SWAP_IF_LITTLE(answer);
+	}
+	return answer;
+}
+
+short CL_InputSource::read_short16()
+{
+	short answer;
+	if (read(&amp;answer, sizeof(short)) != sizeof(short)) throw CL_Error(&quot;CL_InputSource_Datafile::read_short16() failed&quot;);
+
+	if (little_endian_mode)
+	{
+		SWAP_IF_BIG(answer);
+	}
+	else
+	{
+		SWAP_IF_LITTLE(answer);
+	}
+
+	return answer;
+}
+
+unsigned short CL_InputSource::read_ushort16()
+{
+	unsigned short answer;
+	if (read(&amp;answer, sizeof(unsigned short)) != sizeof(unsigned short)) throw CL_Error(&quot;CL_InputSource_Datafile::read_ushort16() failed&quot;);
+
+	if (little_endian_mode)
+	{
+		SWAP_IF_BIG(answer);
+	}
+	else
+	{
+		SWAP_IF_LITTLE(answer);
+	}
+
+	return answer;
+}
+
+char CL_InputSource::read_char8()
+{
+	char answer;
+	if (read(&amp;answer, sizeof(char)) != sizeof(char)) throw CL_Error(&quot;CL_InputSource_Datafile::read_char8() failed&quot;);
+
+	if (little_endian_mode)
+	{
+		SWAP_IF_BIG(answer);
+	}
+	else
+	{
+		SWAP_IF_LITTLE(answer);
+	}
+
+	return answer;
+}
+
+unsigned char CL_InputSource::read_uchar8()
+{
+	unsigned char answer;
+	if (read(&amp;answer, sizeof(unsigned char)) != sizeof(unsigned char)) throw CL_Error(&quot;CL_InputSource_Datafile::read_uchar8() failed&quot;);
+
+	return answer;
+}
+
+float CL_InputSource::read_float32()
+{
+	float answer;
+	if (read(&amp;answer, sizeof(float)) != sizeof(float)) throw CL_Error(&quot;CL_InputSource_Datafile::read_float32() failed&quot;);
+
+	if (little_endian_mode)
+	{
+		SWAP_IF_BIG(answer);
+	}
+	else
+	{
+		SWAP_IF_LITTLE(answer);
+	}
+
+	return answer;
+}
+
+double CL_InputSource::read_float64()
+{
+	double answer;
+	if (read(&amp;answer, sizeof(double)) != sizeof(double)) throw CL_Error(&quot;CL_InputSource_Datafile::read_float64() failed&quot;);
+
+	if (little_endian_mode)
+	{
+		SWAP_IF_BIG(answer);
+	}
+	else
+	{
+		SWAP_IF_LITTLE(answer);
+	}
+
+	return answer;
+}
+
+bool CL_InputSource::read_bool8()
+{
+	bool answer;
+	if (read(&amp;answer, sizeof(bool)) != sizeof(bool)) throw CL_Error(&quot;CL_InputSource_Datafile::read_bool8() failed&quot;);
+
+	if (little_endian_mode)
+	{
+		SWAP_IF_BIG(answer);
+	}
+	else
+	{
+		SWAP_IF_LITTLE(answer);
+	}
+
+	return answer;
+}
+
+std::string CL_InputSource::read_string()
+{
+	int size = read_int32();
+
+	char *str = new char[size];
+	try
+	{
+		read(str, size);
+		
+		std::string ret(str, size);
+		delete[] str;
+
+		return ret;
+	}
+	catch (...)
+	{
+		delete[] str;
+		throw;
+	}
+}

Added: trunk/clanlib/Core/IOData/Generic/inputsource_file.cpp
===================================================================
--- trunk/clanlib/Core/IOData/Generic/inputsource_file.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/Generic/inputsource_file.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,171 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+
+#ifdef WIN32
+#include &lt;direct.h&gt;
+#endif
+#include &lt;API/Core/IOData/inputsource_file.h&gt;
+
+CL_InputSource_File::CL_InputSource_File(const std::string &amp;_filename)
+{
+	filename = _filename;
+	filehandle = NULL;
+	open();
+}
+
+CL_InputSource_File::CL_InputSource_File(const CL_InputSource_File *source)
+{
+	filename = source-&gt;filename;
+	filehandle = NULL;
+
+	open();
+	fseek(filehandle, ftell(source-&gt;filehandle), SEEK_SET);
+}
+
+CL_InputSource_File::~CL_InputSource_File()
+{
+	close();
+}
+
+std::string CL_InputSource_File::translate_path(const std::string &amp;path)
+{
+	int len = 0;
+
+	// try to figure out if path is absolute.
+	if (path.length() &gt; 0 &amp;&amp; (path[0] == '\\' || path[0] == '/' || (path.length() &gt; 1 &amp;&amp; path[1] == ':')))
+	{
+		// path is absolute
+		return path;
+	}
+	else
+	{
+
+		//note, I moved BigZaphod's mac path hack to Application/MacOS/clanapp.cpp -mrfun may 18 2006
+		
+		char cwd[1026];
+		if (getcwd(cwd, 1024) == NULL) throw CL_Error(&quot;Working dir is more than 1024 characters!&quot;);
+		len = strlen(cwd);
+		if (cwd[len-1] != '/' &amp;&amp; cwd[len-1] != '\\') strcat(cwd, &quot;/&quot;);
+		
+		return std::string(cwd) + std::string(path);
+	}
+}
+
+int CL_InputSource_File::read(void *data, int size)
+{
+	return fread(data, 1, size, filehandle);
+}
+
+void CL_InputSource_File::open()
+{
+	if (filehandle != NULL) return;
+
+#ifndef WIN32 // hate win32 non posix conform
+	if (filename[0] == '!')
+	{
+		filehandle = popen(std::string(filename, 1).c_str(), &quot;rb&quot;);
+		if (filehandle == NULL)
+		{
+			throw CL_Error(&quot;Could not open pipe: &quot; + std::string(filename,1));
+		}
+		filesize = 99999999;
+	}
+	else
+#endif
+	{
+		filename = translate_path(filename);
+		filehandle = fopen(filename.c_str(), &quot;rb&quot;);
+		if (filehandle == NULL)
+		{
+			throw CL_Error(&quot;Could not open file: &quot; + filename);
+		}
+		fseek(filehandle, 0, SEEK_END);
+		filesize = ftell(filehandle);
+		fseek(filehandle, 0, SEEK_SET);
+	}
+//	cl_assert(filehandle != NULL);
+}
+
+void CL_InputSource_File::close()
+{
+	if (filehandle == NULL) return;
+	fclose(filehandle);
+
+	filehandle = NULL;
+}
+
+CL_InputSource *CL_InputSource_File::clone() const
+{
+	return new CL_InputSource_File(this);
+}
+
+int CL_InputSource_File::tell() const
+{
+	return ftell(filehandle);
+}
+
+void CL_InputSource_File::seek(int pos, SeekEnum seek_type)
+{
+	switch (seek_type)
+	{
+		case seek_cur:
+			fseek(filehandle, pos, SEEK_CUR);
+			break;
+
+		case seek_set:
+			fseek(filehandle, pos, SEEK_SET);
+			break;
+
+		case seek_end:
+			fseek(filehandle, pos, SEEK_END);
+			break;
+	}
+}
+
+int CL_InputSource_File::size() const
+{
+	return filesize;
+}
+
+void CL_InputSource_File::push_position()
+{
+	int a = ftell(filehandle);
+
+	stack.push(a);
+}
+
+void CL_InputSource_File::pop_position()
+{
+	int a = stack.top();
+	stack.pop();
+
+	fseek(filehandle, a, SEEK_SET);
+}

Added: trunk/clanlib/Core/IOData/Generic/inputsource_memory_generic.cpp
===================================================================
--- trunk/clanlib/Core/IOData/Generic/inputsource_memory_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/Generic/inputsource_memory_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,167 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+
+#include &quot;API/Core/System/cl_assert.h&quot;
+#include &quot;inputsource_memory_generic.h&quot;
+#include &quot;outputsource_memory_generic.h&quot;
+
+CL_InputSource_MemoryGeneric::CL_InputSource_MemoryGeneric(
+	void *_data,
+	int size,
+	bool delete_data)
+{
+	data = (unsigned char *) _data;
+	pos = 0;
+	length = size;
+	delete_data = delete_data;
+}
+
+CL_InputSource_MemoryGeneric::CL_InputSource_MemoryGeneric(
+	const CL_InputSource_MemoryGeneric *MG)
+{
+	data = new unsigned char[MG-&gt;size()];
+	pos = 0;
+	length = MG-&gt;size();
+	delete_data = true;
+	memcpy(data, MG-&gt;data, length);
+}
+
+CL_InputSource_MemoryGeneric::~CL_InputSource_MemoryGeneric()
+{
+	if (delete_data) delete[] data;
+}
+
+int CL_InputSource_MemoryGeneric::read(void *_data, int size)
+{
+	cl_assert(pos + size &lt;= length);
+	
+	memcpy(_data, data + pos, size);
+	pos += size;
+
+	return size;
+}
+
+void CL_InputSource_MemoryGeneric::open()
+{
+	pos = 0;
+}
+
+void CL_InputSource_MemoryGeneric::close()
+{
+}
+
+CL_InputSource *CL_InputSource_MemoryGeneric::clone() const
+{
+	CL_InputSource_MemoryGeneric *ret = new CL_InputSource_MemoryGeneric(data, length, delete_data);
+	ret-&gt;seek(pos, seek_set);
+	return ret;
+}
+
+int CL_InputSource_MemoryGeneric::tell() const
+{
+	return pos;
+}
+
+void CL_InputSource_MemoryGeneric::seek(int _pos, SeekEnum seek_type)
+{
+	switch (seek_type)
+	{
+	case seek_set:
+		pos = _pos;
+		break;
+	
+	case seek_cur:
+		pos += _pos;
+		break;
+	
+	case seek_end:
+		pos = length + _pos;
+		break;
+	
+	default: // invalid seek type!
+		cl_assert(false);
+	}
+}
+
+int CL_InputSource_MemoryGeneric::size() const
+{
+	return length;
+}
+
+void CL_InputSource_MemoryGeneric::push_position()
+{
+	cl_assert(false); // not implemented yet.
+}
+
+void CL_InputSource_MemoryGeneric::pop_position()
+{
+	cl_assert(false); // not implemented yet.
+}
+
+void CL_InputSource_MemoryGeneric::purge()
+{
+	memset(data, 0, length);
+}
+
+CL_InputSourceProvider_Memory::CL_InputSourceProvider_Memory(unsigned char *_data, unsigned int _size, bool _delete_data)
+{
+	data = _data;
+	size = _size;
+	delete_data = _delete_data;
+}
+
+CL_InputSourceProvider_Memory::CL_InputSourceProvider_Memory(CL_InputSource_MemoryGeneric *MG)
+{
+	data = new unsigned char[MG-&gt;size()];
+	size = MG-&gt;size();
+	delete_data = true;
+	MG-&gt;read(data, size);
+}
+
+CL_InputSourceProvider_Memory::CL_InputSourceProvider_Memory(CL_OutputSource_MemoryGeneric *MG)
+{
+	data = new unsigned char[MG-&gt;size()];
+	size = MG-&gt;size();
+	delete_data = true;
+	memcpy(data, MG-&gt;get_data(), size);
+}
+
+CL_InputSource *CL_InputSourceProvider_Memory::open_source(const std::string &amp;)
+{
+	return new CL_InputSource_MemoryGeneric(data, size, delete_data);
+}
+
+CL_InputSourceProvider *CL_InputSourceProvider_Memory::clone()
+{
+ 	cl_assert(false);
+ 	return NULL;
+}
+

Added: trunk/clanlib/Core/IOData/Generic/inputsource_memory_generic.h
===================================================================
--- trunk/clanlib/Core/IOData/Generic/inputsource_memory_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/Generic/inputsource_memory_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,119 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_inputsource_memory_generic
+#define header_inputsource_memory_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/IOData/inputsource.h&quot;
+#include &quot;API/Core/IOData/inputsource_provider.h&quot;
+
+class CL_OutputSource_MemoryGeneric;
+
+class CL_InputSource_MemoryGeneric : public CL_InputSource
+//: Interface to read data from a memory_generic source.
+//- &lt;p&gt;CL_InputSource_MemoryGeneric is used to read data from a memory_generic source.&lt;/p&gt;
+//also: CL_InputSourceProvider - Interface to open input sources with.
+{
+public:
+	CL_InputSource_MemoryGeneric(void *data, int size, bool delete_data = false);
+
+	//: MemoryGeneric copy constructor.
+	//- &lt;p&gt;Makes a seperate copy of the memory in MG.&lt;/p&gt;
+	//also: MemoryGeneric::clone.
+	//param MG: Pointer to the MemoryGeneric object from which to copy.
+	CL_InputSource_MemoryGeneric(const CL_InputSource_MemoryGeneric *MG);
+
+	virtual ~CL_InputSource_MemoryGeneric();
+
+	//: Reads larger amounts of data (no endian and 64 bit conversion).
+	//param data: Points to an array where the read data is stored.
+	//param size: Number of bytes to read.
+	//return: Num bytes actually read.
+	virtual int read(void *data, int size);
+	
+	//: Opens the input source. By default, it is open.
+	virtual void open();
+	
+	//: Closes the input source.
+	virtual void close();
+
+	//: Make a copy of the current InputSource, standing at the same position.
+	//return: The clone of the input source.
+	virtual CL_InputSource *clone() const;
+
+	//: Returns current position in input source.
+	//return: Current position in input source.
+	virtual int tell() const;
+
+	//: Seeks to the specified position in the input source.
+	//param pos: Position relative to 'seek_type'.
+	//param seek_type: Defines what the 'pos' is relative to. Can be either seek_set, seek_cur og seek_end.
+	virtual void seek(int pos, SeekEnum seek_type);
+
+	//: Returns the size of the input source
+	//return: Size of the input source.
+	virtual int size() const;
+
+	//: Pushes the current input source position. The position can be restored again with pop_position.
+	virtual void push_position();
+	
+	//: Pops a previous pushed input source position (returns to the position).
+	virtual void pop_position();
+
+	//: Purges the input buffer of data without deleting the buffer
+	virtual void purge();
+
+private:
+	unsigned char *data;
+	unsigned int pos, length;
+	bool delete_data;
+};
+
+class CL_InputSourceProvider_Memory : public CL_InputSourceProvider
+{
+public:
+	CL_InputSourceProvider_Memory(unsigned char *data, unsigned int size, bool delete_data);
+	CL_InputSourceProvider_Memory(CL_InputSource_MemoryGeneric *MG);
+	CL_InputSourceProvider_Memory(CL_OutputSource_MemoryGeneric *MG);
+
+	virtual CL_InputSource *open_source(const std::string &amp;handle);
+	virtual CL_InputSourceProvider *clone();
+
+private:
+	unsigned char *data;
+	unsigned int size;
+	bool delete_data;
+};
+
+#endif
+

Added: trunk/clanlib/Core/IOData/Generic/inputsource_provider_file.cpp
===================================================================
--- trunk/clanlib/Core/IOData/Generic/inputsource_provider_file.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/Generic/inputsource_provider_file.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,85 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#ifdef WIN32
+#include &lt;direct.h&gt;
+#else
+#include &lt;unistd.h&gt;
+#endif
+
+#include &lt;API/Core/IOData/inputsource_provider_file.h&gt;
+#include &lt;API/Core/IOData/inputsource_file.h&gt;
+
+CL_InputSourceProvider_File::CL_InputSourceProvider_File(const std::string &amp;path)
+{
+	provider_path = CL_InputSource_File::translate_path(path);
+
+	// make sure the resulting path that we create ends with a '/'
+	// this is *also* explicitly needed for everything that tries to load
+	// something with inputprovider(&quot;.&quot;) ==&gt; when &quot;creating&quot; surfaces without using
+	// the resource system
+
+	int len = provider_path.length();
+	if (provider_path[len-1] != '/' &amp;&amp; provider_path[len-1] != '\\') 
+		provider_path += '/';
+}
+
+CL_InputSourceProvider *CL_InputSourceProvider::create_file_provider(const std::string &amp;path)
+{
+	return new CL_InputSourceProvider_File(path);
+}
+
+CL_InputSource *CL_InputSourceProvider_File::open_source(const std::string &amp;filename)
+{
+	return new CL_InputSource_File(get_pathname(filename).c_str());
+}
+
+std::string CL_InputSourceProvider_File::get_pathname(const std::string &amp;filename)
+{        
+	std::string filepath;
+
+	// if path is absolute, do not prepend provider path:
+	if (filename[0] == '\\' || filename[0] == '/' || filename[1] == ':')
+		filepath = filename;
+	else
+		filepath = provider_path + filename;
+
+	return filepath;
+}
+
+CL_InputSourceProvider *CL_InputSourceProvider_File::create_relative(const std::string &amp;path)
+{
+	return new CL_InputSourceProvider_File(provider_path + path);
+}
+
+CL_InputSourceProvider *CL_InputSourceProvider_File::clone()
+{
+	return new CL_InputSourceProvider_File(provider_path);
+}

Added: trunk/clanlib/Core/IOData/Generic/inputsource_zipped.cpp
===================================================================
--- trunk/clanlib/Core/IOData/Generic/inputsource_zipped.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/Generic/inputsource_zipped.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,114 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/IOData/inputsource_zipped.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputSource_Zipped_Generic
+
+class CL_InputSource_Zipped_Generic
+{
+public:
+	CL_InputSource *input;
+	bool delete_input;
+};
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputSource_Zipped Construction:
+
+CL_InputSource_Zipped::CL_InputSource_Zipped(
+	CL_InputSource *input,
+	bool delete_input)
+:
+	impl(new CL_InputSource_Zipped_Generic)
+{
+	impl-&gt;input = input;
+	impl-&gt;delete_input = delete_input;
+}
+
+CL_InputSource_Zipped::~CL_InputSource_Zipped()
+{
+	if (impl-&gt;delete_input) delete impl-&gt;input;
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputSource_Zipped Attributes:
+
+int CL_InputSource_Zipped::tell() const
+{
+	return impl-&gt;input-&gt;tell();
+}
+
+int CL_InputSource_Zipped::size() const
+{
+	return impl-&gt;input-&gt;size();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputSource_Zipped Operations:
+
+int CL_InputSource_Zipped::read(void *data, int size)
+{
+	return impl-&gt;input-&gt;read(data, size);
+}
+
+void CL_InputSource_Zipped::open()
+{
+	impl-&gt;input-&gt;open();
+}
+
+void CL_InputSource_Zipped::close()
+{
+	impl-&gt;input-&gt;close();
+}
+
+CL_InputSource *CL_InputSource_Zipped::clone() const
+{
+	return new CL_InputSource_Zipped(impl-&gt;input-&gt;clone(), true);
+}
+
+void CL_InputSource_Zipped::seek(int pos, SeekEnum seek_type)
+{
+	impl-&gt;input-&gt;seek(pos, seek_type);
+}
+
+void CL_InputSource_Zipped::push_position()
+{
+	impl-&gt;input-&gt;push_position();
+}
+
+void CL_InputSource_Zipped::pop_position()
+{
+	impl-&gt;input-&gt;pop_position();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputSource_Zipped Implementation:

Added: trunk/clanlib/Core/IOData/Generic/outputsource.cpp
===================================================================
--- trunk/clanlib/Core/IOData/Generic/outputsource.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/Generic/outputsource.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,231 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/IOData/outputsource.h&quot;
+#include &quot;API/Core/IOData/cl_endian.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OutputSource operations:
+
+void CL_OutputSource::set_system_mode()
+{
+	little_endian_mode = !CL_Endian::is_system_big();
+}
+
+void CL_OutputSource::set_big_endian_mode()
+{
+	little_endian_mode = false;
+}
+
+void CL_OutputSource::set_little_endian_mode()
+{
+	little_endian_mode = true;
+}
+
+void CL_OutputSource::write_int64(cl_int64 data)
+{
+	cl_int64 final = data;
+	if (little_endian_mode)
+	{
+		SWAP_IF_BIG(final);
+	}
+	else
+	{
+		SWAP_IF_LITTLE(final);
+	}
+	write(&amp;final, sizeof(cl_int64));
+}
+
+void CL_OutputSource::write_uint64(cl_uint64 data)
+{
+	cl_uint64 final = data;
+	if (little_endian_mode)
+	{
+		SWAP_IF_BIG(final);
+	}
+	else
+	{
+		SWAP_IF_LITTLE(final);
+	}
+	write(&amp;final, sizeof(cl_uint64));
+}
+
+void CL_OutputSource::write_int32(cl_int32 data)
+{
+	cl_int32 final = data;
+	if (little_endian_mode)
+	{
+		SWAP_IF_BIG(final);
+	}
+	else
+	{
+		SWAP_IF_LITTLE(final);
+	}
+	write(&amp;final, sizeof(cl_int32));
+}
+
+void CL_OutputSource::write_uint32(cl_uint32 data)
+{
+	cl_uint32 final = data;
+	if (little_endian_mode)
+	{
+		SWAP_IF_BIG(final);
+	}
+	else
+	{
+		SWAP_IF_LITTLE(final);
+	}
+	write(&amp;final, sizeof(cl_uint32));
+}
+
+void CL_OutputSource::write_int16(cl_int16 data)
+{
+	cl_int16 final = data;
+	if (little_endian_mode)
+	{
+		SWAP_IF_BIG(final);
+	}
+	else
+	{
+		SWAP_IF_LITTLE(final);
+	}
+	write(&amp;final, sizeof(cl_int16));
+}
+
+void CL_OutputSource::write_uint16(cl_uint16 data)
+{
+	cl_uint16 final = data;
+	if (little_endian_mode)
+	{
+		SWAP_IF_BIG(final);
+	}
+	else
+	{
+		SWAP_IF_LITTLE(final);
+	}
+	write(&amp;final, sizeof(cl_uint16));
+}
+
+void CL_OutputSource::write_int8(cl_int8 data)
+{
+	write(&amp;data, sizeof(cl_int8));
+}
+
+void CL_OutputSource::write_uint8(cl_uint8 data)
+{
+	write(&amp;data, sizeof(cl_uint8));
+}
+
+void CL_OutputSource::write_short16(short data)
+{
+	short final = data;
+	if (little_endian_mode)
+	{
+		SWAP_IF_BIG(final);
+	}
+	else
+	{
+		SWAP_IF_LITTLE(final);
+	}
+	write(&amp;final, sizeof(short));
+}
+
+void CL_OutputSource::write_ushort16(unsigned short data)
+{
+	unsigned short final = data;
+	if (little_endian_mode)
+	{
+		SWAP_IF_BIG(final);
+	}
+	else
+	{
+		SWAP_IF_LITTLE(final);
+	}
+	write(&amp;final, sizeof(unsigned short));
+}
+
+void CL_OutputSource::write_char8(char data)
+{
+	write(&amp;data, sizeof(char));
+}
+
+void CL_OutputSource::write_uchar8(unsigned char data)
+{
+	write(&amp;data, sizeof(unsigned char));
+}
+
+void CL_OutputSource::write_float32(float data)
+{
+	float final = data;
+	if (little_endian_mode)
+	{
+		SWAP_IF_BIG(final);
+	}
+	else
+	{
+		SWAP_IF_LITTLE(final);
+	}
+	write(&amp;final, sizeof(float));
+}
+
+void CL_OutputSource::write_float64(double data)
+{
+	double final = data;
+	if (little_endian_mode)
+	{
+		SWAP_IF_BIG(final);
+	}
+	else
+	{
+		SWAP_IF_LITTLE(final);
+	}
+	write(&amp;final, sizeof(double));
+}
+
+void CL_OutputSource::write_bool8(bool data)
+{
+	bool final = data;
+	if (little_endian_mode)
+	{
+		SWAP_IF_BIG(final);
+	}
+	else
+	{
+		SWAP_IF_LITTLE(final);
+	}
+	write(&amp;final, sizeof(bool));
+}
+
+void CL_OutputSource::write_string(const std::string &amp;str)
+{
+	int size = str.length();
+	write_int32(size);
+	write(str.data(), size);
+}

Added: trunk/clanlib/Core/IOData/Generic/outputsource_file.cpp
===================================================================
--- trunk/clanlib/Core/IOData/Generic/outputsource_file.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/Generic/outputsource_file.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,95 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/IOData/outputsource_file.h&quot;
+#include &quot;API/Core/System/cl_assert.h&quot;
+//#include &quot;API/Core/System/error.h&quot;
+
+CL_OutputSource_File::CL_OutputSource_File(const std::string &amp;_filename)
+{
+	filename = _filename;
+	pos = 0;
+	file = NULL;
+	open();
+}
+
+CL_OutputSource_File::CL_OutputSource_File()
+{
+	pos = 0;
+	file = NULL;
+}
+
+CL_OutputSource_File::~CL_OutputSource_File()
+{
+	close();
+}
+
+int CL_OutputSource_File::write(const void *data, int size)
+{
+	cl_assert(file != NULL);
+	fwrite(data, size, 1, file);
+	pos += size;
+	return size;
+}
+
+void CL_OutputSource_File::open()
+{
+	if(file != NULL)
+		return;
+
+	file = fopen(filename.c_str(), &quot;w+b&quot;);
+	if(file == NULL)
+		throw CL_Error(&quot;could not create file&quot;);
+}
+
+void CL_OutputSource_File::close()
+{
+	if(file == NULL)
+		return;
+
+	fclose(file);
+	file = NULL;
+}
+
+CL_OutputSource *CL_OutputSource_File::clone()
+{
+	cl_assert(false); // not implemented yet.
+	return NULL;
+}
+
+int CL_OutputSource_File::tell() const
+{
+	return pos;
+}
+
+int CL_OutputSource_File::size() const
+{
+	return pos;
+}

Added: trunk/clanlib/Core/IOData/Generic/outputsource_memory_generic.cpp
===================================================================
--- trunk/clanlib/Core/IOData/Generic/outputsource_memory_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/Generic/outputsource_memory_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,101 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+
+#include &quot;API/Core/System/cl_assert.h&quot;
+#include &lt;API/Core/IOData/outputsource.h&gt;
+#include &quot;outputsource_memory_generic.h&quot;
+
+CL_OutputSource_MemoryGeneric::CL_OutputSource_MemoryGeneric(unsigned int blocksize)
+{
+	m_blocksize = blocksize;
+	m_size = m_blocksize;
+	m_data = new unsigned char[m_blocksize];
+	m_pos = 0;
+}
+
+CL_OutputSource_MemoryGeneric::~CL_OutputSource_MemoryGeneric()
+{
+	delete[] m_data;
+}
+
+void *CL_OutputSource_MemoryGeneric::get_data() const
+{
+	return (void *) m_data;
+}
+
+int CL_OutputSource_MemoryGeneric::write(const void *data, int size)
+{
+	if (m_pos + size &gt; m_size) // extend array with blocksize
+	{
+		int new_size = m_size + size + m_blocksize;
+
+		unsigned char *old = m_data;
+		m_data = new unsigned char[new_size];
+
+		memcpy(m_data, old, m_pos);
+		delete[] old;
+		m_size = new_size;
+	}
+	
+	memcpy(m_data + m_pos, data, size);
+	m_pos += size;
+	
+	return size;
+}
+
+void CL_OutputSource_MemoryGeneric::open()
+{
+}
+
+void CL_OutputSource_MemoryGeneric::close()
+{
+}
+
+CL_OutputSource *CL_OutputSource_MemoryGeneric::clone()
+{
+	cl_assert(false); // not implemented yet.
+	return NULL;
+}
+
+int CL_OutputSource_MemoryGeneric::tell() const
+{
+	return m_pos;
+}
+
+int CL_OutputSource_MemoryGeneric::size() const
+{
+	return m_pos;
+}
+
+void CL_OutputSource_MemoryGeneric::purge()
+{
+	memset(m_data,0,m_size);
+}

Added: trunk/clanlib/Core/IOData/Generic/outputsource_memory_generic.h
===================================================================
--- trunk/clanlib/Core/IOData/Generic/outputsource_memory_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/Generic/outputsource_memory_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,84 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_outputsource_memory_generic
+#define header_outputsource_memory_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/IOData/outputsource.h&quot;
+
+//: Outputsource writing to memory_generic.
+class CL_OutputSource_MemoryGeneric : public CL_OutputSource
+{
+public:
+	CL_OutputSource_MemoryGeneric(unsigned int blocksize = 4*1024);
+	virtual ~CL_OutputSource_MemoryGeneric();
+	
+	//: Get the pointer to the internal data array in the memory_generic source.
+	//: Used to extract the data after usage.
+	//return: Pointer to the data written.
+	void *get_data() const;
+
+	//: Writes larger amounts of data (no endian and 64 bit conversion):
+	//param data: Points to the array written.
+	//param size: Number of bytes to write.
+	//return: Num bytes actually written.
+	virtual int write(const void *data, int size);
+	
+	//: Opens the output source. By default, it is open.
+	virtual void open();
+	
+	//: Closes the output source.
+	virtual void close();
+
+	//: Make a copy of the current OutputSource, standing at the same position.
+	//return: The copy of the output source.
+	virtual CL_OutputSource *clone();
+
+	//: Returns current position in output source.
+	//return: Current position in source.
+	virtual int tell() const;
+
+	//: Returns the size of the output source
+	//return: Current size of output source.
+	virtual int size() const;
+
+	//: Cleans out the databuffer without deleting it.
+	virtual void purge();
+
+private:
+	unsigned int m_blocksize;
+	unsigned char *m_data;
+	unsigned int m_size, m_pos;
+};
+
+#endif

Added: trunk/clanlib/Core/IOData/Generic/outputsource_zipped.cpp
===================================================================
--- trunk/clanlib/Core/IOData/Generic/outputsource_zipped.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/Generic/outputsource_zipped.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,119 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/IOData/outputsource_zipped.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OutputSource_Zipped_Generic
+
+class CL_OutputSource_Zipped_Generic
+{
+public:
+	CL_OutputSource *output;
+	bool delete_output;
+	int pos;
+	int length;
+};
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_OutputSource_Zipped::CL_OutputSource_Zipped(
+	CL_OutputSource *output,
+	bool delete_output)
+:
+	impl(new CL_OutputSource_Zipped_Generic)
+{
+	impl-&gt;output = output;
+	impl-&gt;delete_output = delete_output;
+	impl-&gt;pos = 0;
+	impl-&gt;length = 0;
+}
+
+CL_OutputSource_Zipped::CL_OutputSource_Zipped(
+	const CL_OutputSource_Zipped &amp;copy)
+:
+	impl(new CL_OutputSource_Zipped_Generic)
+{
+	impl-&gt;output = copy.impl-&gt;output-&gt;clone();
+	impl-&gt;delete_output = true;
+	impl-&gt;pos = copy.impl-&gt;pos;
+	impl-&gt;length = copy.impl-&gt;length;
+}
+
+CL_OutputSource_Zipped::~CL_OutputSource_Zipped()
+{
+	if (impl-&gt;delete_output) delete impl-&gt;output;
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+int CL_OutputSource_Zipped::tell() const
+{
+	return impl-&gt;pos;
+}
+
+int CL_OutputSource_Zipped::size() const
+{
+	return impl-&gt;length;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+int CL_OutputSource_Zipped::write(const void *data, int size)
+{
+	int written = impl-&gt;output-&gt;write(data, size);
+	impl-&gt;pos += written;
+	impl-&gt;length += written;
+	return written;
+}
+
+void CL_OutputSource_Zipped::open()
+{
+	impl-&gt;output-&gt;open();
+	impl-&gt;pos = 0;
+	impl-&gt;length = 0;
+}
+
+void CL_OutputSource_Zipped::close()
+{
+	impl-&gt;output-&gt;close();
+}
+
+CL_OutputSource *CL_OutputSource_Zipped::clone()
+{
+	return new CL_OutputSource_Zipped(*this);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Implementation:

Added: trunk/clanlib/Core/IOData/Unix/directory_scanner_unix.cpp
===================================================================
--- trunk/clanlib/Core/IOData/Unix/directory_scanner_unix.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/Unix/directory_scanner_unix.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,156 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &lt;API/Core/System/error.h&gt;
+#ifdef HAVE_LIBGEN_H
+#include &lt;libgen.h&gt;
+#endif
+#include &lt;fnmatch.h&gt;
+#include &lt;unistd.h&gt;
+#include &quot;directory_scanner_unix.h&quot;
+
+CL_DirectoryScanner_Unix::CL_DirectoryScanner_Unix ()
+	: dir_temp (NULL), entry (NULL)
+{
+}
+
+bool CL_DirectoryScanner_Unix::scan (const std::string&amp; arg_path_name)
+{
+	path_name   = arg_path_name;
+	use_pattern = false;
+
+	if (path_name.empty ())
+	  path_name = &quot;.&quot;;
+
+	if(dir_temp)
+		closedir(dir_temp);
+
+	dir_temp = opendir(path_name.c_str());
+	if (dir_temp == NULL)
+		return false;
+	else
+		return true;
+}
+
+bool CL_DirectoryScanner_Unix::scan (const std::string&amp; arg_path_name, 
+				     const std::string&amp; arg_file_pattern)
+{
+	path_name    = arg_path_name;
+	file_pattern = arg_file_pattern;
+	use_pattern  = true;
+
+	if (path_name.empty ())
+	  path_name = &quot;.&quot;;
+
+	if(dir_temp)
+		closedir(dir_temp);
+
+	dir_temp = opendir(path_name.c_str());
+	if (dir_temp == NULL)
+		return false;
+	else
+		return true;
+}
+
+CL_DirectoryScanner_Unix::~CL_DirectoryScanner_Unix()
+{
+	if(dir_temp)
+		closedir(dir_temp);
+}
+
+std::string CL_DirectoryScanner_Unix::get_directory_path()
+{
+	return path_name;
+}
+
+int CL_DirectoryScanner_Unix::get_size()
+{
+	return (int)statbuf.st_size;
+}
+
+std::string CL_DirectoryScanner_Unix::get_name()
+{
+	return file_name;
+}
+
+std::string CL_DirectoryScanner_Unix::get_pathname()
+{
+	return path_name + &quot;/&quot; + file_name;
+}
+
+bool CL_DirectoryScanner_Unix::is_directory()
+{
+	return (statbuf.st_mode &amp; S_IFDIR);
+}
+
+bool CL_DirectoryScanner_Unix::is_hidden()
+{
+	return file_name[0] == '.' &amp;&amp; file_name[1] != 0 &amp;&amp; file_name[1] != '.';
+}
+
+bool CL_DirectoryScanner_Unix::is_readable()
+{
+	return access((path_name + &quot;/&quot; + file_name).c_str(), R_OK) == 0;
+}
+
+bool CL_DirectoryScanner_Unix::is_writable()
+{
+	return access((path_name + &quot;/&quot; + file_name).c_str(), W_OK) == 0;
+}
+
+bool CL_DirectoryScanner_Unix::next()
+{	
+	if(!dir_temp)
+	{
+		return false; //I removed the throw CL_Error() that was here, an invalid directory should return false instead of throw an exception,
+					  //to match the win32 version functionality -mrfun
+	}
+
+	entry = readdir(dir_temp);
+
+	if( entry == NULL )
+		return false;
+
+	file_name = entry-&gt;d_name;
+
+	if (stat((path_name + &quot;/&quot; + file_name).c_str(), &amp;statbuf) == -1)
+		memset(&amp;statbuf, 0, sizeof(statbuf));
+
+	if (use_pattern)
+	{
+		if (fnmatch(file_pattern.c_str(), file_name.c_str(), FNM_PATHNAME) == 0)
+			return true;
+		else
+			return next();
+	} else {
+		return true;
+	}
+}
+
+

Added: trunk/clanlib/Core/IOData/Unix/directory_scanner_unix.h
===================================================================
--- trunk/clanlib/Core/IOData/Unix/directory_scanner_unix.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/Unix/directory_scanner_unix.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,109 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_directory_scanner_unix
+#define header_directory_scanner_unix
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Generic/directory_scanner_generic.h&quot;
+
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;dirent.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;unistd.h&gt;
+
+class CL_DirectoryScanner_Unix : public CL_DirectoryScanner_Generic
+{
+//!Construction:
+public:
+	CL_DirectoryScanner_Unix();
+	~CL_DirectoryScanner_Unix();
+	
+	//: Construct directory scanner for the specified scan expression.
+	//: The scan expression only supports * and ? wildcards. Eg: &quot;gfx/*.jpg&quot;.
+//	CL_DirectoryScanner_Generic(const std::string &amp;scan_exp);
+
+	//: Copy constructor.
+//	CL_DirectoryScanner_Generic(const CL_DirectoryScanner &amp;copy);
+
+//!Attributes:
+public:
+	bool scan (const std::string&amp; pathname);
+	bool scan (const std::string&amp; pathname, const std::string&amp; pattern);
+
+	//: Returns the path of the directory being scanned.
+	std::string get_directory_path();
+
+	//: Returns the size of the current found file.
+	int get_size();
+
+	//: Returns the name of the current found file.
+	std::string get_name();
+	
+	//: Returns the name of the current found file, including the directory path.
+	std::string get_pathname();
+	
+	//: Returns true if filename is a directory.
+	bool is_directory();
+
+	//: Returns true if filename is hidden.
+	bool is_hidden();
+
+  	//: Returns true if file is readable by current user.
+	virtual bool is_readable();
+
+	//: Returns true if file is writable by current user.
+	virtual bool is_writable();
+	// todo: add other attributes of a file.
+
+//!Operations:
+public:
+	//: Copy assignment operator.
+	//CL_DirectoryScanner_Generic &amp;operator =(const CL_DirectoryScanner_Generic &amp;copy);
+
+	//: Find next file in directory scan. Returns false if no more files was found.
+	bool next();
+private:
+	DIR *dir_temp;
+	dirent *entry;
+	struct stat statbuf;
+
+	bool use_pattern;
+	//Path stored without the trailing slash
+	std::string file_name;
+	std::string path_name;
+	std::string file_pattern;
+
+};
+
+#endif

Added: trunk/clanlib/Core/IOData/Win32/directory_scanner_win32.cpp
===================================================================
--- trunk/clanlib/Core/IOData/Win32/directory_scanner_win32.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/Win32/directory_scanner_win32.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,177 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/System/cl_assert.h&quot;
+#include &quot;directory_scanner_win32.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DirectoryScanner_Win32 construction:
+
+CL_DirectoryScanner_Win32::CL_DirectoryScanner_Win32() 
+: handle(INVALID_HANDLE_VALUE), first_next(true)
+{
+}
+
+CL_DirectoryScanner_Win32::CL_DirectoryScanner_Win32(const CL_DirectoryScanner_Win32 &amp;copy) 
+: handle(INVALID_HANDLE_VALUE), first_next(true)
+{
+}
+
+CL_DirectoryScanner_Win32::~CL_DirectoryScanner_Win32()
+{
+	if (INVALID_HANDLE_VALUE) FindClose(handle);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DirectoryScanner_Win32 attributes:
+
+bool CL_DirectoryScanner_Win32::scan (const std::string &amp;pathname)
+{
+	return scan(pathname, &quot;*.*&quot;);
+}
+
+bool CL_DirectoryScanner_Win32::scan (const std::string &amp;pathname, const std::string&amp; pattern)
+{
+	if (handle != INVALID_HANDLE_VALUE)
+	{
+		FindClose(handle);
+		handle = INVALID_HANDLE_VALUE;
+	}
+/*
+	// Find the full path of the directory we are about to search:
+	int size_buffer = GetFullPathName(pathname, 0, 0, 0);
+	LPTSTR buffer = new TCHAR[size_buffer];
+	LPTSTR filepart = 0;
+	GetFullPathName(pathname, size_buffer, buffer, &amp;filepart);
+	full_pathname = path_with_ending_slash(buffer);
+	delete[] buffer;
+*/
+	directory_path = path_with_ending_slash(pathname);
+
+	// Start our search:
+	std::string filename = directory_path + pattern;
+	handle = FindFirstFile(filename.c_str (), &amp;fileinfo);
+	first_next = true;
+	return (handle != INVALID_HANDLE_VALUE);
+}
+
+std::string CL_DirectoryScanner_Win32::get_directory_path()
+{
+	return directory_path;
+}
+
+int CL_DirectoryScanner_Win32::get_size()
+{
+	return fileinfo.nFileSizeLow;
+}
+
+std::string CL_DirectoryScanner_Win32::get_name()
+{
+	if (first_next) return std::string();
+	return std::string(fileinfo.cFileName);
+}
+	
+std::string CL_DirectoryScanner_Win32::get_pathname()
+{
+	if (first_next) return std::string();
+	return directory_path + std::string(fileinfo.cFileName);
+}
+	
+bool CL_DirectoryScanner_Win32::is_directory()
+{
+	if (first_next) return false;
+	return (fileinfo.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY;
+}
+
+bool CL_DirectoryScanner_Win32::is_hidden()
+{
+	if (first_next) return false;
+	return (fileinfo.dwFileAttributes &amp; FILE_ATTRIBUTE_HIDDEN) == FILE_ATTRIBUTE_HIDDEN;
+}
+
+bool CL_DirectoryScanner_Win32::is_readable()
+{
+	if (first_next) return false;
+
+	HANDLE file = CreateFile(
+		get_pathname().c_str(),
+		GENERIC_READ,
+		FILE_SHARE_READ,
+		0,
+		OPEN_EXISTING,
+		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING,
+		0);
+
+	if (file != INVALID_HANDLE_VALUE) CloseHandle(file);
+	return file != INVALID_HANDLE_VALUE;
+}
+
+bool CL_DirectoryScanner_Win32::is_writable()
+{
+	if (first_next) return false;
+
+	HANDLE file = CreateFile(
+		get_pathname().c_str(),
+		GENERIC_READ,
+		FILE_SHARE_READ,
+		0,
+		OPEN_EXISTING,
+		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING,
+		0);
+
+	if (file != INVALID_HANDLE_VALUE) CloseHandle(file);
+	return file != INVALID_HANDLE_VALUE;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DirectoryScanner_Win32 operations:
+
+bool CL_DirectoryScanner_Win32::next() 
+{
+	if (handle == INVALID_HANDLE_VALUE) return false;
+	if (first_next)
+	{
+		first_next = false;
+		return true;
+	}
+
+	return FindNextFile(handle, &amp;fileinfo) == TRUE;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DirectoryScanner_Win32 implementation:
+
+std::string CL_DirectoryScanner_Win32::path_with_ending_slash(const std::string &amp;path)
+{
+	int len = path.length();
+	if (len == 0) return &quot;.\\&quot;;
+	if (path[len-1] == '/' || path[len-1] == '\\') return path;
+	return path + &quot;\\&quot;;
+}

Added: trunk/clanlib/Core/IOData/Win32/directory_scanner_win32.h
===================================================================
--- trunk/clanlib/Core/IOData/Win32/directory_scanner_win32.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/Win32/directory_scanner_win32.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,106 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_directory_scanner_win32
+#define header_directory_scanner_win32
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Generic/directory_scanner_generic.h&quot;
+
+#include &lt;io.h&gt;
+#include &lt;direct.h&gt;
+
+class CL_DirectoryScanner_Win32: public CL_DirectoryScanner_Generic
+{
+//! Construction:
+public:
+	//: Construct initial directory scanner.
+	CL_DirectoryScanner_Win32();
+
+	//: Copy constructor.
+	CL_DirectoryScanner_Win32(const CL_DirectoryScanner_Win32 &amp;copy);
+
+	virtual ~CL_DirectoryScanner_Win32();
+
+//! Attributes:
+public:
+	//: Scan for files in a directory.
+	virtual bool scan (const std::string &amp;pathname);
+
+	//: Scan for files matching a pattern.
+	virtual bool scan (const std::string &amp;pathname, const std::string &amp;pattern);
+
+	//: Returns the path of the directory being scanned.
+	virtual std::string get_directory_path();
+
+	//: Returns the size of the current found file.
+	virtual int get_size();
+
+	//: Returns the name of the current found file.
+	virtual std::string get_name();
+	
+	//: Returns the name of the current found file, including the directory path.
+	virtual std::string get_pathname();
+	
+	//: Returns true if filename is a directory.
+	virtual bool is_directory();
+
+	//: Returns true if filename is hidden.
+	virtual bool is_hidden();
+
+	//: Returns true if filename is readable.
+	virtual bool is_readable();
+
+	//: Returns true if filename is writable.
+	virtual bool is_writable();
+
+//! Operations:
+public:
+	//: Find next file in directory scan. Returns false if no more files was found.
+	virtual bool next();
+
+//! Implementation
+private:
+	std::string path_with_ending_slash(const std::string &amp;path);
+
+	WIN32_FIND_DATA fileinfo;
+
+	HANDLE handle;
+
+	bool first_next;
+
+	std::string scan_exp;
+
+	std::string directory_path;
+};
+
+#endif

Added: trunk/clanlib/Core/IOData/inputsource_memory.cpp
===================================================================
--- trunk/clanlib/Core/IOData/inputsource_memory.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/inputsource_memory.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,131 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &lt;API/Core/System/cl_assert.h&gt;
+#include &lt;API/Core/System/clanstring.h&gt;
+#include &lt;API/Core/IOData/inputsource_memory.h&gt;
+
+CL_InputSource_Memory::CL_InputSource_Memory(const std::string &amp;_data) : pos(0), str_data(_data)
+{
+	data = (unsigned char *) str_data.c_str();
+	data_size = str_data.size();
+}
+
+CL_InputSource_Memory::CL_InputSource_Memory(void *_data, int size, bool copy_data) : data((unsigned char *) _data), data_size(size), pos(0)
+{
+	if (copy_data)
+	{
+		str_data = std::string((char *) data, size);
+		data = (unsigned char *) str_data.c_str();
+	}
+}
+
+CL_InputSource_Memory::~CL_InputSource_Memory()
+{
+}
+
+int CL_InputSource_Memory::read(void *dest_data, int size)
+{
+	if (size &lt; 0)
+		return 0;
+
+	if (pos + size &gt; data_size)
+	{
+		size = data_size - pos;
+		if (size &lt;= 0)
+			return 0;
+	}
+
+	memcpy(dest_data, data + pos, size);
+	pos += size;
+
+	return size;
+}
+
+void CL_InputSource_Memory::open()
+{
+	pos = 0;
+}
+
+void CL_InputSource_Memory::close()
+{
+}
+
+CL_InputSource *CL_InputSource_Memory::clone() const
+{
+	return new CL_InputSource_Memory(data, data_size, true);
+}
+
+int CL_InputSource_Memory::tell() const
+{
+	return pos;
+}
+
+void CL_InputSource_Memory::seek(int new_pos, SeekEnum seek_type)
+{
+	switch (seek_type)
+	{
+	case seek_set:
+		pos = new_pos;
+		break;
+	
+	case seek_cur:
+		pos += new_pos;
+		break;
+	
+	case seek_end:
+		pos = data_size + new_pos;
+		break;
+	
+	default: // invalid seek type!
+		cl_assert(false);
+	}
+}
+
+int CL_InputSource_Memory::size() const
+{
+	return data_size;
+}
+
+void CL_InputSource_Memory::push_position()
+{
+	cl_assert(false); // not implemented yet.
+}
+
+void CL_InputSource_Memory::pop_position()
+{
+	cl_assert(false); // not implemented yet.
+}
+
+std::string CL_InputSource_Memory::get_data() const
+{
+	return str_data;
+}
+

Added: trunk/clanlib/Core/IOData/inputsource_zip_fileentry.cpp
===================================================================
--- trunk/clanlib/Core/IOData/inputsource_zip_fileentry.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/inputsource_zip_fileentry.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,290 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;inputsource_zip_fileentry.h&quot;
+#include &quot;zip_file_entry_generic.h&quot;
+#include &quot;zip_compression_method.h&quot;
+#include &quot;zip_flags.h&quot;
+#include &quot;API/Core/IOData/inputsource_file.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputSource_Zip_FileEntry construction:
+
+CL_InputSource_Zip_FileEntry::CL_InputSource_Zip_FileEntry(const std::string &amp;filename, const CL_Zip_FileEntry &amp;entry) : inputsource(new CL_InputSource_File(filename)), file_entry(entry)
+{
+	// indicate the file is little-endian
+	inputsource-&gt;set_little_endian_mode();
+	source_open = false;
+	open();
+}
+
+CL_InputSource_Zip_FileEntry::CL_InputSource_Zip_FileEntry(const CL_InputSource_Zip_FileEntry &amp;copy)
+{
+	inputsource = copy.inputsource-&gt;clone();
+	file_entry = copy.file_entry;
+	pos = copy.pos;
+	file_header = copy.file_header;
+}
+
+CL_InputSource_Zip_FileEntry::~CL_InputSource_Zip_FileEntry()
+{
+	delete inputsource;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputSource_Zip_FileEntry attributes:
+
+int CL_InputSource_Zip_FileEntry::tell() const
+{
+	return pos;
+}
+
+int CL_InputSource_Zip_FileEntry::size() const
+{
+	return file_header.uncompressed_size;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputSource_Zip_FileEntry operations:
+
+#define cl_min(a, b) (a &lt; b ? a : b)
+
+int CL_InputSource_Zip_FileEntry::read(void *data, int size)
+{
+	switch (file_header.compression_method)
+	{
+	case zip_compress_store: // no compression
+		{
+			int received = inputsource-&gt;read(data, cl_min(size, file_header.uncompressed_size - pos));
+			pos += received;
+			return received;
+		}
+		break;
+
+	case zip_compress_deflate:
+		zs.next_out = (Bytef *) data;
+		zs.avail_out = size;
+		// Continue feeding zlib data until we get our data:
+		while (zs.avail_out &gt; 0)
+		{
+			// zlib needs more data:
+			if (zs.avail_in == 0 &amp;&amp; compressed_pos &lt; file_header.compressed_size)
+			{
+				// Read some compressed data:
+				int received_input = 0;
+				while (received_input &lt; 16*1024)
+				{
+					received_input += inputsource-&gt;read(zbuffer, cl_min(16*1024, file_header.compressed_size - compressed_pos));
+					if (compressed_pos + received_input == file_header.compressed_size) break;
+				}
+				compressed_pos += received_input;
+
+				zs.next_in = (Bytef *) zbuffer;
+				zs.avail_in = received_input;
+			}
+
+			// Decompress data:
+			int result = inflate(&amp;zs, 0);
+			if (result == Z_STREAM_END) break;
+			if (result == Z_NEED_DICT) throw CL_Error(&quot;Zlib inflate wants a dictionary!&quot;);
+			if (result == Z_DATA_ERROR) throw CL_Error(&quot;Zip data stream is corrupted&quot;);
+			if (result == Z_STREAM_ERROR) throw CL_Error(&quot;Zip stream structure was inconsistent!&quot;);
+			if (result == Z_MEM_ERROR) throw CL_Error(&quot;Zlib did not have enough memory to decompress file!&quot;);
+			if (result == Z_BUF_ERROR) throw CL_Error(&quot;Not enough data in buffer when Z_FINISH was used&quot;);
+			if (result != Z_OK) throw CL_Error(&quot;Zlib inflate failed while decompressing zip file!&quot;);
+		}
+		pos += size - zs.avail_out;
+		return size - zs.avail_out;
+
+	case zip_compress_shrunk:
+	case zip_compress_expand_factor_1:
+	case zip_compress_expand_factor_2:
+	case zip_compress_expand_factor_3:
+	case zip_compress_expand_factor_4:
+	case zip_compress_implode:
+	case zip_compress_tokenize:
+	case zip_compress_deflate64:
+	case zip_compress_pkware_implode:
+		break;
+	}
+
+	return 0;
+}
+
+void CL_InputSource_Zip_FileEntry::open()
+{
+	if (source_open) return;
+
+	inputsource-&gt;open();
+	inputsource-&gt;seek(file_entry.impl-&gt;record.relative_offset_of_local_header, CL_InputSource::seek_set);
+	file_header.load(inputsource);
+	pos = 0;
+	compressed_pos = 0;
+
+	// Initialize decompression:
+	int result = 0;
+	switch (file_header.compression_method)
+	{
+	case zip_compress_store: // no compression
+		break;
+
+	case zip_compress_deflate:
+		memset(&amp;zs, 0, sizeof(z_stream));
+		zs.next_in = Z_NULL;
+		zs.avail_in = 0;
+		zs.zalloc = Z_NULL;
+		zs.zfree = Z_NULL;
+		zs.opaque = Z_NULL;
+		//result = inflateInit(&amp;zs);
+		result = inflateInit2(&amp;zs, -15); // Undocumented: if wbits is negative, zlib skips header check
+		if (result != Z_OK) throw CL_Error(&quot;Zlib inflateInit failed for zip index!&quot;);
+		break;
+
+	case zip_compress_shrunk:
+	case zip_compress_expand_factor_1:
+	case zip_compress_expand_factor_2:
+	case zip_compress_expand_factor_3:
+	case zip_compress_expand_factor_4:
+	case zip_compress_implode:
+	case zip_compress_tokenize:
+	case zip_compress_deflate64:
+	case zip_compress_pkware_implode:
+	default:
+		throw CL_Error(CL_String::format(&quot;Unsupported compression method %1&quot;, file_header.compression_method));
+	}
+
+	source_open = true;
+}
+
+void CL_InputSource_Zip_FileEntry::close()
+{
+	if (!source_open) return;
+
+	inputsource-&gt;close();
+
+	// Clean up decompression:
+	switch (file_header.compression_method)
+	{
+	case zip_compress_store: // no compression
+		break;
+
+	case zip_compress_deflate:
+		inflateEnd(&amp;zs);
+		break;
+
+	case zip_compress_shrunk:
+	case zip_compress_expand_factor_1:
+	case zip_compress_expand_factor_2:
+	case zip_compress_expand_factor_3:
+	case zip_compress_expand_factor_4:
+	case zip_compress_implode:
+	case zip_compress_tokenize:
+	case zip_compress_deflate64:
+	case zip_compress_pkware_implode:
+		break;
+	}
+
+	source_open = false;
+}
+
+CL_InputSource *CL_InputSource_Zip_FileEntry::clone() const
+{
+	return new CL_InputSource_Zip_FileEntry(*this);
+}
+
+void CL_InputSource_Zip_FileEntry::seek(int seek_pos, SeekEnum seek_type)
+{
+	int absolute_pos = 0;
+	switch (seek_type)
+	{
+	case seek_set:
+		absolute_pos = seek_pos;
+		break;
+
+	case seek_cur:
+		absolute_pos = pos + seek_pos;
+		break;
+
+	case seek_end:
+		absolute_pos = file_header.uncompressed_size + seek_pos;
+		break;
+	}
+
+	switch (file_header.compression_method)
+	{
+	case zip_compress_store: // no compression
+		inputsource-&gt;seek(absolute_pos-pos, seek_cur);
+		break;
+
+	case zip_compress_deflate:
+		// if backward seeking, restart at beginning of stream.
+		if (absolute_pos &lt; pos)
+		{
+			close();
+			open();
+		}
+
+		char buffer[1024];
+		while (absolute_pos &gt; pos)
+		{
+			int received = read(buffer, cl_min(absolute_pos-pos, 1024));
+			if (received == 0) break;
+		}
+		break;
+
+	case zip_compress_shrunk:
+	case zip_compress_expand_factor_1:
+	case zip_compress_expand_factor_2:
+	case zip_compress_expand_factor_3:
+	case zip_compress_expand_factor_4:
+	case zip_compress_implode:
+	case zip_compress_tokenize:
+	case zip_compress_deflate64:
+	case zip_compress_pkware_implode:
+		break;
+	}
+}
+
+void CL_InputSource_Zip_FileEntry::push_position()
+{
+	position_stack.push(pos);
+	inputsource-&gt;push_position();
+}
+
+void CL_InputSource_Zip_FileEntry::pop_position()
+{
+	inputsource-&gt;pop_position();
+	pos = position_stack.top();
+	position_stack.pop();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputSource_Zip_FileEntry implementation:

Added: trunk/clanlib/Core/IOData/inputsource_zip_fileentry.h
===================================================================
--- trunk/clanlib/Core/IOData/inputsource_zip_fileentry.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/inputsource_zip_fileentry.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,94 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_inputsource_zip_fileentry
+#define header_inputsource_zip_fileentry
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/IOData/inputsource.h&quot;
+#include &quot;API/Core/IOData/zip_file_entry.h&quot;
+#include &quot;zip_local_file_header.h&quot;
+#include &lt;stack&gt;
+#include &lt;zlib.h&gt;
+
+class CL_InputSource_Zip_FileEntry : public CL_InputSource
+{
+//! Construction:
+public:
+	CL_InputSource_Zip_FileEntry(const std::string &amp;filename, const CL_Zip_FileEntry &amp;entry);
+
+	CL_InputSource_Zip_FileEntry(const CL_InputSource_Zip_FileEntry &amp;copy);
+
+	virtual ~CL_InputSource_Zip_FileEntry();
+
+//! Attributes:
+public:
+	virtual int tell() const;
+
+	virtual int size() const;
+
+//! Operations:
+public:
+	virtual int read(void *data, int size);
+
+	virtual void open();
+
+	virtual void close();
+
+	virtual CL_InputSource *clone() const;
+
+	virtual void seek(int pos, SeekEnum seek_type);
+
+	virtual void push_position();
+
+	virtual void pop_position();
+
+//! Implementation:
+private:
+	CL_InputSource *inputsource;
+
+	CL_Zip_FileEntry file_entry;
+
+	CL_Zip_LocalFileHeader file_header;
+
+	cl_int64 pos, compressed_pos;
+
+	z_stream zs;
+
+	std::stack&lt;cl_int64&gt; position_stack;
+
+	bool source_open;
+
+	char zbuffer[16*1024];
+};
+
+#endif

Added: trunk/clanlib/Core/IOData/outputsource_memory.cpp
===================================================================
--- trunk/clanlib/Core/IOData/outputsource_memory.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/outputsource_memory.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,78 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &lt;API/Core/System/cl_assert.h&gt;
+#include &lt;API/Core/IOData/outputsource_memory.h&gt;
+
+CL_OutputSource_Memory::CL_OutputSource_Memory()
+{
+	pos = 0;
+}
+
+CL_OutputSource_Memory::~CL_OutputSource_Memory()
+{
+}
+
+std::string CL_OutputSource_Memory::get_data() const
+{
+	return data;
+}
+
+int CL_OutputSource_Memory::write(const void *source_data, int size)
+{
+	data.append((const char *) source_data, size);
+	pos += size;
+	
+	return size;
+}
+
+void CL_OutputSource_Memory::open()
+{
+}
+
+void CL_OutputSource_Memory::close()
+{
+}
+
+CL_OutputSource *CL_OutputSource_Memory::clone()
+{
+	cl_assert(false); // not implemented yet.
+	return NULL;
+}
+
+int CL_OutputSource_Memory::tell() const 
+{
+	return pos;
+}
+
+int CL_OutputSource_Memory::size() const 
+{
+	return pos;
+}

Added: trunk/clanlib/Core/IOData/zip_64_end_of_central_directory_locator.cpp
===================================================================
--- trunk/clanlib/Core/IOData/zip_64_end_of_central_directory_locator.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/zip_64_end_of_central_directory_locator.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,77 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;zip_64_end_of_central_directory_locator.h&quot;
+#include &quot;API/Core/IOData/inputsource.h&quot;
+#include &quot;API/Core/IOData/outputsource.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_64EndOfCentralDirectoryLocator construction:
+
+CL_Zip_64EndOfCentralDirectoryLocator::CL_Zip_64EndOfCentralDirectoryLocator()
+{
+	signature = 0x07064b50;
+}
+	
+CL_Zip_64EndOfCentralDirectoryLocator::~CL_Zip_64EndOfCentralDirectoryLocator()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////	
+// CL_Zip_64EndOfCentralDirectoryLocator attributes:
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_64EndOfCentralDirectoryLocator operations:
+
+void CL_Zip_64EndOfCentralDirectoryLocator::load(CL_InputSource *input)
+{
+	signature = input-&gt;read_int32();
+	if (signature != 0x07064b50)
+	{
+		throw CL_Error(&quot;Incorrect Zip64 End of central directory locator signature!&quot;);
+	}
+	
+	number_of_disk_with_zip64_end_of_central_directory = input-&gt;read_int32();
+	relative_offset_of_zip64_end_of_central_directory = input-&gt;read_int64();
+	total_number_of_disks = input-&gt;read_int32();
+}
+	
+void CL_Zip_64EndOfCentralDirectoryLocator::save(CL_OutputSource *output)
+{
+	output-&gt;write_int32(signature);
+	output-&gt;write_int32(number_of_disk_with_zip64_end_of_central_directory);
+	output-&gt;write_int64(relative_offset_of_zip64_end_of_central_directory);
+	output-&gt;write_int32(total_number_of_disks);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_64EndOfCentralDirectoryLocator implementation:
+

Added: trunk/clanlib/Core/IOData/zip_64_end_of_central_directory_locator.h
===================================================================
--- trunk/clanlib/Core/IOData/zip_64_end_of_central_directory_locator.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/zip_64_end_of_central_directory_locator.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,70 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_zip_64_end_of_central_directory_locator
+#define header_zip_64_end_of_central_directory_locator
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/IOData/datatypes.h&quot;
+
+class CL_InputSource;
+class CL_OutputSource;
+
+class CL_Zip_64EndOfCentralDirectoryLocator
+{
+//! Construction:
+public:
+	CL_Zip_64EndOfCentralDirectoryLocator();
+	
+	~CL_Zip_64EndOfCentralDirectoryLocator();
+	
+//! Attributes:
+public:
+	cl_int32 signature; // 0x07064b50
+
+	cl_int32 number_of_disk_with_zip64_end_of_central_directory;
+
+	cl_int64 relative_offset_of_zip64_end_of_central_directory;
+
+	cl_int32 total_number_of_disks;
+
+//! Operations:
+public:
+	void load(CL_InputSource *input);
+	
+	void save(CL_OutputSource *output);
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/Core/IOData/zip_64_end_of_central_directory_record.cpp
===================================================================
--- trunk/clanlib/Core/IOData/zip_64_end_of_central_directory_record.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/zip_64_end_of_central_directory_record.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,91 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;zip_64_end_of_central_directory_record.h&quot;
+#include &quot;API/Core/IOData/inputsource.h&quot;
+#include &quot;API/Core/IOData/outputsource.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_64EndOfCentralDirectoryRecord construction:
+
+CL_Zip_64EndOfCentralDirectoryRecord::CL_Zip_64EndOfCentralDirectoryRecord()
+{
+	signature = 0x06064b50;
+}
+	
+CL_Zip_64EndOfCentralDirectoryRecord::~CL_Zip_64EndOfCentralDirectoryRecord()
+{
+}
+	
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_64EndOfCentralDirectoryRecord attributes:
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_64EndOfCentralDirectoryRecord operations:
+
+void CL_Zip_64EndOfCentralDirectoryRecord::load(CL_InputSource *input)
+{
+	signature = input-&gt;read_int32();
+	if (signature != 0x06064b50)
+	{
+		throw CL_Error(&quot;Incorrect Zip64 End of Central Directory Record signature&quot;);
+	}
+	
+	size_of_record = input-&gt;read_int64();
+	version_made_by = input-&gt;read_int16();
+	version_needed_to_extract = input-&gt;read_int16();
+	number_of_this_disk = input-&gt;read_int32();
+	number_of_disk_with_central_directory_start = input-&gt;read_int32();
+	number_of_entries_on_this_disk = input-&gt;read_int64();
+	number_of_entries_in_central_directory = input-&gt;read_int64();
+	size_of_central_directory = input-&gt;read_int64();
+	offset_to_start_of_central_directory = input-&gt;read_int64();
+	
+	// todo: read extensible data sector
+}
+	
+void CL_Zip_64EndOfCentralDirectoryRecord::save(CL_OutputSource *output)
+{
+	output-&gt;write_int32(signature);
+	output-&gt;write_int64(size_of_record);
+	output-&gt;write_int16(version_made_by);
+	output-&gt;write_int16(version_needed_to_extract);
+	output-&gt;write_int32(number_of_this_disk);
+	output-&gt;write_int32(number_of_disk_with_central_directory_start);
+	output-&gt;write_int64(number_of_entries_on_this_disk);
+	output-&gt;write_int64(number_of_entries_in_central_directory);
+	output-&gt;write_int64(size_of_central_directory);
+	output-&gt;write_int64(offset_to_start_of_central_directory);
+	output-&gt;write(extensible_data_sector.data(), extensible_data_sector.size());
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_64EndOfCentralDirectoryRecord implementation:

Added: trunk/clanlib/Core/IOData/zip_64_end_of_central_directory_record.h
===================================================================
--- trunk/clanlib/Core/IOData/zip_64_end_of_central_directory_record.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/zip_64_end_of_central_directory_record.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,84 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_zip_64_end_of_central_directory_record
+#define header_zip_64_end_of_central_directory_record
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/IOData/datatypes.h&quot;
+
+class CL_InputSource;
+class CL_OutputSource;
+
+class CL_Zip_64EndOfCentralDirectoryRecord
+{
+//! Construction:
+public:
+	CL_Zip_64EndOfCentralDirectoryRecord();
+	
+	~CL_Zip_64EndOfCentralDirectoryRecord();
+	
+//! Attributes:
+public:
+	cl_int32 signature; // 0x06064b50
+	
+	cl_int64 size_of_record;
+	
+	cl_int16 version_made_by;
+	
+	cl_int16 version_needed_to_extract;
+	
+	cl_int32 number_of_this_disk;
+	
+	cl_int32 number_of_disk_with_central_directory_start;
+	
+	cl_int64 number_of_entries_on_this_disk;
+	
+	cl_int64 number_of_entries_in_central_directory;
+	
+	cl_int64 size_of_central_directory;
+	
+	cl_int64 offset_to_start_of_central_directory;
+	
+	std::string extensible_data_sector;
+	
+//! Operations:
+public:
+	void load(CL_InputSource *input);
+	
+	void save(CL_OutputSource *output);
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/Core/IOData/zip_archive.cpp
===================================================================
--- trunk/clanlib/Core/IOData/zip_archive.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/zip_archive.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,214 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/IOData/zip_archive.h&quot;
+#include &quot;API/Core/IOData/inputsource_file.h&quot;
+#include &quot;API/Core/IOData/inputsource_memory.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;zip_archive_generic.h&quot;
+#include &quot;zip_file_header.h&quot;
+#include &quot;zip_64_end_of_central_directory_record.h&quot;
+#include &quot;zip_64_end_of_central_directory_locator.h&quot;
+#include &quot;zip_end_of_central_directory_record.h&quot;
+#include &quot;zip_file_entry_generic.h&quot;
+#include &quot;inputsource_zip_fileentry.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_Archive construction:
+
+CL_Zip_Archive::CL_Zip_Archive() : impl(new CL_Zip_Archive_Generic)
+{
+}
+	
+CL_Zip_Archive::CL_Zip_Archive(const std::string &amp;filename) : impl(new CL_Zip_Archive_Generic)
+{
+	impl-&gt;filename = filename;
+
+	// Load zip file structures:
+
+	CL_InputSource *input = new CL_InputSource_File(filename);
+	
+	// indicate the file is little-endian
+	input-&gt;set_little_endian_mode();
+	
+	// Find end of central directory record:
+
+	int size_file = input-&gt;size();
+	
+	char buffer[32*1024];
+	if (size_file &gt; 32*1024) input-&gt;seek(-32*1024, CL_InputSource::seek_end);
+	int size_buffer = input-&gt;read(buffer, 32*1024);
+	
+	int end_record_pos = -1;
+	for (int pos = size_buffer-4; pos &gt;= 0; pos--)
+	{
+		if( buffer[pos] == 0x50 &amp;&amp; buffer[pos+1] == 0x4b &amp;&amp; buffer[pos+2] == 0x05  &amp;&amp; buffer[pos+3] == 0x06 )
+		{
+			end_record_pos = size_file-size_buffer+pos;
+			input-&gt;tell();
+			break;
+		}
+	}
+	if (end_record_pos == -1)
+	{
+		delete input;
+		throw CL_Error(&quot;This appear not to be a zip file&quot;);
+	}
+	
+	// Load end of central directory record:
+	
+	CL_Zip_EndOfCentralDirectoryRecord end_of_directory;
+	input-&gt;seek(end_record_pos, CL_InputSource::seek_set);
+	end_of_directory.load(input);
+	
+	// Look for zip64 central directory locator:
+	
+	bool zip64 = false;
+	CL_Zip_64EndOfCentralDirectoryLocator zip64_locator;
+	CL_Zip_64EndOfCentralDirectoryRecord zip64_end_of_directory;
+	
+	int end64_locator = end_record_pos-20;
+	input-&gt;seek(end64_locator, CL_InputSource::seek_set);
+	if (input-&gt;read_uint32() == 0x07064b50)
+	{
+		// Load zip64 structures:
+		
+		input-&gt;seek(end64_locator, CL_InputSource::seek_set);
+		zip64_locator.load(input);
+		
+		input-&gt;seek(end64_locator+zip64_locator.relative_offset_of_zip64_end_of_central_directory, CL_InputSource::seek_set);
+		zip64_end_of_directory.load(input);
+		
+		zip64 = true;
+	}
+	
+	// Load central directory records:
+	
+	if (zip64) input-&gt;seek(zip64_end_of_directory.offset_to_start_of_central_directory, CL_InputSource::seek_set);
+	else input-&gt;seek(end_of_directory.offset_to_start_of_central_directory, CL_InputSource::seek_set);
+	
+	cl_int64 num_entries = end_of_directory.number_of_entries_in_central_directory;
+	if (zip64) num_entries = zip64_end_of_directory.number_of_entries_in_central_directory;
+
+	for (int i=0; i&lt;num_entries; i++)
+	{
+		CL_Zip_FileEntry entry;
+		entry.impl-&gt;record.load(input);
+		impl-&gt;files.push_back(entry);
+	}
+
+	delete input;
+}
+
+CL_Zip_Archive::CL_Zip_Archive(const CL_Zip_Archive &amp;copy) : impl(copy.impl)
+{
+}
+	
+CL_Zip_Archive::~CL_Zip_Archive()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_Archive attributes:
+
+std::vector&lt;CL_Zip_FileEntry&gt; &amp;CL_Zip_Archive::get_file_list()
+{
+	return impl-&gt;files;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_Archive operations:
+
+CL_InputSource *CL_Zip_Archive::open_source(const std::string &amp;filename)
+{
+	int size = impl-&gt;files.size();
+	for (int i=0; i&lt;size; i++)
+	{
+		CL_Zip_FileEntry &amp;entry = impl-&gt;files[i];
+		if (entry.impl-&gt;record.filename == filename)
+		{
+			switch (entry.impl-&gt;type)
+			{
+			case CL_Zip_FileEntry_Generic::type_file:
+				return new CL_InputSource_Zip_FileEntry(impl-&gt;filename, entry);
+
+			case CL_Zip_FileEntry_Generic::type_removed:
+				break;
+
+			case CL_Zip_FileEntry_Generic::type_added_memory:
+				return new CL_InputSource_Memory(entry.impl-&gt;data);
+
+			case CL_Zip_FileEntry_Generic::type_added_file:
+				return new CL_InputSource_File(entry.impl-&gt;filename);
+			}
+			throw CL_Error(CL_String::format(&quot;Found but hates %1&quot;, filename));
+		}
+	}
+	throw CL_Error(CL_String::format(&quot;Unable to find zip index %1&quot;, filename));
+	return 0;
+}
+
+CL_InputSourceProvider *CL_Zip_Archive::clone()
+{
+	return new CL_Zip_Archive(*this);
+}
+
+std::string CL_Zip_Archive::get_pathname(const std::string &amp;filename)
+{
+	return filename;
+}
+
+CL_InputSourceProvider *CL_Zip_Archive::create_relative(const std::string &amp;path)
+{
+	// This is wrong. Should seperate the inputsource provider from CL_Zip_Archive,
+	// but don't really bother doing it right now.
+	// -- mbn may 10, 2003
+	return clone();
+}
+
+CL_OutputSource *CL_Zip_Archive::create_file(const std::string &amp;filename, bool compress)
+{
+	return 0;
+}
+
+void CL_Zip_Archive::add_file(const std::string &amp;filename, bool compress)
+{
+}
+
+void CL_Zip_Archive::save()
+{
+}
+	
+void CL_Zip_Archive::save(const std::string &amp;filename)
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_Archive implementation:

Added: trunk/clanlib/Core/IOData/zip_archive_generic.h
===================================================================
--- trunk/clanlib/Core/IOData/zip_archive_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/zip_archive_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,58 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_zip_archive_generic
+#define header_zip_archive_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/IOData/zip_file_entry.h&quot;
+
+class CL_Zip_Archive_Generic
+{
+//! Construction:
+public:
+	CL_Zip_Archive_Generic() { return; }
+
+//! Attributes:
+public:
+	std::vector&lt;CL_Zip_FileEntry&gt; files;
+
+	std::string filename;
+
+//! Operations:
+public:
+	
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/Core/IOData/zip_compression_method.h
===================================================================
--- trunk/clanlib/Core/IOData/zip_compression_method.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/zip_compression_method.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,52 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_zip_compression_method
+#define header_zip_compression_method
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+enum CL_Zip_CompressionMethod
+{
+	zip_compress_store, // no compression
+	zip_compress_shrunk,
+	zip_compress_expand_factor_1,
+	zip_compress_expand_factor_2,
+	zip_compress_expand_factor_3,
+	zip_compress_expand_factor_4,
+	zip_compress_implode,
+	zip_compress_tokenize,
+	zip_compress_deflate,
+	zip_compress_deflate64,
+	zip_compress_pkware_implode
+};
+
+#endif

Added: trunk/clanlib/Core/IOData/zip_digital_signature.cpp
===================================================================
--- trunk/clanlib/Core/IOData/zip_digital_signature.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/zip_digital_signature.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,86 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;zip_digital_signature.h&quot;
+#include &quot;API/Core/IOData/inputsource.h&quot;
+#include &quot;API/Core/IOData/outputsource.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_DigitalSignature construction:
+
+CL_Zip_DigitalSignature::CL_Zip_DigitalSignature()
+{
+	signature = 0x05054b50;
+}
+
+CL_Zip_DigitalSignature::~CL_Zip_DigitalSignature()
+{
+}
+	
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_DigitalSignature attributes:
+
+	
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_DigitalSignature operations:
+
+void CL_Zip_DigitalSignature::load(CL_InputSource *input)
+{
+	signature = input-&gt;read_int32();
+	if (signature != 0x05054b50)
+	{
+		throw CL_Error(&quot;Incorrect Digital Signature signature!&quot;);
+	}
+
+	size_of_data = input-&gt;read_short16();
+
+	char *str = new char[size_of_data];
+	try
+	{
+		input-&gt;read(str, size_of_data);
+		signature_data = std::string(str, size_of_data);
+
+		delete[] str;
+	}
+	catch (...)
+	{
+		delete[] str;
+	}
+}
+	
+void CL_Zip_DigitalSignature::save(CL_OutputSource *output)
+{
+	output-&gt;write_int32(signature);
+	output-&gt;write_short16(size_of_data);
+	output-&gt;write(signature_data.data(), size_of_data);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_DigitalSignature implementation:

Added: trunk/clanlib/Core/IOData/zip_digital_signature.h
===================================================================
--- trunk/clanlib/Core/IOData/zip_digital_signature.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/zip_digital_signature.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,64 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef zip_digital_signature
+#define zip_digital_signature
+
+#include &quot;API/Core/IOData/datatypes.h&quot;
+
+class CL_InputSource;
+class CL_OutputSource;
+
+class CL_Zip_DigitalSignature
+{
+//! Construction:
+public:
+	CL_Zip_DigitalSignature();
+	
+	~CL_Zip_DigitalSignature();
+	
+//! Attributes:
+public:
+	cl_int32 signature; // 0x05054b50
+	
+	cl_int16 size_of_data;
+	
+	std::string signature_data;
+	
+//! Operations:
+public:
+	void load(CL_InputSource *input);
+	
+	void save(CL_OutputSource *output);
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/Core/IOData/zip_end_of_central_directory_record.cpp
===================================================================
--- trunk/clanlib/Core/IOData/zip_end_of_central_directory_record.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/zip_end_of_central_directory_record.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,100 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;zip_end_of_central_directory_record.h&quot;
+#include &quot;API/Core/IOData/inputsource.h&quot;
+#include &quot;API/Core/IOData/outputsource.h&quot;
+#include &quot;API/Core/IOData/cl_endian.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_EndOfCentralDirectoryRecord construction:
+
+CL_Zip_EndOfCentralDirectoryRecord::CL_Zip_EndOfCentralDirectoryRecord()
+{	
+	signature = 0x06054b50;
+	SWAP_IF_BIG(signature);
+}
+	
+CL_Zip_EndOfCentralDirectoryRecord::~CL_Zip_EndOfCentralDirectoryRecord()
+{
+}
+	
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_EndOfCentralDirectoryRecord attributes:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_EndOfCentralDirectoryRecord operations:
+
+void CL_Zip_EndOfCentralDirectoryRecord::load(CL_InputSource *input)
+{
+	signature = input-&gt;read_int32();
+	if (signature != 0x06054b50)
+	{
+		throw CL_Error(&quot;Incorrect End of Central Directory Record signature&quot;);
+	}
+	
+	number_of_this_disk = input-&gt;read_int16();
+	number_of_disk_with_start_of_central_directory = input-&gt;read_int16();
+	number_of_entries_on_this_disk = input-&gt;read_int16();
+	number_of_entries_in_central_directory = input-&gt;read_int16();
+	size_of_central_directory = input-&gt;read_int32();
+	offset_to_start_of_central_directory = input-&gt;read_int32();
+	file_comment_length = input-&gt;read_int16();
+
+	char *str = new char[file_comment_length];
+	try
+	{
+		input-&gt;read(str, file_comment_length);
+		file_comment = std::string(str, file_comment_length);
+
+		delete[] str;
+	}
+	catch (...)
+	{
+		delete[] str;
+		throw;
+	}
+}
+	
+void CL_Zip_EndOfCentralDirectoryRecord::save(CL_OutputSource *output)
+{
+	output-&gt;write_int32(signature);
+	output-&gt;write_int16(number_of_this_disk);
+	output-&gt;write_int16(number_of_disk_with_start_of_central_directory);
+	output-&gt;write_int16(number_of_entries_on_this_disk);
+	output-&gt;write_int16(number_of_entries_in_central_directory);
+	output-&gt;write_int32(size_of_central_directory);
+	output-&gt;write_int32(offset_to_start_of_central_directory);
+	output-&gt;write_int16(file_comment_length);
+	output-&gt;write(file_comment.data(), file_comment.length());
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_EndOfCentralDirectoryRecord implementation:

Added: trunk/clanlib/Core/IOData/zip_end_of_central_directory_record.h
===================================================================
--- trunk/clanlib/Core/IOData/zip_end_of_central_directory_record.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/zip_end_of_central_directory_record.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,80 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_zip_end_of_central_directory_record
+#define header_zip_end_of_central_directory_record
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/IOData/datatypes.h&quot;
+
+class CL_InputSource;
+class CL_OutputSource;
+
+class CL_Zip_EndOfCentralDirectoryRecord
+{
+//! Construction:
+public:
+	CL_Zip_EndOfCentralDirectoryRecord();
+	
+	~CL_Zip_EndOfCentralDirectoryRecord();
+	
+//! Attributes:
+public:
+	cl_int32 signature; // 0x06054b50
+
+	cl_int16 number_of_this_disk;
+
+	cl_int16 number_of_disk_with_start_of_central_directory;
+
+	cl_int16 number_of_entries_on_this_disk;
+
+	cl_int16 number_of_entries_in_central_directory;
+
+	cl_int32 size_of_central_directory;
+
+	cl_int32 offset_to_start_of_central_directory;
+
+	cl_int16 file_comment_length;
+
+	std::string file_comment;
+
+//! Operations:
+public:
+	void load(CL_InputSource *input);
+	
+	void save(CL_OutputSource *output);
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/Core/IOData/zip_file_entry.cpp
===================================================================
--- trunk/clanlib/Core/IOData/zip_file_entry.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/zip_file_entry.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,86 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/IOData/zip_file_entry.h&quot;
+#include &quot;zip_file_entry_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_FileEntry construction:
+
+CL_Zip_FileEntry::CL_Zip_FileEntry() : impl(new CL_Zip_FileEntry_Generic)
+{
+	impl-&gt;type = CL_Zip_FileEntry_Generic::type_file;
+}
+	
+CL_Zip_FileEntry::CL_Zip_FileEntry(const CL_Zip_FileEntry &amp;copy) : impl(new CL_Zip_FileEntry_Generic)
+{
+	*impl = *copy.impl;
+}
+	
+CL_Zip_FileEntry::~CL_Zip_FileEntry()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_FileEntry attributes:
+
+const std::string &amp;CL_Zip_FileEntry::get_filename() const
+{
+	return impl-&gt;record.filename;
+}
+	
+cl_int64 CL_Zip_FileEntry::get_uncompressed_size()
+{
+	return impl-&gt;record.uncompressed_size;
+}
+	
+cl_int64 CL_Zip_FileEntry::get_compressed_size()
+{
+	return impl-&gt;record.compressed_size;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_FileEntry operations:
+
+CL_Zip_FileEntry &amp;CL_Zip_FileEntry::operator =(const CL_Zip_FileEntry &amp;copy)
+{
+	*impl = *copy.impl;
+	return *this;
+}
+	
+void CL_Zip_FileEntry::set_filename(const std::string &amp;filename)
+{
+	impl-&gt;record.file_name_length = filename.length();
+	impl-&gt;record.filename = filename;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_FileEntry implementation:

Added: trunk/clanlib/Core/IOData/zip_file_entry_generic.h
===================================================================
--- trunk/clanlib/Core/IOData/zip_file_entry_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/zip_file_entry_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,69 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_zip_file_entry_generic
+#define header_zip_file_entry_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/IOData/datatypes.h&quot;
+#include &quot;zip_file_header.h&quot;
+
+class CL_Zip_FileEntry_Generic
+{
+//! Attributes:
+public:
+	//: Zip file entry type enum.
+	enum Type
+	{
+		type_file,
+		type_removed,
+		type_added_memory,
+		type_added_file
+	};
+	
+	//: Central directory record attributes for entry:
+	CL_Zip_FileHeader record;
+
+	//: File entry type.
+	Type type;
+	
+	//: Offset to zip data in zip file (type_file).
+	// cl_int64 offset;
+
+	//: Filename of file, if added from file (type_added_file).
+	std::string filename;
+	
+	//: Data of zip file entry, if added from memory (type_added_memory).
+	std::string data;
+};
+
+#endif

Added: trunk/clanlib/Core/IOData/zip_file_header.cpp
===================================================================
--- trunk/clanlib/Core/IOData/zip_file_header.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/zip_file_header.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,129 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;zip_file_header.h&quot;
+#include &quot;API/Core/IOData/inputsource.h&quot;
+#include &quot;API/Core/IOData/outputsource.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_FileHeader construction:
+
+CL_Zip_FileHeader::CL_Zip_FileHeader()
+{
+	signature = 0x02014b50;
+}
+	
+CL_Zip_FileHeader::~CL_Zip_FileHeader()
+{
+}
+	
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_FileHeader attributes:
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_FileHeader operations:
+
+void CL_Zip_FileHeader::load(CL_InputSource *input)
+{
+	signature = input-&gt;read_int32();
+	if (signature != 0x02014b50)
+	{
+		throw CL_Error(&quot;Incorrect File Header signature&quot;);
+	}
+	version_made_by = input-&gt;read_int16();
+	version_needed_to_extract = input-&gt;read_int16();
+	general_purpose_bit_flag = input-&gt;read_int16();
+	compression_method = input-&gt;read_int16();
+	last_mod_file_time = input-&gt;read_int16();
+	last_mod_file_date = input-&gt;read_int16();
+	crc32 = input-&gt;read_int32();
+	compressed_size = input-&gt;read_int32();
+	uncompressed_size = input-&gt;read_int32();
+	file_name_length = input-&gt;read_int16();
+	extra_field_length = input-&gt;read_int16();
+	file_comment_length = input-&gt;read_int16();
+	disk_number_start = input-&gt;read_int16();
+	internal_file_attributes = input-&gt;read_int16();
+	external_file_attributes = input-&gt;read_int32();
+	relative_offset_of_local_header = input-&gt;read_int32();
+	filename.resize(file_name_length);
+
+	char *str1 = new char[file_name_length];
+	char *str2 = new char[extra_field_length];
+	char *str3 = new char[file_comment_length];
+	try
+	{
+		input-&gt;read(str1, file_name_length);
+		input-&gt;read(str2, extra_field_length);
+		input-&gt;read(str3, file_comment_length);
+		filename = std::string(str1, file_name_length);
+		extra_field = std::string(str2, extra_field_length);
+		file_comment = std::string(str3, file_comment_length);
+
+		delete[] str1;
+		delete[] str2;
+		delete[] str3;
+	}
+	catch (...)
+	{
+		delete[] str1;
+		delete[] str2;
+		delete[] str3;
+		throw;
+	}
+}
+
+void CL_Zip_FileHeader::save(CL_OutputSource *output)
+{
+	output-&gt;write_int32(signature);
+	output-&gt;write_int16(version_made_by);
+	output-&gt;write_int16(version_needed_to_extract);
+	output-&gt;write_int16(general_purpose_bit_flag);
+	output-&gt;write_int16(compression_method);
+	output-&gt;write_int16(last_mod_file_time);
+	output-&gt;write_int16(last_mod_file_date);
+	output-&gt;write_int32(crc32);
+	output-&gt;write_int32(compressed_size);
+	output-&gt;write_int32(uncompressed_size);
+	output-&gt;write_int16(file_name_length);
+	output-&gt;write_int16(extra_field_length);
+	output-&gt;write_int16(file_comment_length);
+	output-&gt;write_int16(disk_number_start);
+	output-&gt;write_int16(internal_file_attributes);
+	output-&gt;write_int32(external_file_attributes);
+	output-&gt;write_int32(relative_offset_of_local_header);
+	output-&gt;write(filename.data(), file_name_length);
+	output-&gt;write(extra_field.data(), extra_field_length);
+	output-&gt;write(file_comment.data(), file_comment_length);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_FileHeader implementation:

Added: trunk/clanlib/Core/IOData/zip_file_header.h
===================================================================
--- trunk/clanlib/Core/IOData/zip_file_header.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/zip_file_header.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,102 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_zip_file_header
+#define header_zip_file_header
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/IOData/datatypes.h&quot;
+
+class CL_InputSource;
+class CL_OutputSource;
+
+class CL_Zip_FileHeader
+{
+//! Construction:
+public:
+	CL_Zip_FileHeader();
+	
+	~CL_Zip_FileHeader();
+	
+//! Attributes:
+public:
+	cl_int32 signature; // 0x02014b50
+	
+	cl_int16 version_made_by;
+	
+	cl_int16 version_needed_to_extract;
+	
+	cl_int16 general_purpose_bit_flag;
+	
+	cl_int16 compression_method;
+	
+	cl_int16 last_mod_file_time;
+	
+	cl_int16 last_mod_file_date;
+	
+	cl_int32 crc32;
+	
+	cl_int32 compressed_size;
+	
+	cl_int32 uncompressed_size;
+	
+	cl_int16 file_name_length;
+	
+	cl_int16 extra_field_length;
+	
+	cl_int16 file_comment_length;
+	
+	cl_int16 disk_number_start;
+	
+	cl_int16 internal_file_attributes;
+	
+	cl_int32 external_file_attributes;
+	
+	cl_int32 relative_offset_of_local_header;
+	
+	std::string filename;
+	
+	std::string extra_field;
+	
+	std::string file_comment;
+	
+//! Operations:
+public:
+	void load(CL_InputSource *input);
+	
+	void save(CL_OutputSource *output);
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/Core/IOData/zip_flags.h
===================================================================
--- trunk/clanlib/Core/IOData/zip_flags.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/zip_flags.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,59 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef zip_flags
+#define zip_flags
+
+// Version from which Zip64 was introduced
+#define CL_ZIP_64Version 45
+
+// General purpose flags:
+#define CL_ZIP_ENCRYPTED                        1
+
+#define CL_ZIP_IMPLODE_8K_SLIDING_DICT          2
+#define CL_ZIP_IMPLODE_3_SHANNON_FANO_TREES     4
+
+#define CL_ZIP_DEFLATE_COMPRESS_MAXIMUM         2
+#define CL_ZIP_DEFLATE_COMPRESS_FAST            4
+#define CL_ZIP_DEFLATE_COMPRESS_SUPER_FAST      6
+
+#define CL_ZIP_CRC32_IN_FILE_DESCRIPTOR         8
+#define CL_ZIP_DEFLATE64_RESERVED              16
+#define CL_ZIP_FILE_IS_COMPRESSED_PATCHED_DATA 32
+
+// CRC-32 properties:
+
+#define CL_ZIP_CRC_MAGIC_NUMBER 0xdebb20e3
+#define CL_ZIP_CRC_START_VALUE 0xffffffff
+
+// File attributes:
+
+#define CL_ZIP_FILE_ATTR_TEXT 1
+
+#endif

Added: trunk/clanlib/Core/IOData/zip_local_file_descriptor.cpp
===================================================================
--- trunk/clanlib/Core/IOData/zip_local_file_descriptor.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/zip_local_file_descriptor.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,68 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;zip_local_file_descriptor.h&quot;
+#include &quot;API/Core/IOData/inputsource.h&quot;
+#include &quot;API/Core/IOData/outputsource.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_LocalFileDescriptor construction:
+
+CL_Zip_LocalFileDescriptor::CL_Zip_LocalFileDescriptor()
+{
+}
+	
+CL_Zip_LocalFileDescriptor::~CL_Zip_LocalFileDescriptor()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_LocalFileDescriptor attributes:
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_LocalFileDescriptor operations:
+
+void CL_Zip_LocalFileDescriptor::load(CL_InputSource *input)
+{
+	crc32 = input-&gt;read_int32();
+	compressed_size = input-&gt;read_int32();
+	uncompressed_size = input-&gt;read_int32();
+}
+	
+void CL_Zip_LocalFileDescriptor::save(CL_OutputSource *output)
+{
+	output-&gt;write_int32(crc32);
+	output-&gt;write_int32(compressed_size);
+	output-&gt;write_int32(uncompressed_size);
+}
+	
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_LocalFileDescriptor implementation:

Added: trunk/clanlib/Core/IOData/zip_local_file_descriptor.h
===================================================================
--- trunk/clanlib/Core/IOData/zip_local_file_descriptor.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/zip_local_file_descriptor.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,68 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_zip_local_file_descriptor
+#define header_zip_local_file_descriptor
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/IOData/datatypes.h&quot;
+
+class CL_InputSource;
+class CL_OutputSource;
+
+class CL_Zip_LocalFileDescriptor
+{
+//! Construction:
+public:
+	CL_Zip_LocalFileDescriptor();
+	
+	~CL_Zip_LocalFileDescriptor();
+
+//! Attributes:
+public:
+	cl_int32 crc32;
+	
+	cl_int32 compressed_size;
+
+	cl_int32 uncompressed_size;
+	
+//! Operations:
+public:
+	void load(CL_InputSource *input);
+	
+	void save(CL_OutputSource *output);
+	
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/Core/IOData/zip_local_file_header.cpp
===================================================================
--- trunk/clanlib/Core/IOData/zip_local_file_header.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/zip_local_file_header.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,96 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;zip_local_file_header.h&quot;
+#include &quot;API/Core/IOData/inputsource.h&quot;
+#include &quot;API/Core/IOData/outputsource.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_LocalFileHeader construction:
+
+CL_Zip_LocalFileHeader::CL_Zip_LocalFileHeader()
+{
+	signature = 0x04034b50;
+}
+	
+CL_Zip_LocalFileHeader::~CL_Zip_LocalFileHeader()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_LocalFileHeader attributes:
+
+	
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_LocalFileHeader operations:
+
+void CL_Zip_LocalFileHeader::load(CL_InputSource *input)
+{
+	signature = input-&gt;read_int32();
+	if (signature != 0x04034b50)
+	{
+		throw CL_Error(&quot;Incorrect Local File Header signature&quot;);
+	}
+	version_needed_to_extract = input-&gt;read_int16();
+	general_purpose_bit_flag = input-&gt;read_int16();
+	compression_method = input-&gt;read_int16();
+	last_mod_file_time = input-&gt;read_int16();
+	last_mod_file_date = input-&gt;read_int16();
+	crc32 = input-&gt;read_int32();
+	compressed_size = input-&gt;read_int32();
+	uncompressed_size = input-&gt;read_int32();
+	file_name_length = input-&gt;read_int16();
+	extra_field_length = input-&gt;read_int16();
+	char *str1 = new char[file_name_length];
+	char *str2 = new char[extra_field_length];
+	try
+	{
+		input-&gt;read(str1, file_name_length);
+		input-&gt;read(str2, extra_field_length);
+		filename = std::string(str1, file_name_length);
+		extra_field = std::string(str2, extra_field_length);
+
+		delete[] str1;
+		delete[] str2;
+	}
+	catch (...)
+	{
+		delete[] str1;
+		delete[] str2;
+		throw;
+	}
+}
+	
+void CL_Zip_LocalFileHeader::save(CL_OutputSource *output)
+{
+}
+	
+/////////////////////////////////////////////////////////////////////////////
+// CL_Zip_LocalFileHeader implementation:

Added: trunk/clanlib/Core/IOData/zip_local_file_header.h
===================================================================
--- trunk/clanlib/Core/IOData/zip_local_file_header.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/zip_local_file_header.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,88 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_zip_local_file_header
+#define header_zip_local_file_header
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/IOData/datatypes.h&quot;
+
+class CL_InputSource;
+class CL_OutputSource;
+
+class CL_Zip_LocalFileHeader
+{
+//! Construction:
+public:
+	CL_Zip_LocalFileHeader();
+	
+	~CL_Zip_LocalFileHeader();
+
+//! Attributes:
+public:
+	cl_int32 signature; // 0x04034b50
+
+	cl_int16 version_needed_to_extract;
+
+	cl_int16 general_purpose_bit_flag;
+
+	cl_int16 compression_method;
+
+	cl_int16 last_mod_file_time;
+
+	cl_int16 last_mod_file_date;
+
+	cl_int32 crc32;
+
+	cl_int32 compressed_size;
+
+	cl_int32 uncompressed_size;
+
+	cl_int16 file_name_length;
+
+	cl_int16 extra_field_length;
+
+	std::string filename;
+
+	std::string extra_field;
+	
+//! Operations:
+public:
+	void load(CL_InputSource *input);
+	
+	void save(CL_OutputSource *output);
+	
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/Core/IOData/zip_version_attributes.h
===================================================================
--- trunk/clanlib/Core/IOData/zip_version_attributes.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/IOData/zip_version_attributes.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,55 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef zip_version_attributes
+#define zip_version_attributes
+
+enum CL_Zip_VersionAttributes
+{
+	zip_version_msdos,
+	zip_version_amiga,
+	zip_version_openvms
+	zip_version_unix,
+	zip_version_vm_cms,
+	zip_version_atari_st,
+	zip_version_os2,
+	zip_version_macintosh,
+	zip_version_zsystem,
+	zip_version_cpm,
+	zip_version_winnt,
+	zip_version_mvs,
+	zip_version_vse,
+	zip_version_acorn_risc,
+	zip_version_vfat,
+	zip_version_alternate_mvs,
+	zip_version_beos,
+	zip_version_tandem
+};
+
+#endif

Added: trunk/clanlib/Core/Makefile.am
===================================================================
--- trunk/clanlib/Core/Makefile.am	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Makefile.am	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,134 @@
+AUTOMAKE_OPTIONS = subdir-objects
+
+lib_LTLIBRARIES = libclanCore.la
+
+libclanCore_la_SOURCES = \
+core_iostream.cpp \
+IOData/Generic/datafile_inputprovider.cpp \
+IOData/Generic/directory.cpp \
+IOData/Generic/directory_scanner.cpp \
+IOData/Generic/endianess.cpp \
+IOData/Generic/inputsource.cpp \
+IOData/Generic/inputsource_file.cpp \
+IOData/Generic/inputsource_memory_generic.cpp \
+IOData/Generic/inputsource_provider_file.cpp \
+IOData/Generic/inputsource_zipped.cpp \
+IOData/Generic/outputsource.cpp \
+IOData/Generic/outputsource_file.cpp \
+IOData/Generic/outputsource_memory_generic.cpp \
+IOData/Generic/outputsource_zipped.cpp \
+IOData/inputsource_memory.cpp \
+IOData/inputsource_zip_fileentry.cpp \
+IOData/outputsource_memory.cpp \
+IOData/zip_64_end_of_central_directory_locator.cpp \
+IOData/zip_64_end_of_central_directory_record.cpp \
+IOData/zip_archive.cpp \
+IOData/zip_digital_signature.cpp \
+IOData/zip_end_of_central_directory_record.cpp \
+IOData/zip_file_entry.cpp \
+IOData/zip_file_header.cpp \
+IOData/zip_local_file_descriptor.cpp \
+IOData/zip_local_file_header.cpp \
+Math/matrix4x4.cpp \
+Math/cl_vector.cpp \
+Math/line_math.cpp \
+Math/triangle_math.cpp \
+Math/pointset_math.cpp \
+Math/origin.cpp \
+Math/rect.cpp \
+Math/quad.cpp \
+Math/vector2.cpp \
+Math/number_pool.cpp \
+Math/delauney_triangulator.cpp \
+Math/delauney_triangulator_generic.cpp \
+Math/outline_triangulator.cpp \
+Math/outline_triangulator_generic.cpp \
+Resources/resource.cpp \
+Resources/resource_generic.cpp \
+Resources/resource_manager.cpp \
+Resources/resource_manager_generic.cpp \
+Resources/resourcedata.cpp \
+Resources/resourcetype_boolean.cpp \
+Resources/resourcetype_integer.cpp \
+Resources/resourcetype_float.cpp \
+Resources/resourcetype_raw.cpp \
+Resources/resourcetype_string.cpp \
+System/Generic/cl_assert.cpp \
+System/Generic/clanstring.cpp \
+System/Generic/command_line.cpp \
+System/Generic/command_line_generic.cpp \
+System/Generic/console_window.cpp \
+System/Generic/console_window_generic.cpp \
+System/Generic/detect_3dnow.cpp \
+System/Generic/detect_mmx.cpp \
+System/Generic/error.cpp \
+System/Generic/event_listener.cpp \
+System/Generic/event_listener_generic.cpp \
+System/Generic/event_trigger.cpp \
+System/Generic/event_trigger_generic.cpp \
+System/Generic/keep_alive_generic.cpp \
+System/Generic/setupcore.cpp \
+System/Generic/timer_generic.cpp \
+System/Generic/log.cpp \
+System/Generic/call_stack.cpp \
+System/Generic/crash_reporter.cpp \
+XML/dom_attr.cpp \
+XML/dom_cdata_section.cpp \
+XML/dom_character_data.cpp \
+XML/dom_comment.cpp \
+XML/dom_document.cpp \
+XML/dom_document_fragment.cpp \
+XML/dom_document_generic.cpp \
+XML/dom_document_type.cpp \
+XML/dom_element.cpp \
+XML/dom_entity.cpp \
+XML/dom_entity_reference.cpp \
+XML/dom_exception.cpp \
+XML/dom_implementation.cpp \
+XML/dom_named_node_map.cpp \
+XML/dom_node.cpp \
+XML/dom_node_list.cpp \
+XML/dom_notation.cpp \
+XML/dom_processing_instruction.cpp \
+XML/dom_text.cpp \
+XML/xml_tokenizer.cpp \
+XML/xml_token_load.cpp \
+XML/xml_token_save.cpp \
+XML/xml_writer.cpp \
+precomp.cpp
+
+if WIN32
+libclanCore_la_SOURCES += \
+System/Win32/event_listener_win32.cpp \
+System/Win32/event_listener_win32.h \
+System/Win32/event_trigger_win32.cpp \
+System/Win32/event_trigger_win32.h \
+System/Win32/init_win32.cpp \
+System/Win32/init_win32.h \
+System/Win32/mutex_win32.cpp \
+System/Win32/mutex_win32.h \
+System/Win32/thread_win32.cpp \
+System/Win32/thread_win32.h \
+IOData/Win32/directory_scanner_win32.cpp \
+IOData/Win32/directory_scanner_win32.h \
+System/Win32/crash_reporter_win32.cpp
+else
+libclanCore_la_SOURCES += \
+System/Unix/event_listener_unix.cpp \
+System/Unix/event_trigger_unix.cpp \
+System/Unix/init_linux.cpp \
+System/Unix/mutex_pthread.cpp \
+System/Unix/thread_pthread.cpp \
+System/Unix/cl_library.cpp \
+System/Unix/crash_reporter_unix.cpp \
+IOData/Unix/directory_scanner_unix.cpp
+endif
+
+# FIXME: Hardcoding these here might not be a good idea
+libclanCore_la_LIBADD = @LIBPTHREAD@
+
+libclanCore_la_LDFLAGS = \
+  -release $(LT_RELEASE) \
+  -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE)
+
+# EOF #

Added: trunk/clanlib/Core/Math/cl_vector.cpp
===================================================================
--- trunk/clanlib/Core/Math/cl_vector.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Math/cl_vector.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,220 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/Math/cl_vector.h&quot;
+#include &quot;API/Core/System/cl_assert.h&quot;
+#include &lt;cmath&gt;
+
+CL_Vector::CL_Vector(float x, float y, float z, float w)
+{
+	this-&gt;x = x;
+	this-&gt;y = y;
+	this-&gt;z = z;
+	this-&gt;w = w;
+}
+
+CL_Vector::CL_Vector(const CL_Vector &amp;other)
+{
+	x = other.x;
+	y = other.y;
+	z = other.z;
+	w = other.w;
+}
+
+float CL_Vector::norm() const
+{
+	#ifdef WIN32
+	return (float)sqrt(x*x+y*y+z*z);
+	#else
+	return std::sqrt(x*x+y*y+z*z);
+	#endif
+}
+
+void CL_Vector::normalize()
+{
+	float f = norm();
+	if (f!=0)
+	{
+		x /= f;
+		y /= f;
+		z /= f;
+	}
+}
+
+float CL_Vector::dot(const CL_Vector&amp; v) const
+{
+	return x*v.x + y*v.y + z*v.z;  
+}
+
+float CL_Vector::angle(const CL_Vector&amp; v) const
+{
+	#ifdef WIN32
+	return (float)acos(dot(v)/(norm()*v.norm()));  
+	#else
+	return std::acos(dot(v)/(norm()*v.norm()));  
+	#endif
+}
+
+CL_Vector CL_Vector::cross(const CL_Vector&amp; v) const
+{
+	CL_Vector tmp = CL_Vector(y * v.z - z * v.y,
+				  z * v.x - x * v.z,
+				  x * v.y - y * v.x);
+	return tmp;  
+}
+
+// quick hack, same as glRotatef(angle, a);
+CL_Vector CL_Vector::rotate(float angle, const CL_Vector&amp; a) const
+{
+	CL_Vector tmp = CL_Vector();
+
+	#ifdef WIN32
+	float s = (float)sin(angle);
+	float c = (float)cos(angle);
+	#else
+	float s = std::sin(angle);
+	float c = std::cos(angle);
+	#endif
+
+	tmp.x = x*(a.x*a.x*(1-c)+c)     + y*(a.x*a.y*(1-c)-a.z*s) + z*(a.x*a.z*(1-c)+a.y*s);
+	tmp.y = x*(a.y*a.x*(1-c)+a.z*s) + y*(a.y*a.y*(1-c)+c)     + z*(a.y*a.z*(1-c)-a.x*s);
+	tmp.z = x*(a.x*a.z*(1-c)-a.y*s) + y*(a.y*a.z*(1-c)+a.x*s) + z*(a.z*a.z*(1-c)+c);
+	return tmp;  
+}
+
+void CL_Vector::round()
+{
+	x = int(x+0.5f);
+	y = int(y+0.5f);
+	z = int(z+0.5f);
+	w = int(w+0.5f);
+}
+
+CL_Vector CL_Vector::operator * (float s) const
+{
+	return CL_Vector(s * x,
+		 	 s * y,
+			 s * z,
+			 s * w);
+}
+
+CL_Vector operator * (float s, const CL_Vector&amp; v)
+{
+	return CL_Vector(s * v.x,
+			 s * v.y,
+			 s * v.z,
+			 s * v.w);
+}
+
+void CL_Vector::operator += (const CL_Vector&amp; v)
+{
+	x += v.x;
+	y += v.y;
+	z += v.z;
+	w += v.z;
+}
+
+void CL_Vector::operator -= (const CL_Vector&amp; v)
+{
+  	x -= v.x;
+	y -= v.y;
+	z -= v.z;
+	w -= v.w;
+}
+
+void CL_Vector::operator *= (float s)
+{
+	x *= s;
+	y *= s;
+	z *= s;
+	w *= s;
+}
+
+CL_Vector CL_Vector::operator + (const CL_Vector&amp; v) const
+{
+	return CL_Vector(x + v.x,
+			 y + v.y,
+			 z + v.z,
+			 w + v.w);
+}
+
+CL_Vector CL_Vector::operator - (const CL_Vector&amp; v) const
+{
+	return CL_Vector(x - v.x,
+			 y - v.y,
+			 z - v.z,
+			 w - v.z);
+}
+
+CL_Vector CL_Vector::operator - () const
+{
+	return CL_Vector(-x,
+			 -y,
+			 -z,
+			 -w);
+}
+
+CL_Vector&amp; CL_Vector::operator = (const CL_Vector&amp; v)
+{ 
+	x = v.x;
+	y = v.y;
+	z = v.z;
+	w = v.w;
+	return *this;
+}
+ 
+bool CL_Vector::operator == (const CL_Vector&amp; v) const
+{
+	return ((x == v.x) &amp;&amp; (y == v.y) &amp;&amp; (z == v.z) &amp;&amp; (w == v.w));
+}
+
+bool CL_Vector::operator != (const CL_Vector&amp; v) const
+{
+	return !(operator == (v));
+}
+
+float &amp; CL_Vector::operator [] (int n)
+{
+	switch (n)
+	{
+		case 0:	return x;
+		case 1: return y;
+		case 2: return z;
+		case 3: return w;
+	}
+	cl_assert(false);
+	return x;			// dummy
+}
+
+std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, const CL_Vector&amp; v)
+{
+	os &lt;&lt; v.x &lt;&lt; &quot; &quot; &lt;&lt; v.y &lt;&lt; &quot; &quot; &lt;&lt; v.z;
+	return os;
+}

Added: trunk/clanlib/Core/Math/delauney_triangulator.cpp
===================================================================
--- trunk/clanlib/Core/Math/delauney_triangulator.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Math/delauney_triangulator.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,77 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/Math/delauney_triangulator.h&quot;
+#include &quot;delauney_triangulator_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Delauney_Triangulator construction:
+
+CL_DelauneyTriangulator::CL_DelauneyTriangulator() : impl(new CL_DelauneyTriangulator_Generic)
+{
+}
+
+CL_DelauneyTriangulator::~CL_DelauneyTriangulator()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DelauneyTriangulator attributes:
+
+const std::vector&lt;CL_DelauneyTriangulator_Vertex&gt; &amp;CL_DelauneyTriangulator::get_vertices() const
+{
+	return impl-&gt;input_vertices;
+}
+
+const std::vector&lt;CL_DelauneyTriangulator_Triangle&gt; &amp;CL_DelauneyTriangulator::get_triangles() const
+{
+	return impl-&gt;triangles;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DelauneyTriangulator operations:
+
+void CL_DelauneyTriangulator::add_vertex(double x, double y, void *data)
+{
+	CL_DelauneyTriangulator_Vertex vertex;
+	vertex.x = x;
+	vertex.y = y;
+	vertex.data = data;
+	impl-&gt;input_vertices.push_back(vertex);
+}
+
+void CL_DelauneyTriangulator::generate()
+{
+	if (impl-&gt;input_vertices.empty()) return;
+	impl-&gt;triangulate();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DelauneyTriangulator implementation:

Added: trunk/clanlib/Core/Math/delauney_triangulator_generic.cpp
===================================================================
--- trunk/clanlib/Core/Math/delauney_triangulator_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Math/delauney_triangulator_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,351 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;delauney_triangulator_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DelauneyTriangulator_Generic construction:
+
+CL_DelauneyTriangulator_Generic::CL_DelauneyTriangulator_Generic()
+{
+}
+
+CL_DelauneyTriangulator_Generic::~CL_DelauneyTriangulator_Generic()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DelauneyTriangulator_Generic attributes:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DelauneyTriangulator_Generic operations:
+
+void CL_DelauneyTriangulator_Generic::triangulate()
+{
+	// Order vertices:
+
+	std::vector&lt;CL_DelauneyTriangulator_Vertex *&gt; vertices;
+	create_ordered_vertex_list(vertices);
+
+	// Calculate super triangle:
+
+	CL_DelauneyTriangulator_Vertex super_A;
+	CL_DelauneyTriangulator_Vertex super_B;
+	CL_DelauneyTriangulator_Vertex super_C;
+	CL_DelauneyTriangulator_Triangle super_triangle;
+	super_triangle.vertex_A = &amp;super_A;
+	super_triangle.vertex_B = &amp;super_B;
+	super_triangle.vertex_C = &amp;super_C;
+	calculate_supertriangle(vertices, super_triangle);
+
+	// Perform delauney triangulation:
+
+	perform_delauney_triangulation(vertices, super_triangle, triangles);
+}
+
+struct CL_CompareVertices
+{
+	bool operator()(CL_DelauneyTriangulator_Vertex *a, CL_DelauneyTriangulator_Vertex *b) const
+	{
+		if (a-&gt;x == b-&gt;x) return a-&gt;y &lt; b-&gt;y;
+		return a-&gt;x &lt; b-&gt;x;
+	}
+};
+
+void CL_DelauneyTriangulator_Generic::create_ordered_vertex_list(std::vector&lt;CL_DelauneyTriangulator_Vertex *&gt; &amp;vertices)
+{
+	std::vector&lt;CL_DelauneyTriangulator_Vertex&gt;::size_type index_vertices, num_vertices;
+	num_vertices = input_vertices.size();
+	for (index_vertices = 0; index_vertices &lt; num_vertices; index_vertices++)
+	{
+		vertices.push_back(&amp;input_vertices[index_vertices]);
+	}
+
+	// Sort list:
+	std::sort(vertices.begin(), vertices.end(), CL_CompareVertices());
+
+	// Remove duplicates:
+	std::vector&lt;CL_DelauneyTriangulator_Vertex *&gt;::iterator it = vertices.begin();
+	if (it == vertices.end()) return;
+	double last_x = (*it)-&gt;x;
+	double last_y = (*it)-&gt;y;
+	++it;
+	while (it != vertices.end())
+	{
+		if (last_x == (*it)-&gt;x &amp;&amp; last_y == (*it)-&gt;y)
+		{
+			it = vertices.erase(it);
+		}
+		else
+		{
+			last_x = (*it)-&gt;x;
+			last_y = (*it)-&gt;y;
+			++it;
+		}
+	}
+}
+
+void CL_DelauneyTriangulator_Generic::calculate_supertriangle(std::vector&lt;CL_DelauneyTriangulator_Vertex *&gt; &amp;vertices, CL_DelauneyTriangulator_Triangle &amp;super_triangle)
+{
+	// Find min and max values:
+
+	double min_x = 0.0;
+	double max_x = 0.0;
+	double min_y = 0.0;
+	double max_y = 0.0;
+	bool first_point = true;
+
+	std::vector&lt;CL_DelauneyTriangulator_Vertex *&gt;::size_type index_vertices, num_vertices;
+	num_vertices = vertices.size();
+	for (index_vertices = 0; index_vertices &lt; num_vertices; index_vertices++)
+	{
+		CL_DelauneyTriangulator_Vertex *cur_vertex = vertices[index_vertices];
+
+		if (!first_point)
+		{
+			if (min_x &gt; cur_vertex-&gt;x) min_x = cur_vertex-&gt;x;
+			if (max_x &lt; cur_vertex-&gt;x) max_x = cur_vertex-&gt;x;
+			if (min_y &gt; cur_vertex-&gt;y) min_y = cur_vertex-&gt;y;
+			if (max_y &lt; cur_vertex-&gt;y) max_y = cur_vertex-&gt;y;
+		}
+		else
+		{
+			first_point = false;
+			min_x = cur_vertex-&gt;x;
+			max_x = cur_vertex-&gt;x;
+			min_y = cur_vertex-&gt;y;
+			max_y = cur_vertex-&gt;y;
+		}
+	}
+
+	// Setup super triangle based on min/max values:
+
+	super_triangle.vertex_A-&gt;x = min_x-1;
+	super_triangle.vertex_A-&gt;y = min_y-1;
+	super_triangle.vertex_A-&gt;data = 0;
+
+	super_triangle.vertex_B-&gt;x = max_x+(max_x-min_x)+1;
+	super_triangle.vertex_B-&gt;y = min_y-1;
+	super_triangle.vertex_B-&gt;data = 0;
+
+	super_triangle.vertex_C-&gt;x = min_x-1;
+	super_triangle.vertex_C-&gt;y = max_y+(max_y-min_y)+1;
+	super_triangle.vertex_C-&gt;data = 0;
+}
+
+void CL_DelauneyTriangulator_Generic::perform_delauney_triangulation(
+	const std::vector&lt;CL_DelauneyTriangulator_Vertex *&gt; &amp;vertices,
+	const CL_DelauneyTriangulator_Triangle &amp;super_triangle,
+	std::vector&lt;CL_DelauneyTriangulator_Triangle&gt; &amp;triangles)
+{
+/*
+	delauney triangulation algorithm:
+
+	subroutine triangulate
+	input : vertex list
+	output : triangle list
+		initialize the triangle list
+		determine the supertriangle
+		add supertriangle vertices to the end of the vertex list
+		add the supertriangle to the triangle list
+		for each sample point in the vertex list
+			initialize the edge buffer
+			for each triangle currently in the triangle list
+				calculate the triangle circumcircle center and radius
+				if the point lies in the triangle circumcircle then
+					add the three triangle edges to the edge buffer
+					remove the triangle from the triangle list
+				endif
+			endfor
+			delete all doubly specified edges from the edge buffer
+				this leaves the edges of the enclosing polygon only
+			add to the triangle list all triangles formed between the point 
+				and the edges of the enclosing polygon
+		endfor
+		remove any triangles from the triangle list that use the supertriangle vertices
+		remove the supertriangle vertices from the vertex list
+	end
+
+	See <A HREF="http://astronomy.swin.edu.au/~pbourke/terrain/triangulate/">http://astronomy.swin.edu.au/~pbourke/terrain/triangulate/</A> for more info
+*/
+
+	// Reset triangle list.
+	triangles.clear();
+
+	// add supertriangle vertices to the end of the vertex list
+	triangles.push_back(super_triangle);
+
+	// for each sample point in the vertex list:
+	std::vector&lt;CL_DelauneyTriangulator_Vertex *&gt;::size_type index_vertices, num_vertices;
+	num_vertices = vertices.size();
+	for (index_vertices = 0; index_vertices &lt; num_vertices; index_vertices++)
+	{
+		CL_DelauneyTriangulator_Vertex *insertion_point = vertices[index_vertices];
+
+		// Init edge buffer
+		typedef std::pair&lt;CL_DelauneyTriangulator_Vertex *, CL_DelauneyTriangulator_Vertex *&gt; CL_DelauneyTriangulator_Triangle_Edge;
+		std::vector&lt;CL_DelauneyTriangulator_Triangle_Edge&gt; edges;
+
+		// For each triangle currently in the triangle list
+		std::vector&lt;CL_DelauneyTriangulator_Triangle&gt;::size_type index_triangles, num_triangles;
+		num_triangles = triangles.size();
+		for (index_triangles = 0; index_triangles &lt; num_triangles; index_triangles++)
+		{
+			CL_DelauneyTriangulator_Triangle &amp;cur_triangle = triangles[index_triangles];
+
+			// todo: cache circumcenter in triangle?
+			CL_DelauneyTriangulator_Vertex circumcenter = find_circumcenter(cur_triangle);
+			double radius_x = cur_triangle.vertex_A-&gt;x-circumcenter.x;
+			double radius_y = cur_triangle.vertex_A-&gt;y-circumcenter.y;
+			double radius2 = radius_x*radius_x + radius_y*radius_y;
+
+			// Check if the point lies in the triangle circumcircle:
+			double dist_x = insertion_point-&gt;x - circumcenter.x;
+			double dist_y = insertion_point-&gt;y - circumcenter.y;
+			double dist2 = dist_x*dist_x + dist_y*dist_y;
+			if (dist2 &lt; radius2)
+			{
+				// Add triangle edges to edge buffer:
+				edges.push_back(CL_DelauneyTriangulator_Triangle_Edge(cur_triangle.vertex_A, cur_triangle.vertex_B));
+				edges.push_back(CL_DelauneyTriangulator_Triangle_Edge(cur_triangle.vertex_B, cur_triangle.vertex_C));
+				edges.push_back(CL_DelauneyTriangulator_Triangle_Edge(cur_triangle.vertex_C, cur_triangle.vertex_A));
+
+				// Remove triange from triangle list:
+				triangles.erase(triangles.begin()+index_triangles);
+				index_triangles--;
+				num_triangles--;
+			}
+		}
+
+		// Delete all doubly specified edges from the edge buffer
+		// this leaves the edges of the enclosing polygon only
+		int index_edges1, index_edges2, num_edges; // intentionally integer to allow index to be negative when deleting index.
+		num_edges = (int) edges.size();
+		for (index_edges1 = 0; index_edges1 &lt; num_edges; index_edges1++)
+		{
+			CL_DelauneyTriangulator_Triangle_Edge &amp;edge1 = edges[index_edges1];
+			for (index_edges2 = 0/*index_edges1+1*/; index_edges2 &lt; num_edges; index_edges2++)
+			{
+				if (index_edges1 == index_edges2) continue;
+				CL_DelauneyTriangulator_Triangle_Edge &amp;edge2 = edges[index_edges2];
+				if ((edge1.first == edge2.first &amp;&amp; edge1.second == edge2.second) ||
+					(edge1.second == edge2.first &amp;&amp; edge1.first == edge2.second))
+				{
+					// Same edges, delete both:
+					if (index_edges1 &lt; index_edges2)
+					{
+						edges.erase(edges.begin()+index_edges2);
+						edges.erase(edges.begin()+index_edges1);
+					}
+					else
+					{
+						edges.erase(edges.begin()+index_edges1);
+						edges.erase(edges.begin()+index_edges2);
+					}
+					num_edges -= 2;
+					index_edges1--;
+					break;
+				}
+			}
+		}
+
+		// add to the triangle list all triangles formed between the point 
+		// and the edges of the enclosing polygon
+		for (index_edges1 = 0; index_edges1 &lt; num_edges; index_edges1++)
+		{
+			CL_DelauneyTriangulator_Triangle triangle;
+			triangle.vertex_A = edges[index_edges1].first;
+			triangle.vertex_B = edges[index_edges1].second;
+			triangle.vertex_C = insertion_point;
+			triangles.push_back(triangle);
+		}
+	}
+
+	// remove any triangles from the triangle list that use the supertriangle vertices
+	std::vector&lt;CL_DelauneyTriangulator_Triangle&gt;::size_type index_triangles, num_triangles;
+	num_triangles = triangles.size();
+	for (index_triangles = 0; index_triangles &lt; num_triangles; index_triangles++)
+	{
+		CL_DelauneyTriangulator_Triangle &amp;cur_triangle = triangles[index_triangles];
+
+		if (
+			cur_triangle.vertex_A == super_triangle.vertex_A ||
+			cur_triangle.vertex_A == super_triangle.vertex_B ||
+			cur_triangle.vertex_A == super_triangle.vertex_C ||
+			cur_triangle.vertex_B == super_triangle.vertex_A ||
+			cur_triangle.vertex_B == super_triangle.vertex_B ||
+			cur_triangle.vertex_B == super_triangle.vertex_C ||
+			cur_triangle.vertex_C == super_triangle.vertex_A ||
+			cur_triangle.vertex_C == super_triangle.vertex_B ||
+			cur_triangle.vertex_C == super_triangle.vertex_C)
+		{
+			// triangle share one or more points with supertriangle, remove it:
+			triangles.erase(triangles.begin()+index_triangles);
+			index_triangles--;
+			num_triangles--;
+		}
+	}
+}
+
+CL_DelauneyTriangulator_Vertex CL_DelauneyTriangulator_Generic::find_circumcenter(
+	const CL_DelauneyTriangulator_Triangle &amp;triangle)
+{
+	// Subject 1.04: How do I generate a circle through three points?
+	// <A HREF="http://www.faqs.org/faqs/graphics/algorithms-faq/">http://www.faqs.org/faqs/graphics/algorithms-faq/</A>
+
+	double a_0 = triangle.vertex_A-&gt;x;
+	double a_1 = triangle.vertex_A-&gt;y;
+	double b_0 = triangle.vertex_B-&gt;x;
+	double b_1 = triangle.vertex_B-&gt;y;
+	double c_0 = triangle.vertex_C-&gt;x;
+	double c_1 = triangle.vertex_C-&gt;y;
+
+	double A = b_0 - a_0;
+	double B = b_1 - a_1;
+	double C = c_0 - a_0;
+	double D = c_1 - a_1;
+
+	double E = A*(a_0 + b_0) + B*(a_1 + b_1);
+	double F = C*(a_0 + c_0) + D*(a_1 + c_1);
+
+	double G = 2.0*(A*(c_1 - b_1)-B*(c_0 - b_0));
+
+	double p_0 = (D*E - B*F) / G;
+	double p_1 = (A*F - C*E) / G;
+
+	CL_DelauneyTriangulator_Vertex circumcenter;
+	circumcenter.data = 0;
+	circumcenter.x = p_0;
+	circumcenter.y = p_1;
+	return circumcenter;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Tesselator_Generic implementation:

Added: trunk/clanlib/Core/Math/delauney_triangulator_generic.h
===================================================================
--- trunk/clanlib/Core/Math/delauney_triangulator_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Math/delauney_triangulator_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,73 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_delauney_triangulator_generic
+#define header_delauney_triangulator_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/Math/delauney_triangulator.h&quot;
+
+class CL_DelauneyTriangulator_Generic
+{
+//! Construction:
+public:
+	CL_DelauneyTriangulator_Generic();
+
+	~CL_DelauneyTriangulator_Generic();
+
+//! Attributes:
+public:
+	std::vector&lt;CL_DelauneyTriangulator_Vertex&gt; input_vertices;
+
+	std::vector&lt;CL_DelauneyTriangulator_Triangle&gt; triangles;
+
+//! Operations:
+public:
+	void triangulate();
+
+	void create_ordered_vertex_list(
+		std::vector&lt;CL_DelauneyTriangulator_Vertex *&gt; &amp;vertices);
+
+	void calculate_supertriangle(
+		std::vector&lt;CL_DelauneyTriangulator_Vertex *&gt; &amp;vertices,
+		CL_DelauneyTriangulator_Triangle &amp;super_triangle);
+
+	void perform_delauney_triangulation(
+		const std::vector&lt;CL_DelauneyTriangulator_Vertex *&gt; &amp;vertices,
+		const CL_DelauneyTriangulator_Triangle &amp;super_triangle,
+		std::vector&lt;CL_DelauneyTriangulator_Triangle&gt; &amp;triangles);
+
+	CL_DelauneyTriangulator_Vertex find_circumcenter(
+		const CL_DelauneyTriangulator_Triangle &amp;triangle);
+};
+
+#endif

Added: trunk/clanlib/Core/Math/line_math.cpp
===================================================================
--- trunk/clanlib/Core/Math/line_math.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Math/line_math.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,278 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &lt;cmath&gt;
+#include &quot;API/Core/Math/line_math.h&quot;
+
+template&lt;typename T&gt; inline T pow2(T value) { return value*value; }
+template&lt;typename T&gt; inline T cl_min(T a, T b) { if(a &lt; b) return a; return b; }
+template&lt;typename T&gt; inline T cl_max(T a, T b) { if(a &gt; b) return a; return b; }
+
+/* ----- from comp.graphics.algorithms FAQ ------
+
+  Distance to line (Ax,Ay-&gt;Bx,By) from point x,y
+
+	L = sqrt( (Bx-Ax)^2 + (By-Ay)^2 )
+
+	    (Cx-Ax)(Bx-Ax) + (Cy-Ay)(By-Ay)
+	r = -------------------------------
+	                 L^2
+*/
+
+float CL_LineMath::distance_to_line(const CL_Pointf &amp;P, float *line)
+{
+	return distance_to_line( P.x, P.y, line );
+}
+
+float CL_LineMath::distance_to_line(float x, float y, float *line)
+{
+	const float &amp;Ax = line[0];
+	const float &amp;Ay = line[1];
+	const float &amp;Bx = line[2];
+	const float &amp;By = line[3];
+
+	float L = sqrt( pow2(Bx-Ax) + pow2(By-Ay) );
+	float r = ((x-Ax)*(Bx-Ax)+(y-Ay)*(By-Ay))/pow2(L);
+	
+	if( r &lt;= 0 || r &gt;= 1 )
+	{
+		CL_Pointf p(x,y);
+		CL_Pointf A(Ax,Ay);
+		CL_Pointf B(Bx,By);
+		
+		return cl_min( p.distance(A), p.distance(B) );
+	}
+	
+	float s = ((Ay-y)*(Bx-Ax)-(Ax-x)*(By-Ay)) / pow2(L);
+	return fabs(s)*L;
+}
+
+// Collinear points are points that all lie on the same line. 
+
+bool CL_LineMath::collinear( float *lineA, float *lineB )
+{
+	const float &amp;Ax = lineA[0];
+	const float &amp;Ay = lineA[1];
+	const float &amp;Bx = lineA[2];
+	const float &amp;By = lineA[3];
+
+	const float &amp;Cx = lineB[0];
+	const float &amp;Cy = lineB[1];
+	const float &amp;Dx = lineB[2];
+	const float &amp;Dy = lineB[3];
+	
+	float denominator = ((Bx-Ax)*(Dy-Cy)-(By-Ay)*(Dx-Cx));	
+	float numerator = ((Ay-Cy)*(Dx-Cx)-(Ax-Cx)*(Dy-Cy));
+
+	if( denominator == 0 &amp;&amp; numerator == 0 )
+		return true;
+
+	return false;
+}
+
+float CL_LineMath::point_right_of_line( float x, float y, float *line )
+{
+	const float &amp;Ax = line[0];
+	const float &amp;Ay = line[1];
+	const float &amp;Bx = line[2];
+	const float &amp;By = line[3];
+
+	return (Bx-Ax) * (y-Ay) - (x-Ax) * (By-Ay);
+}
+
+float CL_LineMath::point_right_of_line(float x, float y, float Ax, float Ay, float Bx, float By)
+{
+	return (Bx-Ax) * (y-Ay) - (x-Ax) * (By-Ay);
+}
+
+float CL_LineMath::point_right_of_line( const CL_Pointf &amp;A, const CL_Pointf &amp;B, const CL_Pointf &amp;P )
+{
+	return (B.x-A.x) * (P.y-A.y) - (P.x-A.x) * (B.y-A.y);
+}
+
+
+/*	    From comp.graphics.algorithms FAQ	 
+	+---------------------------------------+
+
+    Let A,B,C,D be 2-space position vectors.  Then the directed line
+    segments AB &amp; CD are given by:
+
+        AB=A+r(B-A), r in [0,1]
+        CD=C+s(D-C), s in [0,1]
+
+    If AB &amp; CD intersect, then
+
+        A+r(B-A)=C+s(D-C), or
+
+        Ax+r(Bx-Ax)=Cx+s(Dx-Cx)
+        Ay+r(By-Ay)=Cy+s(Dy-Cy)  for some r,s in [0,1]
+
+    Solving the above for r and s yields
+
+            (Ay-Cy)(Dx-Cx)-(Ax-Cx)(Dy-Cy)
+        r = -----------------------------  (eqn 1)
+            (Bx-Ax)(Dy-Cy)-(By-Ay)(Dx-Cx)
+
+            (Ay-Cy)(Bx-Ax)-(Ax-Cx)(By-Ay)
+        s = -----------------------------  (eqn 2)
+            (Bx-Ax)(Dy-Cy)-(By-Ay)(Dx-Cx)
+
+    Let P be the position vector of the intersection point, then
+
+        P=A+r(B-A) or
+
+        Px=Ax+r(Bx-Ax)
+        Py=Ay+r(By-Ay)
+*/
+
+CL_Pointf CL_LineMath::get_intersection( float *lineA, float *lineB )
+{
+	const float &amp;Ax = lineA[0];
+	const float &amp;Ay = lineA[1];
+	const float &amp;Bx = lineA[2];
+	const float &amp;By = lineA[3];
+
+	const float &amp;Cx = lineB[0];
+	const float &amp;Cy = lineB[1];
+	const float &amp;Dx = lineB[2];
+	const float &amp;Dy = lineB[3];
+
+	float denominator = ((Bx-Ax)*(Dy-Cy)-(By-Ay)*(Dx-Cx));
+
+	if( denominator == 0 )
+		return CL_Pointf(Ax,Ay); 
+	
+	float r = ((Ay-Cy)*(Dx-Cx)-(Ax-Cx)*(Dy-Cy)) / denominator;
+	
+	CL_Pointf P;
+	P.x=Ax+r*(Bx-Ax);
+	P.y=Ay+r*(By-Ay);
+	
+	return P;
+}
+
+/*
+	---- from comp.graphics.algorithms FAQ ----
+
+    By examining the values of r &amp; s, you can also determine some
+    other limiting conditions:
+
+        If 0&lt;=r&lt;=1 &amp; 0&lt;=s&lt;=1, intersection exists
+            r&lt;0 or r&gt;1 or s&lt;0 or s&gt;1 line segments do not intersect
+
+        If the denominator in eqn 1 is zero, AB &amp; CD are parallel
+        If the numerator in eqn 1 is also zero, AB &amp; CD are collinear.
+*/
+
+bool CL_LineMath::intersects( 
+	float *lineA,
+	float *lineB,
+	bool collinear_intersect )
+{
+	const float &amp;Ax = lineA[0];
+	const float &amp;Ay = lineA[1];
+	const float &amp;Bx = lineA[2];
+	const float &amp;By = lineA[3];
+
+	const float &amp;Cx = lineB[0];
+	const float &amp;Cy = lineB[1];
+	const float &amp;Dx = lineB[2];
+	const float &amp;Dy = lineB[3];
+
+	float denominator = ((Bx-Ax)*(Dy-Cy)-(By-Ay)*(Dx-Cx));
+	
+	if( denominator == 0.0f ) // parallell
+	{
+		if( (Ay-Cy)*(Dx-Cx)-(Ax-Cx)*(Dy-Cy) == 0.0f ) // collinear
+		{
+			if( collinear_intersect )
+				return true;
+			else
+				return false; 
+		}
+		return false;
+	}
+	
+	float r = ((Ay-Cy)*(Dx-Cx)-(Ax-Cx)*(Dy-Cy)) / denominator;
+	float s = ((Ay-Cy)*(Bx-Ax)-(Ax-Cx)*(By-Ay)) / denominator;
+	
+	// We use the open interval [0;1) or (0;1] depending on the direction of CD
+	if(Cy &lt; Dy)
+	{
+		if( (s &gt;= 0.0f  &amp;&amp; s &lt; 1.0f) &amp;&amp; (r &gt;= 0.0f &amp;&amp; r &lt;= 1.0f) )
+			return true;
+	}
+	else
+	{
+		if( (s &gt; 0.0f  &amp;&amp; s &lt;= 1.0f) &amp;&amp; (r &gt;= 0.0f &amp;&amp; r &lt;= 1.0f) )
+			return true;
+	}
+	
+	return false;
+}
+
+
+// return the midpoint on the line from A to B
+CL_Pointf CL_LineMath::midpoint( const CL_Pointf &amp;A, const CL_Pointf &amp;B )
+{
+	return CL_Pointf( (A.x+B.x)/2.0f, (A.y+B.y)/2.0f );
+}
+
+// return the normal vector of the line
+CL_Pointf CL_LineMath::normal( const CL_Pointf &amp;A, const CL_Pointf &amp;B )
+{
+	return CL_LineMath::normal(A.x, A.y, B.x, B.y);
+}
+
+CL_Pointf CL_LineMath::normal( float x1, float y1, float x2, float y2 )
+{
+	CL_Pointf N;
+	N.x = -1 * (y2-y1);
+	N.y = x2-x1;
+
+	float len = sqrt(N.x*N.x + N.y*N.y);
+	N.x /= len;
+	N.y /= len;
+
+	return N;
+}
+
+CL_Pointf CL_LineMath::normal( float *line )
+{
+	CL_Pointf N;
+	N.x = -1 * (line[3]-line[1]);
+	N.y = line[2]-line[0];
+
+	float len = sqrt(N.x*N.x + N.y*N.y);
+	N.x /= len;
+	N.y /= len;
+
+	return N;
+}

Added: trunk/clanlib/Core/Math/matrix4x4.cpp
===================================================================
--- trunk/clanlib/Core/Math/matrix4x4.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Math/matrix4x4.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,126 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/Math/matrix4x4.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Matrix4x4 construction:
+
+CL_Matrix4x4::CL_Matrix4x4(bool identity)
+{
+	memset(matrix, 0, sizeof(double[16]));
+	if (identity)
+	{
+		matrix[0] = 1.0;
+		matrix[5] = 1.0;
+		matrix[10] = 1.0;
+		matrix[15] = 1.0;
+	}
+}
+
+CL_Matrix4x4::CL_Matrix4x4(const CL_Matrix4x4 &amp;copy)
+{
+	for (int i=0; i&lt;16; i++)
+		matrix[i] = copy.matrix[i];
+}
+
+CL_Matrix4x4::CL_Matrix4x4(double *init_matrix)
+{
+	for (int i=0; i&lt;16; i++)
+		matrix[i] = init_matrix[i];
+}
+
+CL_Matrix4x4::CL_Matrix4x4(float *init_matrix)
+{
+	for (int i=0; i&lt;16; i++)
+		matrix[i] = (double) init_matrix[i];
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Matrix4x4 attributes:
+
+double CL_Matrix4x4::get_origin_x() const
+{
+	return matrix[12];
+}
+
+double CL_Matrix4x4::get_origin_y() const
+{
+	return matrix[13];
+}
+
+double CL_Matrix4x4::get_origin_z() const
+{
+	return matrix[14];
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Matrix4x4 operations:
+
+bool CL_Matrix4x4::operator==(const CL_Matrix4x4 &amp;other) const 
+{
+	for (int i=0; i&lt;16; i++)
+		if (matrix[i] != other.matrix[i]) return false;
+	return true;
+}
+
+bool CL_Matrix4x4::operator!=(const CL_Matrix4x4 &amp;other) const
+{
+	for (int i=0; i&lt;16; i++)
+		if (matrix[i] != other.matrix[i]) return true;
+	return false;
+}
+
+CL_Matrix4x4 &amp;CL_Matrix4x4::operator =(const CL_Matrix4x4 &amp;copy)
+{
+	for (int i=0; i&lt;16; i++)
+		matrix[i] = copy.matrix[i];
+	return *this;
+}
+
+CL_Matrix4x4 CL_Matrix4x4::multiply(const CL_Matrix4x4 &amp;mult) const
+{
+	CL_Matrix4x4 result;
+	for (int x=0; x&lt;4; x++)
+	{
+		for (int y=0; y&lt;4; y++)
+		{
+			result.matrix[x+y*4] =
+				matrix[x]*mult.matrix[y*4] +
+				matrix[x+4]*mult.matrix[y*4+1] +
+				matrix[x+8]*mult.matrix[y*4+2] +
+				matrix[x+12]*mult.matrix[y*4+3];
+		}
+	}
+	return result;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Matrix4x4 implementation:

Added: trunk/clanlib/Core/Math/number_pool.cpp
===================================================================
--- trunk/clanlib/Core/Math/number_pool.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Math/number_pool.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,85 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/Math/number_pool.h&quot;
+
+CL_NumberPool::CL_NumberPool() :
+initial_number_range(0)
+{
+}
+
+//: Return a unique number.
+unsigned short CL_NumberPool::get_number()
+{
+	unsigned short ret_val;
+
+	// look for available numbers in the number pool
+	if (available_numbers.size() &gt; 0)
+	{
+		std::set&lt;unsigned short&gt;::iterator iter;
+
+		// get the first number available
+		iter = available_numbers.begin();
+
+		// store data to the return variable
+		ret_val = *iter;
+
+		// now remove the number from the pool
+		available_numbers.erase(iter);
+	}
+	// there are no available numbers in the number pool
+	else
+	{
+		// make sure that the initial_number_range has not reached the max
+		if (initial_number_range == USHRT_MAX)
+		{
+			// throw an exeption stating that no more unique numbers can be generated
+			throw CL_Error(&quot;CL_NumberPool::get_number failed: All unique numbers have been used up.&quot;);
+		}
+
+		// generate the a new available number
+		ret_val = initial_number_range++;
+	}
+
+	return ret_val;
+}
+
+//: Pass a number back in so as to beable to reuse the unique number. NOTE: numbers that were not given before or already returned back will be discarded.
+void CL_NumberPool::return_number(unsigned short number)
+{
+	// check if the given number is within the initial_number_range
+	// if it's not, discard it
+	if (number &gt;= initial_number_range)
+		return;
+
+	// add number into list, be it already inserted or not.
+	// since a set can only have unique data, so it doesn't matters
+	available_numbers.insert(number);
+}

Added: trunk/clanlib/Core/Math/origin.cpp
===================================================================
--- trunk/clanlib/Core/Math/origin.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Math/origin.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,102 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+
+#include &quot;API/Core/Math/origin.h&quot;
+
+CL_Point calc_origin(CL_Origin origin, const CL_Size &amp;size)
+{
+	switch(origin)
+	{
+	case origin_top_left:
+	default:
+		return CL_Point(0, 0);
+		break;
+	case origin_top_center:
+		return CL_Point(size.width / 2, 0);
+		break;
+	case origin_top_right:
+		return CL_Point(size.width, 0);
+		break;
+	case origin_center_left:
+		return CL_Point(0, size.height / 2);
+		break;
+	case origin_center:
+		return CL_Point(size.width / 2, size.height / 2);
+		break;
+	case origin_center_right:
+		return CL_Point(size.width, size.height / 2);
+		break;
+	case origin_bottom_left:
+		return CL_Point(0, size.height);
+		break;
+	case origin_bottom_center:
+		return CL_Point(size.width / 2, size.height);
+		break;
+	case origin_bottom_right:
+		return CL_Point(size.width, size.height);
+		break;
+	}
+}
+
+CL_Pointf calc_origin(CL_Origin origin, const CL_Sizef &amp;size)
+{
+	switch(origin)
+	{
+	case origin_top_left:
+	default:
+		return CL_Pointf(0, 0);
+		break;
+	case origin_top_center:
+		return CL_Pointf(size.width / 2, 0);
+		break;
+	case origin_top_right:
+		return CL_Pointf(size.width, 0);
+		break;
+	case origin_center_left:
+		return CL_Pointf(0, size.height / 2);
+		break;
+	case origin_center:
+		return CL_Pointf(size.width / 2, size.height / 2);
+		break;
+	case origin_center_right:
+		return CL_Pointf(size.width, size.height / 2);
+		break;
+	case origin_bottom_left:
+		return CL_Pointf(0, size.height);
+		break;
+	case origin_bottom_center:
+		return CL_Pointf(size.width / 2, size.height);
+		break;
+	case origin_bottom_right:
+		return CL_Pointf(size.width, size.height);
+		break;
+	}
+}

Added: trunk/clanlib/Core/Math/outline_triangulator.cpp
===================================================================
--- trunk/clanlib/Core/Math/outline_triangulator.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Math/outline_triangulator.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,83 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/Math/outline_triangulator.h&quot;
+#include &quot;outline_triangulator_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OutlineTriangulator construction:
+
+CL_OutlineTriangulator::CL_OutlineTriangulator() : impl(new CL_OutlineTriangulator_Generic)
+{
+}
+
+CL_OutlineTriangulator::~CL_OutlineTriangulator()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OutlineTriangulator attributes:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OutlineTriangulator operations:
+
+void CL_OutlineTriangulator::next_contour()
+{
+	if (impl-&gt;current_contour.vertices.empty()) return;
+	impl-&gt;current_polygon.contours.push_back(impl-&gt;current_contour);
+	impl-&gt;current_contour = CL_OutlineTriangulator_Contour();
+}
+
+void CL_OutlineTriangulator::next_polygon()
+{
+	next_contour();
+	if (impl-&gt;current_polygon.contours.empty()) return;
+	impl-&gt;polygons.push_back(impl-&gt;current_polygon);
+	impl-&gt;current_polygon = CL_OutlineTriangulator_Polygon();
+}
+
+void CL_OutlineTriangulator::add_vertex(double x, double y, void *data)
+{
+	CL_OutlineTriangulator_Vertex vertex;
+	vertex.x = x;
+	vertex.y = y;
+	vertex.data = data;
+	impl-&gt;current_contour.vertices.push_back(vertex);
+}
+
+void CL_OutlineTriangulator::generate()
+{
+	next_polygon();
+	if (impl-&gt;polygons.empty()) return;
+	impl-&gt;triangulate();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OutlineTriangulator implementation:

Added: trunk/clanlib/Core/Math/outline_triangulator_generic.cpp
===================================================================
--- trunk/clanlib/Core/Math/outline_triangulator_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Math/outline_triangulator_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,539 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;outline_triangulator_generic.h&quot;
+#include &quot;API/Core/Math/delauney_triangulator.h&quot;
+#include &quot;API/Core/Math/line_math.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OutlineTriangulator_Generic construction:
+
+CL_OutlineTriangulator_Generic::CL_OutlineTriangulator_Generic()
+{
+}
+
+CL_OutlineTriangulator_Generic::~CL_OutlineTriangulator_Generic()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OutlineTriangulator_Generic attributes:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OutlineTriangulator_Generic operations:
+
+void CL_OutlineTriangulator_Generic::triangulate()
+{
+	// Order vertices:
+	std::vector&lt;CL_OutlineTriangulator_Vertex *&gt; vertices;
+	create_ordered_vertex_list(vertices);
+
+	// 1.  Create initial triangulation:
+	CL_DelauneyTriangulator delauney;
+	std::vector&lt;CL_OutlineTriangulator_Vertex *&gt;::size_type index_vertices, num_vertices;
+	num_vertices = vertices.size();
+	for (index_vertices = 0; index_vertices &lt; num_vertices; index_vertices++)
+	{
+		vertices[index_vertices]-&gt;num_triangles = 0;
+		vertices[index_vertices]-&gt;extra = 0;
+		vertices[index_vertices]-&gt;triangles = 0;
+
+		delauney.add_vertex(
+			vertices[index_vertices]-&gt;x,
+			vertices[index_vertices]-&gt;y,
+			vertices[index_vertices]);
+	}
+	delauney.generate();
+
+	// 2.  Link triangles to vertices:
+
+	const std::vector&lt;CL_DelauneyTriangulator_Triangle&gt; &amp;triangles = delauney.get_triangles();
+
+	std::vector&lt;CL_DelauneyTriangulator_Triangle&gt;::size_type index_triangles, num_triangles;
+	num_triangles = triangles.size();
+	for (index_triangles = 0; index_triangles &lt; num_triangles; index_triangles++)
+	{
+		CL_OutlineTriangulator_Vertex *data_A = (CL_OutlineTriangulator_Vertex *) triangles[index_triangles].vertex_A-&gt;data;
+		CL_OutlineTriangulator_Vertex *data_B = (CL_OutlineTriangulator_Vertex *) triangles[index_triangles].vertex_B-&gt;data;
+		CL_OutlineTriangulator_Vertex *data_C = (CL_OutlineTriangulator_Vertex *) triangles[index_triangles].vertex_C-&gt;data;
+		data_A-&gt;num_triangles++;
+		data_B-&gt;num_triangles++;
+		data_C-&gt;num_triangles++;
+	}
+
+	CL_DelauneyTriangulator_Triangle const **links = new CL_DelauneyTriangulator_Triangle const *[num_triangles];
+	int pos = 0;
+	for (index_vertices = 0; index_vertices &lt; num_vertices; index_vertices++)
+	{
+		vertices[index_vertices]-&gt;data = links+pos;
+		pos += vertices[index_vertices]-&gt;num_triangles;
+		vertices[index_vertices]-&gt;num_triangles = 0;
+	}
+
+	for (index_triangles = 0; index_triangles &lt; num_triangles; index_triangles++)
+	{
+		CL_OutlineTriangulator_Vertex *data_A = (CL_OutlineTriangulator_Vertex *) triangles[index_triangles].vertex_A-&gt;data;
+		CL_OutlineTriangulator_Vertex *data_B = (CL_OutlineTriangulator_Vertex *) triangles[index_triangles].vertex_B-&gt;data;
+		CL_OutlineTriangulator_Vertex *data_C = (CL_OutlineTriangulator_Vertex *) triangles[index_triangles].vertex_C-&gt;data;
+		data_A-&gt;triangles[data_A-&gt;num_triangles++] = &amp;triangles[index_triangles];
+		data_B-&gt;triangles[data_B-&gt;num_triangles++] = &amp;triangles[index_triangles];
+		data_C-&gt;triangles[data_C-&gt;num_triangles++] = &amp;triangles[index_triangles];
+	}
+
+	// 3.  Walk contours. Check if any triangles intersect with each line segment.
+	// 3a. Add each triangle's point that intersect to vertex buffer.
+	// 3b. Divide vertices into two lists, one for left and one for right side of line segment.
+	// 3c. Delauney triangulate each point list.
+	// 3d. Update links to include new triangles.
+	// 3e. Add the resulting triangles to triangles list.
+
+	std::list&lt;CL_DelauneyTriangulator_Triangle const *&gt; final_triangles;
+	for (index_triangles = 0; index_triangles &lt; num_triangles; index_triangles++)
+		final_triangles.push_back(&amp;triangles[index_triangles]);
+
+	std::vector&lt;CL_DelauneyTriangulator_Triangle const **&gt; added_links;
+	std::vector&lt;CL_DelauneyTriangulator&gt; extra_triangulations;
+
+	std::vector&lt;CL_OutlineTriangulator_Polygon&gt;::size_type index_polygons, num_polygons;
+	num_polygons = polygons.size();
+	for (index_polygons = 0; index_polygons &lt; num_polygons; index_polygons++)
+	{
+		CL_OutlineTriangulator_Polygon &amp;cur_poly = polygons[index_polygons];
+		std::vector&lt;CL_OutlineTriangulator_Contour&gt;::size_type index_contours, num_contours;
+		num_contours = cur_poly.contours.size();
+		for (index_contours = 0; index_contours &lt; num_contours; index_contours++)
+		{
+			CL_OutlineTriangulator_Contour &amp;cur_contour = cur_poly.contours[index_contours];
+			std::vector&lt;CL_OutlineTriangulator_Vertex&gt;::size_type index_vertices, num_vertices;
+			num_vertices = cur_contour.vertices.size();
+			for (index_vertices = 1; index_vertices &lt; num_vertices; index_vertices++)
+			{
+				CL_OutlineTriangulator_Vertex *vertex_1 = &amp;cur_contour.vertices[index_vertices-1];
+				CL_OutlineTriangulator_Vertex *vertex_2 = &amp;cur_contour.vertices[index_vertices];
+				CL_OutlineTriangulator_Collision collision = find_colliding_triangles(vertex_1, vertex_2);
+				if (collision.triangles.empty())
+					continue;
+
+				std::vector&lt;CL_OutlineTriangulator_Vertex *&gt;::size_type index_points, num_points;
+
+				// Triangulate left and right sides:
+
+				CL_DelauneyTriangulator delauney_first;
+				num_points = collision.first.size();
+				for (index_points = 0; index_points &lt; num_points; index_points++)
+				{
+					delauney.add_vertex(
+						collision.first[index_points]-&gt;x,
+						collision.first[index_points]-&gt;y,
+						collision.first[index_points]);
+				}
+				delauney_first.generate();
+
+				CL_DelauneyTriangulator delauney_second;
+				num_points = collision.second.size();
+				for (index_points = 0; index_points &lt; num_points; index_points++)
+				{
+					delauney.add_vertex(
+						collision.second[index_points]-&gt;x,
+						collision.second[index_points]-&gt;y,
+						collision.second[index_points]);
+				}
+				delauney_second.generate();
+
+				extra_triangulations.push_back(delauney_first);
+				extra_triangulations.push_back(delauney_second);
+
+				// Remove old triangles:
+
+				std::vector&lt;CL_DelauneyTriangulator_Triangle *&gt;::size_type index_old_triangles, size_old_triangles;
+				size_old_triangles = collision.triangles.size();
+				for (index_old_triangles = 0; index_old_triangles &lt; size_old_triangles; index_old_triangles++)
+				{
+					remove_triangle(collision.triangles[index_old_triangles]);
+					final_triangles.remove(collision.triangles[index_old_triangles]);
+				}
+
+				// Add new triangles:
+
+				CL_DelauneyTriangulator_Triangle const **new_links = add_triangles(delauney_first, delauney_second);
+				added_links.push_back(new_links);
+
+				const std::vector&lt;CL_DelauneyTriangulator_Triangle&gt; &amp;triangles1 = delauney_first.get_triangles();
+				const std::vector&lt;CL_DelauneyTriangulator_Triangle&gt; &amp;triangles2 = delauney_second.get_triangles();
+				std::vector&lt;CL_DelauneyTriangulator_Triangle&gt;::size_type index_triangles, num_triangles1, num_triangles2;
+				num_triangles1 = triangles1.size();
+				num_triangles2 = triangles2.size();
+				for (index_triangles = 0; index_triangles &lt; num_triangles1; index_triangles++)
+					final_triangles.push_back(&amp;triangles1[index_triangles]);
+				for (index_triangles = 0; index_triangles &lt; num_triangles2; index_triangles++)
+					final_triangles.push_back(&amp;triangles2[index_triangles]);
+			}
+		}
+	}
+
+	// 4. Remove outside and hole triangles.
+
+	// 5. Clean up:
+
+	delete[] links;
+	std::vector&lt;CL_DelauneyTriangulator_Triangle const **&gt;::size_type index_added_links, size_added_links;
+	size_added_links = added_links.size();
+	for (index_added_links = 0; index_added_links &lt; size_added_links; index_added_links++)
+	{
+		delete[] added_links[index_added_links];
+	}
+
+	// 6. Generate final list:
+
+
+
+}
+
+CL_DelauneyTriangulator_Triangle const **CL_OutlineTriangulator_Generic::add_triangles(
+	CL_DelauneyTriangulator &amp;d1,
+	CL_DelauneyTriangulator &amp;d2)
+{
+	const std::vector&lt;CL_DelauneyTriangulator_Triangle&gt; &amp;triangles1 = d1.get_triangles();
+	const std::vector&lt;CL_DelauneyTriangulator_Triangle&gt; &amp;triangles2 = d2.get_triangles();
+	std::vector&lt;CL_DelauneyTriangulator_Triangle&gt;::size_type index_triangles, num_triangles1, num_triangles2;
+	num_triangles1 = triangles1.size();
+	for (index_triangles = 0; index_triangles &lt; num_triangles1; index_triangles++)
+	{
+		CL_OutlineTriangulator_Vertex *data_A = (CL_OutlineTriangulator_Vertex *) triangles1[index_triangles].vertex_A-&gt;data;
+		CL_OutlineTriangulator_Vertex *data_B = (CL_OutlineTriangulator_Vertex *) triangles1[index_triangles].vertex_B-&gt;data;
+		CL_OutlineTriangulator_Vertex *data_C = (CL_OutlineTriangulator_Vertex *) triangles1[index_triangles].vertex_C-&gt;data;
+		data_A-&gt;extra++;
+		data_B-&gt;extra++;
+		data_C-&gt;extra++;
+	}
+	num_triangles2 = triangles2.size();
+	for (index_triangles = 0; index_triangles &lt; num_triangles2; index_triangles++)
+	{
+		CL_OutlineTriangulator_Vertex *data_A = (CL_OutlineTriangulator_Vertex *) triangles2[index_triangles].vertex_A-&gt;data;
+		CL_OutlineTriangulator_Vertex *data_B = (CL_OutlineTriangulator_Vertex *) triangles2[index_triangles].vertex_B-&gt;data;
+		CL_OutlineTriangulator_Vertex *data_C = (CL_OutlineTriangulator_Vertex *) triangles2[index_triangles].vertex_C-&gt;data;
+		data_A-&gt;extra++;
+		data_B-&gt;extra++;
+		data_C-&gt;extra++;
+	}
+
+	const std::vector&lt;CL_DelauneyTriangulator_Vertex&gt; &amp;vertices1 = d1.get_vertices();
+	const std::vector&lt;CL_DelauneyTriangulator_Vertex&gt; &amp;vertices2 = d2.get_vertices();
+	std::vector&lt;CL_DelauneyTriangulator_Vertex *&gt;::size_type index_vertices, num_vertices1, num_vertices2;
+	num_vertices1 = d1.get_vertices().size();
+	num_vertices2 = d2.get_vertices().size();
+
+	int links_needed = 0;
+	for (index_vertices = 0; index_vertices &lt; num_vertices1; index_vertices++)
+	{
+		CL_OutlineTriangulator_Vertex *v = (CL_OutlineTriangulator_Vertex *) vertices1[index_vertices].data;
+		links_needed += v-&gt;num_triangles + v-&gt;extra;
+	}
+	for (index_vertices = 0; index_vertices &lt; num_vertices2; index_vertices++)
+	{
+		CL_OutlineTriangulator_Vertex *v = (CL_OutlineTriangulator_Vertex *) vertices2[index_vertices].data;
+		links_needed += v-&gt;num_triangles + v-&gt;extra;
+	}
+
+	CL_DelauneyTriangulator_Triangle const **links = new CL_DelauneyTriangulator_Triangle const *[links_needed];
+	int pos = 0;
+	for (index_vertices = 0; index_vertices &lt; num_vertices1; index_vertices++)
+	{
+		CL_OutlineTriangulator_Vertex *v = (CL_OutlineTriangulator_Vertex *) vertices1[index_vertices].data;
+		if (v-&gt;extra == 0)
+			continue;
+
+		for (int i=0; i&lt;v-&gt;num_triangles; i++)
+			links[pos+i] = v-&gt;triangles[i];
+
+		v-&gt;data = links+pos;
+		pos += v-&gt;num_triangles + v-&gt;extra;
+		v-&gt;extra = 0;
+	}
+	for (index_vertices = 0; index_vertices &lt; num_vertices2; index_vertices++)
+	{
+		CL_OutlineTriangulator_Vertex *v = (CL_OutlineTriangulator_Vertex *) vertices2[index_vertices].data;
+		if (v-&gt;extra == 0)
+			continue;
+
+		for (int i=0; i&lt;v-&gt;num_triangles; i++)
+			links[pos+i] = v-&gt;triangles[i];
+
+		v-&gt;data = links+pos;
+		pos += v-&gt;num_triangles + v-&gt;extra;
+		v-&gt;extra = 0;
+	}
+
+	for (index_triangles = 0; index_triangles &lt; num_triangles1; index_triangles++)
+	{
+		CL_OutlineTriangulator_Vertex *data_A = (CL_OutlineTriangulator_Vertex *) triangles1[index_triangles].vertex_A-&gt;data;
+		CL_OutlineTriangulator_Vertex *data_B = (CL_OutlineTriangulator_Vertex *) triangles1[index_triangles].vertex_B-&gt;data;
+		CL_OutlineTriangulator_Vertex *data_C = (CL_OutlineTriangulator_Vertex *) triangles1[index_triangles].vertex_C-&gt;data;
+		data_A-&gt;triangles[data_A-&gt;num_triangles++] = &amp;triangles1[index_triangles];
+		data_B-&gt;triangles[data_B-&gt;num_triangles++] = &amp;triangles1[index_triangles];
+		data_C-&gt;triangles[data_C-&gt;num_triangles++] = &amp;triangles1[index_triangles];
+	}
+	for (index_triangles = 0; index_triangles &lt; num_triangles2; index_triangles++)
+	{
+		CL_OutlineTriangulator_Vertex *data_A = (CL_OutlineTriangulator_Vertex *) triangles2[index_triangles].vertex_A-&gt;data;
+		CL_OutlineTriangulator_Vertex *data_B = (CL_OutlineTriangulator_Vertex *) triangles2[index_triangles].vertex_B-&gt;data;
+		CL_OutlineTriangulator_Vertex *data_C = (CL_OutlineTriangulator_Vertex *) triangles2[index_triangles].vertex_C-&gt;data;
+		data_A-&gt;triangles[data_A-&gt;num_triangles++] = &amp;triangles2[index_triangles];
+		data_B-&gt;triangles[data_B-&gt;num_triangles++] = &amp;triangles2[index_triangles];
+		data_C-&gt;triangles[data_C-&gt;num_triangles++] = &amp;triangles2[index_triangles];
+	}
+
+	return links;
+}
+
+CL_OutlineTriangulator_Collision CL_OutlineTriangulator_Generic::find_colliding_triangles(
+	CL_OutlineTriangulator_Vertex *v1,
+	CL_OutlineTriangulator_Vertex *v2)
+{
+	CL_OutlineTriangulator_Collision collision;
+
+	for (int index_triangles = 0; index_triangles &lt; v1-&gt;num_triangles; index_triangles++)
+	{
+		CL_OutlineTriangulator_Vertex *vA = (CL_OutlineTriangulator_Vertex *) v1-&gt;triangles[index_triangles]-&gt;vertex_A-&gt;data;
+		CL_OutlineTriangulator_Vertex *vB = (CL_OutlineTriangulator_Vertex *) v1-&gt;triangles[index_triangles]-&gt;vertex_B-&gt;data;
+		CL_OutlineTriangulator_Vertex *vC = (CL_OutlineTriangulator_Vertex *) v1-&gt;triangles[index_triangles]-&gt;vertex_C-&gt;data;
+
+		// If an edge is same line as the constrained line, there can be no colliding triangles:
+		if (
+			(v1 == vA &amp;&amp; v2 == vB) ||
+			(v1 == vB &amp;&amp; v2 == vA) ||
+			(v1 == vB &amp;&amp; v2 == vC) ||
+			(v1 == vC &amp;&amp; v2 == vB) ||
+			(v1 == vC &amp;&amp; v2 == vA) ||
+			(v1 == vA &amp;&amp; v2 == vC))
+			return collision;
+
+		bool intersectsA, intersectsB, intersectsC;
+
+		if (v1 == vA || v1 == vB || v2 == vA || v2 == vB)
+			intersectsA = false;
+		else
+			intersectsA = intersects(
+				v1-&gt;x, v1-&gt;y, v2-&gt;x, v2-&gt;y,
+				v1-&gt;triangles[index_triangles]-&gt;vertex_A-&gt;x,
+				v1-&gt;triangles[index_triangles]-&gt;vertex_A-&gt;y,
+				v1-&gt;triangles[index_triangles]-&gt;vertex_B-&gt;x,
+				v1-&gt;triangles[index_triangles]-&gt;vertex_B-&gt;y);
+
+		if (v1 == vB || v1 == vC || v2 == vB || v2 == vC)
+			intersectsB = false;
+		else
+			intersectsB = intersects(
+				v1-&gt;x, v1-&gt;y, v2-&gt;x, v2-&gt;y,
+				v1-&gt;triangles[index_triangles]-&gt;vertex_B-&gt;x,
+				v1-&gt;triangles[index_triangles]-&gt;vertex_B-&gt;y,
+				v1-&gt;triangles[index_triangles]-&gt;vertex_C-&gt;x,
+				v1-&gt;triangles[index_triangles]-&gt;vertex_C-&gt;y);
+
+		if (v1 == vC || v1 == vA || v2 == vC || v2 == vA)
+			intersectsC = false;
+		else
+			intersectsC = intersects(
+				v1-&gt;x, v1-&gt;y, v2-&gt;x, v2-&gt;y,
+				v1-&gt;triangles[index_triangles]-&gt;vertex_C-&gt;x,
+				v1-&gt;triangles[index_triangles]-&gt;vertex_C-&gt;y,
+				v1-&gt;triangles[index_triangles]-&gt;vertex_A-&gt;x,
+				v1-&gt;triangles[index_triangles]-&gt;vertex_A-&gt;y);
+
+		if (intersectsA == false &amp;&amp; intersectsB == false &amp;&amp; intersectsC == false)
+			continue;
+
+		// Collision. Add all points to the correct side of the intersected line:
+
+		collision.triangles.push_back(v1-&gt;triangles[index_triangles]);
+
+		if (vA == v1 || vA == v2)
+		{
+			collision.first.push_back(vA);
+			collision.second.push_back(vA);
+		}
+		else if (CL_LineMath::point_right_of_line(vA-&gt;x, vA-&gt;y, v1-&gt;x, v1-&gt;y, v2-&gt;x, v2-&gt;y))
+		{
+			collision.second.push_back(vA);
+		}
+		else
+		{
+			collision.first.push_back(vA);
+		}
+
+		if (vB == v1 || vB == v2)
+		{
+			collision.first.push_back(vB);
+			collision.second.push_back(vB);
+		}
+		else if (CL_LineMath::point_right_of_line(vB-&gt;x, vB-&gt;y, v1-&gt;x, v1-&gt;y, v2-&gt;x, v2-&gt;y))
+		{
+			collision.second.push_back(vB);
+		}
+		else
+		{
+			collision.first.push_back(vB);
+		}
+
+		if (vC == v1 || vC == v2)
+		{
+			collision.first.push_back(vC);
+			collision.second.push_back(vC);
+		}
+		else if (CL_LineMath::point_right_of_line(vC-&gt;x, vC-&gt;y, v1-&gt;x, v1-&gt;y, v2-&gt;x, v2-&gt;y))
+		{
+			collision.second.push_back(vC);
+		}
+		else
+		{
+			collision.first.push_back(vC);
+		}
+	}
+
+	return collision;
+}
+
+void CL_OutlineTriangulator_Generic::remove_triangle(CL_DelauneyTriangulator_Triangle const *t)
+{
+	for (int vertex = 0; vertex &lt; 3; vertex++)
+	{
+		CL_OutlineTriangulator_Vertex *data = 0;
+		switch (vertex)
+		{
+		case 0:
+			data = (CL_OutlineTriangulator_Vertex *) t-&gt;vertex_A-&gt;data;
+			break;
+
+		case 1:
+			data = (CL_OutlineTriangulator_Vertex *) t-&gt;vertex_B-&gt;data;
+			break;
+
+		case 2:
+			data = (CL_OutlineTriangulator_Vertex *) t-&gt;vertex_C-&gt;data;
+			break;
+		}
+
+		for (int index = 0; index &lt; data-&gt;num_triangles; index++)
+		{
+			if (data-&gt;triangles[index] == t)
+			{
+				for (int index2 = index; index2 &lt; data-&gt;num_triangles-1; index2++)
+				{
+					data-&gt;triangles[index2] = data-&gt;triangles[index2+1];
+				}
+				index--;
+				data-&gt;num_triangles--;
+			}
+		}
+	}
+}
+
+struct CL_CompareVertices
+{
+	bool operator()(CL_OutlineTriangulator_Vertex *a, CL_OutlineTriangulator_Vertex *b) const
+	{
+		if (a-&gt;x == b-&gt;x) return a-&gt;y &lt; b-&gt;y;
+		return a-&gt;x &lt; b-&gt;x;
+	}
+};
+
+void CL_OutlineTriangulator_Generic::create_ordered_vertex_list(std::vector&lt;CL_OutlineTriangulator_Vertex *&gt; &amp;vertices)
+{
+	std::vector&lt;CL_OutlineTriangulator_Polygon&gt;::size_type index_polygons, num_polygons;
+	num_polygons = polygons.size();
+	for (index_polygons = 0; index_polygons &lt; num_polygons; index_polygons++)
+	{
+		CL_OutlineTriangulator_Polygon &amp;cur_poly = polygons[index_polygons];
+		std::vector&lt;CL_OutlineTriangulator_Contour&gt;::size_type index_contours, num_contours;
+		num_contours = cur_poly.contours.size();
+		for (index_contours = 0; index_contours &lt; num_contours; index_contours++)
+		{
+			CL_OutlineTriangulator_Contour &amp;cur_contour = cur_poly.contours[index_contours];
+			std::vector&lt;CL_OutlineTriangulator_Vertex&gt;::size_type index_vertices, num_vertices;
+			num_vertices = cur_contour.vertices.size();
+			for (index_vertices = 0; index_vertices &lt; num_vertices; index_vertices++)
+			{
+				vertices.push_back(&amp;cur_contour.vertices[index_vertices]);
+			}
+		}
+	}
+
+	// Sort list:
+	std::sort(vertices.begin(), vertices.end(), CL_CompareVertices());
+
+	// Remove duplicates:
+	std::vector&lt;CL_OutlineTriangulator_Vertex *&gt;::iterator it = vertices.begin();
+	if (it == vertices.end()) return;
+	double last_x = (*it)-&gt;x;
+	double last_y = (*it)-&gt;y;
+	++it;
+	while (it != vertices.end())
+	{
+		if (last_x == (*it)-&gt;x &amp;&amp; last_y == (*it)-&gt;y)
+		{
+			it = vertices.erase(it);
+		}
+		else
+		{
+			last_x = (*it)-&gt;x;
+			last_y = (*it)-&gt;y;
+			++it;
+		}
+	}
+}
+
+bool CL_OutlineTriangulator_Generic::intersects( 
+	double Ax,
+	double Ay,
+	double Bx,
+	double By,
+	double Cx,
+	double Cy,
+	double Dx,
+	double Dy)
+{
+	double denominator = ((Bx-Ax)*(Dy-Cy)-(By-Ay)*(Dx-Cx));	
+	
+	if( denominator == 0 ) // parallell
+	{
+		return false;
+	}
+
+	double r = ((Ay-Cy)*(Dx-Cx)-(Ax-Cx)*(Dy-Cy)) / denominator;
+	double s = ((Ay-Cy)*(Bx-Ax)-(Ax-Cx)*(By-Ay)) / denominator;
+
+	if( (s &gt; 0.0f &amp;&amp; s &lt; 1.0f) &amp;&amp; (r &gt; 0.0f &amp;&amp; r &lt; 1.0f) )
+		return true;
+
+	return false;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OutlineTriangulator_Generic implementation:

Added: trunk/clanlib/Core/Math/outline_triangulator_generic.h
===================================================================
--- trunk/clanlib/Core/Math/outline_triangulator_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Math/outline_triangulator_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,114 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_outline_triangulator_generic
+#define header_outline_triangulator_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+class CL_DelauneyTriangulator;
+class CL_DelauneyTriangulator_Triangle;
+
+struct CL_OutlineTriangulator_Vertex
+{
+	void *data;
+	double x, y;
+	int num_triangles;
+	int extra;
+	CL_DelauneyTriangulator_Triangle const **triangles;
+};
+
+struct CL_OutlineTriangulator_Contour
+{
+	std::vector&lt;CL_OutlineTriangulator_Vertex&gt; vertices;
+};
+
+struct CL_OutlineTriangulator_Polygon
+{
+	std::vector&lt;CL_OutlineTriangulator_Contour&gt; contours;
+};
+
+struct CL_OutlineTriangulator_Collision
+{
+	std::vector&lt;CL_OutlineTriangulator_Vertex *&gt; first;
+	std::vector&lt;CL_OutlineTriangulator_Vertex *&gt; second;
+	std::vector&lt;CL_DelauneyTriangulator_Triangle const *&gt; triangles;
+};
+
+class CL_OutlineTriangulator_Generic
+{
+//! Construction:
+public:
+	CL_OutlineTriangulator_Generic();
+
+	~CL_OutlineTriangulator_Generic();
+
+//! Attributes:
+public:
+	CL_OutlineTriangulator_Polygon current_polygon;
+
+	CL_OutlineTriangulator_Contour current_contour;
+
+	std::vector&lt;CL_OutlineTriangulator_Polygon&gt; polygons;
+
+//	std::vector&lt;CL_OutlineTriangulator_Triangle&gt; triangles;
+
+//! Operations:
+public:
+	void insert_points();
+
+	void triangulate();
+
+	void create_ordered_vertex_list(
+		std::vector&lt;CL_OutlineTriangulator_Vertex *&gt; &amp;vertices);
+
+	CL_OutlineTriangulator_Collision find_colliding_triangles(
+		CL_OutlineTriangulator_Vertex *v1,
+		CL_OutlineTriangulator_Vertex *v2);
+
+	void remove_triangle(CL_DelauneyTriangulator_Triangle const *t);
+
+	CL_DelauneyTriangulator_Triangle const **add_triangles(
+		CL_DelauneyTriangulator &amp;d1,
+		CL_DelauneyTriangulator &amp;d2);
+
+	bool intersects(
+		double Ax,
+		double Ay,
+		double Bx,
+		double By,
+		double Cx,
+		double Cy,
+		double Dx,
+		double Dy);
+};
+
+#endif

Added: trunk/clanlib/Core/Math/pointset_math.cpp
===================================================================
--- trunk/clanlib/Core/Math/pointset_math.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Math/pointset_math.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,254 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Emanuel Greisen
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &lt;cmath&gt;
+
+#include &quot;API/Core/Math/pointset_math.h&quot;
+#include &quot;API/Core/Math/circle.h&quot;
+#include &quot;API/Core/Math/line_math.h&quot;
+#include &quot;API/Core/Math/point.h&quot;
+
+
+CL_Circlef CL_PointSetMath::minimum_enclosing_disc( const std::vector&lt;CL_Pointf&gt; &amp;points )
+{
+	CL_Circlef smalldisc;
+
+	if(points.size() == 0)
+	{
+		// ERROR !!!!
+		smalldisc.position = CL_Pointf(0.0f, 0.0f);
+		smalldisc.radius = 0.0;
+	}
+	else if(points.size() == 1)
+	{
+		smalldisc.position = points[0];
+		smalldisc.radius = 0.0;
+	}
+	else
+	{
+		int start = 0;
+		int end = points.size() - 1;
+		//TODO: random permutation of the vector...
+
+		// Calculate the disc
+		calculate_minimum_enclosing_disc(smalldisc, points, start, end);
+	}
+
+	return smalldisc;
+}
+
+void CL_PointSetMath::calculate_minimum_enclosing_disc(
+	CL_Circlef &amp;smalldisc,
+	const std::vector&lt;CL_Pointf&gt; &amp;points,
+	int start, int end)
+{
+	// Get first disc (between the first two points)
+	smalldisc.position = CL_LineMath::midpoint(points[start], points[start+1]);
+	smalldisc.radius   = points[start].distance(points[start+1]) / 2.0;
+
+	// Now start the loop
+	for(int i = start+2; i &lt;= end; i++)
+	{
+		// only enlargen the circle if points[i] is not already contained
+		if(smalldisc.position.distance(points[i]) &gt; smalldisc.radius)
+		{
+			minimum_disc_with_1point(smalldisc, points, start, i);
+		}
+	}
+}
+
+
+void CL_PointSetMath::minimum_disc_with_1point(
+	CL_Circlef &amp;smalldisc,
+	const std::vector&lt;CL_Pointf&gt; &amp;points,
+	int start,
+	unsigned int i)
+{
+	// Get first disc (between the first point and `points[i]`)
+	smalldisc.position = CL_LineMath::midpoint(points[start], points[i]);
+	smalldisc.radius   = points[start].distance(points[i]) / 2.0;
+	
+	for(unsigned int j = start+1; j &lt; i; j++)
+	{
+		// only enlargen the circle if points[i] is not already contained
+		if(smalldisc.position.distance(points[j]) &gt; smalldisc.radius)
+		{
+			minimum_disc_with_2points(smalldisc, points, start, i, j);
+		}
+	}
+}
+
+
+void CL_PointSetMath::minimum_disc_with_2points(
+	CL_Circlef &amp;smalldisc,
+	const std::vector&lt;CL_Pointf&gt; &amp;points,
+	int start,
+	unsigned int i,
+	unsigned int j)
+{
+	// Get first disc (between `points[i]` and `points[j]`)
+	smalldisc.position = CL_LineMath::midpoint(points[i], points[j]);
+	smalldisc.radius   = points[i].distance(points[j]) / 2.0;
+
+	for(unsigned int k = start; k &lt; j; k++)
+	{
+		if(k == i || k == j)
+			continue;
+		
+		// only enlargen the circle if points[i] is not already contained
+		if(smalldisc.position.distance(points[k]) &gt; smalldisc.radius)
+		{
+			minimum_disc_with_3points(smalldisc, points, i, j, k);
+		}
+	}
+}
+
+void CL_PointSetMath::minimum_disc_with_3points(
+	CL_Circlef &amp;smalldisc,
+	const std::vector&lt;CL_Pointf&gt; &amp;points,
+	unsigned int i,
+	unsigned int j,
+	unsigned int k)
+{
+	// There is only one circle with all three points on its boundary.
+
+	// Find center:
+	// <A HREF="http://astronomy.swin.edu.au/~pbourke/geometry/circlefrom3/">http://astronomy.swin.edu.au/~pbourke/geometry/circlefrom3/</A>
+	// 
+	CL_Pointf ji_mid  = CL_LineMath::midpoint(points[i],points[j]);
+	CL_Pointf ji_norm = ji_mid + CL_Pointf(points[i].y - ji_mid.y, -(points[i].x - ji_mid.x));
+	CL_Pointf ki_mid  = CL_LineMath::midpoint(points[k],points[i]);
+	CL_Pointf ki_norm = ki_mid + CL_Pointf(points[k].y - ki_mid.y, -(points[k].x - ki_mid.x));
+
+	float lineA[4] = {ji_mid.x, ji_mid.y, ji_norm.x, ji_norm.y };
+	float lineB[4] = {ki_mid.x, ki_mid.y, ki_norm.x, ki_norm.y };
+
+	smalldisc.position = CL_LineMath::get_intersection( lineA, lineB );
+
+	// Since (i,j,k) are all on the circle, just get distance to one of them
+	smalldisc.radius = smalldisc.position.distance(points[i]);
+}
+
+
+
+
+// Descending date sorting function
+struct PointAngleSorter
+{
+	CL_Pointf basepoint;
+	PointAngleSorter(const CL_Pointf &amp;p) : basepoint(p){};
+	
+	bool operator()(const CL_Pointf &amp;p1, const CL_Pointf &amp;p2)
+	{
+		return atan2(basepoint.x - p1.x, basepoint.y - p1.y) &lt; atan2(basepoint.x - p2.x, basepoint.y - p2.y);
+	}
+};
+
+
+/**
+ * OPTIMIZE: we could make it only work in the &quot;points&quot;-vector, instead of returning
+ *           the resulting convex hull. That would save memory, and such.
+ */
+std::vector&lt;CL_Pointf&gt; CL_PointSetMath::convex_hull_from_polygon(std::vector&lt;CL_Pointf&gt; &amp;points)
+{
+	// First we find the point with the lowest x-value (left most point, must be on the convex hull)
+	unsigned int leftpoint = 0;
+	unsigned int rightpoint = 0;
+	unsigned int i;
+	for(i = 1; i &lt; points.size(); i++)
+	{
+		if((points[leftpoint].x == points[i].x &amp;&amp; points[i].y &gt; points[leftpoint].y)
+			 || (points[i].x &lt; points[leftpoint].x))
+		{
+			leftpoint = i;
+		}
+		if((points[rightpoint].x == points[i].x &amp;&amp; points[i].y &lt; points[rightpoint].y)
+			 || (points[i].x &gt; points[rightpoint].x))
+		{
+			rightpoint = i;
+		}
+	}
+	
+	// init our convex hull
+	std::vector&lt;CL_Pointf&gt; hull;
+	hull.clear();
+	hull.push_back(points[leftpoint]);
+
+	// Keep track of the right end-point
+	CL_Pointf rightp(points[rightpoint]);
+	CL_Pointf leftp(points[leftpoint]);
+	
+	// Now we start at the left point, and walk down to generate
+	// the lower half of the convex hull
+	i = (leftpoint+1) % points.size();
+	for(; i != rightpoint; i = (i+1) % points.size())
+	{
+		// Only insert the point if it is on the convex hull
+		if(CL_LineMath::point_right_of_line(hull.back(), points[i], rightp) &lt; 0.0f)
+		{
+			hull.push_back(points[i]);
+			
+			// remove any left-turns behind us
+			while(hull.size() &gt; 2 &amp;&amp;
+				CL_LineMath::point_right_of_line(hull[hull.size()-3], hull[hull.size()-2], hull[hull.size()-1]) &gt;= 0.0f)
+			{
+				// Erase the second backmost point
+				hull[hull.size()-2] = hull[hull.size()-1];
+				hull.pop_back();
+			}
+		}
+	}
+
+	// Add the right-point (it's on the convex hull for sure)
+	hull.push_back(points[rightpoint]);
+
+	// Now we start at the right point, and walk up to generate
+	// the upper half of the convex hull
+	i = (rightpoint+1) % points.size();
+	for(; i != leftpoint; i = (i+1) % points.size())
+	{
+		// Only insert the point if it is on the convex hull
+		if(CL_LineMath::point_right_of_line(hull.back(), points[i], leftp) &lt; 0.0f)
+		{
+			hull.push_back(points[i]);
+			
+			// remove any left-turns behind us
+			while(hull.size() &gt; 2 &amp;&amp;
+				CL_LineMath::point_right_of_line(hull[hull.size()-3], hull[hull.size()-2], hull[hull.size()-1]) &gt;= 0.0f)
+			{
+				// Erase the second backmost point
+				hull[hull.size()-2] = hull[hull.size()-1];
+				hull.pop_back();
+			}
+		}
+	}
+
+	return hull;
+}

Added: trunk/clanlib/Core/Math/quad.cpp
===================================================================
--- trunk/clanlib/Core/Math/quad.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Math/quad.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,92 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/Math/quad.h&quot;
+
+#include &lt;cmath&gt;
+
+#define cl_min(a,b) ((a &lt; b) ? a : b)
+#define cl_max(a,b) ((a &gt; b) ? a : b)
+
+int CL_Quad::get_width() const
+{
+	return cl_max(cl_max(cl_max(x1, x2), x3), x4) 
+		- cl_min(cl_min(cl_min(x1, x2), x3), x4);
+}
+
+int CL_Quad::get_height() const
+{
+	return cl_max(cl_max(cl_max(y1, y2), y3), y4) 
+		- cl_min(cl_min(cl_min(y1, y2), y3), y4);
+}
+
+CL_Rect CL_Quad::get_bounds() const
+{ return CL_Rect( 
+		cl_min(cl_min(cl_min(x1, x2), x3), x4), 
+		cl_min(cl_min(cl_min(y1, y2), y3), y4), 
+		cl_max(cl_max(cl_max(x1, x2), x3), x4), 
+		cl_max(cl_max(cl_max(y1, y2), y3), y4)); 
+}
+
+void CL_Quad::rotate(const CL_Point &amp;hotspot, float angle)
+{
+	//Find the rotated positions of each corner
+	CL_Point p1 = CL_Point(x1, y1).rotate(hotspot, angle);
+	CL_Point p2 = CL_Point(x2, y2).rotate(hotspot, angle);
+	CL_Point p3 = CL_Point(x3, y3).rotate(hotspot, angle);
+	CL_Point p4 = CL_Point(x4, y4).rotate(hotspot, angle);
+	
+	x1 = p1.x; y1 = p1.y;
+	x2 = p2.x; y2 = p2.y;
+	x3 = p3.x; y3 = p3.y;
+	x4 = p4.x; y4 = p4.y;
+}
+
+void CL_Quad::scale(const CL_Point &amp;hotspot, float sx, float sy)
+{
+	x1 = (int)((x1-hotspot.x)*sx+hotspot.x); y1 = (int)((y1-hotspot.y)*sy+hotspot.y);
+	x2 = (int)((x2-hotspot.x)*sx+hotspot.x); y2 = (int)((y2-hotspot.y)*sy+hotspot.y);
+	x3 = (int)((x3-hotspot.x)*sx+hotspot.x); y3 = (int)((y3-hotspot.y)*sy+hotspot.y);
+	x4 = (int)((x4-hotspot.x)*sx+hotspot.x); y4 = (int)((y4-hotspot.y)*sy+hotspot.y);
+}
+
+void CL_Quad::scale(float sx, float sy)
+{
+	x1 = (int)(x1*sx); y1 = (int)(y1*sy);
+	x2 = (int)(x2*sx); y2 = (int)(y2*sy);
+	x3 = (int)(x3*sx); y3 = (int)(y3*sy);
+	x4 = (int)(x4*sx); y4 = (int)(y4*sy);
+}
+
+CL_Point CL_Quad::center() const
+{
+	CL_Rect r = get_bounds();
+	return CL_Point((r.left+r.right)/2, (r.top+r.bottom)/2);
+}

Added: trunk/clanlib/Core/Math/rect.cpp
===================================================================
--- trunk/clanlib/Core/Math/rect.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Math/rect.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,86 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/Math/rect.h&quot;
+
+#include &lt;cmath&gt;
+
+#define cl_min(a,b) ((a &lt; b) ? a : b)
+#define cl_max(a,b) ((a &gt; b) ? a : b)
+
+CL_Rect CL_Rect::get_rot_bounds(const CL_Point &amp;hotspot, float angle) const
+{
+	//Find the rotated positions of each corner
+	CL_Rect retVal(*this);
+	CL_Point ul = CL_Point(retVal.left, retVal.top).rotate(hotspot, angle);
+	CL_Point ur = CL_Point(retVal.right, retVal.top).rotate(hotspot, angle);
+	CL_Point ll = CL_Point(retVal.left, retVal.bottom).rotate(hotspot, angle);
+	CL_Point lr = CL_Point(retVal.right, retVal.bottom).rotate(hotspot, angle);
+	
+	//Use the sidemost corners as the bounds of the new rectangle
+	retVal.left = cl_min(cl_min(ul.x, ur.x), cl_min(ll.x, lr.x));
+	retVal.right = cl_max(cl_max(ul.x, ur.x), cl_max(ll.x, lr.x));
+	retVal.top = cl_min(cl_min(ul.y, ur.y), cl_min(ll.y, lr.y));
+	retVal.bottom = cl_max(cl_max(ul.y, ur.y), cl_max(ll.y, lr.y));
+	
+	return retVal;
+}
+
+CL_Rect CL_Rect::get_rot_bounds(CL_Origin origin, int x, int y, float angle) const
+{
+	return get_rot_bounds(
+		CL_Point(left, top) + calc_origin(origin, get_size()) + CL_Point(x, y),
+		angle);
+}
+
+CL_Rectf CL_Rectf::get_rot_bounds(const CL_Pointf &amp;hotspot, float angle) const
+{
+	//Find the rotated positions of each corner
+	CL_Rectf retVal(*this);
+	CL_Pointf ul = CL_Pointf(retVal.left, retVal.top).rotate(hotspot, angle);
+	CL_Pointf ur = CL_Pointf(retVal.right, retVal.top).rotate(hotspot, angle);
+	CL_Pointf ll = CL_Pointf(retVal.left, retVal.bottom).rotate(hotspot, angle);
+	CL_Pointf lr = CL_Pointf(retVal.right, retVal.bottom).rotate(hotspot, angle);
+	
+	//Use the sidemost corners as the bounds of the new rectangle
+	retVal.left = cl_min(cl_min(ul.x, ur.x), cl_min(ll.x, lr.x));
+	retVal.right = cl_max(cl_max(ul.x, ur.x), cl_max(ll.x, lr.x));
+	retVal.top = cl_min(cl_min(ul.y, ur.y), cl_min(ll.y, lr.y));
+	retVal.bottom = cl_max(cl_max(ul.y, ur.y), cl_max(ll.y, lr.y));
+	
+	return retVal;
+}
+
+CL_Rectf CL_Rectf::get_rot_bounds(CL_Origin origin, float x, float y, float angle) const
+{
+	return get_rot_bounds(
+		CL_Pointf(left, top) + calc_origin(origin, get_size()) + CL_Pointf(x, y),
+		angle);
+}

Added: trunk/clanlib/Core/Math/triangle_math.cpp
===================================================================
--- trunk/clanlib/Core/Math/triangle_math.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Math/triangle_math.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,80 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &lt;cmath&gt;
+#include &quot;API/Core/Math/triangle_math.h&quot;
+
+/*
+	---- from comp.graphics.algorithms FAQ ----
+
+	calculate the barycentric coordinates
+	for a triangle {(x1,y1), (x2,y2), (x3,y3)} and some point (x0,y0)
+
+	Then if b1, b2, and b3 are all &gt; 0, (x0,y0) is strictly inside the triangle;
+
+	if bi = 0 and the other two coordinates are positive,
+	(x0,y0) lies on the edge opposite (xi,yi);
+	
+	if bi and bj = 0, (x0,y0) lies on (xk,yk); if bi &lt; 0,
+	(x0,y0) lies outside the edge opposite (xi,yi);
+
+	if all three coordinates are negative, something else is wrong.
+*/
+
+bool CL_TriangleMath::point_inside_triangle(const CL_Pointf &amp;P, float *vertices, bool on_edge_is_outside)
+{
+	return point_inside_triangle(P.x, P.y, vertices, on_edge_is_outside);
+}
+
+bool CL_TriangleMath::point_inside_triangle( float px, float py, float *vertices, bool on_edge_is_outside)
+{
+	const float &amp;tx0 = vertices[0];
+	const float &amp;ty0 = vertices[1];
+	const float &amp;tx1 = vertices[2];
+	const float &amp;ty1 = vertices[3];
+	const float &amp;tx2 = vertices[4];
+	const float &amp;ty2 = vertices[5];
+
+	float b0 =  (tx1 - tx0) * (ty2 - ty0) - (tx2 - tx0) * (ty1 - ty0);
+	float b1 = ((tx1 - px)  * (ty2 - py)  - (tx2 - px)  * (ty1 - py)) / b0;
+	float b2 = ((tx2 - px)  * (ty0 - py)  - (tx0 - px)  * (ty2 - py)) / b0;
+	float b3 = ((tx0 - px)  * (ty1 - py)  - (tx1 - px)  * (ty0 - py)) / b0;
+	
+	if( (b1 &gt; 0 &amp;&amp; b2 &gt; 0 &amp;&amp; b3 &gt; 0) ) // strictly inside
+	{
+		return true;
+	}
+	
+	if( on_edge_is_outside == false ) // on edge?
+		if( (b1&gt;=0 &amp;&amp; b2&gt;=0 &amp;&amp; b3&gt;=0) &amp;&amp; (b1+b2+b3) &gt;= 0 )  
+			return true;
+	
+	return false;
+}

Added: trunk/clanlib/Core/Math/vector2.cpp
===================================================================
--- trunk/clanlib/Core/Math/vector2.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Math/vector2.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,325 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magic Software - www.magic-software.com
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/Math/vector2.h&quot;
+#include &lt;math.h&gt;
+#include &lt;float.h&gt;
+
+const CL_Vector2 CL_Vector2::ZERO(0.0f,0.0f);
+const CL_Vector2 CL_Vector2::UNIT_X(1.0f,0.0f);
+const CL_Vector2 CL_Vector2::UNIT_Y(0.0f,1.0f);
+float CL_Vector2::FUZZ = 0.0f;
+
+CL_Vector2::CL_Vector2(float fX, float fY)
+{
+    x = fX;
+    y = fY;
+}
+
+CL_Vector2::CL_Vector2(float afCoordinate[2])
+{
+    x = afCoordinate[0];
+    y = afCoordinate[1];
+}
+
+CL_Vector2::CL_Vector2(const CL_Vector2&amp; rkVector)
+{
+    x = rkVector.x;
+    y = rkVector.y;
+}
+
+CL_Vector2&amp; CL_Vector2::operator=(const CL_Vector2&amp; rkVector)
+{
+    x = rkVector.x;
+    y = rkVector.y;
+    return *this;
+}
+
+bool CL_Vector2::operator==(const CL_Vector2&amp; rkVector) const
+{
+    if ( FUZZ == 0.0f )
+        return x == rkVector.x &amp;&amp; y == rkVector.y;
+    else
+        return fabs(x-rkVector.x) &lt;= FUZZ &amp;&amp; fabs(y-rkVector.y) &lt;= FUZZ;
+}
+
+bool CL_Vector2::operator!=(const CL_Vector2&amp; rkVector) const
+{
+    if ( FUZZ == 0.0f )
+        return x != rkVector.x || y != rkVector.y;
+    else
+        return fabs(x-rkVector.x) &gt; FUZZ || fabs(y-rkVector.y) &gt; FUZZ;
+}
+
+bool CL_Vector2::operator&lt;(const CL_Vector2&amp; rkVector) const
+{
+    float fXTmp = rkVector.x, fYTmp = rkVector.y;
+    if ( FUZZ &gt; 0.0f )
+    {
+        if ( fabs(x - fXTmp) &lt;= FUZZ )
+            fXTmp = x;
+        if ( fabs(y - fYTmp) &lt;= FUZZ )
+            fYTmp = y;
+    }
+
+    // compare y values
+    unsigned int uiTest0 = *(unsigned int*)&y;
+    unsigned int uiTest1 = *(unsigned int*)&fYTmp;
+    if ( uiTest0 &lt; uiTest1 )
+        return true;
+    if ( uiTest0 &gt; uiTest1 )
+        return false;
+
+    // compare x values
+    uiTest0 = *(unsigned int*)&x;
+    uiTest1 = *(unsigned int*)&fXTmp;
+    return uiTest0 &lt; uiTest1;
+}
+
+bool CL_Vector2::operator&lt;=(const CL_Vector2&amp; rkVector) const
+{
+    float fXTmp = rkVector.x, fYTmp = rkVector.y;
+    if ( FUZZ &gt; 0.0f )
+    {
+        if ( fabs(x - fXTmp) &lt;= FUZZ )
+            fXTmp = x;
+        if ( fabs(y - fYTmp) &lt;= FUZZ )
+            fYTmp = y;
+    }
+
+    // compare y values
+    unsigned int uiTest0 = *(unsigned int*)&y;
+    unsigned int uiTest1 = *(unsigned int*)&fYTmp;
+    if ( uiTest0 &lt; uiTest1 )
+        return true;
+    if ( uiTest0 &gt; uiTest1 )
+        return false;
+
+    // compare x values
+    uiTest0 = *(unsigned int*)&x;
+    uiTest1 = *(unsigned int*)&fXTmp;
+    return uiTest0 &lt;= uiTest1;
+}
+
+bool CL_Vector2::operator&gt;(const CL_Vector2&amp; rkVector) const
+{
+    float fXTmp = rkVector.x, fYTmp = rkVector.y;
+    if ( FUZZ &gt; 0.0f )
+    {
+        if ( fabs(x - fXTmp) &lt;= FUZZ )
+            fXTmp = x;
+        if ( fabs(y - fYTmp) &lt;= FUZZ )
+            fYTmp = y;
+    }
+
+    // compare y values
+    unsigned int uiTest0 = *(unsigned int*)&y;
+    unsigned int uiTest1 = *(unsigned int*)&fYTmp;
+    if ( uiTest0 &gt; uiTest1 )
+        return true;
+    if ( uiTest0 &lt; uiTest1 )
+        return false;
+
+    // compare x values
+    uiTest0 = *(unsigned int*)&x;
+    uiTest1 = *(unsigned int*)&fXTmp;
+    return uiTest0 &gt; uiTest1;
+}
+
+bool CL_Vector2::operator&gt;=(const CL_Vector2&amp; rkVector) const
+{
+    float fXTmp = rkVector.x, fYTmp = rkVector.y;
+    if ( FUZZ &gt; 0.0f )
+    {
+        if ( fabs(x - fXTmp) &lt;= FUZZ )
+            fXTmp = x;
+        if ( fabs(y - fYTmp) &lt;= FUZZ )
+            fYTmp = y;
+    }
+
+    // compare y values
+    unsigned int uiTest0 = *(unsigned int*)&y;
+    unsigned int uiTest1 = *(unsigned int*)&fYTmp;
+    if ( uiTest0 &gt; uiTest1 )
+        return true;
+    if ( uiTest0 &lt; uiTest1 )
+        return false;
+
+    // compare x values
+    uiTest0 = *(unsigned int*)&x;
+    uiTest1 = *(unsigned int*)&fXTmp;
+    return uiTest0 &gt;= uiTest1;
+}
+
+CL_Vector2 CL_Vector2::operator+(const CL_Vector2&amp; rkVector) const
+{
+    return CL_Vector2(x+rkVector.x,y+rkVector.y);
+}
+
+CL_Vector2 CL_Vector2::operator-(const CL_Vector2&amp; rkVector) const
+{
+    return CL_Vector2(x-rkVector.x,y-rkVector.y);
+}
+
+CL_Vector2 CL_Vector2::operator*(float fScalar) const
+{
+    return CL_Vector2(fScalar*x,fScalar*y);
+}
+
+CL_Vector2 CL_Vector2::operator-() const
+{
+    return CL_Vector2(-x,-y);
+}
+
+/*
+CL_Vector2 Mgc::operator* (float fScalar, const CL_Vector2&amp; rkVector)
+{
+    return CL_Vector2(fScalar*rkVector.x,fScalar*rkVector.y);
+}
+*/
+CL_Vector2 CL_Vector2::operator/(float fScalar) const
+{
+    CL_Vector2 kQuot;
+
+    if ( fScalar != 0.0f )
+    {
+        float fInvScalar = 1.0f/fScalar;
+        kQuot.x = fInvScalar*x;
+        kQuot.y = fInvScalar*y;
+        return kQuot;
+    }
+    else
+    {
+        return CL_Vector2(FLT_MAX,FLT_MAX);
+    }
+}
+
+CL_Vector2&amp; CL_Vector2::operator+=(const CL_Vector2&amp; rkVector)
+{
+    x += rkVector.x;
+    y += rkVector.y;
+    return *this;
+}
+
+CL_Vector2&amp; CL_Vector2::operator-=(const CL_Vector2&amp; rkVector)
+{
+    x -= rkVector.x;
+    y -= rkVector.y;
+    return *this;
+}
+
+CL_Vector2&amp; CL_Vector2::operator*=(float fScalar)
+{
+    x *= fScalar;
+    y *= fScalar;
+    return *this;
+}
+
+CL_Vector2&amp; CL_Vector2::operator/=(float fScalar)
+{
+    if ( fScalar != 0.0f )
+    {
+        float fInvScalar = 1.0f/fScalar;
+        x *= fInvScalar;
+        y *= fInvScalar;
+    }
+    else
+    {
+        x = FLT_MAX;
+        y = FLT_MAX;
+    }
+
+    return *this;
+}
+
+float CL_Vector2::dot(const CL_Vector2&amp; rkVector) const
+{
+    return x*rkVector.x + y*rkVector.y;
+}
+
+float CL_Vector2::length() const
+{
+#ifdef __APPLE__
+    return sqrt(x*x +y*y);
+#else
+    return sqrtf(x*x +y*y);
+#endif
+}
+
+CL_Vector2 CL_Vector2::cross() const
+{
+    return CL_Vector2(y,-x);
+}
+
+CL_Vector2 CL_Vector2::unit_cross() const
+{
+    CL_Vector2 kCross(y,-x);
+    kCross.unitize();
+    return kCross;
+}
+
+float CL_Vector2::unitize(float fTolerance)
+{
+    float fLength = length();
+
+    if ( fLength &gt; fTolerance )
+    {
+        float fInvLength = 1.0f/fLength;
+        x *= fInvLength;
+        y *= fInvLength;
+    }
+    else
+    {
+        fLength = 0.0f;
+    }
+
+    return fLength;
+}
+
+/*
+void CL_Vector2::Orthonormalize (CL_Vector2 akVector[2])	// CL_Vector2 akVector[2]
+{
+    // If the input vectors are v0 and v1, then the Gram-Schmidt
+    // orthonormalization produces vectors u0 and u1 as follows,
+    //
+    //   u0 = v0/|v0|
+    //   u1 = (v1-(u0*v1)u0)/|v1-(u0*v1)u0|
+    //
+    // where |A| indicates length of vector A and A*B indicates dot
+    // product of vectors A and B.
+
+    // compute u0
+    akVector[0].Unitize();
+
+    // compute u1
+    float fDot0 = akVector[0].Dot(akVector[1]); 
+    akVector[1] -= fDot0*akVector[0];
+    akVector[1].Unitize();
+}
+*/

Added: trunk/clanlib/Core/Resources/resource.cpp
===================================================================
--- trunk/clanlib/Core/Resources/resource.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Resources/resource.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,174 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/Resources/resource.h&quot;
+#include &quot;API/Core/Resources/resourcedata.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;API/Core/System/cl_assert.h&quot;
+#include &quot;Core/Resources/resource_manager_generic.h&quot;
+#include &quot;resource_generic.h&quot;
+#include &lt;ctype.h&gt;
+#include &lt;algorithm&gt;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Resource construction:
+
+CL_Resource::CL_Resource(
+	CL_DomElement &amp;element,
+	CL_ResourceManager *manager)
+: impl(new CL_Resource_Generic(element, manager-&gt;impl))
+{
+}
+
+CL_Resource::CL_Resource(const CL_Resource &amp;copy)
+: impl(copy.impl)
+{
+}
+
+CL_Resource::CL_Resource(const CL_SharedPtr&lt;CL_Resource_Generic&gt; &amp;impl)
+: impl(impl)
+{
+}
+
+CL_Resource::CL_Resource()
+{
+}
+
+CL_Resource::~CL_Resource()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Resource attributes:
+
+std::string CL_Resource::get_type() const
+{
+	if (!impl) return 0;
+	return impl-&gt;element.get_tag_name();
+}
+
+std::string CL_Resource::get_name() const
+{
+	if (!impl) return 0;
+	return impl-&gt;element.get_attribute(&quot;name&quot;);
+}
+/*
+std::string CL_Resource::get_full_location() const
+{
+	CL_InputSourceProvider *provider = (CL_InputSourceProvider *) impl-&gt;manager-&gt;get_resource_provider();
+	return provider-&gt;get_path(get_location().c_str());
+}
+*/
+
+CL_DomElement &amp;CL_Resource::get_element()
+{
+	if (!impl)
+	{
+		static CL_DomElement null;
+		return null;
+	}
+	return impl-&gt;element;
+}
+
+CL_ResourceManager CL_Resource::get_manager()
+{
+	return CL_ResourceManager(impl-&gt;manager);
+}
+
+CL_ResourceData *CL_Resource::get_data(const std::string &amp;name)
+{
+	if (!impl) return 0;
+	return impl-&gt;datas[name];
+}
+
+int CL_Resource::get_reference_count() const
+{
+	if (!impl) return 0;
+	return impl-&gt;load_ref;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Resource operations:
+
+void CL_Resource::attach_data(const std::string &amp;name, CL_ResourceData *data)
+{
+	impl-&gt;datas[name] = data;
+}
+
+void CL_Resource::detach_data(CL_ResourceData *data)
+{
+	std::map&lt;std::string, CL_ResourceData *&gt;::iterator it;
+	for (it = impl-&gt;datas.begin(); it != impl-&gt;datas.end(); it++)
+	{
+		if (it-&gt;second == data)
+		{
+			impl-&gt;datas.erase(it);
+			break;
+		}
+	}
+}
+
+void CL_Resource::unload()
+{
+	if (!impl) return;
+	if (impl-&gt;manager == 0) return;
+
+	impl-&gt;load_ref--;
+	cl_assert(impl-&gt;load_ref &gt;= 0);
+	if (impl-&gt;load_ref == 0)
+	{
+		std::map&lt;std::string, CL_ResourceData*&gt;::iterator it;
+		for (it = impl-&gt;datas.begin(); it != impl-&gt;datas.end(); ++it)
+		{
+			CL_ResourceData *data = it-&gt;second;
+			data-&gt;on_unload();
+		}
+	}
+}
+
+void CL_Resource::load()
+{
+	if (!impl) return;
+	if (impl-&gt;manager == 0) return;
+
+	impl-&gt;load_ref++;
+	if (impl-&gt;load_ref == 1)
+	{
+		std::map&lt;std::string, CL_ResourceData*&gt;::iterator it;
+		for (it = impl-&gt;datas.begin(); it != impl-&gt;datas.end(); ++it)
+		{
+			CL_ResourceData *data = it-&gt;second;
+			data-&gt;on_load();
+		}
+	}
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Resource implementation:

Added: trunk/clanlib/Core/Resources/resource_generic.cpp
===================================================================
--- trunk/clanlib/Core/Resources/resource_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Resources/resource_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,60 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;resource_generic.h&quot;
+#include &quot;API/Core/Resources/resourcedata.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Resource_Generic construction:
+
+CL_Resource_Generic::CL_Resource_Generic(
+	CL_DomElement &amp;element,
+	const CL_WeakPtr&lt;CL_ResourceManager_Generic&gt; &amp;manager)
+: load_ref(0), manager(manager), element(element)
+{
+}
+
+CL_Resource_Generic::~CL_Resource_Generic()
+{
+	std::map&lt;std::string, CL_ResourceData*&gt;::iterator it;
+	for (it = datas.begin(); it != datas.end(); ++it)
+	{
+		delete it-&gt;second;
+	}
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Resource_Generic attributes:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Resource_Generic operations:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Resource_Generic implementation:

Added: trunk/clanlib/Core/Resources/resource_generic.h
===================================================================
--- trunk/clanlib/Core/Resources/resource_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Resources/resource_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,70 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_resource_generic
+#define header_resource_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;map&gt;
+#include &lt;string&gt;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;API/Core/System/weakptr.h&quot;
+
+class CL_ResourceData;
+class CL_ResourceManager_Generic;
+
+class CL_Resource_Generic
+{
+//! Construction:
+public:
+	CL_Resource_Generic(CL_DomElement &amp;element, const CL_WeakPtr&lt;CL_ResourceManager_Generic&gt; &amp;manager);
+
+	~CL_Resource_Generic();
+
+//! Attributes:
+public:
+	std::map&lt;std::string, CL_ResourceData*&gt; datas;
+
+	int load_ref;
+
+	CL_WeakPtr&lt;CL_ResourceManager_Generic&gt; manager;
+
+	CL_DomElement element;
+
+//! Operations:
+public:
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/Core/Resources/resource_manager.cpp
===================================================================
--- trunk/clanlib/Core/Resources/resource_manager.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Resources/resource_manager.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,164 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;resource_manager_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ResourceManager construction:
+
+CL_ResourceManager::CL_ResourceManager(
+	const std::string &amp;config_file,
+	CL_InputSourceProvider *provider,
+	bool delete_inputsource_provider)
+: impl(new CL_ResourceManager_Generic)
+{
+	impl-&gt;self = impl;
+	impl-&gt;load(config_file, provider, delete_inputsource_provider);
+}
+
+CL_ResourceManager::CL_ResourceManager(const CL_ResourceManager &amp;copy)
+: impl(copy.impl)
+{
+}
+
+CL_ResourceManager::CL_ResourceManager()
+: impl(new CL_ResourceManager_Generic)
+{
+	impl-&gt;self = impl;
+}
+
+CL_ResourceManager::~CL_ResourceManager()
+{
+}
+
+CL_ResourceManager::CL_ResourceManager(const CL_SharedPtr&lt;CL_ResourceManager_Generic&gt; &amp;impl)
+: impl(impl)
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ResourceManager attributes:
+
+bool CL_ResourceManager::exists(const std::string &amp;res_id)
+{
+	return impl-&gt;exists(res_id);
+}
+
+CL_Resource &amp;CL_ResourceManager::get_resource(const std::string &amp;res_id, bool resolve_alias, int level)
+{
+	CL_Resource &amp;res = impl-&gt;get_resource(res_id);
+	
+	if (resolve_alias &amp;&amp; res.get_type() == &quot;alias&quot; &amp;&amp; level &lt; 20)
+		return get_resource(res.get_element().get_attribute(&quot;link&quot;), true, level+1);
+	else
+		return res;
+}
+
+std::vector&lt;std::string&gt; CL_ResourceManager::get_all_resources()
+{
+	return impl-&gt;get_all_resources();
+}
+
+std::vector&lt;std::string&gt; CL_ResourceManager::get_all_resources(const std::string &amp;section_name)
+{
+	return impl-&gt;get_all_resources(section_name);
+}
+
+std::vector&lt;std::string&gt; CL_ResourceManager::get_all_sections()
+{
+	return impl-&gt;get_all_sections();
+}
+
+std::vector&lt;std::string&gt; CL_ResourceManager::get_sections(const std::string &amp;section_name)
+{
+	return impl-&gt;get_sections(section_name);
+}
+
+std::vector&lt;std::string&gt; CL_ResourceManager::get_resources_of_type(const std::string &amp;type_id)
+{
+	return impl-&gt;get_resources_of_type(type_id);
+}
+
+std::vector&lt;std::string&gt; CL_ResourceManager::get_resources_of_type(const std::string &amp;type_id, const std::string &amp;section_name)
+{
+	return impl-&gt;get_resources_of_type(type_id, section_name);
+}
+
+CL_InputSourceProvider *CL_ResourceManager::get_resource_provider() const
+{
+	return impl-&gt;get_resource_provider();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ResourceManager signals:
+
+CL_Signal_v1&lt;CL_Resource &amp;&gt; &amp;CL_ResourceManager::sig_resource_added()
+{
+	return CL_ResourceManager_Generic::sig_resource_added;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ResourceManager operations:
+
+bool CL_ResourceManager::operator == (const CL_ResourceManager &amp;other) const
+{
+	return impl == other.impl;
+}
+
+void CL_ResourceManager::add_resources(const CL_ResourceManager &amp;additional_resources)
+{
+	impl-&gt;add_resources(additional_resources);
+}
+
+void CL_ResourceManager::remove_resources(const CL_ResourceManager &amp;additional_resources)
+{
+	impl-&gt;remove_resources(additional_resources);
+}
+
+void CL_ResourceManager::load_all()
+{
+	impl-&gt;load_all();
+}
+
+void CL_ResourceManager::unload_all()
+{
+	impl-&gt;unload_all();
+}
+
+void CL_ResourceManager::load_section(const std::string &amp;section_name)
+{
+	impl-&gt;load_section(section_name);
+}
+
+void CL_ResourceManager::unload_section(const std::string &amp;section_name)
+{
+	impl-&gt;unload_section(section_name);
+}

Added: trunk/clanlib/Core/Resources/resource_manager_generic.cpp
===================================================================
--- trunk/clanlib/Core/Resources/resource_manager_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Resources/resource_manager_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,473 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &lt;iterator&gt;
+#include &quot;Core/precomp.h&quot;
+#include &quot;resource_manager_generic.h&quot;
+#include &quot;resource_generic.h&quot;
+#include &quot;API/Core/IOData/inputsource_provider_file.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/Core/IOData/zip_archive.h&quot;
+#include &quot;API/Core/XML/dom_node_list.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ResourceManager_Generic Construction:
+
+CL_ResourceManager_Generic::CL_ResourceManager_Generic() : provider(0), delete_provider(false)
+{
+}
+
+CL_ResourceManager_Generic::~CL_ResourceManager_Generic()
+{
+	if (delete_provider) delete provider;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ResourceManager_Generic Attributes:
+
+bool CL_ResourceManager_Generic::exists(const std::string &amp;res_id)
+{
+	if (resources.find(res_id) != resources.end()) return true;
+
+	// Search in all additional resources:
+	std::list&lt;CL_ResourceManager&gt;::iterator it;
+	for (it = additional_resources.begin(); it != additional_resources.end(); ++it)
+	{
+		if (it-&gt;exists(res_id)) return true;
+	}
+
+	return false;
+}
+
+CL_Resource &amp;CL_ResourceManager_Generic::get_resource(const std::string &amp;res_id)
+{
+	std::map&lt;std::string, CL_Resource&gt;::iterator it = resources.find(res_id);
+	if (it == resources.end())
+	{
+		std::list&lt;CL_ResourceManager&gt;::iterator it2;
+		for (it2 = additional_resources.begin(); it2 != additional_resources.end(); ++it2)
+		{
+			CL_ResourceManager &amp;additional_manager = *it2;
+			if (additional_manager.exists(res_id))
+			{
+				return additional_manager.get_resource(res_id, false);
+			}
+		}
+
+		throw CL_Error(CL_String::format(&quot;Resource '%1' not found&quot;, res_id));
+	}
+	return it-&gt;second;
+}
+
+std::vector&lt;std::string&gt; CL_ResourceManager_Generic::get_all_resources(const std::string &amp;original_section_name)
+{
+	std::vector&lt;std::string&gt; result;
+
+	// Make sure we have a trailing / in section
+	std::string section_name = add_trailing_slash(original_section_name);
+
+	// Add local resources:
+	{
+		std::map&lt;std::string, CL_Resource&gt;::iterator it;
+		for (it = resources.begin(); it != resources.end(); ++it)
+		{
+			if (it-&gt;first.substr(0, section_name.length()) == section_name)
+			{
+				result.push_back(it-&gt;first);
+			}
+		}
+	}
+
+	// Add resources for all additional resources:
+	{
+		std::list&lt;CL_ResourceManager&gt;::iterator it;
+		for (it = additional_resources.begin(); it != additional_resources.end(); ++it)
+		{
+			std::vector&lt;std::string&gt; additionals = it-&gt;get_all_resources(section_name);
+			std::copy(additionals.begin(), additionals.end(), std::back_inserter(result));
+		}
+	}
+
+	return result;
+}
+
+std::vector&lt;std::string&gt; CL_ResourceManager_Generic::get_all_resources()
+{
+	std::vector&lt;std::string&gt; result;
+
+	// Add local resources:
+	{
+		std::map&lt;std::string, CL_Resource&gt;::iterator it;
+		for (it = resources.begin(); it != resources.end(); ++it)
+		{
+			result.push_back(it-&gt;first);
+		}
+	}
+
+	// Add resources for all additional resources:
+	{
+		std::list&lt;CL_ResourceManager&gt;::iterator it;
+		for (it = additional_resources.begin(); it != additional_resources.end(); ++it)
+		{
+			std::vector&lt;std::string&gt; additionals = it-&gt;get_all_resources();
+			std::copy(additionals.begin(), additionals.end(), std::back_inserter(result));
+		}
+	}
+
+	return result;
+}
+
+std::vector&lt;std::string&gt; CL_ResourceManager_Generic::get_all_sections()
+{
+	std::vector&lt;std::string&gt; result;
+
+	// Add local sections:
+	{
+		CL_DomElement element = document.named_item(&quot;resources&quot;).to_element();
+		add_sections(result, element);
+	}
+
+	// Add sections for all additional resources:
+	{
+		std::list&lt;CL_ResourceManager&gt;::iterator it;
+		for (it = additional_resources.begin(); it != additional_resources.end(); ++it)
+		{
+			std::vector&lt;std::string&gt; additionals = it-&gt;get_all_sections();
+			std::copy(additionals.begin(), additionals.end(), std::back_inserter(result));
+		}
+	}
+
+	return result;
+}
+
+std::vector&lt;std::string&gt; CL_ResourceManager_Generic::get_sections(const std::string &amp;section_name)
+{
+	std::vector&lt;std::string&gt; result;
+
+	// Add local sections:
+	{
+		CL_DomElement element = document.named_item(&quot;resources&quot;).to_element();
+		add_section(result, element, section_name);
+	}
+
+	// Add sections for all additional resources:
+	{
+		std::list&lt;CL_ResourceManager&gt;::iterator it;
+		for (it = additional_resources.begin(); it != additional_resources.end(); ++it)
+		{
+			std::vector&lt;std::string&gt; additionals = it-&gt;get_sections(section_name);
+			std::copy(additionals.begin(), additionals.end(), std::back_inserter(result));
+		}
+	}
+
+	return result;
+}
+
+std::vector&lt;std::string&gt; CL_ResourceManager_Generic::get_resources_of_type(const std::string &amp;type_id)
+{
+	std::vector&lt;std::string&gt; result;
+
+	// Add local resources:
+	{
+		std::map&lt;std::string, CL_Resource&gt;::iterator it;
+		for (it = resources.begin(); it != resources.end(); ++it)
+		{
+			if (it-&gt;second.get_type() == type_id) result.push_back(it-&gt;first);
+		}
+	}
+
+	// Add resources for all additional resources:
+	{
+		std::list&lt;CL_ResourceManager&gt;::iterator it;
+		for (it = additional_resources.begin(); it != additional_resources.end(); ++it)
+		{
+			std::vector&lt;std::string&gt; additionals = it-&gt;get_resources_of_type(type_id);
+                        std::copy(additionals.begin(), additionals.end(), std::back_inserter(result));
+		}
+	}
+
+	return result;
+}
+
+std::vector&lt;std::string&gt; CL_ResourceManager_Generic::get_resources_of_type(const std::string &amp;type_id, const std::string &amp;original_section_name)
+{
+	std::vector&lt;std::string&gt; result;
+
+	// Make sure we have a trailing / in section
+	std::string section_name = add_trailing_slash(original_section_name);
+
+	// Add local resources:
+	{
+		std::map&lt;std::string, CL_Resource&gt;::iterator it;
+		for (it = resources.begin(); it != resources.end(); ++it)
+		{
+			if (it-&gt;first.substr(0, section_name.length()) == section_name)
+			{
+				if (it-&gt;second.get_type() == type_id) result.push_back(it-&gt;first);
+			}
+		}
+	}
+
+	// Add resources for all additional resources:
+	{
+		std::list&lt;CL_ResourceManager&gt;::iterator it;
+		for (it = additional_resources.begin(); it != additional_resources.end(); ++it)
+		{
+			std::vector&lt;std::string&gt; additionals = it-&gt;get_resources_of_type(type_id, section_name);
+                        std::copy(additionals.begin(), additionals.end(), std::back_inserter(result));
+		}
+	}
+
+	return result;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ResourceManager_Generic Signals:
+
+CL_Signal_v1&lt;CL_Resource &amp;&gt; CL_ResourceManager_Generic::sig_resource_added;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ResourceManager_Generic Operations:
+
+void CL_ResourceManager_Generic::load(
+	const std::string &amp;config_file,
+	CL_InputSourceProvider *input_provider,
+	bool delete_inputsource_provider)
+{
+	if (delete_provider)
+		delete provider;
+
+	provider = input_provider;
+	delete_provider = delete_inputsource_provider;
+
+	if (provider == 0)
+	{
+		provider = new CL_InputSourceProvider_File(CL_String::get_path(config_file));
+		delete_provider = true;
+	}
+	else
+	{
+		CL_InputSourceProvider *new_provider = provider-&gt;create_relative(CL_String::get_path(config_file));
+		if (delete_provider) delete provider;
+		provider = new_provider;
+		delete_provider = true;
+	}
+
+	try
+	{
+		document.load(provider-&gt;open_source(CL_String::get_filename(config_file)), true);
+	}
+	catch( CL_Error err )
+	{
+		// a hack to report the filename of the malformed xml file
+		err.message.insert(0, config_file + &quot;: &quot; );
+		throw err;
+	}
+
+	CL_DomElement root = document.named_item(&quot;resources&quot;).to_element();
+	if (root.is_null()) throw CL_Error(config_file + &quot;: Not a valid XML resource file.&quot;);
+	parse_section(root);
+
+	std::map&lt;std::string, CL_Resource&gt;::iterator it;
+	for (it = resources.begin(); it != resources.end(); ++it)
+	{
+		sig_resource_added(it-&gt;second);
+	}
+}
+
+void CL_ResourceManager_Generic::add_resources(const CL_ResourceManager &amp;resources)
+{
+	additional_resources.push_back(resources);
+}
+
+void CL_ResourceManager_Generic::remove_resources(const CL_ResourceManager &amp;resources)
+{
+	additional_resources.remove(resources);
+}
+
+void CL_ResourceManager_Generic::load_all()
+{
+	load_section(std::string());
+}
+
+void CL_ResourceManager_Generic::unload_all()
+{
+	unload_section(std::string());
+}
+
+void CL_ResourceManager_Generic::load_section(const std::string &amp;original_section_name)
+{
+	// Make sure we have a trailing / in section
+	std::string section_name = add_trailing_slash(original_section_name);
+
+	// Load local resources:
+	{
+		std::map&lt;std::string, CL_Resource&gt;::iterator it;
+		for (it = resources.begin(); it != resources.end(); ++it)
+		{
+			if (it-&gt;first.substr(0, section_name.length()) == section_name)
+			{
+				it-&gt;second.load();
+			}
+		}
+	}
+
+	// Load additional resources:
+	{
+		std::list&lt;CL_ResourceManager&gt;::iterator it;
+		for (it = additional_resources.begin(); it != additional_resources.end(); ++it)
+		{
+			CL_ResourceManager &amp;additional_manager = *it;
+			additional_manager.load_section(section_name);
+		}
+	}
+}
+
+void CL_ResourceManager_Generic::unload_section(const std::string &amp;original_section_name)
+{
+	// Make sure we have a trailing / in section
+	std::string section_name = add_trailing_slash(original_section_name);
+
+	// Load local resources:
+	{
+		std::map&lt;std::string, CL_Resource&gt;::iterator it;
+		for (it = resources.begin(); it != resources.end(); ++it)
+		{
+			if (it-&gt;first.substr(0, section_name.length()) == section_name)
+			{
+				it-&gt;second.unload();
+			}
+		}
+	}
+
+	// Load additional resources:
+	{
+		std::list&lt;CL_ResourceManager&gt;::iterator it;
+		for (it = additional_resources.begin(); it != additional_resources.end(); ++it)
+		{
+			CL_ResourceManager &amp;additional_manager = *it;
+			additional_manager.unload_section(section_name);
+		}
+	}
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ResourceManager_Generic Implementation:
+
+void CL_ResourceManager_Generic::parse_section(CL_DomElement &amp;sectionElement, const std::string &amp;prefix)
+{
+	std::string path = prefix + sectionElement.get_attribute(&quot;name&quot;) + &quot;/&quot;;
+	if (sectionElement.get_tag_name() == &quot;resources&quot;) path = prefix;
+
+	for (CL_DomNode node = sectionElement.get_first_child(); !node.is_null(); node = node.get_next_sibling())
+	{
+		if (!node.is_element()) continue;
+
+		CL_DomElement element = node.to_element();
+		if (element.get_tag_name() == &quot;section&quot;)
+		{
+			parse_section(element, path);
+		}
+		else if(element.get_tag_name() == &quot;include&quot;)
+		{
+			// get the file name and provider name
+			std::string file_name = element.get_attribute(&quot;file&quot;);
+			std::string zip_name = element.get_attribute(&quot;provider&quot;);
+			bool local = element.get_attribute(&quot;local&quot;,&quot;false&quot;) == &quot;true&quot;;
+
+			CL_ResourceManager *additional_resource;
+			if(local)
+			{
+				file_name = provider-&gt;get_pathname(file_name);
+				additional_resource = new CL_ResourceManager(file_name, provider);
+			}
+			else if(zip_name != &quot;&quot;)
+			{
+				CL_Zip_Archive *arch = new CL_Zip_Archive(zip_name);
+				file_name = arch-&gt;get_pathname(file_name);
+				additional_resource = new CL_ResourceManager(file_name, arch);
+			}
+			else
+			{
+				file_name = provider-&gt;get_pathname(file_name);
+				additional_resource = new CL_ResourceManager(file_name);
+			}
+
+			add_resources(*additional_resource);
+		}
+		else
+		{
+			CL_Resource resource(CL_SharedPtr&lt;CL_Resource_Generic&gt;(new CL_Resource_Generic(element, self)));
+			resources[path + element.get_attribute(&quot;name&quot;)] = resource;
+		}
+	}
+}
+
+void CL_ResourceManager_Generic::add_sections(std::vector&lt;std::string&gt; &amp;returnList, CL_DomElement &amp;sectionElement, const std::string &amp;prefix)
+{
+	std::string path = prefix + sectionElement.get_attribute(&quot;name&quot;) + &quot;/&quot;;
+	if (sectionElement.get_tag_name() == &quot;resources&quot;) path = prefix;
+
+	for (CL_DomNode node = sectionElement.get_first_child(); !node.is_null(); node = node.get_next_sibling())
+	{
+		if (!node.is_element()) continue;
+
+		CL_DomElement element = node.to_element();
+		if (element.get_tag_name() == &quot;section&quot;)
+		{
+			returnList.push_back(path + element.get_attribute(&quot;name&quot;));
+			add_sections(returnList, element, path);
+		}
+	}
+}
+
+void CL_ResourceManager_Generic::add_section(std::vector&lt;std::string&gt; &amp;returnList, CL_DomElement &amp;sectionElement, const std::string &amp;section_name)
+{
+	for (CL_DomNode node = sectionElement.get_first_child(); !node.is_null(); node = node.get_next_sibling())
+	{
+		if (!node.is_element()) continue;
+
+		CL_DomElement element = node.to_element();
+		if (element.get_tag_name() == &quot;section&quot;)
+		{
+			if (sectionElement.get_attribute(&quot;name&quot;) == section_name)
+				returnList.push_back(element.get_attribute(&quot;name&quot;));
+			add_section(returnList, element, section_name);
+		}
+	}
+}
+
+std::string CL_ResourceManager_Generic::add_trailing_slash(const std::string &amp;string)
+{
+	if(string.length() &amp;&amp; string.at(string.length() - 1) != '/')
+		return string + '/';
+	else
+		return string;
+}

Added: trunk/clanlib/Core/Resources/resource_manager_generic.h
===================================================================
--- trunk/clanlib/Core/Resources/resource_manager_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Resources/resource_manager_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,122 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_resource_manager_generic
+#define header_resource_manager_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/Resources/resource.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;API/Core/XML/dom_document.h&quot;
+#include &quot;API/Core/System/weakptr.h&quot;
+#include &lt;string&gt;
+#include &lt;list&gt;
+#include &lt;map&gt;
+
+class CL_InputSourceProvider;
+class CL_DomElement;
+
+class CL_ResourceManager_Generic
+{
+//! Construction:
+public:
+	CL_ResourceManager_Generic();
+
+	~CL_ResourceManager_Generic();
+
+//! Attributes:
+public:
+	bool exists(const std::string &amp;res_id);
+	
+	CL_Resource &amp;get_resource(const std::string &amp;res_id);
+
+	std::vector&lt;std::string&gt; get_all_resources();
+
+	std::vector&lt;std::string&gt; get_all_resources(const std::string &amp;section_name);
+
+	std::vector&lt;std::string&gt; get_all_sections();
+
+	std::vector&lt;std::string&gt; get_sections(const std::string &amp;section_name);
+
+	std::vector&lt;std::string&gt; get_resources_of_type(const std::string &amp;type_id);
+
+	std::vector&lt;std::string&gt; get_resources_of_type(const std::string &amp;type_id, const std::string &amp;section_name);
+
+	CL_InputSourceProvider *get_resource_provider() const { return provider; }
+
+	CL_WeakPtr&lt;CL_ResourceManager_Generic&gt; self;
+
+//! Signals:
+public:
+	static CL_Signal_v1&lt;CL_Resource &amp;&gt; sig_resource_added;
+
+//! Operations:
+public:
+	void load(
+		const std::string &amp;config_file,
+		CL_InputSourceProvider *provider,
+		bool delete_inputsource_provider);
+
+	void add_resources(const CL_ResourceManager &amp;additional_resources);
+
+	void remove_resources(const CL_ResourceManager &amp;additional_resources);
+
+	void load_all();
+
+	void unload_all();
+
+	void load_section(const std::string &amp;section_name);
+
+	void unload_section(const std::string &amp;section_name);
+
+	void parse_section(CL_DomElement &amp;sectionElement, const std::string &amp;prefix = std::string());
+
+	void add_sections(std::vector&lt;std::string&gt; &amp;returnList, CL_DomElement &amp;sectionElement, const std::string &amp;prefix = std::string());
+
+//! Implementation:
+private:
+	std::string add_trailing_slash(const std::string &amp;string);
+
+	void add_section(std::vector&lt;std::string&gt; &amp;returnList, CL_DomElement &amp;sectionElement, const std::string &amp;section_name);
+
+	CL_DomDocument document;
+	
+	std::map&lt;std::string, CL_Resource&gt; resources;
+	
+	std::list&lt;CL_ResourceManager&gt; additional_resources;
+
+	CL_InputSourceProvider *provider;
+
+	bool delete_provider;
+};
+
+#endif

Added: trunk/clanlib/Core/Resources/resourcedata.cpp
===================================================================
--- trunk/clanlib/Core/Resources/resourcedata.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Resources/resourcedata.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,66 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/Resources/resourcedata.h&quot;
+#include &quot;API/Core/System/weakptr.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData_Generic:
+
+class CL_ResourceData_Generic
+{
+public:
+	CL_WeakPtr&lt;CL_Resource_Generic&gt; resource;
+};
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData construction:
+
+CL_ResourceData::CL_ResourceData(CL_Resource &amp;resource)
+: impl(new CL_ResourceData_Generic)
+{
+	impl-&gt;resource = resource.impl;
+}
+
+CL_ResourceData::~CL_ResourceData()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData attributes:
+
+CL_Resource CL_ResourceData::get_resource()
+{
+	return CL_Resource(impl-&gt;resource);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData implementation:

Added: trunk/clanlib/Core/Resources/resourcetype_boolean.cpp
===================================================================
--- trunk/clanlib/Core/Resources/resourcetype_boolean.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Resources/resourcetype_boolean.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,56 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/Resources/resourcetype_boolean.h&quot;
+#include &quot;API/Core/Resources/resource.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData_Boolean construction:
+
+CL_ResourceData_Boolean::CL_ResourceData_Boolean(CL_Resource &amp;resource)
+: CL_ResourceData(resource)
+{
+	std::string location = resource.get_element().get_attribute(&quot;value&quot;);
+
+	if (location == &quot;true&quot; || location == &quot;1&quot;)
+	{
+		value = true;
+	}
+	else if (location == &quot;false&quot; || location == &quot;0&quot;)
+	{
+		value = false;
+	}
+	else
+	{
+		throw CL_Error(std::string(&quot;Boolean resource has invalid value: &quot;) + location);
+	}
+
+	resource.attach_data(&quot;boolean&quot;, this);
+}

Added: trunk/clanlib/Core/Resources/resourcetype_float.cpp
===================================================================
--- trunk/clanlib/Core/Resources/resourcetype_float.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Resources/resourcetype_float.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,44 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/Resources/resourcetype_float.h&quot;
+#include &quot;API/Core/Resources/resource.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData_Float construction:
+
+CL_ResourceData_Float::CL_ResourceData_Float(CL_Resource &amp;resource)
+: CL_ResourceData(resource)
+{
+	value = CL_String::to_float(resource.get_element().get_attribute(&quot;value&quot;));
+
+	resource.attach_data(&quot;float&quot;, this);
+}

Added: trunk/clanlib/Core/Resources/resourcetype_integer.cpp
===================================================================
--- trunk/clanlib/Core/Resources/resourcetype_integer.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Resources/resourcetype_integer.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,44 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/Resources/resourcetype_integer.h&quot;
+#include &quot;API/Core/Resources/resource.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData_Integer construction:
+
+CL_ResourceData_Integer::CL_ResourceData_Integer(CL_Resource &amp;resource)
+: CL_ResourceData(resource)
+{
+	value = CL_String::to_int(resource.get_element().get_attribute(&quot;value&quot;));
+
+	resource.attach_data(&quot;integer&quot;, this);
+}

Added: trunk/clanlib/Core/Resources/resourcetype_raw.cpp
===================================================================
--- trunk/clanlib/Core/Resources/resourcetype_raw.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Resources/resourcetype_raw.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,76 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/Resources/resourcetype_raw.h&quot;
+#include &quot;API/Core/Resources/resource.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;API/Core/IOData/inputsource.h&quot;
+#include &quot;API/Core/IOData/inputsource_provider.h&quot;
+#include &quot;API/Core/IOData/outputsource.h&quot;
+#include &quot;API/Core/IOData/outputsource_provider.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData_Raw construction:
+
+CL_ResourceData_Raw::CL_ResourceData_Raw(CL_Resource &amp;resource)
+: CL_ResourceData(resource)
+{
+	resource.attach_data(&quot;raw&quot;, this);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData_Raw implementation:
+
+void CL_ResourceData_Raw::on_load()
+{
+	CL_ResourceManager manager = get_resource().get_manager();
+	std::string filename = get_resource().get_element().get_attribute(&quot;file&quot;);
+
+	CL_InputSource *input = manager.get_resource_provider()-&gt;open_source(filename.c_str());
+
+	try
+	{
+		int length = input-&gt;size();
+		value = std::vector&lt;unsigned char&gt;(length);
+		input-&gt;read(&amp;value.front(), length);
+	}
+	catch (...)
+	{
+		delete input;
+		throw;
+	}
+
+	delete input;
+}
+
+void CL_ResourceData_Raw::on_unload()
+{
+	value = std::vector&lt;unsigned char&gt;();
+}

Added: trunk/clanlib/Core/Resources/resourcetype_string.cpp
===================================================================
--- trunk/clanlib/Core/Resources/resourcetype_string.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/Resources/resourcetype_string.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,46 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/Resources/resourcetype_string.h&quot;
+#include &quot;API/Core/Resources/resource.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData_String construction:
+
+CL_ResourceData_String::CL_ResourceData_String(CL_Resource &amp;resource)
+: CL_ResourceData(resource)
+{
+	value = resource.get_element().get_attribute(&quot;value&quot;);
+
+	value = CL_String::convert_c_escapes(value);
+
+	resource.attach_data(&quot;string&quot;, this);
+}

Added: trunk/clanlib/Core/System/Generic/call_stack.cpp
===================================================================
--- trunk/clanlib/Core/System/Generic/call_stack.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Generic/call_stack.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,67 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/System/call_stack.h&quot;
+#include &quot;call_stack_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_CallStack Construction:
+
+CL_CallStack::CL_CallStack() : impl(new CL_CallStack_Generic)
+{
+}
+
+CL_CallStack::~CL_CallStack()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_CallStack Attributes:
+
+int CL_CallStack::get_num_frames() const
+{
+	return impl-&gt;frames.size();
+}
+
+const std::string &amp;CL_CallStack::get_call_frame(int frame) const
+{
+	return impl-&gt;frames[frame];
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_CallStack Operations:
+
+void CL_CallStack::add_call_frame(const std::string &amp;str_frame)
+{
+	impl-&gt;frames.push_back(str_frame);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_CallStack Implementation:

Added: trunk/clanlib/Core/System/Generic/call_stack_generic.h
===================================================================
--- trunk/clanlib/Core/System/Generic/call_stack_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Generic/call_stack_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,44 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_call_stack_generic
+#define header_call_stack_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+class CL_CallStack_Generic
+{
+//! Attributes:
+public:
+	std::vector&lt;std::string&gt; frames;
+};
+
+#endif

Added: trunk/clanlib/Core/System/Generic/cl_assert.cpp
===================================================================
--- trunk/clanlib/Core/System/Generic/cl_assert.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Generic/cl_assert.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,57 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+
+#include &lt;cstdlib&gt;
+#include &lt;iostream&gt;
+#include &lt;cassert&gt;
+
+#include &quot;API/Core/System/cl_assert.h&quot;
+
+void CL_Assert::die(bool a, const char *file, int line, const char *function, const char *assert_str)
+{
+	if (a) return;
+
+	if (function == NULL)
+	{
+		std::cout &lt;&lt; std::endl;
+		std::cout &lt;&lt; &quot;ClanLib Assert: &quot; &lt;&lt; file &lt;&lt; &quot;:&quot; &lt;&lt; line &lt;&lt; std::endl;
+		std::cout &lt;&lt; &quot;                '&quot; &lt;&lt; assert_str &lt;&lt; &quot;' failed.&quot; &lt;&lt; std::endl &lt;&lt; std::endl;
+	}
+	else
+	{
+		std::cout &lt;&lt; std::endl;
+		std::cout &lt;&lt; &quot;ClanLib Assert: &quot; &lt;&lt; file &lt;&lt; &quot;:&quot; &lt;&lt; line &lt;&lt; &quot;,&quot; &lt;&lt; std::endl;
+		std::cout &lt;&lt; &quot;                in function &quot; &lt;&lt; function &lt;&lt; std::endl;
+		std::cout &lt;&lt; &quot;                '&quot; &lt;&lt; assert_str &lt;&lt; &quot;' failed.&quot; &lt;&lt; std::endl &lt;&lt; std::endl;
+	}
+
+	abort();
+}

Added: trunk/clanlib/Core/System/Generic/clanstring.cpp
===================================================================
--- trunk/clanlib/Core/System/Generic/clanstring.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Generic/clanstring.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,378 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/Core/Resources/resourcetype_string.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;API/Display/color.h&quot;
+
+#include &lt;ctype.h&gt;                                                          
+#include &lt;stdio.h&gt;
+
+#ifdef WIN32
+#define snprintf _snprintf
+#define CLANSTRING_PATH_DIVIDER &quot;/\\&quot;
+#else
+#define CLANSTRING_PATH_DIVIDER '/'
+#endif
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_String operations:
+
+std::string CL_String::load(const std::string &amp;res_id, CL_ResourceManager *resources)
+{
+	CL_Resource &amp;res = resources-&gt;get_resource(res_id);
+	res.load();
+	CL_ResourceData_String *data = (CL_ResourceData_String *) res.get_data(&quot;string&quot;);
+	res.unload();
+	return data-&gt;value;
+}
+
+std::string CL_String::load(const std::string &amp;res_id, CL_ResourceManager *resources, const std::string &amp;def_value)
+{
+	try
+	{
+		CL_Resource &amp;res = resources-&gt;get_resource(res_id);
+		res.load();
+		CL_ResourceData_String *data = (CL_ResourceData_String *) res.get_data(&quot;string&quot;);
+		res.unload();
+		return data-&gt;value;
+	}
+	catch (CL_Error err)
+	{
+		return def_value;
+	}
+}
+
+std::string CL_String::left(std::string string, int n)
+{
+	return string.substr(0, n);
+}
+
+std::string CL_String::right(std::string string, int n)
+{
+	return string.substr(string.length() - n, string.length());
+}
+
+void CL_String::arg(std::string &amp;format, const std::string &amp;arg, int num)
+{
+	//Covert num into a string
+	char number[10];
+	std::string num_string = &quot;%&quot;;
+	
+	memset(number, 10, 0);
+	snprintf(number, 10, &quot;%d&quot;, num);
+	
+	num_string += number;
+	
+	std::string::size_type offset = format.find(num_string);
+	
+	if(offset == std::string::npos)
+	{
+		//Ah shit!  The value doesn't exist!
+		throw CL_Error(&quot;Unable to find value in controlled string: &quot; + format);
+	}
+	
+	format.replace(format.begin() + offset, format.begin() + offset + num_string.length(), arg);
+}
+
+void CL_String::arg(std::string &amp;format, const char *arg, int num)
+{
+	CL_String::arg(format, std::string(arg), num);
+}
+
+void CL_String::arg(std::string &amp;format, int number, int num)
+{
+	char arg[10];
+	
+	memset(arg, 10, 0);
+	snprintf(arg, 10, &quot;%d&quot;, number);
+	
+	CL_String::arg(format, arg, num);
+}
+
+void CL_String::arg(std::string &amp;format, float number, int num)
+{
+	char arg[32];
+
+	memset(arg, 32, 0);
+	snprintf(arg, 32, &quot;%f&quot;, number);
+	
+	CL_String::arg(format, arg, num);
+}
+
+void CL_String::arg(std::string &amp;format, double number, int num)
+{
+	char arg[32];
+	
+	memset(arg, 32, 0);
+	snprintf(arg, 32, &quot;%#f&quot;, number);
+	
+	CL_String::arg(format, arg, num);
+}
+
+std::string CL_String::from_int(int value)
+{
+	char str[32];
+	memset(str, 32, 0);
+	snprintf(str, 32, &quot;%d&quot;, value);
+	return std::string(str);
+}
+
+std::string CL_String::from_float(float value)
+{
+	char str[32];
+	memset(str, 32, 0);
+	snprintf(str, 32, &quot;%f&quot;, value);
+	return std::string(str);
+}
+
+std::string CL_String::from_double(double value)
+{
+	char str[32];
+	memset(str, 32, 0);
+	snprintf(str, 32, &quot;%#f&quot;, value);
+	return std::string(str);
+}
+
+std::string CL_String::from_bool(bool value)
+{
+	if (value) return &quot;true&quot;;
+	return &quot;false&quot;;
+}
+
+	//- &lt;p&gt;Accepted values: &quot;0&quot;, &quot;1&quot;, &quot;yes&quot;, &quot;no&quot;, &quot;true&quot;, &quot;false&quot;. The function is not case sensitive.&lt;/p&gt;
+bool CL_String::to_bool(const std::string &amp;value)
+{
+	std::string str = CL_String::to_lower(value);
+	if (str == &quot;1&quot;) return true;
+	if (str == &quot;0&quot;) return false;
+	if (str == &quot;yes&quot;) return true;
+	if (str == &quot;no&quot;) return false;
+	if (str == &quot;true&quot;) return true;
+	if (str == &quot;false&quot;) return false;
+	return false;
+}
+
+int CL_String::to_int(const std::string &amp;str)
+{
+	return atoi(str.c_str());
+}
+
+float CL_String::to_float(const std::string &amp;str) 
+{
+	return (float) atof(str.c_str());
+}
+
+double CL_String::to_double(const std::string &amp;str) 
+{
+	return atof(str.c_str());
+}
+
+std::string CL_String::to_lower(const std::string &amp;str) 
+{
+	std::string lower_impl = str;
+
+	for( std::string::iterator i = lower_impl.begin();
+		i != lower_impl.end();
+		++i )
+	{
+		*i = tolower(*i);
+	}
+
+	return lower_impl;
+}
+
+std::string CL_String::to_upper(const std::string &amp;str) 
+{
+	std::string upper_impl = str;
+
+	for( std::string::iterator i = upper_impl.begin();
+		i != upper_impl.end();
+		++i )
+	{
+		*i = toupper(*i);
+	}
+
+	return upper_impl;
+}
+
+std::vector&lt;std::string&gt; CL_String::tokenize(const std::string &amp;str, const std::string &amp;delimit, bool skip_empty)
+{
+	std::vector&lt;std::string&gt; ret;
+	std::string::size_type last_pos = 0;
+	std::string::size_type pos = std::string::npos;
+	if (skip_empty)
+	{
+		last_pos = str.find_first_not_of(delimit, 0);	
+		if (std::string::npos != last_pos)
+			pos = str.find_first_of(delimit, last_pos);
+		while (std::string::npos != pos || std::string::npos != last_pos)
+		{
+			ret.push_back(str.substr(last_pos, pos - last_pos));
+			last_pos = str.find_first_not_of(delimit, pos);
+			pos = str.find_first_of(delimit, last_pos);
+		}
+	}
+	else
+	{
+		pos = str.find_first_of(delimit, last_pos);
+		while (std::string::npos != pos)
+		{
+			ret.push_back(str.substr(last_pos, pos - last_pos));
+			last_pos = pos + 1;
+			pos = str.find_first_of(delimit, last_pos);
+		}
+		ret.push_back(str.substr(last_pos));
+	}
+	return ret;
+}
+
+bool CL_String::compare_nocase(const std::string &amp;a, const std::string &amp;b)
+{
+	std::string::const_iterator i = a.begin();
+	std::string::const_iterator j = b.begin();
+	std::string::const_iterator i_end = a.end();
+	std::string::const_iterator j_end = b.end();
+
+	for(; (i != i_end) &amp;&amp; (j != j_end); ++i, ++j)
+	{
+		if( tolower(*i) != tolower(*j) )
+		{
+			return false;
+		}
+	}
+
+	return i == i_end &amp;&amp; j == j_end;
+}
+
+std::string CL_String::get_path(const std::string &amp;pathname)
+{
+	std::string::size_type last_slash = pathname.find_last_of(CLANSTRING_PATH_DIVIDER);
+
+	if (last_slash == std::string::npos) return std::string(&quot;.&quot;);
+	return pathname.substr(0, last_slash);
+}
+
+std::string CL_String::get_filename(const std::string &amp;pathname)
+{
+	std::string::size_type last_slash = pathname.find_last_of(CLANSTRING_PATH_DIVIDER);
+
+	if (last_slash == std::string::npos) return pathname;
+	return pathname.substr(last_slash+1);
+}
+
+std::string CL_String::get_extension(const std::string &amp;filename)
+{
+	std::string::size_type pos = filename.find_last_of('.');
+	if (pos == filename.npos) return std::string();
+	return filename.substr(pos+1);
+}
+
+std::string CL_String::trim_spaces(const std::string &amp;str)
+{
+	std::string::size_type firstchar = str.find_first_not_of(' ');
+	std::string::size_type lastchar = str.find_last_not_of(' ');
+
+	if (firstchar == std::string::npos) return std::string();
+	if (lastchar == std::string::npos) return std::string();
+
+	return str.substr(firstchar, lastchar-firstchar+1);
+}
+
+std::string CL_String::trim_whitespace(const std::string &amp;str)
+{
+	std::string::size_type length = str.length();
+	if (length == 0) return str;
+
+	std::string::size_type firstchar;
+	std::string::size_type lastchar;
+	
+	for (firstchar = 0; firstchar &lt; length; firstchar++)
+	{
+		if (
+			str[firstchar] != ' ' &amp;&amp;
+			str[firstchar] != '\t' &amp;&amp;
+			str[firstchar] != '\r' &amp;&amp;
+			str[firstchar] != '\n')
+		{
+			break;
+		}
+
+		if (firstchar == length-1) return std::string();
+	}
+
+	for (lastchar = length-1; lastchar &gt;= 0; lastchar--)
+	{
+		if (
+			str[lastchar] != ' ' &amp;&amp;
+			str[lastchar] != '\t' &amp;&amp;
+			str[lastchar] != '\r' &amp;&amp;
+			str[lastchar] != '\n')
+		{
+			break;
+		}
+
+		if (lastchar == 0) return std::string();
+	}
+
+	return str.substr(firstchar, lastchar-firstchar+1);
+}
+
+std::string CL_String::convert_c_escapes(const std::string &amp;str)
+{
+	std::string copy = str;
+
+	std::string::size_type pos = copy.find(&quot;\\n&quot;);
+	while( pos != std::string::npos )
+	{
+		copy = copy.replace( pos, 2, &quot;\n&quot; ); // replace 2 chars at pos with '\n'.
+		pos = copy.find(&quot;\\n&quot;, pos);
+	}
+
+	pos = copy.find(&quot;\\t&quot;);
+	while( pos != std::string::npos )
+	{
+		copy = copy.replace( pos, 2, &quot;\t&quot; );
+		pos = copy.find(&quot;\\t&quot;, pos);
+	}
+
+	pos = copy.find(&quot;\\\\&quot;);
+	while( pos != std::string::npos )
+	{
+		copy = copy.replace( pos, 2, &quot;\\&quot; );
+		pos = copy.find(&quot;\\&quot;, pos);
+	}
+
+	return copy;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_String implementation:

Added: trunk/clanlib/Core/System/Generic/command_line.cpp
===================================================================
--- trunk/clanlib/Core/System/Generic/command_line.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Generic/command_line.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,97 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/System/command_line.h&quot;
+#include &quot;command_line_generic.h&quot;
+
+CL_CommandLine::CL_CommandLine()
+{
+	impl = new CL_CommandLine_Generic();
+}
+
+CL_CommandLine::~CL_CommandLine()
+{
+	delete impl;
+}
+
+void CL_CommandLine::parse_args(int argc, char** argv)
+{
+	impl-&gt;parse_args(argc, argv);
+}
+
+void CL_CommandLine::print_help()
+{
+	impl-&gt;print_help();
+}
+
+void CL_CommandLine::set_help_indent(int i)
+{
+	impl-&gt;set_help_indent(i);
+}
+
+void CL_CommandLine::add_usage(const std::string&amp; usage)
+{
+	impl-&gt;add_usage(usage);
+}
+
+void CL_CommandLine::add_doc(const std::string&amp; doc)
+{
+	impl-&gt;add_doc(doc);
+}
+
+void CL_CommandLine::add_group(const std::string&amp; grouptopic)
+{
+	impl-&gt;add_group(grouptopic);
+}
+
+void CL_CommandLine::add_option(
+	int key, 
+	const std::string&amp; long_option, 
+	const std::string&amp; argument,
+	const std::string&amp; help,
+	bool visible)
+{
+	impl-&gt;add_option(key, long_option, argument, help, visible);
+}
+
+bool CL_CommandLine::next()
+{
+	return impl-&gt;next();
+}
+
+int CL_CommandLine::get_key()
+{
+	return impl-&gt;get_key();
+}
+
+std::string CL_CommandLine::get_argument()
+{
+	return impl-&gt;get_argument();
+}

Added: trunk/clanlib/Core/System/Generic/command_line_generic.cpp
===================================================================
--- trunk/clanlib/Core/System/Generic/command_line_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Generic/command_line_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,339 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+
+#include &lt;iomanip&gt;
+#include &lt;iostream&gt;
+#include &lt;stdio.h&gt;
+
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;command_line_generic.h&quot;
+
+
+#ifdef WIN32
+#define snprintf _snprintf
+#endif
+
+CL_CommandLine_Generic::CL_CommandLine_Generic()
+{
+	help_indent = 18;
+}
+
+void CL_CommandLine_Generic::parse_args(int argc, char** argv)
+{
+	programm = argv[0];
+
+	for(int i = 1; i &lt; argc; ++i) 
+	{
+		if (argv[i][0] == '-') 
+		{
+			if (argv[i][1] == '-') 
+			{
+				// We got a long option
+				if (argv[i][2] == '\0') { 
+					// Got a '--', so we stop evaluating arguments
+					++i;
+					while(i &lt; argc) 
+					{
+						read_option(CL_CommandLine::REST_ARG, argv[i]);
+						++i;
+					}
+				} 
+				else
+				{
+					std::string opt = argv[i] + 2;
+					std::string long_opt;
+					std::string long_opt_arg;
+
+					std::string::size_type pos = opt.find('=');
+
+					if (pos != std::string::npos) 
+					{
+						long_opt = opt.substr(0, pos);
+						long_opt_arg = opt.substr(pos+1);
+					}
+					else 
+					{
+						long_opt = opt;
+					}
+
+					// Long Option
+					Option* option = lookup_long_option(long_opt);
+
+					if (option) 
+					{
+						if (option-&gt;argument.empty()) 
+						{
+							read_option(option-&gt;key, &quot;&quot;);
+						} 
+						else
+						{
+							if (pos != std::string::npos) 
+							{
+								read_option(option-&gt;key, long_opt_arg);
+							}
+							else
+							{            
+								if (i == argc - 1) 
+								{
+									throw CL_Error(&quot;option '&quot; + std::string(argv[i]) + &quot;' requires an argument&quot;);
+								}
+								else 
+								{
+									read_option(option-&gt;key, argv[i + 1]);
+									++i;
+								}
+							}
+						}
+					}
+					else
+					{
+						throw CL_Error(&quot;unrecognized option '&quot; + std::string(argv[i]) + &quot;'&quot;);
+					}
+				}
+			} 
+			else 
+			{
+				// We got a short option
+				char* p = argv[i] + 1;
+          
+				if (*p != '\0') {
+					// Handle option chains
+					while (*p) 
+					{
+						// Short option(s)
+						Option* option = lookup_short_option(*p);
+
+						if (option) 
+						{
+							if (option-&gt;argument.empty()) 
+							{
+								read_option(option-&gt;key, &quot;&quot;);
+							} 
+							else 
+							{
+								if (i == argc - 1 || *(p+1) != '\0') 
+								{
+									// No more arguments
+									throw CL_Error(&quot;option requires an argument -- &quot; + std::string(1, *p));
+								}
+								else
+								{
+									read_option(option-&gt;key, argv[i + 1]);
+									++i;
+								}
+							}
+						} 
+						else 
+						{
+							throw CL_Error(&quot;invalid option -- &quot; + std::string(1, *p));
+						}
+						++p; 
+					}
+				} 
+				else
+				{
+					read_option(CL_CommandLine::REST_ARG, &quot;-&quot;);
+				} 
+			}
+		} 
+		else
+		{
+			read_option(CL_CommandLine::REST_ARG, argv[i]);
+		}
+	}
+
+	current_option = parsed_options.end();
+}
+
+CL_CommandLine_Generic::Option *CL_CommandLine_Generic::lookup_short_option(char short_option)
+{
+	for(Options::iterator i = options.begin(); i != options.end(); ++i)
+	{
+		if (i-&gt;key == short_option)
+			return &amp;(*i);
+	}
+	return 0;
+}
+
+CL_CommandLine_Generic::Option *CL_CommandLine_Generic::lookup_long_option(const std::string&amp; long_option)
+{
+	for(Options::iterator i = options.begin(); i != options.end(); ++i)
+	{
+		if (i-&gt;long_option == long_option)
+			return &amp;*i;
+	}
+	return 0;
+}
+
+void CL_CommandLine_Generic::read_option(int key, const std::string&amp; argument)
+{
+	ParsedOption parsed_option;
+  
+	parsed_option.key = key;
+	parsed_option.argument = argument;
+
+	parsed_options.push_back(parsed_option);
+}
+
+void CL_CommandLine_Generic::print_help()
+{
+	bool first_usage = true;
+	for(Options::iterator i = options.begin(); i != options.end(); ++i)
+	{
+		if (i-&gt;visible)
+		{
+			if (i-&gt;key == USAGE) 
+			{
+				if (first_usage) 
+				{
+					std::cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; programm &lt;&lt; &quot; &quot; &lt;&lt;  i-&gt;help &lt;&lt; std::endl; 
+					first_usage = false;
+				}
+				else
+				{
+					std::cout &lt;&lt; &quot;or:    &quot; &lt;&lt; programm &lt;&lt; &quot; &quot; &lt;&lt; i-&gt;help &lt;&lt; std::endl; 
+				}
+			} 
+			else if (i-&gt;key == GROUP) 
+			{
+				if (i != options.begin())
+					std::cout &lt;&lt; std::endl;
+				std::cout &lt;&lt; i-&gt;help &lt;&lt; std::endl;
+			}
+			else if (i-&gt;key == DOC) 
+			{
+				if (i != options.begin())
+					std::cout &lt;&lt; std::endl;
+				std::cout &lt;&lt; i-&gt;help &lt;&lt; std::endl;
+			}
+			else 
+			{
+				char option[256]   = { 0 };
+				char argument[256] = { 0 };
+
+				if (i-&gt;key &gt; 255 || i-&gt;key &lt; 0)
+					snprintf(option, 256, &quot;--%s&quot;, i-&gt;long_option.c_str());
+				else if (i-&gt;long_option.empty())
+					snprintf(option, 256, &quot;-%c&quot;, char(i-&gt;key));
+				else
+					snprintf(option, 256, &quot;-%c, --%s&quot;, char(i-&gt;key), i-&gt;long_option.c_str());
+
+				if (!i-&gt;argument.empty())
+				{
+					if (i-&gt;long_option.empty())
+						snprintf(argument, 256, &quot; %s&quot;, i-&gt;argument.c_str());
+					else
+						snprintf(argument, 256, &quot;=%s&quot;, i-&gt;argument.c_str());
+				}
+
+				std::cout &lt;&lt; &quot;  &quot; 
+							 &lt;&lt; std::setiosflags(std::ios::left) &lt;&lt; std::setw(help_indent)
+							 &lt;&lt; (std::string(option) + std::string(argument)) &lt;&lt; std::setw(0)
+							 &lt;&lt; &quot; &quot; &lt;&lt; i-&gt;help &lt;&lt; std::endl;
+			}
+		}
+	}
+	std::cout &lt;&lt; std::endl;
+}
+
+void CL_CommandLine_Generic::add_usage(const std::string&amp; usage)
+{
+	Option option;
+
+	option.key          = USAGE;
+	option.help         = usage;
+	option.visible      = true;
+
+	options.push_back(option);   
+}
+
+void CL_CommandLine_Generic::add_doc(const std::string&amp; grouptopic)
+{
+	Option option;
+
+	option.key          = DOC;
+	option.help         = grouptopic;
+	option.visible      = true;
+
+	options.push_back(option);  
+}
+
+void CL_CommandLine_Generic::add_group(const std::string&amp; grouptopic)
+{
+	Option option;
+
+	option.key          = GROUP;
+	option.help         = grouptopic;
+	option.visible      = true;
+
+	options.push_back(option);  
+}
+
+void CL_CommandLine_Generic::add_option(int key, 
+                      const std::string&amp; long_option, 
+                      const std::string&amp; argument,
+                      const std::string&amp; help,
+                      bool visible)
+{
+	Option option;
+
+	option.key          = key;
+	option.help         = help;
+	option.long_option  = long_option;
+	option.argument     = argument;
+	option.visible      = visible;
+
+	options.push_back(option);
+}
+
+bool CL_CommandLine_Generic::next()
+{
+	if (current_option == parsed_options.end()) 
+	{
+		(current_option = parsed_options.begin());
+		return current_option != parsed_options.end();
+	}
+	else
+	{
+		return (++current_option) != parsed_options.end();
+	}
+}
+
+int CL_CommandLine_Generic::get_key()
+{
+	return current_option-&gt;key;
+}
+
+std::string CL_CommandLine_Generic::get_argument()
+{
+	return current_option-&gt;argument;
+}

Added: trunk/clanlib/Core/System/Generic/command_line_generic.h
===================================================================
--- trunk/clanlib/Core/System/Generic/command_line_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Generic/command_line_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,111 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_core_system_command_line_generic
+#define header_core_system_command_line_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &quot;API/Core/System/command_line.h&quot;
+
+class CL_CommandLine_Generic
+{
+private:
+	int help_indent;
+
+	std::string programm;
+
+	struct Option 
+	{
+		int key;
+		std::string help;
+		std::string long_option;
+		std::string argument;
+		bool visible;
+	};
+  
+	typedef std::vector&lt;Option&gt; Options;
+	Options options;
+
+	struct ParsedOption
+	{
+		int key;
+		std::string argument;
+	};
+
+	typedef std::vector&lt;ParsedOption&gt; ParsedOptions;
+	ParsedOptions parsed_options;
+	ParsedOptions::iterator current_option;
+
+	enum
+	{
+		GROUP     = -3,
+		DOC       = -4,
+		USAGE     = -5
+	};
+
+public:  
+	CL_CommandLine_Generic();
+
+	void set_help_indent(int i) { help_indent = i; }
+
+	void add_usage(const std::string&amp; usage);
+	void add_doc(const std::string&amp; doc);
+	void add_group(const std::string&amp; grouptopic);
+  
+	void add_option(int key,
+						 const std::string&amp; long_option, 
+						 const std::string&amp; argument,
+						 const std::string&amp; help,
+						 bool visible = true);
+
+	void parse_args(int argc, char** argv);
+	void print_help();
+  
+	bool next();
+	int get_key();
+	std::string get_argument();
+
+private:
+	void read_option(int id, const std::string&amp; argument);
+
+	/** Find the Option structure that matches \a short_option */
+	Option* lookup_short_option(char short_option);
+
+	/** Find the Option structure that matches \a long_option */
+	Option* lookup_long_option (const std::string&amp; long_option);
+};
+
+#endif
+
+/* EOF */

Added: trunk/clanlib/Core/System/Generic/console_window.cpp
===================================================================
--- trunk/clanlib/Core/System/Generic/console_window.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Generic/console_window.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,72 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/System/console_window.h&quot;
+#include &quot;console_window_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ConsoleWindow construction:
+
+CL_ConsoleWindow::CL_ConsoleWindow(
+	const std::string &amp;title,
+	int width,
+	int height)
+: impl(NULL)
+{
+	impl = new CL_ConsoleWindow_Generic(title, width, height);
+}
+
+CL_ConsoleWindow::~CL_ConsoleWindow()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ConsoleWindow operations:
+
+void CL_ConsoleWindow::redirect_stdio()
+{
+	impl-&gt;redirect_stdio();
+}
+
+void CL_ConsoleWindow::redirect_stdio(const std::string &amp;filename)
+{
+	impl-&gt;redirect_stdio(filename);
+}
+
+void CL_ConsoleWindow::wait_for_key()
+{
+	impl-&gt;wait_for_key();
+}
+
+void CL_ConsoleWindow::display_close_message()
+{
+	impl-&gt;display_close_message();
+}

Added: trunk/clanlib/Core/System/Generic/console_window_generic.cpp
===================================================================
--- trunk/clanlib/Core/System/Generic/console_window_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Generic/console_window_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,143 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/System/cl_assert.h&quot;
+#include &quot;console_window_generic.h&quot;
+
+#include &lt;iostream&gt;
+#include &lt;cstdio&gt;
+
+#ifdef WIN32
+#include &lt;stdio.h&gt;
+static HANDLE scrbuf = NULL;
+#endif
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ConsoleWindow_Generic Construction:
+
+CL_ConsoleWindow_Generic::CL_ConsoleWindow_Generic(
+	const std::string &amp;title,
+	int width,
+	int height)
+{
+#ifdef WIN32
+	AllocConsole();
+	SetConsoleTitle(title.c_str());
+	COORD coord;
+	coord.X = width;
+	coord.Y = height;
+	scrbuf =
+		CreateConsoleScreenBuffer(
+			GENERIC_READ | GENERIC_WRITE,
+			FILE_SHARE_READ | FILE_SHARE_WRITE,
+			NULL,
+			CONSOLE_TEXTMODE_BUFFER,
+			NULL);
+
+	cl_assert(scrbuf != INVALID_HANDLE_VALUE);
+
+	SetConsoleActiveScreenBuffer(scrbuf);
+	SetConsoleScreenBufferSize(scrbuf, coord);
+
+	fstdout = 0;
+	fstdin = 0;
+	fstderr = 0;
+#endif
+}
+
+CL_ConsoleWindow_Generic::~CL_ConsoleWindow_Generic()
+{
+#ifdef WIN32
+	close_file_handles();
+	CloseHandle(scrbuf);
+#endif
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ConsoleWindow_Generic Operations:
+
+void CL_ConsoleWindow_Generic::redirect_stdio()
+{
+#ifdef WIN32
+	close_file_handles();
+	fstdin = freopen(&quot;CONIN$&quot;,&quot;rt&quot;,stdin);
+	fstderr = freopen(&quot;CONOUT$&quot;, &quot;wt&quot;, stderr);
+	fstdout = freopen(&quot;CONOUT$&quot;, &quot;wt&quot;, stdout);
+#endif
+}
+
+void CL_ConsoleWindow_Generic::redirect_stdio(const std::string &amp;file)
+{
+	close_file_handles();
+	fstdout = freopen(file.c_str(),&quot;wt&quot;,stdout);
+	fstderr = freopen(file.c_str(),&quot;wt&quot;,stderr);
+}
+
+void CL_ConsoleWindow_Generic::wait_for_key()
+{
+#ifdef WIN32
+	// If your application crashes here, you are linking with a single threaded
+	// libc in your application! -- mbn 13. Jan 2001.
+  #ifdef __BORLANDC__
+	std::string foo;
+	cin &gt;&gt; foo;
+  #else
+	while (!kbhit()) Sleep(250);
+  #endif
+#endif
+}
+
+void CL_ConsoleWindow_Generic::display_close_message()
+{
+#ifdef WIN32
+	std::cout &lt;&lt; std::endl &lt;&lt; &quot;(press any key to close this console window)&quot;;
+	std::cout.flush();
+
+	wait_for_key();
+#endif
+}
+
+void CL_ConsoleWindow_Generic::close_file_handles()
+{
+#ifdef WIN32
+	if (fstdin)
+	{
+		fclose(fstdin); fstdin = 0;
+	}
+	if (fstderr)
+	{
+		fclose(fstderr); fstderr = 0;
+	}
+	if (fstdout)
+	{
+		fclose(fstdout); fstdout = 0;
+	}
+#endif
+}

Added: trunk/clanlib/Core/System/Generic/console_window_generic.h
===================================================================
--- trunk/clanlib/Core/System/Generic/console_window_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Generic/console_window_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,75 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_console_window_generic
+#define header_console_window_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+#include &lt;cstdio&gt;
+
+class CL_ConsoleWindow_Generic
+{
+//! Construction:
+public:
+	CL_ConsoleWindow_Generic(
+		const std::string &amp;title,
+		int width,
+		int height);
+
+	~CL_ConsoleWindow_Generic();
+
+//! Operations:
+public:
+	void redirect_stdio();
+
+	void redirect_stdio(const std::string &amp;file);
+
+	void wait_for_key();
+	void display_close_message();
+
+//! Implementation:
+private:
+	void close_file_handles();
+
+#ifdef _MSC_VER
+	FILE *fstdout;
+	FILE *fstdin;
+	FILE *fstderr;
+#else
+	std::FILE *fstdout;
+	std::FILE *fstdin;
+	std::FILE *fstderr;
+#endif
+};
+
+#endif

Added: trunk/clanlib/Core/System/Generic/crash_reporter.cpp
===================================================================
--- trunk/clanlib/Core/System/Generic/crash_reporter.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Generic/crash_reporter.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,78 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/System/crash_reporter.h&quot;
+#include &quot;crash_reporter_generic.h&quot;
+
+#ifdef WIN32
+	#define CL_CrashReporter_Platform CL_CrashReporter_Win32
+	#include &quot;../Win32/crash_reporter_win32.h&quot;
+#else
+	#define CL_CrashReporter_Platform CL_CrashReporter_Unix
+	#include &quot;../Unix/crash_reporter_unix.h&quot;
+#endif
+
+/////////////////////////////////////////////////////////////////////////////
+// CrashReporter Construction:
+
+CL_CrashReporter::CL_CrashReporter() : impl(new CL_CrashReporter_Platform)
+{
+}
+
+CL_CrashReporter::~CL_CrashReporter()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CrashReporter Attributes:
+
+static bool dump_to_file = true;
+
+bool CL_CrashReporter::get_dump_to_file()
+{
+	return dump_to_file;
+}
+
+void CL_CrashReporter::set_dump_to_file(bool enable)
+{
+	dump_to_file = enable;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CrashReporter Operations:
+
+CL_Signal_v2&lt;std::string, CL_CallStack&gt; &amp;CL_CrashReporter::sig_crash()
+{
+	static CL_Signal_v2&lt;std::string, CL_CallStack&gt; signal;
+	return signal;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_CrashReporter Implementation:

Added: trunk/clanlib/Core/System/Generic/crash_reporter_generic.h
===================================================================
--- trunk/clanlib/Core/System/Generic/crash_reporter_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Generic/crash_reporter_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,52 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_crash_reporter_generic
+#define header_crash_reporter_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+class CL_CrashReporter_Generic
+{
+//! Construction:
+public:
+	CL_CrashReporter_Generic() { return; }
+
+	virtual ~CL_CrashReporter_Generic() { return; }
+
+//! Attributes:
+public:
+
+//! Operations:
+public:
+};
+
+#endif

Added: trunk/clanlib/Core/System/Generic/detect_3dnow.cpp
===================================================================
--- trunk/clanlib/Core/System/Generic/detect_3dnow.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Generic/detect_3dnow.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,347 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/System/system.h&quot;
+#include &quot;API/Core/System/cl_assert.h&quot;
+#include &quot;API/Core/System/log.h&quot;
+
+static bool do_3dnow_test();
+static bool do_ext_3dnow_test();
+
+bool CL_System::detect_3dnow()
+{
+	static bool has_3dnow = false;
+	static bool first_time = true;
+	
+	if (first_time)
+	{
+		first_time = false;
+		has_3dnow = do_3dnow_test();
+	}
+	
+	return has_3dnow;
+}
+
+bool CL_System::detect_ext_3dnow()
+{
+	static bool has_ext_3dnow = false;
+	static bool first_time = true;
+	
+	if (first_time)
+	{
+		first_time = false;
+		has_ext_3dnow = do_ext_3dnow_test();
+	}
+	
+	return has_ext_3dnow;
+}
+
+static bool do_3dnow_test()
+{
+#ifdef USE_I386_ASSEMBLER
+#ifdef __MSC__
+	unsigned long RegEDX = 0;
+	unsigned long RegEAX = 0;
+
+	try 
+	{
+		_asm
+		{
+			mov		eax, 0x80000000		// set up CPUID to return processor extended functions
+			CPUID						// code bytes = 0fh,  0a2h
+			mov		RegEAX, eax
+		}
+
+		if (!(RegEAX &amp; 0x80000000))		// no functions &gt; 0x80000000 ?
+			return false;				//we don't have any extended features, quit
+		else
+			_asm
+			{
+				mov		eax, 0x80000001 // CPUID ext. function 0x80000001
+				CPUID		                // EDX contains extended feature flags
+				mov		RegEDX, edx     // extended features returned in edx
+			}
+
+	 	}
+	catch(...)					// catch everything
+	{
+		return false;
+	}
+
+	if (RegEDX &amp; 0x80000000) 	// bit 31 indicates presence of 3DNow! technology
+	{
+		try
+		{
+			//DB 0Fh, 0Eh			// try executing the 3DNow! instruction &quot;femms&quot;
+		     	_asm _emit 0x0f;
+		     	_asm _emit 0x0e;
+		}
+		catch(...) { return false; }
+	}
+   	else
+		return false;
+
+	return true;
+#elif __BORLANDC__
+
+//This is for detecting assembly when using the Borland compilers
+//If you do not have TASM then this will not compile
+//If you do have TASM then uncomment the code below, otherwise ignore it
+
+	#ifdef USE_TASM
+	int RegEDX=0,RegEAX=0;
+  try
+  {
+  	asm
+    {
+    	mov		eax, 0x80000000		// set up CPUID to return processor extended functions
+    	CPUID						// code bytes = 0fh,  0a2h
+    	mov		RegEAX, eax
+    }
+  }
+  catch(...) { return false; }
+
+  if(RegEAX &gt; 0x80000000)
+  {
+  	asm
+    {
+			mov     eax, 0x80000001		// CPUID ext. function 0x80000001
+    	CPUID                       // EDX contains extended feature flags
+    	mov		RegEDX, edx			// extended features returned in edx
+    }
+  }
+  else
+  	return false;
+
+  if( RegEDX &amp; 0x80000000)
+  {
+  	try
+		{
+			//DB 0Fh, 0Eh			// try executing the 3DNow! instruction &quot;femms&quot;
+      __emit__(0x0f,0x0e);
+		}
+		catch(...) { return false; }
+  }
+  else
+  	return false;
+  return true;
+  #else
+
+	CL_Log::log(&quot;debug&quot;, &quot;3DNow check support not compiled in.&quot;);
+  return false;
+	#endif
+#elif __GNUC__
+
+	unsigned int RegEDX=0,RegEAX=0;
+	try
+	{
+		asm(
+		&quot;mov 0x80000000, %%eax \n&quot; //Get ready for extended functions
+		&quot;CPUID \n&quot; //Access CPUID
+		: &quot;=a&quot;(RegEAX));
+	}
+	catch(...) 
+	{
+		return false;
+	}
+	if(RegEDX &gt; 0x80000000)
+	{
+		asm(
+				&quot;mov 0x80000001, %%eax \n&quot; //Access extended features
+				&quot;CPUID \n&quot;  //Query CPU
+				: &quot;=d&quot;(RegEDX));
+	}
+	else 
+	{
+		return false;
+	}
+
+	if(!(RegEDX &amp; 0x80000000))
+	{
+		return false;
+	}
+	try
+	{
+		asm(&quot;femms&quot;);
+	}
+	catch(...)
+	{
+		return false;
+	}
+	return true;
+
+#endif
+#else
+	// Not implemented under unix
+	return false;
+#endif //Endif USE_I386_ASSEMBLER
+}
+
+static bool do_ext_3dnow_test()
+{
+#ifdef USE_I386_ASSEMBLER
+#ifdef __MSC__
+	unsigned long RegEDX = 0;
+	unsigned long RegEAX = 0;
+
+	try 
+	{
+		_asm
+		{
+			mov		eax, 0x80000000		// set up CPUID to return processor extended functions
+			CPUID						// code bytes = 0fh,  0a2h
+			mov		RegEAX, eax
+		}
+
+		if (!(RegEAX &amp; 0x80000000))		// no functions &gt; 0x80000000 ?
+			return false;				//we don't have any extended features, quit
+		else
+			_asm
+			{
+				mov     eax, 0x80000001		// CPUID ext. function 0x80000001
+				CPUID                       // EDX contains extended feature flags
+				mov		RegEDX, edx			// extended features returned in edx
+			}
+
+   	}
+	catch(...)					// catch everything
+	{
+		return false;
+	}
+
+	if (RegEDX &amp; 0x40000000) 	// bit 30 indicates presence of extended 3DNow! technology
+	{
+		try
+		{
+			//DB 0Fh, 0Eh			// try executing the 3DNow! instruction &quot;femms&quot;
+		     	_asm _emit 0x0f;
+		     	_asm _emit 0x0e;
+		}
+		catch(...) { return false; }
+	}
+   	else
+		return false;
+
+	return true;
+#elif __BORLANDC__
+
+//This is for detecting assembly when using the Borland compilers
+//If you do not have TASM then this will not compile
+//If you do have TASM then uncomment the code below, otherwise ignore it
+
+	#ifdef USE_TASM
+	int RegEDX=0,RegEAX=0;
+  try
+  {
+  	asm
+    {
+    	mov		eax, 0x80000000		// set up CPUID to return processor extended functions
+    	CPUID						// code bytes = 0fh,  0a2h
+    	mov		RegEAX, eax
+    }
+  }
+  catch(...) { return false; }
+
+  if(RegEAX &gt; 0x80000000)
+  {
+  	asm
+    {
+			mov     eax, 0x80000001		// CPUID ext. function 0x80000001
+    	CPUID                       // EDX contains extended feature flags
+    	mov		RegEDX, edx			// extended features returned in edx
+    }
+  }
+  else
+  	return false;
+
+  if( RegEDX &amp; 0x40000000)
+  {
+  	try
+		{
+			//DB 0Fh, 0Eh			// try executing the 3DNow! instruction &quot;femms&quot;
+      __emit__(0x0f,0x0e);
+		}
+		catch(...) { return false; }
+  }
+  else
+  	return false;
+  return true;
+  #else
+
+	CL_Log::log(&quot;debug&quot;, &quot;3DNow check support not compiled in.&quot;);
+  return false;
+	#endif
+#elif __GNUC__
+
+	unsigned int RegEDX=0,RegEAX=0;
+	try
+	{
+		asm(
+		&quot;mov 0x80000000, %%eax \n&quot; //Get ready for extended functions
+		&quot;CPUID \n&quot; //Access CPUID
+		: &quot;=a&quot;(RegEAX));
+	}
+	catch(...) 
+	{
+		return false;
+	}
+	if(RegEDX &gt; 0x80000000)
+	{
+		asm(
+				&quot;mov 0x80000001, %%eax \n&quot; //Access extended features
+				&quot;CPUID \n&quot;  //Query CPU
+				: &quot;=d&quot;(RegEDX));
+	}
+	else 
+	{
+		return false;
+	}
+
+	if(!(RegEDX &amp; 0x40000000))
+	{
+		return false;
+	}
+	try
+	{
+		asm(&quot;femms&quot;);
+	}
+	catch(...)
+	{
+		return false;
+	}
+	return true;
+
+#endif
+#else
+	// Not implemented under unix
+	return false;
+#endif //Endif USE_I386_ASSEMBLER
+
+}

Added: trunk/clanlib/Core/System/Generic/detect_mmx.cpp
===================================================================
--- trunk/clanlib/Core/System/Generic/detect_mmx.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Generic/detect_mmx.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,149 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Darryl Agostinelli March 4, 2000
+**    Code was adopted from Intel web page
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/System/system.h&quot;
+#include &quot;API/Core/System/cl_assert.h&quot;
+#include &quot;API/Core/System/log.h&quot;
+
+static bool do_mmx_test();
+
+bool CL_System::detect_mmx()
+{
+	static bool has_mmx = false;
+	static bool first_time = true;
+	
+	if (first_time)
+	{
+		first_time = false;
+		has_mmx = do_mmx_test();
+	}
+	
+	return has_mmx;
+}
+
+static bool do_mmx_test()
+{
+#ifdef USE_I386_ASSEMBLER
+#ifdef __MSC__
+	unsigned long RegEDX;
+
+	try 
+	{
+		_asm
+		{
+			mov eax, 1			// set up CPUID to return processor version and features
+								//	0 = vendor string, 1 = version info, 2 = cache info
+			CPUID				// code bytes = 0fh,  0a2h
+			mov RegEDX, edx		// features returned in edx
+		}
+	}
+	catch(...)					// catch everything
+	{
+		return false;			// processor does not support CPUID
+	}
+
+	if (RegEDX &amp; 0x800000) 		// bit 23 is set for MMX technology
+	{
+		try { _asm {emms} }		// try executing the MMX instruction &quot;emms&quot;
+		catch(...) { return false; }
+	}
+	else
+		return false;			// processor supports CPUID but does not support MMX technology
+
+	// if we get here, it means the processor has MMX technology but
+	// floating-point emulation is on; so MMX technology is unavailable
+
+	return true;
+#elif  __GNUC__
+
+	int edx=0;
+	try 
+	{
+		asm(
+				&quot;mov 1,%%eax \n&quot; //Get ready for CPUID
+				&quot;CPUID \n&quot; //Access CPUID
+				:&quot;=d&quot;(edx) 
+			 );
+	}
+	catch(...) //Catch all
+	{
+		return false;
+	}
+	if (edx &amp; 0x800000)
+	{
+		try{ asm(&quot;emms&quot;); }
+		catch(...) {return false;}
+	}
+	else
+		return false;
+	
+	return true;
+#elif __BORLANDC__
+
+//This is for detecting assembly when using the Borland compilers
+//If you do not have TASM then this will not compile
+//If you do have TASM then uncomment the code below, otherwise ignore it
+
+	#ifdef USE_TASM
+	int RegEDX=0;
+	try
+	{
+	asm
+	{
+		mov eax, 1
+		CPUID
+		mov RegEDX, edx
+	}
+	}
+	catch(...) {return false;}
+
+	if (RegEDX &amp; 0x800000)
+	{
+		try{asm{emms}}
+		catch(...) {return false;}
+	}
+	else
+		return false;
+	return true;
+#else
+
+	CL_Log::log(&quot;debug&quot;, &quot;Support to detect this has not been compiled in.&quot;);
+	return false;
+#endif //Endif USE_TASM
+
+#else
+	// Not implemented
+	return false;
+#endif
+
+#else
+	return false;
+#endif //End USE_I386_ASSEMBLER
+}

Added: trunk/clanlib/Core/System/Generic/error.cpp
===================================================================
--- trunk/clanlib/Core/System/Generic/error.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Generic/error.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,40 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+
+void cl_throw_error(const char *message)
+{
+	throw CL_Error(message);
+}
+
+void cl_throw_error(const std::string &amp;message)
+{
+	throw CL_Error(message);
+}

Added: trunk/clanlib/Core/System/Generic/event_listener.cpp
===================================================================
--- trunk/clanlib/Core/System/Generic/event_listener.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Generic/event_listener.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,103 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/System/event_listener.h&quot;
+#include &quot;event_listener_generic.h&quot;
+
+#ifdef WIN32
+#include &quot;Core/System/Win32/event_listener_win32.h&quot;
+#else
+#include &quot;Core/System/Unix/event_listener_unix.h&quot;
+#endif
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventListener construction:
+
+CL_EventListener::CL_EventListener()
+: impl(NULL)
+{
+#ifdef WIN32
+	impl = new CL_EventListener_Win32(this);
+#else
+	impl = new CL_EventListener_Unix(this);
+#endif
+}
+
+CL_EventListener::CL_EventListener(CL_EventTrigger *trigger)
+: impl(NULL)
+{
+#ifdef WIN32
+	impl = new CL_EventListener_Win32(this);
+#else
+	impl = new CL_EventListener_Unix(this);
+#endif
+
+	add_trigger(trigger);
+}
+
+CL_EventListener::~CL_EventListener()
+{
+	if (impl) delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventListener attributes:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventListener operations:
+
+void CL_EventListener::add_trigger(CL_EventTrigger *trigger)
+{
+	if (impl) impl-&gt;add_trigger(trigger);
+}
+
+void CL_EventListener::remove_trigger(CL_EventTrigger *trigger)
+{
+	if (impl) impl-&gt;remove_trigger(trigger);
+}
+
+void CL_EventListener::clear()
+{
+	if (impl) impl-&gt;clear();
+}
+
+void CL_EventListener::reset_all()
+{
+	if (impl) impl-&gt;reset_all();
+}
+
+bool CL_EventListener::wait(int timeout)
+{
+	if (impl) return impl-&gt;wait(timeout);
+	else return false;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventListener implementation:

Added: trunk/clanlib/Core/System/Generic/event_listener_generic.cpp
===================================================================
--- trunk/clanlib/Core/System/Generic/event_listener_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Generic/event_listener_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,75 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;event_listener_generic.h&quot;
+#include &quot;event_trigger_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventListener_Generic construction:
+
+CL_EventListener_Generic::CL_EventListener_Generic(CL_EventListener *owner)
+: owner(owner)
+{
+}
+
+CL_EventListener_Generic::~CL_EventListener_Generic()
+{
+	clear();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventListener_Generic attributes:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventListener_Generic operations:
+
+void CL_EventListener_Generic::add_trigger(const CL_EventTrigger *trigger)
+{
+	triggers.push_back(trigger-&gt;impl);
+}
+
+void CL_EventListener_Generic::remove_trigger(const CL_EventTrigger *trigger)
+{
+	triggers.remove(trigger-&gt;impl);
+}
+
+void CL_EventListener_Generic::clear()
+{
+	triggers.clear();
+}
+
+void CL_EventListener_Generic::reset_all()
+{
+	std::list&lt; CL_SharedPtr&lt;CL_EventTrigger_Generic&gt; &gt;::iterator it;
+	for (it = triggers.begin(); it != triggers.end(); it++) (*it)-&gt;reset();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventListener_Generic implementation:

Added: trunk/clanlib/Core/System/Generic/event_listener_generic.h
===================================================================
--- trunk/clanlib/Core/System/Generic/event_listener_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Generic/event_listener_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,79 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_event_listener_generic
+#define header_event_listener_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/System/event_listener.h&quot;
+#include &quot;API/Core/System/event_trigger.h&quot;
+#include &quot;API/Core/System/sharedptr.h&quot;
+
+class CL_EventTrigger_Generic;
+
+class CL_EventListener_Generic
+{
+//! Construction:
+public:
+	CL_EventListener_Generic(CL_EventListener *owner);
+
+	virtual ~CL_EventListener_Generic();
+
+//! Attributes:
+public:
+
+//! Operations:
+public:
+	//: Adds an event trigger to the listener.
+	void add_trigger(const CL_EventTrigger *trigger);
+
+	//: Removes an event trigger from the listener.
+	void remove_trigger(const CL_EventTrigger *trigger);
+
+	//: Removes all event triggers from the listener.
+	void clear();
+
+	//: Resets all event triggers added to the listener.
+	void reset_all();
+
+	//: Wait until one of the events triggers. The timeout is in milliseconds.
+	//return: true if a event triggered, false if it timed out.
+	virtual bool wait(int timeout)=0;
+
+	std::list&lt; CL_SharedPtr&lt;CL_EventTrigger_Generic&gt; &gt; triggers;
+
+//! Implementation:
+private:
+	CL_EventListener *owner;
+};
+
+#endif

Added: trunk/clanlib/Core/System/Generic/event_trigger.cpp
===================================================================
--- trunk/clanlib/Core/System/Generic/event_trigger.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Generic/event_trigger.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,90 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/System/event_trigger.h&quot;
+#include &quot;event_trigger_generic.h&quot;
+
+#ifdef WIN32
+#include &quot;Core/System/Win32/event_trigger_win32.h&quot;
+#else
+#include &quot;Core/System/Unix/event_trigger_unix.h&quot;
+#endif
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventTrigger construction:
+
+CL_EventTrigger::CL_EventTrigger()
+{
+#ifdef WIN32
+	impl = new CL_EventTrigger_Win32;
+#else
+	impl = new CL_EventTrigger_Unix;
+#endif
+
+	reset();
+}
+
+CL_EventTrigger::CL_EventTrigger(const CL_EventTrigger &amp;copy)
+: impl(copy.impl)
+{
+}
+
+CL_EventTrigger::~CL_EventTrigger()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventTrigger attributes:
+
+bool CL_EventTrigger::get_flag() const
+{
+	return impl-&gt;get_flag();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventTrigger operations:
+
+void CL_EventTrigger::reset() const
+{
+	impl-&gt;reset();
+}
+
+void CL_EventTrigger::set_flag()
+{
+	impl-&gt;set_flag();
+}
+
+bool CL_EventTrigger::wait(int timeout)
+{
+	return impl-&gt;wait(timeout);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventTrigger implementation:

Added: trunk/clanlib/Core/System/Generic/event_trigger_generic.cpp
===================================================================
--- trunk/clanlib/Core/System/Generic/event_trigger_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Generic/event_trigger_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,51 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;event_trigger_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventTrigger_Generic construction:
+
+CL_EventTrigger_Generic::CL_EventTrigger_Generic()
+{
+}
+
+CL_EventTrigger_Generic::~CL_EventTrigger_Generic()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventTrigger_Generic attributes:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventTrigger_Generic operations:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventTrigger_Generic implementation:

Added: trunk/clanlib/Core/System/Generic/event_trigger_generic.h
===================================================================
--- trunk/clanlib/Core/System/Generic/event_trigger_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Generic/event_trigger_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,67 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_event_trigger_generic
+#define header_event_trigger_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+class CL_EventListener;
+
+class CL_EventTrigger_Generic
+{
+//! Construction:
+public:
+	CL_EventTrigger_Generic();
+
+	virtual ~CL_EventTrigger_Generic();
+
+//! Attributes:
+public:
+	virtual bool get_flag() const=0;
+
+//! Operations:
+public:
+	//: Reset trigger flag.
+	virtual void reset() const=0;
+
+	//: Raise trigger flag.
+	virtual void set_flag()=0;
+
+	//: Wait until one of the event triggers. The timeout is in milliseconds.
+	//return: true if the event triggered, false if it timed out.
+	virtual bool wait(int timeout = -1) const=0;
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/Core/System/Generic/keep_alive_generic.cpp
===================================================================
--- trunk/clanlib/Core/System/Generic/keep_alive_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Generic/keep_alive_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,146 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &lt;list&gt;
+#include &lt;map&gt;
+
+#include &quot;API/Core/System/keep_alive.h&quot;
+#include &quot;API/Core/System/system.h&quot;
+#include &quot;API/Core/System/event_listener.h&quot;
+#include &quot;API/Core/System/thread.h&quot;
+#include &quot;API/Core/System/mutex.h&quot;
+
+unsigned int CL_System::susp_start;
+unsigned int CL_System::susp_cnt = 0;
+unsigned int CL_System::susp_accum = 0;
+
+void CL_System::suspend_time()
+{
+	++susp_cnt;
+	if (susp_cnt == 1)
+		susp_start = sys_time();
+}
+
+void CL_System::resume_time()
+{
+	if (susp_cnt != 0) {
+		--susp_cnt;
+		if (susp_cnt == 0) {
+			susp_accum += sys_time() - susp_start;
+		}
+	}
+}
+
+unsigned int CL_System::get_time()
+{
+	if (susp_cnt == 0)
+		return sys_time() - susp_accum;
+	else
+		return susp_start - susp_accum;
+}
+
+CL_Mutex mutex_keep_alive;
+std::map&lt;CL_ThreadId, std::list&lt;CL_KeepAlive*&gt;* &gt; keep_alives;
+
+CL_KeepAlive::CL_KeepAlive()
+{
+	create_thread_id = CL_Thread::get_current_id();
+	CL_MutexSection mutex_lock(&amp;mutex_keep_alive);
+	std::map&lt;CL_ThreadId, std::list&lt;CL_KeepAlive*&gt;* &gt;::iterator it;
+	it = keep_alives.find(create_thread_id);
+	if (it == keep_alives.end())
+	{
+		keep_alives[create_thread_id] = new std::list&lt;CL_KeepAlive*&gt;;
+	}
+	
+	keep_alives[create_thread_id]-&gt;push_back(this);
+}
+
+CL_KeepAlive::~CL_KeepAlive()
+{
+	CL_MutexSection mutex_lock(&amp;mutex_keep_alive);
+	std::list&lt;CL_KeepAlive*&gt; *list = keep_alives[create_thread_id];
+	list-&gt;remove(this);
+	if (list-&gt;empty())
+	{
+		delete list;
+		keep_alives.erase(keep_alives.find(create_thread_id));
+	}
+}
+
+void CL_System::keep_alive()
+{
+	CL_ThreadId cur_thread_id = CL_Thread::get_current_id();
+	CL_MutexSection mutex_lock(&amp;mutex_keep_alive);
+	std::map&lt;CL_ThreadId, std::list&lt;CL_KeepAlive*&gt;* &gt;::iterator it_map;
+	it_map = keep_alives.find(cur_thread_id);
+	if (it_map == keep_alives.end()) return;
+
+	std::list&lt;CL_KeepAlive*&gt; *list = it_map-&gt;second;
+
+	for (
+		std::list&lt;CL_KeepAlive*&gt;::iterator it = list-&gt;begin();
+		it != list-&gt;end();
+		it++)
+	{
+		(*it)-&gt;keep_alive();
+	}
+}
+
+void CL_System::keep_alive(int millis)
+{
+	CL_EventListener events;
+	keep_alive(events, millis);
+}
+
+bool CL_System::keep_alive(CL_EventListener &amp;events, int timeout)
+{
+	// TODO: Add triggers for keep alive objects.
+
+	if (timeout == -1)
+	{
+		do CL_System::keep_alive(); while (!events.wait(10));
+
+		return true;
+	}
+	else
+	{
+		while (timeout &gt; 0)
+		{
+			CL_System::keep_alive();
+			if (events.wait(timeout &gt; 10 ? 10 : timeout)) return true;
+			timeout -= 10;
+		}
+
+		return false;
+	}
+}
+
+

Added: trunk/clanlib/Core/System/Generic/log.cpp
===================================================================
--- trunk/clanlib/Core/System/Generic/log.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Generic/log.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,61 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/System/log.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Log construction:
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Log attributes:
+
+static CL_Signal_v3&lt;const std::string &amp;, int, const std::string &amp;&gt; cl_sig_log;
+
+CL_Signal_v3&lt;const std::string &amp;, int, const std::string &amp;&gt; &amp;CL_Log::sig_log()
+{
+	return cl_sig_log;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Log operations:
+
+void CL_Log::log(const std::string &amp;group, const std::string &amp;message)
+{
+	cl_sig_log(group, 0, message);
+}
+
+void CL_Log::log(const std::string &amp;group, int severity, const std::string &amp;message)
+{
+	cl_sig_log(group, severity, message);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Log implementation:

Added: trunk/clanlib/Core/System/Generic/setupcore.cpp
===================================================================
--- trunk/clanlib/Core/System/Generic/setupcore.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Generic/setupcore.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,88 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &lt;cstdlib&gt;
+#include &quot;API/Core/Resources/resourcetype_boolean.h&quot;
+#include &quot;API/Core/Resources/resourcetype_integer.h&quot;
+#include &quot;API/Core/Resources/resourcetype_float.h&quot;
+#include &quot;API/Core/Resources/resourcetype_string.h&quot;
+#include &quot;API/Core/Resources/resourcetype_raw.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;API/Core/System/setupcore.h&quot;
+
+void init_system(); // this function is implemented in init_PLATFORM.cpp
+void deinit_system(); // this function is implemented in init_PLATFORM.cpp
+
+static int ref_count = 0;
+static CL_Slot slot_resource_added;
+
+static void clancore_resource_added(CL_Resource &amp;resource)
+{
+	std::string type = resource.get_type();
+
+	if (type == &quot;boolean&quot;) new CL_ResourceData_Boolean(resource);
+	if (type == &quot;integer&quot;) new CL_ResourceData_Integer(resource);
+	if (type == &quot;float&quot;) new CL_ResourceData_Float(resource);
+	if (type == &quot;string&quot;) new CL_ResourceData_String(resource);
+	if (type == &quot;raw&quot;) new CL_ResourceData_Raw(resource);
+}
+
+CL_SetupCore::CL_SetupCore(bool register_resources_only)
+{
+	CL_SetupCore::init(register_resources_only);
+}
+
+CL_SetupCore::~CL_SetupCore()
+{
+	CL_SetupCore::deinit();
+}
+
+void CL_SetupCore::init(bool register_resources_only)
+{
+	ref_count++;
+	if (ref_count &gt; 1) return;
+
+	slot_resource_added = CL_ResourceManager::sig_resource_added().connect(&amp;clancore_resource_added);
+	if (register_resources_only) return;
+	
+	init_system();
+}
+
+void CL_SetupCore::deinit()
+{
+	// Since, CL_SetupCore::init() may be called more than once - Only call deinit at the final call to this function
+	if (!ref_count) return;	// Do not allow ref_count to become negative (may occur if something calls deinit() without an init() )
+	ref_count--;
+	if (ref_count &gt; 0) return;	// Wait until final call to deinit
+
+	slot_resource_added = CL_Slot();
+
+	deinit_system();
+}

Added: trunk/clanlib/Core/System/Generic/timer_generic.cpp
===================================================================
--- trunk/clanlib/Core/System/Generic/timer_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Generic/timer_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,85 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/System/timer.h&quot;
+#include &quot;API/Core/System/system.h&quot;
+
+CL_Timer::CL_Timer(unsigned long _interval)
+: interval(_interval), last_time(0), enabled(false)
+{
+}
+
+void CL_Timer::keep_alive()
+{
+	if (!enabled)
+		return;
+
+	unsigned long cur = CL_System::get_time();
+	if (last_time &gt; cur)
+		last_time = cur; // The counter has overflowed the variable - reset it
+		
+	while (cur &gt;= last_time + interval)
+	{
+		sig_timer()();
+		last_time += interval;
+	}
+}
+
+void CL_Timer::enable()
+{
+	enabled = true;
+	last_time = CL_System::get_time();
+}
+
+void CL_Timer::disable()
+{
+	enabled = false;
+}
+
+bool CL_Timer::is_enabled()
+{
+	return enabled;
+}
+
+void CL_Timer::set_interval(unsigned long interval)
+{
+	this-&gt;interval = interval;
+	last_time = CL_System::get_time();
+}
+
+unsigned long CL_Timer::get_interval()
+{
+	return interval;
+}
+
+CL_Signal_v0 &amp;CL_Timer::sig_timer()
+{
+	return signal_timer;
+}

Added: trunk/clanlib/Core/System/Unix/cl_library.cpp
===================================================================
--- trunk/clanlib/Core/System/Unix/cl_library.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Unix/cl_library.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,199 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/System/cl_library.h&quot;
+
+#ifdef USE_DYN
+#include &lt;dlfcn.h&gt;
+#endif
+
+#include &lt;iostream&gt;
+
+std::map&lt;std::string, CL_LibraryFactoryMaker *, std::less&lt;std::string&gt; &gt; CL_LibraryManager::libraries;
+
+CL_LibraryLoader::CL_LibraryLoader(const std::string&amp; file) : filename(file), loaded(false), handle(0), last_error(0)
+{
+	// Be sure to end the given filename with the right extension
+	if(filename.rfind(&quot;.so&quot;,filename.size()) == std::string::npos)
+	{
+		filename.append(&quot;.so&quot;);
+	}
+}
+
+CL_LibraryLoader::~CL_LibraryLoader()
+{
+	// Don't forget to unload the library if needed
+	if((loaded == true) &amp;&amp; (handle != 0))
+		unload();
+}
+
+std::string CL_LibraryLoader::name() const
+{
+	return filename;
+}
+
+bool CL_LibraryLoader::is_loaded() const
+{
+	return loaded;
+}
+
+void *CL_LibraryLoader::resolve(const std::string&amp; symbol)
+{
+#ifdef USE_DYN
+	// Just in case the handle has been corrupted
+	if(handle == 0)
+		return 0;
+
+	// Lookup the symbol name
+	void *adr = dlsym(handle,symbol.c_str());
+	
+	const char *error = dlerror();
+	// If the error is not NULL, then the dlsym call failed
+	if(error != 0)
+	{
+		if(last_error != 0)
+			delete last_error;
+		last_error = new CL_Error(std::string(error));
+		return 0;
+	}
+#else
+	void *adr = 0;
+	if(last_error != 0)
+                delete last_error;
+        last_error = new CL_Error(std::string(&quot;ClanLib hasn't been built with dynamic loading support&quot;));
+#endif
+
+	return adr;
+}
+
+bool CL_LibraryLoader::load()
+{
+#ifdef USE_DYN
+	// We use RTLD_LAZY|RTLD_GLOBAL which is a good default nowadays
+	handle = dlopen(filename.c_str(), RTLD_LAZY|RTLD_GLOBAL);
+	if(handle == 0)
+	{
+		const char *error = dlerror();
+		// If the error is not NULL, then the dlopen call failed
+		if(error != 0)
+		{
+			if(last_error != 0)
+				delete last_error;
+			last_error = new CL_Error(std::string(error));
+			
+		}
+		loaded = false;
+	}
+	else
+	{
+		loaded = true;
+	}
+#else
+	loaded = false;
+	if(last_error != 0)
+                delete last_error;
+        last_error = new CL_Error(std::string(&quot;ClanLib hasn't been built with dynamic loading support&quot;));
+#endif
+
+	return loaded;
+}
+
+bool CL_LibraryLoader::unload()
+{
+#ifdef USE_DYN
+	if(last_error != 0)
+	{
+		delete last_error;
+		last_error = 0;
+	}
+
+	// Well if the handle is already NULL, don't need to unload it again
+	if(handle == 0)
+		return true;
+	
+	if(dlclose(handle) != 0)
+	{
+		last_error = new CL_Error(std::string(dlerror()));
+		return false;
+	}
+
+	handle = 0;
+	loaded = false;
+#endif
+
+	return true;
+}
+
+CL_Error *CL_LibraryLoader::get_last_error() const
+{
+	if(last_error == 0)
+                return new CL_Error(std::string(&quot;No CL_Library error set so far&quot;));
+	return last_error;
+}
+
+CL_LibraryFactoryMaker_t CL_LibraryManager::get(const std::string&amp; lib_name)
+{
+	std::map&lt;std::string, CL_LibraryFactoryMaker *, std::less&lt;std::string&gt; &gt;::iterator libs_itr;
+	CL_LibraryFactoryMaker_t lib;
+	bool found = true;
+
+	if((libs_itr = libraries.find(lib_name)) != libraries.end())
+	{
+		lib = (*libs_itr).second;
+	}
+	else
+	{
+		found = false;
+	}
+
+	if(found == false)
+		return 0;
+
+	return lib;
+}
+
+void CL_LibraryManager::add(const std::string&amp; lib_name,CL_LibraryFactoryMaker *lib)
+{
+	libraries[lib_name] = lib;
+}
+
+void CL_LibraryManager::remove(const std::string&amp; lib_name)
+{
+	if(libraries.find(lib_name) != libraries.end())
+		libraries.erase(lib_name);
+}
+
+bool CL_LibraryManager::has(const std::string&amp; lib_name)
+{
+	if(libraries.find(lib_name) != libraries.end())
+		return true;
+	return false;
+}
+

Added: trunk/clanlib/Core/System/Unix/crash_reporter_unix.cpp
===================================================================
--- trunk/clanlib/Core/System/Unix/crash_reporter_unix.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Unix/crash_reporter_unix.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,65 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/System/crash_reporter.h&quot;
+#include &quot;API/Core/System/log.h&quot;
+#include &quot;crash_reporter_unix.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_CrashReporter_Unix Construction:
+
+CL_CrashReporter_Unix::CL_CrashReporter_Unix()
+{
+}
+
+CL_CrashReporter_Unix::~CL_CrashReporter_Unix()
+{
+}
+
+/*
+todo: hook up signal handlers, then print_trace to file and emit sig_crash
+
+void print_trace (void)
+{
+	void *array[10];
+	size_t size;
+	char **strings;
+	size_t i;
+
+	size = backtrace (array, 10);
+	strings = backtrace_symbols (array, size);
+
+	printf (&quot;Obtained %zd stack frames.\n&quot;, size);
+
+	for (i = 0; i &lt; size; i++) printf (&quot;%s\n&quot;, strings[i]);
+
+	free (strings);
+}
+*/

Added: trunk/clanlib/Core/System/Unix/crash_reporter_unix.h
===================================================================
--- trunk/clanlib/Core/System/Unix/crash_reporter_unix.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Unix/crash_reporter_unix.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,51 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_crash_reporter_unix
+#define header_crash_reporter_unix
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Generic/crash_reporter_generic.h&quot;
+
+class CL_CrashReporter_Unix : public CL_CrashReporter_Generic
+{
+//! Construction:
+public:
+	CL_CrashReporter_Unix();
+
+	~CL_CrashReporter_Unix();
+
+//! Implementation:
+public:
+};
+
+#endif

Added: trunk/clanlib/Core/System/Unix/event_listener_unix.cpp
===================================================================
--- trunk/clanlib/Core/System/Unix/event_listener_unix.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Unix/event_listener_unix.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,90 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;event_listener_unix.h&quot;
+#include &quot;event_trigger_unix.h&quot;
+#include &quot;API/Core/System/system.h&quot;
+
+// note: this cannot be replaced by &lt;ctime&gt;! (timeval needs to be defined)
+#include &lt;sys/time.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;unistd.h&gt;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventListener_Unix construction:
+
+CL_EventListener_Unix::CL_EventListener_Unix(CL_EventListener *owner)
+:
+	CL_EventListener_Generic(owner)
+{
+}
+
+CL_EventListener_Unix::~CL_EventListener_Unix()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventListener_Unix implementation:
+
+bool CL_EventListener_Unix::wait(int timeout)
+{
+	if (triggers.empty()) // no triggers, just do the sleep.
+	{
+		CL_System::sleep(timeout);
+		return false;
+	}
+
+	fd_set rfds;
+	FD_ZERO(&amp;rfds);
+	int highest_fd = -1;
+
+	std::list&lt; CL_SharedPtr&lt;CL_EventTrigger_Generic&gt; &gt;::iterator it;
+	for (it = triggers.begin(); it != triggers.end(); ++it)
+	{
+		CL_EventTrigger_Unix *trigger = static_cast&lt;CL_EventTrigger_Unix*&gt;((*it).get());
+		
+		if (trigger-&gt;wait_pipe[0] &gt; highest_fd) highest_fd = trigger-&gt;wait_pipe[0];
+		FD_SET(trigger-&gt;wait_pipe[0], &amp;rfds);
+	}
+	
+	timeval tv;
+	tv.tv_sec = timeout/1000;
+	tv.tv_usec = (timeout%1000)*1000;
+
+	int result = select(
+		highest_fd+1,
+		&amp;rfds,
+		NULL,
+		NULL,
+		(timeout == -1) ? NULL : &amp;tv);
+
+	if (result &lt;= 0) return false;
+	return true;
+}

Added: trunk/clanlib/Core/System/Unix/event_listener_unix.h
===================================================================
--- trunk/clanlib/Core/System/Unix/event_listener_unix.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Unix/event_listener_unix.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,54 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_event_listener_unix
+#define header_event_listener_unix
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;Core/System/Generic/event_listener_generic.h&quot;
+
+class CL_EventListener_Unix : public CL_EventListener_Generic
+{
+//! Construction:
+public:
+	CL_EventListener_Unix(CL_EventListener *owner);
+
+	virtual ~CL_EventListener_Unix();
+
+//! Implementation:
+private:
+	//: Wait until one of the events triggers. The timeout is in milliseconds.
+	//return: true if a event triggered, false if it timed out.
+	virtual bool wait(int timeout);
+};
+
+#endif

Added: trunk/clanlib/Core/System/Unix/event_trigger_unix.cpp
===================================================================
--- trunk/clanlib/Core/System/Unix/event_trigger_unix.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Unix/event_trigger_unix.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,92 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;event_trigger_unix.h&quot;
+
+// note: this cannot be replaced by &lt;ctime&gt;! (timeval needs to be defined)
+#include &lt;sys/time.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;unistd.h&gt;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventTrigger_Unix construction:
+
+CL_EventTrigger_Unix::CL_EventTrigger_Unix()
+{
+	pipe(wait_pipe);
+}
+
+CL_EventTrigger_Unix::~CL_EventTrigger_Unix()
+{
+	close(wait_pipe[0]);
+	close(wait_pipe[1]);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventTrigger_Unix attributes:
+
+bool CL_EventTrigger_Unix::get_flag() const
+{
+	return wait(0);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventTrigger_Unix operations:
+
+void CL_EventTrigger_Unix::reset() const
+{
+	char v = 0;
+	while (wait(0)) read(wait_pipe[0], &amp;v, 1);
+}
+
+void CL_EventTrigger_Unix::set_flag()
+{
+	char v = 1;
+	if (!wait(0)) write(wait_pipe[1], &amp;v, 1);
+}
+
+bool CL_EventTrigger_Unix::wait(int timeout) const
+{
+	fd_set rfds;
+	FD_ZERO(&amp;rfds);
+	FD_SET(wait_pipe[0], &amp;rfds);
+
+	timeval tv;
+	tv.tv_sec = timeout/1000;
+	tv.tv_usec = (timeout%1000)*1000;
+
+	int result = select(wait_pipe[0]+1, &amp;rfds, NULL, NULL, (timeout == -1) ? NULL : &amp;tv);
+	if (result &lt;= 0) return false;
+
+	return true;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventTrigger_Unix implementation:

Added: trunk/clanlib/Core/System/Unix/event_trigger_unix.h
===================================================================
--- trunk/clanlib/Core/System/Unix/event_trigger_unix.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Unix/event_trigger_unix.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,69 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_event_trigger_unix
+#define header_event_trigger_unix
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Generic/event_trigger_generic.h&quot;
+
+class CL_EventTrigger_Unix : public CL_EventTrigger_Generic
+{
+//! Construction:
+public:
+	CL_EventTrigger_Unix();
+
+	virtual ~CL_EventTrigger_Unix();
+
+//! Attributes:
+public:
+	virtual bool get_flag() const;
+
+//! Operations:
+public:
+	//: Reset trigger flag.
+	virtual void reset() const;
+
+	//: Raise trigger flag.
+	virtual void set_flag();
+
+	//: Wait until one of the event triggers. The timeout is in milliseconds.
+	//return: true if the event triggered, false if it timed out.
+	virtual bool wait(int timeout = -1) const;
+
+//! Implementation:
+public:
+	// Waiting pipe.
+	int wait_pipe[2];
+};
+
+#endif

Added: trunk/clanlib/Core/System/Unix/implementation.h
===================================================================
--- trunk/clanlib/Core/System/Unix/implementation.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Unix/implementation.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,47 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef __IMPLEMENTATION_H__
+#define __IMPLEMENTATION_H__
+
+#ifdef USE_DYN
+#define DL_PREFIX
+#else
+#define DL_PREFIX static
+#endif
+
+typedef char* (*clan_id_proc)();
+typedef void (*clan_init_proc)();
+
+#endif
+
+
+
+
+

Added: trunk/clanlib/Core/System/Unix/init_linux.cpp
===================================================================
--- trunk/clanlib/Core/System/Unix/init_linux.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Unix/init_linux.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,135 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+
+#include &lt;libgen.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;dlfcn.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;dirent.h&gt;
+#include &lt;signal.h&gt;
+#include &lt;cassert&gt;
+#include &lt;cstdio&gt;
+#include &lt;cstdlib&gt;
+#include &quot;implementation.h&quot;
+#include &quot;init_linux.h&quot;
+// note: this cannot be replaced by &lt;ctime&gt;! (timeval needs to be defined)
+#include &lt;sys/time.h&gt;
+#include &quot;API/Core/System/setupcore.h&quot;
+#include &quot;API/Core/System/system.h&quot;
+
+#ifdef __APPLE__
+#include &lt;CoreFoundation/CoreFoundation.h&gt;
+#endif
+
+static int init_ref_count = 0;
+long _begin_time;
+
+void init_system()
+{
+	init_ref_count++;
+	if (init_ref_count &gt; 1) return;
+
+	timeval tv;
+	gettimeofday(&amp;tv, NULL);
+	_begin_time = (long) tv.tv_sec*(long) 1000+(long) tv.tv_usec/(long) 1000;
+
+	#ifdef NDEBUG
+	signal(SIGSEGV, deinit);
+	#endif
+}
+
+void deinit_system()
+{
+	init_ref_count--;
+	if (init_ref_count &gt; 0) return;
+
+	#ifdef NDEBUG
+	signal(SIGSEGV,SIG_DFL); //restore default behavior
+	#endif
+}
+
+unsigned int CL_System::sys_time()
+{
+	timeval tv;
+	gettimeofday(&amp;tv, NULL);
+
+	return (long) tv.tv_sec*(long) 1000 + (long) tv.tv_usec/(long) 1000 - _begin_time;
+}
+
+void CL_System::sleep(int millis)
+{
+	timeval tv;
+	tv.tv_sec = millis/1000;
+	tv.tv_usec = (millis%1000)*1000;
+	select(0, 0, 0, 0, &amp;tv);
+}
+
+std::string CL_System::get_exe_path()
+{
+	char exe_file[PATH_MAX + 1];
+#ifdef __APPLE__
+	CFBundleRef mainBundle = CFBundleGetMainBundle();
+	if (mainBundle) 
+	{
+		CFURLRef mainURL = CFBundleCopyBundleURL(mainBundle);
+		
+		if (mainURL) 
+		{
+			int ok = CFURLGetFileSystemRepresentation (
+				mainURL, (Boolean) true, (UInt8*)exe_file, PATH_MAX 
+			);
+			
+			if (ok)
+			{
+				return std::string(exe_file) + &quot;/&quot;;
+			}
+		}
+	}
+	
+	throw CL_Error(&quot;get_exe_path failed&quot;);	
+
+#else
+	int size;
+	size = readlink(&quot;/proc/self/exe&quot;, exe_file, PATH_MAX);
+	if (size &lt; 0)
+	{
+		throw CL_Error(strerror(errno));
+	}
+	else
+	{
+		exe_file[size] = '\0';
+		return std::string(dirname(exe_file)) + &quot;/&quot;;
+	}
+#endif
+	
+}
+
+/* EOF */

Added: trunk/clanlib/Core/System/Unix/init_linux.h
===================================================================
--- trunk/clanlib/Core/System/Unix/init_linux.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Unix/init_linux.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,44 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_init_linux
+#define header_init_linux
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+
+class CL_System_Unix
+{
+public:
+};
+
+#endif

Added: trunk/clanlib/Core/System/Unix/mutex_pthread.cpp
===================================================================
--- trunk/clanlib/Core/System/Unix/mutex_pthread.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Unix/mutex_pthread.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,125 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef __USE_UNIX98
+	#define __USE_UNIX98
+#endif  
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/System/cl_assert.h&quot;
+#include &lt;pthread.h&gt;
+#include &quot;mutex_pthread.h&quot;
+
+// We need to do this because the posix threads library under linux obviously
+// suck:
+extern &quot;C&quot;
+{
+#ifdef __FreeBSD__
+	int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int kind);
+#else
+	int pthread_mutexattr_setkind_np(pthread_mutexattr_t *attr, int kind);
+#endif
+}
+
+CL_Mutex *CL_Mutex::create()
+{
+	return new CL_Mutex;
+}
+////////////////////////////////////////////////////////////////////////////////
+// CL_Mutex Posix implementation
+
+CL_Mutex::CL_Mutex()
+: impl(new CL_Mutex_Generic)
+{
+	pthread_mutexattr_t attr;
+	pthread_mutexattr_init(&amp;attr);
+
+#ifdef __APPLE__
+	pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE );
+#else
+#ifdef __FreeBSD__
+        pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);
+#else
+#if PTHREAD_MUTEX_RECURSIVE_NP
+// cygwin
+	pthread_mutexattr_setkind_np(&amp;attr, PTHREAD_MUTEX_RECURSIVE);
+#else
+	pthread_mutexattr_setkind_np(&amp;attr, PTHREAD_MUTEX_RECURSIVE_NP);
+#endif
+#endif
+#endif
+	pthread_mutex_init(&amp;impl-&gt;mutex, &amp;attr);
+	pthread_mutexattr_destroy(&amp;attr);
+
+	pthread_cond_init(&amp;impl-&gt;cond,0);
+}
+
+CL_Mutex::CL_Mutex(const CL_Mutex &amp;copy)
+{
+	cl_assert(false);
+}
+
+void CL_Mutex::operator=(const CL_Mutex &amp;copy)
+{
+	cl_assert(false);
+}
+
+CL_Mutex::~CL_Mutex()
+{
+	pthread_mutex_destroy(&amp;impl-&gt;mutex);
+	pthread_cond_destroy(&amp;impl-&gt;cond);
+	delete impl;
+}
+	
+void CL_Mutex::enter()
+{
+	pthread_mutex_lock(&amp;impl-&gt;mutex);
+}
+
+void CL_Mutex::leave()
+{
+	pthread_mutex_unlock(&amp;impl-&gt;mutex);
+}
+
+
+void CL_Mutex::wait()
+{
+	pthread_cond_wait(&amp;impl-&gt;cond,&amp;impl-&gt;mutex);
+}
+
+
+void CL_Mutex::notify()
+{
+	pthread_cond_signal(&amp;impl-&gt;cond);
+}
+
+void CL_Mutex::notify_all()
+{
+	pthread_cond_broadcast(&amp;impl-&gt;cond);
+}

Added: trunk/clanlib/Core/System/Unix/mutex_pthread.h
===================================================================
--- trunk/clanlib/Core/System/Unix/mutex_pthread.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Unix/mutex_pthread.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,46 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_mutex_pthread
+#define header_mutex_pthread
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/System/mutex.h&quot;
+
+class CL_Mutex_Generic
+{
+public:
+	pthread_mutex_t mutex;
+	pthread_cond_t cond;
+};
+
+#endif

Added: trunk/clanlib/Core/System/Unix/thread_pthread.cpp
===================================================================
--- trunk/clanlib/Core/System/Unix/thread_pthread.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Unix/thread_pthread.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,234 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+
+#include &lt;pthread.h&gt;
+#include &quot;API/Core/System/cl_assert.h&quot;
+#include &quot;API/Core/System/log.h&quot;
+#include &quot;thread_pthread.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Thread_Helper unix implementation:
+
+class CL_Thread_Helper : public CL_Runnable
+{
+public:
+	CL_Thread_Helper(int (*func)(void*), void *value)
+		: func(func), value(value)
+	{
+	}
+
+	virtual void run()
+	{
+		func(value);
+	}
+
+private:
+	int (*func)(void*);
+
+	void *value;
+};
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Thread unix/pthread implementation:
+
+CL_Thread::CL_Thread(int (*func)(void*), void *value)
+: impl(new CL_Thread_Generic)
+{
+	impl-&gt;ref_count = 1;
+	impl-&gt;runnable = new CL_Thread_Helper(func, value);
+	impl-&gt;delete_runnable = true;
+	impl-&gt;running = false;
+}
+
+CL_Thread::CL_Thread(CL_Runnable *runnable, bool delete_runnable)
+: impl(new CL_Thread_Generic)
+{
+	impl-&gt;ref_count = 1;
+	impl-&gt;runnable = runnable;
+	impl-&gt;delete_runnable = delete_runnable;
+	impl-&gt;running = false;
+}
+
+CL_Thread::CL_Thread(const CL_Thread &amp;copy)
+: impl(copy.impl)
+{
+	if (impl) impl-&gt;ref_count++;
+}
+
+CL_Thread::CL_Thread()
+: impl(0)
+{
+}
+
+CL_Thread::~CL_Thread()
+{
+	if (impl)
+	{
+		impl-&gt;ref_count--;
+		if (impl-&gt;ref_count == 0)
+		{
+			terminate();
+			if (impl-&gt;delete_runnable) delete impl-&gt;runnable;
+			delete impl;
+		}
+	}
+}
+
+CL_Thread &amp;CL_Thread::operator =(const CL_Thread &amp;copy)
+{
+	if (impl)
+	{
+		impl-&gt;ref_count--;
+		if (impl-&gt;ref_count == 0)
+		{
+			terminate();
+			if (impl-&gt;delete_runnable) delete impl-&gt;runnable;
+			delete impl;
+		}
+	}
+
+	impl = copy.impl;
+	if (impl) impl-&gt;ref_count++;
+	return *this;
+}
+
+void CL_Thread::start()
+{
+	if (impl-&gt;running) return;
+
+	cl_assert(
+		pthread_create(
+			&amp;impl-&gt;thread,
+			NULL,
+			impl-&gt;run_init,
+			impl)==0);
+
+	impl-&gt;running = true;
+}
+
+void *CL_Thread_Generic::run_init(void *_self)
+{
+	CL_Thread_Generic *self = (CL_Thread_Generic *) _self;
+
+	// kill thread immidiately - no cancelation point...
+	pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
+
+	self-&gt;runnable-&gt;run();
+	return NULL;
+}
+
+void CL_Thread::terminate()
+{
+	if (impl-&gt;running) pthread_cancel(impl-&gt;thread);
+	impl-&gt;running = false;
+}
+
+void CL_Thread::wait()
+{
+	if (impl-&gt;running) pthread_join(impl-&gt;thread, NULL);
+	impl-&gt;running = false;
+}
+
+void CL_Thread::set_priority(EThreadPriority priority)
+{
+#ifdef __APPLE__
+	struct sched_param param;
+	memset(&amp;param, 0, sizeof(struct sched_param));
+
+	// on macosx the valid values for thread priority are 0-127
+	// may be different on other posix systems - unknown.
+	switch (priority)
+	{
+	case cl_priority_above_normal:	param.sched_priority = 50;	break;
+	case cl_priority_below_normal:	param.sched_priority = 15;	break;
+	case cl_priority_highest:		param.sched_priority = 100;	break;
+	case cl_priority_idle:			param.sched_priority = 5;	break;
+	case cl_priority_lowest:		param.sched_priority = 0;	break;
+	case cl_priority_time_critical:	param.sched_priority = 127;	break;
+	case cl_priority_normal:
+	default:						param.sched_priority = 31;	break;
+	}
+	
+	int i = pthread_setschedparam(impl-&gt;thread, SCHED_RR, &amp;param);
+	if (i != 0)
+		throw CL_Error(CL_String::format(&quot;Failed to set thread priority (error %1)&quot;,i));
+#endif
+	// Linux doesn't let your set proirities real time due to its renice model
+}
+
+CL_ThreadId CL_Thread::get_current_id()
+{
+	return CL_ThreadId();
+}
+
+CL_ThreadId::CL_ThreadId()
+:impl(new CL_ThreadId_Generic)
+{
+	impl-&gt;thread_id = pthread_self();
+}
+
+CL_ThreadId::CL_ThreadId(const CL_ThreadId &amp;copy)
+:impl(new CL_ThreadId_Generic)
+{
+	*this = copy;
+}
+
+CL_ThreadId::~CL_ThreadId()
+{
+	delete impl;
+}
+
+CL_ThreadId &amp;CL_ThreadId::operator=(const CL_ThreadId &amp;copy)
+{
+	// I think this is safe to do, but I'm not certain at this point
+	impl-&gt;thread_id = copy.impl-&gt;thread_id;
+	return *this;
+}
+
+bool CL_ThreadId::operator ==(const CL_ThreadId &amp;cmp) const
+{
+	return pthread_equal(impl-&gt;thread_id, cmp.impl-&gt;thread_id);
+}
+
+bool CL_ThreadId::operator !=(const CL_ThreadId &amp;cmp) const
+{
+	return !operator ==(cmp);
+}
+
+bool CL_ThreadId::operator &lt;(const CL_ThreadId &amp;cmp) const
+{
+	// first test with operator== because different pthread_t values from the same
+	// thread may not be binary equal to each other - this routine is probably not
+	// the best but it should get the job done for now
+	if (operator ==(cmp)) return false;
+	return memcmp(&amp;impl-&gt;thread_id, &amp;cmp.impl-&gt;thread_id, sizeof(pthread_t)) &lt; 0;
+}

Added: trunk/clanlib/Core/System/Unix/thread_pthread.h
===================================================================
--- trunk/clanlib/Core/System/Unix/thread_pthread.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Unix/thread_pthread.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,57 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_thread_pthread
+#define header_thread_pthread
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/System/thread.h&quot;
+
+class CL_Thread_Generic
+{
+public:
+	CL_Runnable *runnable;
+	pthread_t thread;
+	bool running;
+	bool delete_runnable;
+	int ref_count;
+
+	static void *run_init(void *self);
+};
+
+class CL_ThreadId_Generic
+{
+public:
+	pthread_t thread_id;
+};
+
+#endif

Added: trunk/clanlib/Core/System/Win32/cl_library.cpp
===================================================================
--- trunk/clanlib/Core/System/Win32/cl_library.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Win32/cl_library.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,166 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/System/cl_library.h&quot;
+
+std::map&lt;std::string, CL_LibraryFactoryMaker *, std::less&lt;std::string&gt; &gt; CL_LibraryManager::libraries;
+
+CL_LibraryLoader::CL_LibraryLoader(const std::string&amp; file) : filename(file), loaded(false), handle(0), last_error(0)
+{
+	if(filename.rfind(&quot;.dll&quot;,filename.size()) == -1)
+	{
+		filename.append(&quot;.dll&quot;);
+	}
+}
+
+CL_LibraryLoader::~CL_LibraryLoader()
+{
+	// Don't forget to unload the library if needed
+	if((loaded == true) &amp;&amp; (handle != 0))
+		unload();
+}
+
+std::string CL_LibraryLoader::name() const
+{
+	return filename;
+}
+
+bool CL_LibraryLoader::is_loaded() const
+{
+	return loaded;
+}
+
+void *CL_LibraryLoader::resolve(const std::string&amp; symbol)
+{
+	// Just in case the handle has been corrupted
+	if(handle == 0)
+		return 0;
+
+	// Lookup the symbol name
+	void *adr = (void *) GetProcAddress(handle,symbol.c_str());
+
+	if(adr == 0)
+	{
+		if(last_error != 0)
+			delete last_error;
+		last_error = new CL_Error(std::string(&quot;Couldn't find &quot; + symbol + &quot; within &quot; + filename));
+		return 0;
+	}
+	
+	return adr;
+}
+
+bool CL_LibraryLoader::load()
+{
+	handle = LoadLibrary(filename.c_str());
+	if(handle == 0)
+	{
+		if(last_error != 0)
+			delete last_error;
+		last_error = new CL_Error(std::string(&quot;Couldn't load &quot; + filename));
+		loaded = false;
+	}
+	else
+	{
+		loaded = true;
+	}
+
+	return loaded;
+}
+
+bool CL_LibraryLoader::unload()
+{
+	if(last_error != 0)
+	{
+		delete last_error;
+		last_error = 0;
+	}
+
+	// Well if the handle is already NULL, don't need to unload it again
+	if(handle == 0)
+		return true;
+	
+	if(FreeLibrary(handle) == 0)
+	{
+		last_error = new CL_Error(std::string(&quot;Couldn't unload &quot; + filename));
+		return false;
+	}
+
+	handle = 0;
+	loaded = false;
+
+	return true;
+}
+
+CL_Error *CL_LibraryLoader::get_last_error() const
+{
+	if(last_error == 0)
+		return new CL_Error(&quot;No CL_Library has been set&quot;);
+	return last_error;
+}
+
+CL_LibraryFactoryMaker_t CL_LibraryManager::get(const std::string&amp; lib_name)
+{
+	std::map&lt;std::string, CL_LibraryFactoryMaker *, std::less&lt;std::string&gt; &gt;::iterator libs_itr;
+	CL_LibraryFactoryMaker_t lib;
+	bool found = true;
+
+	if((libs_itr = libraries.find(lib_name)) != libraries.end())
+	{
+		lib = (*libs_itr).second;
+	}
+	else
+	{
+		found = false;
+	}
+
+	if(found == false)
+		return 0;
+
+	return lib;
+}
+
+void CL_LibraryManager::add(const std::string&amp; lib_name,CL_LibraryFactoryMaker *lib)
+{
+	libraries[lib_name] = lib;
+}
+
+void CL_LibraryManager::remove(const std::string&amp; lib_name)
+{
+	if(libraries.find(lib_name) != libraries.end())
+		libraries.erase(lib_name);
+}
+
+bool CL_LibraryManager::has(const std::string&amp; lib_name)
+{
+	if(libraries.find(lib_name) != libraries.end())
+		return true;
+	return false;
+}

Added: trunk/clanlib/Core/System/Win32/crash_reporter_win32.cpp
===================================================================
--- trunk/clanlib/Core/System/Win32/crash_reporter_win32.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Win32/crash_reporter_win32.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,830 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/System/crash_reporter.h&quot;
+#include &quot;API/Core/System/log.h&quot;
+#include &quot;crash_reporter_win32.h&quot;
+
+#ifdef _MSC_VER
+#pragma warning (disable:4535)
+#endif
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_CrashReporter_Win32 Construction:
+
+CL_CrashReporter_Win32::CL_CrashReporter_Win32()
+{
+#ifdef HAS_PDB_SUPPORT
+	if (moduleImagehlp == 0)
+	{
+		moduleImagehlp = LoadLibrary( &quot;imagehlp.dll&quot; );
+		if ( moduleImagehlp == 0 )
+		{
+			CL_Log::log(&quot;debug&quot;, &quot;Unable to load imagehlp.dll. Crash reporter disabled.&quot;);
+			return;
+		}
+
+		ptrSymCleanup = (TypeSymCleanup) GetProcAddress( moduleImagehlp, &quot;SymCleanup&quot; );
+		ptrSymFunctionTableAccess = (TypeSymFunctionTableAccess) GetProcAddress( moduleImagehlp, &quot;SymFunctionTableAccess&quot; );
+		ptrSymGetLineFromAddr = (TypeSymGetLineFromAddr) GetProcAddress( moduleImagehlp, &quot;SymGetLineFromAddr&quot; );
+		ptrSymGetModuleBase = (TypeSymGetModuleBase) GetProcAddress( moduleImagehlp, &quot;SymGetModuleBase&quot; );
+		ptrSymGetModuleInfo = (TypeSymGetModuleInfo) GetProcAddress( moduleImagehlp, &quot;SymGetModuleInfo&quot; );
+		ptrSymGetOptions = (TypeSymGetOptions) GetProcAddress( moduleImagehlp, &quot;SymGetOptions&quot; );
+		ptrSymGetSymFromAddr = (TypeSymGetSymFromAddr) GetProcAddress( moduleImagehlp, &quot;SymGetSymFromAddr&quot; );
+		ptrSymInitialize = (TypeSymInitialize) GetProcAddress( moduleImagehlp, &quot;SymInitialize&quot; );
+		ptrSymSetOptions = (TypeSymSetOptions) GetProcAddress( moduleImagehlp, &quot;SymSetOptions&quot; );
+		ptrStackWalk = (TypeStackWalk) GetProcAddress( moduleImagehlp, &quot;StackWalk&quot; );
+		ptrUnDecorateSymbolName = (TypeUnDecorateSymbolName) GetProcAddress( moduleImagehlp, &quot;UnDecorateSymbolName&quot; );
+		ptrSymLoadModule = (TypeSymLoadModule) GetProcAddress( moduleImagehlp, &quot;SymLoadModule&quot; );
+
+		if (
+			ptrSymCleanup == 0 ||
+			ptrSymFunctionTableAccess == 0 ||
+			ptrSymGetLineFromAddr == 0 ||
+			ptrSymGetModuleBase == 0 ||
+			ptrSymGetModuleInfo == 0 ||
+			ptrSymGetOptions == 0 ||
+			ptrSymGetSymFromAddr == 0 ||
+			ptrSymInitialize == 0 ||
+			ptrSymSetOptions == 0 ||
+			ptrStackWalk == 0 ||
+			ptrUnDecorateSymbolName == 0 ||
+			ptrSymLoadModule == 0)
+		{
+			CL_Log::log(&quot;debug&quot;, &quot;Unable to find all symbols in imagehlp.dll. Crash reporter disabled.&quot;);
+			FreeLibrary( moduleImagehlp );
+			moduleImagehlp = 0;
+			return;
+		}
+
+		// Setup search path for pdb (symbol information) files:
+
+		#define TTBUFLEN 65536 // for a temp buffer
+		char tt[TTBUFLEN];
+
+		if ( GetCurrentDirectoryA( TTBUFLEN, tt ) )
+			userSearchPath += tt + std::string( &quot;;&quot; );
+		// dir with executable
+		if ( GetModuleFileNameA( 0, tt, TTBUFLEN ) )
+		{
+			char *p;
+			for ( p = tt + strlen( tt ) - 1; p &gt;= tt; -- p )
+			{
+				// locate the rightmost path separator
+				if ( *p == '\\' || *p == '/' || *p == ':' )
+					break;
+			}
+			// if we found one, p is pointing at it; if not, tt only contains
+			// an exe name (no path), and p points before its first byte
+			if ( p != tt ) // path sep found?
+			{
+				if ( *p == ':' ) // we leave colons in place
+					++ p;
+				*p = '\0'; // eliminate the exe name and last path sep
+				userSearchPath += tt + std::string( &quot;;&quot; );
+			}
+		}
+		// environment variable _NT_SYMBOL_PATH
+		if ( GetEnvironmentVariableA( &quot;_NT_SYMBOL_PATH&quot;, tt, TTBUFLEN ) )
+			userSearchPath += tt + std::string( &quot;;&quot; );
+		// environment variable _NT_ALTERNATE_SYMBOL_PATH
+		if ( GetEnvironmentVariableA( &quot;_NT_ALTERNATE_SYMBOL_PATH&quot;, tt, TTBUFLEN ) )
+			userSearchPath += tt + std::string( &quot;;&quot; );
+		// environment variable SYSTEMROOT
+		if ( GetEnvironmentVariableA( &quot;SYSTEMROOT&quot;, tt, TTBUFLEN ) )
+			userSearchPath += tt + std::string( &quot;;&quot; );
+
+		if ( userSearchPath.size() &gt; 0 ) // if we added anything, we have a trailing semicolon
+			userSearchPath = userSearchPath.substr( 0, userSearchPath.size() - 1 );
+	}
+	
+	if (moduleDbghlp == 0)
+	{
+		moduleDbghlp = LoadLibrary( &quot;dbghelp.dll&quot; );
+		if ( moduleDbghlp == 0 )
+		{
+			CL_Log::log(&quot;debug&quot;, &quot;Unable to load dbghlp.dll. Crash reporter disabled.&quot;);
+			return;
+		}
+
+		ptrMiniDumpWriteDump = (TypeMiniDumpWriteDump) GetProcAddress( moduleDbghlp, &quot;MiniDumpWriteDump&quot; );
+
+		if (ptrMiniDumpWriteDump == 0)
+		{
+			CL_Log::log(&quot;debug&quot;, &quot;Unable to find all symbols in dbghlp.dll. Crash reporter disabled.&quot;);
+			FreeLibrary( moduleDbghlp );
+			moduleDbghlp = 0;
+			return;
+		}
+	}
+
+#ifdef HAS_SE_TRANSLATOR
+	ptrOldFilter = _set_se_translator(&amp;CL_CrashReporter_Win32::unhandledExceptionFilter);
+#else
+	ptrOldFilter = SetUnhandledExceptionFilter(&amp;CL_CrashReporter_Win32::unhandledExceptionFilter);
+#endif
+
+#endif
+}
+
+CL_CrashReporter_Win32::~CL_CrashReporter_Win32()
+{
+#ifdef HAS_PDB_SUPPORT
+#ifdef HAS_SE_TRANSLATOR
+	_set_se_translator(ptrOldFilter);
+#else
+	// Dont do this since exception filter seem to be on process level and not thread level:
+	// ptrOldFilter = SetUnhandledExceptionFilter(ptrOldFilter);
+#endif
+#endif
+
+//	if (moduleImagehlp == 0) return;
+//	FreeLibrary( moduleImagehlp );
+//	moduleImagehlp = 0;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CrashReporter Implementation:
+
+#ifdef HAS_PDB_SUPPORT
+
+struct DumpParams
+{
+	HANDLE hProcess;
+	HANDLE hThread;
+	int threadId;
+	PEXCEPTION_POINTERS exceptionInfo;
+	unsigned int exceptionCode;
+};
+
+#ifdef HAS_SE_TRANSLATOR
+void CL_CrashReporter_Win32::unhandledExceptionFilter(unsigned int exceptionCode, PEXCEPTION_POINTERS exceptionInfo)
+#else
+LONG CL_CrashReporter_Win32::unhandledExceptionFilter(PEXCEPTION_POINTERS exceptionInfo)
+#endif
+{
+#ifndef HAS_SE_TRANSLATOR
+	unsigned int exceptionCode = GetExceptionCode();
+#endif
+
+	// Ignore those bloody breakpoints!
+	if (exceptionCode == EXCEPTION_BREAKPOINT) return;
+
+	DumpParams dumpParams;
+	dumpParams.hProcess = GetCurrentProcess();
+	dumpParams.hThread = GetCurrentThread();
+	dumpParams.threadId = GetCurrentThreadId();
+	dumpParams.exceptionInfo = exceptionInfo;
+	dumpParams.exceptionCode = exceptionCode;
+
+	DWORD threadId;
+	HANDLE hThread = CreateThread(0, 0, &amp;CL_CrashReporter_Win32::dumpStack, &amp;dumpParams, 0, &amp;threadId);
+	WaitForSingleObject(hThread, INFINITE);
+
+//	if (ptrOldFilter) ptrOldFilter(exceptionCode, exceptionInfo);
+	abort();
+#ifndef HAS_SE_TRANSLATOR
+	return EXCEPTION_CONTINUE_SEARCH;
+#endif
+}
+
+DWORD WINAPI CL_CrashReporter_Win32::dumpStack(LPVOID lpThreadParameter)
+{
+	DumpParams *dumpParams = (DumpParams *) lpThreadParameter;
+	HANDLE hProcess = dumpParams-&gt;hProcess;
+	HANDLE hThread = dumpParams-&gt;hThread;
+	PEXCEPTION_POINTERS exceptionInfo = dumpParams-&gt;exceptionInfo;
+
+	// Get path to executable:
+	TCHAR szDllName[_MAX_PATH];
+	TCHAR szDrive[_MAX_DRIVE];
+	TCHAR szDir[_MAX_DIR];
+	TCHAR szFilename[256];
+	TCHAR szExt[256];
+
+	GetModuleFileName(0, szDllName, _MAX_PATH);
+	_splitpath(szDllName, szDrive, szDir, szFilename, szExt);
+
+	TCHAR fileName[1024];
+
+	// Produce minidump file:
+	_snprintf(fileName, 1024, &quot;%s%scoredump-%d.dmp&quot;, szDrive, szDir, dumpParams-&gt;threadId);
+	HANDLE hFile = CreateFile(
+		fileName,
+		GENERIC_WRITE, FILE_SHARE_READ, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
+
+	MINIDUMP_EXCEPTION_INFORMATION exInfo;
+
+	exInfo.ThreadId = dumpParams-&gt;threadId;
+	exInfo.ExceptionPointers = exceptionInfo;
+	exInfo.ClientPointers = 0;
+
+	ptrMiniDumpWriteDump( GetCurrentProcess(), GetCurrentProcessId(), hFile, MiniDumpNormal, &amp;exInfo, 0, 0);
+
+	CloseHandle(hFile);
+
+	// why oh why does SymInitialize() want a writeable string?
+	char tt[TTBUFLEN];
+	strncpy( tt, userSearchPath.c_str(), TTBUFLEN );
+	tt[TTBUFLEN - 1] = '\0'; // if strncpy() overruns, it doesn't add the null terminator
+
+	ptrSymInitialize(hProcess, tt, FALSE);
+
+	DWORD symOptions;
+	symOptions = ptrSymGetOptions();
+	symOptions |= SYMOPT_LOAD_LINES;
+	symOptions &amp;= ~SYMOPT_UNDNAME;
+	ptrSymSetOptions( symOptions );
+
+	#define MAXNAMELEN 1024 // max name length for found symbols
+	#define IMGSYMLEN ( sizeof IMAGEHLP_SYMBOL )
+
+	IMAGEHLP_SYMBOL *pSym = (IMAGEHLP_SYMBOL *) malloc( IMGSYMLEN + MAXNAMELEN );
+	char undName[MAXNAMELEN]; // undecorated name
+	char undFullName[MAXNAMELEN]; // undecorated name with all shenanigans
+	IMAGEHLP_MODULE Module;
+	IMAGEHLP_LINE Line;
+
+	memset( pSym, '\0', IMGSYMLEN + MAXNAMELEN );
+	pSym-&gt;SizeOfStruct = IMGSYMLEN;
+	pSym-&gt;MaxNameLength = MAXNAMELEN;
+
+	memset( &amp;Line, '\0', sizeof Line );
+	Line.SizeOfStruct = sizeof Line;
+
+	memset( &amp;Module, '\0', sizeof Module );
+	Module.SizeOfStruct = sizeof Module;
+
+	DWORD offsetFromSymbol; // tells us how far from the symbol we were
+	offsetFromSymbol = 0;
+
+	// Enumerate modules and tell imagehlp.dll about them.
+	enumAndLoadModuleSymbols( hProcess, GetCurrentProcessId() );
+
+	STACKFRAME stackframe; // in/out stackframe
+	memset( &amp;stackframe, 0, sizeof(stackframe) );
+	stackframe.AddrPC.Offset = exceptionInfo-&gt;ContextRecord-&gt;Eip;
+	stackframe.AddrPC.Mode = AddrModeFlat;
+	stackframe.AddrFrame.Offset = exceptionInfo-&gt;ContextRecord-&gt;Ebp;
+	stackframe.AddrFrame.Mode = AddrModeFlat;
+
+	// normally, call ImageNtHeader() and use machine info from PE header
+	DWORD imageType = IMAGE_FILE_MACHINE_I386;
+
+	_snprintf(fileName, 1024, &quot;%s%scoredump-%d.txt&quot;, szDrive, szDir, dumpParams-&gt;threadId);
+
+	hFile = CreateFile(
+		fileName,
+		GENERIC_WRITE, FILE_SHARE_READ, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
+
+	char stringBuffer[1024];
+	DWORD bytesWritten;
+
+	char *exceptionStr = &quot;Unknown exception.&quot;;
+	switch (dumpParams-&gt;exceptionCode)
+	{
+	case EXCEPTION_ACCESS_VIOLATION:
+		exceptionStr = &quot;EXCEPTION_ACCESS_VIOLATION, The thread attempted to read from or write to a virtual address for which it does not have the appropriate access.&quot;;
+		break;
+
+	case EXCEPTION_BREAKPOINT:
+		exceptionStr = &quot;EXCEPTION_BREAKPOINT, A breakpoint was encountered.&quot;;
+		break;
+
+	case EXCEPTION_DATATYPE_MISALIGNMENT:
+		exceptionStr = &quot;EXCEPTION_DATATYPE_MISALIGNMENT, The thread attempted to read or write data that is misaligned on hardware that does not provide alignment.&quot;;
+		break;
+
+	case EXCEPTION_SINGLE_STEP:
+		exceptionStr = &quot;EXCEPTION_SINGLE_STEP, A trace trap or other single-instruction mechanism signaled that one instruction has been executed.&quot;;
+		break;
+
+	case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
+		exceptionStr = &quot;EXCEPTION_ARRAY_BOUNDS_EXCEEDED, The thread attempted to access an array element that is out of bounds, and the underlying hardware supports bounds checking.&quot;;
+		break;
+
+	case EXCEPTION_FLT_DENORMAL_OPERAND:
+		exceptionStr = &quot;EXCEPTION_FLT_DENORMAL_OPERAND, One of the operands in a floating-point operation is denormal.&quot;;
+		break;
+
+	case EXCEPTION_FLT_DIVIDE_BY_ZERO:
+		exceptionStr = &quot;EXCEPTION_FLT_DIVIDE_BY_ZERO, The thread attempted to divide a floating-point value by a floating-point divisor of zero.&quot;;
+		break;
+
+	case EXCEPTION_FLT_INEXACT_RESULT:
+		exceptionStr = &quot;EXCEPTION_FLT_INEXACT_RESULT, The result of a floating-point operation cannot be represented exactly as a decimal fraction.&quot;;
+		break;
+
+	case EXCEPTION_FLT_INVALID_OPERATION:
+		exceptionStr = &quot;EXCEPTION_FLT_INVALID_OPERATION, This exception represents any floating-point exception not included in this list.&quot;;
+		break;
+
+	case EXCEPTION_FLT_OVERFLOW:
+		exceptionStr = &quot;EXCEPTION_FLT_OVERFLOW, The exponent of a floating-point operation is greater than the magnitude allowed by the corresponding type.&quot;;
+		break;
+
+	case EXCEPTION_FLT_STACK_CHECK:
+		exceptionStr = &quot;EXCEPTION_FLT_STACK_CHECK, The stack overflowed or underflowed as the result of a floating-point operation.&quot;;
+		break;
+
+	case EXCEPTION_FLT_UNDERFLOW:
+		exceptionStr = &quot;EXCEPTION_FLT_UNDERFLOW, The exponent of a floating-point operation is less than the magnitude allowed by the corresponding type.&quot;;
+		break;
+
+	case EXCEPTION_INT_DIVIDE_BY_ZERO:
+		exceptionStr = &quot;EXCEPTION_INT_DIVIDE_BY_ZERO, The thread attempted to divide an integer value by an integer divisor of zero.&quot;;
+		break;
+
+	case EXCEPTION_INT_OVERFLOW:
+		exceptionStr = &quot;EXCEPTION_INT_OVERFLOW, The result of an integer operation caused a carry out of the most significant bit of the result.&quot;;
+		break;
+
+	case EXCEPTION_PRIV_INSTRUCTION:
+		exceptionStr = &quot;EXCEPTION_PRIV_INSTRUCTION, The thread attempted to execute an instruction whose operation is not allowed in the current machine mode.&quot;;
+		break;
+
+	case EXCEPTION_NONCONTINUABLE_EXCEPTION:
+		exceptionStr = &quot;EXCEPTION_NONCONTINUABLE_EXCEPTION, The thread attempted to continue execution after a noncontinuable exception occurred.&quot;;
+		break;
+	}
+
+	_snprintf(stringBuffer, 1024, &quot;Exception in thread %d: %s\r\n&quot;, dumpParams-&gt;threadId, exceptionStr);
+	WriteFile(hFile, stringBuffer, strlen(stringBuffer), &amp;bytesWritten, 0);
+
+	_snprintf(stringBuffer, 1024, &quot;-- Begin stack trace --\r\n&quot;);
+	WriteFile(hFile, stringBuffer, strlen(stringBuffer), &amp;bytesWritten, 0);
+
+	_snprintf(stringBuffer, 1024, &quot; Nr Flags PC       Return   Frame    Stack\r\n&quot;);
+	WriteFile(hFile, stringBuffer, strlen(stringBuffer), &amp;bytesWritten, 0);
+
+	int frameNum = 0;
+	while (true)
+	{
+		// if this returns ERROR_INVALID_ADDRESS (487) or ERROR_NOACCESS (998), you can
+		// assume that either you are done, or that the stack is so hosed that the next
+		// deeper frame could not be found.
+
+		if (!ptrStackWalk(
+				imageType,
+				hProcess,
+				hThread,
+				&amp;stackframe,
+				exceptionInfo-&gt;ContextRecord,
+				0,
+				ptrSymFunctionTableAccess,
+				ptrSymGetModuleBase,
+				0 ) )
+			break;
+
+		_snprintf(
+			stringBuffer,
+			1024,
+			&quot;%3d %c%c    %08lx %08lx %08lx %08lx &quot;,
+			frameNum,
+			stackframe.Far? 'F': '.',
+			stackframe.Virtual? 'V': '.',
+			stackframe.AddrPC.Offset,
+			stackframe.AddrReturn.Offset,
+			stackframe.AddrFrame.Offset,
+			stackframe.AddrStack.Offset );
+
+		WriteFile(hFile, stringBuffer, strlen(stringBuffer), &amp;bytesWritten, 0);
+
+		if ( stackframe.AddrPC.Offset == 0 )
+		{
+			_snprintf(stringBuffer, 1024, &quot;(-nosymbols- PC == 0)\r\n&quot; );
+			WriteFile(hFile, stringBuffer, strlen(stringBuffer), &amp;bytesWritten, 0);
+		}
+		else
+		{
+			// we seem to have a valid PC
+
+			// show procedure info (SymGetSymFromAddr())
+			if ( ! ptrSymGetSymFromAddr( hProcess, stackframe.AddrPC.Offset, &amp;offsetFromSymbol, pSym ) )
+			{
+				if ( GetLastError() != 487 )
+				{
+					_snprintf(stringBuffer, 1024, &quot;SymGetSymFromAddr(): gle = %lu\r\n&quot;, GetLastError() );
+					WriteFile(hFile, stringBuffer, strlen(stringBuffer), &amp;bytesWritten, 0);
+				}
+			}
+			else
+			{
+				// UnDecorateSymbolName()
+				ptrUnDecorateSymbolName( pSym-&gt;Name, undName, MAXNAMELEN, UNDNAME_NAME_ONLY );
+				ptrUnDecorateSymbolName( pSym-&gt;Name, undFullName, MAXNAMELEN, UNDNAME_COMPLETE );
+				_snprintf(stringBuffer, 1024, &quot;%s&quot;, undName );
+				WriteFile(hFile, stringBuffer, strlen(stringBuffer), &amp;bytesWritten, 0);
+				if ( offsetFromSymbol != 0 )
+				{
+					_snprintf(stringBuffer, 1024, &quot; %+ld bytes&quot;, (long) offsetFromSymbol );
+					WriteFile(hFile, stringBuffer, strlen(stringBuffer), &amp;bytesWritten, 0);
+				}
+				WriteFile(hFile, &quot;\r\n&quot;, 2, &amp;bytesWritten, 0 );
+				_snprintf(stringBuffer, 1024, &quot;    Sig:  %s\r\n&quot;, pSym-&gt;Name );
+				WriteFile(hFile, stringBuffer, strlen(stringBuffer), &amp;bytesWritten, 0);
+				_snprintf(stringBuffer, 1024, &quot;    Decl: %s\r\n&quot;, undFullName );
+				WriteFile(hFile, stringBuffer, strlen(stringBuffer), &amp;bytesWritten, 0);
+			}
+
+			// show line number info, NT5.0-method (SymGetLineFromAddr())
+			if ( ptrSymGetLineFromAddr != 0 )
+			{ // yes, we have SymGetLineFromAddr()
+				if ( ! ptrSymGetLineFromAddr( hProcess, stackframe.AddrPC.Offset, &amp;offsetFromSymbol, &amp;Line ) )
+				{
+					if ( GetLastError() != 487 )
+					{
+						_snprintf(stringBuffer, 1024, &quot;SymGetLineFromAddr(): gle = %lu\r\n&quot;, GetLastError() );
+						WriteFile(hFile, stringBuffer, strlen(stringBuffer), &amp;bytesWritten, 0);
+					}
+				}
+				else
+				{
+					_snprintf(stringBuffer, 1024, &quot;    Line: %s(%lu) %+ld bytes\r\n&quot;,
+						Line.FileName, Line.LineNumber, offsetFromSymbol );
+					WriteFile(hFile, stringBuffer, strlen(stringBuffer), &amp;bytesWritten, 0);
+				}
+			}
+
+			// show module info (SymGetModuleInfo())
+			if ( ! ptrSymGetModuleInfo( hProcess, stackframe.AddrPC.Offset, &amp;Module ) )
+			{
+				_snprintf(stringBuffer, 1024, &quot;SymGetModuleInfo): gle = %lu\r\n&quot;, GetLastError() );
+				WriteFile(hFile, stringBuffer, strlen(stringBuffer), &amp;bytesWritten, 0);
+			}
+			else
+			{ // got module info OK
+				char ty[80];
+				switch ( Module.SymType )
+				{
+				case SymNone:
+					strcpy( ty, &quot;-nosymbols-&quot; );
+					break;
+				case SymCoff:
+					strcpy( ty, &quot;COFF&quot; );
+					break;
+				case SymCv:
+					strcpy( ty, &quot;CV&quot; );
+					break;
+				case SymPdb:
+					strcpy( ty, &quot;PDB&quot; );
+					break;
+				case SymExport:
+					strcpy( ty, &quot;-exported-&quot; );
+					break;
+				case SymDeferred:
+					strcpy( ty, &quot;-deferred-&quot; );
+					break;
+				case SymSym:
+					strcpy( ty, &quot;SYM&quot; );
+					break;
+				default:
+					_snprintf( ty, sizeof ty, &quot;symtype=%ld&quot;, (long) Module.SymType );
+					break;
+				}
+
+				_snprintf(stringBuffer, 1024, &quot;    Mod:  %s[%s], base: %08lxh\r\n&quot;,
+					Module.ModuleName, Module.ImageName, Module.BaseOfImage );
+				WriteFile(hFile, stringBuffer, strlen(stringBuffer), &amp;bytesWritten, 0);
+				_snprintf(stringBuffer, 1024, &quot;    Sym:  type: %s, file: %s\r\n&quot;,
+					ty, Module.LoadedImageName );
+				WriteFile(hFile, stringBuffer, strlen(stringBuffer), &amp;bytesWritten, 0);
+			}
+		}
+
+		// no return address means no deeper stackframe
+		if ( stackframe.AddrReturn.Offset == 0 ) break;
+
+		frameNum++;
+	}
+
+	_snprintf(stringBuffer, 1024, &quot;-- End stack trace --\r\n&quot;);
+	WriteFile(hFile, stringBuffer, strlen(stringBuffer), &amp;bytesWritten, 0);
+
+	CloseHandle(hFile);
+
+	ptrSymCleanup(hProcess);
+
+	// todo: signal CL_CrashReporter::sig_crash here
+/*
+	hFile = CreateFile(
+		fileName,
+		GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
+
+	int pos = 0;
+	DWORD bytesRead;
+	ReadFile(hFile, stringBuffer, 1024, &amp;bytesRead, 0);
+	stringBuffer[bytesRead] = 0;
+	while (bytesRead &gt; 0)
+	{
+		char *ptrNewline = strstr(stringBuffer, &quot;\r\n&quot;);
+		if (ptrNewline)
+		{
+			ptrNewline[0] = 0;
+			CL_Log::log(&quot;debug&quot;, stringBuffer);
+			pos += ptrNewline-stringBuffer+2;
+			SetFilePointer(hFile, pos, 0, FILE_BEGIN);
+		}
+
+		ReadFile(hFile, stringBuffer, 1024, &amp;bytesRead, 0);
+		stringBuffer[bytesRead] = 0;
+	}
+
+	CloseHandle(hFile);
+*/
+
+	return 0;
+}
+
+void CL_CrashReporter_Win32::enumAndLoadModuleSymbols( HANDLE hProcess, DWORD pid )
+{
+	ModuleList modules;
+	ModuleListIter it;
+	char *img, *mod;
+
+	// fill in module list
+	fillModuleList( modules, pid, hProcess );
+
+	for ( it = modules.begin(); it != modules.end(); ++ it )
+	{
+		// unfortunately, SymLoadModule() wants writeable strings
+		img = new char[(*it).imageName.size() + 1];
+		strcpy( img, (*it).imageName.c_str() );
+		mod = new char[(*it).moduleName.size() + 1];
+		strcpy( mod, (*it).moduleName.c_str() );
+
+		ptrSymLoadModule( hProcess, 0, img, mod, (*it).baseAddress, (*it).size );
+/*		if ( ptrSymLoadModule( hProcess, 0, img, mod, (*it).baseAddress, (*it).size ) == 0 )
+			printf( &quot;Error %lu loading symbols for \&quot;%s\&quot;\n&quot;,
+				GetLastError(), (*it).moduleName.c_str() );
+		else
+			printf( &quot;Symbols loaded: \&quot;%s\&quot;\n&quot;, (*it).moduleName.c_str() );
+*/
+		delete [] img;
+		delete [] mod;
+	}
+}
+
+
+
+bool CL_CrashReporter_Win32::fillModuleList( ModuleList&amp; modules, DWORD pid, HANDLE hProcess )
+{
+	// try toolhelp32 first
+	if ( fillModuleListTH32( modules, pid ) )
+		return true;
+	// nope? try psapi, then
+	return fillModuleListPSAPI( modules, pid, hProcess );
+}
+
+
+
+// miscellaneous toolhelp32 declarations; we cannot #include the header
+// because not all systems may have it
+#define MAX_MODULE_NAME32 255
+#define TH32CS_SNAPMODULE   0x00000008
+#pragma pack( push, 8 )
+typedef struct tagMODULEENTRY32
+{
+    DWORD   dwSize;
+    DWORD   th32ModuleID;       // This module
+    DWORD   th32ProcessID;      // owning process
+    DWORD   GlblcntUsage;       // Global usage count on the module
+    DWORD   ProccntUsage;       // Module usage count in th32ProcessID's context
+    BYTE  * modBaseAddr;        // Base address of module in th32ProcessID's context
+    DWORD   modBaseSize;        // Size in bytes of module starting at modBaseAddr
+    HMODULE hModule;            // The hModule of this module in th32ProcessID's context
+    char    szModule[MAX_MODULE_NAME32 + 1];
+    char    szExePath[MAX_PATH];
+} MODULEENTRY32;
+typedef MODULEENTRY32 *  PMODULEENTRY32;
+typedef MODULEENTRY32 *  LPMODULEENTRY32;
+#pragma pack( pop )
+
+
+
+bool CL_CrashReporter_Win32::fillModuleListTH32( ModuleList&amp; modules, DWORD pid )
+{
+	// CreateToolhelp32Snapshot()
+	typedef HANDLE (__stdcall *tCT32S)( DWORD dwFlags, DWORD th32ProcessID );
+	// Module32First()
+	typedef BOOL (__stdcall *tM32F)( HANDLE hSnapshot, LPMODULEENTRY32 lpme );
+	// Module32Next()
+	typedef BOOL (__stdcall *tM32N)( HANDLE hSnapshot, LPMODULEENTRY32 lpme );
+
+	// I think the DLL is called tlhelp32.dll on Win9X, so we try both
+	const char *dllname[] = { &quot;kernel32.dll&quot;, &quot;tlhelp32.dll&quot; };
+	HINSTANCE hToolhelp;
+	tCT32S pCT32S;
+	tM32F pM32F;
+	tM32N pM32N;
+
+	HANDLE hSnap;
+	MODULEENTRY32 me = { sizeof me };
+	bool keepGoing;
+	ModuleEntry e;
+	int i;
+
+	#define lenof(a) (sizeof(a) / sizeof((a)[0]))
+	for ( i = 0; i &lt; lenof( dllname ); ++ i )
+	{
+		hToolhelp = LoadLibraryA( dllname[i] );
+		if ( hToolhelp == 0 )
+			continue;
+		pCT32S = (tCT32S) GetProcAddress( hToolhelp, &quot;CreateToolhelp32Snapshot&quot; );
+		pM32F = (tM32F) GetProcAddress( hToolhelp, &quot;Module32First&quot; );
+		pM32N = (tM32N) GetProcAddress( hToolhelp, &quot;Module32Next&quot; );
+		if ( pCT32S != 0 &amp;&amp; pM32F != 0 &amp;&amp; pM32N != 0 )
+			break; // found the functions!
+		FreeLibrary( hToolhelp );
+		hToolhelp = 0;
+	}
+
+	if ( hToolhelp == 0 ) // nothing found?
+		return false;
+
+	hSnap = pCT32S( TH32CS_SNAPMODULE, pid );
+	if ( hSnap == (HANDLE) -1 )
+		return false;
+
+	keepGoing = !!pM32F( hSnap, &amp;me );
+	while ( keepGoing )
+	{
+		// here, we have a filled-in MODULEENTRY32
+//		printf( &quot;%08lXh %6lu %-15.15s %s\n&quot;, me.modBaseAddr, me.modBaseSize, me.szModule, me.szExePath );
+		e.imageName = me.szExePath;
+		e.moduleName = me.szModule;
+		e.baseAddress = (DWORD) me.modBaseAddr;
+		e.size = me.modBaseSize;
+		modules.push_back( e );
+		keepGoing = !!pM32N( hSnap, &amp;me );
+	}
+
+	CloseHandle( hSnap );
+
+	FreeLibrary( hToolhelp );
+
+	return modules.size() != 0;
+}
+
+
+
+// miscellaneous psapi declarations; we cannot #include the header
+// because not all systems may have it
+typedef struct _MODULEINFO {
+    LPVOID lpBaseOfDll;
+    DWORD SizeOfImage;
+    LPVOID EntryPoint;
+} MODULEINFO, *LPMODULEINFO;
+
+
+
+bool CL_CrashReporter_Win32::fillModuleListPSAPI( ModuleList&amp; modules, DWORD pid, HANDLE hProcess )
+{
+	// EnumProcessModules()
+	typedef BOOL (__stdcall *tEPM)( HANDLE hProcess, HMODULE *lphModule, DWORD cb, LPDWORD lpcbNeeded );
+	// GetModuleFileNameEx()
+	typedef DWORD (__stdcall *tGMFNE)( HANDLE hProcess, HMODULE hModule, LPSTR lpFilename, DWORD nSize );
+	// GetModuleBaseName() -- redundant, as GMFNE() has the same prototype, but who cares?
+	typedef DWORD (__stdcall *tGMBN)( HANDLE hProcess, HMODULE hModule, LPSTR lpFilename, DWORD nSize );
+	// GetModuleInformation()
+	typedef BOOL (__stdcall *tGMI)( HANDLE hProcess, HMODULE hModule, LPMODULEINFO pmi, DWORD nSize );
+
+	HINSTANCE hPsapi;
+	tEPM pEPM;
+	tGMFNE pGMFNE;
+	tGMBN pGMBN;
+	tGMI pGMI;
+
+	unsigned int i;
+	ModuleEntry e;
+	DWORD cbNeeded;
+	MODULEINFO mi;
+	HMODULE *hMods = 0;
+	char *tt = 0;
+
+	hPsapi = LoadLibrary( &quot;psapi.dll&quot; );
+	if ( hPsapi == 0 )
+		return false;
+
+	modules.clear();
+
+	pEPM = (tEPM) GetProcAddress( hPsapi, &quot;EnumProcessModules&quot; );
+	pGMFNE = (tGMFNE) GetProcAddress( hPsapi, &quot;GetModuleFileNameExA&quot; );
+	pGMBN = (tGMFNE) GetProcAddress( hPsapi, &quot;GetModuleBaseNameA&quot; );
+	pGMI = (tGMI) GetProcAddress( hPsapi, &quot;GetModuleInformation&quot; );
+	if ( pEPM == 0 || pGMFNE == 0 || pGMBN == 0 || pGMI == 0 )
+	{
+		// yuck. Some API is missing.
+		FreeLibrary( hPsapi );
+		return false;
+	}
+
+	hMods = new HMODULE[TTBUFLEN / sizeof HMODULE];
+	tt = new char[TTBUFLEN];
+	// not that this is a sample. Which means I can get away with
+	// not checking for errors, but you cannot. :)
+
+	if ( ! pEPM( hProcess, hMods, TTBUFLEN, &amp;cbNeeded ) )
+	{
+//		printf( &quot;EPM failed, gle = %lu\n&quot;, GetLastError() );
+		goto cleanup;
+	}
+
+	if ( cbNeeded &gt; TTBUFLEN )
+	{
+//		printf( &quot;More than %lu module handles. Huh?\n&quot;, lenof( hMods ) );
+		goto cleanup;
+	}
+
+	for ( i = 0; i &lt; cbNeeded / sizeof hMods[0]; ++ i )
+	{
+		// for each module, get:
+		// base address, size
+		pGMI( hProcess, hMods[i], &amp;mi, sizeof mi );
+		e.baseAddress = (DWORD) mi.lpBaseOfDll;
+		e.size = mi.SizeOfImage;
+		// image file name
+		tt[0] = '\0';
+		pGMFNE( hProcess, hMods[i], tt, TTBUFLEN );
+		e.imageName = tt;
+		// module name
+		tt[0] = '\0';
+		pGMBN( hProcess, hMods[i], tt, TTBUFLEN );
+		e.moduleName = tt;
+//		printf( &quot;%08lXh %6lu %-15.15s %s\n&quot;, e.baseAddress,
+//			e.size, e.moduleName.c_str(), e.imageName.c_str() );
+
+		modules.push_back( e );
+	}
+
+cleanup:
+	if ( hPsapi )
+		FreeLibrary( hPsapi );
+	delete [] tt;
+	delete [] hMods;
+
+	return modules.size() != 0;
+}
+
+HINSTANCE CL_CrashReporter_Win32::moduleImagehlp = 0;
+
+HINSTANCE CL_CrashReporter_Win32::moduleDbghlp = 0;
+
+CL_CrashReporter_Win32::TypeSymCleanup CL_CrashReporter_Win32::ptrSymCleanup = 0;
+
+CL_CrashReporter_Win32::TypeSymFunctionTableAccess CL_CrashReporter_Win32::ptrSymFunctionTableAccess = 0;
+
+CL_CrashReporter_Win32::TypeSymGetLineFromAddr CL_CrashReporter_Win32::ptrSymGetLineFromAddr = 0;
+
+CL_CrashReporter_Win32::TypeSymGetModuleBase CL_CrashReporter_Win32::ptrSymGetModuleBase = 0;
+
+CL_CrashReporter_Win32::TypeSymGetModuleInfo CL_CrashReporter_Win32::ptrSymGetModuleInfo = 0;
+
+CL_CrashReporter_Win32::TypeSymGetOptions CL_CrashReporter_Win32::ptrSymGetOptions = 0;
+
+CL_CrashReporter_Win32::TypeSymGetSymFromAddr CL_CrashReporter_Win32::ptrSymGetSymFromAddr = 0;
+
+CL_CrashReporter_Win32::TypeSymInitialize CL_CrashReporter_Win32::ptrSymInitialize = 0;
+
+CL_CrashReporter_Win32::TypeSymLoadModule CL_CrashReporter_Win32::ptrSymLoadModule = 0;
+
+CL_CrashReporter_Win32::TypeSymSetOptions CL_CrashReporter_Win32::ptrSymSetOptions = 0;
+
+CL_CrashReporter_Win32::TypeStackWalk CL_CrashReporter_Win32::ptrStackWalk = 0;
+
+CL_CrashReporter_Win32::TypeUnDecorateSymbolName CL_CrashReporter_Win32::ptrUnDecorateSymbolName = 0;
+
+CL_CrashReporter_Win32::TypeMiniDumpWriteDump CL_CrashReporter_Win32::ptrMiniDumpWriteDump = 0;
+
+_se_translator_function CL_CrashReporter_Win32::ptrOldFilter = 0;
+
+std::string CL_CrashReporter_Win32::userSearchPath;
+
+#endif

Added: trunk/clanlib/Core/System/Win32/crash_reporter_win32.h
===================================================================
--- trunk/clanlib/Core/System/Win32/crash_reporter_win32.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Win32/crash_reporter_win32.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,214 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_crash_reporter_win32
+#define header_crash_reporter_win32
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Generic/crash_reporter_generic.h&quot;
+
+/*
+	HAS_PDB_SUPPORT enables support for the crash reporter.
+	If its not defined, then the crash reporter will do nothing.
+
+	HAS_SE_TRANSLATOR enables support for using Visual C++ exception handling
+	to catch the WIN32 structured exception. This allows us to catch it at a
+	much earlier stage than otherwise.
+
+	As of this date, both will be defined if compiled with Visual C++ 7 or better,
+	and otherwise disabled. People porting to another compile may try define first
+	pdb support, and then maybe afterwards se translator if the compiler support
+	this msvc keyword.
+
+	For users with Visual C++ 6, it is possible to enable this as well, but it
+	requires that you have installed a recent version of the Microsoft Platform SDK.
+*/
+
+#if _MSC_VER &gt;= 1300
+#define HAS_SE_TRANSLATOR
+#define HAS_PDB_SUPPORT
+#endif
+
+#ifdef HAS_PDB_SUPPORT
+
+// imagehlp.h must be compiled with packing to eight-byte-boundaries,
+// but does nothing to enforce that. I am grateful to Jeff Shanholtz
+// &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">JShanholtz at premia.com</A>&gt; for finding this problem.
+#pragma pack( push, before_imagehlp, 8 )
+#include &lt;imagehlp.h&gt;
+#pragma pack( pop, before_imagehlp )
+#endif
+
+class CL_CrashReporter_Win32 : public CL_CrashReporter_Generic
+{
+//! Construction:
+public:
+	CL_CrashReporter_Win32();
+
+	~CL_CrashReporter_Win32();
+
+//! Implementation:
+public:
+#ifdef HAS_PDB_SUPPORT
+	typedef BOOL (__stdcall *TypeSymCleanup)( IN HANDLE hProcess );
+
+	typedef PVOID (__stdcall *TypeSymFunctionTableAccess)( HANDLE hProcess, DWORD AddrBase );
+
+	typedef BOOL (__stdcall *TypeSymGetLineFromAddr)(
+		IN HANDLE hProcess,
+		IN DWORD dwAddr,
+		OUT PDWORD pdwDisplacement,
+		OUT PIMAGEHLP_LINE Line );
+
+	typedef DWORD (__stdcall *TypeSymGetModuleBase)( IN HANDLE hProcess, IN DWORD dwAddr );
+
+	typedef BOOL (__stdcall *TypeSymGetModuleInfo)(
+		IN HANDLE hProcess,
+		IN DWORD dwAddr,
+		OUT PIMAGEHLP_MODULE ModuleInfo );
+
+	typedef DWORD (__stdcall *TypeSymGetOptions)( VOID );
+
+	typedef BOOL (__stdcall *TypeSymGetSymFromAddr)(
+		IN HANDLE hProcess,
+		IN DWORD dwAddr,
+		OUT PDWORD pdwDisplacement,
+		OUT PIMAGEHLP_SYMBOL Symbol );
+
+	typedef BOOL (__stdcall *TypeSymInitialize)(
+		IN HANDLE hProcess,
+		IN PSTR UserSearchPath,
+		IN BOOL fInvadeProcess );
+
+	typedef DWORD (__stdcall *TypeSymLoadModule)(
+		IN HANDLE hProcess,
+		IN HANDLE hFile,
+		IN PSTR ImageName,
+		IN PSTR ModuleName,
+		IN DWORD BaseOfDll,
+		IN DWORD SizeOfDll );
+
+	typedef DWORD (__stdcall *TypeSymSetOptions)(
+		IN DWORD SymOptions );
+
+	typedef BOOL (__stdcall *TypeStackWalk)(
+		DWORD MachineType,
+		HANDLE hProcess,
+		HANDLE hThread,
+		LPSTACKFRAME StackFrame,
+		PVOID ContextRecord,
+		PREAD_PROCESS_MEMORY_ROUTINE ReadMemoryRoutine,
+		PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine,
+		PGET_MODULE_BASE_ROUTINE GetModuleBaseRoutine,
+		PTRANSLATE_ADDRESS_ROUTINE TranslateAddress );
+
+	typedef DWORD (__stdcall WINAPI *TypeUnDecorateSymbolName)(
+		PCSTR DecoratedName,
+		PSTR UnDecoratedName,
+		DWORD UndecoratedLength,
+		DWORD Flags );
+
+	typedef BOOL (WINAPI *TypeMiniDumpWriteDump)(
+		HANDLE hProcess, DWORD dwPid, HANDLE hFile, MINIDUMP_TYPE DumpType,
+		CONST PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam,
+		CONST PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,
+		CONST PMINIDUMP_CALLBACK_INFORMATION CallbackParam);
+
+	static HINSTANCE moduleImagehlp;
+
+	static HINSTANCE moduleDbghlp;
+
+	static TypeSymCleanup ptrSymCleanup;
+
+	static TypeSymFunctionTableAccess ptrSymFunctionTableAccess;
+
+	static TypeSymGetLineFromAddr ptrSymGetLineFromAddr;
+
+	static TypeSymGetModuleBase ptrSymGetModuleBase;
+
+	static TypeSymGetModuleInfo ptrSymGetModuleInfo;
+
+	static TypeSymGetOptions ptrSymGetOptions;
+
+	static TypeSymGetSymFromAddr ptrSymGetSymFromAddr;
+
+	static TypeSymInitialize ptrSymInitialize;
+
+	static TypeSymLoadModule ptrSymLoadModule;
+
+	static TypeSymSetOptions ptrSymSetOptions;
+
+	static TypeStackWalk ptrStackWalk;
+
+	static TypeUnDecorateSymbolName ptrUnDecorateSymbolName;
+
+	static TypeMiniDumpWriteDump ptrMiniDumpWriteDump;
+
+#ifdef HAS_SE_TRANSLATOR
+	static _se_translator_function ptrOldFilter;
+#else
+	static LPTOP_LEVEL_EXCEPTION_FILTER ptrOldFilter;
+#endif
+
+	static std::string userSearchPath;
+
+#ifdef HAS_SE_TRANSLATOR
+	static void unhandledExceptionFilter(unsigned int exceptionCode, PEXCEPTION_POINTERS exceptionInfo);
+#else
+	static LONG WINAPI unhandledExceptionFilter(PEXCEPTION_POINTERS exceptionInfo);
+#endif
+
+	static DWORD WINAPI dumpStack(LPVOID lpThreadParameter);
+
+	static void enumAndLoadModuleSymbols( HANDLE hProcess, DWORD pid );
+
+	struct ModuleEntry
+	{
+		std::string imageName;
+		std::string moduleName;
+		DWORD baseAddress;
+		DWORD size;
+	};
+
+	typedef std::vector&lt; ModuleEntry &gt; ModuleList;
+
+	typedef ModuleList::iterator ModuleListIter;
+
+	static bool fillModuleList( ModuleList&amp; modules, DWORD pid, HANDLE hProcess );
+
+	static bool fillModuleListTH32( ModuleList&amp; modules, DWORD pid );
+
+	static bool fillModuleListPSAPI( ModuleList&amp; modules, DWORD pid, HANDLE hProcess );
+#endif
+};
+
+#endif

Added: trunk/clanlib/Core/System/Win32/event_listener_win32.cpp
===================================================================
--- trunk/clanlib/Core/System/Win32/event_listener_win32.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Win32/event_listener_win32.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,80 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;event_listener_win32.h&quot;
+#include &quot;event_trigger_win32.h&quot;
+#include &quot;API/Core/System/system.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventListener_Win32 construction:
+
+CL_EventListener_Win32::CL_EventListener_Win32(CL_EventListener *owner)
+:
+	CL_EventListener_Generic(owner)
+{
+}
+
+CL_EventListener_Win32::~CL_EventListener_Win32()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventListener_Win32 implementation:
+
+bool CL_EventListener_Win32::wait(int timeout)
+{
+	if (triggers.empty()) // no triggers, just do the sleep.
+	{
+		CL_System::sleep(timeout);
+		return false;
+	}
+
+	int num_handles = triggers.size();
+	HANDLE *handles = new HANDLE[num_handles];
+
+	int i = 0;
+	std::list&lt; CL_SharedPtr&lt;CL_EventTrigger_Generic&gt; &gt;::iterator it;
+	for (it = triggers.begin(); it != triggers.end(); it++)
+	{
+		CL_EventTrigger_Win32 *trigger = static_cast&lt;CL_EventTrigger_Win32*&gt;((*it).get());
+		handles[i++] = trigger-&gt;wait_handle;
+	}
+
+	DWORD result = WaitForMultipleObjects(
+		num_handles,
+		handles,
+		FALSE,
+		timeout == -1 ? INFINITE : timeout);
+
+	delete[] handles;
+
+	if (result == WAIT_TIMEOUT) return false;
+	return true;
+}

Added: trunk/clanlib/Core/System/Win32/event_listener_win32.h
===================================================================
--- trunk/clanlib/Core/System/Win32/event_listener_win32.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Win32/event_listener_win32.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,54 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_event_listener_win32
+#define header_event_listener_win32
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;Core/System/Generic/event_listener_generic.h&quot;
+
+class CL_EventListener_Win32 : public CL_EventListener_Generic
+{
+//! Construction:
+public:
+	CL_EventListener_Win32(CL_EventListener *owner);
+
+	virtual ~CL_EventListener_Win32();
+
+//! Implementation:
+private:
+	//: Wait until one of the events triggers. The timeout is in milliseconds.
+	//return: true if a event triggered, false if it timed out.
+	virtual bool wait(int timeout);
+};
+
+#endif

Added: trunk/clanlib/Core/System/Win32/event_trigger_win32.cpp
===================================================================
--- trunk/clanlib/Core/System/Win32/event_trigger_win32.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Win32/event_trigger_win32.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,79 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;event_trigger_win32.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventTrigger_Win32 construction:
+
+CL_EventTrigger_Win32::CL_EventTrigger_Win32()
+:
+	wait_handle(NULL)
+{
+	wait_handle = CreateEvent(NULL, TRUE, FALSE, NULL);
+}
+
+CL_EventTrigger_Win32::~CL_EventTrigger_Win32()
+{
+	CloseHandle(wait_handle);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventTrigger_Win32 attributes:
+
+bool CL_EventTrigger_Win32::get_flag() const
+{
+	return WaitForSingleObject(wait_handle, 0) != WAIT_TIMEOUT;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventTrigger_Win32 operations:
+
+void CL_EventTrigger_Win32::reset() const
+{
+	ResetEvent(wait_handle);
+}
+
+void CL_EventTrigger_Win32::set_flag()
+{
+	SetEvent(wait_handle);
+}
+
+bool CL_EventTrigger_Win32::wait(int timeout) const
+{
+	DWORD result = WaitForSingleObject(
+		wait_handle,
+		(timeout == -1) ? INFINITE : timeout);
+
+	return (result != WAIT_TIMEOUT);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_EventTrigger_Win32 implementation:

Added: trunk/clanlib/Core/System/Win32/event_trigger_win32.h
===================================================================
--- trunk/clanlib/Core/System/Win32/event_trigger_win32.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Win32/event_trigger_win32.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,74 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_event_trigger_generic_win32
+#define header_event_trigger_generic_win32
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../Generic/event_trigger_generic.h&quot;
+#include &quot;event_listener_win32.h&quot;
+
+class CL_EventTrigger_Win32 : public CL_EventTrigger_Generic
+{
+//! Construction:
+public:
+	CL_EventTrigger_Win32();
+
+	virtual ~CL_EventTrigger_Win32();
+
+//! Attributes:
+public:
+	bool get_flag() const;
+
+	HANDLE get_handle() const { return wait_handle; }
+
+//! Operations:
+public:
+	//: Reset trigger flag.
+	virtual void reset() const;
+
+	//: Raise trigger flag.
+	virtual void set_flag();
+
+	//: Wait until one of the event triggers. The timeout is in milliseconds.
+	//return: true if the event triggered, false if it timed out.
+	virtual bool wait(int timeout = -1) const;
+
+	friend class CL_EventListener_Win32;
+
+//! Implementation:
+private:
+	//: Win32 event handle. Used to wait with WaitForSingleObject().
+	HANDLE wait_handle;
+};
+
+#endif

Added: trunk/clanlib/Core/System/Win32/init_win32.cpp
===================================================================
--- trunk/clanlib/Core/System/Win32/init_win32.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Win32/init_win32.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,156 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+**
+**	File purpose:
+**    This file is the WinMain entry point. It will setup the clanCore
+**    win32 environment.
+**
+**    This file also contain the win32 specific implementations
+**    of the CL_System class.
+**
+**    The win32 versions of CL_SetupCore functions are also defined here.
+*/
+
+#include &quot;Core/precomp.h&quot; // visual c++: precompiled header file MUST be mentioned FIRST.
+
+#ifdef BORLAND
+#include &lt;stdio.h&gt;
+#pragma hdrstop
+#endif
+
+#include &quot;init_win32.h&quot;
+#include &quot;API/Core/System/keep_alive.h&quot;
+#include &quot;API/Core/System/setupcore.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/Core/System/cl_assert.h&quot;
+
+class CL_Win32Event_Dispatcher : public CL_KeepAlive
+{
+public:
+	virtual void keep_alive();
+};
+
+// Setup a CL_System::keep_alive() listener that will read win32 events
+// and dispatch them.
+CL_Win32Event_Dispatcher *event_dispatcher = NULL;
+
+void CL_SetupCore::set_instance(HINSTANCE hInstance)
+{
+	CL_System_Win32::hInstance = hInstance;
+}
+
+static int init_ref_count = 0;
+void init_system()
+{
+	init_ref_count++;
+	if (init_ref_count &gt; 1) return;
+
+	event_dispatcher = new CL_Win32Event_Dispatcher;
+
+	// if you get this assertion, you forgot to call CL_SetupCore::set_instance()
+	// prior to CL_SetupCore::init().
+	cl_assert(CL_System_Win32::hInstance != NULL);
+
+	// Redirect C++ output streams to the output window in developer studio:
+//	std::cout = iostream(&amp;debug_buf);
+//	cerr = iostream(&amp;debug_buf);
+}
+
+void deinit_system()
+{
+	init_ref_count--;
+	if (init_ref_count &gt; 0) return;
+
+	delete event_dispatcher;
+	event_dispatcher = NULL;
+}
+
+void CL_Win32Event_Dispatcher::keep_alive()
+{
+	// Check for win32 events and dispatch them to MainMessageHandler().
+
+	MSG msg;
+
+	while (PeekMessage(&amp;msg, NULL, 0, 0, PM_NOREMOVE) == TRUE)
+	{
+		int ret = GetMessage(&amp;msg, NULL, 0, 0);
+		if (ret &gt; 0)
+		{
+			TranslateMessage(&amp;msg);
+			DispatchMessage(&amp;msg);
+		}
+		else
+		{
+			if (ret == 0)
+				throw CL_Error(&quot;WM_QUIT&quot;);
+			else
+				throw CL_Error(CL_String::from_int(GetLastError()));
+		}
+	}
+}
+
+// Win32 implementation of CL_System functions:
+
+unsigned int CL_System::sys_time()
+{
+	static LARGE_INTEGER perf_frequency, perf_counter;
+	static bool first_time = true;
+
+	if (first_time)
+	{
+		QueryPerformanceFrequency(&amp;perf_frequency);
+		perf_frequency.QuadPart /= 1000;
+		first_time = false;
+	}
+
+	QueryPerformanceCounter(&amp;perf_counter);
+	return (unsigned int) (perf_counter.QuadPart / perf_frequency.QuadPart);
+}
+
+void CL_System::sleep(int millis)
+{
+	Sleep(millis);
+}
+
+std::string CL_System::get_exe_path()
+{
+	// Get path to executable:
+	TCHAR szDllName[_MAX_PATH];
+	TCHAR szDrive[_MAX_DRIVE];
+	TCHAR szDir[_MAX_DIR];
+	TCHAR szFilename[256];
+	TCHAR szExt[256];
+	GetModuleFileName(0, szDllName, _MAX_PATH);
+	_splitpath(szDllName, szDrive, szDir, szFilename, szExt);
+
+	return std::string(szDrive) + std::string(szDir); 
+}
+
+// Global vars:
+HINSTANCE CL_System_Win32::hInstance = NULL;

Added: trunk/clanlib/Core/System/Win32/init_win32.h
===================================================================
--- trunk/clanlib/Core/System/Win32/init_win32.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Win32/init_win32.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,55 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_init_win32
+#define header_init_win32
+
+#ifdef CL_API_DLL
+#ifdef CL_CORE_EXPORT
+#define CL_API_CORE __declspec(dllexport)
+#else
+#define CL_API_CORE __declspec(dllimport)
+#endif
+#else
+#define CL_API_CORE
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/System/system.h&quot;
+
+class CL_API_CORE CL_System_Win32 : public CL_System
+{
+public:
+	static HINSTANCE hInstance;
+};
+
+#endif

Added: trunk/clanlib/Core/System/Win32/mutex_win32.cpp
===================================================================
--- trunk/clanlib/Core/System/Win32/mutex_win32.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Win32/mutex_win32.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,92 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+
+#include &quot;mutex_win32.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Mutex 0.4 backward compatibility
+
+CL_Mutex *CL_Mutex::create()
+{
+	return new CL_Mutex;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Mutex win32 implementation
+
+CL_Mutex::CL_Mutex()
+: impl(new CL_Mutex_Generic)
+{
+	InitializeCriticalSection(&amp;impl-&gt;mutex);
+	impl-&gt;event = CreateEvent(NULL, FALSE, FALSE, NULL);
+}
+
+CL_Mutex::CL_Mutex(const CL_Mutex &amp;copy)
+{
+	cl_assert(false);
+}
+
+void CL_Mutex::operator =(const CL_Mutex &amp;copy)
+{
+	cl_assert(false);
+}
+
+CL_Mutex::~CL_Mutex()
+{
+	DeleteCriticalSection(&amp;impl-&gt;mutex);
+	CloseHandle(impl-&gt;event);
+	delete impl;
+}
+
+void CL_Mutex::enter()
+{
+	EnterCriticalSection(&amp;impl-&gt;mutex);
+}
+
+void CL_Mutex::leave()
+{
+	LeaveCriticalSection(&amp;impl-&gt;mutex);
+}
+
+void CL_Mutex::wait() 
+{ 
+	WaitForSingleObject(impl-&gt;event, INFINITE);
+}
+
+void CL_Mutex::notify() 
+{ 
+	SetEvent(impl-&gt;event);
+}
+
+void CL_Mutex::notify_all() 
+{ 
+	cl_assert(false); 
+}

Added: trunk/clanlib/Core/System/Win32/mutex_win32.h
===================================================================
--- trunk/clanlib/Core/System/Win32/mutex_win32.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Win32/mutex_win32.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,48 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_mutex_win32
+#define header_mutex_win32
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/System/mutex.h&quot;
+#include &quot;API/Core/System/cl_assert.h&quot;
+#include &lt;windows.h&gt;
+
+class CL_Mutex_Generic
+{
+public:
+	CRITICAL_SECTION mutex;
+	HANDLE event;
+};
+
+#endif

Added: trunk/clanlib/Core/System/Win32/thread_win32.cpp
===================================================================
--- trunk/clanlib/Core/System/Win32/thread_win32.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Win32/thread_win32.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,227 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+
+#include &quot;API/Core/System/thread.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/System/crash_reporter.h&quot;
+#include &quot;thread_win32.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Thread_Helper win32 implementation:
+
+class CL_Thread_Helper : public CL_Runnable
+{
+public:
+	CL_Thread_Helper(int (*func)(void*), void *value)
+		: func(func), value(value)
+	{
+	}
+
+	virtual void run()
+	{
+		func(value);
+	}
+
+private:
+	int (*func)(void*);
+
+	void *value;
+};
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Thread win32 implementation:
+
+CL_Thread::CL_Thread()
+: impl(0)
+{
+}
+
+CL_Thread::CL_Thread(int (*func)(void*), void *value)
+: impl(new CL_Thread_Generic)
+{
+	impl-&gt;runnable = new CL_Thread_Helper(func, value);
+	impl-&gt;delete_runnable = true;
+	impl-&gt;thread_handle = NULL;
+	impl-&gt;ref_count = 1;
+}
+
+CL_Thread::CL_Thread(CL_Runnable *runnable, bool delete_runnable)
+: impl(new CL_Thread_Generic)
+{
+	impl-&gt;runnable = runnable;
+	impl-&gt;delete_runnable = delete_runnable;
+	impl-&gt;thread_handle = NULL;
+	impl-&gt;ref_count = 1;
+}
+
+CL_Thread::CL_Thread(const CL_Thread &amp;copy)
+: impl(copy.impl)
+{
+	if (impl) impl-&gt;ref_count++;
+}
+
+CL_Thread::~CL_Thread()
+{
+	if (impl)
+	{
+		impl-&gt;ref_count--;
+		if (impl-&gt;ref_count == 0)
+		{
+			if (impl-&gt;thread_handle != NULL) terminate();
+			if (impl-&gt;delete_runnable) delete impl-&gt;runnable;
+			delete impl;
+		}
+	}
+}
+
+unsigned long __stdcall CL_Thread_Generic::func_proxy(void *arg)
+{
+#ifndef _DEBUG
+	// Create minidumps when not in debug mode.
+	CL_CrashReporter crash_reporter;
+#endif
+
+	CL_Thread_Generic *self = (CL_Thread_Generic *) arg;
+	self-&gt;runnable-&gt;run();
+
+	return 0;
+}
+
+CL_Thread &amp;CL_Thread::operator =(const CL_Thread &amp;copy)
+{
+	if (impl)
+	{
+		impl-&gt;ref_count--;
+		if (impl-&gt;ref_count == 0)
+		{
+			if (impl-&gt;thread_handle != NULL) terminate();
+			if (impl-&gt;delete_runnable) delete impl-&gt;runnable;
+			delete impl;
+		}
+	}
+
+	impl = copy.impl;
+	if (impl) impl-&gt;ref_count++;
+	return *this;
+}
+
+void CL_Thread::start()
+{
+	impl-&gt;thread_handle = CreateThread(
+		NULL,
+		0,
+		impl-&gt;func_proxy,
+		impl,
+		0,
+		&amp;impl-&gt;thread_id);
+
+	if (impl-&gt;thread_handle == NULL)
+		throw CL_Error(&quot;Failed to create thread&quot;);
+}
+
+void CL_Thread::terminate()
+{
+	TerminateThread(impl-&gt;thread_handle, 0);
+	CloseHandle(impl-&gt;thread_handle);
+	impl-&gt;thread_handle = NULL;
+}
+
+void CL_Thread::wait()
+{
+	if (impl-&gt;thread_handle == NULL) return;
+
+	WaitForSingleObject(impl-&gt;thread_handle, INFINITE);
+	CloseHandle(impl-&gt;thread_handle);
+	impl-&gt;thread_handle = NULL;
+}
+
+void CL_Thread::set_priority(EThreadPriority priority)
+{
+	if (impl-&gt;thread_handle == NULL) return;
+
+	int prio = THREAD_PRIORITY_NORMAL;
+	switch (priority)
+	{
+	case cl_priority_above_normal:  prio = THREAD_PRIORITY_ABOVE_NORMAL;  break;
+	case cl_priority_below_normal:  prio = THREAD_PRIORITY_BELOW_NORMAL;  break;
+	case cl_priority_highest:       prio = THREAD_PRIORITY_HIGHEST;       break;
+	case cl_priority_idle:          prio = THREAD_PRIORITY_IDLE;          break;
+	case cl_priority_lowest:        prio = THREAD_PRIORITY_LOWEST;        break;
+	case cl_priority_normal:        prio = THREAD_PRIORITY_NORMAL;        break;
+	case cl_priority_time_critical: prio = THREAD_PRIORITY_TIME_CRITICAL; break;
+	}
+
+	BOOL result = SetThreadPriority(impl-&gt;thread_handle, prio);
+	if (result == FALSE) throw CL_Error(&quot;Failed to set thread priority&quot;);
+}
+
+CL_ThreadId CL_Thread::get_current_id()
+{
+	return CL_ThreadId();
+}
+
+CL_ThreadId::CL_ThreadId()
+:impl(new CL_ThreadId_Generic)
+{
+	impl-&gt;thread_id = GetCurrentThreadId();
+}
+
+CL_ThreadId::CL_ThreadId(const CL_ThreadId &amp;copy)
+:impl(new CL_ThreadId_Generic)
+{
+	*this = copy;
+}
+
+CL_ThreadId::~CL_ThreadId()
+{
+	delete impl;
+}
+
+CL_ThreadId &amp;CL_ThreadId::operator=(const CL_ThreadId &amp;copy)
+{
+	impl-&gt;thread_id = copy.impl-&gt;thread_id;
+	return *this;
+}
+
+bool CL_ThreadId::operator ==(const CL_ThreadId &amp;cmp) const
+{
+	return impl-&gt;thread_id == cmp.impl-&gt;thread_id;
+}
+
+bool CL_ThreadId::operator !=(const CL_ThreadId &amp;cmp) const
+{
+	return !operator ==(cmp);
+}
+
+bool CL_ThreadId::operator &lt;(const CL_ThreadId &amp;cmp) const
+{
+	return impl-&gt;thread_id &lt; cmp.impl-&gt;thread_id;
+}

Added: trunk/clanlib/Core/System/Win32/thread_win32.h
===================================================================
--- trunk/clanlib/Core/System/Win32/thread_win32.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/System/Win32/thread_win32.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,63 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_thread_win32
+#define header_thread_win32
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/System/thread.h&quot;
+#include &lt;windows.h&gt;
+
+class CL_Thread_Generic
+{
+//! Attributes:
+public:
+	static unsigned long __stdcall func_proxy(void *arg);
+
+	HANDLE thread_handle;
+
+	DWORD thread_id;
+	
+	CL_Runnable *runnable;
+	
+	bool delete_runnable;
+	
+	int ref_count;
+};
+
+class CL_ThreadId_Generic
+{
+public:
+	DWORD thread_id;
+};
+
+#endif

Added: trunk/clanlib/Core/XML/dom_attr.cpp
===================================================================
--- trunk/clanlib/Core/XML/dom_attr.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/dom_attr.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,85 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/XML/dom_attr.h&quot;
+#include &quot;API/Core/XML/dom_document.h&quot;
+#include &quot;dom_node_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomAttr construction:
+
+CL_DomAttr::CL_DomAttr()
+{
+}
+
+CL_DomAttr::CL_DomAttr(CL_DomDocument doc, const std::string &amp;name)
+: CL_DomNode(doc, ATTRIBUTE_NODE)
+{
+	impl-&gt;node_name = name;
+}
+
+CL_DomAttr::CL_DomAttr(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl) : CL_DomNode(impl)
+{
+}
+
+CL_DomAttr::~CL_DomAttr()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomAttr attributes:
+
+std::string CL_DomAttr::get_name() const
+{
+	if (impl) return impl-&gt;node_name;
+	return std::string();
+}
+	
+bool CL_DomAttr::get_specified() const
+{
+	return false;
+}
+	
+std::string CL_DomAttr::get_value() const
+{
+	if (impl) return impl-&gt;node_value;
+	return std::string();
+}
+	
+void CL_DomAttr::set_value(const std::string &amp;value)
+{
+	if (impl) impl-&gt;node_value = value;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomAttr operations:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomAttr implementation:

Added: trunk/clanlib/Core/XML/dom_cdata_section.cpp
===================================================================
--- trunk/clanlib/Core/XML/dom_cdata_section.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/dom_cdata_section.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,62 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/XML/dom_cdata_section.h&quot;
+#include &quot;dom_node_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomCDATASection construction:
+
+CL_DomCDATASection::CL_DomCDATASection()
+{
+}
+
+CL_DomCDATASection::CL_DomCDATASection(CL_DomDocument &amp;doc, const std::string &amp;data)
+: CL_DomText(doc, CDATA_SECTION_NODE)
+{
+	impl-&gt;node_value = data;
+}
+
+CL_DomCDATASection::CL_DomCDATASection(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl) : CL_DomText(impl)
+{
+}
+
+CL_DomCDATASection::~CL_DomCDATASection()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomCDATASection attributes:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomCDATASection operations:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomCDATASection implementation:

Added: trunk/clanlib/Core/XML/dom_character_data.cpp
===================================================================
--- trunk/clanlib/Core/XML/dom_character_data.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/dom_character_data.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,92 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/XML/dom_character_data.h&quot;
+#include &quot;dom_node_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomCharacterData construction:
+
+CL_DomCharacterData::CL_DomCharacterData()
+{
+}
+
+CL_DomCharacterData::CL_DomCharacterData(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl) : CL_DomNode(impl)
+{
+}
+
+CL_DomCharacterData::CL_DomCharacterData(CL_DomDocument &amp;doc, unsigned short node_type)
+: CL_DomNode(doc, node_type)
+{
+}
+
+CL_DomCharacterData::~CL_DomCharacterData()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomCharacterData attributes:
+
+unsigned long CL_DomCharacterData::get_length()
+{
+	return 0;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomCharacterData operations:
+
+std::string CL_DomCharacterData::substring_data(unsigned long offset, unsigned long count)
+{
+	if (impl) return impl-&gt;node_value.substr(offset, count);
+	return std::string();
+}
+
+void CL_DomCharacterData::append_data(const std::string &amp;arg)
+{
+	if (impl) impl-&gt;node_value.append(arg);
+}
+
+void CL_DomCharacterData::insert_data(unsigned long offset, const std::string &amp;arg)
+{
+	if (impl) impl-&gt;node_value.insert(offset, arg);
+}
+
+void CL_DomCharacterData::delete_data(unsigned long offset, unsigned long count)
+{
+	if (impl) impl-&gt;node_value.erase(offset, count);
+}
+
+void CL_DomCharacterData::replace_data(unsigned long offset, unsigned long count, const std::string &amp;arg)
+{
+	if (impl) impl-&gt;node_value.replace(offset, count, arg);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomCharacterData implementation:

Added: trunk/clanlib/Core/XML/dom_comment.cpp
===================================================================
--- trunk/clanlib/Core/XML/dom_comment.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/dom_comment.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,62 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/XML/dom_comment.h&quot;
+#include &quot;dom_node_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomComment construction:
+
+CL_DomComment::CL_DomComment()
+{
+}
+
+CL_DomComment::CL_DomComment(CL_DomDocument &amp;doc, const std::string &amp;data)
+: CL_DomCharacterData(doc, COMMENT_NODE)
+{
+	impl-&gt;node_value = data;
+}
+
+CL_DomComment::CL_DomComment(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl) : CL_DomCharacterData(impl)
+{
+}
+
+CL_DomComment::~CL_DomComment()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomComment attributes:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomComment operations:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomComment implementation:

Added: trunk/clanlib/Core/XML/dom_document.cpp
===================================================================
--- trunk/clanlib/Core/XML/dom_document.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/dom_document.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,312 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/XML/dom_document.h&quot;
+#include &quot;API/Core/XML/dom_document_type.h&quot;
+#include &quot;API/Core/XML/dom_implementation.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;API/Core/XML/dom_document_fragment.h&quot;
+#include &quot;API/Core/XML/dom_text.h&quot;
+#include &quot;API/Core/XML/dom_comment.h&quot;
+#include &quot;API/Core/XML/dom_cdata_section.h&quot;
+#include &quot;API/Core/XML/dom_processing_instruction.h&quot;
+#include &quot;API/Core/XML/dom_attr.h&quot;
+#include &quot;API/Core/XML/dom_entity_reference.h&quot;
+#include &quot;API/Core/XML/dom_node_list.h&quot;
+#include &quot;API/Core/XML/xml_tokenizer.h&quot;
+#include &quot;API/Core/XML/xml_writer.h&quot;
+#include &quot;API/Core/XML/xml_token.h&quot;
+#include &quot;dom_document_generic.h&quot;
+#include &lt;stack&gt;
+
+#include &quot;API/Core/XML/xml_token_load.h&quot;
+#include &quot;API/Core/XML/xml_token_save.h&quot;
+#include &quot;API/Core/XML/xml_token_string.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomDocument construction:
+
+CL_DomDocument::CL_DomDocument() : CL_DomNode(CL_SharedPtr&lt;CL_DomNode_Generic&gt;(new CL_DomDocument_Generic))
+{
+}
+
+CL_DomDocument::CL_DomDocument(CL_InputSource *input, bool delete_input, bool eat_whitespace)
+: CL_DomNode(CL_SharedPtr&lt;CL_DomNode_Generic&gt;(new CL_DomDocument_Generic))
+{
+	load(input, delete_input, eat_whitespace);
+}
+
+CL_DomDocument::CL_DomDocument(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl) : CL_DomNode(impl)
+{
+}
+
+CL_DomDocument::~CL_DomDocument()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomDocument attributes:
+
+CL_DomDocumentType CL_DomDocument::get_doctype()
+{
+	return CL_DomDocumentType(*this);
+}
+
+CL_DomImplementation CL_DomDocument::get_implementation()
+{
+	return CL_DomImplementation(*this);
+}
+
+CL_DomElement CL_DomDocument::get_document_element()
+{
+	CL_DomNode cur(impl-&gt;first_child);
+	while (!cur.is_null())
+	{
+		if (cur.is_element()) return cur.to_element();
+		cur = cur.get_next_sibling();
+	}
+	return CL_DomElement();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomDocument operations:
+
+CL_DomElement CL_DomDocument::create_element(const std::string &amp;tag_name)
+{
+	return CL_DomElement(*this, tag_name);
+}
+
+CL_DomDocumentFragment CL_DomDocument::create_document_fragment()
+{
+	return CL_DomDocumentFragment(*this);
+}
+
+CL_DomText CL_DomDocument::create_text_node(const std::string &amp;data)
+{
+	return CL_DomText(*this, data);
+}
+
+CL_DomComment CL_DomDocument::create_comment(const std::string &amp;data)
+{
+	return CL_DomComment(*this, data);
+}
+
+CL_DomCDATASection CL_DomDocument::create_cdata_section(const std::string &amp;data)
+{
+	return CL_DomCDATASection(*this, data);
+}
+
+CL_DomProcessingInstruction CL_DomDocument::create_processing_instruction(
+	const std::string &amp;target,
+	const std::string &amp;data)
+{
+	return CL_DomProcessingInstruction(*this, target, data);
+}
+
+CL_DomAttr CL_DomDocument::create_attribute(const std::string &amp;name)
+{
+	return CL_DomAttr(*this, name);
+}
+
+CL_DomEntityReference CL_DomDocument::create_entity_reference(const std::string &amp;name)
+{
+	return CL_DomEntityReference(*this, name);
+}
+
+CL_DomNodeList CL_DomDocument::get_elements_by_tag_name(const std::string &amp;tag_name)
+{
+	return CL_DomNodeList(*this, tag_name);
+}
+
+std::vector&lt;CL_DomNode&gt; CL_DomDocument::load(
+	CL_InputSource *input,
+	bool delete_input,
+	bool eat_whitespace,
+	CL_DomNode insert_point)
+{
+	clear_all();
+
+	CL_XMLTokenizer tokenizer(input, delete_input);
+	tokenizer.set_eat_whitespace(eat_whitespace);
+
+	if (insert_point.is_element() == false)
+		insert_point = *this;
+		
+	std::stack&lt;CL_DomNode&gt; node_stack;
+	node_stack.push(insert_point);
+
+	std::vector&lt;CL_DomNode&gt; result;
+	
+	try
+	{
+		CL_XMLTokenLoad cur_token = tokenizer.next();
+		while (cur_token.get_type() != CL_XMLToken::NULL_TOKEN)
+		{
+			switch (cur_token.get_type())
+			{
+			case CL_XMLToken::TEXT_TOKEN:
+				node_stack.top().append_child(create_text_node(cur_token.get_value()));
+				if (node_stack.top() == insert_point)
+					result.push_back(node_stack.top().get_last_child());
+				break;
+
+			case CL_XMLToken::CDATA_SECTION_TOKEN:
+				node_stack.top().append_child(create_cdata_section(cur_token.get_value()));
+				if (node_stack.top() == insert_point)
+					result.push_back(node_stack.top().get_last_child());
+				break;
+
+			case CL_XMLToken::ELEMENT_TOKEN:
+				if (cur_token.get_variant() != CL_XMLToken::END)
+				{
+					CL_DomElement element = create_element(cur_token.get_name());
+					node_stack.top().append_child(element);
+					if (node_stack.top() == insert_point)
+						result.push_back(node_stack.top().get_last_child());
+
+					int size = cur_token.get_attributes_number();
+					for (int i=0; i&lt;size; i++)
+					{
+						std::pair&lt;CL_XMLTokenString, CL_XMLTokenString&gt; const &amp; attribute = cur_token.get_attribute_fast(i);
+						element.set_attribute(attribute.first.to_string(), attribute.second.to_string());
+					}
+				
+					if (cur_token.get_variant() == CL_XMLToken::BEGIN)
+						node_stack.push(element);
+				}
+				else
+				{
+					node_stack.pop();
+					if (node_stack.empty()) throw CL_Error(&quot;Malformed XML tree!&quot;);
+				}
+				break;
+
+			case CL_XMLToken::NULL_TOKEN: 
+				break;
+
+			case CL_XMLToken::ENTITY_REFERENCE_TOKEN: 
+				break;
+
+			case CL_XMLToken::ENTITY_TOKEN: 
+				break;
+			
+			case CL_XMLToken::COMMENT_TOKEN:
+				break;
+
+			case CL_XMLToken::DOCUMENT_TYPE_TOKEN:
+				break;
+
+			case CL_XMLToken::NOTATION_TOKEN:
+				break;
+
+			case CL_XMLToken::PROCESSING_INSTRUCTION_TOKEN:
+				break;
+			}		
+
+			cur_token = tokenizer.next();
+		}
+	}
+	catch (CL_Error e)
+	{
+		for (std::vector&lt;CL_DomNode&gt;::size_type i = 0; i &lt; result.size(); i++)
+		{
+			insert_point.remove_child(result[i]);
+		}
+		throw e;
+	}
+	return result;
+}
+
+void CL_DomDocument::save(CL_OutputSource *output, bool delete_output, bool insert_whitespace)
+{
+	CL_XMLWriter writer(output, delete_output);
+	writer.set_insert_whitespace(insert_whitespace);
+
+	std::stack&lt;CL_DomNode&gt; node_stack;
+	CL_DomNode cur_node = get_first_child();
+	while (!cur_node.is_null())
+	{
+		// Create opening node:
+		CL_XMLTokenSave opening_node;
+		opening_node.set_type((CL_XMLToken::TokenType) cur_node.get_node_type());
+		opening_node.set_variant(cur_node.has_child_nodes() ? CL_XMLToken::BEGIN : CL_XMLToken::SINGLE);
+		opening_node.set_name(cur_node.get_node_name());
+		opening_node.set_value(cur_node.get_node_value());
+		if (cur_node.is_element())
+		{
+			for (int i = 0; i &lt; cur_node.impl-&gt;attributes.get_length(); ++i)
+			{
+				opening_node.set_attribute(cur_node.impl-&gt;attributes.item(i).to_attr().get_name(),
+													cur_node.impl-&gt;attributes.item(i).to_attr().get_value());
+			}
+		}
+		writer.write(opening_node);
+
+		// Create any possible child nodes:
+		if (cur_node.has_child_nodes())
+		{
+			node_stack.push(cur_node);
+			cur_node = cur_node.get_first_child();
+			continue;
+		}
+
+		// Create closing nodes until we reach next opening node in tree:
+		while (true)
+		{
+			if (cur_node.has_child_nodes())
+			{
+				CL_XMLTokenSave closing_node;
+				closing_node.set_type((CL_XMLToken::TokenType) cur_node.get_node_type());
+				closing_node.set_name(cur_node.get_node_name());
+				closing_node.set_variant(CL_XMLToken::END);
+				writer.write(closing_node);
+			}
+
+			cur_node = cur_node.get_next_sibling();
+			if (!cur_node.is_null()) break;
+			if (node_stack.empty()) break;
+
+			cur_node = node_stack.top();
+			node_stack.pop();
+		}
+	}
+}
+
+void CL_DomDocument::clear_all()
+{
+	while (!get_first_child().is_null())
+	{
+		CL_DomNode node = get_first_child();
+		remove_child(node);
+	}
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomDocument implementation:

Added: trunk/clanlib/Core/XML/dom_document_fragment.cpp
===================================================================
--- trunk/clanlib/Core/XML/dom_document_fragment.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/dom_document_fragment.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,55 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/XML/dom_document_fragment.h&quot;
+#include &quot;dom_node_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomDocumentFragment construction:
+
+CL_DomDocumentFragment::CL_DomDocumentFragment()
+{
+}
+
+CL_DomDocumentFragment::CL_DomDocumentFragment(CL_DomDocument &amp;doc)
+: CL_DomNode(doc, DOCUMENT_FRAGMENT_NODE)
+{
+}
+
+CL_DomDocumentFragment::CL_DomDocumentFragment(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl) : CL_DomNode(impl)
+{
+}
+
+CL_DomDocumentFragment::~CL_DomDocumentFragment()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomDocumentFragment implementation:

Added: trunk/clanlib/Core/XML/dom_document_generic.cpp
===================================================================
--- trunk/clanlib/Core/XML/dom_document_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/dom_document_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,44 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/XML/dom_node.h&quot;
+#include &quot;dom_document_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomDocument_Generic construction:
+
+CL_DomDocument_Generic::CL_DomDocument_Generic()
+{
+	node_type = CL_DomNode::DOCUMENT_NODE;
+}
+
+CL_DomDocument_Generic::~CL_DomDocument_Generic()
+{
+}

Added: trunk/clanlib/Core/XML/dom_document_generic.h
===================================================================
--- trunk/clanlib/Core/XML/dom_document_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/dom_document_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,48 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_dom_document_generic
+#define header_dom_document_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;dom_node_generic.h&quot;
+
+class CL_DomDocument_Generic : public CL_DomNode_Generic
+{
+//! Construction:
+public:
+	CL_DomDocument_Generic();
+
+	~CL_DomDocument_Generic();
+};
+
+#endif

Added: trunk/clanlib/Core/XML/dom_document_type.cpp
===================================================================
--- trunk/clanlib/Core/XML/dom_document_type.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/dom_document_type.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,78 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/XML/dom_document_type.h&quot;
+#include &quot;API/Core/XML/dom_named_node_map.h&quot;
+#include &quot;dom_node_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomDocumentType construction:
+
+CL_DomDocumentType::CL_DomDocumentType()
+{
+}
+
+CL_DomDocumentType::CL_DomDocumentType(CL_DomDocument &amp;doc)
+: CL_DomNode(doc, DOCUMENT_TYPE_NODE)
+{
+}
+
+CL_DomDocumentType::CL_DomDocumentType(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl) : CL_DomNode(impl)
+{
+}
+	
+CL_DomDocumentType::~CL_DomDocumentType()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomDocumentType attributes:
+
+std::string CL_DomDocumentType::get_name() const
+{
+	if (impl) return impl-&gt;node_name;
+	return std::string();
+}
+	
+CL_DomNamedNodeMap CL_DomDocumentType::get_entities() const
+{
+	return CL_DomNamedNodeMap();
+}
+	
+CL_DomNamedNodeMap CL_DomDocumentType::get_notations() const
+{
+	return CL_DomNamedNodeMap();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomDocumentType operations:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomDocumentType implementation:

Added: trunk/clanlib/Core/XML/dom_element.cpp
===================================================================
--- trunk/clanlib/Core/XML/dom_element.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/dom_element.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,154 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;API/Core/XML/dom_node_list.h&quot;
+#include &quot;API/Core/XML/dom_attr.h&quot;
+#include &quot;API/Core/XML/dom_document.h&quot;
+#include &quot;dom_node_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomElement construction:
+
+CL_DomElement::CL_DomElement()
+{
+}
+
+CL_DomElement::CL_DomElement(CL_DomDocument &amp;doc, const std::string &amp;tag_name)
+: CL_DomNode(doc, ELEMENT_NODE)
+{
+	impl-&gt;node_name = tag_name;
+}
+
+CL_DomElement::CL_DomElement(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl) : CL_DomNode(impl)
+{
+}
+
+CL_DomElement::~CL_DomElement()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomElement attributes:
+
+std::string CL_DomElement::get_tag_name() const
+{
+	if (impl) return impl-&gt;node_name;
+	return std::string();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomElement operations:
+
+bool CL_DomElement::has_attribute(const std::string &amp;name) const
+{
+	if (impl)
+	{
+		for(int i = 0; i &lt; (int)impl-&gt;attributes.get_length(); ++i)
+			if (impl-&gt;attributes.item(i).to_attr().get_name() == name)
+				return true;
+	}
+	return false;
+}
+
+std::string CL_DomElement::get_attribute(const std::string &amp;name) const
+{
+	if (impl)
+	{
+		for(int i = 0; i &lt; (int)impl-&gt;attributes.get_length(); ++i)
+			if (impl-&gt;attributes.item(i).to_attr().get_name() == name)
+				return impl-&gt;attributes.item(i).to_attr().get_value();
+	}
+	return std::string();
+}
+
+std::string CL_DomElement::get_attribute(const std::string &amp;name, const std::string &amp;default_value) const
+{
+	if (impl)
+	{
+		for(int i = 0; i &lt; (int)impl-&gt;attributes.get_length(); ++i)
+			if (impl-&gt;attributes.item(i).to_attr().get_name() == name)
+				return impl-&gt;attributes.item(i).to_attr().get_value();
+	}
+	return default_value;
+}
+
+void CL_DomElement::set_attribute(const std::string &amp;name, const std::string &amp;value)
+{
+	if (impl)
+	{
+		for(int i = 0; i &lt; (int)impl-&gt;attributes.get_length(); ++i)
+			if (impl-&gt;attributes.item(i).to_attr().get_name() == name)
+			{
+				impl-&gt;attributes.item(i).to_attr().set_value(value);
+				return;
+			}
+
+		CL_DomAttr attr(get_owner_document(), name);
+		impl-&gt;attributes.set_named_item(attr);
+		attr.impl-&gt;node_value = value;
+	}
+}
+
+void CL_DomElement::remove_attribute(const std::string &amp;name)
+{
+	if (impl)
+	{
+		impl-&gt;attributes.remove_named_item(name);
+	}
+}
+
+CL_DomNodeList CL_DomElement::get_elements_by_tag_name(const std::string &amp;name)
+{
+	return CL_DomNodeList(*this, name);
+}
+
+std::string CL_DomElement::get_text() const
+{
+	std::string str;
+	if (has_child_nodes() == false)
+		return str;
+
+	CL_DomNode cur = get_first_child();
+	while (!cur.is_null())
+	{
+		if (cur.is_text())
+			str.append(cur.get_node_value());
+		cur = cur.get_next_sibling();
+	}
+	return str;
+}
+
+void CL_DomElement::normalize()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomElement implementation:

Added: trunk/clanlib/Core/XML/dom_entity.cpp
===================================================================
--- trunk/clanlib/Core/XML/dom_entity.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/dom_entity.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,70 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/XML/dom_entity.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomEntity construction:
+
+CL_DomEntity::CL_DomEntity()
+{
+}
+
+CL_DomEntity::CL_DomEntity(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl) : CL_DomNode(impl)
+{
+}
+	
+CL_DomEntity::~CL_DomEntity()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomEntity attributes:
+
+std::string CL_DomEntity::get_public_id() const
+{
+	return std::string();
+}
+	
+std::string CL_DomEntity::get_system_id() const
+{
+	return std::string();
+}
+	
+std::string CL_DomEntity::get_notation_name() const
+{
+	return std::string();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomEntity operations:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomEntity implementation:

Added: trunk/clanlib/Core/XML/dom_entity_reference.cpp
===================================================================
--- trunk/clanlib/Core/XML/dom_entity_reference.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/dom_entity_reference.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,62 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/XML/dom_entity_reference.h&quot;
+#include &quot;dom_node_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomEntityReference construction:
+
+CL_DomEntityReference::CL_DomEntityReference()
+{
+}
+
+CL_DomEntityReference::CL_DomEntityReference(CL_DomDocument &amp;doc, const std::string &amp;name)
+: CL_DomNode(doc, ENTITY_REFERENCE_NODE)
+{
+	impl-&gt;node_name = name;
+}
+
+CL_DomEntityReference::CL_DomEntityReference(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl) : CL_DomNode(impl)
+{
+}
+
+CL_DomEntityReference::~CL_DomEntityReference()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomEntityReference attributes:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomEntityReference operations:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomEntityReference implementation:

Added: trunk/clanlib/Core/XML/dom_exception.cpp
===================================================================
--- trunk/clanlib/Core/XML/dom_exception.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/dom_exception.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,87 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/XML/dom_exception.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomException construction:
+
+static std::string code_to_message(unsigned short code)
+{
+	switch (code)
+	{
+	case CL_DomException::DOMSTRING_SIZE_ERR:
+		return &quot;DOMSTRING_SIZE_ERR: Specified range of text does not fit into a DOMString&quot;;
+		
+	case CL_DomException::HIERARCHY_REQUEST_ERR:
+		return &quot;HIERARCHY_REQUEST_ERR: Attemped to insert node where it doesn't belong&quot;;
+		
+	case CL_DomException::INDEX_SIZE_ERR:
+		return &quot;INDEX_SIZE_ERR: Index or size is negative, or greater than the allowed value&quot;;
+		
+	case CL_DomException::INUSE_ATTRIBUTE_ERR:
+		return &quot;INUSE_ATTRIBUTE_ERR: An attempt was made to add an attribute that is already in use elsewhere&quot;;
+		
+	case CL_DomException::INVALID_CHARACTER_ERR:
+		return &quot;INVALID_CHARACTER_ERR: An invalid or illegal character was specified, such as in a name&quot;;
+		
+	case CL_DomException::NOT_FOUND_ERR:
+		return &quot;NOT_FOUND_ERR: An attempt was made to reference a node in a context where it does not exist&quot;;
+		
+	case CL_DomException::NOT_SUPPORTED_ERR:
+		return &quot;NOT_SUPPORTED_ERR: The implementation does not support the type of object requested&quot;;
+		
+	case CL_DomException::NO_DATA_ALLOWED_ERR:
+		return &quot;NO_DATA_ALLOWED_ERR: Data was specified for a node which does not support data&quot;;
+		
+	case CL_DomException::NO_MODIFICATION_ALLOWED_ERR:
+		return &quot;NO_MODIFICATION_ALLOWED_ERR: An attempt was made to modify an object where modifications are not allowed&quot;;
+		
+	case CL_DomException::WRONG_DOCUMENT_ERR:
+		return &quot;WRONG_DOCUMENT_ERR: A node was used in a different document than the one that created it&quot;;
+	}
+
+	return CL_String::format(&quot;Unknown DOM exception code %1&quot;, code);
+}
+
+CL_DomException::CL_DomException(unsigned short code) : CL_Error(code_to_message(code)), code(code)
+{
+}
+
+CL_DomException::CL_DomException(const std::string &amp;message, unsigned short code) : CL_Error(message), code(code)
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomException attributes:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomException implementation:

Added: trunk/clanlib/Core/XML/dom_implementation.cpp
===================================================================
--- trunk/clanlib/Core/XML/dom_implementation.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/dom_implementation.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,67 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/XML/dom_implementation.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomImplementation construction:
+
+CL_DomImplementation::CL_DomImplementation()
+{
+}
+
+CL_DomImplementation::CL_DomImplementation(CL_DomDocument &amp;doc)
+{
+}
+
+CL_DomImplementation::~CL_DomImplementation()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomImplementation attributes:
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomImplementation operations:
+
+bool CL_DomImplementation::has_feature(
+	const std::string &amp;feature,
+	const std::string &amp;version)
+{
+	if (CL_String::to_lower(feature) == &quot;xml&quot; &amp;&amp; (version == &quot;1.0&quot; || version.empty()))
+		return true;
+
+	return false;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomImplementation implementation:

Added: trunk/clanlib/Core/XML/dom_named_node_map.cpp
===================================================================
--- trunk/clanlib/Core/XML/dom_named_node_map.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/dom_named_node_map.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,109 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/System/cl_assert.h&quot;
+#include &quot;Core/XML/dom_named_node_map_generic.h&quot;
+#include &quot;API/Core/XML/dom_named_node_map.h&quot;
+#include &quot;API/Core/XML/dom_attr.h&quot;
+#include &quot;API/Core/XML/dom_node.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomNamedNodeMap construction:
+
+CL_DomNamedNodeMap::CL_DomNamedNodeMap()
+{
+	impl = new CL_DomNamedNodeMap_Generic();
+}
+
+CL_DomNamedNodeMap::CL_DomNamedNodeMap(CL_DomNode &amp;node)
+{
+	// FIXME: Not sure what this should do
+	cl_assert(0);
+}
+
+CL_DomNamedNodeMap::~CL_DomNamedNodeMap()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomNamedNodeMap attributes:
+
+int CL_DomNamedNodeMap::get_length() const
+{
+	return impl-&gt;attributes.size();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomNamedNodeMap operations:
+
+CL_DomNode CL_DomNamedNodeMap::get_named_item(const std::string &amp;name) const
+{
+	int size = impl-&gt;attributes.size();
+	for (int i=0; i&lt;size; i++)
+	{
+		if (impl-&gt;attributes[i].first == name)
+		{
+			return CL_DomNode(impl-&gt;attributes[i].second);
+		}
+	}
+	return CL_DomNode();
+}
+
+CL_DomNode CL_DomNamedNodeMap::set_named_item(const CL_DomNode &amp;node)
+{
+	int size = impl-&gt;attributes.size();
+	for (int i=0; i&lt;size; i++)
+	{
+		if (impl-&gt;attributes[i].first == node.to_attr().get_name())
+		{
+			CL_DomNode oldnode(impl-&gt;attributes[i].second);
+			impl-&gt;attributes[i].second = node;
+			return oldnode;
+		}
+	}
+	
+	impl-&gt;attributes.push_back(std::pair&lt;std::string, CL_DomNode&gt;(node.to_attr().get_name(), node));
+
+	return CL_DomNode();
+}
+
+CL_DomNode CL_DomNamedNodeMap::remove_named_item(const std::string &amp;name)
+{
+	// FIXME: Implement me
+	return CL_DomNode();
+}
+
+CL_DomNode CL_DomNamedNodeMap::item(unsigned long index) const
+{
+	return CL_DomNode(impl-&gt;attributes[index].second);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomNamedNodeMap implementation:

Added: trunk/clanlib/Core/XML/dom_named_node_map_generic.h
===================================================================
--- trunk/clanlib/Core/XML/dom_named_node_map_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/dom_named_node_map_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,63 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_dom_named_node_map_generic
+#define header_dom_named_node_map_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/System/sharedptr.h&quot;
+#include &quot;API/Core/XML/dom_node.h&quot;
+
+class CL_DomNamedNodeMap_Generic
+{
+//! Construction:
+public:
+	CL_DomNamedNodeMap_Generic()
+	{
+	}
+
+	virtual ~CL_DomNamedNodeMap_Generic()
+	{
+	}
+
+//! Attributes:
+public:
+	std::vector&lt;std::pair&lt;std::string, CL_DomNode&gt; &gt; attributes;
+
+//! Operations:
+public:
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/Core/XML/dom_node.cpp
===================================================================
--- trunk/clanlib/Core/XML/dom_node.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/dom_node.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,462 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/XML/dom_node.h&quot;
+#include &quot;API/Core/XML/dom_node_list.h&quot;
+#include &quot;API/Core/XML/dom_named_node_map.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;API/Core/XML/dom_attr.h&quot;
+#include &quot;API/Core/XML/dom_text.h&quot;
+#include &quot;API/Core/XML/dom_cdata_section.h&quot;
+#include &quot;API/Core/XML/dom_entity_reference.h&quot;
+#include &quot;API/Core/XML/dom_entity.h&quot;
+#include &quot;API/Core/XML/dom_processing_instruction.h&quot;
+#include &quot;API/Core/XML/dom_comment.h&quot;
+#include &quot;API/Core/XML/dom_document.h&quot;
+#include &quot;API/Core/XML/dom_document_type.h&quot;
+#include &quot;API/Core/XML/dom_document_fragment.h&quot;
+#include &quot;API/Core/XML/dom_notation.h&quot;
+#include &quot;dom_node_generic.h&quot;
+#include &quot;dom_document_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomNode construction:
+
+CL_DomNode::CL_DomNode()
+{
+}
+
+CL_DomNode::CL_DomNode(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl) : impl(impl)
+{
+}
+
+CL_DomNode::CL_DomNode(const CL_DomNode &amp;copy) : impl(copy.impl)
+{
+}
+
+CL_DomNode::CL_DomNode(CL_DomDocument &amp;doc, unsigned short node_type)
+: impl(new CL_DomNode_Generic)
+{
+	impl-&gt;owner_document = doc.impl;
+	impl-&gt;node_type = node_type;
+}
+
+CL_DomNode::~CL_DomNode()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomNode attributes:
+
+std::string CL_DomNode::get_node_name() const
+{
+	if (!impl.is_null())
+	{
+		switch (impl-&gt;node_type)
+		{
+		case CDATA_SECTION_NODE:
+			return &quot;#cdata-section&quot;;
+		case COMMENT_NODE:
+			return &quot;#comment&quot;;
+		case DOCUMENT_NODE:
+			return &quot;#document&quot;;
+		case DOCUMENT_FRAGMENT_NODE:
+			return &quot;#document-fragment&quot;;
+		case TEXT_NODE:
+			return &quot;#text&quot;;
+		case ATTRIBUTE_NODE:
+		case DOCUMENT_TYPE_NODE:
+		case ELEMENT_NODE:
+		case ENTITY_NODE:
+		case ENTITY_REFERENCE_NODE:
+		case NOTATION_NODE:
+		case PROCESSING_INSTRUCTION_NODE:
+		default:
+			return impl-&gt;node_name;
+		}
+	}
+	return std::string();
+}
+
+std::string CL_DomNode::get_node_value() const
+{
+	if (!impl.is_null())
+	{
+		switch (impl-&gt;node_type)
+		{
+		case DOCUMENT_NODE:
+		case DOCUMENT_FRAGMENT_NODE:
+		case DOCUMENT_TYPE_NODE:
+		case ELEMENT_NODE:
+		case ENTITY_NODE:
+		case ENTITY_REFERENCE_NODE:
+		case NOTATION_NODE:
+			return std::string();
+
+		case TEXT_NODE:
+		case ATTRIBUTE_NODE:
+		case PROCESSING_INSTRUCTION_NODE:
+		default:
+			return impl-&gt;node_value;
+		}
+	}
+	return std::string();
+}
+
+void CL_DomNode::set_node_value(const std::string &amp;value)
+{
+	if (!impl.is_null()) impl-&gt;node_value = value;
+}
+
+unsigned short CL_DomNode::get_node_type() const
+{
+	if (!impl.is_null()) return impl-&gt;node_type;
+	return NULL_NODE;
+}
+
+CL_DomNode CL_DomNode::get_parent_node() const
+{
+	if (!impl.is_null()) return CL_DomNode(impl-&gt;parent);
+	return CL_DomNode();
+}
+
+CL_DomNodeList CL_DomNode::get_child_nodes() const
+{
+	CL_DomNodeList lst;
+	CL_DomNode node = get_first_child();
+	while(!node.is_null()) 
+	{
+		lst.add_item(node);
+		node = node.get_next_sibling();
+	}
+	return lst;
+}
+
+CL_DomNode CL_DomNode::get_first_child() const
+{
+	if (!impl.is_null()) return CL_DomNode(impl-&gt;first_child);
+	return CL_DomNode();
+}
+
+CL_DomNode CL_DomNode::get_last_child() const
+{
+	if (!impl.is_null()) return CL_DomNode(impl-&gt;last_child);
+	return CL_DomNode();
+}
+
+CL_DomNode CL_DomNode::get_previous_sibling() const
+{
+	if (!impl.is_null()) return CL_DomNode(impl-&gt;previous_sibling);
+	return CL_DomNode();
+}
+
+CL_DomNode CL_DomNode::get_next_sibling() const
+{
+	if (!impl.is_null()) return CL_DomNode(impl-&gt;next_sibling);
+	return CL_DomNode();
+}
+
+CL_DomNamedNodeMap CL_DomNode::get_attributes()
+{
+	if (!impl.is_null() &amp;&amp; impl-&gt;node_type == ELEMENT_NODE)
+		return impl-&gt;attributes;
+	return CL_DomNamedNodeMap();
+}
+
+CL_DomDocument CL_DomNode::get_owner_document()
+{
+	if (!impl.is_null()) return CL_DomDocument(impl-&gt;owner_document);
+	return CL_DomDocument();
+}
+
+bool CL_DomNode::is_null() const
+{
+	return get_node_type() == NULL_NODE;
+}
+
+bool CL_DomNode::is_element() const
+{
+	return get_node_type() == ELEMENT_NODE;
+}
+
+bool CL_DomNode::is_attr() const
+{
+	return get_node_type() == ATTRIBUTE_NODE;
+}
+
+bool CL_DomNode::is_text() const
+{
+	return get_node_type() == TEXT_NODE;
+}
+
+bool CL_DomNode::is_cdata_section() const
+{
+	return get_node_type() == CDATA_SECTION_NODE;
+}
+
+bool CL_DomNode::is_entity_reference() const
+{
+	return get_node_type() == ENTITY_REFERENCE_NODE;
+}
+
+bool CL_DomNode::is_entity() const
+{
+	return get_node_type() == ENTITY_NODE;
+}
+
+bool CL_DomNode::is_processing_instruction() const
+{
+	return get_node_type() == PROCESSING_INSTRUCTION_NODE;
+}
+
+bool CL_DomNode::is_comment() const
+{
+	return get_node_type() == COMMENT_NODE;
+}
+
+bool CL_DomNode::is_document() const
+{
+	return get_node_type() == DOCUMENT_NODE;
+}
+
+bool CL_DomNode::is_document_type() const
+{
+	return get_node_type() == DOCUMENT_TYPE_NODE;
+}
+
+bool CL_DomNode::is_document_fragment() const
+{
+	return get_node_type() == DOCUMENT_FRAGMENT_NODE;
+}
+
+bool CL_DomNode::is_notation() const
+{
+	return get_node_type() == NOTATION_NODE;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomNode operations:
+
+CL_DomNode &amp;CL_DomNode::operator =(const CL_DomNode &amp;copy)
+{
+	impl = copy.impl;
+	return *this;
+}
+
+bool CL_DomNode::operator ==(const CL_DomNode &amp;other) const
+{
+	return (impl == other.impl);
+}
+
+CL_DomNode CL_DomNode::insert_before(CL_DomNode &amp;new_child, CL_DomNode &amp;ref_child)
+{
+	if (!impl.is_null())
+	{
+		new_child.impl-&gt;previous_sibling = ref_child.impl-&gt;previous_sibling;
+		new_child.impl-&gt;next_sibling = ref_child.impl;
+		ref_child.impl-&gt;previous_sibling = new_child.impl;
+		if (!new_child.impl-&gt;previous_sibling.is_null())
+			new_child.impl-&gt;previous_sibling-&gt;next_sibling = new_child.impl;
+		if (impl-&gt;first_child == ref_child.impl) impl-&gt;first_child = new_child.impl;
+		new_child.impl-&gt;parent = impl;
+
+		return new_child;
+	}
+	return CL_DomNode();
+}
+
+CL_DomNode CL_DomNode::replace_child(CL_DomNode &amp;new_child, CL_DomNode &amp;old_child)
+{
+	if (!impl.is_null())
+	{
+		CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;prev = old_child.impl-&gt;previous_sibling;
+		CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;next = old_child.impl-&gt;next_sibling;
+
+		// update child siblings
+		if (!next.is_null()) next-&gt;previous_sibling = new_child.impl;
+		if (!prev.is_null()) prev-&gt;next_sibling = new_child.impl;
+
+		// update new child
+		new_child.impl-&gt;previous_sibling = prev;
+		new_child.impl-&gt;next_sibling = next;
+		new_child.impl-&gt;parent = impl;
+
+		// update self (parent)
+		if (impl-&gt;first_child == old_child.impl) impl-&gt;first_child = new_child.impl;
+		if (impl-&gt;last_child == old_child.impl) impl-&gt;last_child = new_child.impl;
+
+		// update old child
+		old_child.impl-&gt;previous_sibling = CL_SharedPtr&lt;CL_DomNode_Generic&gt;();
+		old_child.impl-&gt;next_sibling = CL_SharedPtr&lt;CL_DomNode_Generic&gt;();
+		old_child.impl-&gt;parent = CL_WeakPtr&lt;CL_DomNode_Generic&gt;();
+		return new_child;
+	}
+	return CL_DomNode();
+}
+
+CL_DomNode CL_DomNode::remove_child(CL_DomNode &amp;old_child)
+{
+	if (!impl.is_null())
+	{
+		CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;prev = old_child.impl-&gt;previous_sibling;
+		CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;next = old_child.impl-&gt;next_sibling;
+		if (!next.is_null()) next-&gt;previous_sibling = prev;
+		if (!prev.is_null()) prev-&gt;next_sibling = next;
+		if (impl-&gt;first_child == old_child.impl) impl-&gt;first_child = next;
+		if (impl-&gt;last_child == old_child.impl) impl-&gt;last_child = prev;
+		old_child.impl-&gt;previous_sibling = CL_SharedPtr&lt;CL_DomNode_Generic&gt;();
+		old_child.impl-&gt;next_sibling = CL_SharedPtr&lt;CL_DomNode_Generic&gt;();
+		old_child.impl-&gt;parent = CL_WeakPtr&lt;CL_DomNode_Generic&gt;();
+	}
+	return CL_DomNode();
+}
+
+CL_DomNode CL_DomNode::append_child(CL_DomNode new_child)
+{
+	if (!impl.is_null())
+	{
+		if (!impl-&gt;last_child.is_null())
+		{
+			impl-&gt;last_child-&gt;next_sibling = new_child.impl;
+			new_child.impl-&gt;previous_sibling = impl-&gt;last_child;
+			impl-&gt;last_child = new_child.impl;
+		}
+		else
+		{
+			impl-&gt;first_child = new_child.impl;
+			impl-&gt;last_child = new_child.impl;
+		}
+		new_child.impl-&gt;parent = impl;
+		return new_child;
+	}
+	return CL_DomNode();
+}
+
+bool CL_DomNode::has_child_nodes() const
+{
+	if (!impl.is_null()) return !impl-&gt;first_child.is_null();
+	return false;
+}
+
+CL_DomNode CL_DomNode::clone_node(bool deep) const
+{
+	return CL_DomNode();
+}
+
+bool CL_DomNode::is_same_node(const CL_DomNode &amp;node) const
+{
+	return impl.get() == node.impl.get();
+}
+
+CL_DomElement CL_DomNode::to_element() const
+{
+	if (is_element()) return CL_DomElement(impl);
+	return CL_DomElement();
+}
+
+CL_DomAttr CL_DomNode::to_attr() const
+{
+	if (is_attr()) return CL_DomAttr(impl);
+	return CL_DomAttr();
+}
+
+CL_DomText CL_DomNode::to_text() const
+{
+	if (is_text()) return CL_DomText(impl);
+	return CL_DomText();
+}
+
+CL_DomCDATASection CL_DomNode::to_cdata_section() const
+{
+	if (is_cdata_section()) return CL_DomCDATASection(impl);
+	return CL_DomCDATASection();
+}
+
+CL_DomEntityReference CL_DomNode::to_entity_reference() const
+{
+	if (is_entity_reference()) return CL_DomEntityReference(impl);
+	return CL_DomEntityReference();
+}
+
+CL_DomEntity CL_DomNode::to_entity() const
+{
+	if (is_entity()) return CL_DomEntity(impl);
+	return CL_DomEntity();
+}
+
+CL_DomProcessingInstruction CL_DomNode::to_processing_instruction() const
+{
+	if (is_processing_instruction()) return CL_DomProcessingInstruction(impl);
+	return CL_DomProcessingInstruction();
+}
+
+CL_DomComment CL_DomNode::to_comment() const
+{
+	if (is_comment()) return CL_DomComment(impl);
+	return CL_DomComment();
+}
+
+CL_DomDocument CL_DomNode::to_document() const
+{
+	if (is_document()) return CL_DomDocument(impl);
+	return CL_DomDocument();
+}
+
+CL_DomDocumentType CL_DomNode::to_document_type() const
+{
+	if (is_document_type()) return CL_DomDocumentType(impl);
+	return CL_DomDocumentType();
+}
+
+CL_DomDocumentFragment CL_DomNode::to_document_fragment() const
+{
+	if (is_document_fragment()) return CL_DomDocumentFragment(impl);
+	return CL_DomDocumentFragment();
+}
+
+CL_DomNotation CL_DomNode::to_notation() const
+{
+	if (is_notation()) return CL_DomNotation(impl);
+	return CL_DomNotation();
+}
+
+CL_DomNode CL_DomNode::named_item(const std::string &amp;name) const
+{
+	CL_DomNode node = get_first_child();
+	while (node.is_null() == false)
+	{
+		if (node.get_node_name() == name) return node;
+		node = node.get_next_sibling();
+	}
+	return CL_DomNode();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomNode implementation:

Added: trunk/clanlib/Core/XML/dom_node_generic.h
===================================================================
--- trunk/clanlib/Core/XML/dom_node_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/dom_node_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,99 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_dom_node_generic
+#define header_dom_node_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/System/sharedptr.h&quot;
+#include &quot;API/Core/System/weakptr.h&quot;
+#include &quot;API/Core/XML/dom_named_node_map.h&quot;
+
+#include &lt;map&gt;
+#include &lt;string&gt;
+
+class CL_DomDocument_Generic;
+
+class CL_DomNode_Generic
+{
+//! Construction:
+public:
+	CL_DomNode_Generic()
+	{
+	}
+
+	virtual ~CL_DomNode_Generic()
+	{
+		CL_SharedPtr&lt;CL_DomNode_Generic&gt; temp = last_child;
+
+		while (!temp.is_null ())
+		{ 
+			temp-&gt;free_refs ();
+
+			temp = temp-&gt;previous_sibling;
+		}
+	}
+
+//! Attributes:
+public:
+	std::string node_name;
+
+	std::string node_value;
+
+	unsigned short node_type;
+
+	CL_WeakPtr&lt;CL_DomNode_Generic&gt; parent;
+
+	CL_SharedPtr&lt;CL_DomNode_Generic&gt; first_child;
+
+	CL_SharedPtr&lt;CL_DomNode_Generic&gt; last_child;
+
+	CL_SharedPtr&lt;CL_DomNode_Generic&gt; previous_sibling;
+
+	CL_SharedPtr&lt;CL_DomNode_Generic&gt; next_sibling;
+
+	CL_WeakPtr&lt;CL_DomNode_Generic&gt; owner_document;
+
+	CL_DomNamedNodeMap attributes;
+
+//! Operations:
+public:
+
+//! Implementation:
+private:
+	void free_refs (void)
+	{
+		next_sibling.release ();
+	};
+};
+
+#endif

Added: trunk/clanlib/Core/XML/dom_node_list.cpp
===================================================================
--- trunk/clanlib/Core/XML/dom_node_list.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/dom_node_list.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,85 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/XML/dom_node_list.h&quot;
+#include &quot;API/Core/XML/dom_node.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomNodeList construction:
+
+CL_DomNodeList::CL_DomNodeList()
+{
+}
+
+CL_DomNodeList::CL_DomNodeList(CL_DomNode &amp;node, const std::string &amp;tag_name)
+{
+	CL_DomNode current_child=node.get_first_child();
+	while(!current_child.is_null())
+	{
+		if(current_child.get_node_name()==tag_name)
+		{
+			add_item(current_child);
+		}
+		current_child=current_child.get_next_sibling();
+	}
+}
+
+CL_DomNodeList::~CL_DomNodeList()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomNodeList attributes:
+
+int CL_DomNodeList::get_length() const
+{
+	return (node_list.size());
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomNodeList operations:
+
+CL_DomNode CL_DomNodeList::item(unsigned long index) const
+{
+	if( index &lt; 0 || index &gt;= node_list.size() )
+	{//if the given index is not valid
+		CL_DomNode empty_node;
+		return(empty_node);
+	}
+	std::vector&lt;CL_DomNode&gt;::const_iterator i=node_list.begin()+index;
+	return(*i);
+}
+
+void CL_DomNodeList::add_item(CL_DomNode &amp;to_add)
+{
+	node_list.push_back(to_add);
+}
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomNodeList implementation:

Added: trunk/clanlib/Core/XML/dom_notation.cpp
===================================================================
--- trunk/clanlib/Core/XML/dom_notation.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/dom_notation.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,65 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/XML/dom_notation.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomNotation construction:
+
+CL_DomNotation::CL_DomNotation()
+{
+}
+
+CL_DomNotation::CL_DomNotation(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl) : CL_DomNode(impl)
+{
+}
+	
+CL_DomNotation::~CL_DomNotation()
+{
+}
+	
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomNotation attributes:
+
+std::string CL_DomNotation::get_public_id() const
+{
+	return std::string();
+}
+
+std::string CL_DomNotation::get_system_id() const
+{
+	return std::string();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomNotation operations:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomNotation implementation:

Added: trunk/clanlib/Core/XML/dom_processing_instruction.cpp
===================================================================
--- trunk/clanlib/Core/XML/dom_processing_instruction.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/dom_processing_instruction.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,76 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/XML/dom_processing_instruction.h&quot;
+#include &quot;dom_node_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomProcessingInstruction construction:
+
+CL_DomProcessingInstruction::CL_DomProcessingInstruction()
+{
+}
+
+CL_DomProcessingInstruction::CL_DomProcessingInstruction(CL_DomDocument &amp;doc, const std::string &amp;target, const std::string &amp;data)
+: CL_DomNode(doc, PROCESSING_INSTRUCTION_NODE)
+{
+	impl-&gt;node_value = data;
+}
+
+CL_DomProcessingInstruction::CL_DomProcessingInstruction(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl) : CL_DomNode(impl)
+{
+}
+
+CL_DomProcessingInstruction::~CL_DomProcessingInstruction()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomProcessingInstruction attributes:
+
+std::string CL_DomProcessingInstruction::get_target() const
+{
+	return std::string();
+}
+
+std::string CL_DomProcessingInstruction::get_data() const
+{
+	return std::string();
+}
+
+void CL_DomProcessingInstruction::set_data(const std::string &amp;data)
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomProcessingInstruction operations:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomProcessingInstruction implementation:

Added: trunk/clanlib/Core/XML/dom_text.cpp
===================================================================
--- trunk/clanlib/Core/XML/dom_text.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/dom_text.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,72 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/XML/dom_text.h&quot;
+#include &quot;dom_node_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomText construction:
+
+CL_DomText::CL_DomText()
+{
+}
+
+CL_DomText::CL_DomText(CL_DomDocument &amp;doc, const std::string &amp;data)
+: CL_DomCharacterData(doc, TEXT_NODE)
+{
+	impl-&gt;node_value = data;
+}
+
+CL_DomText::CL_DomText(CL_DomDocument &amp;doc, unsigned short node_type)
+: CL_DomCharacterData(doc, node_type)
+{
+}
+
+CL_DomText::CL_DomText(const CL_SharedPtr&lt;CL_DomNode_Generic&gt; &amp;impl) : CL_DomCharacterData(impl)
+{
+}
+	
+CL_DomText::~CL_DomText()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomText attributes:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomText operations:
+
+CL_DomText CL_DomText::splitText(unsigned long offset)
+{
+	return CL_DomText();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DomText implementation:

Added: trunk/clanlib/Core/XML/xml_token_load.cpp
===================================================================
--- trunk/clanlib/Core/XML/xml_token_load.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/xml_token_load.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,132 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/XML/xml_token_load.h&quot;
+#include &quot;xml_token_load_generic.h&quot;
+#include &quot;API/Core/XML/xml_token_string.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_XMLTokenLoad construction:
+
+CL_XMLTokenLoad::CL_XMLTokenLoad()
+	: impl(new CL_XMLTokenLoad_Generic)
+{
+}
+	
+CL_XMLTokenLoad::CL_XMLTokenLoad(const CL_XMLTokenLoad &amp;copy)
+	: impl(copy.impl)
+{
+}
+	
+CL_XMLTokenLoad::~CL_XMLTokenLoad()
+{
+}
+	
+/////////////////////////////////////////////////////////////////////////////
+// CL_XMLTokenLoad attributes:
+
+CL_XMLToken::TokenType CL_XMLTokenLoad::get_type() const
+{
+	return impl-&gt;type;
+}
+
+CL_XMLToken::TokenVariant CL_XMLTokenLoad::get_variant() const
+{
+	return impl-&gt;variant;
+}
+
+std::string CL_XMLTokenLoad::get_name() const
+{
+	return impl-&gt;name.to_string();
+}
+
+std::string CL_XMLTokenLoad::get_value() const
+{
+	return impl-&gt;value.to_string();
+}
+
+int CL_XMLTokenLoad::get_attributes_number() const
+{
+	return impl-&gt;attributes.size();
+}
+
+std::pair&lt;std::string, std::string&gt; CL_XMLTokenLoad::get_attribute(int attribute_num) const
+{
+	if (attribute_num &lt; 0 || attribute_num &gt;= (int)impl-&gt;attributes.size())
+		return std::make_pair(std::string(), std::string());
+
+	std::pair&lt;CL_XMLTokenString, CL_XMLTokenString&gt; const &amp; attribute = impl-&gt;attributes[attribute_num];
+	return std::make_pair(attribute.first.to_string(), attribute.second.to_string());
+}
+
+const std::pair&lt;CL_XMLTokenString, CL_XMLTokenString&gt; &amp; CL_XMLTokenLoad::get_attribute_fast(int attribute_num) const
+{
+	return impl-&gt;attributes[attribute_num];
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_XMLTokenLoad operations:
+
+void CL_XMLTokenLoad::set_type(TokenType type)
+{
+	impl-&gt;type = type;
+}
+
+void CL_XMLTokenLoad::set_variant(TokenVariant variant)
+{
+	impl-&gt;variant = variant;
+}
+
+void CL_XMLTokenLoad::set_name(const CL_XMLTokenString &amp; name)
+{
+	impl-&gt;name = name;
+}
+
+void CL_XMLTokenLoad::set_value(const CL_XMLTokenString &amp; value)
+{
+	impl-&gt;value = value;
+}
+
+void CL_XMLTokenLoad::set_attribute(const CL_XMLTokenString &amp; name, const CL_XMLTokenString &amp; value)
+{
+	int size = impl-&gt;attributes.size();
+	for (int i=0; i&lt;size; i++)
+	{
+		if (impl-&gt;attributes[i].first == name)
+		{
+			impl-&gt;attributes[i].second = value;
+			return;
+		}
+	}
+	impl-&gt;attributes.push_back(std::make_pair(name, value));
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_XMLTokenLoad implementation:

Added: trunk/clanlib/Core/XML/xml_token_load_generic.h
===================================================================
--- trunk/clanlib/Core/XML/xml_token_load_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/xml_token_load_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,64 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_xml_token_load_generic
+#define header_xml_token_load_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/XML/xml_token.h&quot;
+#include &quot;API/Core/XML/xml_token_string.h&quot;
+
+class CL_XMLTokenLoad_Generic
+{
+//! Construction:
+public:
+	CL_XMLTokenLoad_Generic() : type(CL_XMLToken::NULL_TOKEN), variant(CL_XMLToken::SINGLE) { return; }
+
+	~CL_XMLTokenLoad_Generic() { return; }
+	
+//! Attributes:
+public:
+	CL_XMLToken::TokenType type;
+
+	CL_XMLToken::TokenVariant variant;
+
+	CL_XMLTokenString name;
+
+	CL_XMLTokenString value;
+	
+	std::vector&lt; std::pair&lt;CL_XMLTokenString, CL_XMLTokenString&gt; &gt; attributes;
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/Core/XML/xml_token_save.cpp
===================================================================
--- trunk/clanlib/Core/XML/xml_token_save.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/xml_token_save.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,125 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/XML/xml_token_save.h&quot;
+#include &quot;xml_token_save_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_XMLTokenSave construction:
+
+CL_XMLTokenSave::CL_XMLTokenSave()
+	: impl(new CL_XMLTokenSave_Generic)
+{
+}
+	
+CL_XMLTokenSave::CL_XMLTokenSave(const CL_XMLTokenSave &amp;copy)
+	: impl(copy.impl)
+{
+}
+	
+CL_XMLTokenSave::~CL_XMLTokenSave()
+{
+}
+	
+/////////////////////////////////////////////////////////////////////////////
+// CL_XMLTokenSave attributes:
+
+CL_XMLTokenSave::TokenType CL_XMLTokenSave::get_type() const
+{
+	return impl-&gt;type;
+}
+
+CL_XMLTokenSave::TokenVariant CL_XMLTokenSave::get_variant() const
+{
+	return impl-&gt;variant;
+}
+
+std::string CL_XMLTokenSave::get_name() const
+{
+	return impl-&gt;name;
+}
+
+std::string CL_XMLTokenSave::get_value() const
+{
+	return impl-&gt;value;
+}
+
+int CL_XMLTokenSave::get_attributes_number() const
+{
+	return impl-&gt;attributes.size();
+}
+
+std::pair&lt;std::string, std::string&gt; CL_XMLTokenSave::get_attribute(int attribute_num) const
+{
+	if (attribute_num &lt; 0 || attribute_num &gt;= (int)impl-&gt;attributes.size())
+		return std::make_pair(std::string(), std::string());
+
+	return impl-&gt;attributes[attribute_num];
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_XMLTokenSave operations:
+
+void CL_XMLTokenSave::set_type(TokenType type)
+{
+	impl-&gt;type = type;
+}
+
+void CL_XMLTokenSave::set_variant(TokenVariant variant)
+{
+	impl-&gt;variant = variant;
+}
+
+void CL_XMLTokenSave::set_name(const std::string &amp;name)
+{
+	impl-&gt;name = name;
+}
+
+void CL_XMLTokenSave::set_value(const std::string &amp;value)
+{
+	impl-&gt;value = value;
+}
+
+void CL_XMLTokenSave::set_attribute(const std::string &amp;name, const std::string &amp;value)
+{
+	int size = impl-&gt;attributes.size();
+	for (int i=0; i&lt;size; i++)
+	{
+		if (impl-&gt;attributes[i].first == name)
+		{
+			impl-&gt;attributes[i].second = value;
+			return;
+		}
+	}
+	impl-&gt;attributes.push_back(std::pair&lt;std::string, std::string&gt;(name, value));
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_XMLTokenSave implementation:

Added: trunk/clanlib/Core/XML/xml_token_save_generic.h
===================================================================
--- trunk/clanlib/Core/XML/xml_token_save_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/xml_token_save_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,62 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_xml_token_save_generic
+#define header_xml_token_save_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/XML/xml_token.h&quot;
+#include &lt;map&gt;
+#include &lt;string&gt;
+
+class CL_XMLTokenSave_Generic
+{
+//! Construction:
+public:
+	CL_XMLTokenSave_Generic() : ref_count(0), type(CL_XMLToken::NULL_TOKEN), variant(CL_XMLToken::SINGLE) { return; }
+	~CL_XMLTokenSave_Generic() { return; }
+	
+//! Attributes:
+public:
+	int ref_count;
+	CL_XMLToken::TokenType type;
+	CL_XMLToken::TokenVariant variant;
+	std::string name;
+	std::string value;
+
+	std::vector&lt; std::pair&lt;std::string, std::string&gt; &gt; attributes;
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/Core/XML/xml_tokenizer.cpp
===================================================================
--- trunk/clanlib/Core/XML/xml_tokenizer.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/xml_tokenizer.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,401 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/XML/xml_tokenizer.h&quot;
+#include &quot;API/Core/XML/xml_token_load.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;xml_tokenizer_generic.h&quot;
+#include &quot;API/Core/XML/xml_token_string.h&quot;
+
+#include &lt;algorithm&gt;
+#include &lt;utility&gt;
+//#include &lt;iterator&gt;
+
+//std::string replace_escapes(std::string str);
+
+//template &lt;typename Iter&gt;
+//std::string replace_escapes_fast(Iter begin, Iter end);
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_XMLTokenizer construction:
+
+CL_XMLTokenizer::CL_XMLTokenizer()
+{
+}
+
+CL_XMLTokenizer::CL_XMLTokenizer(const CL_XMLTokenizer &amp;copy) : impl(copy.impl)
+{
+}
+
+CL_XMLTokenizer::CL_XMLTokenizer(CL_InputSource *input, bool delete_input) : impl(new CL_XMLTokenizer_Generic)
+{
+	impl-&gt;input = input;
+	impl-&gt;delete_input = delete_input;
+	impl-&gt;size = input-&gt;size();
+	impl-&gt;data.resize(impl-&gt;size);
+	input-&gt;read(&amp;impl-&gt;data[0], impl-&gt;size);
+	impl-&gt;pos = 0;
+}
+
+CL_XMLTokenizer::~CL_XMLTokenizer()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_XMLTokenizer attributes:
+
+bool CL_XMLTokenizer::get_eat_whitespace() const
+{
+	return impl-&gt;eat_whitespace;
+}
+
+void CL_XMLTokenizer::set_eat_whitespace(bool enable)
+{
+	impl-&gt;eat_whitespace = enable;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_XMLTokenizer operations:
+
+CL_XMLTokenLoad CL_XMLTokenizer::next()
+{
+	if (impl == 0)
+		return CL_XMLTokenLoad();
+
+	if (impl-&gt;pos == impl-&gt;size)
+		return CL_XMLTokenLoad(); // EOF, return null token.
+
+	bool is_need_escape = true;
+
+	if (impl-&gt;data[impl-&gt;pos] != '&lt;') // Text node
+	{
+		std::string::size_type start_pos = impl-&gt;pos;
+		std::string::size_type end_pos = impl-&gt;data.find('&lt;', start_pos);
+		if (end_pos == impl-&gt;data.npos) end_pos = impl-&gt;size;
+		impl-&gt;pos = end_pos;
+
+		CL_XMLTokenString text(&amp;impl-&gt;data[start_pos], end_pos-start_pos, is_need_escape);
+		if (impl-&gt;eat_whitespace)
+		{
+			text = trim_whitespace(text);
+			if (text.empty())
+				return next();
+		}
+
+		CL_XMLTokenLoad token;
+		token.set_type(CL_XMLToken::TEXT_TOKEN);
+		token.set_value(text);
+
+		return token;
+	}
+	else // Tag node
+	{
+		impl-&gt;pos++;
+		if (impl-&gt;pos == impl-&gt;size)
+			throw CL_Error(&quot;Premature end of XML data!&quot;);
+
+		// Try to early predict what sort of node it might be:
+		bool closing = false;
+		bool questionMark = false;
+		bool exclamationMark = false;
+		if (impl-&gt;data[impl-&gt;pos] == '/')
+			closing = true;
+		else
+			if (impl-&gt;data[impl-&gt;pos] == '?')
+				questionMark = true;
+			else
+				if (impl-&gt;data[impl-&gt;pos] == '!')
+					exclamationMark = true;
+
+		if (closing || questionMark || exclamationMark)
+		{
+			impl-&gt;pos++;
+			if (impl-&gt;pos == impl-&gt;size) throw CL_Error(&quot;Premature end of XML data!&quot;);
+		}
+
+		if (exclamationMark) // check for cdata section or comments
+		{
+			if (impl-&gt;data.compare(impl-&gt;pos, 2, &quot;--&quot;) == 0) // comment block
+			{
+				std::string::size_type start_pos = impl-&gt;pos+2;
+				std::string::size_type end_pos = impl-&gt;data.find(&quot;--&gt;&quot;, start_pos);
+				if (end_pos == impl-&gt;data.npos)
+					throw CL_Error(&quot;Premature end of XML data!&quot;);
+				impl-&gt;pos = end_pos+3;
+
+				CL_XMLTokenLoad token;
+				token.set_type(CL_XMLToken::COMMENT_TOKEN);
+				token.set_variant(CL_XMLToken::SINGLE);
+				token.set_value(CL_XMLTokenString(&amp;impl-&gt;data[start_pos], end_pos-start_pos, is_need_escape));
+				return token;
+			}
+
+			if (impl-&gt;data.compare(impl-&gt;pos, 7, &quot;[CDATA[&quot;) != 0)
+				throw CL_Error(CL_String::format(&quot;Error in XML stream at position %1&quot;, static_cast&lt;int&gt;(impl-&gt;pos)));
+			std::string::size_type start_pos = impl-&gt;pos+7;
+			std::string::size_type end_pos = impl-&gt;data.find(&quot;]]&gt;&quot;, start_pos);
+			if (end_pos == impl-&gt;data.npos)
+				throw CL_Error(&quot;Premature end of XML data!&quot;);
+			impl-&gt;pos = end_pos+3;
+
+			CL_XMLTokenLoad token;
+			token.set_type(CL_XMLToken::CDATA_SECTION_TOKEN);
+			token.set_variant(CL_XMLToken::SINGLE);
+			token.set_value(CL_XMLTokenString(&amp;impl-&gt;data[start_pos], end_pos-start_pos, is_need_escape));
+			return token;
+		}
+
+		// Extract the tag name:
+		std::string::size_type start_pos = impl-&gt;pos;
+		std::string::size_type end_pos = impl-&gt;data.find_first_of(&quot; \r\n\t?/&gt;&quot;, start_pos);
+		if (end_pos == impl-&gt;data.npos)
+			throw CL_Error(&quot;Premature end of XML data!&quot;);
+		impl-&gt;pos = end_pos;
+
+		CL_XMLTokenLoad token;
+		token.set_type(questionMark ? CL_XMLToken::PROCESSING_INSTRUCTION_TOKEN : CL_XMLToken::ELEMENT_TOKEN);
+		token.set_variant(closing ? CL_XMLToken::END : CL_XMLToken::BEGIN);
+		token.set_name(CL_XMLTokenString(&amp;impl-&gt;data[start_pos], end_pos-start_pos, is_need_escape));
+		//token.set_name(replace_escapes_fast(impl-&gt;data.begin() + start_pos, impl-&gt;data.begin() + end_pos));
+
+		// Check for possible attributes:
+		while (true)
+		{
+			// Strip whitespace:
+			impl-&gt;pos = impl-&gt;data.find_first_not_of(&quot; \r\n\t&quot;, impl-&gt;pos);
+			if (impl-&gt;pos == impl-&gt;data.npos)
+				throw CL_Error(&quot;Premature end of XML data!&quot;);
+
+			// End of tag, stop searching for more attributes:
+			if (impl-&gt;data[impl-&gt;pos] == '/' || impl-&gt;data[impl-&gt;pos] == '?' || impl-&gt;data[impl-&gt;pos] == '&gt;')
+				break;
+
+			// Extract attribute name:
+			std::string::size_type start_pos = impl-&gt;pos;
+			std::string::size_type end_pos = impl-&gt;data.find_first_of(&quot; \r\n\t=&quot;, start_pos);
+			if (end_pos == impl-&gt;data.npos)
+				throw CL_Error(&quot;Premature end of XML data!&quot;);
+			impl-&gt;pos = end_pos;
+
+			CL_XMLTokenString attributeName(&amp;impl-&gt;data[start_pos], end_pos-start_pos, is_need_escape);
+
+			// Find seperator:
+			impl-&gt;pos = impl-&gt;data.find_first_not_of(&quot; \r\n\t&quot;, impl-&gt;pos);
+			if (impl-&gt;pos == impl-&gt;data.npos || impl-&gt;pos == impl-&gt;size-1)
+				throw CL_Error(&quot;Premature end of XML data!&quot;);
+			if (impl-&gt;data[impl-&gt;pos++] != '=')
+				throw CL_Error(CL_String::format(&quot;XML error(s), parser confused at line %1 (tag=%2, attributeName=%3)&quot;, impl-&gt;get_line_number(), token.get_name(), attributeName.to_string()));
+
+			// Strip whitespace:
+			impl-&gt;pos = impl-&gt;data.find_first_not_of(&quot; \r\n\t&quot;, impl-&gt;pos);
+			if (impl-&gt;pos == impl-&gt;data.npos)
+				throw CL_Error(&quot;Premature end of XML data!&quot;);
+
+			// Extract attribute value:
+			char const * first_of = &quot; \r\n\t&quot;;
+			if (impl-&gt;data[impl-&gt;pos] == '&quot;')
+			{
+				first_of = &quot;\&quot;&quot;;
+				impl-&gt;pos++;
+				if (impl-&gt;pos == impl-&gt;size)
+					throw CL_Error(&quot;Premature end of XML data!&quot;);
+			}
+			else
+				if (impl-&gt;data[impl-&gt;pos] == '\'')
+				{
+					first_of = &quot;'&quot;;
+					impl-&gt;pos++;
+					if (impl-&gt;pos == impl-&gt;size)
+						throw CL_Error(&quot;Premature end of XML data!&quot;);
+				}
+
+			start_pos = impl-&gt;pos;
+			end_pos = impl-&gt;data.find_first_of(first_of, start_pos);
+			if (end_pos == impl-&gt;data.npos)
+				throw CL_Error(&quot;Premature end of XML data!&quot;);
+			
+			CL_XMLTokenString attributeValue(CL_XMLTokenString(&amp;impl-&gt;data[start_pos], end_pos-start_pos, is_need_escape));
+
+			impl-&gt;pos = end_pos + 1;
+			if (impl-&gt;pos == impl-&gt;size)
+				throw CL_Error(&quot;Premature end of XML data!&quot;);
+
+			// Finally apply attribute to token:
+			token.set_attribute(attributeName, attributeValue);
+		}
+
+		// Check if its singular:
+		if (impl-&gt;data[impl-&gt;pos] == '/' || impl-&gt;data[impl-&gt;pos] == '?')
+		{
+			token.set_variant(CL_XMLToken::SINGLE);
+			impl-&gt;pos++;
+			if (impl-&gt;pos == impl-&gt;size)
+				throw CL_Error(&quot;Premature end of XML data!&quot;);
+		}
+
+		// Data stream should be ending now.
+		if (impl-&gt;data[impl-&gt;pos] != '&gt;')
+			throw CL_Error(CL_String::format(&quot;Error in XML stream, line %1 (expected end of tag)&quot;, impl-&gt;get_line_number()));
+		impl-&gt;pos++;
+
+		return token;
+	}
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_XMLTokenizer implementation:
+
+/*
+inline bool try_replace(std::string &amp; str, std::string::size_type pos, std::string const &amp; escape, char const * escape_char)
+{
+	if (pos + escape.size() &lt;= str.size())
+		if (std::equal(escape.begin(), escape.end(), str.begin() + pos))
+		{
+			str.replace(pos, escape.size(), escape_char);
+			return true;
+		}
+	return false;
+}
+
+std::string replace_escapes(std::string str)
+{
+	std::string::size_type pos;
+
+	static std::string const amp(&quot;&amp;amp&quot;);
+	static std::string const quot(&quot;&amp;quot&quot;);
+	static std::string const apos(&quot;&amp;apos&quot;);
+	static std::string const lt(&quot;&amp;lt&quot;);
+	static std::string const gt(&quot;&amp;gt&quot;);
+
+	pos = 0;
+	while (pos != std::string::npos)
+	{
+		pos = str.find('&amp;', pos);
+		if (pos == std::string::npos)
+			break;
+
+		if (	try_replace(str, pos, amp, &quot;&amp;&quot;)
+			||	try_replace(str, pos, quot, &quot;\&quot;&quot;)
+			||	try_replace(str, pos, apos, &quot;\'&quot;)
+			||	try_replace(str, pos, gt, &quot;&gt;&quot;)
+			||	try_replace(str, pos, lt, &quot;&lt;&quot;) )
+		{
+		}
+		pos++;
+	}
+
+	return str;
+}
+*/
+
+//std::string &amp; replace_escapes(std::string &amp; str)
+//{
+//	std::string::size_type pos;
+//
+//	static std::string const amp(&quot;&amp;amp&quot;);
+//	static std::string const quot(&quot;&amp;quot&quot;);
+//	static std::string const apos(&quot;&amp;apos&quot;);
+//	static std::string const lt(&quot;&amp;lt&quot;);
+//	static std::string const gt(&quot;&amp;gt&quot;);
+//
+//	pos = 0;
+//	while (pos != std::string::npos)
+//	{
+//		pos = str.find('&amp;', pos);
+//		if (pos == std::string::npos)
+//			break;
+//
+//		if (	try_replace(str, pos, amp, &quot;&amp;&quot;)
+//			||	try_replace(str, pos, quot, &quot;\&quot;&quot;)
+//			||	try_replace(str, pos, apos, &quot;\'&quot;)
+//			||	try_replace(str, pos, gt, &quot;&gt;&quot;)
+//			||	try_replace(str, pos, lt, &quot;&lt;&quot;) )
+//		{
+//		}
+//		pos++;
+//	}
+//
+//	return str;
+//}
+
+/*
+template &lt;typename Container, typename Iter&gt;
+inline bool append_escape(Container &amp; buff, Iter &amp; begin, Iter end, std::string const &amp; escape, char escape_char)
+{
+	if (static_cast&lt;ptrdiff_t&gt;(escape.size()) &lt;= std::distance(begin, end))
+		if (std::equal(escape.begin(), escape.end(), begin))
+		{
+			buff.insert(buff.end(), 1, escape_char);
+			std::advance(begin, escape.size());
+			return true;
+		}
+	return false;
+}
+
+template &lt;typename Iter&gt;
+std::string replace_escapes_fast(Iter begin, Iter end)
+{
+	static std::string const amp(&quot;&amp;amp&quot;);
+	static std::string const quot(&quot;&amp;quot&quot;);
+	static std::string const apos(&quot;&amp;apos&quot;);
+	static std::string const lt(&quot;&amp;lt&quot;);
+	static std::string const gt(&quot;&amp;gt&quot;);
+
+	std::size_t size = std::distance(begin, end);
+//	static std::string str;
+//	str.reserve(size);
+//	str.resize(0);
+
+	static std::vector&lt;char&gt; buff;
+//	buff.reserve(size);
+	buff.resize(0);
+
+	while(begin != end)
+	{
+		Iter pos = std::find(begin, end, '&amp;');
+		buff.insert(buff.end(), begin, pos);
+		if (pos == end)
+			break;
+
+		begin = pos;
+		if (	append_escape(buff, begin, end, amp, '&amp;')
+			||	append_escape(buff, begin, end, quot, '\&quot;')
+			||	append_escape(buff, begin, end, apos, '\'')
+			||	append_escape(buff, begin, end, gt, '&gt;')
+			||	append_escape(buff, begin, end, lt, '&lt;'))
+		{
+		}
+		else
+			++begin;
+	}
+	return std::string(&amp;buff[0], buff.size());
+}
+*/

Added: trunk/clanlib/Core/XML/xml_tokenizer_generic.h
===================================================================
--- trunk/clanlib/Core/XML/xml_tokenizer_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/xml_tokenizer_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,81 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_xml_tokenizer_generic
+#define header_xml_tokenizer_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/IOData/inputsource.h&quot;
+
+class CL_XMLTokenizer_Generic
+{
+//! Construction:
+public:
+	CL_XMLTokenizer_Generic() : input(0), delete_input(false), pos(0), size(0), eat_whitespace(true) { return; }
+
+	~CL_XMLTokenizer_Generic() { if (delete_input) delete input; }
+
+//! Attributes:
+public:
+	CL_InputSource *input;
+	
+	bool delete_input;
+
+	std::string::size_type pos, size;
+
+	std::string data;
+
+	bool eat_whitespace;
+
+//! Operations:
+public:
+	// used to get the line number when there is an error in the xml file
+	int get_line_number()
+	{
+		int line = 1;
+		std::string::size_type tmp_pos = 0;
+
+		std::string::const_iterator it;
+		for( it = data.begin(); it != data.end() &amp;&amp; tmp_pos &lt;= pos; ++it, tmp_pos++ )
+		{
+			if( (*it) == '\n' )
+				line++;
+		}
+	
+		return line;
+	}
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/Core/XML/xml_writer.cpp
===================================================================
--- trunk/clanlib/Core/XML/xml_writer.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/xml_writer.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,253 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &quot;API/Core/XML/xml_writer.h&quot;
+#include &quot;API/Core/XML/xml_token_save.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;xml_writer_generic.h&quot;
+
+//static std::string insert_escapes(std::string str);
+static std::string insert_escapes_fast(std::string str);
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_XMLWriter construction:
+
+CL_XMLWriter::CL_XMLWriter()
+{
+}
+
+CL_XMLWriter::CL_XMLWriter(const CL_XMLWriter &amp;copy) : impl(copy.impl)
+{
+}
+
+CL_XMLWriter::CL_XMLWriter(CL_OutputSource *output, bool delete_output) : impl(new CL_XMLWriter_Generic)
+{
+	impl-&gt;output = output;
+	impl-&gt;delete_output = delete_output;
+}
+
+CL_XMLWriter::~CL_XMLWriter()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_XMLWriter attributes:
+
+bool CL_XMLWriter::get_insert_whitespace() const
+{
+	return impl-&gt;insert_whitespace;
+}
+
+void CL_XMLWriter::set_insert_whitespace(bool enable)
+{
+	impl-&gt;insert_whitespace = enable;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_XMLWriter operations:
+
+void CL_XMLWriter::write(const CL_XMLTokenSave &amp;token)
+{
+	if (!impl) return;
+
+	std::string str;
+	switch (token.get_type())
+	{
+	case CL_XMLToken::NULL_TOKEN:
+		return; // should this throw exception instead?
+		
+	case CL_XMLToken::ELEMENT_TOKEN:
+		if (token.get_variant() == CL_XMLToken::END)
+		{
+			str = CL_String::format(&quot;&lt;/%1&gt;&quot;, insert_escapes_fast(token.get_name()));
+		}
+		else
+		{
+			str = CL_String::format(&quot;&lt;%1&quot;, insert_escapes_fast(token.get_name()));
+
+			int size = token.get_attributes_number();
+			for (int i=0; i&lt;size; i++)
+			{
+				std::pair&lt;std::string, std::string&gt; attribute(token.get_attribute(i));
+				str.append(CL_String::format(&quot; %1=\&quot;%2\&quot;&quot;, insert_escapes_fast(attribute.first), insert_escapes_fast(attribute.second)));
+			}
+
+			if (token.get_variant() == CL_XMLToken::SINGLE)
+				str.append(&quot;/&gt;&quot;);
+			else
+				str.append(&quot;&gt;&quot;);
+		}
+		break;
+		
+	case CL_XMLToken::TEXT_TOKEN:
+		str = insert_escapes_fast(token.get_value());
+		break;
+		
+	case CL_XMLToken::CDATA_SECTION_TOKEN:
+		str = CL_String::format(&quot;&lt;![CDATA[%1]]&gt;&quot;, token.get_value());
+		break;
+
+	case CL_XMLToken::COMMENT_TOKEN:
+		str = CL_String::format(&quot;&lt;!--%1--&gt;&quot;, token.get_value());
+		break;
+
+	case CL_XMLToken::ENTITY_REFERENCE_TOKEN:
+	case CL_XMLToken::ENTITY_TOKEN:
+	case CL_XMLToken::PROCESSING_INSTRUCTION_TOKEN:
+	case CL_XMLToken::DOCUMENT_TYPE_TOKEN:
+	case CL_XMLToken::NOTATION_TOKEN:
+		return; // not implemented yet.
+	}
+
+	if (token.get_variant() == CL_XMLToken::END)
+	{
+		impl-&gt;indent--;
+	}
+
+	if (impl-&gt;insert_whitespace)
+	{
+		std::string indent_tabs(impl-&gt;indent, '\t');
+		impl-&gt;output-&gt;write(indent_tabs.data(), indent_tabs.size());
+	}
+
+	impl-&gt;output-&gt;write(str.data(), str.size());
+
+	if (impl-&gt;insert_whitespace)
+	{
+#ifdef WIN32
+		impl-&gt;output-&gt;write(&quot;\r\n&quot;, 2);
+#else
+		impl-&gt;output-&gt;write(&quot;\n&quot;, 1);
+#endif
+	}
+
+	if (token.get_variant() == CL_XMLToken::BEGIN)
+	{
+		impl-&gt;indent++;
+	}
+}
+	
+/////////////////////////////////////////////////////////////////////////////
+// CL_XMLWriter implementation:
+
+#if 0
+static std::string insert_escapes(std::string str)
+{
+	std::string::size_type pos;
+
+	pos = 0;
+	while (pos != std::string::npos)
+	{
+		pos = str.find(&quot;&amp;&quot;, pos);
+		if (pos == std::string::npos) break;
+		str.replace( pos, 1, &quot;&amp;&quot; );
+		pos++;
+	}
+	
+	pos = 0;
+	while (pos != std::string::npos)
+	{
+		pos = str.find(&quot;\&quot;&quot;, pos);
+		if (pos == std::string::npos) break;
+		str.replace( pos, 1, &quot;&quot;&quot; );
+		pos++;
+	}
+
+	pos = 0;
+	while (pos != std::string::npos)
+	{
+		pos = str.find(&quot;\'&quot;, pos);
+		if (pos == std::string::npos) break;
+		str.replace( pos, 1, &quot;&apos;&quot; );
+		pos++;
+	}
+
+	pos = 0;
+	while (pos != std::string::npos)
+	{
+		pos = str.find(&quot;&lt;&quot;, pos);
+		if (pos == std::string::npos) break;
+		str.replace( pos, 1, &quot;&lt;&quot; );
+		pos++;
+	}
+
+	pos = 0;
+	while (pos != std::string::npos)
+	{
+		pos = str.find(&quot;&gt;&quot;, pos);
+		if (pos == std::string::npos) break;
+		str.replace( pos, 1, &quot;&gt;&quot; );
+		pos++;
+	}
+
+	return str;
+}
+#endif 
+
+static std::string insert_escapes_fast(std::string str)
+{
+	static std::string const amp(&quot;&amp;&quot;);
+	static std::string const quot(&quot;&quot;&quot;);
+	static std::string const apos(&quot;&apos;&quot;);
+	static std::string const lt(&quot;&lt;&quot;);
+	static std::string const gt(&quot;&gt;&quot;);
+
+	std::string::size_type pos = 0;
+	while (pos &lt; str.size())
+	{
+		switch(str[pos])
+		{
+		case '&amp;':
+			str.replace(pos, 1, amp);
+			pos += amp.size();
+			break;
+		case '\'':
+			str.replace(pos, 1, apos);
+			pos += apos.size();
+			break;
+		case '\&quot;':
+			str.replace(pos, 1, quot);
+			pos += quot.size();
+			break;
+		case '&lt;':
+			str.replace(pos, 1, lt);
+			pos += lt.size();
+			break;
+		case '&gt;':
+			str.replace(pos, 1, gt);
+			pos += gt.size();
+			break;
+		default:
+			++pos;
+			break;
+		}
+	}
+	return str;
+}

Added: trunk/clanlib/Core/XML/xml_writer_generic.h
===================================================================
--- trunk/clanlib/Core/XML/xml_writer_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/XML/xml_writer_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,64 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_xml_writer_generic
+#define header_xml_writer_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/IOData/outputsource.h&quot;
+
+class CL_XMLWriter_Generic
+{
+//! Construction:
+public:
+	CL_XMLWriter_Generic() : output(0), delete_output(false), insert_whitespace(true), indent(0) { return; }
+
+	~CL_XMLWriter_Generic() { if (delete_output) delete output; }
+
+//! Attributes:
+public:
+	CL_OutputSource *output;
+	
+	bool delete_output;
+
+	bool insert_whitespace;
+
+	int indent;
+
+//! Operations:
+public:
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/Core/core_iostream.cpp
===================================================================
--- trunk/clanlib/Core/core_iostream.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/core_iostream.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,93 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Ingo Ruhnke
+**    Dieter Buys
+*/
+
+#include &quot;Core/precomp.h&quot;
+#include &lt;iostream&gt;
+#include &quot;API/Core/Math/rect.h&quot;
+#include &quot;API/Core/Math/size.h&quot;
+#include &quot;API/Core/Math/point.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/core_iostream.h&quot;
+
+std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const CL_Rect&amp; rect)
+{
+	s &lt;&lt; &quot;[&quot;
+	  &lt;&lt; rect.left   &lt;&lt; &quot;, &quot;
+	  &lt;&lt; rect.top    &lt;&lt; &quot;, &quot;
+	  &lt;&lt; rect.right  &lt;&lt; &quot;, &quot;
+	  &lt;&lt; rect.bottom &lt;&lt; &quot;]&quot;;
+	return s;
+}
+
+std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const CL_Rectf&amp; rect)
+{
+	s &lt;&lt; &quot;[&quot;
+	  &lt;&lt; rect.left   &lt;&lt; &quot;, &quot;
+	  &lt;&lt; rect.top    &lt;&lt; &quot;, &quot;
+	  &lt;&lt; rect.right  &lt;&lt; &quot;, &quot;
+	  &lt;&lt; rect.bottom &lt;&lt; &quot;]&quot;;
+	return s;
+}
+
+std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const CL_Point&amp; point)
+{
+	s &lt;&lt; &quot;[&quot;
+	  &lt;&lt; point.x   &lt;&lt; &quot;, &quot;
+	  &lt;&lt; point.y &lt;&lt; &quot;]&quot;;
+	return s;
+}
+
+std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const CL_Pointf&amp; point)
+{
+	s &lt;&lt; &quot;[&quot;
+	  &lt;&lt; point.x   &lt;&lt; &quot;, &quot;
+	  &lt;&lt; point.y &lt;&lt; &quot;]&quot;;
+	return s;
+}
+
+std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const CL_Size&amp; size)
+{
+	s &lt;&lt; size.width &lt;&lt; &quot;x&quot; &lt;&lt; size.height;
+	return s;
+}
+
+std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const CL_Sizef&amp; size)
+{
+	s &lt;&lt; size.width &lt;&lt; &quot;x&quot; &lt;&lt; size.height;
+	return s;
+}
+
+std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const CL_Error&amp; error)
+{
+	s &lt;&lt; error.message;
+	return s;
+}
+
+// EOF //
+

Added: trunk/clanlib/Core/precomp.cpp
===================================================================
--- trunk/clanlib/Core/precomp.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/precomp.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,30 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Core/precomp.h&quot;

Added: trunk/clanlib/Core/precomp.h
===================================================================
--- trunk/clanlib/Core/precomp.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Core/precomp.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,71 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_precomp
+#define header_precomp
+
+#ifdef WIN32
+#ifdef _MSC_VER
+# pragma warning (disable:4786)
+#endif
+#include &lt;windows.h&gt;
+#include &lt;process.h&gt;
+#include &lt;dinput.h&gt;
+#include &lt;dsound.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;math.h&gt;
+#include &lt;conio.h&gt;
+#endif
+
+#include &quot;API/signals.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+
+#ifdef __BORLANDC__
+#define BAD_MATH
+#endif
+
+#ifdef BAD_MATH
+#define sqrtf sqrt
+#define acosf acos
+#define sinf sin
+#define cosf cos
+#endif
+
+#if defined(_DEBUG) &amp;&amp; !defined(DEBUG)
+#define DEBUG
+#endif
+
+#ifdef WIN32
+#define BREAKPOINT
+#else
+#define BREAKPOINT asm(&quot;int $03&quot;);
+#endif
+
+#endif

Added: trunk/clanlib/Display/Collision/collision_outline.cpp
===================================================================
--- trunk/clanlib/Display/Collision/collision_outline.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Collision/collision_outline.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,646 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Harry Storbacka
+**    Magnus Norddahl
+**    James Wynn
+**    Emanuel Greisen
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/Collision/collision_outline.h&quot;
+#include &quot;API/Display/Collision/outline_provider_bitmap.h&quot;
+#include &quot;API/Display/Collision/outline_provider_file.h&quot;
+#include &quot;API/Display/Collision/outline_circle.h&quot;
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Display/display_window.h&quot;
+#include &quot;API/Display/graphic_context.h&quot;
+#include &quot;API/Display/pixel_format.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/Display/Providers/provider_factory.h&quot;
+#include &quot;API/Display/pixel_buffer.h&quot;
+#include &quot;collision_outline_generic.h&quot;
+#include &quot;../surface_target.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;Display/resourcedata_collisionoutline.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_CollisionOutline Construction:
+
+CL_CollisionOutline::CL_CollisionOutline()
+ : impl(0)
+{
+	impl = new CL_CollisionOutline_Generic();
+}
+
+
+CL_CollisionOutline::CL_CollisionOutline(const CL_CollisionOutline &amp;other)
+ : impl(0)
+{
+	impl = new CL_CollisionOutline_Generic();
+
+	*this = other;
+}
+
+CL_CollisionOutline::CL_CollisionOutline(std::vector&lt;CL_Contour&gt; contours, int width, int height)
+ : impl(0)
+{
+	impl = new CL_CollisionOutline_Generic();
+	impl-&gt;contours = contours;
+	impl-&gt;width = width;
+	impl-&gt;height = height;
+}
+
+CL_CollisionOutline::CL_CollisionOutline(
+	const std::string &amp;filename,
+	int alpha_limit,
+	CL_OutlineAccuracy accuracy,
+	bool get_insides)
+ : impl(0)
+{
+	if( CL_String::right(filename, 3) == &quot;out&quot; )
+	{
+		impl = new CL_CollisionOutline_Generic( new CL_OutlineProviderFile(filename), accuracy_raw );
+		return;
+	}
+
+	CL_PixelBuffer pbuf = CL_ProviderFactory::load(filename);
+	
+	if( pbuf.get_format() == CL_PixelFormat::rgba8888 )
+	{
+		impl = new CL_CollisionOutline_Generic(
+			new CL_OutlineProviderBitmap(pbuf, alpha_limit, get_insides), accuracy);
+	}
+	else
+	{
+		impl = new CL_CollisionOutline_Generic(
+			new CL_OutlineProviderBitmap(pbuf, alpha_limit, get_insides), accuracy_raw);
+	}
+
+	set_rotation_hotspot(origin_center);
+}
+
+CL_CollisionOutline::CL_CollisionOutline(
+	const std::string &amp;resource_id,
+	CL_ResourceManager *manager )
+ : impl(0)
+{
+	resource = manager-&gt;get_resource(resource_id);
+	resource.load();
+
+	CL_ResourceData_CollisionOutline *data =
+		(CL_ResourceData_CollisionOutline *) resource.get_data(&quot;collisionoutline&quot;);
+
+	if (!data)
+		throw CL_Error(&quot;Resource '&quot; + resource_id + &quot;' is not of type 'collisionoutline'&quot;);
+
+	impl = new CL_CollisionOutline_Generic();
+	*this = data-&gt;get_CollisionOutline();
+
+	resource.unload();
+}
+
+CL_CollisionOutline::CL_CollisionOutline(
+	CL_PixelBuffer pbuf,
+	int alpha_limit,
+	CL_OutlineAccuracy accuracy)
+ : impl(0)
+{
+	if( pbuf.get_format() == CL_PixelFormat::rgba8888 )
+	{
+		impl = new CL_CollisionOutline_Generic(
+			new CL_OutlineProviderBitmap(pbuf, alpha_limit), accuracy );
+	}
+	else
+	{
+		impl = new CL_CollisionOutline_Generic(
+			new CL_OutlineProviderBitmap(pbuf, alpha_limit), accuracy_raw );
+	}
+	
+	set_rotation_hotspot(origin_center);
+}
+
+CL_CollisionOutline::~CL_CollisionOutline()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_CollisionOutline Attributes:
+
+std::vector&lt;CL_Contour&gt; &amp;CL_CollisionOutline::get_contours() const
+{
+	return impl-&gt;contours;
+}
+
+CL_Circlef CL_CollisionOutline::get_minimum_enclosing_disc() const
+{
+	return impl-&gt;minimum_enclosing_disc;
+}
+
+CL_Pointf CL_CollisionOutline::get_translation() const
+{
+	return impl-&gt;position;
+}
+
+float CL_CollisionOutline::get_angle() const
+{
+	return impl-&gt;angle;
+}
+
+CL_Pointf CL_CollisionOutline::get_scale() const
+{
+	return impl-&gt;scale_factor;
+}
+
+bool CL_CollisionOutline::get_inside_test() const
+{
+	return impl-&gt;do_inside_test;
+}
+
+void CL_CollisionOutline::get_alignment( CL_Origin &amp;origin, float &amp;x, float &amp;y ) const
+{
+	origin = impl-&gt;translation_origin;
+	x = impl-&gt;translation_offset.x;
+	y = impl-&gt;translation_offset.y;
+}
+
+void CL_CollisionOutline::get_rotation_hotspot( CL_Origin &amp;origin, float &amp;x, float &amp;y) const
+{
+	origin = impl-&gt;rotation_origin;
+	x = impl-&gt;rotation_hotspot.x;
+	y = impl-&gt;rotation_hotspot.y;
+}
+
+unsigned int CL_CollisionOutline::get_width() const
+{
+	return impl-&gt;width;
+}
+
+unsigned int CL_CollisionOutline::get_height() const
+{
+	return impl-&gt;height;
+}
+
+std::vector&lt;CL_CollidingContours&gt; &amp;CL_CollisionOutline::get_collision_info() const
+{
+	return impl-&gt;collision_info;
+}
+
+void CL_CollisionOutline::set_collision_info(const std::vector&lt;CL_CollidingContours&gt; &amp;colinfo)
+{
+	impl-&gt;collision_info = colinfo;
+}
+
+void CL_CollisionOutline::clean_collision_info()
+{
+	impl-&gt;collision_info.clear();
+}
+
+
+void CL_CollisionOutline::get_collision_info_state(bool &amp;points, bool &amp;normals, bool &amp;metadata, bool &amp;pendepth) const
+{
+	points = impl-&gt;collision_info_points;
+	normals = impl-&gt;collision_info_normals;
+	metadata = impl-&gt;collision_info_meta;
+	pendepth = impl-&gt;collision_info_pen_depth;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_CollisionOutline Operations:
+
+CL_CollisionOutline &amp;CL_CollisionOutline::operator=(const CL_CollisionOutline &amp;other)
+{
+	if( this == &amp;other )
+		return *this;
+
+	delete impl;
+	impl = new CL_CollisionOutline_Generic();
+
+	impl-&gt;contours = other.get_contours();
+	impl-&gt;do_inside_test = other.get_inside_test();
+	impl-&gt;width = other.get_width();
+	impl-&gt;height = other.get_height();
+	impl-&gt;position = other.get_translation();
+	impl-&gt;scale_factor = other.get_scale();
+	impl-&gt;angle = other.get_angle();
+	//impl-&gt;radius = other.get_radius();
+	impl-&gt;minimum_enclosing_disc = other.get_minimum_enclosing_disc();
+
+	bool points, normals, metadata, pendepths;
+	other.get_collision_info_state(points,normals,metadata,pendepths);
+	enable_collision_info(points,normals,metadata,pendepths);
+
+	CL_Origin origin;
+	float x, y;
+	other.get_alignment(origin,x,y);
+
+	impl-&gt;translation_origin = origin;
+	impl-&gt;translation_offset.x = x;
+	impl-&gt;translation_offset.y = y;
+
+	other.get_rotation_hotspot(origin,x,y);
+
+	impl-&gt;rotation_origin = origin;
+	impl-&gt;rotation_hotspot.x = x;
+	impl-&gt;rotation_hotspot.y = y;
+	return *this;
+}
+
+void CL_CollisionOutline::optimize(unsigned char check_distance, float corner_angle )
+{
+	impl-&gt;optimize(check_distance, corner_angle);
+}
+
+
+void CL_CollisionOutline::draw(
+	float x,
+	float y,
+	const CL_Color &amp;color,
+	CL_GraphicContext *gc)
+{
+	// Get a graphics context
+	if (gc == 0) gc = CL_Display::get_current_window()-&gt;get_gc();
+	
+	// Draw collision outline (Contours are assumed as closed polygons, hence we use line-loop)
+	for(unsigned int i = 0; i &lt; impl-&gt;contours.size(); i++)
+	{
+		// Draw the contour
+		unsigned int numpoints = impl-&gt;contours[i].points.size();
+		for(unsigned int s = 0; s &lt; numpoints; s++)
+		{
+			const CL_Pointf &amp;p1 = impl-&gt;contours[i].points[s];
+			const CL_Pointf &amp;p2 = impl-&gt;contours[i].points[(s+1) % numpoints];
+			gc-&gt;draw_line( int(x + p1.x+0.5f), int(y + p1.y+0.5f), int(x + p2.x+0.5f), int(y + p2.y+0.5f), color);
+		}
+		// Add points (as oposite color)
+		// TODO: This did not work with SDL, the draw_pixel fails
+		CL_Color colorinv(255-color.get_red(),255-color.get_green(),255-color.get_blue());
+		for(unsigned int s1 = 0; s1 &lt; numpoints; s1++)
+		{
+			const CL_Pointf &amp;p1 = impl-&gt;contours[i].points[s1];
+			gc-&gt;draw_pixel( int(x + p1.x+0.5f), int(y + p1.y+0.5f), colorinv);
+		}
+	}
+}
+
+void CL_CollisionOutline::draw_sub_circles(
+	float x,
+	float y,
+	const CL_Color &amp;color,
+	CL_GraphicContext *gc)
+{
+	// Get a graphics context
+	if (gc == 0) gc = CL_Display::get_current_window()-&gt;get_gc();
+
+	// Draw the circles
+	for(unsigned int i = 0; i &lt; impl-&gt;contours.size(); i++)
+	{
+		unsigned int numcircles = impl-&gt;contours[i].sub_circles.size();
+		for(unsigned int s = 0; s &lt; numcircles; s++)
+		{
+			CL_Pointf center = impl-&gt;contours[i].sub_circles[s].position;
+			float radius     = impl-&gt;contours[i].sub_circles[s].radius;
+			float numsegments = 16;
+			for(float e = 0; e &lt; numsegments; e++)
+			{
+				float offx1 = cos(M_PI * 2.0 * (e / numsegments))*radius;
+				float offy1 = sin(M_PI * 2.0 * (e / numsegments))*radius;
+				float offx2 = cos(M_PI * 2.0 * ((e+1) / numsegments))*radius;
+				float offy2 = sin(M_PI * 2.0 * ((e+1) / numsegments))*radius;
+				CL_Pointf p1(x + center.x + offx1, y + center.y + offy1);
+				CL_Pointf p2(x + center.x + offx2, y + center.y + offy2);
+				gc-&gt;draw_line( int(p1.x+0.5f), int(p1.y+0.5f), int(p2.x+0.5f), int(p2.y+0.5f), color);
+			}
+		}
+	}
+}
+
+void CL_CollisionOutline::draw_smallest_enclosing_disc(
+	float x,
+	float y,
+	const CL_Color &amp;color,
+	CL_GraphicContext *gc)
+{
+	// Get a graphics context
+	if (gc == 0) gc = CL_Display::get_current_window()-&gt;get_gc();
+
+	// Draw the smallest enclosing disc
+	CL_Pointf center = impl-&gt;minimum_enclosing_disc.position;
+	float radius     = impl-&gt;minimum_enclosing_disc.radius;
+	float numsegments = 24; // To make it visible if the outline has only one contour, and the contour only has one sub-circle
+	for(float e = 0; e &lt; numsegments; e++)
+	{
+		float offx1 = cos(M_PI * 2.0 * (e / numsegments))*radius;
+		float offy1 = sin(M_PI * 2.0 * (e / numsegments))*radius;
+		float offx2 = cos(M_PI * 2.0 * ((e+1) / numsegments))*radius;
+		float offy2 = sin(M_PI * 2.0 * ((e+1) / numsegments))*radius;
+		CL_Pointf p1(x + center.x + offx1, y + center.y + offy1);
+		CL_Pointf p2(x + center.x + offx2, y + center.y + offy2);
+		gc-&gt;draw_line( int(p1.x+0.5f), int(p1.y+0.5f), int(p2.x+0.5f), int(p2.y+0.5f), color);
+	}
+}
+
+void CL_CollisionOutline::set_translation(float x, float y)
+{
+	impl-&gt;set_translation(x,y);
+}
+
+void CL_CollisionOutline::set_scale(float x, float y)
+{
+	impl-&gt;set_scale(x,y);
+}
+
+void CL_CollisionOutline::set_angle(float angle)
+{
+	impl-&gt;set_angle(angle);
+}
+
+void CL_CollisionOutline::rotate(float angle)
+{
+	impl-&gt;rotate(angle);
+}
+
+void CL_CollisionOutline::set_inside_test(bool value)
+{
+	impl-&gt;do_inside_test = value;
+}
+
+void CL_CollisionOutline::enable_collision_info(  bool points, bool normals, bool metadata, bool pen_depth)
+{
+	impl-&gt;collision_info_points = points;
+	impl-&gt;collision_info_normals = normals;
+	impl-&gt;collision_info_meta = metadata;
+	impl-&gt;collision_info_pen_depth = pen_depth;
+	impl-&gt;collision_info_collect = points || normals || metadata || pen_depth;
+}
+
+void CL_CollisionOutline::calculate_radius()
+{
+	impl-&gt;calculate_radius();
+}
+
+void CL_CollisionOutline::calculate_sub_circles(float radius_multiplier)
+{
+	impl-&gt;calculate_sub_circles(radius_multiplier);
+}
+
+void CL_CollisionOutline::calculate_smallest_enclosing_discs()
+{
+	impl-&gt;calculate_smallest_enclosing_discs();
+}
+
+void CL_CollisionOutline::calculate_convex_hulls()
+{
+	impl-&gt;calculate_convex_hulls();
+}
+
+void CL_CollisionOutline::save(const std::string &amp;filename, CL_OutputSourceProvider *provider) const
+{
+	impl-&gt;save(filename, provider);
+}
+
+bool CL_CollisionOutline::collide(const CL_CollisionOutline &amp;outline, bool remove_old_collision_info)
+{
+	return impl-&gt;collide(outline, remove_old_collision_info);
+}
+
+void CL_CollisionOutline::calculate_penetration_depth(std::vector&lt;CL_CollidingContours&gt; &amp;collision_info)
+{
+	CL_CollisionOutline_Generic::calculate_penetration_depth(collision_info);
+}
+
+bool CL_CollisionOutline::point_inside(const CL_Pointf &amp;point) const
+{
+	return impl-&gt;point_inside(point);
+}
+
+void CL_CollisionOutline::set_alignment( CL_Origin origin, float x, float y )
+{
+	CL_Origin old_origin = impl-&gt;translation_origin;
+
+	// undo previous translation offset.
+	impl-&gt;set_translation(-impl-&gt;translation_offset.x, -impl-&gt;translation_offset.y, true);
+	
+	// undo previous origin.
+	if( origin != impl-&gt;translation_origin )
+	{
+		float fix_x = 0, fix_y = 0;
+
+		float width = impl-&gt;width/2;
+		float height = impl-&gt;height/2;
+
+		switch( old_origin )
+		{
+		 case origin_top_left:
+			fix_x = -width;
+			fix_y = -height;
+			break;
+		 case origin_top_center:
+			fix_x = 0;
+			fix_y = -height;
+			break;
+		 case origin_top_right:
+			fix_x = width;
+			fix_y = -height;
+			break;
+
+		 case origin_center_left:
+			fix_x = -width;
+			fix_y = 0;
+			break;
+		 case origin_center:
+			fix_x = 0;
+			fix_y = 0;
+			break;
+		 case origin_center_right:
+			fix_x = width;
+			fix_y = 0;
+			break;
+
+		 case origin_bottom_left:
+			fix_x = -width;
+			fix_y = height;
+			break;
+		 case origin_bottom_center:
+			fix_x = 0;
+			fix_y = height;
+			break;
+		 case origin_bottom_right:
+			fix_x = width;
+			fix_y = height;
+			break;
+		}
+
+		impl-&gt;set_translation(fix_x, fix_y, true); // offset outline points
+
+		impl-&gt;rotation_hotspot.x += fix_x;
+		impl-&gt;rotation_hotspot.y += fix_y;
+	}
+
+	
+	impl-&gt;translation_origin = origin;
+	impl-&gt;translation_offset.x = x;
+	impl-&gt;translation_offset.y = y;
+	
+	impl-&gt;set_translation(x, y, true); // offset outline points
+
+	// set new origin offset.
+	if( origin != origin_center )
+	{
+		float fix_x = 0, fix_y = 0;
+
+		float width = impl-&gt;width/2;
+		float height = impl-&gt;height/2;
+
+		switch( origin )
+		{
+		 case origin_top_left:
+			fix_x = width;
+			fix_y = height;
+			break;
+		 case origin_top_center:
+			fix_x = 0;
+			fix_y = height;
+			break;
+		 case origin_top_right:
+			fix_x = -width;
+			fix_y = height;
+			break;
+
+		 case origin_center_left:
+			fix_x = width;
+			fix_y = 0;
+			break;
+		 case origin_center:
+			fix_x = 0;
+			fix_y = 0;
+			break;
+		 case origin_center_right:
+			fix_x = -width;
+			fix_y = 0;
+			break;
+
+		 case origin_bottom_left:
+			fix_x = width;
+			fix_y = -height;
+			break;
+		 case origin_bottom_center:
+			fix_x = 0;
+			fix_y = -height;
+			break;
+		 case origin_bottom_right:
+			fix_x = -width;
+			fix_y = -height;
+			break;
+		}
+		
+		impl-&gt;set_translation(fix_x, fix_y, true); // offset outline points
+
+		impl-&gt;rotation_hotspot.x += fix_x;
+		impl-&gt;rotation_hotspot.y += fix_y;
+	}
+
+	impl-&gt;calculate_radius();
+}
+
+void CL_CollisionOutline::set_rotation_hotspot( CL_Origin origin, float x, float y )
+{
+	// undo translation origin
+	CL_Origin trans_origin = impl-&gt;translation_origin;	
+	set_alignment(origin_center);
+
+	// undo the rotation of the current rotation hotspot
+	float angle = impl-&gt;angle;
+	impl-&gt;set_angle(0.0f);
+
+	float fix_x = 0, fix_y = 0;
+
+	// set new origin offset.
+	if( origin != origin_center )
+	{
+		float width = impl-&gt;width/2;
+		float height = impl-&gt;height/2;
+
+		switch( origin )
+		{
+		 case origin_top_left:
+			fix_x = -width;
+			fix_y = -height;
+			break;
+		 case origin_top_center:
+			fix_x = 0;
+			fix_y = -height;
+			break;
+		 case origin_top_right:
+			fix_x = width;
+			fix_y = -height;
+			break;
+
+		 case origin_center_left:
+			fix_x = -width;
+			fix_y = 0;
+			break;
+		 case origin_center:
+			fix_x = 0;
+			fix_y = 0;
+			break;
+		 case origin_center_right:
+			fix_x = width;
+			fix_y = 0;
+			break;
+
+		 case origin_bottom_left:
+			fix_x = -width;
+			fix_y = height;
+			break;
+		 case origin_bottom_center:
+			fix_x = 0;
+			fix_y = height;
+			break;
+		 case origin_bottom_right:
+			fix_x = width;
+			fix_y = height;
+			break;
+		}
+	}
+
+	impl-&gt;rotation_origin = origin;
+
+	impl-&gt;rotation_hotspot.x = fix_x + x;
+	impl-&gt;rotation_hotspot.y = fix_y + y;
+
+	// transform data using new rotation hotspot
+	impl-&gt;set_angle(angle);
+
+	set_alignment(trans_origin);
+
+	impl-&gt;calculate_radius();
+}
+

Added: trunk/clanlib/Display/Collision/collision_outline_generic.cpp
===================================================================
--- trunk/clanlib/Display/Collision/collision_outline_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Collision/collision_outline_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,885 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Harry Storbacka
+**    Magnus Norddahl
+**    James Wynn
+**    Emanuel Greisen
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Core/IOData/outputsource.h&quot;
+#include &quot;API/Core/IOData/outputsource_provider.h&quot;
+#include &quot;collision_outline_generic.h&quot;
+#include &quot;API/Display/Collision/collision_outline.h&quot;
+#include &quot;API/Display/Collision/outline_provider.h&quot;
+#include &quot;API/Display/Collision/outline_accuracy.h&quot;
+#include &quot;API/Display/Collision/outline_math.h&quot;
+#include &quot;API/Core/Math/line_math.h&quot;
+#include &quot;API/Core/Math/circle.h&quot;
+#include &quot;API/Core/Math/pointset_math.h&quot;
+#include &quot;API/Core/Math/cl_vector.h&quot;
+#include &quot;API/Core/Math/vector2.h&quot;
+#include &quot;API/Core/IOData/outputsource_file.h&quot;
+#include &quot;API/Core/System/log.h&quot;
+#include &lt;float.h&gt;
+
+template&lt;typename T&gt; inline T cl_min(T a, T b) { if(a &lt; b) return a; return b; }
+template&lt;typename T&gt; inline T cl_max(T a, T b) { if(a &gt; b) return a; return b; }
+template&lt;typename T&gt; inline T pow2(T a) { return a*a; }
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_CollisionOutline_Generic::CL_CollisionOutline_Generic()
+:
+	do_inside_test(false),
+	width(0), height(0),
+	angle(0),
+//	radius(0),
+	minimum_enclosing_disc(0.0f,0.0f,0.0f),
+	position(0,0),
+	scale_factor(1,1),
+	translation_offset(0,0),
+	translation_origin(origin_top_left),
+	rotation_hotspot(0,0),
+	rotation_origin(origin_center),
+	collision_info_points(false),
+	collision_info_normals(false),
+	collision_info_meta(false),
+	collision_info_pen_depth(false),
+	collision_info_collect(false)
+{
+	return;
+}
+
+CL_CollisionOutline_Generic::CL_CollisionOutline_Generic(
+	CL_OutlineProvider *provider,
+	CL_OutlineAccuracy accuracy )
+:
+	do_inside_test(false),
+	width(0), height(0),
+	angle(0),
+//	radius(0),
+	minimum_enclosing_disc(0.0f,0.0f,0.0f),
+	position(0,0),
+	scale_factor(1,1),
+	translation_offset(0,0),
+	translation_origin(origin_top_left),
+	rotation_hotspot(0,0),
+	rotation_origin(origin_center),
+	collision_info_points(false),
+	collision_info_normals(false),
+	collision_info_meta(false),
+	collision_info_pen_depth(false),
+	collision_info_collect(false)
+{
+	contours = provider-&gt;get_contours();
+	width = provider-&gt;get_width();
+	height = provider-&gt;get_height();
+	//TODO: minimum_enclosing_disc = provider-&gt;get_minimum_enclosing_disc();
+
+	delete provider;
+
+	int check_distance = 3;
+
+	switch( accuracy )
+	{
+	 case accuracy_high:
+		optimize(check_distance, float(M_PI/7.0f));
+		break;
+	 case accuracy_medium:
+		optimize(check_distance, float(M_PI/6.0f));
+		break;
+	 case accuracy_low:
+		optimize(check_distance, float(M_PI/5.0f));
+		break;
+	 case accuracy_poor:
+		optimize(check_distance, float(M_PI/4.0f));
+		break;
+	 case accuracy_raw:
+		break;
+	default:
+		break;
+	}
+	
+	calculate_radius();
+	calculate_sub_circles();
+}
+
+
+CL_CollisionOutline_Generic::~CL_CollisionOutline_Generic()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_CollisionOutline_Generic::set_translation(float x, float y, bool offset_points)
+{
+	CL_Pointf old_position = position;
+
+	if( !offset_points )
+	{
+		position.x = x;
+		position.y = y;
+	}
+
+	CL_Pointf translation;
+
+	if( offset_points )
+	{
+		translation.x = x;
+		translation.y = y;
+	}
+	else
+		translation = (position - old_position);
+
+	std::vector&lt;CL_Contour&gt;::iterator it;
+	for( it = contours.begin(); it != contours.end(); ++it )
+	{
+		std::vector&lt;CL_Pointf&gt;::iterator ita;
+		for( ita = (*it).points.begin(); ita != (*it).points.end(); ++ita )
+			(*ita) += translation;
+	}
+
+	for( it = contours.begin(); it != contours.end(); ++it )
+	{
+		std::vector&lt;CL_OutlineCircle&gt;::iterator ita;
+		for( ita = (*it).sub_circles.begin(); ita != (*it).sub_circles.end(); ++ita )
+		{
+			(*ita).position += translation;
+		}
+	}
+
+	minimum_enclosing_disc.position += translation;
+}
+
+void CL_CollisionOutline_Generic::rotate(float add_angle)
+{
+	angle += add_angle;
+
+	std::vector&lt;CL_Contour&gt;::iterator it;
+	for( it = contours.begin(); it != contours.end(); ++it )
+	{
+		std::vector&lt;CL_Pointf&gt;::iterator ita;
+		for( ita = (*it).points.begin(); ita != (*it).points.end(); ++ita )
+		{
+			(*ita) = (*ita).rotate(position+rotation_hotspot, add_angle);
+		}
+	}
+
+	for( it = contours.begin(); it != contours.end(); ++it )
+	{
+		std::vector&lt;CL_OutlineCircle&gt;::iterator ita;
+		for( ita = (*it).sub_circles.begin(); ita != (*it).sub_circles.end(); ++ita )
+		{
+			(*ita).position = (*ita).position.rotate(position+rotation_hotspot, add_angle);
+		}
+	}
+
+	// Rotate our &quot;radius&quot; too
+	minimum_enclosing_disc.position = minimum_enclosing_disc.position.rotate(position+rotation_hotspot, add_angle);
+}
+
+void CL_CollisionOutline_Generic::set_angle(float angle)
+{
+	float rotate_angle = angle - this-&gt;angle;
+	this-&gt;angle = angle;
+
+	std::vector&lt;CL_Contour&gt;::iterator it;
+	for( it = contours.begin(); it != contours.end(); ++it )
+	{
+		std::vector&lt;CL_Pointf&gt;::iterator ita;
+		for( ita = (*it).points.begin(); ita != (*it).points.end(); ++ita )
+		{
+			(*ita) = (*ita).rotate(position+rotation_hotspot, rotate_angle);
+		}
+	}
+
+	for( it = contours.begin(); it != contours.end(); ++it )
+	{
+		std::vector&lt;CL_OutlineCircle&gt;::iterator ita;
+		for( ita = (*it).sub_circles.begin(); ita != (*it).sub_circles.end(); ++ita )
+		{	
+			(*ita).position = (*ita).position.rotate(position+rotation_hotspot, rotate_angle);
+		}
+	}
+
+	// Rotate our &quot;radius&quot; too
+	minimum_enclosing_disc.position = minimum_enclosing_disc.position.rotate(position+rotation_hotspot, rotate_angle);
+	
+}
+
+void CL_CollisionOutline_Generic::set_scale(float new_scale_x, float new_scale_y)
+{
+	if( scale_factor.x == new_scale_x &amp;&amp; scale_factor.y == new_scale_y )
+		return;
+
+	if (new_scale_x == 0 || new_scale_y == 0)
+		return;
+
+	float scale_x = new_scale_x / scale_factor.x;
+	float scale_y = new_scale_y / scale_factor.y;
+	
+	std::vector&lt;CL_Contour&gt;::iterator it;
+	for( it = contours.begin(); it != contours.end(); ++it )
+	{
+		std::vector&lt;CL_Pointf&gt;::iterator ita;
+		for( ita = (*it).points.begin(); ita != (*it).points.end(); ++ita )
+		{
+			(*ita).x = position.x + (((*ita).x-position.x)*scale_x);
+			(*ita).y = position.y + (((*ita).y-position.y)*scale_y);
+		}
+	}
+	
+	// we can skip this recalculation (if its a unit-scale)
+	if(new_scale_x == new_scale_y)
+	{
+		minimum_enclosing_disc.position.x = position.x + ((minimum_enclosing_disc.position.x-position.x)*scale_x);
+		minimum_enclosing_disc.position.y = position.y + ((minimum_enclosing_disc.position.y-position.y)*scale_y);
+		minimum_enclosing_disc.radius *= (new_scale_x/scale_factor.x);
+
+		// TODO: we should be able to scale these too (if 
+		calculate_sub_circles();
+	}
+	else
+	{
+		calculate_sub_circles();
+		calculate_radius();
+	}
+
+	scale_factor.x = new_scale_x;
+	scale_factor.y = new_scale_y;
+}
+
+
+void CL_CollisionOutline_Generic::calculate_radius()
+{
+	std::vector&lt;CL_Pointf&gt; allpoints;
+	std::vector&lt;CL_Contour&gt;::iterator it;
+	for( it = contours.begin(); it != contours.end(); ++it )
+	{
+		for(std::vector&lt;CL_Pointf&gt;::const_iterator pit = (*it).points.begin(); pit != (*it).points.end(); pit++)
+		{
+			allpoints.push_back(*pit);
+		}
+	}
+	minimum_enclosing_disc = CL_PointSetMath::minimum_enclosing_disc(allpoints);
+	minimum_enclosing_disc.radius += 0.01f; // Just to make sure.
+}
+
+void CL_CollisionOutline_Generic::calculate_sub_circles(float radius_multiplier)
+{
+	/*
+	 * The new way of doing it, is as follows:
+	 * [Outer loop: for all contours]
+	 *    - Estimate a subcircle-radius: Average of line-segment-lengths * 3.5 (maybe this should be a parameter ?)
+	 *   [Loop: for all points]
+	 *    - Create a subcircle for the next two points (this gives a center and a radius)
+	 *      [Inner loop: as long as we have more points]
+	 *        - Add the next point: maybe expand the radius, and change the center
+	 *        - [if: (radius &gt; avg-radius &amp;&amp; more than two more points exist)]
+	 *          - Break inner loop !
+	 *    - Add the subcircle to the list
+	**/
+	std::vector&lt;CL_Contour&gt;::iterator it;
+	for( it = contours.begin(); it != contours.end(); ++it )
+	{
+		(*it).sub_circles.clear();
+
+		const std::vector&lt;CL_Pointf&gt; &amp;points = (*it).points;
+		// Test that we have at least 2 points
+		if(points.size() &lt; 2)
+		{
+			CL_Log::log(&quot;ClanCollision&quot;, &quot;Error: contour has less than 2 points&quot;);
+			continue;
+		}
+
+		// sub_radius = average of line lenghts in the contour * 3.5
+		float sub_radius = 0.0f;
+		for( unsigned int j=0; j &lt; points.size(); ++j )
+		{
+			int j2 = (j+1) % points.size();
+			sub_radius += (points[j].distance(points[j2]));
+		}
+		sub_radius /= points.size();
+		sub_radius *= radius_multiplier;
+
+		unsigned int i=0;
+		while(i &lt; points.size())
+		{
+			// Create a circle from the first two points
+			CL_OutlineCircle circle;
+			circle.start = i;    // i denotes the index of the beginning
+			circle.end   = i+1;  // (i+1) denotes the index of the end: and it loops
+			CL_OutlineMath::minimum_enclosing_sub_circle(circle,points,sub_radius);
+			circle.radius += 0.01f; // Just to make sure.
+			
+			// Add the circle
+			(*it).sub_circles.push_back(circle);
+
+			// update i for next circle
+			i = circle.end;
+		}
+	}
+}
+
+void CL_CollisionOutline_Generic::calculate_smallest_enclosing_discs()
+{	
+	std::vector&lt;CL_Contour&gt;::iterator it;
+	for( it = contours.begin(); it != contours.end(); ++it )
+	{
+		(*it).sub_circles.clear();
+		CL_Circlef tmpdisc = CL_PointSetMath::minimum_enclosing_disc((*it).points);
+		CL_OutlineCircle mindisc;
+		mindisc.position = tmpdisc.position;
+		mindisc.radius = (float)tmpdisc.radius;
+		mindisc.radius += 0.01f; // Just to make sure.
+		mindisc.start = 0;
+		mindisc.end   = (*it).points.size(); // This is actualy the first point, but this is how to start and end the same place
+		(*it).sub_circles.push_back(mindisc);
+	}
+}
+
+void CL_CollisionOutline_Generic::calculate_convex_hulls()
+{
+	std::vector&lt;CL_Contour&gt;::iterator it;
+	for( it = contours.begin(); it != contours.end(); ++it )
+	{
+		(*it).points = CL_PointSetMath::convex_hull_from_polygon((*it).points);
+	}
+	// We use smallest enclosing discs,
+	// since that gives great results with a convex shapes.
+	calculate_smallest_enclosing_discs();
+}
+
+void CL_CollisionOutline_Generic::optimize(unsigned char check_distance, float corner_angle)
+{
+	unsigned char orig_check_distance = check_distance;
+
+	std::vector&lt;CL_Contour&gt;::iterator it;
+	for( it = contours.begin(); it != contours.end(); ++it )
+	{
+		check_distance = orig_check_distance;
+
+		std::vector&lt;CL_Pointf&gt; &amp;points = (*it).points;
+
+		if( points.empty() ) continue;
+
+		std::vector&lt;CL_Pointf&gt; optimized;
+
+		optimized.push_back(points.front());
+
+		if( static_cast&lt;int&gt;(points.size()) &lt; check_distance )
+			check_distance = 1;
+
+		for( unsigned int i=0; i &lt; points.size()-check_distance; ++i )
+		{
+			int A_index = i-check_distance;
+			int B_index = i+check_distance;
+
+			if( A_index &lt; 0 )
+			{
+				if( points.front() == points.back() )
+					A_index += points.size();
+				else
+					A_index = 0;
+			}
+			if( B_index &gt; (int)points.size() )
+			{
+				if( points.front() == points.back() )
+					B_index -= points.size();
+				else
+					B_index = (int)points.size();
+			}
+
+			CL_Pointf &amp;A = optimized.back();
+			CL_Pointf &amp;B = points[i];
+			CL_Pointf &amp;C = points[B_index];
+
+			CL_Vector AB(B.x-A.x, B.y-A.y);
+			CL_Vector BC(C.x-B.x, C.y-B.y);
+
+			if( check_distance != 1 &amp;&amp; AB.norm() &lt; 2 )
+				continue;
+
+			float angle = AB.angle(BC);
+			
+			if( angle &gt; corner_angle )
+			{
+				optimized.push_back(points[i]);
+			}
+		}
+
+		points = optimized;
+	}
+}
+
+void CL_CollisionOutline_Generic::save(const std::string &amp;filename, CL_OutputSourceProvider *provider) const
+{
+/*	fileformat:
+
+	uint32  type        // file type identifier	
+	uint8   version     // file version	
+	uint32  width       // width of the outline
+	uint32  height      // height of the outline
+	float32 x-pos       // of enclosing disc
+	float32 y-pos       // of enclosing disc
+	float32 radius      // of enclosing disc
+
+	uint32 num_contours
+		uint32 num_points contour 1
+			float32 px1
+			float32 py1
+			float32 px2
+			float32 py2
+			... contour 1 data ...
+		uint32 num_points contour 2
+			... contour 2 data ...
+		uint32 num_points contour N
+			... contour N data ...
+*/
+
+/*	if( provider == 0 )
+		provider = new CL_OutputSourceProvider::open_source(&quot;.&quot;);
+	else
+		provider = _provider-&gt;clone();
+*/
+
+	CL_OutputSource *output_source = new CL_OutputSource_File(filename); // provider-&gt;open_source(filename);
+
+	// file type identifyer
+	output_source-&gt;write_uint32( 0x16082004 );
+
+	// fileformat version
+	output_source-&gt;write_uint8(1);
+
+	// width
+	output_source-&gt;write_int32(width);
+
+	// height
+	output_source-&gt;write_int32(height);
+
+	// x-pos of enclosing disc
+	output_source-&gt;write_float32(minimum_enclosing_disc.position.x);
+	// y-pos of enclosing disc
+	output_source-&gt;write_float32(minimum_enclosing_disc.position.y);
+	// radius of enclosing disc
+	output_source-&gt;write_float32(minimum_enclosing_disc.radius);
+	
+	// number of contours
+	output_source-&gt;write_uint32(contours.size());
+	
+	std::vector&lt;CL_Contour&gt;::const_iterator it_cont;
+	for( it_cont = contours.begin(); it_cont != contours.end(); ++it_cont )
+	{
+		// number of points in contours
+		output_source-&gt;write_uint32((*it_cont).points.size());
+		
+		std::vector&lt;CL_Pointf&gt;::const_iterator it;
+		for( it = (*it_cont).points.begin(); it != (*it_cont).points.end(); ++it )
+		{
+			// x,y of points
+			output_source-&gt;write_float32((*it).x);
+			output_source-&gt;write_float32((*it).y);
+		}
+	}
+
+	output_source-&gt;close();
+
+	delete output_source;
+}
+
+
+bool CL_CollisionOutline_Generic::collide( const CL_CollisionOutline &amp;outline, bool remove_old_collision_info)
+{
+	if( collision_info_collect &amp;&amp; remove_old_collision_info )
+	{
+		collision_info.clear();
+	}
+
+	// bounding circle test.
+	float dist = minimum_enclosing_disc.position.distance(outline.get_minimum_enclosing_disc().position);
+	
+	if( dist &gt; (minimum_enclosing_disc.radius + outline.get_minimum_enclosing_disc().radius ))
+		return false;
+
+
+	bool any_collisions = false;
+	// collision sub circle test
+	std::vector&lt;CL_Contour&gt;::const_iterator it_contours, it_contours2;
+	for( it_contours = contours.begin(); it_contours != contours.end(); ++it_contours )
+	{
+		for( it_contours2 = outline.get_contours().begin();
+			 it_contours2 != outline.get_contours().end();
+			 ++it_contours2 )
+		{
+			if( contours_collide( (*it_contours), (*it_contours2) ) )
+			{
+				if( collision_info_collect == false ) 
+					return true; // don't return info about all line intersections
+				any_collisions = true;
+			}
+			else if( do_inside_test || outline.get_inside_test() )
+			{
+				if( point_inside_contour((*it_contours).points[0], (*it_contours2)))
+				{
+					if( collision_info_collect )
+					{
+						// Add this info to the
+						collision_info.push_back(CL_CollidingContours(&amp;(*it_contours), &amp;(*it_contours2), true));
+					}
+					else
+					{
+						return true; // don't return info about the collision
+					}
+					any_collisions = true;
+				}
+				if(point_inside_contour((*it_contours2).points[0], (*it_contours)) )
+				{
+					if( collision_info_collect )
+					{
+						// Add this info to the
+						collision_info.push_back(CL_CollidingContours(&amp;(*it_contours2), &amp;(*it_contours), true));
+					}
+					else
+					{
+						return true; // don't return info about the collision
+					}
+					any_collisions = true;
+				}
+			}
+		}
+	}
+
+	// Should we calculate the penetration depth
+	if( !collision_info.empty() &amp;&amp; collision_info_pen_depth &amp;&amp; remove_old_collision_info)
+	{
+		// We only do this, if we have any info and if is new collision-info.
+		calculate_penetration_depth(collision_info);
+	}
+	
+	return any_collisions;
+}
+
+
+bool CL_CollisionOutline_Generic::point_inside( const CL_Pointf &amp;point ) const
+{
+	float dist = minimum_enclosing_disc.position.distance(point);
+	
+	if( dist &gt; minimum_enclosing_disc.radius)
+		return false;
+
+	std::vector&lt;CL_Contour&gt;::const_iterator it;	
+	for( it = contours.begin(); it != contours.end(); ++it )
+	{
+		if( point_inside_contour(point, (*it)) )
+		{
+			return true;
+		}
+	}
+	
+	return false;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_CollisionOutline_Generic Implementation:
+
+bool CL_CollisionOutline_Generic::point_inside_contour( const CL_Pointf &amp;point, const CL_Contour &amp;contour )
+{
+	// In case the contour is inside-out (the inside of a hollow polygon) it makes no sense to do this test.
+	if(contour.is_inside_contour)
+		return false;
+	
+	float lineX[4];
+	lineX[0] = point.x;
+	lineX[1] = point.y+0.000f;
+	lineX[2] = point.x+99999.0f; // contour.get_radius()*4;
+	lineX[3] = point.y+0.000f;
+
+	// collide the line with the outline.
+	int num_intersections_x = 0;
+
+	const std::vector&lt;CL_Pointf&gt; &amp;points = contour.points;
+
+	std::vector&lt;CL_OutlineCircle&gt;::const_iterator it;
+	for( it = contour.sub_circles.begin();
+		 it != contour.sub_circles.end();
+		 ++it )
+	{
+		const CL_OutlineCircle &amp;circle = (*it);
+
+		float dist = fabs(circle.position.y - point.y);
+
+		if( dist &lt;= circle.radius )
+		{
+			// test each line segment inside the circle
+		
+			for( unsigned int i=circle.start; i != circle.end; ++i )
+			{
+				float line2[4];
+				line2[0] = points[ i    % points.size()].x;
+				line2[1] = points[ i    % points.size()].y;
+				line2[2] = points[(i+1) % points.size()].x;
+				line2[3] = points[(i+1) % points.size()].y;
+
+				if( CL_LineMath::intersects(lineX, line2, false) )
+				{
+					num_intersections_x++;
+				}
+			}
+		}
+	}
+
+	if( num_intersections_x % 2 )
+	{
+		return true;
+	}
+	
+	return false;
+}
+
+inline bool CL_CollisionOutline_Generic::line_bounding_box_overlap( const std::vector&lt;CL_Pointf&gt; &amp;rect1, const std::vector&lt;CL_Pointf&gt; &amp;rect2, int i, int j, int i2, int j2 ) const
+{
+	float left   = cl_min(rect1[i].x, rect1[i2].x);
+	float right  = cl_max(rect1[i].x, rect1[i2].x);
+	float top    = cl_min(rect1[i].y, rect1[i2].y);
+	float bottom = cl_max(rect1[i].y, rect1[i2].y);
+
+	float r_left   = cl_min(rect2[j].x, rect2[j2].x);
+	float r_right  = cl_max(rect2[j].x, rect2[j2].x);
+	float r_top    = cl_min(rect2[j].y, rect2[j2].y);
+	float r_bottom = cl_max(rect2[j].y, rect2[j2].y);
+
+	return (r_left &lt;= right &amp;&amp; r_right &gt;= left &amp;&amp; r_top &lt;= bottom &amp;&amp; r_bottom &gt;= top);
+}
+
+bool CL_CollisionOutline_Generic::contours_collide(const CL_Contour &amp;contour1, const CL_Contour &amp;contour2, bool do_subcirle_test)
+{
+	CL_CollidingContours metadata(&amp;contour1, &amp;contour2);
+	
+	std::vector&lt;CL_OutlineCircle&gt;::const_iterator it_oc1, it_oc2;
+	for( it_oc1 = contour1.sub_circles.begin(); it_oc1 != contour1.sub_circles.end(); ++it_oc1 )
+	{
+		for( it_oc2 = contour2.sub_circles.begin(); it_oc2 != contour2.sub_circles.end(); ++it_oc2 )
+		{
+			if( do_subcirle_test ? (*it_oc1).collide(*it_oc2) : true ) // outline circles collide
+			{
+				// test each line segment inside the colliding circles
+
+				const std::vector&lt;CL_Pointf&gt; &amp;points1 = contour1.points;
+				const std::vector&lt;CL_Pointf&gt; &amp;points2 = contour2.points;
+				
+				int num_points1 = points1.size();
+				int num_points2 = points2.size();
+				
+				for( unsigned int counter_i=(*it_oc1).start; counter_i != (*it_oc1).end; ++counter_i )
+				{
+					int i  = counter_i % num_points1;
+					int i2 = (counter_i+1) % num_points1;
+					
+					for( unsigned int counter_j=(*it_oc2).start; counter_j != (*it_oc2).end; ++counter_j )
+					{
+						int j  = counter_j % num_points2;
+						int j2 = (counter_j+1) % num_points2;
+						
+						if( line_bounding_box_overlap(points1, points2, i, j, i2, j2) )
+						{
+							float line1[4];
+							line1[0] = points1[i].x;
+							line1[1] = points1[i].y;
+							line1[2] = points1[i2].x;
+							line1[3] = points1[i2].y;
+							
+							float line2[4];
+							line2[0] = points2[j].x;
+							line2[1] = points2[j].y;
+							line2[2] = points2[j2].x;
+							line2[3] = points2[j2].y;
+
+							if( CL_LineMath::intersects( line1, line2 ) )
+							{
+								if( collision_info_collect )
+								{
+									CL_CollisionPoint collisionpoint;
+									
+									if ( collision_info_points )
+									{
+										collisionpoint.point = CL_LineMath::get_intersection(line1,line2);
+									}
+									
+									if( collision_info_normals )
+									{
+										collisionpoint.normal = CL_LineMath::normal(line2);
+									}
+									
+									if( collision_info_meta )
+									{
+										collisionpoint.contour1_line_start = i;
+										collisionpoint.contour1_line_end   = i2;
+										collisionpoint.contour2_line_start = j;
+										collisionpoint.contour2_line_end   = j2;
+										// Found by the dot-product of line1 and the perpendicular of line2:
+										{
+											CL_Pointf line1(points1[i2].x - points1[i].x, points1[i2].y - points1[i].y);
+											CL_Pointf line2(-(points2[j2].y - points2[j].y), points2[j2].x - points2[j].x);
+											collisionpoint.is_entry = (line1.x * line2.x + line1.y * line2.y) &lt; 0.0;
+										}
+									}
+									metadata.points.push_back(collisionpoint);
+								}
+								else
+									return true;
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+	if( collision_info_collect &amp;&amp; metadata.points.size() &gt; 0)
+	{
+		// Add this info
+		collision_info.push_back(metadata);
+		return true;
+	}
+
+	return false;
+}
+
+void CL_CollisionOutline_Generic::calculate_penetration_depth( std::vector&lt; CL_CollidingContours &gt; &amp; collision_info )
+{
+	// Figure out the pen-depth
+	for(std::vector&lt;CL_CollidingContours&gt;::iterator it = collision_info.begin(); it != collision_info.end(); ++it)
+	{
+		CL_CollidingContours &amp;cc = (*it);
+		if(cc.points.size() % 2 != 0)
+		{
+			std::cout &lt;&lt; &quot;ERROR: we have an uneven number of collisionpoints: &quot; &lt;&lt; cc.points.size() &lt;&lt; &quot;\n&quot;;
+			for(std::vector&lt;CL_CollisionPoint&gt;::iterator pit = cc.points.begin(); pit != cc.points.end(); ++pit)
+			{
+				CL_CollisionPoint &amp;p1 = (*pit);
+				std::cout &lt;&lt; &quot;\tLineSegment1:&quot;
+					&lt;&lt; &quot;(&quot; &lt;&lt; cc.contour1-&gt;points[p1.contour1_line_start].x
+					&lt;&lt; &quot;,&quot; &lt;&lt; cc.contour1-&gt;points[p1.contour1_line_start].y &lt;&lt; &quot;) - &quot;
+					&lt;&lt; &quot;(&quot; &lt;&lt; cc.contour1-&gt;points[p1.contour1_line_end].x
+					&lt;&lt; &quot;,&quot; &lt;&lt; cc.contour1-&gt;points[p1.contour1_line_end].y &lt;&lt; &quot;)\n&quot;;
+				std::cout &lt;&lt; &quot;\tLineSegment2:&quot;
+					&lt;&lt; &quot;(&quot; &lt;&lt; cc.contour2-&gt;points[p1.contour2_line_start].x
+					&lt;&lt; &quot;,&quot; &lt;&lt; cc.contour2-&gt;points[p1.contour2_line_start].y &lt;&lt; &quot;) - &quot;
+					&lt;&lt; &quot;(&quot; &lt;&lt; cc.contour2-&gt;points[p1.contour2_line_end].x
+					&lt;&lt; &quot;,&quot; &lt;&lt; cc.contour2-&gt;points[p1.contour2_line_end].y &lt;&lt; &quot;)\n&quot;;
+				std::cout &lt;&lt; &quot;\tColPoint:  (&quot;&lt;&lt;p1.point.x&lt;&lt;&quot;,&quot;&lt;&lt;p1.point.y&lt;&lt;&quot;)\n&quot;;
+				std::cout &lt;&lt; &quot;\tColNormal: (&quot;&lt;&lt;p1.normal.x&lt;&lt;&quot;,&quot;&lt;&lt;p1.normal.y&lt;&lt;&quot;)\n&quot;;
+				std::cout &lt;&lt; &quot;\tis_entry: &quot; &lt;&lt; p1.is_entry &lt;&lt;&quot;\n&quot;;
+				std::cout &lt;&lt; &quot;\tcontour1_line_start: &quot;&lt;&lt;p1.contour1_line_start&lt;&lt;&quot;, &quot;
+					&lt;&lt;&quot;contour1_line_end: &quot;&lt;&lt;p1.contour1_line_end&lt;&lt;&quot;,\n&quot;
+					&lt;&lt;&quot;\tcontour2_line_start: &quot;&lt;&lt;p1.contour2_line_start&lt;&lt;&quot;, &quot;
+					&lt;&lt;&quot;contour2_line_end: &quot;&lt;&lt;p1.contour2_line_end &lt;&lt;&quot;\n&quot;;
+			}
+			std::cout &lt;&lt; &quot;RORRE\n&quot;;
+			continue;
+		}
+		// First calculate one common normal for the whole thing
+		// FIXME: oposing normals might generate (0,0) as normal, and that can not be right.
+		CL_Vector2 normal(0.0,0.0);
+		unsigned int cp;
+		for(cp = 0; cp &lt; cc.points.size(); cp+=2)
+		{
+			std::vector&lt;CL_Pointf&gt; c1points;
+			std::vector&lt;CL_Pointf&gt; c2points;
+			int firstpoint = cp;
+			if(!cc.points[firstpoint].is_entry)
+				firstpoint++;
+			CL_CollisionPoint p1 = cc.points[firstpoint     % cc.points.size()];
+			CL_CollisionPoint p2 = cc.points[(firstpoint+1) % cc.points.size()];
+
+			normal.x += -(p1.point - p2.point).y;
+			normal.y += (p1.point - p2.point).x;
+		}
+		normal.unitize();
+		cc.penetration_normal = CL_Pointf(normal.x, normal.y);
+
+		// Now look at each and every overlapping region
+		cc.penetration_depth = 0.0;
+		for(unsigned int cp2 = 0; cp2 &lt; cc.points.size(); cp2+=2)
+		{
+			std::vector&lt;CL_Pointf&gt; c1points;
+			std::vector&lt;CL_Pointf&gt; c2points;
+			int firstpoint = cp2;
+			if(!cc.points[firstpoint].is_entry)
+				firstpoint++;
+
+			CL_CollisionPoint p1 = cc.points[firstpoint     % cc.points.size()];
+			CL_CollisionPoint p2 = cc.points[(firstpoint+1) % cc.points.size()];
+
+			// Get points inside on c1
+			c1points.push_back(p2.point - p1.point);
+			c1points.push_back(p1.point - p1.point);
+			for(int p4 = p1.contour1_line_end; p4 != p2.contour1_line_end; p4 = ((p4+1) % cc.contour1-&gt;points.size()))
+			{
+				c1points.push_back(cc.contour1-&gt;points[p4] - p1.point);
+				//c1points.push_back(cc.contour1-&gt;points[p]);
+			}
+			// Get points inside on c2
+			c2points.push_back(p2.point - p1.point);
+			c2points.push_back(p1.point - p1.point);
+			for(int p6 = p2.contour2_line_end; p6 != p1.contour2_line_end; p6 = ((p6+1) % cc.contour2-&gt;points.size()))
+			{
+				c2points.push_back(cc.contour2-&gt;points[p6] - p1.point);
+				//c2points.push_back(cc.contour2-&gt;points[p]);
+			}
+		
+			// Calculate the penetration-depth of this overlap
+			float c1maxdepth = FLT_MAX;
+			float c2maxdepth = FLT_MIN;
+			for(unsigned int p5 = 0; p5 &lt; c1points.size(); p5++)
+			{
+				// The dotproduct is the projection onto an other vector
+				float newdepth = c1points[p5].x * normal.x + c1points[p5].y * normal.y;
+				if(newdepth &lt; c1maxdepth)
+				{
+					cc.contour1_deep_point = c1points[p5] + p1.point;
+					c1maxdepth = newdepth;
+				}
+			}
+			for(unsigned int p = 0; p &lt; c2points.size(); p++)
+			{
+				// The dotproduct is the projection onto an other vector
+				float newdepth = c2points[p].x * normal.x + c2points[p].y * normal.y;
+				if(newdepth &gt; c2maxdepth)
+				{
+					cc.contour2_deep_point = c2points[p] + p1.point;
+					c2maxdepth = newdepth;
+				}
+			}
+			cc.penetration_depth = cl_max(cc.penetration_depth, c2maxdepth - c1maxdepth);
+		}
+		
+		//NONO: maxpendepth = std::min(maxpendepth, 40.0f);
+	}
+}

Added: trunk/clanlib/Display/Collision/collision_outline_generic.h
===================================================================
--- trunk/clanlib/Display/Collision/collision_outline_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Collision/collision_outline_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,102 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    Emanuel Greisen
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_surface_outline_generic
+#define header_surface_outline_generic
+
+#include &quot;API/Display/Collision/collision_outline.h&quot;
+#include &quot;Display/Collision/collision_outline_generic.h&quot;
+#include &quot;API/Display/Collision/contour.h&quot;
+#include &quot;API/Display/Collision/outline_circle.h&quot;
+#include &quot;API/Display/Collision/outline_accuracy.h&quot;
+#include &quot;API/Core/Math/rect.h&quot;
+
+class CL_OutlineProvider;
+
+class CL_CollisionOutline_Generic
+{
+//! Construction:
+public:
+	CL_CollisionOutline_Generic();
+	CL_CollisionOutline_Generic( CL_OutlineProvider *provider, CL_OutlineAccuracy accuracy );
+	
+	~CL_CollisionOutline_Generic();
+
+//! Attributes:
+public:
+	std::vector&lt;CL_Contour&gt; contours;
+	bool do_inside_test;
+
+	int width, height;
+	float angle;
+	//float radius;
+	CL_Circlef minimum_enclosing_disc;
+
+	CL_Pointf position;
+	CL_Pointf scale_factor;
+	CL_Pointf translation_offset;
+	CL_Origin translation_origin;
+	CL_Pointf rotation_hotspot;
+	CL_Origin rotation_origin;
+
+	bool collision_info_points;
+	bool collision_info_normals;
+	bool collision_info_meta;
+	bool collision_info_pen_depth;
+	///&lt; points || normals || meta (quick way of seeing if any info is collected)
+	bool collision_info_collect;
+
+	std::vector&lt;CL_CollidingContours&gt; collision_info;
+
+//! Operations:
+ public:
+	void set_translation(float x, float y, bool offset_points=false);
+	void set_scale(float sx, float sy);
+	void set_angle(float angle);
+	void rotate(float angle);
+
+	void optimize(unsigned char check_distance, float corner_angle);
+	void save(const std::string &amp;filename, CL_OutputSourceProvider *provider) const;
+
+	bool collide( const CL_CollisionOutline &amp;outline, bool remove_old_collision_info);
+	bool point_inside( const CL_Pointf &amp;point ) const;
+	static bool point_inside_contour( const CL_Pointf &amp;point, const CL_Contour &amp;contour);
+	bool contours_collide(const CL_Contour &amp;contour1, const CL_Contour &amp;contour2, bool do_subcirle_test=true);
+	static void calculate_penetration_depth(std::vector&lt;CL_CollidingContours&gt; &amp;collision_info);
+
+	void calculate_radius();
+	void calculate_sub_circles(float radius_multiplier=3.5f);
+	void calculate_smallest_enclosing_discs();
+	void calculate_convex_hulls();
+
+	inline bool line_bounding_box_overlap( const std::vector&lt;CL_Pointf&gt; &amp;rect1, const std::vector&lt;CL_Pointf&gt; &amp;rect2, int i, int j, int i2, int j2 ) const;
+};
+
+#endif

Added: trunk/clanlib/Display/Collision/outline_math.cpp
===================================================================
--- trunk/clanlib/Display/Collision/outline_math.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Collision/outline_math.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,119 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Emanuel Greisen
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/Collision/outline_math.h&quot;
+#include &quot;API/Display/Collision/outline_circle.h&quot;
+#include &quot;API/Core/Math/line_math.h&quot;
+#include &quot;API/Core/Math/pointset_math.h&quot;
+#include &quot;API/Core/Math/point.h&quot;
+
+
+//    Variant of minimum enclosing disc routines, now with radius cap.
+
+void CL_OutlineMath::minimum_enclosing_sub_circle(
+	CL_OutlineCircle &amp;smalldisc,
+	const std::vector&lt;CL_Pointf&gt; &amp;points,
+	float maxradius)
+{
+	int real_i_indx = smalldisc.end % points.size();
+	// Get first disc (between the first two points)
+	smalldisc.position = CL_LineMath::midpoint(points[smalldisc.start], points[real_i_indx]);
+	smalldisc.radius   = points[smalldisc.start].distance(points[real_i_indx]) / 2.0;
+	while(smalldisc.end &lt; points.size())
+	{
+		// Add next one
+		smalldisc.end++;
+		real_i_indx = smalldisc.end % points.size();
+		// only enlargen the circle if points[i] is not already contained
+		if(smalldisc.position.distance(points[real_i_indx]) &gt; smalldisc.radius)
+		{
+			// Break if we have already exceeded the radius
+			if(smalldisc.radius &gt; maxradius)
+			{
+				smalldisc.end--;
+				return;
+			}
+			CL_OutlineMath::minimum_enclosing_sub_circle_with_1point(smalldisc, points);
+		}
+	}
+}
+
+
+void CL_OutlineMath::minimum_enclosing_sub_circle_with_1point(
+	CL_OutlineCircle &amp;smalldisc,
+	const std::vector&lt;CL_Pointf&gt; &amp;points)
+{
+	int real_i_indx = smalldisc.end % points.size();
+	// Get first disc (between the first point and `points[i]`)
+	smalldisc.position = CL_LineMath::midpoint(points[smalldisc.start], points[real_i_indx]);
+	smalldisc.radius   = points[smalldisc.start].distance(points[real_i_indx]) / 2.0;
+	//for(int j = smalldisc.start; j &lt; smalldisc.end; j++)
+	for(unsigned int j = smalldisc.start+1; j &lt; smalldisc.end; j++)
+	{
+		int real_j_indx = j % points.size();
+		// only enlargen the circle if points[j] is not already contained
+		if(smalldisc.position.distance(points[real_j_indx]) &gt; smalldisc.radius)
+		{
+			CL_OutlineMath::minimum_enclosing_sub_circle_with_2points(smalldisc, points, j);
+		}
+	}
+}
+
+
+void CL_OutlineMath::minimum_enclosing_sub_circle_with_2points(
+	CL_OutlineCircle &amp;smalldisc,
+	const std::vector&lt;CL_Pointf&gt; &amp;points,
+	unsigned int j)
+{
+	int real_i_indx = smalldisc.end % points.size();
+	int real_j_indx = j % points.size();
+
+	// Get first disc (between `points[j]` and `points[i]`)
+	smalldisc.position = CL_LineMath::midpoint(points[real_j_indx], points[real_i_indx]);
+	smalldisc.radius   = points[real_j_indx].distance(points[real_i_indx]) / 2.0;
+	for(unsigned int k = smalldisc.start; k &lt; j; k++)
+	{
+		if(k == smalldisc.end || k == j)
+			continue;
+		int real_k_indx = k % points.size();
+		// only enlargen the circle if points[k] is not already contained
+		if(smalldisc.position.distance(points[real_k_indx]) &gt; smalldisc.radius)
+		{
+			CL_Circlef tmp_disc;
+			tmp_disc.position = smalldisc.position;
+			tmp_disc.radius = smalldisc.radius;
+			CL_PointSetMath::minimum_disc_with_3points(tmp_disc, points, real_i_indx, j, real_k_indx);
+			smalldisc.position = tmp_disc.position;
+			smalldisc.radius = tmp_disc.radius;
+		}
+	}
+}
+
+

Added: trunk/clanlib/Display/Collision/outline_provider_bitmap.cpp
===================================================================
--- trunk/clanlib/Display/Collision/outline_provider_bitmap.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Collision/outline_provider_bitmap.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,68 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Harry Storbacka
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/pixel_buffer.h&quot;
+#include &quot;API/Display/Collision/outline_provider_bitmap.h&quot;
+#include &quot;API/Display/Collision/outline_accuracy.h&quot;
+#include &quot;outline_provider_bitmap_generic.h&quot;
+#include &quot;API/Display/Collision/outline_circle.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OutlineProviderBitmap construction:
+
+CL_OutlineProviderBitmap::CL_OutlineProviderBitmap(CL_PixelBuffer pbuf, int alpha_limit, bool get_insides)
+{
+	impl = new CL_OutlineProviderBitmap_Generic( pbuf, alpha_limit, get_insides);
+}
+
+CL_OutlineProviderBitmap::~CL_OutlineProviderBitmap()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OutlineProviderBitmap attributes:
+
+std::vector&lt;CL_Contour&gt; CL_OutlineProviderBitmap::get_contours()
+{
+	return impl-&gt;contours;
+}
+
+int CL_OutlineProviderBitmap::get_width()
+{
+	return impl-&gt;width;
+}
+
+int CL_OutlineProviderBitmap::get_height()
+{
+	return impl-&gt;height;
+}
+

Added: trunk/clanlib/Display/Collision/outline_provider_bitmap_generic.cpp
===================================================================
--- trunk/clanlib/Display/Collision/outline_provider_bitmap_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Collision/outline_provider_bitmap_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,440 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Harry Storbacka
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/Collision/outline_accuracy.h&quot;
+#include &quot;API/Display/Collision/outline_circle.h&quot;
+#include &quot;API/Display/pixel_buffer.h&quot;
+#include &quot;API/Display/pixel_format.h&quot;
+#include &quot;API/Core/IOData/cl_endian.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;outline_provider_bitmap_generic.h&quot;
+#include &quot;collision_outline_generic.h&quot;
+
+CL_OutlineProviderBitmap_Generic::CL_OutlineProviderBitmap_Generic(
+	CL_PixelBuffer pbuf,
+	int alpha_limit,
+	bool get_insides)
+:
+	data(0),
+	get_insides(get_insides),
+	alpha_limit(alpha_limit),
+	//double_precision(false),
+	//consecutive_left_turns(0),
+	//consecutive_right_turns(0),
+	alpha_pixel(CL_Endian::is_system_big() ? 3 : 0),
+	pb(pbuf),
+	last_point(0,0),
+	last_dir(DIR_LEFT)
+{
+	if( pbuf.get_format() != CL_PixelFormat::rgba8888 )
+	{
+		// the image contains no alpha - add only a rectangle
+		CL_Contour contour;
+		
+		contour.points.push_back( CL_Pointf(0.0f,0.0f) );
+		contour.points.push_back( CL_Pointf(0.0f,(float)height) );
+		contour.points.push_back( CL_Pointf((float)width,(float)height) );
+		contour.points.push_back( CL_Pointf((float)width,0.0f) );
+		
+		contours.push_back(contour);
+		
+		return;
+	}
+
+	height = pbuf.get_height();
+	width = pbuf.get_width();
+	
+	// allocate a grid of unsigned chars, this represents the corners between pixels.
+	// We will only use the first 4 bits of each char:
+	//  (1 &lt;&lt; 0) 0x1 : the pixel to the upper left
+	//  (1 &lt;&lt; 1) 0x2 : the pixel to the upper right
+	//  (1 &lt;&lt; 2) 0x4 : the pixel to the lower left
+	//  (1 &lt;&lt; 3) 0x8 : the pixel to the lower right
+	data = new unsigned char[(height+1)*(width+1)];
+
+	// The image part
+	pbuf.lock();
+	for(int y = 0; y &lt;= height; y++)
+	{
+		for(int x = 0; x &lt;= width; x++)
+		{
+			get_corner(x,y) = 0x0;
+			if(is_opaque(x-1,y-1))
+				get_corner(x,y) |= 0x1;
+			if(is_opaque(x,y-1))
+				get_corner(x,y) |= 0x2;
+			if(is_opaque(x-1,y))
+				get_corner(x,y) |= 0x4;
+			if(is_opaque(x,y))
+				get_corner(x,y) |= 0x8;
+		}
+	}
+	pbuf.unlock();
+
+	find_contours();
+}
+
+CL_OutlineProviderBitmap_Generic::~CL_OutlineProviderBitmap_Generic()
+{
+	delete data;
+}
+
+void CL_OutlineProviderBitmap_Generic::find_contours()
+{
+	CL_Pointf start_point(find_next_contour_start(0,0));
+		
+	while( start_point.x != -1.0f &amp;&amp; start_point.y != -1.0f )
+	{
+		CL_Contour contour;
+		
+		contour.points.push_back(start_point);
+
+		// initialize outline finder algorithm (get_next_point)
+		last_point = CL_Point(start_point);
+		last_corner = get_corner(last_point.x,last_point.y); // can be 0x8 or 0xe
+		if(last_corner == 0x8)
+		{
+			// This is the top left corner of an outside contour
+			last_dir = DIR_LEFT; // Since we are now going down, last time we was going left.
+			contour.is_inside_contour = false;
+		}
+		else if(last_corner == 0x7)
+		{
+			// This is the top left corner of an inside contour
+			last_dir = DIR_UP; // Since we are now going right, last time was up
+			contour.is_inside_contour = true;
+		}
+		else
+			throw CL_Error(&quot;Arg, the start corner is not of any of the two known types: 0x8, 0x7\n&quot;);
+			
+		while( true )
+		{
+			get_next_point(contour.points);
+			
+			if( contour.points.front().x == contour.points.back().x
+				&amp;&amp; contour.points.front().y == contour.points.back().y )
+			{
+				if( contour.points.size() &gt; 3 )
+				{
+					// line loop closed, remove last point (its the same as the first)
+					contour.points.pop_back();
+					break;
+				}
+				else
+					throw CL_Error(CL_String::format(&quot;Error: front() == back(), but only %1  points in list&quot;, (int)contour.points.size()));
+			}
+
+			if( contour.points.size() &gt; 10000 ) break; // Sanity ?
+		}
+		// Now we have found the points for the contour, but this contour might be an
+		// inside of some other contour.
+		//   (Image a big 'O' would give two contours one on the outside, one on the inside
+		//    but the inside one is inside-out, very bad !)
+		// If this is the case we should &quot;connect&quot; it to the outer contour, that way they
+		// become one concave contour, and all collision-tests will work.
+		if(!contour.is_inside_contour)
+		{
+			// It's a normal (outside) contour
+			contour.sub_circles.clear();
+			contours.push_back(contour);
+		}
+		else
+		{
+			if(get_insides)
+			{
+				// Reverse the points (and shift by one, to get the same point as the front)
+				std::vector&lt;CL_Pointf&gt; rpoints;
+				rpoints.push_back(contour.points.front());
+				contour.points.erase(contour.points.begin());
+				std::vector&lt;CL_Pointf&gt;::reverse_iterator it = contour.points.rend();
+				do
+				{
+					it--;
+					rpoints.push_back(*it);
+				}
+				while(it != contour.points.rbegin());
+				// Since we will be going through our starting point twice, we add it to the end.
+				rpoints.push_back(rpoints.front());
+				
+				CL_Contour *outside_contour = 0;
+				CL_Pointf tmp_point = rpoints.front();
+				// Look for the outside contour to the left of our starting point (that was the upper left corner, remember)
+				while(!outside_contour)
+				{
+					tmp_point.x--;
+					outside_contour = point_in_outline((int)tmp_point.x, (int)tmp_point.y);
+				}
+				// Now we have the outside contour, and we know at what point we can splice our selves in.
+				// then all we need to do is combine the two vectors, into one great list of points.
+				std::vector&lt;CL_Pointf&gt; combined_points;
+				// First add from the outer contour untill we reach the point where we should splice.
+				while(outside_contour-&gt;points.size() &gt; 0)
+				{
+					CL_Pointf outside_point = outside_contour-&gt;points.front();
+					combined_points.push_back(outside_point);
+					outside_contour-&gt;points.erase(outside_contour-&gt;points.begin());
+					if(outside_point.x == tmp_point.x &amp;&amp; outside_point.y == tmp_point.y)
+					{
+						CL_Pointf bridge_point(outside_point);
+						// Build the bridge from the outside to the inside
+						for(bridge_point.x++; bridge_point.x != rpoints.front().x; bridge_point.x++)
+						{
+							combined_points.push_back(bridge_point);
+						}
+							
+						// Now its time to add our reversed points
+						for(std::vector&lt;CL_Pointf&gt;::iterator it = rpoints.begin(); it != rpoints.end(); ++it)
+						{
+							combined_points.push_back(*it);
+						}
+
+						bridge_point = combined_points.back();
+						// Build the bridge back from the inside to the outside
+						// Build the bridge from the outside to the inside
+						for(bridge_point.x--; bridge_point.x != outside_point.x; bridge_point.x--)
+						{
+							combined_points.push_back(bridge_point);
+						}
+						
+						// And add the outside point again to complete the link
+						combined_points.push_back(outside_point);
+					}
+				}
+				// Now we have combined the points, then we just add them to the other contour.
+				outside_contour-&gt;points = combined_points;
+			}
+		}
+	
+		int next_search_start_x = (int)start_point.x + 1;
+		int next_search_start_y = (int)start_point.y;
+
+		if( next_search_start_x &gt;= width+1 )
+		{
+			next_search_start_x = 0;
+			next_search_start_y++;
+			if( next_search_start_y &gt;= height+1 )
+				break;
+		}
+
+		start_point = find_next_contour_start(
+			next_search_start_x,
+			next_search_start_y);
+	}
+}
+
+
+CL_Pointf CL_OutlineProviderBitmap_Generic::find_next_contour_start(unsigned int sx, unsigned int sy)
+{
+	// we start where we last stopped
+	for( int y=sy; y &lt; height+1; y++ )
+	{
+		// first time we start where we last stopped
+		for( int x=sx; x &lt; width+1; x++ )
+		{
+			// We can only start on a corner facing up and left, unless we also look for insides
+			if( get_corner(x,y) == 0x8 || (get_insides &amp;&amp; get_corner(x,y) == 0x7) )
+			{
+				// Lets check that it has not already been used
+				if( !point_in_outline(x,y) )
+					return CL_Pointf((float)x,(float)y);
+			}
+		}
+		sx = 0;
+	}
+	
+	return CL_Pointf(-1.0f,-1.0f);
+}
+
+
+
+void CL_OutlineProviderBitmap_Generic::get_next_point(std::vector&lt;CL_Pointf&gt; &amp;points)
+{
+	/*
+	 See what type of corner we are, this gives us our counter-clockwise direction
+	  in case of interesting places with connected corners, we use the last direction to figure it out.
+	  above all cases in the switch, you can se what pixels are opaque if the corner in question is the middle
+	  corner.
+	*/
+	MoveDir next_dir = DIR_UP;
+	switch(last_corner)
+	{
+	// X0
+	// 00
+	case 0x1:
+		next_dir = DIR_UP;
+		break;
+	// 0X
+	// 00
+	case 0x2:
+		next_dir = DIR_RIGHT;
+		break;
+	// XX
+	// 00
+	case 0x3:
+		next_dir = DIR_RIGHT;
+		break;
+	// 00
+	// X0
+	case 0x4:
+		next_dir = DIR_LEFT;
+		break;
+	// X0
+	// X0
+	case 0x5:
+		next_dir = DIR_UP;
+		break;
+	// 0X
+	// X0
+	case 0x6:
+		if(last_dir == DIR_UP)
+			next_dir = DIR_RIGHT;
+		else if(last_dir == DIR_DOWN)
+			next_dir = DIR_LEFT;
+		else
+			throw CL_Error(CL_String::format(&quot;Came to a corner-type: 0x6, but last direction was: %1&quot;,last_dir));
+		break;
+	// XX
+	// X0
+	case 0x7:
+		next_dir = DIR_RIGHT;
+		break;
+	// 00
+	// 0X
+	case 0x8:
+		next_dir = DIR_DOWN;
+		break;
+	// X0
+	// 0X
+	case 0x9:
+		if(last_dir == DIR_RIGHT)
+			next_dir = DIR_DOWN;
+		else if(last_dir == DIR_LEFT)
+			next_dir = DIR_UP;
+		else
+			throw CL_Error(CL_String::format(&quot;Came to a corner-type: 0x9, but last direction was: %1&quot;, last_dir));
+		break;
+	// 0X
+	// 0X
+	case 0xa:
+		next_dir = DIR_DOWN;
+		break;
+	// XX
+	// 0X
+	case 0xb:
+		next_dir = DIR_DOWN;
+		break;
+	// 00
+	// XX
+	case 0xc:
+		next_dir = DIR_LEFT;
+		break;
+	// X0
+	// XX
+	case 0xd:
+		next_dir = DIR_UP;
+		break;
+	// 0X
+	// XX
+	case 0xe:
+		next_dir = DIR_LEFT;
+		break;
+	
+	default:
+		throw CL_Error(CL_String::format(&quot;Unknown corner-type: %1&quot;, last_corner));
+		break;
+	}
+	
+	CL_Point next_point(0,0);
+	switch (next_dir)
+	{
+	case DIR_UP:
+		//printf(&quot;up (%x)\n&quot;, last_corner);
+		next_point = CL_Point(last_point.x, last_point.y-1);
+		break;
+	case DIR_DOWN:
+		//printf(&quot;down (%x)\n&quot;, last_corner);
+		next_point = CL_Point(last_point.x, last_point.y+1);
+		break;
+	case DIR_LEFT:
+		//printf(&quot;left (%x)\n&quot;, last_corner);
+		next_point = CL_Point(last_point.x-1, last_point.y);
+		break;
+	case DIR_RIGHT:
+		//printf(&quot;right (%x)\n&quot;, last_corner);
+		next_point = CL_Point(last_point.x+1, last_point.y);
+		break;
+	}
+	last_point = next_point;
+	last_dir = next_dir;
+	last_corner = get_corner(next_point.x, next_point.y);
+	points.push_back(next_point);
+}
+
+CL_Contour *CL_OutlineProviderBitmap_Generic::point_in_outline(unsigned int x, unsigned int y)
+{
+	std::vector&lt;CL_Contour&gt;::iterator it;
+	for( it = contours.begin(); it != contours.end(); ++it )
+	{
+		std::vector&lt;CL_Pointf&gt;::iterator ita;
+		for( ita = (*it).points.begin(); ita != (*it).points.end(); ++ita )
+		{
+			if( (*ita).x == x &amp;&amp; (*ita).y == y ) 
+			{
+				return &amp;(*it);
+			}
+		}
+	}
+
+	return 0;
+}
+
+bool CL_OutlineProviderBitmap_Generic::is_opaque(int x, int y)
+{
+	if(x &lt; 0 || y &lt; 0 || x &gt;= width || y &gt;= height)
+	{
+		return false;
+	}
+	
+	unsigned char *pbdata = static_cast&lt;unsigned char *&gt;(pb.get_data());
+	unsigned int pitch = pb.get_pitch();
+	unsigned char bpp = pb.get_format().get_depth()/8;
+
+	return pbdata[y*pitch+x*bpp+alpha_pixel] &gt;= alpha_limit;
+}
+
+bool CL_OutlineProviderBitmap_Generic::is_edge(int x, int y)
+{
+	// These are the only (non-edges)
+	// 0x0: empty
+	// 0xf: full
+	return (get_corner(x,y) != 0x0 &amp;&amp; get_corner(x,y) != 0xf);
+}

Added: trunk/clanlib/Display/Collision/outline_provider_bitmap_generic.h
===================================================================
--- trunk/clanlib/Display/Collision/outline_provider_bitmap_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Collision/outline_provider_bitmap_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,95 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Harry Storbacka
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_outline_provider_bitmap_generic
+#define header_outline_provider_bitmap_generic
+
+#include &quot;API/Display/Collision/contour.h&quot;
+
+class CL_PixelBuffer;
+
+class CL_OutlineProviderBitmap_Generic
+{
+//!Construction
+ public:
+	CL_OutlineProviderBitmap_Generic(CL_PixelBuffer pbuf, int alpha_limit=128, bool get_insides=true);
+	~CL_OutlineProviderBitmap_Generic();
+
+//!Attributes
+	std::vector&lt;CL_Contour&gt; contours;
+	int width, height;
+
+ private:
+	// find the start point of the next outline
+	CL_Pointf find_next_contour_start(unsigned int x, unsigned int y);
+
+	// add the next point
+	void get_next_point(std::vector&lt;CL_Pointf&gt; &amp;points);
+
+	// test if a point is already included in some outline
+	CL_Contour *point_in_outline(unsigned int x, unsigned int y);
+
+	// test if a pixel is alpha or opaque
+	bool is_opaque(int x, int y);
+
+	// test if a corner is part of an edge
+	bool is_edge(int x, int y);
+	inline unsigned char &amp;get_corner(int x, int y)
+	{
+		return data[y*(width+1)+x];
+	}
+
+	// Find the contours
+	void find_contours();
+
+	unsigned char *data;
+	unsigned char last_corner;
+
+	bool get_insides;
+	
+	int alpha_limit;
+
+	int alpha_pixel;
+
+	CL_PixelBuffer &pb;
+
+	CL_Point last_point;
+	
+	enum MoveDir
+	{
+		DIR_LEFT=0,
+		DIR_RIGHT,
+		DIR_UP,
+		DIR_DOWN
+	} last_dir;
+
+};
+
+#endif

Added: trunk/clanlib/Display/Collision/outline_provider_file.cpp
===================================================================
--- trunk/clanlib/Display/Collision/outline_provider_file.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Collision/outline_provider_file.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,66 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Harry Storbacka
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/Collision/outline_provider_file.h&quot;
+#include &quot;API/Display/Collision/outline_circle.h&quot;
+#include &quot;outline_provider_file_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OutlineProviderFile Construction:
+
+CL_OutlineProviderFile::CL_OutlineProviderFile(const std::string &amp;filename, CL_InputSourceProvider *provider)
+{
+	impl = new CL_OutlineProviderFile_Generic( filename, provider );
+}
+
+CL_OutlineProviderFile::~CL_OutlineProviderFile()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OutlineProviderFile Attributes:
+
+std::vector&lt;CL_Contour&gt; CL_OutlineProviderFile::get_contours()
+{
+	return impl-&gt;contours;
+}
+
+int CL_OutlineProviderFile::get_width()
+{
+	return impl-&gt;width;
+}
+
+int CL_OutlineProviderFile::get_height()
+{
+	return impl-&gt;height;
+}
+

Added: trunk/clanlib/Display/Collision/outline_provider_file_generic.cpp
===================================================================
--- trunk/clanlib/Display/Collision/outline_provider_file_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Collision/outline_provider_file_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,110 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Harry Storbacka
+**    Magnus Norddahl
+**    James Wynn
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Core/IOData/inputsource_provider.h&quot;
+#include &quot;API/Core/IOData/inputsource.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;outline_provider_file_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OutlineProviderFile_Generic construction:
+
+CL_OutlineProviderFile_Generic::CL_OutlineProviderFile_Generic(
+	const std::string &amp;filename,
+	CL_InputSourceProvider *_provider)
+{
+	if( _provider == 0 )
+		provider = CL_InputSourceProvider::create_file_provider(&quot;.&quot;);
+	else
+		provider = _provider-&gt;clone();
+	
+	load(filename);
+}
+
+CL_OutlineProviderFile_Generic::~CL_OutlineProviderFile_Generic()
+{
+	delete provider;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OutlineProviderFile_Generic operations:
+
+void CL_OutlineProviderFile_Generic::load(const std::string &amp;filename)
+{
+	CL_InputSource *input_source = provider-&gt;open_source(filename);
+
+	// file type &amp; version identifiers
+	int type = input_source-&gt;read_uint32();
+	unsigned char version = input_source-&gt;read_uint8();
+
+	if( type != 0x16082004  )
+		throw CL_Error(CL_String::format(&quot;File is not a collision outline file: '%1'&quot;, filename) );
+	if( version != 1 )
+		throw CL_Error(CL_String::format(&quot;Unsupported version of outline format: %1 in file '%2'. Supported versions: 1.&quot;, version, filename) );
+
+	// read in width and height
+	width = input_source-&gt;read_int32();
+	height = input_source-&gt;read_int32();
+
+	// x-pos of enclosing disc
+	minimum_enclosing_disc.position.x = input_source-&gt;read_float32();
+	// y-pos of enclosing disc
+	minimum_enclosing_disc.position.y = input_source-&gt;read_float32();
+	// radius of enclosing disc
+	minimum_enclosing_disc.radius = input_source-&gt;read_float32();
+	
+	// num contours
+	int num_contours = input_source-&gt;read_uint32();
+
+	for( int cc=0; cc &lt; num_contours; ++cc )
+	{
+		CL_Contour contour;
+
+		int num_points = input_source-&gt;read_uint32();
+
+		for( int pp=0; pp &lt; num_points; ++pp )
+		{
+			CL_Pointf point(0,0);
+			point.x = input_source-&gt;read_float32();
+			point.y = input_source-&gt;read_float32();
+
+			contour.points.push_back(point);
+		}
+		
+		contours.push_back(contour);
+	}
+
+	input_source-&gt;close();
+
+	delete input_source;
+}

Added: trunk/clanlib/Display/Collision/outline_provider_file_generic.h
===================================================================
--- trunk/clanlib/Display/Collision/outline_provider_file_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Collision/outline_provider_file_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,56 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_outline_provider_file_generic
+#define header_outline_provider_file_generic
+
+#include &quot;API/Display/Collision/contour.h&quot;
+#include &quot;API/Core/Math/circle.h&quot;
+
+#include &lt;vector&gt;
+#include &lt;string&gt;
+
+class CL_InputSourceProvider;
+
+class CL_OutlineProviderFile_Generic
+{
+ public:
+	CL_OutlineProviderFile_Generic(const std::string &amp;filename, CL_InputSourceProvider *provider);
+	~CL_OutlineProviderFile_Generic();
+
+	std::vector&lt;CL_Contour&gt; contours;
+	int width, height;
+	CL_Circlef minimum_enclosing_disc;
+
+ private:
+	void load(const std::string &amp;filename);	
+	CL_InputSourceProvider *provider;
+};
+
+#endif

Added: trunk/clanlib/Display/Makefile.am
===================================================================
--- trunk/clanlib/Display/Makefile.am	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Makefile.am	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,121 @@
+lib_LTLIBRARIES = libclanDisplay.la
+
+# FIXME: This needs to be @LIBS@ or @X11LIBS@ or something like that
+if WIN32
+else
+libclanDisplay_la_LIBADD = -L/usr/X11R6/lib/ -lX11 -lXmu -lGL -lGLU -lpng -ljpeg -lXxf86vm @X_LIBS@
+endif
+
+libclanDisplay_la_SOURCES = \
+display_target.cpp \
+display_precomp.h \
+surface.cpp \
+canvas.cpp \
+canvas_generic.h \
+color.cpp \
+display_iostream.cpp \
+display_mode.cpp \
+display_window.cpp \
+sprite_packer.cpp \
+surface_generic.cpp \
+setupdisplay.cpp \
+input_device_generic.h \
+sprite.cpp \
+graphic_context.cpp \
+graphic_context_generic.cpp \
+pixel_buffer_memory.h \
+display.cpp \
+display_window_description.cpp \
+font.cpp \
+font_target_sprite.cpp \
+keyboard.cpp \
+joystick.cpp \
+mouse.cpp \
+sprite_description.cpp \
+input_buffer.cpp \
+input_buffer_generic.h \
+input_button.cpp \
+input_button_generic.cpp \
+input_device_generic.cpp \
+input_context_generic.cpp \
+input_event.cpp \
+surface_target.cpp \
+display_precomp.cpp \
+input_device.cpp \
+key_binding.cpp \
+resourcedata_collisionoutline.cpp \
+resourcedata_font.cpp \
+resourcedata_text_styler.cpp \
+Providers/jpeg_provider.cpp \
+Providers/jpeg_provider_generic.cpp \
+Providers/jpeg_provider_generic.h \
+Providers/pcx_provider.cpp \
+Providers/pcx_provider_generic.cpp \
+Providers/pcx_provider_generic.h \
+Providers/png_provider.cpp \
+Providers/png_provider_generic.h \
+Providers/png_provider_generic.cpp \
+Providers/provider_factory.cpp \
+Providers/provider_type.cpp \
+Providers/targa_provider.cpp \
+Providers/targa_provider_generic.cpp \
+Providers/targa_provider_generic.h \
+input_context_generic.h \
+sprite_packer_generic.cpp \
+sprite_generic.cpp \
+pixel_format.cpp \
+pixel_buffer.cpp \
+pixel_buffer_generic.cpp \
+pixel_buffer_generic.h \
+pixel_buffer_memory.cpp \
+display_window_generic.h \
+sprite_generic.h \
+font_generic.h \
+font_target_sprite.h \
+surface_generic.h \
+sprite_packer_generic.h \
+font_generic.cpp \
+sprite_description_generic.h \
+surface_opengl.h \
+resourcedata_surface.cpp \
+resourcedata_sprite.cpp \
+resourcedata_sprite_description.cpp \
+surface_target.h \
+input_context.cpp \
+display_window_generic.cpp \
+glyph_buffer.cpp \
+text_styler.cpp \
+frameratecounter.cpp \
+frameratecounter_generic.h \
+Collision/collision_outline.cpp \
+Collision/collision_outline_generic.cpp \
+Collision/collision_outline_generic.h \
+Collision/outline_math.cpp \
+Collision/outline_provider_bitmap.cpp \
+Collision/outline_provider_bitmap_generic.cpp \
+Collision/outline_provider_bitmap_generic.h \
+Collision/outline_provider_file.cpp \
+Collision/outline_provider_file_generic.cpp \
+Collision/outline_provider_file_generic.h
+
+
+if WIN32
+libclanDisplay_la_SOURCES += \
+Win32/dc_buffer.cpp \
+Win32/dc_buffer_generic.cpp \
+Win32/dc_buffer_generic.h \
+Win32/display_window_win32.cpp \
+Win32/display_window_win32.h \
+Win32/input_device_directinput.cpp \
+Win32/input_device_directinput.h \
+Win32/input_device_win32keyboard.cpp \
+Win32/input_device_win32keyboard.h \
+Win32/input_device_win32mouse.cpp \
+Win32/input_device_win32mouse.h
+endif
+
+libclanDisplay_la_LDFLAGS = \
+  -release $(LT_RELEASE) \
+  -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE)
+
+# EOF #

Added: trunk/clanlib/Display/Providers/jpeg_provider.cpp
===================================================================
--- trunk/clanlib/Display/Providers/jpeg_provider.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Providers/jpeg_provider.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,162 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &lt;iostream&gt;
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/Providers/jpeg_provider.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;jpeg_provider_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_JPEGProvider construction:
+
+CL_JPEGProvider::CL_JPEGProvider(
+	const std::string &amp;name,
+	CL_InputSourceProvider *provider)
+: CL_PixelBuffer(
+	new CL_JPEGProvider_Generic(
+		name,
+		provider))
+{
+}
+
+void
+CL_JPEGProvider::save(
+	CL_PixelBuffer buffer,
+	const std::string &amp;filename,
+	CL_OutputSourceProvider *output_provider,
+        int quality)
+{
+	if (output_provider)
+		throw CL_Error(&quot;Saving to OutputSource currently not supported&quot;);
+
+	buffer.lock();
+	if (buffer.get_format() != CL_PixelFormat::bgr888)
+	{
+		CL_PixelBuffer newbuf(buffer.get_width(), buffer.get_height(), 
+									 buffer.get_width()*3, CL_PixelFormat::bgr888);
+		buffer.convert(newbuf);
+		buffer.unlock();
+		buffer = newbuf;
+		buffer.lock();
+	}
+
+	struct jpeg_compress_struct cinfo;
+	struct jpeg_error_mgr jerr;
+	/* More stuff */
+	FILE * outfile;		/* target file */
+	JSAMPROW row_pointer[1];	/* pointer to JSAMPLE row[s] */
+	int row_stride;		/* physical row width in image buffer */
+
+	/* Step 1: allocate and initialize JPEG compression object */
+
+	/* We have to set up the error handler first, in case the initialization
+	 * step fails.  (Unlikely, but it could happen if you are out of memory.)
+	 * This routine fills in the contents of struct jerr, and returns jerr's
+	 * address which we place into the link field in cinfo.
+	 */
+	cinfo.err = jpeg_std_error(&amp;jerr);
+	/* Now we can initialize the JPEG compression object. */
+	jpeg_create_compress(&amp;cinfo);
+
+	/* Step 2: specify data destination (eg, a file) */
+	/* Note: steps 2 and 3 can be done in either order. */
+
+	/* Here we use the library-supplied code to send compressed data to a
+	 * stdio stream.  You can also write your own code to do something else.
+	 * VERY IMPORTANT: use &quot;b&quot; option to fopen() if you are on a machine that
+	 * requires it in order to write binary files.
+	 */
+	if ((outfile = fopen(filename.c_str(), &quot;wb&quot;)) == NULL) {
+		throw CL_Error(&quot;can't open &quot;  + filename);
+	}
+	jpeg_stdio_dest(&amp;cinfo, outfile);
+
+	/* Step 3: set parameters for compression */
+
+	/* First we supply a description of the input image.
+	 * Four fields of the cinfo struct must be filled in:
+	 */
+	cinfo.image_width  = buffer.get_width(); 	/* image width and height, in pixels */
+	cinfo.image_height = buffer.get_height();
+	cinfo.input_components = 3;		/* # of color components per pixel */
+	cinfo.in_color_space = JCS_RGB; 	/* colorspace of input image */
+	/* Now use the library's routine to set default compression parameters.
+	 * (You must set at least cinfo.in_color_space before calling this,
+	 * since the defaults depend on the source color space.)
+	 */
+	jpeg_set_defaults(&amp;cinfo);
+	/* Now you can set any non-default parameters you wish to.
+	 * Here we just illustrate the use of quality (quantization table) scaling:
+	 */
+	jpeg_set_quality(&amp;cinfo, quality, TRUE /* limit to baseline-JPEG values */);
+
+	/* Step 4: Start compressor */
+
+	/* TRUE ensures that we will write a complete interchange-JPEG file.
+	 * Pass TRUE unless you are very sure of what you're doing.
+	 */
+	jpeg_start_compress(&amp;cinfo, TRUE);
+
+	/* Step 5: while (scan lines remain to be written) */
+	/*           jpeg_write_scanlines(...); */
+
+	/* Here we use the library's state variable cinfo.next_scanline as the
+	 * loop counter, so that we don't have to keep track ourselves.
+	 * To keep things simple, we pass one scanline per call; you can pass
+	 * more if you wish, though.
+	 */
+	row_stride = buffer.get_width() * 3;	/* JSAMPLEs per row in image_buffer */
+
+	while (cinfo.next_scanline &lt; cinfo.image_height) {
+		/* jpeg_write_scanlines expects an array of pointers to scanlines.
+		 * Here the array is only one element long, but you could pass
+		 * more than one scanline at a time if that's more convenient.
+		 */
+		row_pointer[0] = &amp;static_cast&lt;unsigned char*&gt;(buffer.get_data())[cinfo.next_scanline * row_stride];
+		(void) jpeg_write_scanlines(&amp;cinfo, row_pointer, 1);
+	}
+
+	/* Step 6: Finish compression */
+
+	jpeg_finish_compress(&amp;cinfo);
+	/* After finish_compress, we can close the output file. */
+	fclose(outfile);
+
+	/* Step 7: release JPEG compression object */
+
+	/* This is an important step since it will release a good deal of memory. */
+	jpeg_destroy_compress(&amp;cinfo);
+
+	/* And we're done! */
+
+	buffer.unlock();
+}
+
+/* EOF */

Added: trunk/clanlib/Display/Providers/jpeg_provider_generic.cpp
===================================================================
--- trunk/clanlib/Display/Providers/jpeg_provider_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Providers/jpeg_provider_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,288 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#define WIN32_LEAN_AND_MEAN
+#include &quot;jpeg_provider_generic.h&quot;
+#include &lt;setjmp.h&gt;
+#ifdef __APPLE__
+    #include &lt;libjpeg/jerror.h&gt;
+#else
+    #include &lt;jerror.h&gt;
+#endif
+#include &quot;API/Core/System/log.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/IOData/cl_endian.h&quot;
+
+#define INPUT_BUF_SIZE  4096
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_JPEGProvider_Generic construction:
+
+CL_JPEGProvider_Generic::CL_JPEGProvider_Generic(
+	const std::string &amp;name,
+	CL_InputSourceProvider *_provider)
+{
+	if (_provider == NULL)
+	{
+		input_provider = CL_InputSourceProvider::create_file_provider(&quot;.&quot;);
+	}
+	else
+	{
+		input_provider = _provider-&gt;clone();
+	}
+
+	filename = name;
+	image = NULL;
+
+	init();
+}
+
+CL_JPEGProvider_Generic::~CL_JPEGProvider_Generic()
+{
+	deinit();
+	delete input_provider;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_JPEGProvider_Generic attributes:
+
+unsigned int CL_JPEGProvider_Generic::get_red_mask() const
+{
+	return 0xff0000;
+}
+
+unsigned int CL_JPEGProvider_Generic::get_green_mask() const
+{
+	return 0x00ff00;
+}
+
+unsigned int CL_JPEGProvider_Generic::get_blue_mask() const
+{
+	return 0x0000ff;
+}
+
+unsigned int CL_JPEGProvider_Generic::get_alpha_mask() const
+{
+	return 0x000000;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_JPEGProvider_Generic operations:
+  
+void *CL_JPEGProvider_Generic::get_data()
+{
+	return image;
+}
+
+void CL_JPEGProvider_Generic::init()
+{
+	struct jpeg_error_mgr jerr;	
+	struct jpeg_decompress_struct cinfo;
+	//	FILE * infile;		
+	JSAMPARRAY buffer;	
+	int row_stride;		
+	
+	input_source = input_provider-&gt;open_source(filename);
+
+	cinfo.err = jpeg_std_error(&amp;jerr);
+	jpeg_create_decompress(&amp;cinfo);
+	jpeg_InputSource_src(&amp;cinfo, this);
+	jpeg_read_header(&amp;cinfo, TRUE);
+	jpeg_start_decompress(&amp;cinfo);
+
+	row_stride = cinfo.output_width * cinfo.output_components;
+
+	width = cinfo.output_width;
+	height = cinfo.output_height;
+	pitch = width * 3;
+
+	// FIXME: Where is the allocated memory freed?
+	buffer = (*cinfo.mem-&gt;alloc_sarray)
+		((j_common_ptr) &amp;cinfo, JPOOL_IMAGE, row_stride, 32);
+
+	image = new unsigned char[get_pitch() * cinfo.output_height];
+
+	// RGB Image
+	if (cinfo.output_components == 3)
+	{
+		while (cinfo.output_scanline &lt; cinfo.output_height) 
+		{
+			jpeg_read_scanlines(&amp;cinfo, buffer, 1);
+		
+			for(unsigned int i=0; i &lt; get_pitch(); i += 3)
+			{
+				if( CL_Endian::is_system_big() )
+				{
+					image[pitch * (cinfo.output_scanline - 1) + i + 0] = buffer[0][i + 0];
+					image[pitch * (cinfo.output_scanline - 1) + i + 1] = buffer[0][i + 1];
+					image[pitch * (cinfo.output_scanline - 1) + i + 2] = buffer[0][i + 2];
+				}
+				else
+				{
+					image[pitch * (cinfo.output_scanline - 1) + i + 0] = buffer[0][i + 2];
+					image[pitch * (cinfo.output_scanline - 1) + i + 1] = buffer[0][i + 1];
+					image[pitch * (cinfo.output_scanline - 1) + i + 2] = buffer[0][i + 0];
+				}
+			}
+		}
+	}
+	// Greyscale Image
+	else if (cinfo.output_components == 1)
+	{
+		while (cinfo.output_scanline &lt; cinfo.output_height) 
+		{
+			jpeg_read_scanlines(&amp;cinfo, buffer, 1);
+			
+			for(int i=0; i &lt; width; i += 1)
+			{
+				image[pitch * (cinfo.output_scanline - 1) + 3*i + 0] = buffer[0][i];
+				image[pitch * (cinfo.output_scanline - 1) + 3*i + 1] = buffer[0][i];
+				image[pitch * (cinfo.output_scanline - 1) + 3*i + 2] = buffer[0][i];
+			}			
+		}
+	}
+	else
+	{
+		throw CL_Error(CL_String::format(&quot;CL_JPEGProvider: Unsupported color completion: %1&quot;,  cinfo.output_components));
+	}
+	
+	jpeg_finish_decompress(&amp;cinfo);
+	jpeg_destroy_decompress(&amp;cinfo);
+	delete input_source;
+	input_source = 0;
+
+
+	// this could be integrated better, but I'm too tired, so I just hack CL_PixelBuffer
+	// support into it. -- mbn 21. feb 2002
+
+	CL_PixelBuffer_Generic::format.enable_colorkey(false);
+	CL_PixelBuffer_Generic::format.set_colorkey(0);
+	CL_PixelBuffer_Generic::format.set_depth(24);
+	CL_PixelBuffer_Generic::format.set_red_mask(get_red_mask());
+	CL_PixelBuffer_Generic::format.set_green_mask(get_green_mask());
+	CL_PixelBuffer_Generic::format.set_blue_mask(get_blue_mask());
+	CL_PixelBuffer_Generic::format.set_alpha_mask(get_alpha_mask());
+	CL_PixelBuffer_Generic::pitch = get_pitch();
+	CL_PixelBuffer_Generic::width = get_width();
+	CL_PixelBuffer_Generic::height = get_height();
+}
+
+void CL_JPEGProvider_Generic::deinit()
+{
+	delete[] image;
+	image = NULL;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_JPEGProvider_Generic implementation:
+
+void CL_JPEGProvider_Generic::jpeg_InputSource_src (j_decompress_ptr cinfo, CL_JPEGProvider_Generic* provider)
+{
+	InputSource_src_ptr src;
+	
+	if (cinfo-&gt;src == NULL) /* first time for this JPEG object? */
+	{
+		cinfo-&gt;src = (struct jpeg_source_mgr*)
+			(*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
+						    sizeof(InputSource_source_mgr));
+		src = (InputSource_src_ptr) cinfo-&gt;src;
+		src-&gt;buffer = (JOCTET *)
+			(*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
+						    INPUT_BUF_SIZE * sizeof(JOCTET));
+	}
+
+	src = (InputSource_src_ptr) cinfo-&gt;src;
+	src-&gt;pub.init_source = CL_JPEGProvider_Generic::init_source;
+	src-&gt;pub.fill_input_buffer = CL_JPEGProvider_Generic::fill_input_buffer;
+	src-&gt;pub.skip_input_data = CL_JPEGProvider_Generic::skip_input_data;
+	src-&gt;pub.resync_to_restart = jpeg_resync_to_restart; /* use default method */
+	src-&gt;pub.term_source = CL_JPEGProvider_Generic::term_source;
+	src-&gt;jpeg_provider = provider;
+	src-&gt;pub.bytes_in_buffer = 0; /* forces fill_input_buffer on first read */
+	src-&gt;pub.next_input_byte = NULL; /* until buffer loaded */
+}
+
+void CL_JPEGProvider_Generic::init_source (j_decompress_ptr cinfo)
+{
+	InputSource_src_ptr src = (InputSource_src_ptr) cinfo-&gt;src;
+	src-&gt;start_of_file = TRUE;	
+}
+
+boolean CL_JPEGProvider_Generic::fill_input_buffer (j_decompress_ptr cinfo)
+{
+	InputSource_src_ptr src = (InputSource_src_ptr) cinfo-&gt;src;
+	size_t nbytes;
+
+	nbytes = src-&gt;jpeg_provider-&gt;input_source-&gt;read (src-&gt;buffer, INPUT_BUF_SIZE);
+	
+	if (nbytes &lt;= 0) 
+	{
+		if (src-&gt;start_of_file)	/* Treat empty input file as fatal error */
+			ERREXIT(cinfo, JERR_INPUT_EMPTY);
+		WARNMS(cinfo, JWRN_JPEG_EOF);
+		/* Insert a fake EOI marker */
+		src-&gt;buffer[0] = (JOCTET) 0xFF;
+		src-&gt;buffer[1] = (JOCTET) JPEG_EOI;
+		nbytes = 2;
+	}
+	src-&gt;pub.next_input_byte = src-&gt;buffer;
+	src-&gt;pub.bytes_in_buffer = nbytes;
+	src-&gt;start_of_file = FALSE;
+	
+	return TRUE;
+}
+
+void CL_JPEGProvider_Generic::skip_input_data (j_decompress_ptr cinfo, long num_bytes)
+{
+	InputSource_src_ptr src = (InputSource_src_ptr) cinfo-&gt;src;
+	
+	/* Just a dumb implementation for now.  Could use fseek() except
+	 * it doesn't work on pipes.  Not clear that being smart is worth
+	 * any trouble anyway --- large skips are infrequent.
+	 */
+	if (num_bytes &gt; 0)
+	{
+		while (num_bytes &gt; (long) src-&gt;pub.bytes_in_buffer)
+		{
+			num_bytes -= (long) src-&gt;pub.bytes_in_buffer;
+			(void) fill_input_buffer(cinfo);
+			/* note we assume that fill_input_buffer will never return FALSE,
+			 * so suspension need not be handled.
+			 */
+		}
+		src-&gt;pub.next_input_byte += (size_t) num_bytes;
+		src-&gt;pub.bytes_in_buffer -= (size_t) num_bytes;
+	}
+}
+
+void CL_JPEGProvider_Generic::term_source (j_decompress_ptr cinfo)
+{
+	// do nothing
+}

Added: trunk/clanlib/Display/Providers/jpeg_provider_generic.h
===================================================================
--- trunk/clanlib/Display/Providers/jpeg_provider_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Providers/jpeg_provider_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,163 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_jpeg_provider_generic
+#define header_jpeg_provider_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#if _MSC_VER &gt;= 1300
+#define HAVE_BOOLEAN
+#endif
+
+#ifdef WIN32
+#define XMD_H
+#endif
+
+#include &lt;stdio.h&gt;
+extern &quot;C&quot;
+{
+	#undef FAR
+
+	#ifdef __APPLE__
+	#include &lt;libjpeg/jpeglib.h&gt;
+	#else
+	#include &lt;jpeglib.h&gt;
+	#endif
+}
+
+#include &quot;API/Display/Providers/jpeg_provider.h&quot;
+#include &quot;Display/pixel_buffer_generic.h&quot;
+
+#include &quot;API/Core/IOData/inputsource.h&quot;
+#include &quot;API/Core/IOData/inputsource_provider.h&quot;
+
+class CL_InputSourceProvider;
+
+//: Surface provider that can load JPEG (.jpg) files.
+class CL_JPEGProvider_Generic : public CL_PixelBuffer_Generic
+{
+//! Construction:
+public:
+	//: Constructs a surface provider that can read JPEG&#164; files.
+	CL_JPEGProvider_Generic(
+		const std::string &amp;name, 
+		CL_InputSourceProvider *provider);
+
+	~CL_JPEGProvider_Generic();
+
+//! Attributes:
+public:
+	//: Returns the pitch of the image (bytes per line).
+	unsigned int get_pitch() const { return pitch; }
+
+	//: Returns the width of the image.
+	unsigned int get_width() const { return width; }
+
+	//: Returns the height of the image.
+	unsigned int get_height() const { return height; }
+	
+	//: Returns the number of subsprites in the image.
+	unsigned int get_num_frames() const { return 1; }
+
+	//: Returns the pixelformat used by the image.
+	// EPixelFormat get_pixel_format() const { return RGB888; }
+
+	//: Returns the red color mask used by the target.
+	unsigned int get_red_mask() const;
+
+	//: Returns the green color mask by the target.
+	unsigned int get_green_mask() const;
+
+	//: Returns the blue color mask by the target.
+	unsigned int get_blue_mask() const;
+
+	//: Returns the alpha mask by the target.
+	unsigned int get_alpha_mask() const;
+
+//! Operations:
+public:
+	//: Returns the image data. Provider must be locked before pointer is valid.
+	void *get_data();
+
+	//: Reference counted lock function. Allocate pixel buffer in this function. 
+	virtual void perform_lock() { return; }
+
+	//: Reference counted unlock function. Free pixel buffer in this function.
+	virtual void perform_unlock() { return; }
+
+	//: Loads the JPEG data into the pixel buffer.
+	void init();
+
+	//: Cleans up.
+	void deinit();
+
+//! Implementation:
+private:
+	// Functions for managing the input handling
+	static void jpeg_InputSource_src (j_decompress_ptr cinfo, CL_JPEGProvider_Generic* prov); 
+
+	static void init_source (j_decompress_ptr cinfo);
+
+	static boolean fill_input_buffer (j_decompress_ptr cinfo);
+
+	static void skip_input_data (j_decompress_ptr cinfo, long num_bytes);
+
+	static void term_source (j_decompress_ptr cinfo);
+
+	std::string filename;
+
+	unsigned char *image;
+
+	int pitch;
+
+	int width, height;
+
+	int bpp;
+
+	int pos;
+
+	typedef struct
+	{
+		struct jpeg_source_mgr   pub;           /* public fields */
+		CL_JPEGProvider_Generic* jpeg_provider; /* source stream */
+		JOCTET *                 buffer;        /* start of buffer */
+		boolean                  start_of_file; /* have we gotten any data yet? */
+	} InputSource_source_mgr;
+	
+	typedef InputSource_source_mgr* InputSource_src_ptr;
+
+	CL_InputSourceProvider* input_provider;
+
+	CL_InputSource* input_source;
+};
+
+#endif

Added: trunk/clanlib/Display/Providers/pcx_provider.cpp
===================================================================
--- trunk/clanlib/Display/Providers/pcx_provider.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Providers/pcx_provider.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,57 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/Providers/pcx_provider.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;pcx_provider_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_PCXProvider construction:
+
+CL_PCXProvider::CL_PCXProvider(
+		const std::string &amp;name,
+		CL_InputSourceProvider *provider)
+: CL_PixelBuffer(
+	new CL_PCXProvider_Generic(
+		name,
+		provider))
+{
+}
+
+void
+CL_PCXProvider::save(
+	CL_PixelBuffer buffer,
+	const std::string &amp;filename,
+	CL_OutputSourceProvider *output_provider)
+{
+	throw CL_Error(&quot;PCXProvider doesn't support saving&quot;);
+}
+
+/* EOF */

Added: trunk/clanlib/Display/Providers/pcx_provider_generic.cpp
===================================================================
--- trunk/clanlib/Display/Providers/pcx_provider_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Providers/pcx_provider_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,284 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;pcx_provider_generic.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_PCXProvider_Generic construction:
+
+CL_PCXProvider_Generic::CL_PCXProvider_Generic(
+	std::string _name, 
+	CL_InputSourceProvider *_provider)
+{
+	CL_InputSourceProvider *provider = _provider != NULL ? _provider-&gt;clone() : CL_InputSourceProvider::create_file_provider(&quot;.&quot;);
+	cl_assert(provider != NULL);
+	
+	image = NULL;
+
+	CL_InputSource *datafile = provider-&gt;open_source(_name.c_str());
+	datafile-&gt;set_little_endian_mode();
+	try
+	{
+		read_pcx(_name, datafile);
+	}
+	catch (...)
+	{
+		delete datafile;
+		delete provider;
+		throw;
+	}
+	delete datafile;
+	delete provider;
+}
+
+CL_PCXProvider_Generic::~CL_PCXProvider_Generic()
+{
+	delete[] image;
+	image = NULL;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_PCXProvider_Generic implementation:
+
+void CL_PCXProvider_Generic::read_pcx(
+	std::string _name, 
+	CL_InputSource *_datafile)
+{
+	// make sure its valid
+	cl_assert(_datafile != NULL);
+	
+	// Read the file header and initialize the variables
+	//: This method was created to breakup the PCX decoding code
+	//: so the initializing code was separated from the actual
+	//: decoding algorithm
+
+	unsigned char header[128];  
+
+	{
+		int read = _datafile-&gt;read(header, 128);
+		if (read != 128)
+			throw CL_Error(&quot;File not big enough to read the PCX header&quot;);
+	}
+
+	// only the useful fields that will be used more than once
+	struct PCXHeader {
+		unsigned char version;
+		unsigned char encoding;
+		unsigned char bits_per_pixel_per_plane;
+		short xmin;
+		short ymin;
+		short xmax;
+		short ymax;
+		unsigned char color_map[48];
+		unsigned char nplanes;
+		unsigned short bytes_per_line;
+	} pcx_header;
+
+	if (header[0] != 10)
+		throw CL_Error(&quot;Not a PCX file&quot;);
+
+	pcx_header.version = header[1];
+	pcx_header.encoding = header[2];
+	pcx_header.bits_per_pixel_per_plane = header[3];
+	pcx_header.xmin = (header[5] &lt;&lt; 8) | header[4];	
+	pcx_header.ymin = (header[7] &lt;&lt; 8) | header[6];
+	pcx_header.xmax = (header[9] &lt;&lt; 8) | header[8];
+	pcx_header.ymax = (header[11] &lt;&lt; 8) | header[10];
+
+	const int width = (pcx_header.xmax - pcx_header.xmin) + 1;
+	const int height = (pcx_header.ymax - pcx_header.ymin) + 1;
+
+	memcpy(pcx_header.color_map, &amp;header[16], sizeof(pcx_header.color_map));
+	pcx_header.nplanes = header[65];
+	pcx_header.bytes_per_line = (header[67] &lt;&lt; 8) | header[66];
+
+	// both 8bit with palette and 24bit rgb modes require version 5
+	if (pcx_header.version &lt; 5)
+		throw CL_Error(&quot;PCX version unsupported&quot;);
+
+	const int total_line_bytes = pcx_header.bytes_per_line * pcx_header.nplanes;
+
+	int pitch = 0;
+
+	// decide which pixelformat to use (8 bit palette or 24 bit)
+	if (pcx_header.nplanes == 3 &amp;&amp; pcx_header.bits_per_pixel_per_plane == 8)
+	{
+		// 24 bit RGB mode
+		pitch = width * 3;
+		image = new unsigned char[pitch * height];
+		cl_assert(image != NULL);
+
+		unsigned char *p = image;
+		const int extra = total_line_bytes - pitch;
+
+		// get the data
+		if (!pcx_header.encoding)
+		{
+			// uncompressed
+			for (int y = 0; y &lt; height; y++)
+			{
+				_datafile-&gt;read(p, pitch);
+				if (extra &gt; 0)
+					_datafile-&gt;seek(extra, CL_InputSource::seek_cur);
+				p += pitch;
+			}
+		}
+		else
+		{
+			// compressed
+			for (int y = 0; y &lt; height; y++)
+			{
+				int count;
+				// first red component
+				int x = 0, xx = 0, comp = 0;
+				while (x &lt; total_line_bytes)
+				{
+					int ch = _datafile-&gt;read_uint8();
+					if ((ch &amp; 0xC0) == 0xC0)
+					{
+						count = ch &amp; 0x3F;
+						ch = _datafile-&gt;read_uint8();
+					}
+					else
+						count = 1;
+
+					while (count--)
+					{
+						if (xx &lt; width)
+							image[(y * pitch) + ((xx * 3) + comp)] = ch;
+						x++;
+						if (x == pcx_header.bytes_per_line)
+						{
+							// blue component now
+							comp = 1;
+							xx = 0;
+						}
+						else if (x == pcx_header.bytes_per_line*2)
+						{
+							// green component now
+							comp = 2;
+							xx = 0;
+						}
+						else
+							xx++;
+					}
+				}
+			}
+		}
+		CL_PixelBuffer_Generic::format.enable_colorkey(false);
+		CL_PixelBuffer_Generic::format.set_colorkey(0);
+		CL_PixelBuffer_Generic::format.set_depth(24);
+		CL_PixelBuffer_Generic::format.set_red_mask(0x0000ff);
+		CL_PixelBuffer_Generic::format.set_green_mask(0x00ff00);
+		CL_PixelBuffer_Generic::format.set_blue_mask(0xff0000);
+		CL_PixelBuffer_Generic::format.set_alpha_mask(0);
+		CL_PixelBuffer_Generic::pitch = pitch;
+		CL_PixelBuffer_Generic::width = width;
+		CL_PixelBuffer_Generic::height = height;
+	}
+	else if (pcx_header.nplanes == 1 &amp;&amp; pcx_header.bits_per_pixel_per_plane == 8)
+	{
+		// 8 bit indexed mode
+		pitch = width;
+		image = new unsigned char[pitch * height];
+		cl_assert(image != NULL);
+
+		unsigned char *p = image;
+		const int extra = total_line_bytes - pitch;
+
+		// get the data
+		if (!pcx_header.encoding)
+		{
+			// uncompressed
+			for (int y = 0; y &lt; height; y++)
+			{
+				_datafile-&gt;read(p, pitch);
+				if (extra &gt; 0)
+					_datafile-&gt;seek(extra, CL_InputSource::seek_cur);
+				p += pitch;
+			}
+		}
+		else
+		{
+			// compressed
+			for (int y = 0; y &lt; height; y++)
+			{
+				int count;
+				int x = 0;
+				while (x &lt; total_line_bytes)
+				{
+					int ch = _datafile-&gt;read_uint8();
+					if ((ch &amp; 0xC0) == 0xC0)
+					{
+						count = ch &amp; 0x3F;
+						ch = _datafile-&gt;read_uint8();
+					}
+					else
+						count = 1;
+					
+					while (count--)
+					{
+						if (x &lt; width)
+						{
+							*p = ch;
+							p++;
+						}
+						x++;
+					}
+				}
+			}
+		}
+
+		// read the palette
+		if (_datafile-&gt;read_int8() != 12)
+		{
+			delete[] image;
+			throw CL_Error(&quot;Palette not found&quot;);
+		}
+		for (int i = 0; i &lt; 256; i++)
+		{
+			const int r = _datafile-&gt;read_uint8();
+			const int g = _datafile-&gt;read_uint8();
+			const int b = _datafile-&gt;read_uint8();
+			palette[i].set_color(r, g, b);
+		}
+
+		CL_PixelBuffer_Generic::format.enable_colorkey(false);
+		CL_PixelBuffer_Generic::format.set_colorkey(0);
+		CL_PixelBuffer_Generic::format.set_depth(8);
+		CL_PixelBuffer_Generic::format.set_type(pixelformat_index);
+		CL_PixelBuffer_Generic::pitch = pitch;
+		CL_PixelBuffer_Generic::width = width;
+		CL_PixelBuffer_Generic::height = height;
+	}
+	else
+		throw CL_Error(&quot;Unsupported PCX format&quot;);
+}

Added: trunk/clanlib/Display/Providers/pcx_provider_generic.h
===================================================================
--- trunk/clanlib/Display/Providers/pcx_provider_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Providers/pcx_provider_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,79 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_pcx_provider_generic
+#define header_pcx_provider_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Display/Providers/pcx_provider.h&quot;
+#include &quot;Display/pixel_buffer_generic.h&quot;
+#include &quot;API/Core/IOData/inputsource.h&quot;
+#include &quot;API/Core/IOData/inputsource_provider.h&quot;
+
+//: Surface provider that can load PCX files.
+class CL_PCXProvider_Generic : public CL_PixelBuffer_Generic
+{
+//! Construction:
+public:
+	//: Constructs a surface provider that can read pcx files.
+	//param name: Name of the pcx file to load.
+	//param provider: Input source provider that delivers the pcx file.
+	CL_PCXProvider_Generic(
+		std::string name,
+		CL_InputSourceProvider *provider);
+
+	//: PCX Provider destructor
+	virtual ~CL_PCXProvider_Generic();
+
+//! Operations:
+public:
+	//: Returns the image data. Provider must be locked before pointer is valid.
+	virtual void *get_data() { return image; }
+
+	//: Reference counted lock function. Allocate pixel buffer in this function. 
+	virtual void perform_lock() { return; }
+
+	//: Reference counted unlock function. Free pixel buffer in this function.
+	virtual void perform_unlock() { return; }
+
+//! Implementation:
+private:
+	//: Loads the pcx
+	void read_pcx(
+		std::string _name, 
+		CL_InputSource *_datafile);
+
+	//: Image data.
+	unsigned char *image;
+};
+
+#endif

Added: trunk/clanlib/Display/Providers/png_provider.cpp
===================================================================
--- trunk/clanlib/Display/Providers/png_provider.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Providers/png_provider.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,119 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &lt;errno.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;iostream&gt;
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Display/Providers/png_provider.h&quot;
+#include &quot;png_provider_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_PNGProvider construction:
+
+CL_PNGProvider::CL_PNGProvider(
+	const std::string &amp;name,
+	CL_InputSourceProvider *provider)
+: CL_PixelBuffer(
+	new CL_PNGProvider_Generic(
+		name,
+		provider))
+{
+}
+
+void
+CL_PNGProvider::save(
+	CL_PixelBuffer buffer,
+	const std::string &amp;filename,
+	CL_OutputSourceProvider *output_provider)
+{
+	if (output_provider)
+		throw CL_Error(&quot;Saving to OutputSource currently not supported&quot;);
+
+	buffer.lock();
+	if (buffer.get_format() != CL_PixelFormat::abgr8888)
+	{
+		CL_PixelBuffer newbuf(buffer.get_width(), buffer.get_height(), 
+									 buffer.get_width()*4, CL_PixelFormat::abgr8888);
+		buffer.unlock();
+		buffer.convert(newbuf);
+		buffer = newbuf;
+		buffer.lock();
+	}
+
+	FILE* fp;
+	fp = fopen(filename.c_str (), &quot;wb&quot;);
+	if (fp == NULL)
+      throw CL_Error(strerror(errno));
+	
+	png_structp png_ptr;
+	png_infop info_ptr;
+
+	png_ptr  = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
+	info_ptr = png_create_info_struct(png_ptr);
+
+	png_init_io(png_ptr, fp);
+
+	png_set_IHDR(png_ptr, info_ptr, 
+					 buffer.get_width(), buffer.get_height(), 8 /* bitdepth */,
+					 PNG_COLOR_TYPE_RGBA,
+					 PNG_INTERLACE_NONE, 
+					 PNG_COMPRESSION_TYPE_BASE, 
+					 PNG_FILTER_TYPE_BASE);
+
+	png_write_info(png_ptr, info_ptr);
+
+	png_uint_32 height = buffer.get_height();
+	png_uint_32 row_bytes = buffer.get_width()*4;
+
+	png_byte* image = new png_byte[height * row_bytes];
+	png_bytep* row_pointers = new png_bytep[height];
+
+	// fill the image with data
+	for (int i = 0; i &lt; buffer.get_width()*buffer.get_height()*4; ++i)
+      image[i] = static_cast&lt;unsigned char*&gt;(buffer.get_data())[i];
+
+	// generate row pointers
+	for (unsigned int k = 0; k &lt; height; k++)
+      row_pointers[k] = image + (k * row_bytes);
+
+	png_write_image(png_ptr, row_pointers);
+
+	png_write_end(png_ptr, info_ptr);
+
+	delete image;
+	delete row_pointers;
+
+	fclose(fp);
+
+	buffer.unlock();	
+}
+
+/* EOF */

Added: trunk/clanlib/Display/Providers/png_provider_generic.cpp
===================================================================
--- trunk/clanlib/Display/Providers/png_provider_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Providers/png_provider_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,524 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+
+#include &quot;png_provider_generic.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/IOData/cl_endian.h&quot;
+#include &lt;utility&gt;
+
+/*
+	Known Bugs:
+
+	- this provider might not work with 16bit PNG's 
+	- this provider might not work with some grayscale PNG's (don't remember which one)
+*/
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_PNGProvider_Generic construction:
+
+CL_PNGProvider_Generic::CL_PNGProvider_Generic(
+	const std::string &amp;name,
+	CL_InputSourceProvider *_provider)
+{
+	if (_provider == NULL)
+		provider = CL_InputSourceProvider::create_file_provider(&quot;.&quot;);
+	else
+		provider = _provider-&gt;clone();
+
+	trans_col = -1;
+	m_uses_src_colorkey = false;
+
+	filename = name;
+	image = NULL;
+
+	init();
+}
+
+CL_PNGProvider_Generic::~CL_PNGProvider_Generic()
+{
+	deinit();
+	delete provider;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_PNGProvider_Generic attributes:
+
+bool CL_PNGProvider_Generic::is_indexed() const
+{
+	return (format.get_depth()==8);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_PNGProvider_Generic operations:
+
+void* CL_PNGProvider_Generic::get_data()
+{
+	return image;
+}
+
+void CL_PNGProvider_Generic::init()
+{
+	//setting up PNGLIB stuff
+	png_ptr = png_create_read_struct (PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
+	
+	if (!png_ptr) 
+		throw CL_Error (&quot;CL_PNGProvider_Generic: png_create_read_struct() failed&quot;);
+	
+	info_ptr = png_create_info_struct(png_ptr);
+
+	if (!info_ptr)
+	{
+		png_destroy_read_struct(&amp;png_ptr, (png_infopp) NULL, (png_infopp) NULL);
+		throw CL_Error (&quot;CL_PNGProvider_Generic: png_create_info_struct() failed&quot;);
+	}
+
+	end_info = png_create_info_struct(png_ptr);
+
+	if (!end_info)
+	{
+		png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr, (png_infopp) NULL);
+		cl_assert(false);
+	}   
+	if (setjmp(png_ptr-&gt;jmpbuf))
+	{
+		png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr, &amp;end_info);
+		cl_assert(false);
+	}  
+	
+	cl_assert(provider != NULL);
+	input_source = provider-&gt;open_source(filename);
+	cl_assert(input_source!=NULL);
+
+	// tell libpng form whom it get the fileData
+	png_set_read_fn(png_ptr, this, &amp;CL_PNGProvider_Generic::pngread_file);
+
+	// reading the header infos and actually read data ...
+	read_data();
+
+	// remove our data_provider from libpng
+	png_set_read_fn(png_ptr,NULL,NULL);
+
+	// free memory ...
+	png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr,&amp;end_info);
+
+	delete input_source;
+
+
+	// this could be integrated better, but I'm too tired, so I just hack CL_PixelBuffer
+	// support into it. -- mbn 21. feb 2002
+
+	CL_PixelBuffer_Generic::format.enable_colorkey(uses_src_colorkey());
+	CL_PixelBuffer_Generic::format.set_colorkey(get_src_colorkey());
+	CL_PixelBuffer_Generic::pitch = get_pitch();
+	CL_PixelBuffer_Generic::width = get_width();
+	CL_PixelBuffer_Generic::height = get_height();
+	if (is_indexed()) CL_PixelBuffer_Generic::format.set_type(pixelformat_index);
+}
+
+void CL_PNGProvider_Generic::deinit()
+{
+	delete[] image;
+	image   =  NULL;
+}
+  
+/////////////////////////////////////////////////////////////////////////////
+// CL_PNGProvider_Generic implementation:
+
+void CL_PNGProvider_Generic::pngread_file(
+	png_structp png_ptr,
+	png_bytep data, 
+	png_size_t length)
+{
+	// since this method is static, we need to know who we are ...
+	CL_PNGProvider_Generic *instance =  (CL_PNGProvider_Generic *) png_get_io_ptr(png_ptr);
+	// no error-checking here ....
+	unsigned int read_length = instance-&gt;get_input_source ()-&gt;read(data, length);
+	cl_assert (read_length == length);
+}
+
+void CL_PNGProvider_Generic::read_data()
+{
+	// initial fileinfo
+	png_read_info(png_ptr, info_ptr); 
+	
+	// reduce 16bit/channel to 8Bit/channel
+	png_set_strip_16(png_ptr);  
+	
+	// reread infostruct to reflect the made settings
+	png_read_update_info(png_ptr, info_ptr); 
+
+	width  = png_get_image_width(png_ptr,info_ptr);
+	height = png_get_image_height(png_ptr,info_ptr);
+	color_type = png_get_color_type(png_ptr,info_ptr);
+
+	switch (color_type)
+	{
+	case PNG_COLOR_TYPE_GRAY:
+		read_data_grayscale ();
+		break;
+	case PNG_COLOR_TYPE_GRAY_ALPHA:
+		read_data_grayscale_alpha ();
+		break;
+	case PNG_COLOR_TYPE_PALETTE:
+		read_data_palette ();
+		break;
+	case PNG_COLOR_TYPE_RGB:
+		read_data_rgb ();
+		break;
+
+	case PNG_COLOR_TYPE_RGB_ALPHA:
+		read_data_rgba ();
+		break;
+	default:
+		throw CL_Error (&quot;CL_PNGProvider_Generic: Unsupported PNG format!&quot;);
+		break;
+	}
+}
+
+void CL_PNGProvider_Generic::read_data_rgb()
+{
+	format.set_type(pixelformat_rgba);
+	format.set_red_mask(0xff0000);
+	format.set_green_mask(0x00ff00);
+	format.set_blue_mask(0x0000ff);
+	format.set_alpha_mask(0x000000);
+	format.set_depth(24);
+
+	pitch = png_get_rowbytes(png_ptr, info_ptr);
+
+	// This is deleted in the unlock () call
+	image = new unsigned char[pitch * height];
+
+	// setup pointers to each row in our target image
+	png_bytep* row_pointers = new png_bytep[height];
+	{
+		for (int y = 0; y &lt; height; y++)
+			row_pointers[y] = image + (pitch * y);
+	}
+	png_read_image(png_ptr, row_pointers);
+	delete[] row_pointers;
+
+	// swap the colors in the right order
+	if (!CL_Endian::is_system_big())
+	{
+		for(int y = 0; y &lt; height; ++y)
+		{
+			unsigned char * line = &amp;image[y * pitch];
+			for (int i = 0; i &lt; width * 3; i += 3)
+				std::swap(line[i + 0], line[i + 2]);
+		}
+	}
+}
+
+void CL_PNGProvider_Generic::read_data_rgba()
+{
+	format.set_type(pixelformat_rgba);
+	format.set_red_mask  (0xff000000);
+	format.set_green_mask(0x00ff0000);
+	format.set_blue_mask (0x0000ff00);
+	format.set_alpha_mask(0x000000ff);
+
+	format.set_depth(32);
+
+	pitch = png_get_rowbytes(png_ptr, info_ptr);
+
+	// This is deleted in the unlock () call
+	image = new unsigned char[pitch * height];
+
+	// setup pointers to each row in our target image
+	png_bytep* row_pointers = new png_bytep[height];
+	{
+		for (int y = 0; y &lt; height; y++)
+			row_pointers[y] = image + (pitch * y);
+	}
+	png_read_image(png_ptr, row_pointers);
+	delete[] row_pointers;
+
+	if (!CL_Endian::is_system_big())
+	{
+		for(int y = 0; y &lt; height; ++y)
+		{
+			unsigned char * line = &amp;image[y * pitch];
+			for (int i = 0; i &lt; width * 4; i += 4)
+			{
+				std::swap(line[i + 0], line[i + 3]);
+				std::swap(line[i + 1], line[i + 2]);
+			}
+		}
+	}
+}
+
+void CL_PNGProvider_Generic::read_data_grayscale()
+{
+	format.set_type(pixelformat_rgba);
+	format.set_red_mask(0xff000000);
+	format.set_green_mask(0x00ff0000);
+	format.set_blue_mask(0x0000ff00);
+	format.set_alpha_mask(0x000000ff);
+	format.set_depth(32);
+
+	int bit_depth = png_get_bit_depth(png_ptr, info_ptr);
+
+	// We expand the grayscale values if necessary, so we always
+	// get 8bits per pixel
+	if (bit_depth &lt; 8) png_set_expand (png_ptr);
+
+	int rowbytes  = png_get_rowbytes (png_ptr, info_ptr);
+	pitch = rowbytes * 4;
+
+	// Allocating the temporary buffer and fill it
+	unsigned char* tmp_image = new unsigned char[height * rowbytes];
+	png_bytep* row_pointers  = new png_bytep[height];
+	{
+		for (int y = 0; y &lt; height; y++)
+			row_pointers[y] = tmp_image + (rowbytes * y);
+	}
+	png_read_image(png_ptr, row_pointers);
+	delete[] row_pointers;
+
+	// Reading and setting up the transparent colors from the image
+	int num_trans = 0;
+	png_color_16p trans_values;
+	png_bytep trans;
+	png_get_tRNS(png_ptr, info_ptr, &amp;trans, &amp;num_trans, &amp;trans_values);
+	
+	if (num_trans &gt; 0)
+	{
+		if (trans)
+		{
+			// This is a Pallette image
+			trans_col = trans[0];
+		}
+		else
+		{
+			// Non-pallete image
+			trans_col = trans_values[0].gray;
+		}
+	}
+
+	image = new unsigned char[height * pitch];
+	// Coverting the data in the tmp buffer to our final data
+	{
+		for (int i = 0; i &lt; rowbytes * height; i++)
+		{
+			if (!CL_Endian::is_system_big())
+			{
+				image[4*i + 0] = tmp_image[i] == trans_col ? 0 : 255;
+				image[4*i + 3] = tmp_image[i];
+			}
+			else
+			{
+				image[4*i + 3] = tmp_image[i] == trans_col ? 0 : 255;
+				image[4*i + 0] = tmp_image[i];
+			}
+			image[4*i + 1] = tmp_image[i];
+			image[4*i + 2] = tmp_image[i];
+		}
+	}
+	delete[] tmp_image;
+}
+
+void CL_PNGProvider_Generic::read_data_grayscale_alpha()
+{
+	format.set_type(pixelformat_rgba);
+	format.set_red_mask(0xff000000);
+	format.set_green_mask(0x00ff0000);
+	format.set_blue_mask(0x0000ff00);
+	format.set_alpha_mask(0x000000ff);
+	format.set_depth(32);
+
+	pitch = width * 4;
+
+	int bit_depth = png_get_bit_depth(png_ptr,info_ptr);
+	int rowbytes  = png_get_rowbytes(png_ptr, info_ptr);
+
+	// We expand the grayscale values if necessare, so we always
+	// get 8bits per pixel
+	if (bit_depth &lt; 8) png_set_expand (png_ptr);
+
+	// Allocating the temporary buffer
+	unsigned char* tmp_image = new unsigned char[height * rowbytes];
+	png_bytep* row_pointers = new png_bytep[height];
+	{
+		for (int y = 0; y &lt; height; y++)
+			row_pointers[y] = tmp_image + (rowbytes * y);
+	}
+ 	png_read_image(png_ptr, row_pointers);
+	delete[] row_pointers;
+
+	// Creating the final image out of tmp_image
+	image = new unsigned char[pitch * height];
+	for (int i = 0; i &lt; rowbytes * height; i += 2)
+	{
+		if (!CL_Endian::is_system_big())
+		{
+			image[2*i + 0] = tmp_image[i + 1];
+			image[2*i + 3] = tmp_image[i + 0];
+		}
+		else
+		{
+			image[2*i + 0] = tmp_image[i + 0];
+			image[2*i + 3] = tmp_image[i + 1];
+		}
+
+		image[2*i + 1] = tmp_image[i + 0];
+		image[2*i + 2] = tmp_image[i + 0];
+	}
+
+	delete[] tmp_image;
+}
+
+void CL_PNGProvider_Generic::read_data_palette()
+{
+	
+	format.set_type(pixelformat_index);
+	format.set_red_mask(0x00000000);
+	format.set_green_mask(0x00000000);
+	format.set_blue_mask(0x00000000);
+	format.set_alpha_mask(0x00000000);
+	format.set_depth(8);
+
+	int bit_depth = png_get_bit_depth(png_ptr,info_ptr);
+	int rowbytes = png_get_rowbytes(png_ptr, info_ptr);
+
+	unsigned char* tmp_image = new unsigned char[height * rowbytes];
+	// Allocating the temporary buffer (will be deleted some
+	// screens below
+	png_bytep* row_pointers = new png_bytep[height];
+	{
+		for (int y = 0; y &lt; height; y++)
+			row_pointers[y] = tmp_image + (rowbytes * y);
+	}
+	png_read_image(png_ptr, row_pointers);
+	
+	if (bit_depth == 8)
+	{
+		// We don't need to convert the data, so we can use
+		// what we got
+		image = tmp_image;
+		pitch = rowbytes;
+	}
+	else
+	{
+		// We need to convert the data
+		pitch = width;
+
+		int y,x;
+
+		switch (bit_depth)
+		{
+		case 1:
+			image = new unsigned char[height * rowbytes * 8];
+			for (y = 0; y &lt; height; y++)
+			{
+				for (x = 0; x &lt; rowbytes; x++)
+				{
+					image[y*pitch + 8*x + 0] = row_pointers[y][x] &gt;&gt; 7;
+					image[y*pitch + 8*x + 1] = row_pointers[y][x] &gt;&gt; 6 &amp; 0x1;
+					image[y*pitch + 8*x + 2] = row_pointers[y][x] &gt;&gt; 5 &amp; 0x1;
+					image[y*pitch + 8*x + 3] = row_pointers[y][x] &gt;&gt; 4 &amp; 0x1;
+					image[y*pitch + 8*x + 4] = row_pointers[y][x] &gt;&gt; 3 &amp; 0x1;
+					image[y*pitch + 8*x + 5] = row_pointers[y][x] &gt;&gt; 2 &amp; 0x1;
+					image[y*pitch + 8*x + 6] = row_pointers[y][x] &gt;&gt; 1 &amp; 0x1;
+					image[y*pitch + 8*x + 7] = row_pointers[y][x] &amp; 0x1;
+				}
+			}
+			break;
+		case 2:
+			image = new unsigned char[height * rowbytes * 4];
+			for (y = 0; y &lt; height; y++)
+			{
+				for (x = 0; x &lt; rowbytes; x++)
+				{
+					image[y*pitch + 4*x + 0] = row_pointers[y][x] &gt;&gt; 6;
+					image[y*pitch + 4*x + 1] = row_pointers[y][x] &gt;&gt; 4 &amp; 0x3;
+					image[y*pitch + 4*x + 2] = row_pointers[y][x] &gt;&gt; 2 &amp; 0x3;
+					image[y*pitch + 4*x + 3] = row_pointers[y][x] &amp; 0x3;
+				}
+			}
+			break;
+		case 4:
+			image = new unsigned char[height * rowbytes * 2];
+			for (y = 0; y &lt; height; y++)
+			{
+				for (x = 0; x &lt; rowbytes; x++)
+				{
+					image[y*pitch + 2*x + 0] = row_pointers[y][x] &gt;&gt; 4;
+					image[y*pitch + 2*x + 1] = row_pointers[y][x] &amp; 0x0f;
+				}
+			}
+			break;
+		default:
+			throw CL_Error (&quot;CL_PNGProvider_Generic: Unhandled bit depth&quot;);
+		}
+		delete[] tmp_image;
+	}
+	delete[] row_pointers;
+
+	// Read the png palette and create the CL_Palette 
+	int num_colors = 256;
+	png_colorp png_palette;
+	png_get_PLTE(png_ptr, info_ptr, &amp;png_palette, &amp;num_colors);
+	if (num_colors &gt; 256)
+		num_colors = 256; // clanlib currently only support palette sizes of max 256.
+		
+	{
+		for (int k = 0; k &lt; num_colors; k++)
+			palette[k].set_color(png_palette[k].red, png_palette[k].green, png_palette[k].blue);
+	}
+
+	if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))
+	{
+		// Reading and setting up the transparent colors from the image
+		int num_trans = 0;
+		png_color_16p trans_values;
+		png_bytep trans;
+
+		png_get_tRNS(png_ptr, info_ptr, &amp;trans, &amp;num_trans, &amp;trans_values);
+
+		//Trans information exists for each color in the palette, it doesn't mean
+		//that color is actually transparent.   We need to check its alpha for that data.
+		//Ideally, we should probably detect if more than one is transparent and convert it to a full
+		//alpha, but that seems like overkill for now. -mrfun
+
+		for (int i=0; i &lt; num_trans; i++)
+		{
+			if (trans[i] == 0)
+			{
+				trans_col = i;
+				m_uses_src_colorkey = true;
+				break; //we only support one color
+			}
+		}
+		
+	}
+
+}

Added: trunk/clanlib/Display/Providers/png_provider_generic.h
===================================================================
--- trunk/clanlib/Display/Providers/png_provider_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Providers/png_provider_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,143 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_png_provider_generic
+#define header_png_provider_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Display/Providers/png_provider.h&quot;
+#include &quot;Display/pixel_buffer_generic.h&quot;
+
+#include &quot;API/Core/IOData/inputsource.h&quot;
+#include &quot;API/Core/IOData/inputsource_provider.h&quot;
+
+#ifdef __APPLE__
+	#include &lt;libpng/png.h&gt;
+#else
+	#include &lt;png.h&gt;
+#endif
+
+class CL_PNGProvider_Generic : public CL_PixelBuffer_Generic
+{
+//! Construction:
+public:
+	CL_PNGProvider_Generic(
+		const std::string &amp;name, 
+		CL_InputSourceProvider *provider = 0);
+
+	~CL_PNGProvider_Generic();
+
+//! Attributes:
+public:
+	//: returns Pointer to CL_InputSource
+	//: (used by libpng-callback CL_PNGProvider::pngread_file() )
+	CL_InputSource *get_input_source() { return input_source; }
+
+	//: Returns the pitch of the image (bytes per line).
+	unsigned int get_pitch() const { return pitch; }
+
+	//: Returns the width of the image.
+	unsigned int get_width() const { return width; }
+
+	//: Returns the height of the image.
+	unsigned int get_height() const { return height; }
+	
+	//: Returns the number of subsprites in the image.
+	unsigned int get_num_frames() const { return 1; }
+
+	//: Returns the transparency color used.
+	unsigned int get_src_colorkey() const { return trans_col; }
+
+	//: Returns whether a source colorkey is used.
+	bool uses_src_colorkey() const { return m_uses_src_colorkey; }
+
+	//: Returns whether the target uses an indexed color mode or not.
+	bool is_indexed() const;
+	
+//! Operations:
+public:
+	//: Returns the image data. Provider must be locked before pointer is valid.
+	virtual void *get_data();
+
+	//: Reference counted lock function. Allocate pixel buffer in this function. 
+	virtual void perform_lock() { return; }
+
+	//: Reference counted unlock function. Free pixel buffer in this function.
+	virtual void perform_unlock() { return; }
+
+	//: Loads the PNG into the pixel buffer.
+	virtual void init();
+
+	//: Cleans up.
+	virtual void deinit();
+	
+//! Implementation:
+private:
+	//: Callback used by libpng to retrieve the filedata. 
+	//: (calls get_input_source()-&gt;read_uchar8())
+	static void pngread_file(png_structp png_ptr, png_bytep data, png_size_t length);
+
+	void read_data();
+
+	void read_data_rgb();
+
+	void read_data_rgba();
+
+	void read_data_grayscale();
+
+	void read_data_grayscale_alpha();
+
+	void read_data_palette();
+
+	std::string filename;
+
+	bool m_uses_src_colorkey;
+	
+	unsigned char *image;
+	int pitch;
+	int no_sprs;
+	int width;
+	int height;
+
+	int trans_col;
+	int color_type;
+
+	CL_InputSourceProvider *provider;
+	CL_InputSource *input_source;
+
+	//PNGlib stuff:
+	png_structp png_ptr;
+	png_infop info_ptr;
+	png_infop end_info;
+};
+
+#endif

Added: trunk/clanlib/Display/Providers/provider_factory.cpp
===================================================================
--- trunk/clanlib/Display/Providers/provider_factory.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Providers/provider_factory.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,87 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/Providers/provider_factory.h&quot;
+#include &quot;API/Display/Providers/provider_type.h&quot;
+#include &quot;API/Display/pixel_buffer.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ProviderFactory attributes:
+
+std::map&lt;std::string, CL_ProviderType *&gt; CL_ProviderFactory::types;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ProviderFactory operations:
+
+CL_PixelBuffer CL_ProviderFactory::load(
+	const std::string &amp;filename,
+	const std::string &amp;type,
+	CL_InputSourceProvider *input_provider)
+{
+	if (type != &quot;&quot;)
+	{
+		if (types.find(type) == types.end()) throw CL_Error(&quot;Unknown image provider type &quot; + type);
+
+		CL_ProviderType *factory = types[type];
+		return factory-&gt;load(filename, input_provider);
+	}
+
+	// Determine file extension and use it to lookup type.
+	std::string ext = CL_String::right(filename, 4);
+	if (ext.at(0) == '.') ext = CL_String::right(ext, 3);
+	ext = CL_String::to_lower(ext);
+	if (types.find(ext) == types.end()) throw CL_Error(std::string(&quot;Unknown image provider type &quot;) + ext);
+
+	CL_ProviderType *factory = types[ext];
+	return factory-&gt;load(filename, input_provider);
+}
+
+void
+CL_ProviderFactory::save(
+	CL_PixelBuffer buffer,
+	const std::string &amp;filename,
+	const std::string &amp;type_,
+	CL_OutputSourceProvider *output_provider)
+{
+	std::string type = type_;
+
+	if (type.empty())
+		type = CL_String::get_extension(filename);
+	
+	if (types.find(type) == types.end()) throw CL_Error(&quot;Unknown image provider type &quot; + type);
+	
+	CL_ProviderType *factory = types[type];
+	factory-&gt;save(buffer, filename, output_provider);
+}
+
+
+/* EOF */

Added: trunk/clanlib/Display/Providers/provider_type.cpp
===================================================================
--- trunk/clanlib/Display/Providers/provider_type.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Providers/provider_type.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,61 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/Providers/provider_type.h&quot;
+#include &quot;API/Display/Providers/provider_factory.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ProviderType construction:
+
+CL_ProviderType::CL_ProviderType(const std::string &amp;type)
+{
+	CL_ProviderFactory::types[type] = this;
+}
+
+CL_ProviderType::~CL_ProviderType()
+{
+	std::map&lt;std::string, CL_ProviderType *&gt;::iterator it;
+	
+	for (it = CL_ProviderFactory::types.begin(); it != CL_ProviderFactory::types.end(); it++)
+	{
+		if (it-&gt;second == this)
+		{
+			CL_ProviderFactory::types.erase(it);
+			break;
+		}
+	}
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ProviderType operations:
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ProviderType implementation:

Added: trunk/clanlib/Display/Providers/targa_provider.cpp
===================================================================
--- trunk/clanlib/Display/Providers/targa_provider.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Providers/targa_provider.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,57 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Display/Providers/targa_provider.h&quot;
+#include &quot;targa_provider_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_TargaProvider construction:
+
+CL_TargaProvider::CL_TargaProvider(
+	const std::string &amp;name,
+	CL_InputSourceProvider *provider)
+: CL_PixelBuffer(
+	new CL_TargaProvider_Generic(
+		name,
+		provider))
+{
+}
+
+void
+CL_TargaProvider::save(
+	CL_PixelBuffer buffer,
+	const std::string &amp;filename,
+	CL_OutputSourceProvider *output_provider)
+{
+	throw CL_Error(&quot;TargaProvider doesn't support saving&quot;);
+}
+
+/* EOF */

Added: trunk/clanlib/Display/Providers/targa_provider_generic.cpp
===================================================================
--- trunk/clanlib/Display/Providers/targa_provider_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Providers/targa_provider_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,767 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &lt;map&gt;
+#include &quot;API/Display/Providers/targa_provider.h&quot;
+#include &quot;API/Core/IOData/cl_endian.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/System/cl_assert.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;targa_provider_generic.h&quot;
+
+using namespace std;
+
+struct CL_TargaProvider_Generic::TGA_Header
+{
+	unsigned char id_length;
+	unsigned char colormap_type;
+	unsigned char image_type_code;
+	unsigned short colormap_orig;
+	unsigned short colormap_length;
+	unsigned char colormap_entry_size;
+	short image_x_orig;
+	short image_y_orig;
+	unsigned short image_width;
+	unsigned short image_height;
+	unsigned char image_pixel_size;
+	unsigned char image_descriptor_byte;
+} tga_header;
+
+CL_TargaProvider_Generic::CL_TargaProvider_Generic(
+	const std::string name,
+	CL_InputSourceProvider *_provider)
+{
+	CL_InputSourceProvider *provider;
+	if (_provider == NULL)
+		provider = CL_InputSourceProvider::create_file_provider(&quot;.&quot;);
+	else
+		provider = _provider-&gt;clone();
+
+	cl_assert(provider != NULL);
+
+	image = NULL;
+
+	CL_InputSource *input_source = provider-&gt;open_source(name.c_str());
+	cl_assert(input_source != NULL);
+	input_source-&gt;set_little_endian_mode();
+
+	// read the data
+	try
+	{
+		read_tga(input_source);
+	}
+	catch (...)
+	{
+		delete input_source;
+		delete provider;
+		throw;
+	}
+
+	delete input_source;
+	delete provider;
+}
+
+CL_TargaProvider_Generic::~CL_TargaProvider_Generic()
+{
+	delete[] image;
+	image =  NULL;
+}
+
+/*
+	Read the file data - a .TGA file can exist in several
+	different formats - huffman encoded formats are not supported.
+*/
+void CL_TargaProvider_Generic::read_tga(CL_InputSource *input_source)
+{
+	TGA_Header header;
+	// read the header
+	input_source-&gt;seek(0, CL_InputSource::seek_set);
+	header.id_length = input_source-&gt;read_uint8();
+	header.colormap_type = input_source-&gt;read_uint8();
+	header.image_type_code = input_source-&gt;read_uint8();
+	header.colormap_orig = input_source-&gt;read_uint16();
+	header.colormap_length = input_source-&gt;read_uint16();
+	header.colormap_entry_size = input_source-&gt;read_uint8();
+	header.image_x_orig = input_source-&gt;read_int16();
+	header.image_y_orig = input_source-&gt;read_int16();
+	header.image_width = input_source-&gt;read_uint16();
+	header.image_height = input_source-&gt;read_uint16();
+	header.image_pixel_size = input_source-&gt;read_uint8();
+	header.image_descriptor_byte = input_source-&gt;read_uint8();
+
+	// skip the id
+	if (header.id_length &gt; 0)
+		input_source-&gt;seek(header.id_length, CL_InputSource::seek_cur);
+
+	switch (header.image_type_code)
+	{
+	case 1:
+		read_colormapped(input_source, header);
+		break;
+	case 2:
+		read_rgb(input_source, header);
+		break;
+	case 9:
+		read_rle_colormapped(input_source, header);
+		break;
+	case 10:
+		read_rle_rgb(input_source, header);
+		break;
+	default:
+		throw CL_Error(&quot;Unsupported TGA filetype encountered&quot;);
+		break;
+	}
+}
+
+/*
+	CODE FOR DECODING TYPE 1 TARGA FILES
+*/
+void CL_TargaProvider_Generic::read_colormapped(
+	CL_InputSource *input_source, 
+	const CL_TargaProvider_Generic::TGA_Header &amp;header)
+{
+	int pitch = 0;
+	const int width = header.image_width;
+	const int height = header.image_height;
+
+	// if we use a palette that is &lt;= 256 colors, we can convert it to the standard palette type
+	if (header.colormap_length &lt;= 256)
+	{		
+		// read the color map to palette
+		{
+			for (unsigned int i = 0; i &lt; header.colormap_length; i++)
+			{
+				int r = 0, g = 0, b = 0, a = 255;
+				if (header.colormap_entry_size == 32)
+				{
+					b = input_source-&gt;read_uint8();
+					g = input_source-&gt;read_uint8();
+					r = input_source-&gt;read_uint8();
+					a = input_source-&gt;read_uint8();
+				}
+				else if (header.colormap_entry_size == 24)
+				{
+					b = input_source-&gt;read_uint8();
+					g = input_source-&gt;read_uint8();
+					r = input_source-&gt;read_uint8();
+				}
+				else if (header.colormap_entry_size == 16)
+				{
+					// ARRRRRGG GGGBBBBB (little endian)
+					const unsigned int color = input_source-&gt;read_uint16();
+					a = (color &amp; CL_PixelFormat::get_bitmask(1, 15)) ? 255 : 0;
+					r = ((color &amp; CL_PixelFormat::get_bitmask(5, 10)) &gt;&gt; 10) &lt;&lt; 3;
+					g = ((color &amp; CL_PixelFormat::get_bitmask(5, 5)) &gt;&gt; 5) &lt;&lt; 3;
+					b = ((color &amp; CL_PixelFormat::get_bitmask(5, 0)) &gt;&gt; 0) &lt;&lt; 3;
+				}
+				palette.colors[i] = CL_Color(r, g, b, a);
+			}
+		}
+
+		pitch = width;
+
+		image = new unsigned char[height * pitch];
+		cl_assert(image != 0);
+
+		const bool is_mirrored = (header.image_descriptor_byte &amp; (1 &lt;&lt; 5)) ? false : true;
+		const int target_y_modifier = is_mirrored ? -1 : 1;
+		int targety = is_mirrored ? (height - 1) : 0;
+		int index_size = header.image_pixel_size / 8;
+		cl_assert(index_size &lt;= int(sizeof(unsigned int)));
+		bool big = CL_Endian::is_system_big();
+		for (int y = 0; y &lt; height; y++, targety += target_y_modifier)
+		{
+			unsigned char *p = image + (targety * pitch);
+			for (int x = 0; x &lt; width; x++, p++)
+			{
+				unsigned int index = 0;
+				input_source-&gt;read(&amp;index, index_size);
+				if (big)
+					CL_Endian::swap(&amp;index, index_size);
+				index -= header.colormap_orig;
+				*p = (unsigned char)index;
+			}
+		}
+
+		CL_PixelBuffer_Generic::format.enable_colorkey(false);
+		CL_PixelBuffer_Generic::format.set_colorkey(0);
+		CL_PixelBuffer_Generic::format.set_depth(8);
+		CL_PixelBuffer_Generic::format.set_type(pixelformat_index);
+		CL_PixelBuffer_Generic::pitch = pitch;
+		CL_PixelBuffer_Generic::width = width;
+		CL_PixelBuffer_Generic::height = height;
+	}
+
+	// else we need to convert to the given mode
+	else
+	{		
+		// read the color map to unsigned int in the native format
+		map&lt;unsigned int, unsigned int&gt; color_map;
+		{
+			int c_size = header.colormap_entry_size / 8;
+			cl_assert(c_size &lt;= 4);
+			bool big = CL_Endian::is_system_big();
+			for (int i = header.colormap_orig; i &lt; header.colormap_orig + header.colormap_length; i++)
+			{
+				unsigned int c = 0;
+				input_source-&gt;read(&amp;c, c_size);
+				if (big) CL_Endian::swap(&amp;c, c_size);
+				color_map[i] = c;
+			}
+		}
+		const int bytes_per_pixel = header.colormap_entry_size / 8;
+		pitch = width * bytes_per_pixel;
+
+		// set to true if an alpha value &gt; 0 was found (if the color depth supports it)
+		int alpha_found = false;
+		int alpha_mask;
+		if (bytes_per_pixel == 2)
+			alpha_mask = 0x8000;
+		else if (bytes_per_pixel == 4)
+			alpha_mask = 0xff000000;
+		else
+			alpha_mask = 0;
+
+		image = new unsigned char[height * pitch];
+		cl_assert(image != 0);
+
+		const bool is_mirrored = (header.image_descriptor_byte &amp; (1 &lt;&lt; 5)) ? false : true;
+		const int target_y_modifier = is_mirrored ? -1 : 1;
+		int targety = is_mirrored ? (height - 1) : 0;
+		int index_size = header.image_pixel_size / 8;
+		cl_assert(index_size &lt;= 4);
+		bool big = CL_Endian::is_system_big();
+		for (int y = 0; y &lt; height; y++, targety += target_y_modifier)
+		{
+			unsigned char *p = image + (targety * pitch);
+			for (int x = 0; x &lt; width; x++, p += bytes_per_pixel)
+			{
+				unsigned int index = 0;
+				input_source-&gt;read(&amp;index, index_size);
+				if (big) CL_Endian::swap(&amp;index, index_size);
+
+				const unsigned int c = color_map[index];
+				memcpy(p, &amp;c, bytes_per_pixel);
+				alpha_found |= c &amp; alpha_mask;
+			}
+		}
+
+		const int bpp = header.colormap_entry_size;
+
+		CL_PixelBuffer_Generic::format.enable_colorkey(false);
+		CL_PixelBuffer_Generic::format.set_colorkey(0);
+		CL_PixelBuffer_Generic::format.set_depth(bpp);
+		if (bpp == 32)
+		{
+			CL_PixelBuffer_Generic::format.set_red_mask(0x00ff0000);
+			CL_PixelBuffer_Generic::format.set_green_mask(0x0000ff00);
+			CL_PixelBuffer_Generic::format.set_blue_mask(0x000000ff);
+			if (alpha_found)
+				CL_PixelBuffer_Generic::format.set_alpha_mask(0xff000000);
+			else
+				CL_PixelBuffer_Generic::format.set_alpha_mask(0);
+		}
+		else if (bpp == 24)
+		{
+			CL_PixelBuffer_Generic::format.set_red_mask(0xff0000);
+			CL_PixelBuffer_Generic::format.set_green_mask(0x00ff00);
+			CL_PixelBuffer_Generic::format.set_blue_mask(0x0000ff);
+			CL_PixelBuffer_Generic::format.set_alpha_mask(0x000000);
+		}
+		else if (bpp == 16)
+		{
+			// ARRRRRGG GGGBBBBB (little endian)
+			CL_PixelBuffer_Generic::format.set_red_mask(CL_PixelFormat::get_bitmask(5, 10));
+			CL_PixelBuffer_Generic::format.set_green_mask(CL_PixelFormat::get_bitmask(5, 5));
+			CL_PixelBuffer_Generic::format.set_blue_mask(CL_PixelFormat::get_bitmask(5, 0));
+			if (alpha_found)
+				CL_PixelBuffer_Generic::format.set_alpha_mask(CL_PixelFormat::get_bitmask(1, 15));
+			else
+				CL_PixelBuffer_Generic::format.set_alpha_mask(0);
+		}
+		CL_PixelBuffer_Generic::pitch = pitch;
+		CL_PixelBuffer_Generic::width = width;
+		CL_PixelBuffer_Generic::height = height;
+	}
+}
+
+/*
+	CODE FOR DECODING TYPE 2 TARGA FILES
+*/
+void CL_TargaProvider_Generic::read_rgb(
+	CL_InputSource *input_source, 
+	const CL_TargaProvider_Generic::TGA_Header &amp;header)
+{
+	if (header.colormap_type != 0)
+	{
+		// skip the color map
+		input_source-&gt;seek(header.colormap_length * (header.colormap_entry_size / 8), CL_InputSource::seek_cur);
+	}
+
+	const int width = header.image_width;
+	const int height = header.image_height;
+	const int bytes_per_pixel = header.image_pixel_size / 8;
+	int pitch = width * bytes_per_pixel;
+
+	// set to true if an alpha value &gt; 0 was found (if the color depth supports it)
+	int alpha_found = false;
+	int alpha_mask;
+	if (bytes_per_pixel == 2)
+		alpha_mask = 0x8000;
+	else if (bytes_per_pixel == 4)
+		alpha_mask = 0xff000000;
+	else
+		alpha_mask = 0;
+
+	image = new unsigned char[pitch * height];
+	cl_assert(image != 0);
+
+	const bool is_mirrored = (header.image_descriptor_byte &amp; (1 &lt;&lt; 5)) ? false : true;
+	const int target_y_modifier = is_mirrored ? -1 : 1;
+	int targety = is_mirrored ? (height - 1) : 0;
+	int size_c = header.image_pixel_size / 8;
+	cl_assert(size_c &lt;= 4);
+	bool big = CL_Endian::is_system_big();
+	for (int y = 0; y &lt; height; y++, targety += target_y_modifier)
+	{
+		unsigned char *p = image + (targety * pitch);
+		for (int x = 0; x &lt; width; x++, p += bytes_per_pixel)
+		{
+			unsigned int c = 0;
+			input_source-&gt;read(&amp;c, size_c);
+			if (big) CL_Endian::swap(&amp;c, size_c);
+
+			memcpy(p, &amp;c, bytes_per_pixel);
+			alpha_found |= c &amp; alpha_mask;
+		}
+	}
+
+	const int bpp = header.image_pixel_size;
+
+	CL_PixelBuffer_Generic::format.enable_colorkey(false);
+	CL_PixelBuffer_Generic::format.set_colorkey(0);
+	CL_PixelBuffer_Generic::format.set_depth(bpp);
+	if (bpp == 32)
+	{
+		CL_PixelBuffer_Generic::format.set_red_mask(0x00ff0000);
+		CL_PixelBuffer_Generic::format.set_green_mask(0x0000ff00);
+		CL_PixelBuffer_Generic::format.set_blue_mask(0x000000ff);
+		if (alpha_found)
+			CL_PixelBuffer_Generic::format.set_alpha_mask(0xff000000);
+		else
+			CL_PixelBuffer_Generic::format.set_alpha_mask(0);
+	}
+	else if (bpp == 24)
+	{
+		CL_PixelBuffer_Generic::format.set_red_mask(0xff0000);
+		CL_PixelBuffer_Generic::format.set_green_mask(0x00ff00);
+		CL_PixelBuffer_Generic::format.set_blue_mask(0x0000ff);
+		CL_PixelBuffer_Generic::format.set_alpha_mask(0x000000);
+	}
+	else if (bpp == 16)
+	{
+		// ARRRRRGG GGGBBBBB (little endian)
+		CL_PixelBuffer_Generic::format.set_red_mask(CL_PixelFormat::get_bitmask(5, 10));
+		CL_PixelBuffer_Generic::format.set_green_mask(CL_PixelFormat::get_bitmask(5, 5));
+		CL_PixelBuffer_Generic::format.set_blue_mask(CL_PixelFormat::get_bitmask(5, 0));
+		if (alpha_found)
+			CL_PixelBuffer_Generic::format.set_alpha_mask(CL_PixelFormat::get_bitmask(1, 15));
+		else
+			CL_PixelBuffer_Generic::format.set_alpha_mask(0);
+	}
+	CL_PixelBuffer_Generic::pitch = pitch;
+	CL_PixelBuffer_Generic::width = width;
+	CL_PixelBuffer_Generic::height = height;
+}
+
+/*
+	CODE FOR DECODING TYPE 9 TARGA FILES
+*/
+void CL_TargaProvider_Generic::read_rle_colormapped(
+	CL_InputSource *input_source, 
+	const CL_TargaProvider_Generic::TGA_Header &amp;header)
+{
+	int pitch = 0;
+	const int width = header.image_width;
+	const int height = header.image_height;
+
+	const unsigned int type_mask = CL_PixelFormat::get_bitmask(1, 7);
+	const unsigned int count_mask = CL_PixelFormat::get_bitmask(7, 0);
+
+	// if we use a palette that is &lt;= 256 colors, we can convert it to the standard palette type
+	if (header.colormap_length &lt;= 256)
+	{		
+		// read the color map to palette
+		{
+			for (unsigned int i = 0; i &lt; header.colormap_length; i++)
+			{
+				int r = 0, g = 0, b = 0, a = 255;
+				if (header.colormap_entry_size == 32)
+				{
+					b = input_source-&gt;read_uint8();
+					g = input_source-&gt;read_uint8();
+					r = input_source-&gt;read_uint8();
+					a = input_source-&gt;read_uint8();
+				}
+				else if (header.colormap_entry_size == 24)
+				{
+					b = input_source-&gt;read_uint8();
+					g = input_source-&gt;read_uint8();
+					r = input_source-&gt;read_uint8();
+				}
+				else if (header.colormap_entry_size == 16)
+				{
+					// ARRRRRGG GGGBBBBB (little endian)
+					const unsigned int color = input_source-&gt;read_uint16();
+					a = (color &amp; CL_PixelFormat::get_bitmask(1, 15)) ? 255 : 0;
+					r = ((color &amp; CL_PixelFormat::get_bitmask(5, 10)) &gt;&gt; 10) &lt;&lt; 3;
+					g = ((color &amp; CL_PixelFormat::get_bitmask(5, 5)) &gt;&gt; 5) &lt;&lt; 3;
+					b = ((color &amp; CL_PixelFormat::get_bitmask(5, 0)) &gt;&gt; 0) &lt;&lt; 3;
+				}
+				palette.colors[i] = CL_Color(r, g, b, a);
+			}
+		}
+
+		pitch = width;
+
+		image = new unsigned char[height * pitch];
+		cl_assert(image != 0);
+
+		// repetitions left of an RLE packed and its associated color
+		unsigned int repe_left = 0, repe_color = 0;
+		// pixels of a raw packet left
+		unsigned int raw_left = 0;
+
+		const bool is_mirrored = (header.image_descriptor_byte &amp; (1 &lt;&lt; 5)) ? false : true;
+		const int target_y_modifier = is_mirrored ? -1 : 1;
+		int targety = is_mirrored ? (height - 1) : 0;
+		int size_c = header.image_pixel_size / 8;
+		cl_assert(size_c &lt;= 4);
+		bool big = CL_Endian::is_system_big();
+		for (int y = 0; y &lt; height; y++, targety += target_y_modifier)
+		{
+			unsigned char *p = image + (targety * pitch);
+			for (int x = 0; x &lt; width; x++, p++)
+			{
+				if (!repe_left &amp;&amp; !raw_left)
+				{
+					// read packet type
+					unsigned char ptype = input_source-&gt;read_uint8();
+					if (ptype &amp; type_mask)
+					{
+						repe_left = (ptype &amp; count_mask) + 1;
+						unsigned int c = 0;
+						input_source-&gt;read(&amp;c, size_c);
+						if (big) CL_Endian::swap(&amp;c, size_c);
+						repe_color = c - header.colormap_orig;
+					}
+					else
+						raw_left = (ptype &amp; count_mask) + 1;
+				}
+
+				if (repe_left)
+				{
+					*p = (unsigned char)repe_color;
+					repe_left--;
+				}
+				else if (raw_left)
+				{
+					unsigned int c = 0;
+					input_source-&gt;read(&amp;c, size_c);
+					if (big) CL_Endian::swap(&amp;c, size_c);
+					c -= header.colormap_orig;
+					*p = (unsigned char)c;
+					raw_left--;
+				}
+			}
+		}
+
+		CL_PixelBuffer_Generic::format.enable_colorkey(false);
+		CL_PixelBuffer_Generic::format.set_colorkey(0);
+		CL_PixelBuffer_Generic::format.set_depth(8);
+		CL_PixelBuffer_Generic::format.set_type(pixelformat_index);
+		CL_PixelBuffer_Generic::pitch = pitch;
+		CL_PixelBuffer_Generic::width = width;
+		CL_PixelBuffer_Generic::height = height;
+	}
+
+	// else we need to convert to the given mode
+	else
+	{		
+		// read the color map to unsigned int in the native format
+		map&lt;unsigned int, unsigned int&gt; color_map;
+		{
+			int size_c = header.colormap_entry_size / 8;
+			cl_assert(size_c &lt;= 4);
+			bool big = CL_Endian::is_system_big();
+			for (int i = header.colormap_orig; i &lt; header.colormap_orig + header.colormap_length; i++)
+			{
+				unsigned int c = 0;
+				input_source-&gt;read(&amp;c, size_c);
+				if (big) CL_Endian::swap(&amp;c, size_c);
+				color_map[i] = c;
+			}
+		}
+		const int bytes_per_pixel = header.colormap_entry_size / 8;
+		pitch = width * bytes_per_pixel;
+
+		image = new unsigned char[height * pitch];
+		cl_assert(image != 0);
+
+		// set to true if an alpha value &gt; 0 was found (if the color depth supports it)
+		int alpha_found = false;
+		int alpha_mask;
+		if (bytes_per_pixel == 2)
+			alpha_mask = 0x8000;
+		else if (bytes_per_pixel == 4)
+			alpha_mask = 0xff000000;
+		else
+			alpha_mask = 0;
+
+		// repetitions left of an RLE packed and its associated color
+		unsigned int repe_left = 0, repe_color = 0;
+		// pixels of a raw packet left
+		unsigned int raw_left = 0;
+
+		const bool is_mirrored = (header.image_descriptor_byte &amp; (1 &lt;&lt; 5)) ? false : true;
+		const int target_y_modifier = is_mirrored ? -1 : 1;
+		int targety = is_mirrored ? (height - 1) : 0;
+		int size_c = header.image_pixel_size / 8;
+		cl_assert(size_c &lt;= 4);
+		bool big = CL_Endian::is_system_big();
+		for (int y = 0; y &lt; height; y++, targety += target_y_modifier)
+		{
+			unsigned char *p = image + (targety * pitch);
+			for (int x = 0; x &lt; width; x++, p += bytes_per_pixel)
+			{
+				if (!repe_left &amp;&amp; !raw_left)
+				{
+					// read packet type
+					unsigned char ptype = input_source-&gt;read_uint8();
+					if (ptype &amp; type_mask)
+					{
+						repe_left = (ptype &amp; count_mask) + 1;
+						unsigned int c = 0;
+						input_source-&gt;read(&amp;c, size_c);
+						if (big) CL_Endian::swap(&amp;c, size_c);
+						repe_color = c;
+					}
+					else
+						raw_left = (ptype &amp; count_mask) + 1;
+				}
+
+				if (repe_left)
+				{
+					const unsigned int c = color_map[repe_color];
+					memcpy(p, &amp;c, bytes_per_pixel);
+					alpha_found |= c &amp; alpha_mask;
+					--repe_left;
+				}
+				else if (raw_left)
+				{
+					unsigned int i = 0;
+					input_source-&gt;read(&amp;i, size_c);
+					if (big) CL_Endian::swap(&amp;i, size_c);
+					const unsigned int c = color_map[i];
+					memcpy(p, &amp;c, bytes_per_pixel);
+					alpha_found |= c &amp; alpha_mask;
+					--raw_left;
+				}
+			}
+		}
+
+		const int bpp = header.colormap_entry_size;
+
+		CL_PixelBuffer_Generic::format.enable_colorkey(false);
+		CL_PixelBuffer_Generic::format.set_colorkey(0);
+		CL_PixelBuffer_Generic::format.set_depth(bpp);
+		if (bpp == 32)
+		{
+			CL_PixelBuffer_Generic::format.set_red_mask(0x00ff0000);
+			CL_PixelBuffer_Generic::format.set_green_mask(0x0000ff00);
+			CL_PixelBuffer_Generic::format.set_blue_mask(0x000000ff);
+			if (alpha_found)
+				CL_PixelBuffer_Generic::format.set_alpha_mask(0xff000000);
+			else
+				CL_PixelBuffer_Generic::format.set_alpha_mask(0);
+		}
+		else if (bpp == 24)
+		{
+			CL_PixelBuffer_Generic::format.set_red_mask(0xff0000);
+			CL_PixelBuffer_Generic::format.set_green_mask(0x00ff00);
+			CL_PixelBuffer_Generic::format.set_blue_mask(0x0000ff);
+			CL_PixelBuffer_Generic::format.set_alpha_mask(0x000000);
+		}
+		else if (bpp == 16)
+		{
+			// ARRRRRGG GGGBBBBB (little endian)
+			CL_PixelBuffer_Generic::format.set_red_mask(CL_PixelFormat::get_bitmask(5, 10));
+			CL_PixelBuffer_Generic::format.set_green_mask(CL_PixelFormat::get_bitmask(5, 5));
+			CL_PixelBuffer_Generic::format.set_blue_mask(CL_PixelFormat::get_bitmask(5, 0));
+			if (alpha_found)
+				CL_PixelBuffer_Generic::format.set_alpha_mask(CL_PixelFormat::get_bitmask(1, 15));
+			else
+				CL_PixelBuffer_Generic::format.set_alpha_mask(0);
+		}
+		CL_PixelBuffer_Generic::pitch = pitch;
+		CL_PixelBuffer_Generic::width = width;
+		CL_PixelBuffer_Generic::height = height;
+	}
+
+}
+
+/*
+	CODE FOR DECODING TYPE 10 TARGA FILES
+*/
+void CL_TargaProvider_Generic::read_rle_rgb(
+	CL_InputSource *input_source, 
+	const CL_TargaProvider_Generic::TGA_Header &amp;header)
+{
+	if (header.colormap_type != 0)
+	{
+		// skip the color map
+		input_source-&gt;seek(header.colormap_length * (header.colormap_entry_size / 8), CL_InputSource::seek_cur);
+	}
+
+	const int width = header.image_width;
+	const int height = header.image_height;
+
+	const unsigned int type_mask = CL_PixelFormat::get_bitmask(1, 7);
+	const unsigned int count_mask = CL_PixelFormat::get_bitmask(7, 0);
+
+	const int bytes_per_pixel = header.image_pixel_size / 8;
+	pitch = width * bytes_per_pixel;
+
+	image = new unsigned char[height * pitch];
+	cl_assert(image != 0);
+
+	// set to true if an alpha value &gt; 0 was found (if the color depth supports it)
+	int alpha_found = false;
+	int alpha_mask;
+	if (bytes_per_pixel == 2)
+		alpha_mask = 0x8000;
+	else if (bytes_per_pixel == 4)
+		alpha_mask = 0xff000000;
+	else
+		alpha_mask = 0;
+
+	// repetitions left of an RLE packed and its associated color
+	unsigned int repe_left = 0, repe_color = 0;
+	// pixels of a raw packet left
+	unsigned int raw_left = 0;
+
+	const bool is_mirrored = (header.image_descriptor_byte &amp; (1 &lt;&lt; 5)) ? false : true;
+	const int target_y_modifier = is_mirrored ? -1 : 1;
+	int targety = is_mirrored ? (height - 1) : 0;
+	int size_c = header.image_pixel_size / 8;
+	cl_assert(size_c &lt;= 4);
+	bool big = CL_Endian::is_system_big();
+	for (int y = 0; y &lt; height; y++, targety += target_y_modifier)
+	{
+		unsigned char *p = image + (targety * pitch);
+		for (int x = 0; x &lt; width; x++, p += bytes_per_pixel)
+		{
+			if (!repe_left &amp;&amp; !raw_left)
+			{
+				// read packet type
+				unsigned char ptype = input_source-&gt;read_uint8();
+				if (ptype &amp; type_mask)
+				{
+					repe_left = (ptype &amp; count_mask) + 1;
+					unsigned int c = 0;
+					input_source-&gt;read(&amp;c, size_c);
+					if (big) CL_Endian::swap(&amp;c, size_c);
+					repe_color = c;
+				}
+				else
+					raw_left = (ptype &amp; count_mask) + 1;
+			}
+
+			if (repe_left)
+			{
+				memcpy(p, &amp;repe_color, bytes_per_pixel);
+				alpha_found |= repe_color &amp; alpha_mask;
+				--repe_left;
+			}
+			else if (raw_left)
+			{
+				unsigned int c = 0;
+				input_source-&gt;read(&amp;c, size_c);
+				if (big) CL_Endian::swap(&amp;c, size_c);
+				memcpy(p, &amp;c, bytes_per_pixel);
+				alpha_found |= c &amp; alpha_mask;
+				--raw_left;
+			}
+		}
+	}
+
+	const int bpp = header.image_pixel_size;
+
+	CL_PixelBuffer_Generic::format.enable_colorkey(false);
+	CL_PixelBuffer_Generic::format.set_colorkey(0);
+	CL_PixelBuffer_Generic::format.set_depth(bpp);
+	if (bpp == 32)
+	{
+		CL_PixelBuffer_Generic::format.set_red_mask(0x00ff0000);
+		CL_PixelBuffer_Generic::format.set_green_mask(0x0000ff00);
+		CL_PixelBuffer_Generic::format.set_blue_mask(0x000000ff);
+		if (alpha_found)
+			CL_PixelBuffer_Generic::format.set_alpha_mask(0xff000000);
+		else
+			CL_PixelBuffer_Generic::format.set_alpha_mask(0);
+	}
+	else if (bpp == 24)
+	{
+		CL_PixelBuffer_Generic::format.set_red_mask(0xff0000);
+		CL_PixelBuffer_Generic::format.set_green_mask(0x00ff00);
+		CL_PixelBuffer_Generic::format.set_blue_mask(0x0000ff);
+		CL_PixelBuffer_Generic::format.set_alpha_mask(0x000000);
+	}
+	else if (bpp == 16)
+	{
+		// ARRRRRGG GGGBBBBB (little endian)
+		CL_PixelBuffer_Generic::format.set_red_mask(CL_PixelFormat::get_bitmask(5, 10));
+		CL_PixelBuffer_Generic::format.set_green_mask(CL_PixelFormat::get_bitmask(5, 5));
+		CL_PixelBuffer_Generic::format.set_blue_mask(CL_PixelFormat::get_bitmask(5, 0));
+		if (alpha_found)
+			CL_PixelBuffer_Generic::format.set_alpha_mask(CL_PixelFormat::get_bitmask(1, 15));
+		else
+			CL_PixelBuffer_Generic::format.set_alpha_mask(0);
+	}
+	CL_PixelBuffer_Generic::pitch = pitch;
+	CL_PixelBuffer_Generic::width = width;
+	CL_PixelBuffer_Generic::height = height;
+
+}
+
+void *CL_TargaProvider_Generic::get_data()
+{
+	return image;
+}

Added: trunk/clanlib/Display/Providers/targa_provider_generic.h
===================================================================
--- trunk/clanlib/Display/Providers/targa_provider_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Providers/targa_provider_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,83 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_targaprovider_generic
+#define header_targaprovider_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Display/Providers/targa_provider.h&quot;
+#include &quot;Display/pixel_buffer_generic.h&quot;
+
+#include &quot;API/Core/IOData/inputsource.h&quot;
+#include &quot;API/Core/IOData/inputsource_provider.h&quot;
+
+//: Surface provider that can load targa (.tga) files.
+class CL_TargaProvider_Generic : public CL_PixelBuffer_Generic
+{
+//! Construction:
+public:
+	//: Constructs a surface provider that can read targa files.
+	//param name: Name of the targa file to load.
+	//param provider: Input source provider that delivers the targa file.
+	CL_TargaProvider_Generic(
+		const std::string name,
+		CL_InputSourceProvider *provider);
+
+	//: Target Provider Destructor
+	virtual ~CL_TargaProvider_Generic();
+
+//! Operations:
+public:
+	//: Returns the image data. Provider must be locked before pointer is valid.
+	virtual void *get_data();
+
+	//: Reference counted lock function. Allocate pixel buffer in this function. 
+	virtual void perform_lock() { return; }
+
+	//: Reference counted unlock function. Free pixel buffer in this function.
+	virtual void perform_unlock() { return; }
+
+//! Implementation:
+private:
+	struct TGA_Header;
+
+	unsigned char *image;
+							
+	void read_tga(CL_InputSource *input_source);
+
+	void read_colormapped(CL_InputSource *input_source, const TGA_Header &amp;header);
+	void read_rgb(CL_InputSource *input_source, const TGA_Header &amp;header);
+	void read_rle_colormapped(CL_InputSource *input_source, const TGA_Header &amp;header);
+	void read_rle_rgb(CL_InputSource *input_source, const TGA_Header &amp;header);
+};
+
+#endif

Added: trunk/clanlib/Display/Win32/dc_buffer.cpp
===================================================================
--- trunk/clanlib/Display/Win32/dc_buffer.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Win32/dc_buffer.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,52 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/Providers/dc_buffer.h&quot;
+#include &quot;dc_buffer_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DeviceContextBuffer construction:
+
+CL_DeviceContextBuffer::CL_DeviceContextBuffer(
+	HDC reference_dc, int width, int height, bool monocrome_alpha)
+: CL_PixelBuffer(new CL_DeviceContextBuffer_Generic(reference_dc, width, height, monocrome_alpha))
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DeviceContextBuffer attributes:
+
+HDC CL_DeviceContextBuffer::get_dc()
+{
+	return ((CL_DeviceContextBuffer_Generic *) impl)-&gt;get_dc();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DeviceContextBuffer implementation:

Added: trunk/clanlib/Display/Win32/dc_buffer_generic.cpp
===================================================================
--- trunk/clanlib/Display/Win32/dc_buffer_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Win32/dc_buffer_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,135 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;dc_buffer_generic.h&quot;
+
+// Define DIBSECTION to share pixelbuffer data with GDI. Currently fucks up colors tho.
+// #define USE_DIBSECTION
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DeviceContextBuffer_Generic construction:
+
+CL_DeviceContextBuffer_Generic::CL_DeviceContextBuffer_Generic(HDC reference_dc, int bitmap_width, int bitmap_height, bool monocrome_alpha)
+{
+	ref_dc = reference_dc;
+
+	// Find the pixelformat properties for the reference DC:
+	unsigned int red_mask   = 0xff0000;
+	unsigned int green_mask = 0x00ff00;
+	unsigned int blue_mask  = 0x0000ff;
+
+	// Setup pixelbuffer format info:
+	if (monocrome_alpha)
+	{
+		format.set_red_mask(red_mask);
+		format.set_green_mask(red_mask);
+		format.set_blue_mask(red_mask);
+		format.set_alpha_mask(blue_mask);
+		format.set_depth(32);
+	}
+	else
+	{
+		format.set_red_mask(red_mask);
+		format.set_green_mask(green_mask);
+		format.set_blue_mask(blue_mask);
+		format.set_alpha_mask(0);
+		format.set_depth(32);
+	}
+	width = bitmap_width;
+	height = bitmap_height;
+	pitch = width*4;
+
+	// Create DC and bitmap for pixelbuffer:
+	memory_dc = CreateCompatibleDC(ref_dc);
+
+	memset(&amp;bitmap_info, 0, sizeof(BITMAPINFO));
+	bitmap_info.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+	bitmap_info.bmiHeader.biWidth = width;
+	bitmap_info.bmiHeader.biHeight = -height;
+	bitmap_info.bmiHeader.biPlanes = 1;
+	bitmap_info.bmiHeader.biBitCount = 32;
+	bitmap_info.bmiHeader.biCompression = BI_BITFIELDS;
+	bitmap_info.bmiHeader.biSizeImage = pitch*height;
+	bitmap_info.bmiColors[0].rgbRed = red_mask;
+	bitmap_info.bmiColors[0].rgbGreen = green_mask;
+	bitmap_info.bmiColors[0].rgbBlue = blue_mask;
+#ifdef USE_DIBSECTION
+	bitmap = CreateDIBSection(ref_dc, &amp;bitmap_info, DIB_RGB_COLORS, (LPVOID *) &amp;data, 0, 0);
+#else
+	bitmap = CreateCompatibleBitmap(ref_dc, width, height);
+	first_lock = true;
+	data = 0;
+#endif
+
+	orig_bitmap = (HBITMAP) SelectObject(memory_dc, bitmap);
+}
+
+CL_DeviceContextBuffer_Generic::~CL_DeviceContextBuffer_Generic()
+{
+#ifndef USE_DIBSECTION
+	delete[] data;
+#endif
+
+	SelectObject(memory_dc, orig_bitmap);
+	DeleteObject(bitmap);
+	DeleteDC(memory_dc);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DeviceContextBuffer_Generic operations:
+
+void *CL_DeviceContextBuffer_Generic::get_data()
+{
+	return data;
+}
+
+void CL_DeviceContextBuffer_Generic::perform_lock()
+{
+#ifdef USE_DIBSECTION
+	// We call GdiFlush() here to ensure that any operations on the device context actually finished when
+	// application start accessing the data.
+	GdiFlush();
+#else
+	if (first_lock)
+	{
+		data = new unsigned char[pitch*height];
+
+		/*int scanlines =*/ GetDIBits(memory_dc, bitmap, 0, height, data, &amp;bitmap_info, DIB_RGB_COLORS);
+		first_lock = false;
+	}
+#endif
+}
+
+void CL_DeviceContextBuffer_Generic::perform_unlock()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DeviceContextBuffer_Generic implementation:

Added: trunk/clanlib/Display/Win32/dc_buffer_generic.h
===================================================================
--- trunk/clanlib/Display/Win32/dc_buffer_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Win32/dc_buffer_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,81 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_dc_buffer_generic
+#define header_dc_buffer_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;windows.h&gt;
+#include &quot;API/Display/pixel_buffer.h&quot;
+#include &quot;Display/pixel_buffer_generic.h&quot;
+
+class CL_DeviceContextBuffer_Generic : public CL_PixelBuffer_Generic
+{
+//! Construction:
+public:
+	//: Construct a pixelbuffer using the pixel format of the passed device context.
+	CL_DeviceContextBuffer_Generic(HDC reference_dc, int width, int height, bool monocrome_alpha);
+
+	~CL_DeviceContextBuffer_Generic();
+
+//! Attributes:
+public:
+	HDC get_dc() { return memory_dc; }
+
+//! Operations:
+public:
+	//: Returns a pointer to the beginning of the pixel buffer. Pointer
+	//: is only valid inside a lock/unlock session.
+	virtual void *get_data();
+
+	//: Reference counted lock function.
+	virtual void perform_lock();
+
+	//: Reference counted unlock function.
+	virtual void perform_unlock();
+
+//! Implementation:
+private:
+	HDC ref_dc;
+
+	HDC memory_dc;
+
+	BITMAPINFO bitmap_info;
+
+	HBITMAP bitmap, orig_bitmap;
+
+	unsigned char *data;
+
+	bool first_lock;
+};
+
+#endif

Added: trunk/clanlib/Display/Win32/display_window_win32.cpp
===================================================================
--- trunk/clanlib/Display/Win32/display_window_win32.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Win32/display_window_win32.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,910 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;dinput.h&quot;
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;display_window_win32.h&quot;
+#include &quot;input_device_win32keyboard.h&quot;
+#include &quot;input_device_win32mouse.h&quot;
+#include &quot;input_device_directinput.h&quot;
+#include &quot;Core/System/Win32/init_win32.h&quot;
+#include &quot;API/Display/input_event.h&quot;
+#include &quot;API/Display/keys.h&quot;
+#include &quot;API/Display/display_window_description.h&quot;
+#include &quot;API/Core/Math/rect.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/Core/System/log.h&quot;
+
+#ifndef WM_MOUSEWHEEL
+#define WM_MOUSEWHEEL    0x020A
+#endif
+
+#ifndef WM_XBUTTONDOWN
+#define WM_XBUTTONDOWN   0x020B
+#define WM_XBUTTONUP     0x020C
+#define WM_XBUTTONDBLCLK 0x020D
+#endif
+
+#ifndef WS_EX_LAYERED
+#define WS_EX_LAYERED 0x00080000
+#endif
+
+// My dinput.lib seem to be broken (the one with msvc7).
+// It gives me a linker error about DirectInput8Create. Easier to create with cocreateinstance than
+// download hundred megabytes. :) -- mbn 5 oct 2003
+#define BROKEN_DINPUT
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DisplayWindow_Win32 construction:
+
+CL_DisplayWindow_Win32::CL_DisplayWindow_Win32()
+: hwnd(NULL), title(&quot;nonamed&quot;), fullscreen(false),
+	allow_resize(false), layered(false), bpp(0), saved_position(0, 0, 0, 0),
+	left_ctrl_down(false), left_alt_down(false), left_shift_down(false),
+	right_ctrl_down(false), right_alt_down(false), right_shift_down(false),
+	mouse_pos(-1,-1), directinput(0), repeat_count(0), previous_key_down(0)
+{
+	keyboard = CL_InputDevice(new CL_InputDevice_Win32Keyboard(this));
+	mouse = CL_InputDevice(new CL_InputDevice_Win32Mouse(this));
+
+	memset(keys_down, 0, 256);
+
+#ifndef BROKEN_DINPUT
+	HRESULT result = DirectInput8Create(GetModuleHandle(0), DIRECTINPUT_VERSION, IID_IDirectInput8, (LPVOID *) &amp;directinput, 0);
+	if (FAILED(result))
+	{
+		CL_Log::log(&quot;debug&quot;, &quot;Unable to initialize direct input&quot;);
+	}
+#else
+	// My directinput doesnt know this directinput8create function (hmm weird)
+	// So creating it via CoCreateInstance instead..
+
+	HRESULT result = CoInitialize(0);
+	if (FAILED(result))
+	{
+		throw CL_Error(&quot;CL_DisplayWindow_Win32: Damn murphy must hate you. CoInitialize failed!&quot;);
+	}
+
+	result = CoCreateInstance(CLSID_DirectInput8, 0, CLSCTX_INPROC_SERVER, IID_IDirectInput8A, (LPVOID *) &amp;directinput);
+	if (FAILED(result))
+	{
+		CL_Log::log(&quot;debug&quot;, &quot;Unable to create direct input&quot;);
+	}
+	else
+	{
+		result = directinput-&gt;Initialize(GetModuleHandle(0), DIRECTINPUT_VERSION);
+		if (FAILED(result))
+		{
+			directinput-&gt;Release();
+			directinput = 0;
+
+			CL_Log::log(&quot;debug&quot;, &quot;Unable to initialize direct input&quot;);
+		}
+	}
+#endif
+}
+
+CL_DisplayWindow_Win32::~CL_DisplayWindow_Win32()
+{
+	if (hwnd) destroy_window();
+#ifndef BROKEN_DINPUT
+	if (directinput) directinput-&gt;Release();
+#else
+	if (directinput) directinput-&gt;Release();
+	CoUninitialize();
+#endif
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DisplayWindow_Win32 attributes:
+
+std::map&lt;HWND, CL_DisplayWindow_Win32 *&gt; CL_DisplayWindow_Win32::window_map;
+
+int CL_DisplayWindow_Win32::get_width() const
+{
+	if (layered) return layered_position.get_width();
+
+	RECT rect;
+	GetClientRect(hwnd, &amp;rect);
+	return rect.right - rect.left;
+}
+
+int CL_DisplayWindow_Win32::get_height() const
+{
+	if (layered) return layered_position.get_height();
+
+	RECT rect;
+	GetClientRect(hwnd, &amp;rect);
+	return rect.bottom - rect.top;
+}
+
+bool CL_DisplayWindow_Win32::is_fullscreen() const
+{
+	return fullscreen;
+}
+
+bool CL_DisplayWindow_Win32::has_focus() const
+{
+	return (GetFocus() == hwnd);
+}
+
+int CL_DisplayWindow_Win32::get_buffer_count() const
+{
+	return 1;
+}
+
+bool CL_DisplayWindow_Win32::get_keycode(int keycode) const
+{
+	return false;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DisplayWindow_Win32 operations:
+
+void CL_DisplayWindow_Win32::set_fullscreen(int width, int height, int bpp, int refresh_rate)
+{
+	CL_DisplayWindowDescription desc;
+	desc.set_title(title);
+	desc.set_size(CL_Size(width, height));
+	desc.set_bpp(bpp);
+	desc.set_refresh_rate(refresh_rate);
+	desc.set_allow_resize(allow_resize);
+	desc.set_fullscreen(true);
+	desc.set_layered(layered);
+	create_window(desc);
+}
+
+void CL_DisplayWindow_Win32::set_windowed()
+{
+	if (!fullscreen) return;
+
+	CL_DisplayWindowDescription desc;
+	desc.set_title(title);
+    desc.set_size(CL_Size(get_width(), get_height()));
+	desc.set_allow_resize(allow_resize);
+	desc.set_layered(layered);
+	create_window(desc);
+}
+
+void CL_DisplayWindow_Win32::set_title(const std::string &amp;_title)
+{
+	title = _title;
+	SetWindowText(hwnd, title.c_str());
+}
+
+void CL_DisplayWindow_Win32::set_position(const CL_Rect &amp;pos)
+{
+	RECT rect, clientRect;
+	GetWindowRect(hwnd, &amp;rect);
+	GetClientRect(hwnd, &amp;clientRect);
+	int windowWidth = pos.get_width()+(rect.right-rect.left)-(clientRect.right-clientRect.left);
+	int windowHeight = pos.get_height()+(rect.bottom-rect.top)-(clientRect.bottom-clientRect.top);
+
+	layered_position = pos;
+	SetWindowPos(hwnd, 0, pos.left, pos.top, windowWidth, windowHeight, SWP_NOREPOSITION|SWP_NOZORDER);
+}
+
+void CL_DisplayWindow_Win32::set_position(int x, int y)
+{
+	CL_Size size = layered_position.get_size();
+	layered_position = CL_Rect(x, y, x+size.width, y+size.height);
+
+	SetWindowPos(hwnd, 0, x, y, 0, 0, SWP_NOREPOSITION|SWP_NOZORDER|SWP_NOSIZE);
+}
+
+void CL_DisplayWindow_Win32::set_size(int width, int height)
+{
+	layered_position.set_size(CL_Size(width, height));
+
+	RECT rect, clientRect;
+	GetWindowRect(hwnd, &amp;rect);
+	GetClientRect(hwnd, &amp;clientRect);
+	int windowWidth = width+(rect.right-rect.left)-(clientRect.right-clientRect.left);
+	int windowHeight = height+(rect.bottom-rect.top)-(clientRect.bottom-clientRect.top);
+
+	SetWindowPos(hwnd, 0, 0, 0, windowWidth, windowHeight, SWP_NOREPOSITION|SWP_NOZORDER|SWP_NOMOVE);
+}
+
+void CL_DisplayWindow_Win32::set_buffer_count(int flipping_buffers)
+{
+}
+
+void CL_DisplayWindow_Win32::update(const CL_Rect &amp;rect)
+{
+}
+
+void CL_DisplayWindow_Win32::flip(int interval)
+{
+}
+
+void CL_DisplayWindow_Win32::create_window(const CL_DisplayWindowDescription &amp;desc)
+{
+	if (hwnd)
+	{
+		modify_window(desc);
+	}
+	else
+	{
+		create_new_window(desc);
+	}
+}
+
+void CL_DisplayWindow_Win32::modify_window(const CL_DisplayWindowDescription &amp;desc)
+{
+	bool clientSize = true;
+
+	if (!fullscreen)
+	{
+		RECT rect;
+		GetWindowRect(hwnd, &amp;rect);
+		saved_position.left = rect.left;
+		saved_position.top = rect.top;
+		saved_position.right = rect.right;
+		saved_position.bottom = rect.bottom;
+	}
+
+	title = desc.get_title();
+	fullscreen = desc.is_fullscreen();
+	layered = desc.is_layered();
+	layered_position = desc.get_position();
+	allow_resize = desc.get_allow_resize();
+
+	int x = 0;
+	int y = 0;
+	int width = desc.get_size().width;
+	int height = desc.get_size().height;
+
+	if (desc.is_fullscreen())
+	{
+		width = GetSystemMetrics(SM_CXSCREEN);
+		height = GetSystemMetrics(SM_CYSCREEN);
+	}
+	else
+	{
+		int scr_width = GetSystemMetrics(SM_CXSCREEN);
+		int scr_height = GetSystemMetrics(SM_CYSCREEN);
+
+		x = scr_width/2 - width/2;
+		y = scr_height/2 - height/2;
+	}
+
+	if (width == 0 &amp;&amp; height == 0)
+	{
+		x = saved_position.left;
+		y = saved_position.top;
+		width = saved_position.get_width();
+		height = saved_position.get_height();
+		clientSize = false;
+	}
+
+	int style;
+	if (desc.is_fullscreen())
+	{
+		style = WS_POPUP;
+	}
+	else if (allow_resize)
+	{
+		style = WS_POPUP | WS_SYSMENU | WS_CAPTION | WS_SIZEBOX | WS_MAXIMIZEBOX | WS_MINIMIZEBOX;
+	}
+	else
+	{
+		style = WS_POPUPWINDOW | WS_CAPTION | WS_MINIMIZEBOX;
+	}
+
+	int ex_style = 0;
+	if (desc.is_layered())
+	{
+		ex_style = WS_EX_LAYERED;
+	}
+
+	// get size of window with decorations to pass to CreateWindow
+	RECT window_rect = { x, y, x+width, y+height };
+	if (clientSize)
+		AdjustWindowRectEx( &amp;window_rect, style, FALSE, ex_style );
+
+	SetWindowLong(hwnd, GWL_STYLE, style);
+	SetWindowLong(hwnd, GWL_EXSTYLE, ex_style);
+
+	if (desc.is_fullscreen())
+	{
+		// Make always on top
+		SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, width, height, SWP_FRAMECHANGED);
+	}
+	else
+	{
+		// Clear always on top flag; size as requested by description struct.
+		SetWindowPos(
+			hwnd,
+			HWND_NOTOPMOST,
+			window_rect.left,
+			window_rect.top,
+			window_rect.right-window_rect.left,
+			window_rect.bottom-window_rect.top,
+			SWP_FRAMECHANGED);
+	}
+
+	ShowWindow(hwnd, SW_SHOW);
+	UpdateWindow(hwnd);
+	RedrawWindow(0, 0, 0, RDW_ALLCHILDREN|RDW_INVALIDATE|RDW_UPDATENOW);
+}
+
+void CL_DisplayWindow_Win32::create_new_window(const CL_DisplayWindowDescription &amp;desc)
+{
+	bool clientSize = true;
+
+	title = desc.get_title();
+	fullscreen = desc.is_fullscreen();
+	layered = desc.is_layered();
+	layered_position = desc.get_position();
+	allow_resize = desc.get_allow_resize();
+
+	WNDCLASS wndclass;
+
+	wndclass.style = CS_DBLCLKS;
+	wndclass.lpfnWndProc = (WNDPROC) CL_DisplayWindow_Win32::message_handler;
+	wndclass.cbClsExtra = 0;
+	wndclass.cbWndExtra = 0;
+	wndclass.hInstance = CL_System_Win32::hInstance;
+	wndclass.hIcon = LoadIcon(CL_System_Win32::hInstance, MAKEINTRESOURCE(1001));
+	wndclass.hCursor = LoadCursor (NULL,IDC_ARROW);
+	wndclass.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
+	wndclass.lpszMenuName = &quot;ClanApplication&quot;;
+	wndclass.lpszClassName = &quot;ClanApplication&quot;;
+
+	RegisterClass(&amp;wndclass);
+
+	int x = 0;
+	int y = 0;
+	int width = desc.get_size().width;
+	int height = desc.get_size().height;
+
+	if (desc.is_fullscreen())
+	{
+		width = GetSystemMetrics(SM_CXSCREEN);
+		height = GetSystemMetrics(SM_CYSCREEN);
+	}
+	else
+	{
+		int scr_width = GetSystemMetrics(SM_CXSCREEN);
+		int scr_height = GetSystemMetrics(SM_CYSCREEN);
+
+		x = scr_width/2 - width/2;
+		y = scr_height/2 - height/2;
+	}
+
+	if (width == 0 &amp;&amp; height == 0)
+	{
+		x = saved_position.left;
+		y = saved_position.top;
+		width = saved_position.get_width();
+		height = saved_position.get_height();
+		clientSize = false;
+	}
+
+	int style;
+	if (desc.is_fullscreen())
+	{
+		style = WS_POPUP;
+	}
+	else if (allow_resize)
+	{
+		style = WS_POPUP | WS_SYSMENU | WS_CAPTION | WS_SIZEBOX | WS_MAXIMIZEBOX | WS_MINIMIZEBOX;
+	}
+	else
+	{
+		style = WS_POPUPWINDOW | WS_CAPTION | WS_MINIMIZEBOX;
+	}
+
+	int ex_style = 0;
+	if (desc.is_layered())
+	{
+		ex_style = WS_EX_LAYERED;
+	}
+
+	// get size of window with decorations to pass to CreateWindow
+	RECT window_rect = { x, y, x+width, y+height };
+	if (clientSize)
+		AdjustWindowRectEx( &amp;window_rect, style, FALSE, ex_style );
+
+	hwnd = CreateWindowEx(
+		ex_style,
+		&quot;ClanApplication&quot;,
+		title.c_str(),
+		style,
+		window_rect.left,
+		window_rect.top,
+		window_rect.right - window_rect.left,
+		window_rect.bottom - window_rect.top,
+		NULL,
+		NULL,
+		CL_System_Win32::hInstance,
+		NULL);
+
+	window_map[hwnd] = this; // register window in &quot;hwnd to window&quot; hash table
+
+	cl_assert(hwnd != NULL);
+
+	if (desc.is_fullscreen())
+	{
+		// Make always on top
+		SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, width, height, 0); 
+	}
+
+	ShowWindow(hwnd, SW_SHOW);
+	UpdateWindow(hwnd);
+
+	// Connect input context to new window:
+
+	input_context.clear();
+	input_context.add_keyboard(keyboard);
+	input_context.add_mouse(mouse);
+
+	// Go looking for joysticks:
+	if (directinput)
+	{
+		HRESULT result = directinput-&gt;EnumDevices(
+			DI8DEVCLASS_GAMECTRL,
+			&amp;CL_DisplayWindow_Win32::enum_devices_callback,
+			this,
+			DIEDFL_ATTACHEDONLY);
+		if (FAILED(result))
+		{
+			CL_Log::log(&quot;debug&quot;, &quot;Unable to enumerate direct input devices&quot;);
+		}
+	}
+}
+
+BOOL CL_DisplayWindow_Win32::enum_devices_callback(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef)
+{
+	CL_DisplayWindow_Win32 *self = (CL_DisplayWindow_Win32 *) pvRef;
+	try
+	{
+		CL_InputDevice device(new CL_InputDevice_DirectInput(self, lpddi));
+		self-&gt;input_context.add_joystick(device);
+	}
+	catch (CL_Error error)
+	{
+		CL_Log::log(&quot;debug&quot;, &quot;Could not setup game controller: %1&quot;, error.message);
+	}
+	return TRUE;
+}
+
+void CL_DisplayWindow_Win32::destroy_window()
+{
+	if (hwnd == NULL) return;
+
+	fullscreen = false;
+	layered = false;
+
+	input_context.clear();
+
+	BOOL res = DestroyWindow(hwnd);
+	cl_assert(res == TRUE);
+	hwnd = NULL;
+}
+
+void CL_DisplayWindow_Win32::show_system_cursor()
+{
+	ShowCursor(TRUE);
+}
+
+void CL_DisplayWindow_Win32::hide_system_cursor()
+{
+	ShowCursor(FALSE);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DisplayWindow_Win32 implementation:
+
+LONG WINAPI CL_DisplayWindow_Win32::message_handler(
+	HWND hWnd,
+	UINT uMsg,
+	WPARAM wParam,
+	LPARAM lParam)
+{
+	// Lookup window and call its event handler:
+ 	std::map&lt;HWND, CL_DisplayWindow_Win32 *&gt;::iterator it = window_map.find(hWnd);
+	if (it != window_map.end())
+	{
+		bool handled = it-&gt;second-&gt;received_event(uMsg, wParam, lParam);
+		if (handled) return TRUE;
+	}
+
+	// Do default window processing if our event handler didnt handle it:
+	return DefWindowProc(hWnd, uMsg, wParam, lParam);
+}
+
+bool CL_DisplayWindow_Win32::received_event(UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+	switch (uMsg)
+	{
+	case WM_KEYDOWN:
+	case WM_SYSKEYDOWN:
+	case WM_KEYUP:
+	case WM_SYSKEYUP:
+		received_keyboard_input(uMsg, wParam, lParam);
+		return true;
+
+	case WM_LBUTTONDOWN:
+	case WM_LBUTTONUP:
+	case WM_LBUTTONDBLCLK:
+	case WM_RBUTTONDOWN:
+	case WM_RBUTTONUP:
+	case WM_RBUTTONDBLCLK:
+	case WM_MBUTTONDOWN:
+	case WM_MBUTTONUP:
+	case WM_MBUTTONDBLCLK:
+	case WM_MOUSEWHEEL:
+	case WM_XBUTTONDOWN:
+	case WM_XBUTTONUP:
+	case WM_XBUTTONDBLCLK:
+		received_mouse_input(uMsg, wParam, lParam);
+		return true;
+
+	case WM_MOUSEMOVE:
+		received_mouse_move(uMsg, wParam, lParam);
+		return true;
+
+	case WM_SIZE:
+		sig_resize(LOWORD(lParam), HIWORD(lParam));
+		return true;
+
+	case WM_ACTIVATE:
+		if (LOWORD(wParam) == WA_INACTIVE)
+			sig_lost_focus();
+		else
+			sig_got_focus();
+		return true;
+
+	case WM_CLOSE:
+		sig_window_close();
+		return true;
+
+	case WM_PAINT:
+		{
+//			HDC hdc = (HDC) wParam;
+			RECT rect;
+			if (GetUpdateRect(hwnd, &amp;rect, FALSE))
+			{
+				PAINTSTRUCT paint;
+				BeginPaint(hwnd, &amp;paint);
+
+				CL_Rect cl_rect;
+				cl_rect.left = rect.left;
+				cl_rect.top = rect.top;
+				cl_rect.right = rect.right;
+				cl_rect.bottom = rect.bottom;
+
+				sig_paint(cl_rect);
+
+				EndPaint(hwnd, &amp;paint);
+			}
+			else
+			{
+				CL_Rect cl_rect(0, 0, get_width(), get_height());
+				sig_paint(cl_rect);
+			}
+		}
+		return true;
+
+	case WM_DESTROY:
+		window_map.erase(window_map.find(hwnd));
+		return true;
+
+	case WM_SYSCOMMAND:
+		// Do not allow screensaver to start.
+		if (wParam == SC_SCREENSAVE) return true;
+		break;
+	}
+
+	return false;
+}
+
+void CL_DisplayWindow_Win32::set_videomode(int width, int height, int bpp, int refresh_rate)
+{
+	DEVMODE devmode;
+	memset(&amp;devmode, 0, sizeof(DEVMODE));
+
+	// Default to 32 bit BPP:
+	if (bpp == 0) bpp = 32;
+	
+	int index = 0;
+
+	// User wants a specific refresh-rate:
+	if (refresh_rate != 0)
+	{
+		while (true)
+		{
+			DEVMODE cur_devmode;
+			memset(&amp;cur_devmode, 0, sizeof(DEVMODE));
+			cur_devmode.dmSize = sizeof(DEVMODE);
+			if (EnumDisplaySettings(0, index++, &amp;cur_devmode) == 0) break;
+
+			if (
+				cur_devmode.dmPelsWidth == width &amp;&amp;
+				cur_devmode.dmPelsHeight == height &amp;&amp;
+				cur_devmode.dmBitsPerPel == bpp &amp;&amp;
+				cur_devmode.dmDisplayFrequency == refresh_rate)
+			{
+				devmode = cur_devmode;
+			}
+		}
+	}
+	
+	// If specific mode not found, try to find the highest possible refresh-rate mode:
+	if (devmode.dmFields == 0)
+	{
+		while (true)
+		{
+			DEVMODE cur_devmode;
+			memset(&amp;cur_devmode, 0, sizeof(DEVMODE));
+			cur_devmode.dmSize = sizeof(DEVMODE);
+			if (EnumDisplaySettings(0, index++, &amp;cur_devmode) == 0) break;
+			
+			if (
+				cur_devmode.dmPelsWidth == width &amp;&amp;
+				cur_devmode.dmPelsHeight == height &amp;&amp;
+				cur_devmode.dmBitsPerPel == bpp &amp;&amp;
+				cur_devmode.dmDisplayFrequency &gt; devmode.dmDisplayFrequency)
+			{
+				devmode = cur_devmode;
+			}
+		}
+	}
+
+	// If the mode wasnt found, try anyway but without refresh mode info:
+	if (devmode.dmFields == 0)
+	{
+		devmode.dmSize = sizeof(DEVMODE);
+		devmode.dmPelsWidth = width;
+		devmode.dmPelsHeight = height;
+		devmode.dmBitsPerPel = bpp;
+		devmode.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;
+	}
+
+	saved_window_positions.clear();
+	//EnumWindows(&amp;CL_DisplayWindow_Win32::enum_windows_callback_save, (LPARAM) this);
+
+	LONG err = ChangeDisplaySettings(&amp;devmode, CDS_FULLSCREEN);
+
+	if (err != DISP_CHANGE_SUCCESSFUL)
+	{
+		switch (err)
+		{
+		case DISP_CHANGE_RESTART:
+			throw CL_Error(&quot;This OS sucks! It wants you to restart your computer to change to fullscreen!!!&quot;);
+
+		case DISP_CHANGE_FAILED:
+			throw CL_Error(&quot;The display driver failed the specified graphics mode.&quot;);
+
+		case DISP_CHANGE_BADMODE:
+			throw CL_Error(&quot;The graphics mode is not supported.&quot;);
+
+		default:
+			throw CL_Error(CL_String::format(&quot;Could not change videomode, error %1&quot;, (int)err));
+		}
+	}
+}
+
+void CL_DisplayWindow_Win32::restore_videomode()
+{
+	ChangeDisplaySettings(NULL, 0);
+	//EnumWindows(&amp;CL_DisplayWindow_Win32::enum_windows_callback_restore, (LPARAM) this);
+	saved_window_positions.clear();
+}
+
+BOOL CL_DisplayWindow_Win32::enum_windows_callback_save(HWND hwnd, LPARAM lParam)
+{
+	if (IsWindowVisible(hwnd) == FALSE) return TRUE;
+
+	CL_DisplayWindow_Win32 *self = (CL_DisplayWindow_Win32*) lParam;
+	WINDOWPLACEMENT placement;
+	memset(&amp;placement, 0, sizeof(WINDOWPLACEMENT));
+	placement.length = sizeof(WINDOWPLACEMENT);
+	GetWindowPlacement(hwnd, &amp;placement);
+	LONG wndprc = GetWindowLong(hwnd, GWL_WNDPROC);
+	self-&gt;saved_window_positions[hwnd] = std::pair&lt;LONG, WINDOWPLACEMENT&gt;(wndprc, placement);
+	return TRUE;
+}
+
+BOOL CL_DisplayWindow_Win32::enum_windows_callback_restore(HWND hwnd, LPARAM lParam)
+{
+	if (IsWindowVisible(hwnd) == FALSE) return TRUE;
+
+	CL_DisplayWindow_Win32 *self = (CL_DisplayWindow_Win32*) lParam;
+	if (self-&gt;saved_window_positions.find(hwnd) == self-&gt;saved_window_positions.end()) return TRUE;
+
+	LONG wndprc = GetWindowLong(hwnd, GWL_WNDPROC);
+	if (wndprc == self-&gt;saved_window_positions[hwnd].first)
+	{
+		SetWindowPlacement(hwnd, &amp;self-&gt;saved_window_positions[hwnd].second);
+	}
+	return TRUE;
+}
+
+void CL_DisplayWindow_Win32::received_keyboard_input(UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+	// Keep get_keycode() up-to-date.
+	GetKeyboardState(keys_down);
+
+	// Is message a down or up event?
+	bool keydown;
+	switch (uMsg)
+	{
+		case WM_KEYDOWN:
+		case WM_SYSKEYDOWN:
+			keydown = true;
+			break;
+		
+		case WM_KEYUP:
+		case WM_SYSKEYUP:
+			keydown = false;
+			break;
+
+		default:
+			return;
+	}
+
+//	int scancode = (lParam &amp; 0xff0000) &gt;&gt; 16;
+//	bool extended_key = (lParam &amp; 0x1000000) != 0;
+
+	// Update the ctrl/alt/shift hints:
+	int key_id = wParam;
+
+	// Ah fuckit. This platform appearently cant properly tell left from right unless you're
+	// polling. -- mbn 6. august 2002.
+	switch (key_id)
+	{
+	case VK_CONTROL: left_ctrl_down = keydown; right_ctrl_down = keydown; break;
+	case VK_MENU: left_alt_down = keydown; right_alt_down = keydown; break;
+	case VK_SHIFT: left_shift_down = keydown; right_shift_down = keydown; break;
+	}
+
+	// Add to repeat count
+	if(keydown)
+	{
+		if(key_id == previous_key_down)
+			repeat_count++;
+		previous_key_down = key_id;
+	}
+	else
+	{
+		repeat_count = 0;
+		previous_key_down = 0;
+	}
+
+	// Prepare event to be emitted:
+	CL_InputEvent key;
+	if (keydown)
+		key.type = CL_InputEvent::pressed;
+	else
+		key.type = CL_InputEvent::released;
+	key.mouse_pos = mouse_pos;
+	key.id = key_id;
+	key.device = keyboard;
+	key.repeat_count = repeat_count;
+
+	// Figure out what character sequence this maps to:
+	char buf[4];
+	int result = ToAscii(
+		(UINT) key_id,
+		MapVirtualKey((UINT) key_id, 0),
+		keys_down,
+		(LPWORD) buf,
+		0);
+	if (result == 1 || result == 2) key.str = std::string(buf, result);
+
+	// Emit message:
+	CL_InputDevice keyboard = get_ic()-&gt;get_keyboard();
+	if (keydown)
+		keyboard.sig_key_down()(key);
+	else
+		keyboard.sig_key_up()(key);
+}
+
+void CL_DisplayWindow_Win32::received_mouse_input(UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+	// Map windows events to something more interesting:
+	int id;
+	bool up = false;
+	bool down = false;
+	bool dbl = false;
+
+	switch (uMsg)
+	{
+	case WM_LBUTTONDOWN: id = 0; down = true; break;
+	case WM_LBUTTONUP: id = 0; up = true; break;
+	case WM_LBUTTONDBLCLK: id = 0; down = true; dbl = true; break;
+	case WM_RBUTTONDOWN: id = 1; down = true; break;
+	case WM_RBUTTONUP: id = 1; up = true; break;
+	case WM_RBUTTONDBLCLK: id = 1; down = true; break;
+	case WM_MBUTTONDOWN: id = 2; down = true; break;
+	case WM_MBUTTONUP: id = 2; up = true; break;
+	case WM_MBUTTONDBLCLK: id = 2; down = true; dbl = true; break;
+	case WM_MOUSEWHEEL: id = ((short)HIWORD(wParam) &gt; 0) ? 3 : 4; up = true; down = true; break;
+	case WM_XBUTTONDOWN: id = 4 + HIWORD(wParam); down = true; break;
+	case WM_XBUTTONUP: id = 4 + HIWORD(wParam); up = true; break;
+	case WM_XBUTTONDBLCLK: id = 4 + HIWORD(wParam); down = true; dbl = true; break;
+	default:
+		return;
+	}
+
+	// Prepare event to be emitted:
+	CL_InputEvent key;
+	key.mouse_pos = mouse_pos;
+	key.id = id;
+	key.device = mouse;
+
+	CL_InputDevice mouse = get_ic()-&gt;get_mouse();
+
+	// Emit message:
+	if (down)
+	{
+		key.type = CL_InputEvent::pressed;
+		if (dbl)
+		{
+			key.repeat_count = 2;
+			mouse.sig_key_dblclk()(key);
+		}
+		else
+		{
+			mouse.sig_key_down()(key);
+		}
+	}
+
+	if (up)
+	{
+		key.type = CL_InputEvent::released;
+		mouse.sig_key_up()(key);
+	}
+}
+
+void CL_DisplayWindow_Win32::received_mouse_move(UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+	// Fetch coordinates
+	int x = LOWORD(lParam);
+	int y = HIWORD(lParam);
+
+	if(mouse_pos.x != x || mouse_pos.y != y)
+	{
+		mouse_pos.x = x;
+		mouse_pos.y = y;
+
+		// Prepare event to be emitted:
+		CL_InputEvent key;
+		key.type = CL_InputEvent::moved;
+		key.device = mouse;
+		key.mouse_pos = mouse_pos;
+
+		// Fire off signal
+		CL_InputDevice mouse = get_ic()-&gt;get_mouse();
+		mouse.sig_move()(key);
+	}
+}

Added: trunk/clanlib/Display/Win32/display_window_win32.h
===================================================================
--- trunk/clanlib/Display/Win32/display_window_win32.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Win32/display_window_win32.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,189 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_display_window_win32
+#define header_display_window_win32
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;Display/display_window_generic.h&quot;
+#include &quot;API/Core/Math/rect.h&quot;
+#include &quot;API/Display/input_context.h&quot;
+#include &quot;API/Display/input_device.h&quot;
+#include &lt;map&gt;
+
+#include &lt;dinput.h&gt;
+
+#if DIRECTINPUT_HEADER_VERSION &lt; 0x0800
+#error Found DirectX headers older than 8.0. Please download a newer directx, and make sure its FIRST in the include path and library path (Tools-&gt;Options-&gt;Directories in MSVC).
+#endif
+
+class CL_API_DISPLAY CL_DisplayWindow_Win32 : public CL_DisplayWindow_Generic
+{
+//! Construction:
+public:
+	CL_DisplayWindow_Win32();
+
+	virtual ~CL_DisplayWindow_Win32();
+
+//! Attributes:
+public:
+	virtual int get_width() const;
+
+	virtual int get_height() const;
+
+	virtual bool is_fullscreen() const;
+
+	virtual bool has_focus() const;
+
+	virtual int get_buffer_count() const;
+
+	virtual bool get_keycode(int keycode) const;
+
+	HWND get_hwnd() { return hwnd; }
+
+	virtual CL_InputContext *get_ic() { return &amp;input_context; }
+
+	const CL_Rect &amp;get_layer_position() const { return layered_position; }
+
+	LPDIRECTINPUT8 get_directinput() const { return directinput; }
+
+	CL_Point mouse_pos;
+
+	bool left_ctrl_down, left_alt_down, left_shift_down;
+
+	bool right_ctrl_down, right_alt_down, right_shift_down;
+
+//! Operations:
+public:
+	virtual void set_fullscreen(int width, int height, int bpp, int refresh_rate);
+
+	virtual void set_windowed();
+
+	virtual void set_title(const std::string &amp;title);
+
+	virtual void set_position(const CL_Rect &amp;pos);
+
+	virtual void set_position(int x, int y);
+
+	virtual void set_size(int width, int height);
+
+	virtual void set_buffer_count(int flipping_buffers);
+
+	virtual void update(const CL_Rect &amp;rect);
+
+	virtual void flip(int interval);
+
+	virtual void create_window(const CL_DisplayWindowDescription &amp;desc);
+
+	virtual void destroy_window();
+
+	virtual void show_system_cursor();
+
+	virtual void hide_system_cursor();
+
+	void set_videomode(int width, int height, int bpp, int refresh_rate);
+
+	void restore_videomode();
+
+	virtual bool received_event(UINT uMsg, WPARAM wParam, LPARAM lParam);
+
+//! Implementation:
+private:
+	//: Creates the initial window based on the window description.
+	void create_new_window(const CL_DisplayWindowDescription &amp;desc);
+
+	//: Updates the already created window to new window description.
+	void modify_window(const CL_DisplayWindowDescription &amp;desc);
+
+	static BOOL CALLBACK enum_windows_callback_save(HWND hwnd, LPARAM lParam);
+
+	static BOOL CALLBACK enum_windows_callback_restore(HWND hwnd, LPARAM lParam);
+
+	static BOOL CALLBACK enum_devices_callback(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef);
+
+	void received_keyboard_input(UINT uMsg, WPARAM wParam, LPARAM lParam);
+
+	void received_mouse_input(UINT uMsg, WPARAM wParam, LPARAM lParam);
+
+	void received_mouse_move(UINT uMsg, WPARAM wParam, LPARAM lParam);
+
+	static std::map&lt;HWND, CL_DisplayWindow_Win32 *&gt; window_map;
+
+	static LONG WINAPI message_handler(
+		HWND hWnd,
+		UINT uMsg,
+		WPARAM wParam,
+		LPARAM lParam);
+
+	CL_InputContext input_context;
+
+	CL_InputDevice keyboard;
+
+	CL_InputDevice mouse;
+
+	HWND hwnd;
+
+	std::string title;
+
+	bool fullscreen;
+
+	bool allow_resize;
+
+	bool layered;
+
+	CL_Rect layered_position;
+
+	int bpp;
+
+	unsigned char keys_down[256];
+
+	int previous_key_down;
+	int repeat_count;
+
+	CL_Rect saved_position;
+
+	LPDIRECTINPUT8 directinput;
+
+	std::map&lt; HWND, std::pair&lt;LONG, WINDOWPLACEMENT&gt; &gt; saved_window_positions;
+};
+
+#endif

Added: trunk/clanlib/Display/Win32/input_device_directinput.cpp
===================================================================
--- trunk/clanlib/Display/Win32/input_device_directinput.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Win32/input_device_directinput.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,625 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/input_event.h&quot;
+#include &quot;input_device_directinput.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/System/log.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_DirectInput construction:
+
+CL_InputDevice_DirectInput::CL_InputDevice_DirectInput(
+	CL_DisplayWindow_Win32 *window,
+	LPCDIDEVICEINSTANCE ptr_device_instance)
+	: window(window), device_instance(*ptr_device_instance), directinput_device(0)
+{
+	HRESULT result = window-&gt;get_directinput()-&gt;CreateDevice(
+		device_instance.guidInstance,
+		&amp;directinput_device,
+		0);
+
+	if (FAILED(result))
+	{
+		throw CL_Error(
+			CL_String::format(
+				&quot;Unable to open device %1 (%2)&quot;,
+				device_instance.tszInstanceName,
+				device_instance.tszProductName));
+	}
+
+	result = directinput_device-&gt;SetCooperativeLevel(window-&gt;get_hwnd(), DISCL_FOREGROUND|DISCL_NONEXCLUSIVE);
+	if (FAILED(result))
+	{
+		directinput_device-&gt;Release();
+
+		throw CL_Error(
+			CL_String::format(
+				&quot;Unable to the set cooperative level for %1 (%2)&quot;,
+				device_instance.tszInstanceName,
+				device_instance.tszProductName));
+	}
+
+	result = directinput_device-&gt;SetDataFormat(&amp;c_dfDIJoystick2);
+	if (FAILED(result))
+	{
+		directinput_device-&gt;Release();
+
+		throw CL_Error(
+			CL_String::format(
+				&quot;Unable to set device dataformat for %1 (%2)&quot;,
+				device_instance.tszInstanceName,
+				device_instance.tszProductName));
+	}
+
+	// Enable buffering of input events:
+	DIPROPDWORD value;
+	memset(&amp;value, 0, sizeof(DIPROPDWORD));
+	value.diph.dwSize = sizeof(DIPROPDWORD);
+	value.diph.dwHeaderSize = sizeof(DIPROPHEADER);
+	value.diph.dwObj = 0;
+	value.diph.dwHow = DIPH_DEVICE;
+	value.dwData = 128;
+	result = directinput_device-&gt;SetProperty(DIPROP_BUFFERSIZE, &amp;value.diph);
+	if (FAILED(result))
+	{
+		directinput_device-&gt;Release();
+
+		throw CL_Error(
+			CL_String::format(
+				&quot;Unable to set buffer size attribute on device %1 (%2)&quot;,
+				device_instance.tszInstanceName,
+				device_instance.tszProductName));
+	}
+
+	result = directinput_device-&gt;Acquire();
+	if (FAILED(result))
+	{
+		directinput_device-&gt;Release();
+
+		throw CL_Error(
+			CL_String::format(
+				&quot;Unable to acquire device %1 (%2)&quot;,
+				device_instance.tszInstanceName,
+				device_instance.tszProductName));
+	}
+}
+
+CL_InputDevice_DirectInput::~CL_InputDevice_DirectInput()
+{
+	if (directinput_device) directinput_device-&gt;Release();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_DirectInput attributes:
+
+int CL_InputDevice_DirectInput::get_x() const
+{
+	return 0;
+}
+
+int CL_InputDevice_DirectInput::get_y() const
+{
+	return 0;
+}
+
+bool CL_InputDevice_DirectInput::get_keycode(int keycode) const
+{
+	if (keycode &lt; 0 || keycode &gt;= 128) return false;
+
+	DIJOYSTATE2 joystate2;
+	HRESULT result = directinput_device-&gt;GetDeviceState(sizeof(DIJOYSTATE2), &amp;joystate2);
+	if (FAILED(result)) return false;
+
+	return LOBYTE(joystate2.rgbButtons[keycode]) != 0;
+}
+
+std::string CL_InputDevice_DirectInput::get_key_name(int id) const
+{
+	return CL_String::format(&quot;Joystick button %1&quot;, id);
+}
+
+float CL_InputDevice_DirectInput::get_axis(int index) const
+{
+	DIJOYSTATE2 joystate2;
+	HRESULT result = directinput_device-&gt;GetDeviceState(sizeof(DIJOYSTATE2), &amp;joystate2);
+	if (FAILED(result)) return 0;
+
+	switch (index)
+	{
+	case 0:
+		return float(joystate2.lX)/(0xffff/2)-1.0f;
+
+	case 1:
+		return float(joystate2.lY)/(0xffff/2)-1.0f;
+
+	case 2:
+		return float(joystate2.lZ)/(0xffff/2)-1.0f;
+
+	case 3:
+		return float(joystate2.lRx)/(0xffff/2)-1.0f;
+
+	case 4:
+		return float(joystate2.lRy)/(0xffff/2)-1.0f;
+
+	case 5:
+		return float(joystate2.lRz)/(0xffff/2)-1.0f;
+
+	case 6:
+		return float(joystate2.rglSlider[0])/(0xffff/2)-1.0f;
+
+	case 7:
+		return float(joystate2.rglSlider[1])/(0xffff/2)-1.0f;
+
+	case 8:
+		return float(joystate2.lVX)/(0xffff/2)-1.0f;
+
+	case 9:
+		return float(joystate2.lVY)/(0xffff/2)-1.0f;
+
+	case 10:
+		return float(joystate2.lVZ)/(0xffff/2)-1.0f;
+
+	case 11:
+		return float(joystate2.lVRx)/(0xffff/2)-1.0f;
+
+	case 12:
+		return float(joystate2.lVRy)/(0xffff/2)-1.0f;
+
+	case 13:
+		return float(joystate2.lVRz)/(0xffff/2)-1.0f;
+
+	case 14:
+		return float(joystate2.rglVSlider[0])/(0xffff/2)-1.0f;
+
+	case 15:
+		return float(joystate2.rglVSlider[1])/(0xffff/2)-1.0f;
+
+	case 16:
+		return float(joystate2.lAX)/(0xffff/2)-1.0f;
+
+	case 17:
+		return float(joystate2.lAY)/(0xffff/2)-1.0f;
+
+	case 18:
+		return float(joystate2.lAZ)/(0xffff/2)-1.0f;
+
+	case 19:
+		return float(joystate2.lARx)/(0xffff/2)-1.0f;
+
+	case 20:
+		return float(joystate2.lARy)/(0xffff/2)-1.0f;
+
+	case 21:
+		return float(joystate2.lARz)/(0xffff/2)-1.0f;
+
+	case 22:
+		return float(joystate2.rglASlider[0])/(0xffff/2)-1.0f;
+
+	case 23:
+		return float(joystate2.rglASlider[1])/(0xffff/2)-1.0f;
+
+	case 24:
+		return float(joystate2.lFX)/(0xffff/2)-1.0f;
+
+	case 25:
+		return float(joystate2.lFY)/(0xffff/2)-1.0f;
+
+	case 26:
+		return float(joystate2.lFZ)/(0xffff/2)-1.0f;
+
+	case 27:
+		return float(joystate2.lFRx)/(0xffff/2)-1.0f;
+
+	case 28:
+		return float(joystate2.lFRy)/(0xffff/2)-1.0f;
+
+	case 29:
+		return float(joystate2.lFRz)/(0xffff/2)-1.0f;
+
+	case 30:
+		return float(joystate2.rglFSlider[0])/(0xffff/2)-1.0f;
+
+	case 31:
+		return float(joystate2.rglFSlider[1])/(0xffff/2)-1.0f;
+
+	case 32:
+		return float(joystate2.rgdwPOV[0]);
+
+	case 33:
+		return float(joystate2.rgdwPOV[1]);
+
+	case 34:
+		return float(joystate2.rgdwPOV[2]);
+
+	case 35:
+		return float(joystate2.rgdwPOV[3]);
+	}
+
+	return 0.0f;
+}
+
+std::string CL_InputDevice_DirectInput::get_name() const
+{
+	return device_instance.tszInstanceName;
+}
+
+int CL_InputDevice_DirectInput::get_axis_count() const
+{
+	return 36;
+}
+
+int CL_InputDevice_DirectInput::get_button_count() const
+{
+	return -1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_DirectInput operations:
+
+void CL_InputDevice_DirectInput::set_position(int x, int y)
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_DirectInput implementation:
+
+void CL_InputDevice_DirectInput::keep_alive()
+{
+	directinput_device-&gt;Poll();
+
+	// Get events:
+	while (true)
+	{
+		DIDEVICEOBJECTDATA buffer[16];
+		DWORD num_events = 16;
+
+		HRESULT result = directinput_device-&gt;GetDeviceData(
+			sizeof(DIDEVICEOBJECTDATA),
+			buffer,
+			&amp;num_events,
+			0);
+
+		// Try to reacquire joystick if we lost it.
+		if (result == DIERR_INPUTLOST || result == DIERR_NOTACQUIRED) directinput_device-&gt;Acquire();
+
+		if (FAILED(result) &amp;&amp; result != DI_BUFFEROVERFLOW) break;
+		if (num_events == 0) break;
+
+		// Ok here follows the decoding of events.
+		//
+		// Imagine that. Microsoft managed to make something even more ugly than the MAPI API and
+		// the older Direct3D APIs. Didn't think that was possible.
+		//
+		// Microsoft monkey #1: &quot;I got this cool idea. We simply just do a memcpy from the driver
+		// to the directinput application and returns offsets into the struct that changed&quot;
+		//
+		// Microsoft monkey #2: &quot;Aw cool man. That's like.. even better than the MAPI API I did back
+		// in 1994.. Brilliant&quot;
+		//
+		// Monkey #1 and #2 laughs evilly
+
+		for (unsigned int i=0; i&lt;num_events; i++)
+		{
+			CL_InputEvent event;
+			event.device = CL_InputDevice(this);
+			event.mouse_pos = window-&gt;mouse_pos;
+			event.repeat_count = 0;
+
+			if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, lX))
+			{
+				// X Axis position event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 0;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, lY))
+			{
+				// Y Axis position event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 1;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, lZ))
+			{
+				// Z Axis position event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 2;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, rglSlider[0]))
+			{
+				// extra 1 axis position event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 3;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, rglSlider[1]))
+			{
+				// extra 2 axis position event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 4;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs &gt;= FIELD_OFFSET(DIJOYSTATE2, rgbButtons) &amp;&amp; buffer[i].dwOfs &lt; FIELD_OFFSET(DIJOYSTATE2, rgbButtons)+128)
+			{
+				// Button event
+				int button_index = buffer[i].dwOfs - FIELD_OFFSET(DIJOYSTATE2, rgbButtons);
+				event.id = button_index;
+
+				if (LOBYTE(buffer[i].dwData)) // If high bit of lower byte is set, key is down
+				{
+					event.type = CL_InputEvent::pressed;
+					sig_key_down.call(event);
+				}
+				else
+				{
+					event.type = CL_InputEvent::released;
+					sig_key_up.call(event);
+				}
+			}
+			else if (buffer[i].dwOfs &gt;= FIELD_OFFSET(DIJOYSTATE2, rgdwPOV) &amp;&amp; buffer[i].dwOfs &lt; FIELD_OFFSET(DIJOYSTATE2, rgdwPOV)+4*sizeof(DWORD))
+			{
+				// Hat event:
+				int hat_index = (buffer[i].dwOfs - FIELD_OFFSET(DIJOYSTATE2, rgdwPOV)) / sizeof(DWORD);
+				bool centered = (LOWORD(buffer[i].dwData) == 0xFFFF);
+				int direction = buffer[i].dwData / DI_DEGREES;
+				if (centered) direction = -1;
+
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 32 + hat_index;
+				event.axis_pos = float(direction);
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, lRx))
+			{
+				// X Axis rotation event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 5;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, lRy))
+			{
+				// Y Axis rotation event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 6;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, lRz))
+			{
+				// Z Axis rotation event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 7;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, lVX))
+			{
+				// X Axis velocity event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 8;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, lVY))
+			{
+				// Y Axis velocity event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 9;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, lVZ))
+			{
+				// Z Axis velocity event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 10;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, lVRx))
+			{
+				// X Axis angular velocity event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 11;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, lVRy))
+			{
+				// Y Axis angular velocity event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 12;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, lVRz))
+			{
+				// Z Axis angular velocity event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 13;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, rglVSlider[0]))
+			{
+				// extra 1 axis velocity event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 14;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, rglVSlider[1]))
+			{
+				// extra 2 axis velocity event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 15;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, lAX))
+			{
+				// X Axis acceleration event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 16;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, lAY))
+			{
+				// Y Axis acceleration event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 17;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, lAZ))
+			{
+				// Z Axis acceleration event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 18;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, lARx))
+			{
+				// X Axis angular acceleration event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 19;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, lARy))
+			{
+				// Y Axis angular acceleration event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 20;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, lARz))
+			{
+				// Z Axis angular acceleration event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 21;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, rglASlider[0]))
+			{
+				// extra 1 axis acceleration event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 22;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, rglASlider[1]))
+			{
+				// extra 2 axis acceleration event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 23;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, lFX))
+			{
+				// X Axis force event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 24;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, lFY))
+			{
+				// Y Axis force event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 25;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, lFZ))
+			{
+				// Z Axis force event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 26;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, lFRx))
+			{
+				// X Axis torque event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 27;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, lFRy))
+			{
+				// Y Axis torque event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 28;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, lFRz))
+			{
+				// Z Axis torque event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 29;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, rglFSlider[0]))
+			{
+				// extra 1 axis force event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 30;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+			else if (buffer[i].dwOfs == FIELD_OFFSET(DIJOYSTATE2, rglFSlider[1]))
+			{
+				// extra 2 axis force event
+				event.type = CL_InputEvent::axis_moved;
+				event.id = 31;
+				event.axis_pos = float(buffer[i].dwData)/(0xffff/2)-1.0f;
+				sig_axis_move.call(event);
+			}
+		}
+	}
+}

Added: trunk/clanlib/Display/Win32/input_device_directinput.h
===================================================================
--- trunk/clanlib/Display/Win32/input_device_directinput.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Win32/input_device_directinput.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,92 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_input_device_directinput
+#define header_input_device_directinput
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../input_device_generic.h&quot;
+#include &quot;display_window_win32.h&quot;
+#include &quot;API/Core/System/keep_alive.h&quot;
+
+class CL_InputDevice_DirectInput : public CL_InputDevice_Generic, public CL_KeepAlive
+{
+//! Construction:
+public:
+	CL_InputDevice_DirectInput(CL_DisplayWindow_Win32 *window, LPCDIDEVICEINSTANCE device_instance);
+
+	virtual ~CL_InputDevice_DirectInput();
+
+//! Attributes:
+public:
+	//: Returns the x position of the device.
+	virtual int get_x() const;
+
+	//: Returns the y position of the device.
+	virtual int get_y() const;
+
+	//: Returns true if the passed key code is down for this device.
+	virtual bool get_keycode(int keycode) const;
+
+	//: Key name for specified identifier (A, B, C, Space, Enter, Backspace).
+	virtual std::string get_key_name(int id) const;
+
+	//: Returns the the current position of a joystick axis.
+	virtual float get_axis(int index) const;
+
+	//: Returns the name of the device (i.e. 'Microsoft Sidewinder 3D').
+	virtual std::string get_name() const;
+
+	//: Returns the number of axes available on this device.
+	virtual int get_axis_count() const;
+
+	//: Returns the number of buttons available on this device.
+	//- &lt;p&gt;If used on a keyboard, this function returns -1.&lt;/p&gt;
+	virtual int get_button_count() const;
+
+//! Operations:
+public:
+	//: Sets the position of the device.
+	virtual void set_position(int x, int y);
+
+//! Implementation:
+private:
+	virtual void keep_alive();
+
+	CL_DisplayWindow_Win32 *window;
+
+	DIDEVICEINSTANCE device_instance;
+
+	LPDIRECTINPUTDEVICE8 directinput_device;
+};
+
+#endif

Added: trunk/clanlib/Display/Win32/input_device_win32keyboard.cpp
===================================================================
--- trunk/clanlib/Display/Win32/input_device_win32keyboard.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Win32/input_device_win32keyboard.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,91 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &lt;windows.h&gt;
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;input_device_win32keyboard.h&quot;
+#include &quot;display_window_win32.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_Win32Keyboard construction:
+
+CL_InputDevice_Win32Keyboard::CL_InputDevice_Win32Keyboard(CL_DisplayWindow_Win32 *window) : window(window)
+{
+	type = CL_InputDevice::keyboard;
+}
+
+CL_InputDevice_Win32Keyboard::~CL_InputDevice_Win32Keyboard()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_Win32Keyboard attributes:
+
+bool CL_InputDevice_Win32Keyboard::get_keycode(int keycode) const
+{
+	// Ignore all key events when we don't have focus
+	if (!window-&gt;has_focus())
+		return false;
+
+	return (GetKeyState(keycode) &amp; 0xfe) != 0;
+}
+
+std::string CL_InputDevice_Win32Keyboard::get_key_name(int virtual_key) const
+{
+	char name[1024];
+	UINT scancode = MapVirtualKey(virtual_key, 0);
+	int length = GetKeyNameText(scancode &lt;&lt; 16, name, 1024);
+	return std::string(name, length);
+}
+
+float CL_InputDevice_Win32Keyboard::get_axis(int index) const
+{
+	return 0.0f;
+}
+
+std::string CL_InputDevice_Win32Keyboard::get_name() const
+{
+	return &quot;System Keyboard&quot;;
+}
+
+int CL_InputDevice_Win32Keyboard::get_axis_count() const
+{
+	return 0;
+}
+
+int CL_InputDevice_Win32Keyboard::get_button_count() const
+{
+	return -1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_Win32Keyboard operations:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_Win32Keyboard implementation:

Added: trunk/clanlib/Display/Win32/input_device_win32keyboard.h
===================================================================
--- trunk/clanlib/Display/Win32/input_device_win32keyboard.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Win32/input_device_win32keyboard.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,78 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_input_device_win32keyboard
+#define header_input_device_win32keyboard
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../input_device_generic.h&quot;
+
+class CL_DisplayWindow_Win32;
+
+class CL_InputDevice_Win32Keyboard : public CL_InputDevice_Generic
+{
+//! Construction:
+public:
+	CL_InputDevice_Win32Keyboard(CL_DisplayWindow_Win32 *window);
+
+	virtual ~CL_InputDevice_Win32Keyboard();
+
+//! Attributes:
+public:
+	//: Returns true if the passed key code is down for this device.
+	virtual bool get_keycode(int keycode) const;
+
+	//: Key name for specified identifier (A, B, C, Space, Enter, Backspace).
+	virtual std::string get_key_name(int id) const;
+
+	//: Returns the the current position of a joystick axis.
+	virtual float get_axis(int index) const;
+
+	//: Returns the name of the device (i.e. 'Microsoft Sidewinder 3D').
+	virtual std::string get_name() const;
+
+	//: Returns the number of axes available on this device.
+	virtual int get_axis_count() const;
+
+	//: Returns the number of buttons available on this device.
+	//- &lt;p&gt;If used on a keyboard, this function returns -1.&lt;/p&gt;
+	virtual int get_button_count() const;
+
+//! Operations:
+public:
+
+//! Implementation:
+private:
+	CL_DisplayWindow_Win32 *window;
+};
+
+#endif

Added: trunk/clanlib/Display/Win32/input_device_win32mouse.cpp
===================================================================
--- trunk/clanlib/Display/Win32/input_device_win32mouse.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Win32/input_device_win32mouse.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,141 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/input_event.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;input_device_win32mouse.h&quot;
+#include &quot;display_window_win32.h&quot;
+#include &lt;stdio.h&gt;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_Win32Mouse construction:
+
+CL_InputDevice_Win32Mouse::CL_InputDevice_Win32Mouse(CL_DisplayWindow_Win32 *window) : window(window)
+{
+	type = CL_InputDevice::mouse;
+	for (int i=0; i&lt;32; i++) key_states[i] = false;
+	slots.connect(sig_key_down, this, &amp;CL_InputDevice_Win32Mouse::on_key_down);
+	slots.connect(sig_key_up, this, &amp;CL_InputDevice_Win32Mouse::on_key_up);
+}
+
+CL_InputDevice_Win32Mouse::~CL_InputDevice_Win32Mouse()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_Win32Mouse attributes:
+
+int CL_InputDevice_Win32Mouse::get_x() const
+{
+	POINT cursor_pos;
+	GetCursorPos(&amp;cursor_pos);
+
+	BOOL res = ScreenToClient(window-&gt;get_hwnd(), &amp;cursor_pos);
+	if (res == FALSE) return 0;
+
+	return cursor_pos.x;
+}
+
+int CL_InputDevice_Win32Mouse::get_y() const
+{
+	POINT cursor_pos;
+	GetCursorPos(&amp;cursor_pos);
+
+	BOOL res = ScreenToClient(window-&gt;get_hwnd(), &amp;cursor_pos);
+	if (res == FALSE) return 0;
+
+	return cursor_pos.y;
+}
+
+bool CL_InputDevice_Win32Mouse::get_keycode(int keycode) const
+{
+	if (keycode &lt; 0 || keycode &gt;= 32) return false;
+	return key_states[keycode];
+}
+
+std::string CL_InputDevice_Win32Mouse::get_key_name(int id) const
+{
+	switch (id)
+	{
+	case 0: return &quot;Mouse left&quot;;
+	case 1: return &quot;Mouse right&quot;;
+	case 2: return &quot;Mouse middle&quot;;
+	case 3: return &quot;Mouse wheel up&quot;;
+	case 4: return &quot;Mouse wheel down&quot;;
+	}
+
+	return CL_String::format(&quot;Mouse button %1&quot;, id);
+}
+
+float CL_InputDevice_Win32Mouse::get_axis(int index) const
+{
+	return 0.0f;
+}
+
+std::string CL_InputDevice_Win32Mouse::get_name() const
+{
+	return &quot;System Mouse&quot;;
+}
+
+int CL_InputDevice_Win32Mouse::get_axis_count() const
+{
+	return 0;
+}
+
+int CL_InputDevice_Win32Mouse::get_button_count() const
+{
+	return -1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_Win32Mouse operations:
+
+void CL_InputDevice_Win32Mouse::set_position(int x, int y)
+{
+	POINT pt;
+	pt.x = x;
+	pt.y = y;
+	
+	ClientToScreen(window-&gt;get_hwnd(), &amp;pt);
+	SetCursorPos(pt.x, pt.y);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_Win32Mouse implementation:
+
+void CL_InputDevice_Win32Mouse::on_key_down(const CL_InputEvent &amp;event)
+{
+	key_states[event.id] = true;
+}
+
+void CL_InputDevice_Win32Mouse::on_key_up(const CL_InputEvent &amp;event)
+{
+	key_states[event.id] = false;
+}

Added: trunk/clanlib/Display/Win32/input_device_win32mouse.h
===================================================================
--- trunk/clanlib/Display/Win32/input_device_win32mouse.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/Win32/input_device_win32mouse.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,94 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_input_device_win32mouse
+#define header_input_device_win32mouse
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../input_device_generic.h&quot;
+
+class CL_DisplayWindow_Win32;
+
+class CL_InputDevice_Win32Mouse : public CL_InputDevice_Generic
+{
+//! Construction:
+public:
+	CL_InputDevice_Win32Mouse(CL_DisplayWindow_Win32 *window);
+
+	virtual ~CL_InputDevice_Win32Mouse();
+
+//! Attributes:
+public:
+	//: Returns the x position of the device.
+	virtual int get_x() const;
+
+	//: Returns the y position of the device.
+	virtual int get_y() const;
+
+	//: Returns true if the passed key code is down for this device.
+	virtual bool get_keycode(int keycode) const;
+
+	//: Key name for specified identifier (A, B, C, Space, Enter, Backspace).
+	virtual std::string get_key_name(int id) const;
+
+	//: Returns the the current position of a joystick axis.
+	virtual float get_axis(int index) const;
+
+	//: Returns the name of the device (i.e. 'Microsoft Sidewinder 3D').
+	virtual std::string get_name() const;
+
+	//: Returns the number of axes available on this device.
+	virtual int get_axis_count() const;
+
+	//: Returns the number of buttons available on this device.
+	//- &lt;p&gt;If used on a keyboard, this function returns -1.&lt;/p&gt;
+	virtual int get_button_count() const;
+
+//! Operations:
+public:
+	//: Sets the position of the device.
+	virtual void set_position(int x, int y);
+
+//! Implementation:
+private:
+	void on_key_down(const CL_InputEvent &amp;event);
+
+	void on_key_up(const CL_InputEvent &amp;event);
+
+	bool key_states[32];
+	
+	CL_DisplayWindow_Win32 *window;
+
+	CL_SlotContainer slots;
+};
+
+#endif

Added: trunk/clanlib/Display/canvas.cpp
===================================================================
--- trunk/clanlib/Display/canvas.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/canvas.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,119 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/canvas.h&quot;
+#include &quot;canvas_generic.h&quot;
+#include &quot;display_target.h&quot;
+#include &quot;API/Display/pixel_buffer.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Canvas construction:
+
+CL_Canvas::CL_Canvas() : impl(CL_DisplayTarget::current()-&gt;create_canvas())
+{
+}
+
+CL_Canvas::CL_Canvas(const CL_Surface &amp;initial_active_surface) : impl(CL_DisplayTarget::current()-&gt;create_canvas())
+{
+	impl-&gt;select_surface(initial_active_surface.impl);
+}
+
+CL_Canvas::CL_Canvas(const CL_Canvas &amp;copy) : impl(copy.impl)
+{
+}
+
+CL_Canvas::~CL_Canvas()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Canvas attributes:
+
+CL_GraphicContext *CL_Canvas::get_gc()
+{
+	return impl-&gt;get_gc();
+}
+
+CL_PixelBuffer CL_Canvas::get_pixeldata()
+{
+	return impl-&gt;get_pixeldata(CL_Rect(0, 0, get_width(), get_height()));
+}
+
+CL_PixelBuffer CL_Canvas::get_pixeldata(const CL_Rect &amp;area)
+{
+	return impl-&gt;get_pixeldata(area);
+}
+
+int CL_Canvas::get_width() const
+{
+	return impl-&gt;get_width();
+}
+
+int CL_Canvas::get_height() const
+{
+	return impl-&gt;get_height();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Canvas operations:
+
+CL_Canvas &amp;CL_Canvas::operator =(const CL_Canvas &amp;copy)
+{
+	impl = copy.impl;
+	return *this;
+}
+
+void CL_Canvas::set_pixeldata(const CL_PixelBuffer &amp;data)
+{
+	impl-&gt;set_pixeldata(CL_Point(0,0), CL_Rect(0, 0, data.get_width(), data.get_height()), data);
+}
+
+void CL_Canvas::set_pixeldata(const CL_Point &amp;dest, const CL_PixelBuffer &amp;data)
+{
+	impl-&gt;set_pixeldata(dest, CL_Rect(0, 0, data.get_width(), data.get_height()), data);
+}
+
+void CL_Canvas::set_pixeldata(const CL_Point &amp;dest, const CL_Rect &amp;src, const CL_PixelBuffer &amp;data)
+{
+	impl-&gt;set_pixeldata(dest, src, data);
+}
+
+void CL_Canvas::select_surface(CL_Surface &amp;surface)
+{
+	impl-&gt;select_surface(surface.impl);
+}
+
+void CL_Canvas::sync_surface()
+{
+	impl-&gt;sync_surface();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Canvas implementation:

Added: trunk/clanlib/Display/canvas_generic.h
===================================================================
--- trunk/clanlib/Display/canvas_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/canvas_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,76 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_canvas_generic
+#define header_canvas_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Display/canvas.h&quot;
+
+class CL_Surface_Generic;
+
+class CL_Canvas_Generic
+{
+//! Construction:
+public:
+	CL_Canvas_Generic() : ref_count(0) { return; }
+
+	virtual ~CL_Canvas_Generic() { return; }
+
+//! Attributes:
+public:
+	virtual CL_GraphicContext *get_gc() = 0;
+
+	virtual CL_PixelBuffer get_pixeldata(const CL_Rect &amp;area) = 0;
+
+	virtual int get_width() const = 0;
+	
+	virtual int get_height() const = 0;
+	
+//! Operations:
+public:
+	void add_ref() { ref_count++; }
+
+	void release_ref() { ref_count--; if (ref_count == 0) delete this; }
+
+	virtual void set_pixeldata(const CL_Point &amp;dest, const CL_Rect &amp;src, const CL_PixelBuffer &amp;data) = 0;
+
+	virtual void select_surface(CL_Surface_Generic *surface) = 0;
+	
+	virtual void sync_surface() = 0;
+
+//! Implementation:
+private:
+	int ref_count;
+};
+
+#endif

Added: trunk/clanlib/Display/color.cpp
===================================================================
--- trunk/clanlib/Display/color.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/color.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,575 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/color.h&quot;
+#include &quot;API/Display/pixel_format.h&quot;
+#include &lt;map&gt;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Color operations:
+
+CL_Color::CL_Color(const CL_Colorf&amp; color)
+	: color((static_cast&lt;unsigned int&gt;(color.alpha   * 255) &lt;&lt; 24)
+			  | (static_cast&lt;unsigned int&gt;(color.red   * 255) &lt;&lt; 16) 
+			  | (static_cast&lt;unsigned int&gt;(color.green * 255) &lt;&lt; 8) 
+			  | (static_cast&lt;unsigned int&gt;(color.blue  * 255)))
+{
+}
+
+CL_Color CL_Color::from_pixelformat(unsigned int raw_color, const CL_PixelFormat &amp;pf)
+{
+	const int in_r_shift = CL_PixelFormat::get_mask_shift(pf.get_red_mask());
+	const int in_g_shift = CL_PixelFormat::get_mask_shift(pf.get_green_mask());
+	const int in_b_shift = CL_PixelFormat::get_mask_shift(pf.get_blue_mask());
+	const int in_a_shift = CL_PixelFormat::get_mask_shift(pf.get_alpha_mask());
+
+	const int in_r_bits = CL_PixelFormat::get_mask_bits(pf.get_red_mask());
+	const int in_g_bits = CL_PixelFormat::get_mask_bits(pf.get_green_mask());
+	const int in_b_bits = CL_PixelFormat::get_mask_bits(pf.get_blue_mask());
+	const int in_a_bits = CL_PixelFormat::get_mask_bits(pf.get_alpha_mask());
+
+	const int in_r_bitmask = CL_PixelFormat::get_bitmask(in_r_bits, 0);
+	const int in_g_bitmask = CL_PixelFormat::get_bitmask(in_g_bits, 0);
+	const int in_b_bitmask = CL_PixelFormat::get_bitmask(in_b_bits, 0);
+	const int in_a_bitmask = CL_PixelFormat::get_bitmask(in_a_bits, 0);
+
+	unsigned int in_r = 0, in_g = 0, in_b = 0, in_a = 0xff;
+	if (in_r_bitmask)
+		in_r = ((raw_color &gt;&gt; in_r_shift) &amp; in_r_bitmask) &lt;&lt; (8 - in_r_bits);
+	if (in_g_bitmask)
+		in_g = ((raw_color &gt;&gt; in_g_shift) &amp; in_g_bitmask) &lt;&lt; (8 - in_g_bits);
+	if (in_b_bitmask)
+		in_b = ((raw_color &gt;&gt; in_b_shift) &amp; in_b_bitmask) &lt;&lt; (8 - in_b_bits);
+	if (in_a_bitmask)
+		in_a = ((raw_color &gt;&gt; in_a_shift) &amp; in_a_bitmask) &lt;&lt; (8 - in_a_bits);
+
+	return CL_Color(in_r, in_g, in_b, in_a);
+}
+
+unsigned int CL_Color::to_pixelformat(const CL_PixelFormat &amp;pf) const
+{
+	const int out_r_shift = CL_PixelFormat::get_mask_shift(pf.get_red_mask());
+	const int out_g_shift = CL_PixelFormat::get_mask_shift(pf.get_green_mask());
+	const int out_b_shift = CL_PixelFormat::get_mask_shift(pf.get_blue_mask());
+	const int out_a_shift = CL_PixelFormat::get_mask_shift(pf.get_alpha_mask());
+
+	const int out_r_bits = CL_PixelFormat::get_mask_bits(pf.get_red_mask());
+	const int out_g_bits = CL_PixelFormat::get_mask_bits(pf.get_green_mask());
+	const int out_b_bits = CL_PixelFormat::get_mask_bits(pf.get_blue_mask());
+	const int out_a_bits = CL_PixelFormat::get_mask_bits(pf.get_alpha_mask());
+
+	const unsigned int in_r = get_red();
+	const unsigned int in_g = get_green();
+	const unsigned int in_b = get_blue();
+	const unsigned int in_a = get_alpha();
+
+	unsigned int out_pixel = 0;
+	out_pixel = 0;
+	if (out_r_bits)
+		out_pixel |= (in_r &gt;&gt; (8 - out_r_bits)) &lt;&lt; out_r_shift;
+	if (out_g_bits)
+		out_pixel |= (in_g &gt;&gt; (8 - out_g_bits)) &lt;&lt; out_g_shift;
+	if (out_b_bits)
+		out_pixel |= (in_b &gt;&gt; (8 - out_b_bits)) &lt;&lt; out_b_shift;
+	if (out_a_bits)
+		out_pixel |= (in_a &gt;&gt; (8 - out_a_bits)) &lt;&lt; out_a_shift;
+
+	return out_pixel;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Color attributes:
+
+CL_Color CL_Color::aliceblue(240, 248, 255);
+CL_Color CL_Color::antiquewhite(250, 235, 215);
+CL_Color CL_Color::aqua( 0, 255, 255);
+CL_Color CL_Color::aquamarine(127, 255, 212);
+CL_Color CL_Color::azure(240, 255, 255);
+CL_Color CL_Color::beige(245, 245, 220);
+CL_Color CL_Color::bisque(255, 228, 196);
+CL_Color CL_Color::black( 0, 0, 0);
+CL_Color CL_Color::blanchedalmond(255, 235, 205);
+CL_Color CL_Color::blue( 0, 0, 255);
+CL_Color CL_Color::blueviolet(138, 43, 226);
+CL_Color CL_Color::brown(165, 42, 42);
+CL_Color CL_Color::burlywood(222, 184, 135);
+CL_Color CL_Color::cadetblue( 95, 158, 160);
+CL_Color CL_Color::chartreuse(127, 255, 0);
+CL_Color CL_Color::chocolate(210, 105, 30);
+CL_Color CL_Color::coral(255, 127, 80);
+CL_Color CL_Color::cornflowerblue(100, 149, 237);
+CL_Color CL_Color::cornsilk(255, 248, 220);
+CL_Color CL_Color::crimson(220, 20, 60);
+CL_Color CL_Color::cyan( 0, 255, 255);
+CL_Color CL_Color::darkblue( 0, 0, 139);
+CL_Color CL_Color::darkcyan( 0, 139, 139);
+CL_Color CL_Color::darkgoldenrod(184, 134, 11);
+CL_Color CL_Color::darkgray(169, 169, 169);
+CL_Color CL_Color::darkgreen( 0, 100, 0);
+CL_Color CL_Color::darkgrey(169, 169, 169);
+CL_Color CL_Color::darkkhaki(189, 183, 107);
+CL_Color CL_Color::darkmagenta(139, 0, 139);
+CL_Color CL_Color::darkolivegreen( 85, 107, 47);
+CL_Color CL_Color::darkorange(255, 140, 0);
+CL_Color CL_Color::darkorchid(153, 50, 204);
+CL_Color CL_Color::darkred(139, 0, 0);
+CL_Color CL_Color::darksalmon(233, 150, 122);
+CL_Color CL_Color::darkseagreen(143, 188, 143);
+CL_Color CL_Color::darkslateblue( 72, 61, 139);
+CL_Color CL_Color::darkslategray( 47, 79, 79);
+CL_Color CL_Color::darkslategrey( 47, 79, 79);
+CL_Color CL_Color::darkturquoise( 0, 206, 209);
+CL_Color CL_Color::darkviolet(148, 0, 211);
+CL_Color CL_Color::deeppink(255, 20, 147);
+CL_Color CL_Color::deepskyblue( 0, 191, 255);
+CL_Color CL_Color::dimgray(105, 105, 105);
+CL_Color CL_Color::dimgrey(105, 105, 105);
+CL_Color CL_Color::dodgerblue( 30, 144, 255);
+CL_Color CL_Color::firebrick(178, 34, 34);
+CL_Color CL_Color::floralwhite(255, 250, 240);
+CL_Color CL_Color::forestgreen( 34, 139, 34);
+CL_Color CL_Color::fuchsia(255, 0, 255);
+CL_Color CL_Color::gainsboro(220, 220, 220);
+CL_Color CL_Color::ghostwhite(248, 248, 255);
+CL_Color CL_Color::gold(255, 215, 0);
+CL_Color CL_Color::goldenrod(218, 165, 32);
+CL_Color CL_Color::gray(128, 128, 128);
+CL_Color CL_Color::grey(128, 128, 128);
+CL_Color CL_Color::green( 0, 128, 0);
+CL_Color CL_Color::greenyellow(173, 255, 47);
+CL_Color CL_Color::honeydew(240, 255, 240);
+CL_Color CL_Color::hotpink(255, 105, 180);
+CL_Color CL_Color::indianred(205, 92, 92);
+CL_Color CL_Color::indigo( 75, 0, 130);
+CL_Color CL_Color::ivory(255, 255, 240);
+CL_Color CL_Color::khaki(240, 230, 140);
+CL_Color CL_Color::lavender(230, 230, 250);
+CL_Color CL_Color::lavenderblush(255, 240, 245);
+CL_Color CL_Color::lawngreen(124, 252, 0);
+CL_Color CL_Color::lemonchiffon(255, 250, 205);
+CL_Color CL_Color::lightblue(173, 216, 230);
+CL_Color CL_Color::lightcoral(240, 128, 128);
+CL_Color CL_Color::lightcyan(224, 255, 255);
+CL_Color CL_Color::lightgoldenrodyellow(250, 250, 210);
+CL_Color CL_Color::lightgray(211, 211, 211);
+CL_Color CL_Color::lightgreen(144, 238, 144);
+CL_Color CL_Color::lightgrey(211, 211, 211);
+CL_Color CL_Color::lightpink(255, 182, 193);
+CL_Color CL_Color::lightsalmon(255, 160, 122);
+CL_Color CL_Color::lightseagreen( 32, 178, 170);
+CL_Color CL_Color::lightskyblue(135, 206, 250);
+CL_Color CL_Color::lightslategray(119, 136, 153);
+CL_Color CL_Color::lightslategrey(119, 136, 153);
+CL_Color CL_Color::lightsteelblue(176, 196, 222);
+CL_Color CL_Color::lightyellow(255, 255, 224);
+CL_Color CL_Color::lime( 0, 255, 0);
+CL_Color CL_Color::limegreen( 50, 205, 50);
+CL_Color CL_Color::linen(250, 240, 230);
+CL_Color CL_Color::magenta(255, 0, 255);
+CL_Color CL_Color::maroon(128, 0, 0);
+CL_Color CL_Color::mediumaquamarine(102, 205, 170);
+CL_Color CL_Color::mediumblue( 0, 0, 205);
+CL_Color CL_Color::mediumorchid(186, 85, 211);
+CL_Color CL_Color::mediumpurple(147, 112, 219);
+CL_Color CL_Color::mediumseagreen( 60, 179, 113);
+CL_Color CL_Color::mediumslateblue(123, 104, 238);
+CL_Color CL_Color::mediumspringgreen( 0, 250, 154);
+CL_Color CL_Color::mediumturquoise( 72, 209, 204);
+CL_Color CL_Color::mediumvioletred(199, 21, 133);
+CL_Color CL_Color::midnightblue( 25, 25, 112);
+CL_Color CL_Color::mintcream(245, 255, 250);
+CL_Color CL_Color::mistyrose(255, 228, 225);
+CL_Color CL_Color::moccasin(255, 228, 181);
+CL_Color CL_Color::navajowhite(255, 222, 173);
+CL_Color CL_Color::navy( 0, 0, 128);
+CL_Color CL_Color::oldlace(253, 245, 230);
+CL_Color CL_Color::olive(128, 128, 0);
+CL_Color CL_Color::olivedrab(107, 142, 35);
+CL_Color CL_Color::orange(255, 165, 0);
+CL_Color CL_Color::orangered(255, 69, 0);
+CL_Color CL_Color::orchid(218, 112, 214);
+CL_Color CL_Color::palegoldenrod(238, 232, 170);
+CL_Color CL_Color::palegreen(152, 251, 152);
+CL_Color CL_Color::paleturquoise(175, 238, 238);
+CL_Color CL_Color::palevioletred(219, 112, 147);
+CL_Color CL_Color::papayawhip(255, 239, 213);
+CL_Color CL_Color::peachpuff(255, 218, 185);
+CL_Color CL_Color::peru(205, 133, 63);
+CL_Color CL_Color::pink(255, 192, 203);
+CL_Color CL_Color::plum(221, 160, 221);
+CL_Color CL_Color::powderblue(176, 224, 230);
+CL_Color CL_Color::purple(128, 0, 128);
+CL_Color CL_Color::red(255, 0, 0);
+CL_Color CL_Color::rosybrown(188, 143, 143);
+CL_Color CL_Color::royalblue( 65, 105, 225);
+CL_Color CL_Color::saddlebrown(139, 69, 19);
+CL_Color CL_Color::salmon(250, 128, 114);
+CL_Color CL_Color::sandybrown(244, 164, 96);
+CL_Color CL_Color::seagreen( 46, 139, 87);
+CL_Color CL_Color::seashell(255, 245, 238);
+CL_Color CL_Color::sienna(160, 82, 45);
+CL_Color CL_Color::silver(192, 192, 192);
+CL_Color CL_Color::skyblue(135, 206, 235);
+CL_Color CL_Color::slateblue(106, 90, 205);
+CL_Color CL_Color::slategray(112, 128, 144);
+CL_Color CL_Color::slategrey(112, 128, 144);
+CL_Color CL_Color::snow(255, 250, 250);
+CL_Color CL_Color::springgreen( 0, 255, 127);
+CL_Color CL_Color::steelblue( 70, 130, 180);
+CL_Color CL_Color::tan(210, 180, 140);
+CL_Color CL_Color::teal( 0, 128, 128);
+CL_Color CL_Color::thistle(216, 191, 216);
+CL_Color CL_Color::tomato(255, 99, 71);
+CL_Color CL_Color::turquoise( 64, 224, 208);
+CL_Color CL_Color::violet(238, 130, 238);
+CL_Color CL_Color::wheat(245, 222, 179);
+CL_Color CL_Color::white(255, 255, 255);
+CL_Color CL_Color::whitesmoke(245, 245, 245);
+CL_Color CL_Color::yellow(255, 255, 0);
+CL_Color CL_Color::yellowgreen(154, 205, 50);
+
+CL_Color &amp;CL_Color::find_color(const std::string &amp;name)
+{
+	static std::map&lt;std::string, CL_Color *&gt; color_map;
+	if (color_map.empty())
+	{
+		color_map[&quot;aliceblue&quot;] = &amp;CL_Color::aliceblue;
+		color_map[&quot;antiquewhite&quot;] = &amp;CL_Color::antiquewhite;
+		color_map[&quot;aqua&quot;] = &amp;CL_Color::aqua;
+		color_map[&quot;aquamarine&quot;] = &amp;CL_Color::aquamarine;
+		color_map[&quot;azure&quot;] = &amp;CL_Color::azure;
+		color_map[&quot;beige&quot;] = &amp;CL_Color::beige;
+		color_map[&quot;bisque&quot;] = &amp;CL_Color::bisque;
+		color_map[&quot;black&quot;] = &amp;CL_Color::black;
+		color_map[&quot;blanchedalmond&quot;] = &amp;CL_Color::blanchedalmond;
+		color_map[&quot;blue&quot;] = &amp;CL_Color::blue;
+		color_map[&quot;blueviolet&quot;] = &amp;CL_Color::blueviolet;
+		color_map[&quot;brown&quot;] = &amp;CL_Color::brown;
+		color_map[&quot;burlywood&quot;] = &amp;CL_Color::burlywood;
+		color_map[&quot;cadetblue&quot;] = &amp;CL_Color::cadetblue;
+		color_map[&quot;chartreuse&quot;] = &amp;CL_Color::chartreuse;
+		color_map[&quot;chocolate&quot;] = &amp;CL_Color::chocolate;
+		color_map[&quot;coral&quot;] = &amp;CL_Color::coral;
+		color_map[&quot;cornflowerblue&quot;] = &amp;CL_Color::cornflowerblue;
+		color_map[&quot;cornsilk&quot;] = &amp;CL_Color::cornsilk;
+		color_map[&quot;crimson&quot;] = &amp;CL_Color::crimson;
+		color_map[&quot;cyan&quot;] = &amp;CL_Color::cyan;
+		color_map[&quot;darkblue&quot;] = &amp;CL_Color::darkblue;
+		color_map[&quot;darkcyan&quot;] = &amp;CL_Color::darkcyan;
+		color_map[&quot;darkgoldenrod&quot;] = &amp;CL_Color::darkgoldenrod;
+		color_map[&quot;darkgray&quot;] = &amp;CL_Color::darkgray;
+		color_map[&quot;darkgreen&quot;] = &amp;CL_Color::darkgreen;
+		color_map[&quot;darkgrey&quot;] = &amp;CL_Color::darkgrey;
+		color_map[&quot;darkkhaki&quot;] = &amp;CL_Color::darkkhaki;
+		color_map[&quot;darkmagenta&quot;] = &amp;CL_Color::darkmagenta;
+		color_map[&quot;darkolivegreen&quot;] = &amp;CL_Color::darkolivegreen;
+		color_map[&quot;darkorange&quot;] = &amp;CL_Color::darkorange;
+		color_map[&quot;darkorchid&quot;] = &amp;CL_Color::darkorchid;
+		color_map[&quot;darkred&quot;] = &amp;CL_Color::darkred;
+		color_map[&quot;darksalmon&quot;] = &amp;CL_Color::darksalmon;
+		color_map[&quot;darkseagreen&quot;] = &amp;CL_Color::darkseagreen;
+		color_map[&quot;darkslateblue&quot;] = &amp;CL_Color::darkslateblue;
+		color_map[&quot;darkslategray&quot;] = &amp;CL_Color::darkslategray;
+		color_map[&quot;darkslategrey&quot;] = &amp;CL_Color::darkslategrey;
+		color_map[&quot;darkturquoise&quot;] = &amp;CL_Color::darkturquoise;
+		color_map[&quot;darkviolet&quot;] = &amp;CL_Color::darkviolet;
+		color_map[&quot;deeppink&quot;] = &amp;CL_Color::deeppink;
+		color_map[&quot;deepskyblue&quot;] = &amp;CL_Color::deepskyblue;
+		color_map[&quot;dimgray&quot;] = &amp;CL_Color::dimgray;
+		color_map[&quot;dimgrey&quot;] = &amp;CL_Color::dimgrey;
+		color_map[&quot;dodgerblue&quot;] = &amp;CL_Color::dodgerblue;
+		color_map[&quot;firebrick&quot;] = &amp;CL_Color::firebrick;
+		color_map[&quot;floralwhite&quot;] = &amp;CL_Color::floralwhite;
+		color_map[&quot;forestgreen&quot;] = &amp;CL_Color::forestgreen;
+		color_map[&quot;fuchsia&quot;] = &amp;CL_Color::fuchsia;
+		color_map[&quot;gainsboro&quot;] = &amp;CL_Color::gainsboro;
+		color_map[&quot;ghostwhite&quot;] = &amp;CL_Color::ghostwhite;
+		color_map[&quot;gold&quot;] = &amp;CL_Color::gold;
+		color_map[&quot;goldenrod&quot;] = &amp;CL_Color::goldenrod;
+		color_map[&quot;gray&quot;] = &amp;CL_Color::gray;
+		color_map[&quot;grey&quot;] = &amp;CL_Color::grey;
+		color_map[&quot;green&quot;] = &amp;CL_Color::green;
+		color_map[&quot;greenyellow&quot;] = &amp;CL_Color::greenyellow;
+		color_map[&quot;honeydew&quot;] = &amp;CL_Color::honeydew;
+		color_map[&quot;hotpink&quot;] = &amp;CL_Color::hotpink;
+		color_map[&quot;indianred&quot;] = &amp;CL_Color::indianred;
+		color_map[&quot;indigo&quot;] = &amp;CL_Color::indigo;
+		color_map[&quot;ivory&quot;] = &amp;CL_Color::ivory;
+		color_map[&quot;khaki&quot;] = &amp;CL_Color::khaki;
+		color_map[&quot;lavender&quot;] = &amp;CL_Color::lavender;
+		color_map[&quot;lavenderblush&quot;] = &amp;CL_Color::lavenderblush;
+		color_map[&quot;lawngreen&quot;] = &amp;CL_Color::lawngreen;
+		color_map[&quot;lemonchiffon&quot;] = &amp;CL_Color::lemonchiffon;
+		color_map[&quot;lightblue&quot;] = &amp;CL_Color::lightblue;
+		color_map[&quot;lightcoral&quot;] = &amp;CL_Color::lightcoral;
+		color_map[&quot;lightcyan&quot;] = &amp;CL_Color::lightcyan;
+		color_map[&quot;lightgoldenrodyellow&quot;] = &amp;CL_Color::lightgoldenrodyellow;
+		color_map[&quot;lightgray&quot;] = &amp;CL_Color::lightgray;
+		color_map[&quot;lightgreen&quot;] = &amp;CL_Color::lightgreen;
+		color_map[&quot;lightgrey&quot;] = &amp;CL_Color::lightgrey;
+		color_map[&quot;lightpink&quot;] = &amp;CL_Color::lightpink;
+		color_map[&quot;lightsalmon&quot;] = &amp;CL_Color::lightsalmon;
+		color_map[&quot;lightseagreen&quot;] = &amp;CL_Color::lightseagreen;
+		color_map[&quot;lightskyblue&quot;] = &amp;CL_Color::lightskyblue;
+		color_map[&quot;lightslategray&quot;] = &amp;CL_Color::lightslategray;
+		color_map[&quot;lightslategrey&quot;] = &amp;CL_Color::lightslategrey;
+		color_map[&quot;lightsteelblue&quot;] = &amp;CL_Color::lightsteelblue;
+		color_map[&quot;lightyellow&quot;] = &amp;CL_Color::lightyellow;
+		color_map[&quot;lime&quot;] = &amp;CL_Color::lime;
+		color_map[&quot;limegreen&quot;] = &amp;CL_Color::limegreen;
+		color_map[&quot;linen&quot;] = &amp;CL_Color::linen;
+		color_map[&quot;magenta&quot;] = &amp;CL_Color::magenta;
+		color_map[&quot;maroon&quot;] = &amp;CL_Color::maroon;
+		color_map[&quot;mediumaquamarine&quot;] = &amp;CL_Color::mediumaquamarine;
+		color_map[&quot;mediumblue&quot;] = &amp;CL_Color::mediumblue;
+		color_map[&quot;mediumorchid&quot;] = &amp;CL_Color::mediumorchid;
+		color_map[&quot;mediumpurple&quot;] = &amp;CL_Color::mediumpurple;
+		color_map[&quot;mediumseagreen&quot;] = &amp;CL_Color::mediumseagreen;
+		color_map[&quot;mediumslateblue&quot;] = &amp;CL_Color::mediumslateblue;
+		color_map[&quot;mediumspringgreen&quot;] = &amp;CL_Color::mediumspringgreen;
+		color_map[&quot;mediumturquoise&quot;] = &amp;CL_Color::mediumturquoise;
+		color_map[&quot;mediumvioletred&quot;] = &amp;CL_Color::mediumvioletred;
+		color_map[&quot;midnightblue&quot;] = &amp;CL_Color::midnightblue;
+		color_map[&quot;mintcream&quot;] = &amp;CL_Color::mintcream;
+		color_map[&quot;mistyrose&quot;] = &amp;CL_Color::mistyrose;
+		color_map[&quot;moccasin&quot;] = &amp;CL_Color::moccasin;
+		color_map[&quot;navajowhite&quot;] = &amp;CL_Color::navajowhite;
+		color_map[&quot;navy&quot;] = &amp;CL_Color::navy;
+		color_map[&quot;oldlace&quot;] = &amp;CL_Color::oldlace;
+		color_map[&quot;olive&quot;] = &amp;CL_Color::olive;
+		color_map[&quot;olivedrab&quot;] = &amp;CL_Color::olivedrab;
+		color_map[&quot;orange&quot;] = &amp;CL_Color::orange;
+		color_map[&quot;orangered&quot;] = &amp;CL_Color::orangered;
+		color_map[&quot;orchid&quot;] = &amp;CL_Color::orchid;
+		color_map[&quot;palegoldenrod&quot;] = &amp;CL_Color::palegoldenrod;
+		color_map[&quot;palegreen&quot;] = &amp;CL_Color::palegreen;
+		color_map[&quot;paleturquoise&quot;] = &amp;CL_Color::paleturquoise;
+		color_map[&quot;palevioletred&quot;] = &amp;CL_Color::palevioletred;
+		color_map[&quot;papayawhip&quot;] = &amp;CL_Color::papayawhip;
+		color_map[&quot;peachpuff&quot;] = &amp;CL_Color::peachpuff;
+		color_map[&quot;peru&quot;] = &amp;CL_Color::peru;
+		color_map[&quot;pink&quot;] = &amp;CL_Color::pink;
+		color_map[&quot;plum&quot;] = &amp;CL_Color::plum;
+		color_map[&quot;powderblue&quot;] = &amp;CL_Color::powderblue;
+		color_map[&quot;purple&quot;] = &amp;CL_Color::purple;
+		color_map[&quot;red&quot;] = &amp;CL_Color::red;
+		color_map[&quot;rosybrown&quot;] = &amp;CL_Color::rosybrown;
+		color_map[&quot;royalblue&quot;] = &amp;CL_Color::royalblue;
+		color_map[&quot;saddlebrown&quot;] = &amp;CL_Color::saddlebrown;
+		color_map[&quot;salmon&quot;] = &amp;CL_Color::salmon;
+		color_map[&quot;sandybrown&quot;] = &amp;CL_Color::sandybrown;
+		color_map[&quot;seagreen&quot;] = &amp;CL_Color::seagreen;
+		color_map[&quot;seashell&quot;] = &amp;CL_Color::seashell;
+		color_map[&quot;sienna&quot;] = &amp;CL_Color::sienna;
+		color_map[&quot;silver&quot;] = &amp;CL_Color::silver;
+		color_map[&quot;skyblue&quot;] = &amp;CL_Color::skyblue;
+		color_map[&quot;slateblue&quot;] = &amp;CL_Color::slateblue;
+		color_map[&quot;slategray&quot;] = &amp;CL_Color::slategray;
+		color_map[&quot;slategrey&quot;] = &amp;CL_Color::slategrey;
+		color_map[&quot;snow&quot;] = &amp;CL_Color::snow;
+		color_map[&quot;springgreen&quot;] = &amp;CL_Color::springgreen;
+		color_map[&quot;steelblue&quot;] = &amp;CL_Color::steelblue;
+		color_map[&quot;tan&quot;] = &amp;CL_Color::tan;
+		color_map[&quot;teal&quot;] = &amp;CL_Color::teal;
+		color_map[&quot;thistle&quot;] = &amp;CL_Color::thistle;
+		color_map[&quot;tomato&quot;] = &amp;CL_Color::tomato;
+		color_map[&quot;turquoise&quot;] = &amp;CL_Color::turquoise;
+		color_map[&quot;violet&quot;] = &amp;CL_Color::violet;
+		color_map[&quot;wheat&quot;] = &amp;CL_Color::wheat;
+		color_map[&quot;white&quot;] = &amp;CL_Color::white;
+		color_map[&quot;whitesmoke&quot;] = &amp;CL_Color::whitesmoke;
+		color_map[&quot;yellow&quot;] = &amp;CL_Color::yellow;
+		color_map[&quot;yellowgreen&quot;] = &amp;CL_Color::yellowgreen;
+	}
+	
+	std::map&lt;std::string, CL_Color *&gt;::iterator it = color_map.find(name);
+	if (it != color_map.end()) return *it-&gt;second;
+
+	static CL_Color null(0,0,0,0);
+	return null;
+}
+	
+std::vector&lt;std::string&gt; &amp;CL_Color::get_names()
+{
+	static std::vector&lt;std::string&gt; names;
+	
+	if (names.empty())
+	{
+		names.push_back(&quot;aliceblue&quot;);
+		names.push_back(&quot;antiquewhite&quot;);
+		names.push_back(&quot;aqua&quot;);
+		names.push_back(&quot;aquamarine&quot;);
+		names.push_back(&quot;azure&quot;);
+		names.push_back(&quot;beige&quot;);
+		names.push_back(&quot;bisque&quot;);
+		names.push_back(&quot;black&quot;);
+		names.push_back(&quot;blanchedalmond&quot;);
+		names.push_back(&quot;blue&quot;);
+		names.push_back(&quot;blueviolet&quot;);
+		names.push_back(&quot;brown&quot;);
+		names.push_back(&quot;burlywood&quot;);
+		names.push_back(&quot;cadetblue&quot;);
+		names.push_back(&quot;chartreuse&quot;);
+		names.push_back(&quot;chocolate&quot;);
+		names.push_back(&quot;coral&quot;);
+		names.push_back(&quot;cornflowerblue&quot;);
+		names.push_back(&quot;cornsilk&quot;);
+		names.push_back(&quot;crimson&quot;);
+		names.push_back(&quot;cyan&quot;);
+		names.push_back(&quot;darkblue&quot;);
+		names.push_back(&quot;darkcyan&quot;);
+		names.push_back(&quot;darkgoldenrod&quot;);
+		names.push_back(&quot;darkgray&quot;);
+		names.push_back(&quot;darkgreen&quot;);
+		names.push_back(&quot;darkgrey&quot;);
+		names.push_back(&quot;darkkhaki&quot;);
+		names.push_back(&quot;darkmagenta&quot;);
+		names.push_back(&quot;darkolivegreen&quot;);
+		names.push_back(&quot;darkorange&quot;);
+		names.push_back(&quot;darkorchid&quot;);
+		names.push_back(&quot;darkred&quot;);
+		names.push_back(&quot;darksalmon&quot;);
+		names.push_back(&quot;darkseagreen&quot;);
+		names.push_back(&quot;darkslateblue&quot;);
+		names.push_back(&quot;darkslategray&quot;);
+		names.push_back(&quot;darkslategrey&quot;);
+		names.push_back(&quot;darkturquoise&quot;);
+		names.push_back(&quot;darkviolet&quot;);
+		names.push_back(&quot;deeppink&quot;);
+		names.push_back(&quot;deepskyblue&quot;);
+		names.push_back(&quot;dimgray&quot;);
+		names.push_back(&quot;dimgrey&quot;);
+		names.push_back(&quot;dodgerblue&quot;);
+		names.push_back(&quot;firebrick&quot;);
+		names.push_back(&quot;floralwhite&quot;);
+		names.push_back(&quot;forestgreen&quot;);
+		names.push_back(&quot;fuchsia&quot;);
+		names.push_back(&quot;gainsboro&quot;);
+		names.push_back(&quot;ghostwhite&quot;);
+		names.push_back(&quot;gold&quot;);
+		names.push_back(&quot;goldenrod&quot;);
+		names.push_back(&quot;gray&quot;);
+		names.push_back(&quot;grey&quot;);
+		names.push_back(&quot;green&quot;);
+		names.push_back(&quot;greenyellow&quot;);
+		names.push_back(&quot;honeydew&quot;);
+		names.push_back(&quot;hotpink&quot;);
+		names.push_back(&quot;indianred&quot;);
+		names.push_back(&quot;indigo&quot;);
+		names.push_back(&quot;ivory&quot;);
+		names.push_back(&quot;khaki&quot;);
+		names.push_back(&quot;lavender&quot;);
+		names.push_back(&quot;lavenderblush&quot;);
+		names.push_back(&quot;lawngreen&quot;);
+		names.push_back(&quot;lemonchiffon&quot;);
+		names.push_back(&quot;lightblue&quot;);
+		names.push_back(&quot;lightcoral&quot;);
+		names.push_back(&quot;lightcyan&quot;);
+		names.push_back(&quot;lightgoldenrodyellow&quot;);
+		names.push_back(&quot;lightgray&quot;);
+		names.push_back(&quot;lightgreen&quot;);
+		names.push_back(&quot;lightgrey&quot;);
+		names.push_back(&quot;lightpink&quot;);
+		names.push_back(&quot;lightsalmon&quot;);
+		names.push_back(&quot;lightseagreen&quot;);
+		names.push_back(&quot;lightskyblue&quot;);
+		names.push_back(&quot;lightslategray&quot;);
+		names.push_back(&quot;lightslategrey&quot;);
+		names.push_back(&quot;lightsteelblue&quot;);
+		names.push_back(&quot;lightyellow&quot;);
+		names.push_back(&quot;lime&quot;);
+		names.push_back(&quot;limegreen&quot;);
+		names.push_back(&quot;linen&quot;);
+		names.push_back(&quot;magenta&quot;);
+		names.push_back(&quot;maroon&quot;);
+		names.push_back(&quot;mediumaquamarine&quot;);
+		names.push_back(&quot;mediumblue&quot;);
+		names.push_back(&quot;mediumorchid&quot;);
+		names.push_back(&quot;mediumpurple&quot;);
+		names.push_back(&quot;mediumseagreen&quot;);
+		names.push_back(&quot;mediumslateblue&quot;);
+		names.push_back(&quot;mediumspringgreen&quot;);
+		names.push_back(&quot;mediumturquoise&quot;);
+		names.push_back(&quot;mediumvioletred&quot;);
+		names.push_back(&quot;midnightblue&quot;);
+		names.push_back(&quot;mintcream&quot;);
+		names.push_back(&quot;mistyrose&quot;);
+		names.push_back(&quot;moccasin&quot;);
+		names.push_back(&quot;navajowhite&quot;);
+		names.push_back(&quot;navy&quot;);
+		names.push_back(&quot;oldlace&quot;);
+		names.push_back(&quot;olive&quot;);
+		names.push_back(&quot;olivedrab&quot;);
+		names.push_back(&quot;orange&quot;);
+		names.push_back(&quot;orangered&quot;);
+		names.push_back(&quot;orchid&quot;);
+		names.push_back(&quot;palegoldenrod&quot;);
+		names.push_back(&quot;palegreen&quot;);
+		names.push_back(&quot;paleturquoise&quot;);
+		names.push_back(&quot;palevioletred&quot;);
+		names.push_back(&quot;papayawhip&quot;);
+		names.push_back(&quot;peachpuff&quot;);
+		names.push_back(&quot;peru&quot;);
+		names.push_back(&quot;pink&quot;);
+		names.push_back(&quot;plum&quot;);
+		names.push_back(&quot;powderblue&quot;);
+		names.push_back(&quot;purple&quot;);
+		names.push_back(&quot;red&quot;);
+		names.push_back(&quot;rosybrown&quot;);
+		names.push_back(&quot;royalblue&quot;);
+		names.push_back(&quot;saddlebrown&quot;);
+		names.push_back(&quot;salmon&quot;);
+		names.push_back(&quot;sandybrown&quot;);
+		names.push_back(&quot;seagreen&quot;);
+		names.push_back(&quot;seashell&quot;);
+		names.push_back(&quot;sienna&quot;);
+		names.push_back(&quot;silver&quot;);
+		names.push_back(&quot;skyblue&quot;);
+		names.push_back(&quot;slateblue&quot;);
+		names.push_back(&quot;slategray&quot;);
+		names.push_back(&quot;slategrey&quot;);
+		names.push_back(&quot;snow&quot;);
+		names.push_back(&quot;springgreen&quot;);
+		names.push_back(&quot;steelblue&quot;);
+		names.push_back(&quot;tan&quot;);
+		names.push_back(&quot;teal&quot;);
+		names.push_back(&quot;thistle&quot;);
+		names.push_back(&quot;tomato&quot;);
+		names.push_back(&quot;turquoise&quot;);
+		names.push_back(&quot;violet&quot;);
+		names.push_back(&quot;wheat&quot;);
+		names.push_back(&quot;white&quot;);
+		names.push_back(&quot;whitesmoke&quot;);
+		names.push_back(&quot;yellow&quot;);
+		names.push_back(&quot;yellowgreen&quot;);
+	}
+	
+	return names;
+}

Added: trunk/clanlib/Display/display.cpp
===================================================================
--- trunk/clanlib/Display/display.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/display.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,391 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Display/pixel_buffer.h&quot;
+#include &quot;API/Display/display_mode.h&quot;
+#include &quot;API/Display/input_context.h&quot;
+#include &quot;API/Display/graphic_context.h&quot;
+#include &quot;display_window_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Display attributes:
+
+CL_DisplayWindow *CL_Display::get_current_window()
+{
+	return CL_DisplayWindow_Generic::current;
+}
+
+int CL_Display::get_width()
+{
+	return CL_DisplayWindow_Generic::current-&gt;get_width();
+}
+
+int CL_Display::get_height()
+{
+	return CL_DisplayWindow_Generic::current-&gt;get_height();
+}
+
+bool CL_Display::is_fullscreen()
+{
+	return CL_DisplayWindow_Generic::current-&gt;is_fullscreen();
+}
+
+bool CL_Display::has_focus()
+{
+	return CL_DisplayWindow_Generic::current-&gt;has_focus();
+}
+
+CL_PixelBuffer CL_Display::get_buffer(int i)
+{
+	return CL_DisplayWindow_Generic::current-&gt;get_buffer(i);
+}
+
+int CL_Display::get_buffer_count()
+{
+	return CL_DisplayWindow_Generic::current-&gt;get_buffer_count();
+}
+
+CL_PixelBuffer CL_Display::get_front_buffer()
+{
+	return CL_DisplayWindow_Generic::current-&gt;get_front_buffer();
+}
+
+CL_PixelBuffer CL_Display::get_back_buffer()
+{
+	return CL_DisplayWindow_Generic::current-&gt;get_back_buffer();
+}
+
+const CL_Rect &amp;CL_Display::get_cliprect()
+{
+	return CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;get_cliprect();
+}
+
+const CL_Matrix4x4 &amp;CL_Display::get_modelview()
+{
+	return CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;get_modelview();
+}
+	
+/////////////////////////////////////////////////////////////////////////////
+// CL_Display operations:
+
+void CL_Display::set_current_window(CL_DisplayWindow *window)
+{
+	CL_DisplayWindow_Generic::current = window;
+}
+
+void CL_Display::set_fullscreen(int width, int height, int bpp)
+{
+	CL_DisplayWindow_Generic::current-&gt;set_fullscreen(width, height, bpp, 0);
+}
+
+void CL_Display::set_fullscreen(const CL_DisplayMode &amp;display_mode)
+{
+	CL_DisplayWindow_Generic::current-&gt;set_fullscreen(display_mode);
+}
+
+void CL_Display::set_windowed()
+{
+	CL_DisplayWindow_Generic::current-&gt;set_windowed();
+}
+
+void CL_Display::set_title(const std::string &amp;title)
+{
+	CL_DisplayWindow_Generic::current-&gt;set_title(title);
+}
+
+void CL_Display::set_position(const CL_Rect &amp;pos)
+{
+	CL_DisplayWindow_Generic::current-&gt;set_position(pos);
+}
+
+void CL_Display::set_position(int x, int y)
+{
+	CL_DisplayWindow_Generic::current-&gt;set_position(x, y);
+}
+
+void CL_Display::set_size(int width, int height)
+{
+	CL_DisplayWindow_Generic::current-&gt;set_size(width, height);
+}
+
+void CL_Display::set_buffer_count(int flipping_buffers)
+{
+	CL_DisplayWindow_Generic::current-&gt;set_buffer_count(flipping_buffers);
+}
+
+void CL_Display::update(const CL_Rect &amp;rect)
+{
+	CL_DisplayWindow_Generic::current-&gt;update(rect);
+}
+
+void CL_Display::flip(int interval)
+{
+	CL_DisplayWindow_Generic::current-&gt;flip(interval);
+}
+
+void CL_Display::flush()
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;flush();
+}
+
+void CL_Display::draw_pixel(int x, int y, const CL_Color &amp;color)
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;draw_pixel(x, y, color);
+}
+
+void CL_Display::draw_line(float x1, float y1, float x2, float y2, const CL_Color &amp;color)
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;draw_line(x1, y1, x2, y2, color);
+}
+
+void CL_Display::draw_line(const CL_Pointf &amp;a, const CL_Pointf &amp;b, const CL_Color &amp;color)
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;draw_line(a.x, a.y, b.x, b.y, color);
+}
+
+void CL_Display::draw_lines(int count, double *vertices, const CL_Color &amp;color)
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;draw_lines(count, vertices, color);
+}
+
+void CL_Display::draw_rect(const CL_Rectf &amp;rect, const CL_Color &amp;color)
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;draw_rect(rect, color);
+}
+
+void CL_Display::fill_rect(const CL_Rectf &amp;rect, const CL_Gradient &amp;gradient)
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;fill_rect(rect, gradient);
+}
+
+void CL_Display::fill_rect(const CL_Rectf &amp;rect, const CL_Color &amp;color)
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;fill_rect(rect, color);
+}
+
+void CL_Display::draw_quad(const CL_Quad &amp;quad, const CL_Color &amp;color)
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;draw_quad(quad, color);
+}
+
+void CL_Display::fill_quad(const CL_Quad &amp;quad, const CL_Gradient &amp;gradient)
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;fill_quad(quad, gradient);
+}
+
+void CL_Display::fill_quad(const CL_Quad &amp;quad, const CL_Color &amp;color)
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;fill_quad(quad, color);
+}
+
+void CL_Display::draw_triangle(
+		double x1, double y1,
+		double x2, double y2,
+		double x3, double y3,
+		const CL_Color &amp;color)
+{
+	CL_GraphicContext *gc = CL_DisplayWindow_Generic::current-&gt;get_gc();
+
+	gc-&gt;draw_triangle(x1,y1,x2,y2,x3,y3,color);
+}
+
+void CL_Display::fill_triangle(
+		double x1, double y1,
+		double x2, double y2,
+		double x3, double y3,
+		const CL_Gradient &amp;gradient)
+{
+	CL_GraphicContext *gc = CL_DisplayWindow_Generic::current-&gt;get_gc();
+
+	gc-&gt;fill_triangle(x1,y1,x2,y2,x3,y3,gradient);
+}
+
+void CL_Display::draw_triangles(
+		unsigned int count,
+		bool fill,
+		double *vertices,
+		unsigned char *color,
+		int *uv,
+		CL_Surface *texture)
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;draw_triangles(count, fill, vertices, color, uv, texture);
+}
+
+void CL_Display::draw_triangles(
+		unsigned int count,
+		bool fill,
+		double *vertices,
+		const CL_Color &amp;color,
+		int *uv,
+		CL_Surface *texture )
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;draw_triangles(count, fill, vertices, color, uv, texture);
+}
+
+void CL_Display::draw_trianglesd(
+		unsigned int count,
+		bool fill,
+		double *vertices,
+		double *color,
+		double *uv,
+		CL_Surface *texture )
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;draw_trianglesd(count, fill, vertices, color, uv, texture);
+}
+
+void CL_Display::draw_trianglesd(
+		unsigned int count,
+		bool fill,
+		double *vertices,
+		const CL_Color &amp;color,
+		double *uv,
+		CL_Surface *texture )
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;draw_trianglesd(count, fill, vertices, color, uv, texture);
+}
+
+void CL_Display::clear(const CL_Color &amp;color)
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;clear(color);
+}
+
+void CL_Display::set_cliprect(const CL_Rect &amp;rect)
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;set_cliprect(rect);
+}
+
+void CL_Display::push_cliprect(const CL_Rect &amp;rect)
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;push_cliprect(rect);
+}
+
+void CL_Display::push_cliprect()
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;push_cliprect();
+}
+
+void CL_Display::pop_cliprect()
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;pop_cliprect();
+}
+
+void CL_Display::set_modelview(const CL_Matrix4x4 &amp;matrix)
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;set_modelview(matrix);
+}
+
+void CL_Display::add_modelview(const CL_Matrix4x4 &amp;matrix)
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;add_modelview(matrix);
+}
+
+void CL_Display::push_modelview()
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;push_modelview();
+}
+
+void CL_Display::set_translate(double x, double y, double z)
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;set_translate(x, y, z);
+}
+
+void CL_Display::add_translate(double x, double y, double z)
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;add_translate(x, y, z);
+}
+
+void CL_Display::push_translate(double x, double y, double z)
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;push_translate(x, y, z);
+}
+
+void CL_Display::set_rotate(double angle, double x, double y, double z)
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;set_rotate(angle, x, y, z);
+}
+
+void CL_Display::add_rotate(double angle, double x, double y, double z)
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;add_rotate(angle, x, y, z);
+}
+
+void CL_Display::push_rotate(double angle, double x, double y, double z)
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;push_rotate(angle, x, y, z);
+}
+
+void CL_Display::set_scale(double x, double y, double z)
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;set_scale(x, y, z);
+}
+
+void CL_Display::add_scale(double x, double y, double z)
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;add_scale(x, y, z);
+}
+
+void CL_Display::push_scale(double x, double y, double z)
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;push_scale(x, y, z);
+}
+
+void CL_Display::pop_modelview()
+{
+	CL_DisplayWindow_Generic::current-&gt;get_gc()-&gt;pop_modelview();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Display signals:
+
+CL_Signal_v2&lt;int, int&gt; &amp;CL_Display::sig_resize()
+{
+	return CL_DisplayWindow_Generic::current-&gt;sig_resize();
+}
+
+CL_Signal_v1&lt;const CL_Rect &amp;&gt; &amp;CL_Display::sig_paint()
+{
+	return CL_DisplayWindow_Generic::current-&gt;sig_paint();
+}
+
+CL_Signal_v0 &amp;CL_Display::sig_lost_focus()
+{
+	return CL_DisplayWindow_Generic::current-&gt;sig_lost_focus();
+}
+
+CL_Signal_v0 &amp;CL_Display::sig_got_focus()
+{
+	return CL_DisplayWindow_Generic::current-&gt;sig_got_focus();
+}
+
+CL_Signal_v0 &amp;CL_Display::sig_window_close()
+{
+	return CL_DisplayWindow_Generic::current-&gt;sig_window_close();
+}

Added: trunk/clanlib/Display/display_iostream.cpp
===================================================================
--- trunk/clanlib/Display/display_iostream.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/display_iostream.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,92 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &lt;iostream&gt;
+#include &quot;API/Display/display_window.h&quot;
+#include &quot;API/Display/input_event.h&quot;
+#include &quot;API/Display/input_device.h&quot;
+#include &quot;API/Display/display_iostream.h&quot;
+#include &quot;API/Core/core_iostream.h&quot;
+
+std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const CL_DisplayWindow&amp; window)
+{
+	s &lt;&lt; &quot;#&lt;CL_DisplayWindow: &quot; &lt;&lt; window.get_width() &lt;&lt; &quot;x&quot; &lt;&lt; window.get_height() &lt;&lt; &quot;&gt;&quot;;
+	return s;
+}
+
+std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const CL_InputDevice&amp; device)
+{
+	s &lt;&lt; &quot;#&lt;CL_InputDevice: '&quot; &lt;&lt; device.get_name() &lt;&lt; &quot;'&gt;&quot;;
+	return s;
+}
+
+std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const CL_InputEvent&amp; event)
+{
+	s &lt;&lt; &quot;#&lt;CL_InputEvent: &quot;;
+
+	switch (event.type)
+	{
+	case CL_InputEvent::no_key:
+      s &lt;&lt; &quot;no_key&quot;;
+      break;
+	case CL_InputEvent::pressed:
+      s &lt;&lt; &quot;pressed&quot;;
+		s &lt;&lt; &quot;, '&quot; &lt;&lt; event.device.get_key_name(event.id) &lt;&lt; &quot;'&quot;;
+		s &lt;&lt; &quot;, &quot; &lt;&lt; event.mouse_pos; 
+      break;
+	case CL_InputEvent::released:
+      s &lt;&lt; &quot;released&quot;;
+		s &lt;&lt; &quot;, '&quot; &lt;&lt; event.device.get_key_name(event.id) &lt;&lt; &quot;'&quot;;
+		s &lt;&lt; &quot;, &quot; &lt;&lt; event.mouse_pos; 
+      break;
+	case CL_InputEvent::pointer_moved:
+      s &lt;&lt; &quot;pointer_moved&quot;;
+		s &lt;&lt; &quot;, pos: &quot; &lt;&lt; event.mouse_pos; 
+      break;
+	case CL_InputEvent::axis_moved:
+      s &lt;&lt; &quot;axis_moved&quot;;
+		s &lt;&lt; &quot;, id: &quot; &lt;&lt; event.id;
+		s &lt;&lt; &quot;, pos: &quot; &lt;&lt; event.axis_pos;
+      break;
+	case CL_InputEvent::ball_moved:
+      s &lt;&lt; &quot;ball_moved&quot;;
+		s &lt;&lt; &quot;, &quot; &lt;&lt; event.mouse_pos; 
+      break;
+	default:
+      s &lt;&lt; &quot;unknown&quot;;
+	}
+
+	s &lt;&lt; &quot;, &quot; &lt;&lt; event.device;
+	s &lt;&lt; &quot;&gt;&quot;;
+
+	return s;
+}
+
+// EOF //

Added: trunk/clanlib/Display/display_mode.cpp
===================================================================
--- trunk/clanlib/Display/display_mode.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/display_mode.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,167 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef __APPLE__
+#ifndef WIN32
+#include &lt;X11/Xlib.h&gt;
+#include &lt;X11/extensions/xf86vmode.h&gt;
+#define V_DBLSCAN       0x020
+#else
+#include &lt;windows.h&gt;
+#endif
+#endif
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/display_mode.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;display_mode_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DisplayMode construction:
+
+CL_DisplayMode::CL_DisplayMode(const CL_Size &amp;res, int bpp, int refresh_rate) : impl(0)
+{
+	impl = new CL_DisplayMode_Generic;
+	impl-&gt;resolution = res;
+	impl-&gt;bpp = bpp;
+	impl-&gt;refresh_rate = refresh_rate;
+}
+
+CL_DisplayMode::CL_DisplayMode(const CL_DisplayMode &amp;copy) : impl (new CL_DisplayMode_Generic)
+{
+	*impl = *copy.impl;
+}
+
+CL_DisplayMode::~CL_DisplayMode()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DisplayMode attributes:
+
+CL_Size CL_DisplayMode::get_resolution() const
+{
+	return impl-&gt;resolution;
+}
+
+int CL_DisplayMode::get_bpp() const
+{
+	return impl-&gt;bpp;
+}
+
+int CL_DisplayMode::get_refresh_rate() const
+{
+	return impl-&gt;refresh_rate;
+}
+
+std::string CL_DisplayMode::get_string() const
+{
+	return CL_String::format(&quot;%1x%2x%3@%4&quot;, impl-&gt;resolution.width, impl-&gt;resolution.height, impl-&gt;bpp, impl-&gt;refresh_rate);
+}
+
+std::vector&lt;CL_DisplayMode&gt; &amp;CL_DisplayMode::get_display_modes()
+{
+	static std::vector&lt;CL_DisplayMode&gt; modes;
+
+	if(modes.empty())
+	{
+#ifdef WIN32
+		int index = 0;
+		while (true)
+		{
+			DEVMODE cur_devmode;
+			memset(&amp;cur_devmode, 0, sizeof(DEVMODE));
+			cur_devmode.dmSize = sizeof(DEVMODE);
+			if (EnumDisplaySettings(0, index++, &amp;cur_devmode) == 0) break;
+
+			modes.push_back(CL_DisplayMode(
+				CL_Size(cur_devmode.dmPelsWidth, cur_devmode.dmPelsHeight),
+				cur_devmode.dmBitsPerPel,
+				cur_devmode.dmDisplayFrequency));
+		}
+#else
+#ifndef __APPLE__
+		Display *display = XOpenDisplay(NULL);
+
+		int event_base;
+		int error_base;
+
+		// Check for VidMode extension
+		if (XF86VidModeQueryExtension(display, &amp;event_base, &amp;error_base))
+		{
+			int screen = DefaultScreen(display);
+
+			XF86VidModeModeInfo **vmodes;
+			int nmodes;
+
+			if (XF86VidModeGetAllModeLines(display, screen, &amp;nmodes, &amp;vmodes))
+			{
+				int bpp = DefaultDepth(display, screen);
+				int refresh_rate;
+
+				for (int i = 0; i &lt; nmodes; i++)
+				{
+					if(vmodes[i]-&gt;htotal * vmodes[i]-&gt;vtotal != 0)
+					{
+						if ((vmodes[i]-&gt;flags) &amp; V_DBLSCAN)
+							refresh_rate = vmodes[i]-&gt;dotclock * 500 / (vmodes[i]-&gt;htotal * vmodes[i]-&gt;vtotal);
+						else
+							refresh_rate = vmodes[i]-&gt;dotclock * 1000 / (vmodes[i]-&gt;htotal * vmodes[i]-&gt;vtotal);
+					}
+					else
+						refresh_rate = 0;
+
+					modes.push_back(CL_DisplayMode(
+						CL_Size(vmodes[i]-&gt;hdisplay, vmodes[i]-&gt;vdisplay),
+						bpp,
+						refresh_rate));
+				}
+			}
+		}
+
+		XCloseDisplay(display);
+#endif
+#endif
+	}
+
+	return modes;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DisplayMode attributes:
+
+CL_DisplayMode &amp;CL_DisplayMode::operator =(const CL_DisplayMode &amp;copy)
+{
+	*impl = *copy.impl;
+	return *this;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DisplayMode implementation:

Added: trunk/clanlib/Display/display_mode_generic.h
===================================================================
--- trunk/clanlib/Display/display_mode_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/display_mode_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,51 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_display_mode_generic
+#define header_display_mode_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+#include &quot;API/Core/Math/size.h&quot;
+
+class CL_DisplayMode_Generic
+{
+//! Attributes:
+public:
+	CL_Size resolution;
+	
+	int bpp;
+
+	int refresh_rate;
+};
+
+#endif

Added: trunk/clanlib/Display/display_precomp.cpp
===================================================================
--- trunk/clanlib/Display/display_precomp.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/display_precomp.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,30 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;

Added: trunk/clanlib/Display/display_precomp.h
===================================================================
--- trunk/clanlib/Display/display_precomp.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/display_precomp.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,37 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+// Win32 precompiled header file support.
+#ifdef WIN32
+#pragma warning(disable : 4786)
+#include &lt;windows.h&gt;
+#endif
+
+#include &quot;API/Core/System/cl_assert.h&quot;
+

Added: trunk/clanlib/Display/display_target.cpp
===================================================================
--- trunk/clanlib/Display/display_target.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/display_target.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,64 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;display_target.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DisplayTarget construction:
+
+CL_DisplayTarget::CL_DisplayTarget()
+{
+	current_target = this;
+}
+
+CL_DisplayTarget::~CL_DisplayTarget()
+{
+	current_target = 0;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DisplayTarget attributes:
+
+CL_DisplayTarget *CL_DisplayTarget::current_target = 0;
+
+CL_DisplayTarget *CL_DisplayTarget::current()
+{
+	if (current_target == 0) 
+		throw CL_Error (&quot;You need a create a display target first.&quot;);
+
+	return current_target;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DisplayTarget operations:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DisplayTarget implementation:

Added: trunk/clanlib/Display/display_target.h
===================================================================
--- trunk/clanlib/Display/display_target.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/display_target.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,95 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_display_target
+#define header_display_target
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Display/surface.h&quot;
+
+class CL_Font_Generic;
+class CL_Font_Target;
+class CL_DisplayWindow_Generic;
+class CL_Surface_Target;
+class CL_Canvas_Generic;
+
+class CL_API_DISPLAY CL_DisplayTarget
+{
+//! Construction:
+public:
+	CL_DisplayTarget();
+
+	virtual ~CL_DisplayTarget();
+
+//! Attributes:
+public:
+	static CL_DisplayTarget *current();
+	static CL_DisplayTarget *current_target;
+
+//! Operations:
+public:
+	virtual CL_DisplayWindow_Generic *create_window()=0;
+
+	virtual CL_Surface_Target *create_surface(
+		CL_PixelBuffer provider,
+		int flag)=0;
+
+	virtual CL_Canvas_Generic *create_canvas()=0;
+
+	virtual CL_Font_Target* create_system_font_target(
+		CL_Font_Generic *attributes,
+		const std::string &amp;font_name,
+		const std::string &amp;letters,
+		int height,
+		int width,
+		bool bold,
+		bool italic,
+		bool underline,
+		bool strikeout)=0;
+
+	virtual bool enable_packer()=0;
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/Display/display_window.cpp
===================================================================
--- trunk/clanlib/Display/display_window.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/display_window.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,275 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/display_mode.h&quot;
+#include &quot;API/Display/display_window.h&quot;
+#include &quot;API/Display/display_window_description.h&quot;
+#include &quot;display_window_generic.h&quot;
+#include &quot;display_target.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DisplayWindow construction:
+
+CL_DisplayWindow::CL_DisplayWindow()
+: impl(0)
+{
+}
+
+CL_DisplayWindow::CL_DisplayWindow(
+	const std::string &amp;title,
+	int width,
+	int height,
+	bool start_fullscreen,
+	bool allow_resize,
+	int flipping_buffers)
+: impl(0)
+{
+	impl = CL_DisplayTarget::current()-&gt;create_window();
+	cl_assert(impl != 0); // platform not implemented?
+	if (impl) impl-&gt;add_ref();
+
+	CL_DisplayWindowDescription desc;
+	desc.set_title(title);
+	desc.set_size(CL_Size(width, height));
+	desc.set_fullscreen(start_fullscreen);
+	desc.set_flipping_buffers(flipping_buffers);
+	desc.set_allow_resize(allow_resize);
+
+	impl-&gt;create_window(desc);
+
+	// Automatically map first created display window as 'CL_Display current'.
+	if (CL_DisplayWindow_Generic::current == 0) CL_DisplayWindow_Generic::current = this;
+
+	impl-&gt;sig_resize(get_width(), get_height());
+}
+
+CL_DisplayWindow::CL_DisplayWindow(const CL_DisplayWindowDescription &amp;description)
+: impl(0)
+{
+	impl = CL_DisplayTarget::current()-&gt;create_window();
+	cl_assert(impl != 0); // platform not implemented?
+	if (impl) impl-&gt;add_ref();
+
+	impl-&gt;create_window(description);
+
+	// Automatically map first created display window as 'CL_Display current'.
+	if (CL_DisplayWindow_Generic::current == 0) CL_DisplayWindow_Generic::current = this;
+
+	impl-&gt;sig_resize(get_width(), get_height());
+}
+
+CL_DisplayWindow::~CL_DisplayWindow()
+{
+	if (impl) impl-&gt;release_ref();
+	if (CL_DisplayWindow_Generic::current == this) CL_DisplayWindow_Generic::current = 0;
+}
+
+CL_DisplayWindow::CL_DisplayWindow(CL_DisplayWindow_Generic *impl)
+: impl(impl)
+{
+	if (impl) impl-&gt;add_ref();
+
+	// Automatically map first created display window as 'CL_Display current'.
+	if (CL_DisplayWindow_Generic::current == 0) CL_DisplayWindow_Generic::current = this;
+}
+
+CL_DisplayWindow::CL_DisplayWindow(const CL_DisplayWindow &amp;copy)
+: impl(copy.impl)
+{
+	if (impl) impl-&gt;add_ref();
+	if (CL_DisplayWindow_Generic::current == &amp;copy) CL_DisplayWindow_Generic::current = this;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DisplayWindow attributes:
+
+int CL_DisplayWindow::get_width() const
+{
+	return impl-&gt;get_width();
+}
+
+int CL_DisplayWindow::get_height() const
+{
+	return impl-&gt;get_height();
+}
+
+bool CL_DisplayWindow::is_fullscreen() const
+{
+	return impl-&gt;is_fullscreen();
+}
+
+bool CL_DisplayWindow::has_focus() const
+{
+	return impl-&gt;has_focus();
+}
+
+CL_PixelBuffer CL_DisplayWindow::get_buffer(int i) const
+{
+	return impl-&gt;get_buffer(i);
+}
+
+int CL_DisplayWindow::get_buffer_count() const
+{
+	return impl-&gt;get_buffer_count();
+}
+
+CL_PixelBuffer CL_DisplayWindow::get_front_buffer()
+{
+	return impl-&gt;get_buffer(0);
+}
+
+CL_PixelBuffer CL_DisplayWindow::get_back_buffer()
+{
+	return impl-&gt;get_buffer(impl-&gt;get_buffer_count()-1);
+}
+
+CL_Signal_v2&lt;int, int&gt; &amp;CL_DisplayWindow::sig_resize()
+{
+	return impl-&gt;sig_resize;
+}
+
+CL_Signal_v1&lt;const CL_Rect &amp;&gt; &amp;CL_DisplayWindow::sig_paint()
+{
+	return impl-&gt;sig_paint;
+}
+
+CL_Signal_v0 &amp;CL_DisplayWindow::sig_lost_focus()
+{
+	return impl-&gt;sig_lost_focus;
+}
+
+CL_Signal_v0 &amp;CL_DisplayWindow::sig_got_focus()
+{
+	return impl-&gt;sig_got_focus;
+}
+
+CL_Signal_v0 &amp;CL_DisplayWindow::sig_window_close()
+{
+	return impl-&gt;sig_window_close;
+}
+
+CL_GraphicContext *CL_DisplayWindow::get_gc()
+{
+	return impl-&gt;get_gc();
+}
+
+CL_InputContext *CL_DisplayWindow::get_ic()
+{
+	return impl-&gt;get_ic();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DisplayWindow operations:
+
+CL_DisplayWindow &amp;CL_DisplayWindow::operator =(const CL_DisplayWindow &amp;copy)
+{
+	if (impl != copy.impl)
+	{
+		if (impl) impl-&gt;release_ref();
+		impl = copy.impl;
+		if (impl) impl-&gt;add_ref();
+	}
+	if (CL_DisplayWindow_Generic::current == &amp;copy) CL_DisplayWindow_Generic::current = this;
+	return *this;
+}
+
+void CL_DisplayWindow::set_fullscreen(int width, int height, int bpp, int refresh_rate)
+{
+	impl-&gt;set_fullscreen(width, height, bpp, refresh_rate);
+	impl-&gt;sig_resize(get_width(), get_height());
+}
+
+void CL_DisplayWindow::set_fullscreen(const CL_DisplayMode &amp;display_mode)
+{
+	set_fullscreen(
+		display_mode.get_resolution().width, 
+		display_mode.get_resolution().height, 
+		display_mode.get_bpp(),
+		display_mode.get_refresh_rate());
+}
+
+void CL_DisplayWindow::set_windowed()
+{
+	impl-&gt;set_windowed();
+	impl-&gt;sig_resize(get_width(), get_height());
+}
+
+void CL_DisplayWindow::set_title(const std::string &amp;title)
+{
+	impl-&gt;set_title(title);
+}
+
+void CL_DisplayWindow::set_position(const CL_Rect &amp;pos)
+{
+	impl-&gt;set_position(pos);
+}
+
+void CL_DisplayWindow::set_position(int x, int y)
+{
+	impl-&gt;set_position(x, y);
+}
+
+void CL_DisplayWindow::set_size(int width, int height)
+{
+	impl-&gt;set_size(width, height);
+}
+
+void CL_DisplayWindow::set_buffer_count(int flipping_buffers)
+{
+	impl-&gt;set_buffer_count(flipping_buffers);
+}
+
+void CL_DisplayWindow::update(const CL_Rect &amp;rect)
+{
+	impl-&gt;update(rect);
+}
+
+void CL_DisplayWindow::flip(int interval)
+{
+	impl-&gt;do_flip(interval);
+}
+
+void CL_DisplayWindow::set_cursor(const CL_Sprite &amp;cursor)
+{
+	impl-&gt;set_cursor(cursor);
+}
+
+void CL_DisplayWindow::show_cursor()
+{
+	impl-&gt;show_cursor();
+}
+
+void CL_DisplayWindow::hide_cursor()
+{
+	impl-&gt;hide_cursor();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DisplayWindow implementation:

Added: trunk/clanlib/Display/display_window_description.cpp
===================================================================
--- trunk/clanlib/Display/display_window_description.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/display_window_description.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,160 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+	
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/display_window_description.h&quot;
+#include &quot;display_window_description_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DisplayWindowDescription construction:
+
+CL_DisplayWindowDescription::CL_DisplayWindowDescription() : impl(new CL_DisplayWindowDescription_Generic)
+{
+}
+
+CL_DisplayWindowDescription::CL_DisplayWindowDescription(const CL_DisplayWindowDescription &amp;copy) : impl(copy.impl)
+{
+}
+
+CL_DisplayWindowDescription::CL_DisplayWindowDescription(CL_DisplayWindowDescription_Generic *impl) : impl(impl)
+{
+}
+
+CL_DisplayWindowDescription::~CL_DisplayWindowDescription()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DisplayWindowDescription attributes:
+
+const std::string &amp;CL_DisplayWindowDescription::get_title() const
+{
+	return impl-&gt;title;
+}
+
+CL_Size CL_DisplayWindowDescription::get_size() const
+{
+	return impl-&gt;position.get_size();
+}
+
+CL_Rect CL_DisplayWindowDescription::get_position() const
+{
+	return impl-&gt;position;
+}
+
+bool CL_DisplayWindowDescription::is_fullscreen() const
+{
+	return impl-&gt;fullscreen;
+}
+
+int CL_DisplayWindowDescription::get_flipping_buffers() const
+{
+	return impl-&gt;flipping_buffers;
+}
+
+bool CL_DisplayWindowDescription::get_allow_resize() const
+{
+	return impl-&gt;allow_resize;
+}
+
+#ifdef WIN32
+bool CL_DisplayWindowDescription::is_layered() const
+{
+	return impl-&gt;layered;
+}
+#endif
+
+int CL_DisplayWindowDescription::get_bpp() const
+{
+	return impl-&gt;bpp;
+}
+
+int CL_DisplayWindowDescription::get_refresh_rate() const
+{
+	return impl-&gt;refresh_rate;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DisplayWindowDescription operations:
+
+CL_DisplayWindowDescription &amp;CL_DisplayWindowDescription::operator =(const CL_DisplayWindowDescription &amp;copy)
+{
+	impl = copy.impl;
+	return *this;
+}
+
+void CL_DisplayWindowDescription::set_title(const std::string &amp;title)
+{
+	impl-&gt;title = title;
+}
+
+void CL_DisplayWindowDescription::set_size(const CL_Size &amp;size)
+{
+	impl-&gt;position.set_size(size);
+}
+
+void CL_DisplayWindowDescription::set_position(const CL_Rect &amp;position)
+{
+	impl-&gt;position = position;
+}
+
+void CL_DisplayWindowDescription::set_fullscreen(bool fullscreen)
+{
+	impl-&gt;fullscreen = fullscreen;
+}
+
+void CL_DisplayWindowDescription::set_flipping_buffers(int num_buffers)
+{
+	impl-&gt;flipping_buffers = num_buffers;
+}
+
+void CL_DisplayWindowDescription::set_allow_resize(bool allow_resize)
+{
+	impl-&gt;allow_resize = allow_resize;
+}
+
+void CL_DisplayWindowDescription::set_bpp(int bytes)
+{
+	impl-&gt;bpp = bytes;
+}
+
+void CL_DisplayWindowDescription::set_refresh_rate(int refresh_rate)
+{
+	impl-&gt;refresh_rate = refresh_rate;
+}
+
+#ifdef WIN32
+void CL_DisplayWindowDescription::set_layered(bool layered)
+{
+	impl-&gt;layered = layered;
+}
+#endif
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DisplayWindowDescription implementation:

Added: trunk/clanlib/Display/display_window_description_generic.h
===================================================================
--- trunk/clanlib/Display/display_window_description_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/display_window_description_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,81 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_display_window_description_generic
+#define header_display_window_description_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+#include &quot;API/Core/Math/rect.h&quot;
+
+class CL_DisplayWindowDescription_Generic
+{
+//! Construction:
+public:
+	CL_DisplayWindowDescription_Generic()
+	{
+		title = &quot;Untitled clanlib window&quot;;
+		position = CL_Rect(-1, -1, 639, 479);
+		fullscreen = false;
+		flipping_buffers = 2;
+		allow_resize = false;
+		refresh_rate = 0;
+		bpp = 0;
+		#ifdef WIN32
+		layered = false;
+		#endif
+	}
+
+	virtual ~CL_DisplayWindowDescription_Generic() { return; }
+
+//! Attributes:
+public:
+	std::string title;
+
+	CL_Rect position;
+
+	bool fullscreen;
+
+	bool allow_resize;
+
+	int flipping_buffers;
+	
+	int bpp;
+
+	int refresh_rate;
+	
+#ifdef WIN32
+	bool layered;
+#endif
+};
+
+#endif

Added: trunk/clanlib/Display/display_window_generic.cpp
===================================================================
--- trunk/clanlib/Display/display_window_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/display_window_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,104 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;display_window_generic.h&quot;
+#include &quot;API/Display/input_device.h&quot;
+#include &quot;API/Display/input_context.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DisplayWindow_Generic construction:
+
+CL_DisplayWindow_Generic::CL_DisplayWindow_Generic() : cursor_visible(true), ref_count(0)
+{
+}
+
+CL_DisplayWindow_Generic::~CL_DisplayWindow_Generic()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DisplayWindow_Generic attributes:
+
+CL_DisplayWindow *CL_DisplayWindow_Generic::current = 0;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DisplayWindow_Generic operations:
+
+void CL_DisplayWindow_Generic::add_ref()
+{
+	ref_count++;
+}
+
+void CL_DisplayWindow_Generic::release_ref()
+{
+	ref_count--;
+	if (ref_count == 0)
+	{
+		cursor = CL_Sprite();
+		delete this;
+	}
+}
+
+void CL_DisplayWindow_Generic::do_flip(int interval)
+{
+	CL_InputDevice &amp;mouse = get_ic()-&gt;get_mouse();
+	if (!cursor.is_null())
+	{
+		cursor.update();
+		cursor.draw(mouse.get_x(), mouse.get_y(), get_gc());
+	}
+	flip(interval);
+}
+
+void CL_DisplayWindow_Generic::set_cursor(const CL_Sprite &amp;sprite)
+{
+	cursor = sprite;
+	cursor_changed();
+	if (cursor_visible)
+	{
+		if (!cursor.is_null()) hide_system_cursor();
+		else show_system_cursor();
+	}
+}
+
+void CL_DisplayWindow_Generic::show_cursor()
+{
+	if (cursor.is_null()) show_system_cursor();
+	cursor_visible = true;
+}
+
+void CL_DisplayWindow_Generic::hide_cursor()
+{
+	if (cursor.is_null()) hide_system_cursor();
+	cursor_visible = false;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_DisplayWindow_Generic implementation:

Added: trunk/clanlib/Display/display_window_generic.h
===================================================================
--- trunk/clanlib/Display/display_window_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/display_window_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,143 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_display_window_generic
+#define header_display_window_generic
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Display/display_window.h&quot;
+#include &quot;API/Display/sprite.h&quot;
+
+class CL_DisplayWindowDescription;
+class CL_DisplayMode;
+
+class CL_API_DISPLAY CL_DisplayWindow_Generic
+{
+//! Construction:
+public:
+	CL_DisplayWindow_Generic();
+
+	virtual ~CL_DisplayWindow_Generic();
+
+//! Attributes:
+public:
+	virtual int get_width() const=0;
+
+	virtual int get_height() const=0;
+
+	virtual bool is_fullscreen() const=0;
+
+	virtual bool has_focus() const=0;
+
+	virtual CL_PixelBuffer get_buffer(int i) const=0;
+
+	virtual int get_buffer_count() const=0;
+
+	virtual CL_GraphicContext *get_gc()=0;
+
+	virtual CL_InputContext *get_ic()=0;
+
+	//: CL_Display's 'current window' reference.
+	static CL_DisplayWindow *current;
+
+//! Operations:
+public:
+	void add_ref();
+
+	void release_ref();
+
+	virtual void create_window(const CL_DisplayWindowDescription &amp;desc)=0;
+
+	virtual void set_fullscreen(int width, int height, int bpp, int refresh_rate)=0;
+
+	virtual void set_windowed()=0;
+
+	virtual void set_title(const std::string &amp;title)=0;
+
+	virtual void set_position(const CL_Rect &amp;pos)=0;
+
+	virtual void set_position(int x, int y)=0;
+
+	virtual void set_size(int width, int height)=0;
+
+	virtual void set_buffer_count(int flipping_buffers)=0;
+
+	virtual void update(const CL_Rect &amp;rect)=0;
+
+	virtual void flip(int interval)=0;
+
+	virtual void show_system_cursor()=0;
+
+	virtual void hide_system_cursor()=0;
+
+	void do_flip(int interval);
+
+	void set_cursor(const CL_Sprite &amp;sprite);
+
+	void show_cursor();
+
+	void hide_cursor();
+
+//! Signals:
+public:
+	CL_Signal_v2&lt;int, int&gt; sig_resize;
+
+	CL_Signal_v1&lt;const CL_Rect &amp;&gt; sig_paint;
+
+	CL_Signal_v0 sig_lost_focus;
+
+	CL_Signal_v0 sig_got_focus;
+
+	CL_Signal_v0 sig_window_close;
+
+//! Implementation:
+private:
+	virtual void cursor_changed() { return; }
+
+	CL_Sprite cursor;
+
+	bool cursor_visible;
+
+	int ref_count;
+};
+
+#endif

Added: trunk/clanlib/Display/font.cpp
===================================================================
--- trunk/clanlib/Display/font.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/font.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,701 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/font.h&quot;
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Display/display_window.h&quot;
+#include &quot;API/Display/graphic_context.h&quot;
+#include &quot;API/Display/glyph_buffer.h&quot;
+#include &quot;API/Display/color.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;font_generic.h&quot;
+#include &quot;font_target.h&quot;
+#include &quot;font_target_sprite.h&quot;
+#include &quot;resourcedata_font.h&quot;
+#include &quot;display_target.h&quot;
+#include &lt;algorithm&gt;
+#include &lt;cmath&gt;
+#include &lt;memory&gt;
+#include &lt;utility&gt;
+
+#define cl_min(a,b) ((a &lt; b) ? a : b)
+#define cl_max(a,b) ((a &gt; b) ? a : b)
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Font construction:
+
+CL_Font::CL_Font()
+{
+}
+
+CL_Font::CL_Font(const CL_Font &amp;copy)
+: impl(copy.impl)
+{
+	resource = copy.resource;
+	resource.load();
+}
+
+CL_Font::CL_Font(
+	const std::string &amp;resource_id,
+	CL_ResourceManager *manager)
+{
+	resource = manager-&gt;get_resource(resource_id);
+	resource.load();
+	
+	CL_ResourceData_Font *data = (CL_ResourceData_Font *) resource.get_data(&quot;font&quot;);
+
+	if (!data)
+		throw CL_Error(&quot;Resource '&quot; + resource_id + &quot;' is not of type 'font'&quot;);
+
+	operator=(data-&gt;get_font());
+}
+
+CL_Font::CL_Font(
+	const CL_Sprite &amp;letters,
+	const std::string &amp;letter_chars,
+	int space_width,
+	bool monospace)
+: impl(new CL_Font_Generic)
+{
+	impl-&gt;target = CL_SharedPtr&lt;CL_Font_Target&gt;(
+		new CL_Font_Target_Sprite(
+			impl.get(),
+			letters,
+			letter_chars,
+			space_width,
+			monospace));
+}
+
+CL_Font::CL_Font(
+	const std::string &amp;font_name,
+	int height,
+	int width,
+	bool bold,
+	bool italic,
+	bool underline,
+	bool strikeout)
+: impl(new CL_Font_Generic)
+{
+	//First thirty two characters are undrawable in ASCII
+	std::string letters;
+	letters.reserve(256-32);
+	for (int x = 32; x &lt; 256; ++x)
+		letters.append(1, (unsigned int)(x));
+
+	impl-&gt;target = CL_SharedPtr&lt;CL_Font_Target&gt;(
+		CL_DisplayTarget::current()-&gt;create_system_font_target(
+			impl.get(),
+			font_name,
+			letters,
+			height,
+			width,
+			bold,
+			italic,
+			underline,
+			strikeout));
+}
+
+CL_Font::CL_Font(
+	const std::string &amp;font_name,
+	const std::string &amp;letter_chars,
+	int height,
+	int width,
+	bool bold,
+	bool italic,
+	bool underline,
+	bool strikeout)
+: impl(new CL_Font_Generic)
+{
+	impl-&gt;target = CL_SharedPtr&lt;CL_Font_Target&gt;(
+		CL_DisplayTarget::current()-&gt;create_system_font_target(
+			impl.get(),
+			font_name,
+			letter_chars,
+			height,
+			width,
+			bold,
+			italic,
+			underline,
+			strikeout));
+}
+
+CL_Font::~CL_Font()
+{
+	resource.unload();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Font attributes:
+
+std::string CL_Font::get_delims() const
+{
+	return impl-&gt;delims;
+}
+
+int CL_Font::get_width_offset() const
+{
+	return impl-&gt;width_offset;
+}
+
+int CL_Font::get_height_offset() const
+{
+	return impl-&gt;height_offset;
+}
+
+void CL_Font::get_scale(float &amp;x, float &amp;y) const
+{
+	impl-&gt;target-&gt;get_scale(x, y);
+}
+
+float CL_Font::get_alpha() const
+{
+	return impl-&gt;target-&gt;get_alpha();
+}
+
+void CL_Font::get_color(float &amp;red, float &amp;green, float &amp;blue, float &amp;alpha) const
+{
+	impl-&gt;target-&gt;get_color(red, green, blue, alpha);
+}
+
+CL_Color CL_Font::get_color() const
+{
+	float r,g,b,a;
+	get_color(r, g, b, a);
+	return CL_Color(int(r*255.0f), int(g*255.0f), int(b*255.0f), int(a*255.0f));
+}
+
+void CL_Font::get_blend_func(CL_BlendFunc &amp;src, CL_BlendFunc &amp;dest) const
+{
+	impl-&gt;target-&gt;get_blend_func(src, dest);
+}
+
+void CL_Font::get_glyph_rot_hotspot(CL_Origin &amp;origin, int &amp;x, int &amp;y) const
+{
+	impl-&gt;target-&gt;get_rot_hotspot(origin, x, y);
+}
+
+void CL_Font::get_alignment(CL_Origin &amp;origin, int &amp;x, int &amp;y) const
+{
+	origin = impl-&gt;trans_origin;
+	x = impl-&gt;trans_x;
+	y = impl-&gt;trans_y;
+}
+
+int CL_Font::get_height() const
+{
+	return impl-&gt;target-&gt;get_height();
+}
+
+int CL_Font::get_height(const std::string &amp;str, CL_Size max_size) const
+{
+	return get_size(str, max_size).height;
+}
+
+int CL_Font::get_height(
+	std::string::const_iterator start,
+	std::string::const_iterator end,
+	CL_Size max_size) const
+{
+	return get_size(start, end, max_size).height;
+}
+
+int CL_Font::get_width(unsigned int letter) const
+{
+	return impl-&gt;target-&gt;get_width(letter);
+}
+
+int CL_Font::get_width(
+	const std::string &amp;str,
+	CL_Size max_size) const
+{
+	return get_size(str, max_size).width;
+}
+
+int CL_Font::get_width(
+	std::string::const_iterator start,
+	std::string::const_iterator end,
+	CL_Size max_size) const
+{
+	return get_size(start, end, max_size).width;
+}
+
+CL_Size CL_Font::get_size(
+	std::string::const_iterator start,
+	std::string::const_iterator end,
+	CL_Size max_size) const
+{
+	CL_GlyphBuffer gb;
+	draw_to_gb(start, end, gb, max_size);
+	return gb.get_size();
+}
+
+CL_Size CL_Font::get_size(unsigned int letter) const
+{
+	return CL_Size(get_width(letter), get_height());
+}
+
+CL_Size CL_Font::get_size(
+	const std::string &amp;str,
+	CL_Size max_size) const
+{
+	return get_size(str.begin(), str.end(), max_size);
+}
+
+CL_Rect CL_Font::bounding_rect(
+	CL_Rect dest,
+	std::string::const_iterator start,
+	std::string::const_iterator end) const
+{
+	CL_GlyphBuffer gb;
+	draw_to_gb(start, end, gb, dest.get_size());
+	gb.set_alignment(impl-&gt;trans_origin, impl-&gt;trans_x, impl-&gt;trans_y);
+	return gb.bounding_rect(dest);
+}
+
+CL_Rect CL_Font::bounding_rect(int x, int y, const std::string &amp;str) const
+{
+	return bounding_rect(CL_Rect(x, y, x, y), str.begin(), str.end());
+}
+
+CL_Rect CL_Font::bounding_rect(CL_Rect dest, const std::string &amp;str) const
+{
+	return bounding_rect(dest, str.begin(), str.end());
+}
+
+CL_Rect CL_Font::bounding_rect(
+	int x, int y,
+	std::string::const_iterator start,
+	std::string::const_iterator end) const
+{
+	return bounding_rect(CL_Rect(x, y, x, y), start, end);
+}
+
+bool CL_Font::is_glyph(unsigned int chr) const
+{
+	return impl-&gt;target-&gt;is_glyph(chr);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Font operations:
+
+CL_Font &amp;CL_Font::operator =(const CL_Font &amp;copy)
+{
+	impl = copy.impl;
+	
+	resource.unload();
+	resource = copy.resource;
+	resource.load();
+
+	return *this;
+}
+
+CL_Font::operator bool() const
+{
+	return (impl.get() != 0);
+}
+
+int CL_Font::draw(
+	CL_Rect dest,
+	std::string::const_iterator start,
+	std::string::const_iterator end,
+	CL_GraphicContext *context) const
+{
+	if (context == 0)
+		context = CL_Display::get_current_window()-&gt;get_gc();
+	
+	CL_GlyphBuffer gb;
+	int dist = draw_to_gb(start, end, gb, dest.get_size());
+	gb.set_alignment(impl-&gt;trans_origin, impl-&gt;trans_x, impl-&gt;trans_y);
+	
+	if (impl-&gt;trans_origin == origin_top_left)
+		gb.fixed_draw(dest.left - impl-&gt;trans_x, dest.top - impl-&gt;trans_y, context);
+	else
+		gb.draw(dest, context);
+	
+	return dist;
+}
+
+int CL_Font::draw(
+	int x, int y,
+	const std::string &amp;str,
+	CL_GraphicContext *context) const
+{
+	return draw(CL_Rect(x, y, x, y), str.begin(), str.end(), context);
+}
+
+int CL_Font::draw(
+	CL_Rect dest,
+	const std::string &amp;str,
+	CL_GraphicContext *context) const
+{
+	return draw(dest, str.begin(), str.end(), context);
+}
+
+int CL_Font::draw(
+	int x, int y,
+	std::string::const_iterator start,
+	std::string::const_iterator end,
+	CL_GraphicContext *context) const
+{
+	return draw(CL_Rect(x, y, x, y), start, end, context);
+}
+
+//Given a CL_GlyphBuffer, ensures that a given line is flush with the line above it
+//Returns the offset that was applied
+int squish_line(CL_GlyphBuffer&amp; gb, CL_GlyphBuffer::Range line)
+{
+	std::vector&lt;CL_GlyphBuffer::Glyph&gt;&amp; glyphs = gb.get_glyphs();
+
+	if (line.start &lt;= line.end)
+		return 0;
+	
+	if (glyphs.size() != 0 &amp;&amp; line.start != 0)
+	{
+		int dist; //The offset we'll apply to y ord of each glyph in the line
+		
+		int curline_top = gb.internal_rect(line).top;
+		if (curline_top == 0)
+			return 0;
+		
+		if (line.start != 0)
+		{
+			int prevline_bottom = gb.internal_rect(gb.get_line(line.start-1)).bottom;
+			
+			if (prevline_bottom == 0)
+				return 0;
+			else
+				dist = prevline_bottom - curline_top; 
+		}
+		else
+		{
+			dist = -curline_top; //Move to 0
+		}
+		
+		for (int x = line.start; x != line.end; ++x)
+			glyphs[x].pos.y += dist;
+
+		return dist;
+	}
+	
+	return 0;
+}
+
+int CL_Font::draw_to_gb(
+	std::string::const_iterator start,
+	std::string::const_iterator end,
+	CL_GlyphBuffer &amp;gb,
+	CL_Size max_size) const
+{
+	std::vector&lt;CL_GlyphBuffer::Glyph&gt;&amp; glyphs = gb.get_glyphs(); //Shortcut to the glyphs vector in the gb
+	const int font_height = impl-&gt;target-&gt;get_height(); //Distance to move at carriage feed
+	const int orig_size = glyphs.size(); //Size of the glyphs vector before we start messing with it
+	
+	//Barf if things look evil
+	if (
+		start &gt;= end ||
+		font_height &lt;= 0 ||
+		max_size.height &lt; 0 ||
+		max_size.width &lt; 0)
+	{
+		return 0;
+	}
+	
+	CL_Point pos(0, 0); //Drawing position, at the top of the current line
+	int line_height = font_height;//Height of the current line
+	int line_start = 0; //Index of the character beginning the current line
+	bool squishing = false; //True if we need to do squishing (if there's fonts of differing height on this line)
+	
+	//If we aren't starting at the beginning of a line, then we need to compensate
+	//Either the line is taller than this font, which means any new glyphs we add on this line need to be pushed down
+	//Or this font is taller than previous glyphs on the line, which means we need to move down the previous glyphs
+	if (glyphs.size() != 0)
+	{
+		const CL_GlyphBuffer::Range eline(gb.get_line(glyphs.size()-1)); //Glyphs in the final existing GB line
+		const CL_Rect eline_rect(gb.internal_rect(eline, false)); //Rectangle of eline, incl. invis glyphs
+		
+		//Place pos directly after the last glyph in the buffer
+		pos.x = eline_rect.right;
+		pos.y = eline_rect.top;
+		
+		//If glyphs already on this line are taller than this font, then adjust height for this line
+		if (eline_rect.get_height() &gt; font_height)
+			line_height = eline_rect.get_height();
+		
+		//If the last character of that line is a newline, do a carriage return
+		//If it isn't, and our font is taller than previous glyphs on the line, then move those glyphs down to match
+		if (glyphs[eline.end-1].character == '\n') {
+			//Carriage return
+			pos.x = 0;
+			pos.y += line_height;
+		}
+		else if (eline_rect.get_height() &lt; font_height)
+		{
+			//If we have enough room, move the existing glyphs down to meet our baseline
+			if (max_size.height == 0 || pos.y + font_height &lt;= max_size.height)
+				for (int x = eline.start; x &lt; eline.end; ++x)
+					glyphs[x].pos.y += font_height - eline_rect.get_height();
+		}
+		
+		line_start = gb.get_line(glyphs.size()-1).start;
+
+		if (line_height != font_height)
+			squishing = true;
+	}
+	
+	//If inserting the first glyph would go over the height limit, end the draw now
+	if (max_size.height != 0 &amp;&amp; pos.y + font_height &gt; max_size.height)
+	{
+		if (squishing)
+			squish_line(gb, CL_GlyphBuffer::Range(line_start, glyphs.size()));
+		
+		return 0;
+	}
+	
+	//Put a marker for this font into the GB, and reserve a bit of space in the GB's glyph vector
+	gb.change_font(*this);
+	glyphs.reserve(cl_min(end - start, 1000));
+	
+	//For every character in the input range (or as far through that range as we can get)
+	for (std::string::const_iterator it = start; it != end; ++it)
+	{
+		const unsigned int chr = ((unsigned char) *it); // The character this glyph represents
+		const int gwidth = get_width(chr); //Width of the glyph
+		
+		//If a character is wider than max width, stop the presses
+		if (max_size.width != 0 &amp;&amp; gwidth &gt; max_size.width)
+		{
+			if (squishing)
+				squish_line(gb, CL_GlyphBuffer::Range(line_start, glyphs.size()));
+			
+			return glyphs.size() - orig_size;
+		}
+		
+		//If this character extends over the wrapping border, and word wrapping is on, and it has a glyph...
+		if (max_size.width != 0 &amp;&amp; pos.x + gwidth &gt; max_size.width &amp;&amp; is_glyph(chr))
+		{
+			//Carriage return
+			pos.x = 0;
+			pos.y += line_height;
+			line_height = font_height;
+			
+			//Try to find a delimiter on the last line
+			int delim_idx = -1;
+			for (int glyph_idx = glyphs.size()-1; glyph_idx &gt;= line_start; --glyph_idx)
+			{
+				if (
+					impl-&gt;delims.find(glyphs[glyph_idx].character) != std::string::npos &amp;&amp;
+					(!is_glyph(glyph_idx) || gb.internal_rect(glyph_idx).right &lt;= max_size.width)
+				)
+				{
+					delim_idx = glyph_idx;
+					break;
+				}
+			}
+			
+			//If this line has a delimiter...
+			if (delim_idx != -1)
+			{
+				//Height of glyphs after the delimiter
+				int wrapline_height = gb.get_height(CL_GlyphBuffer::Range(delim_idx+1, glyphs.size()));
+				
+				//Height of the line we're wrapping the text onto, which becomes the new last line
+				line_height = cl_max(wrapline_height, font_height);
+				
+				//If we don't have enough vertical room to wrap glyphs here, end the draw
+				if (max_size.height != 0 &amp;&amp; pos.y + line_height &gt; max_size.height)
+				{
+					//Clip out that final partial word
+					gb.remove(CL_GlyphBuffer::Range(delim_idx + 1, glyphs.size()));
+					
+					if (squishing)
+						squish_line(gb, CL_GlyphBuffer::Range(line_start, glyphs.size()));
+								
+					return glyphs.size() - orig_size;
+				}
+				else
+				{
+					//Move glyphs after the delimiter onto the next line, move pos right after them
+					std::vector&lt;CL_GlyphBuffer::Glyph&gt;::size_type x;
+					for (x = delim_idx + 1; x != glyphs.size(); ++x)
+					{
+						glyphs[x].pos = CL_Point(pos.x, glyphs[x].pos.y + line_height);
+						pos.x += gb.get_width(static_cast&lt;int&gt;(x));
+					}
+					
+					//Remove excess vertical space from the previous-to-last-line
+					//Move the cursor and the line segment we just wrapped up to compensate
+					if (squishing)
+					{
+						int squishdist = squish_line(gb, CL_GlyphBuffer::Range(line_start, delim_idx+1));
+						pos.y += squishdist;
+						for (x = delim_idx + 1; x != glyphs.size(); ++x)
+							glyphs[x].pos.y += squishdist;
+					}
+					
+					line_start = delim_idx + 1;
+					squishing = false;
+				}
+			}
+			//This line doesn't have a delimiter, so we have to break in the middle of a word
+			else
+			{
+				//Remove any excess vertical space on the last line, move cursor to compensate
+				if (squishing)
+					pos.y += squish_line(gb, CL_GlyphBuffer::Range(line_start, glyphs.size()));
+				
+				line_start = glyphs.size();
+				squishing = false;
+				
+				//If we don't have enough vertical room to put any glyphs here, end the draw
+				if (max_size.height != 0 &amp;&amp; pos.y + line_height &gt; max_size.height)
+					return glyphs.size() - orig_size;
+			}
+		}
+		
+		//Insert the glyph
+		glyphs.push_back(CL_GlyphBuffer::Glyph(
+			CL_Point(pos.x, pos.y + (line_height - font_height)), 
+			chr));
+		
+		//Advance the cursor
+		pos.x += gwidth;
+		
+		//If this character is a newline
+		if (chr == '\n')
+		{
+			//Carriage return
+			pos.x = 0;
+			pos.y += line_height;
+			line_height = font_height;
+			
+			//Remove excess vertical space, adjust cursor to compensate
+			if (squishing)
+				pos.y += squish_line(gb, CL_GlyphBuffer::Range(line_start, glyphs.size()));
+			
+			line_start = glyphs.size();
+			squishing = false;
+			
+			//If we've exceeded height, then end the draw
+			if (max_size.height != 0 &amp;&amp; pos.y + line_height &gt; max_size.height)
+				return glyphs.size() - orig_size;
+		}
+	}
+	
+	//We made it through the entire input string, huzzah
+	if (squishing)
+		squish_line(gb, CL_GlyphBuffer::Range(line_start, glyphs.size()));
+	
+	return glyphs.size() - orig_size;
+}
+
+int CL_Font::draw_to_gb(
+	const std::string &amp;str,
+	CL_GlyphBuffer &amp;gb,
+	CL_Size max_size) const
+{
+	return draw_to_gb(str.begin(), str.end(), gb, max_size);
+}
+
+void CL_Font::draw_glyph(int x, int y, unsigned int glyph, float ang, CL_GraphicContext *gc)
+{
+	if (gc == 0) gc = CL_Display::get_current_window()-&gt;get_gc();
+	impl-&gt;target-&gt;draw_glyph(x, y, glyph, ang, gc);
+}
+
+void CL_Font::draw_character(int x, int y, unsigned int chr, float ang, CL_GraphicContext *gc)
+{
+	if (gc == 0) gc = CL_Display::get_current_window()-&gt;get_gc();
+	impl-&gt;target-&gt;draw_character(x, y, chr, ang, gc);
+}
+
+void CL_Font::set_delims(const std::string&amp; delims)
+{
+	impl-&gt;delims = delims;
+}
+
+void CL_Font::set_width_offset(int offset)
+{
+	impl-&gt;width_offset = offset;
+}
+
+void CL_Font::set_height_offset(int offset)
+{
+	impl-&gt;height_offset = offset;
+}
+
+void CL_Font::set_scale(float x, float y)
+{
+	impl-&gt;target-&gt;set_scale(x, y);
+}
+
+void CL_Font::set_alpha(float alpha)
+{
+	impl-&gt;target-&gt;set_alpha(alpha);
+}
+
+void CL_Font::set_color(float r, float g, float b, float a)
+{
+	impl-&gt;target-&gt;set_color(r, g, b, a);
+}
+
+void CL_Font::set_color(const CL_Color&amp; c)
+{
+	set_color(float(c.get_red())/255.0f, float(c.get_green())/255.0f, float(c.get_blue())/255.0f, float(c.get_alpha())/255.0f);
+}
+
+void CL_Font::set_blend_func(CL_BlendFunc src, CL_BlendFunc dest)
+{
+	impl-&gt;target-&gt;set_blend_func(src, dest);
+}
+
+void CL_Font::set_glyph_rot_hotspot(CL_Origin origin, int x, int y)
+{
+	impl-&gt;target-&gt;set_rot_hotspot(origin, x, y);
+}
+
+void CL_Font::set_alignment(CL_Origin origin, int x, int y)
+{
+	impl-&gt;trans_origin = origin;
+	impl-&gt;trans_x = x;
+	impl-&gt;trans_y = y;
+}
+
+CL_Sprite&amp; CL_Font::get_glyphs()
+{
+	CL_Font_Target* target = impl-&gt;target;
+	
+	CL_Font_Target_Sprite* sprite_target =
+		static_cast&lt;CL_Font_Target_Sprite*&gt;(target);
+	
+	return sprite_target-&gt;get_glyphs();	
+}
+

Added: trunk/clanlib/Display/font_generic.cpp
===================================================================
--- trunk/clanlib/Display/font_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/font_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,66 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;font_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Font_Generic construction:
+
+CL_Font_Generic::CL_Font_Generic() :
+	width_offset(0),
+	height_offset(0),
+	trans_origin(origin_top_left),
+	trans_x(0),
+	trans_y(0),
+	delims(&quot; &quot;)
+{
+}
+
+CL_Font_Generic::CL_Font_Generic(const CL_Font_Generic &amp;copy) :
+	width_offset(copy.width_offset),
+	height_offset(copy.height_offset),
+	trans_origin(copy.trans_origin),
+	trans_x(copy.trans_x),
+	trans_y(copy.trans_y),
+	delims(copy.delims),
+	target(copy.target)
+{
+}
+
+CL_Font_Generic::~CL_Font_Generic()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Font_Generic attributes:
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Font_Generic operations:

Added: trunk/clanlib/Display/font_generic.h
===================================================================
--- trunk/clanlib/Display/font_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/font_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,88 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_font_generic
+#define header_font_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Display/sprite.h&quot;
+#include &quot;API/Core/Math/origin.h&quot;
+#include &quot;API/Display/font.h&quot;
+#include &quot;API/Core/Math/point.h&quot;
+#include &quot;API/Core/System/clonable.h&quot;
+#include &lt;string&gt;
+
+class CL_GraphicContext;
+class CL_GlyphBuffer;
+class CL_Size;
+class CL_Rect;
+class CL_Font_Target;
+
+class CL_Font_Generic : public CL_Clonable
+{
+//! Construction:
+public:
+	CL_Font_Generic(); 
+
+	CL_Font_Generic(const CL_Font_Generic &amp;copy);
+	
+	virtual ~CL_Font_Generic();
+
+//! Attributes:
+public:
+	//: Alters the percieved width of each glyph
+	int width_offset;
+	
+	//: Alters the percieved height of each line
+	int height_offset;
+	
+	//: Alignment
+	CL_Origin trans_origin;
+
+	int trans_x;
+	
+	int trans_y;
+	
+	//: A list of characters (other than the newline character) that seperate words
+	std::string delims;
+
+	CL_SharedPtr&lt;CL_Font_Target&gt; target;
+	
+//! Operations:
+public:
+	virtual CL_Clonable *clone() const { return new CL_Font_Generic(*this); }
+
+//! Implementation
+private:
+};
+
+#endif

Added: trunk/clanlib/Display/font_target.h
===================================================================
--- trunk/clanlib/Display/font_target.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/font_target.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,120 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_font_target
+#define header_font_target
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Display/blend_func.h&quot;
+#include &quot;API/Core/Math/origin.h&quot;
+
+class CL_Font_Generic;
+class CL_GraphicContext;
+
+class CL_API_DISPLAY CL_Font_Target
+{
+//! Construction:
+public:
+	CL_Font_Target(CL_Font_Generic *attributes) : attributes(attributes) { return; }
+
+	virtual ~CL_Font_Target() { return; }
+
+//! Attributes:
+public:
+	//: If 0, variable width font. If another number, all characters are this width
+	virtual int get_fixed_width() const=0;
+	
+	//: Gets the width of a single glyph directly from the map, including scaling and offsets
+	virtual int get_width(unsigned int chr) const=0;
+	
+	//: Gets the height of the font, including scaling and offsets
+	virtual int get_height() const=0;
+
+	//: Returns true if the given character has any associated glyph
+	virtual bool is_glyph(unsigned int chr) const=0;
+
+	virtual void get_scale(float&amp; x, float&amp; y) const=0;
+
+	virtual float get_alpha() const=0;
+	
+	virtual void get_color(float&amp; r, float&amp; g, float&amp; b, float&amp; a) const=0;
+	
+	virtual void get_blend_func(CL_BlendFunc &amp;src, CL_BlendFunc &amp;dest) const=0;
+	
+	virtual void get_rot_hotspot(CL_Origin &amp;origin, int &amp;x, int &amp;y) const=0;
+
+protected:
+	CL_Font_Generic *attributes;
+
+//! Operations:
+public:
+	virtual void set_scale(float x, float y)=0;
+
+	virtual void set_alpha(float a)=0;
+
+	virtual void set_color(float r, float g, float b, float a)=0;
+
+	virtual void set_blend_func(CL_BlendFunc src, CL_BlendFunc dest)=0;
+
+	virtual void set_rot_hotspot(CL_Origin origin, int x, int y)=0;
+
+	//: Draws a glyph at a given location.
+	//param x, y: The upper-left coordinates of where to draw the glyph.
+	//param chr: The character to draw the glyph of.
+	//param ang: The amount to rotate the glyph by. The hotspot is set with CL_Font::set_glyph_rot_hotspot().
+	//param gc: Graphic context to render to.
+	//- &lt;p&gt; If there is no such glyph for that character, nothing is drawn. &lt;/p&gt;
+	virtual void draw_glyph(int x, int y, unsigned int chr, float ang, CL_GraphicContext *gc) const=0;
+
+	//: Draws a single character to a given spot.
+	//param x, y: The upper-left coordinates of where to draw the character.
+	//param chr: The character to draw the glyph of.
+	//param ang: The amount to rotate the glyph by. The hotspot is set with CL_Font::set_glyph_rot_hotspot().
+	//param gc: Graphic context to render to.
+	//- &lt;p&gt; If there is no glyph for the given character, then nothing is drawn. &lt;/p&gt;
+	virtual void draw_character(int x, int y, unsigned int chr, float ang, CL_GraphicContext *gc) const=0;
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/Display/font_target_sprite.cpp
===================================================================
--- trunk/clanlib/Display/font_target_sprite.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/font_target_sprite.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,275 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;font_target_sprite.h&quot;
+#include &quot;font_generic.h&quot;
+#include &quot;API/Core/Math/size.h&quot;
+#include &quot;API/Core/Math/rect.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/Display/sprite.h&quot;
+#include &lt;cmath&gt;
+#include &lt;algorithm&gt;
+#include &lt;vector&gt;
+
+#define cl_min(a,b) ((a &lt; b) ? a : b)
+#define cl_max(a,b) ((a &gt; b) ? a : b)
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Font_Target_Sprite construction:
+
+CL_Font_Target_Sprite::CL_Font_Target_Sprite(
+	CL_Font_Generic *attributes,
+	const CL_Sprite &amp;new_glyphs,
+	const std::string &amp;letters,
+	int new_spacelen,
+	bool monospace)
+: CL_Font_Target(attributes)
+{
+	fixed_width = 0;
+	height = 0;
+
+	//Size of char limit on most platforms is 256
+	const int length = cl_min((int)(letters.size()), 256);
+	
+	if ((length &gt; new_glyphs.get_frame_count()) || (length == 0))
+	{
+		throw CL_Error(
+			CL_String::format(
+				&quot;Font error: Letter characters: %1, Available font glyphs: %2&quot;, 
+				length,
+				new_glyphs.get_frame_count()));
+	}
+	
+	//If monospace font requested, find the width of the widest glyph
+	//Then set the fixed_width var to that width, which gwidth() checks for
+	//Also set space to that width
+	if (monospace)
+	{
+		for (short i=0; i &lt; length; ++i)
+		{
+			int glyph_width = new_glyphs.get_frame_size(i).width;
+			if (glyph_width &gt; fixed_width)
+				fixed_width = glyph_width;
+		}
+		
+		new_spacelen = fixed_width;
+	}
+	//If not monospace, and space width not specified, then use average width as space width
+	else if (new_spacelen &lt; 0)
+	{
+		std::string::size_type space_pos = letters.find(' ');
+		
+		if (space_pos != std::string::npos)
+		{
+			//If there is a character for space, then use it
+			new_spacelen = new_glyphs.get_frame_size((int)space_pos).width;
+		}
+		else
+		{
+			//Make the space size the average of all character sizes
+			new_spacelen = 0;
+			
+			for (int pos = 0; pos &lt; length; ++pos)
+			{
+				new_spacelen += new_glyphs.get_frame_size((int)(pos)).width;
+			}
+			
+			new_spacelen /= length;
+		}
+	}
+	
+	for (short i=0; i &lt; length; ++i)
+	{
+		int glyph_height = new_glyphs.get_frame_size(i).height;
+		if (glyph_height &gt; height)
+			height = glyph_height;
+	}
+	
+	glyphs = new_glyphs;
+	glyphs.set_alignment(origin_top_left, 0, 0);
+	glyphs.set_rotation_hotspot(origin_top_left, 0, 0);
+	spacelen = new_spacelen;
+	
+	//If monospace font requested, find the width of the widest glyph
+	//Then set the fixed_width var to that width, which gwidth() checks for
+	if (monospace)
+	{
+		for (short i=0; i &lt; length; ++i)
+		{
+			int glyph_width = new_glyphs.get_frame_size(i).width;
+			if (glyph_width &gt; fixed_width)
+				fixed_width = glyph_width;
+		}
+	}	
+
+	// Setup char to glyph map:
+
+	char_to_glyph_map.reserve(256);
+	for (int index = 0; index &lt; 256; index++) char_to_glyph_map.push_back(static_cast&lt;unsigned int&gt;(-1));
+
+	std::string::const_iterator it = letters.begin();
+	for (unsigned short index_letters=0; index_letters &lt; letters.length(); ++index_letters)
+	{
+		unsigned int letter = ((unsigned char)*it);
+		char_to_glyph_map[letter] = index_letters;
+		++it;
+	}
+}
+
+CL_Font_Target_Sprite::~CL_Font_Target_Sprite()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Font_Target_Sprite attributes:
+
+int CL_Font_Target_Sprite::get_fixed_width() const
+{
+	return fixed_width;
+}
+
+int CL_Font_Target_Sprite::get_width(unsigned int chr) const
+{
+	if (chr == '\n')
+		return 0;
+	
+	int width = attributes-&gt;width_offset;
+	
+	if (fixed_width != 0)
+	{
+		width += fixed_width;
+	}
+	else
+	{
+		short glyph_num = char_to_glyph_map[chr];
+		if (glyph_num != -1)
+			width += glyphs.get_frame_size(glyph_num).width;
+		else
+			width += spacelen;
+	}
+	
+	float scale_x, scale_y;
+	get_scale(scale_x, scale_y);
+	return cl_max(0, (int)(width*scale_x));
+}
+
+int CL_Font_Target_Sprite::get_height() const
+{
+	float scale_x, scale_y;
+	get_scale(scale_x, scale_y);
+	
+	return (int)((height + attributes-&gt;height_offset) * scale_y);
+}
+
+bool CL_Font_Target_Sprite::is_glyph(unsigned int chr) const
+{
+	if (char_to_glyph_map[chr] == static_cast&lt;unsigned int&gt;(-1))
+		return false;
+	
+	return true;
+}
+
+void CL_Font_Target_Sprite::get_scale(float&amp; x, float&amp; y) const
+{
+	glyphs.get_scale(x, y);
+}
+
+float CL_Font_Target_Sprite::get_alpha() const
+{
+	return glyphs.get_alpha();
+}
+
+void CL_Font_Target_Sprite::get_color(float&amp; r, float&amp; g, float&amp; b, float&amp; a) const
+{
+	glyphs.get_color(r, g, b, a);
+}
+
+void CL_Font_Target_Sprite::get_blend_func(CL_BlendFunc &amp;src, CL_BlendFunc &amp;dest) const
+{
+	glyphs.get_blend_func(src, dest);
+}
+
+void CL_Font_Target_Sprite::get_rot_hotspot(CL_Origin &amp;origin, int &amp;x, int &amp;y) const
+{
+	glyphs.get_rotation_hotspot(origin, x, y);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Font_Target_Sprite operations:
+
+void CL_Font_Target_Sprite::set_scale(float x, float y)
+{
+	glyphs.set_scale(x, y);
+}
+
+void CL_Font_Target_Sprite::set_alpha(float a)
+{
+	glyphs.set_alpha(a);
+}
+
+void CL_Font_Target_Sprite::set_color(float r, float g, float b, float a)
+{
+	glyphs.set_color(r, g, b, a);
+}
+
+void CL_Font_Target_Sprite::set_blend_func(CL_BlendFunc src, CL_BlendFunc dest)
+{
+	glyphs.set_blend_func(src, dest);
+}
+
+void CL_Font_Target_Sprite::set_rot_hotspot(CL_Origin origin, int x, int y)
+{
+	glyphs.set_rotation_hotspot(origin, x, y);
+}
+
+void CL_Font_Target_Sprite::draw_glyph(int x, int y, unsigned int glyph_index, float ang, CL_GraphicContext *gc) const
+{
+	if (glyph_index != static_cast&lt;unsigned int&gt;(-1))
+	{
+		if (ang != 0.0)
+			glyphs.rotate(ang);
+		
+		glyphs.set_frame(glyph_index);
+		glyphs.draw(x, y, gc);
+
+		if (ang != 0.0)
+			glyphs.rotate(-ang);
+	}
+}
+
+void CL_Font_Target_Sprite::draw_character(int x, int y, unsigned int chr, float ang, CL_GraphicContext *gc) const
+{
+	short glyph_num = char_to_glyph_map[chr];
+	if (glyph_num != -1) draw_glyph(x, y, glyph_num, ang, gc);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Font_Target_Sprite implementation:

Added: trunk/clanlib/Display/font_target_sprite.h
===================================================================
--- trunk/clanlib/Display/font_target_sprite.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/font_target_sprite.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,137 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_font_target_sprite
+#define header_font_target_sprite
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;font_target.h&quot;
+#include &quot;API/Display/sprite.h&quot;
+#include &lt;string&gt;
+#include &lt;vector&gt;
+
+class CL_API_DISPLAY CL_Font_Target_Sprite : public CL_Font_Target
+{
+//! Construction:
+public:
+	CL_Font_Target_Sprite(
+		CL_Font_Generic *attributes,
+		const CL_Sprite &amp;letters,
+		const std::string &amp;letter_chars,
+		int space_width = -1,
+		bool monospace = false);
+
+	~CL_Font_Target_Sprite();
+
+//! Attributes:
+public:
+	//: If 0, variable width font. If another number, all characters are this width
+	int get_fixed_width() const;
+	
+	//: Gets the width of a single glyph directly from the map, including scaling and offsets
+	int get_width(unsigned int chr) const;
+	
+	//: Gets the height of the font, including scaling and offsets
+	int get_height() const;
+
+	//: Returns true if the given character has any associated glyph
+	bool is_glyph(unsigned int chr) const;
+
+	void get_scale(float&amp; x, float&amp; y) const;
+
+	float get_alpha() const;
+	
+	void get_color(float&amp; r, float&amp; g, float&amp; b, float&amp; a) const;
+	
+	void get_blend_func(CL_BlendFunc &amp;src, CL_BlendFunc &amp;dest) const;
+	
+	void get_rot_hotspot(CL_Origin &amp;origin, int &amp;x, int &amp;y) const;
+
+//! Operations:
+public:
+	void set_scale(float x, float y);
+
+	void set_alpha(float a);
+
+	void set_color(float r, float g, float b, float a);
+
+	void set_blend_func(CL_BlendFunc src, CL_BlendFunc dest);
+
+	void set_rot_hotspot(CL_Origin origin, int x, int y);
+
+	//: Draws a glyph at a given location.
+	//param x, y: The upper-left coordinates of where to draw the glyph.
+	//param chr: The character to draw the glyph of.
+	//param ang: The amount to rotate the glyph by. The hotspot is set with CL_Font::set_glyph_rot_hotspot().
+	//param gc: Graphic context to render to.
+	//- &lt;p&gt; If there is no such glyph for that character, nothing is drawn. &lt;/p&gt;
+	void draw_glyph(int x, int y, unsigned int chr, float ang, CL_GraphicContext *gc) const;
+
+	//: Draws a single character to a given spot.
+	//param x, y: The upper-left coordinates of where to draw the character.
+	//param chr: The character to draw the glyph of.
+	//param ang: The amount to rotate the glyph by. The hotspot is set with CL_Font::set_glyph_rot_hotspot().
+	//param gc: Graphic context to render to.
+	//- &lt;p&gt; If there is no glyph for the given character, then nothing is drawn. &lt;/p&gt;
+	void draw_character(int x, int y, unsigned int chr, float ang, CL_GraphicContext *gc) const;
+
+	inline CL_Sprite&amp; get_glyphs() { return glyphs; }
+	
+//! Implementation:
+private:
+	//: Character to glyph map.
+	std::vector&lt;unsigned int&gt; char_to_glyph_map;
+
+	//: Glyphs of the actual characters.
+	mutable CL_Sprite glyphs;
+	
+	//: Height of font (i.e. height of the tallest character, before scaling/offsets)
+	int height;
+	
+	//: If 0, variable width font. If another number, all characters are this width
+	int fixed_width;
+
+	//: Distance to go at any unrecognized character, before scaling/offsets
+	int spacelen;
+};
+
+#endif

Added: trunk/clanlib/Display/frameratecounter.cpp
===================================================================
--- trunk/clanlib/Display/frameratecounter.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/frameratecounter.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,95 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/frameratecounter.h&quot;
+#include &quot;API/Core/System/system.h&quot;
+#include &quot;frameratecounter_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_FramerateCounter construction:
+
+CL_FramerateCounter::CL_FramerateCounter()
+: impl(new CL_FramerateCounter_Generic)
+{
+	impl-&gt;start_time = CL_System::get_time();
+	impl-&gt;total_time = 0;
+	impl-&gt;frame_time = 0;
+	impl-&gt;fps_result = 0;
+	impl-&gt;fps_counter = 0;
+}
+
+CL_FramerateCounter::~CL_FramerateCounter ()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_FramerateCounter attributes:
+
+int CL_FramerateCounter::get_fps()
+{
+	return impl-&gt;fps_result;
+}
+
+void CL_FramerateCounter::set_fps_limit(int fps) 
+{
+	if (fps &gt; 0)
+		impl-&gt;frame_time = 1000 / fps;
+	else
+		impl-&gt;frame_time = 0;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_FramerateCounter implementation:
+
+void CL_FramerateCounter::keep_alive()
+{
+	int cur_time = CL_System::get_time();
+	int delta_time = cur_time - impl-&gt;start_time;
+	impl-&gt;start_time = cur_time;
+	
+	if (delta_time &lt; impl-&gt;frame_time)
+	{
+		CL_System::sleep(impl-&gt;frame_time - delta_time);
+		impl-&gt;total_time += impl-&gt;frame_time;
+	}
+	else
+	{
+		impl-&gt;total_time += delta_time;
+	}
+		
+	if(impl-&gt;total_time &gt;= 1000)	// One second has passed
+	{
+		impl-&gt;fps_result = impl-&gt;fps_counter + 1;
+		impl-&gt;fps_counter = impl-&gt;total_time = 0;
+	}
+	impl-&gt;fps_counter++;	// Increase fps
+}

Added: trunk/clanlib/Display/frameratecounter_generic.h
===================================================================
--- trunk/clanlib/Display/frameratecounter_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/frameratecounter_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,49 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_frameratecounter_generic
+#define header_frameratecounter_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+class CL_FramerateCounter_Generic
+{
+public:
+	CL_FramerateCounter_Generic() { }
+
+	int start_time;
+	int total_time;
+	int frame_time;
+	int fps_result;
+	int fps_counter;
+};
+
+#endif

Added: trunk/clanlib/Display/glyph_buffer.cpp
===================================================================
--- trunk/clanlib/Display/glyph_buffer.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/glyph_buffer.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,637 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Core/Math/point.h&quot;
+#include &quot;API/Core/Math/rect.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Display/glyph_buffer.h&quot;
+#include &quot;API/Display/graphic_context.h&quot;
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Display/display_window.h&quot;
+
+#include &lt;cmath&gt;
+#include &lt;map&gt;
+#include &lt;climits&gt;
+
+#define cl_min(a,b) ((a &lt; b) ? a : b)
+#define cl_max(a,b) ((a &gt; b) ? a : b)
+
+CL_GlyphBuffer::CL_GlyphBuffer() :
+	scale_x(1.0f), scale_y(1.0f),
+	rot_angle(0.0f), rot_origin(origin_center),
+	rot_x(0), rot_y(0), trans_origin(origin_top_left),
+	trans_x(0), trans_y(0)
+	{}
+
+void CL_GlyphBuffer::Range::verify(const CL_GlyphBuffer&amp; gb)
+{
+	if (start &lt; 0)
+		start = 0;
+	
+	if (end &gt; static_cast&lt;int&gt;(gb.get_glyphs().size()))
+		end = gb.get_glyphs().size();
+
+	if (end &lt; 0)
+		end = 0;
+	
+	if (start &gt; end)
+		start = end;
+}
+
+void CL_GlyphBuffer::Range::remove_invis_left(const CL_GlyphBuffer&amp; gb)
+{
+	verify(gb);
+
+	while (
+	start &lt; end &amp;&amp;
+	gb.get_font_for(start)-&gt;second.is_glyph(gb.get_glyphs()[start].character) == 0)
+		++start;
+}
+
+void CL_GlyphBuffer::Range::remove_invis_right(const CL_GlyphBuffer&amp; gb)
+{
+	verify(gb);
+
+	while (
+	end &gt; start &amp;&amp;
+	gb.get_font_for(end-1)-&gt;second.is_glyph(gb.get_glyphs()[end-1].character) == 0)
+		--end;
+}
+
+std::map&lt;int, CL_Font&gt;::iterator CL_GlyphBuffer::get_font_for(int glyph_index)
+{
+	if (font_markers.size() == 0)
+		return font_markers.end();
+	
+	if (glyph_index &lt; 0)
+		glyph_index = 0;
+	
+	if (glyph_index &gt; static_cast&lt;int&gt;(glyphs.size() - 1))
+		glyph_index = glyphs.size() - 1;
+	
+	//Find a font_marker associated with an index above the given one, or the end
+	std::map&lt;int, CL_Font&gt;::iterator it = font_markers.begin();
+	for (; it != font_markers.end(); ++it)
+		if (it-&gt;first &gt; glyph_index)
+			break;
+	
+	if (it == font_markers.begin())
+		return font_markers.end();
+	
+	return --it;
+}
+
+std::map&lt;int, CL_Font&gt;::const_iterator CL_GlyphBuffer::get_font_for(int glyph_index) const
+{
+	if (glyph_index &lt; 0)
+		glyph_index = 0;
+	
+	if (glyph_index &gt; static_cast&lt;int&gt;(glyphs.size() - 1))
+		glyph_index = glyphs.size() - 1;
+	
+	//Upper bound finds the first element whose key is greater than the given key
+	//So after decrementing it, then it will be the font marker which covers the given glyph
+	//Remember that font markers affect glyphs with indices &gt;= their key number, up to the next marker's key
+	std::map&lt;int, CL_Font&gt;::const_iterator it = font_markers.upper_bound(glyph_index);
+	if (it == font_markers.begin())
+		return font_markers.end();
+	return --it;
+}
+
+CL_Rect CL_GlyphBuffer::bounding_rect(Range range, CL_Rect dest, bool ignore_invis) const
+{
+	CL_Rect retVal = internal_rect(range, ignore_invis);
+	CL_Point offset = i2e_offset(retVal, dest);
+	
+	retVal.left += offset.x;
+	retVal.top += offset.y;
+	retVal.right += offset.x;
+	retVal.bottom += offset.y;
+	
+	return retVal;
+}
+
+CL_Rect CL_GlyphBuffer::internal_rect(Range range, bool ignore_invis) const
+{
+	range.verify(*this);
+	
+	//Use a weird inverse rectangle to start out with
+	//Since we get the bounding rect by just comparing each side of each glyph with respective sides of the rect-in-progress...
+	//Using this rect means the first glyph we compare against determines the initial rectangle
+	CL_Rect retVal(INT_MAX, INT_MAX, INT_MIN, INT_MIN);
+	
+	//For every glyph in the buffer...
+	for (Iter it(*this, range); !it.at_end(range); ++it)
+	{
+		std::vector&lt;Glyph&gt;::const_iterator glyph = glyphs.begin() + it.get_glyph_num(); //Glyph vector element
+		const CL_Font&amp; fnt = it.get_font();
+		
+		//If ignore_invis is turned on, check to see if this glyph is supplied by the font
+		if (!ignore_invis || (ignore_invis &amp;&amp; fnt.is_glyph(glyph-&gt;character)))
+		{
+			float scale_eff_x, scale_eff_y;
+			it.get_scale_eff(scale_eff_x, scale_eff_y);
+			
+			//Rectangle containing the glyph
+			CL_Rect gr(
+				glyph-&gt;pos.x,
+				glyph-&gt;pos.y,
+				glyph-&gt;pos.x + (int)(fnt.get_width(glyph-&gt;character) * scale_eff_x),
+				glyph-&gt;pos.y + (int)(fnt.get_height() * scale_eff_y));
+			
+			//Compensate for rotation of the glyph and font rotation
+			float angle_eff = it.get_angle_eff();
+			if (angle_eff != 0.0)
+			{
+				CL_Origin grot_hotspot; int grot_x, grot_y;
+				fnt.get_glyph_rot_hotspot(grot_hotspot, grot_x, grot_y);
+				gr = gr.get_rot_bounds(grot_hotspot, grot_x, grot_y, angle_eff);
+			}
+			
+			//Push on the sides of the returned rect so it contains this glyph
+			retVal.left = cl_min(gr.left, retVal.left);
+			retVal.right = cl_max(gr.right, retVal.right);
+			retVal.top = cl_min(gr.top, retVal.top);
+			retVal.bottom = cl_max(gr.bottom, retVal.bottom);
+		}
+	}
+	
+	//If there weren't any real glyphs, then return a rectangle with zero size
+	if (retVal == CL_Rect(INT_MAX, INT_MAX, INT_MIN, INT_MIN))
+		retVal = CL_Rect(0,0,0,0);
+	
+	return retVal;
+}
+
+std::vector&lt;CL_GlyphBuffer::Range&gt; CL_GlyphBuffer::get_lines(CL_GlyphBuffer::Range range) const
+{
+	range.verify(*this);
+	std::vector&lt;CL_GlyphBuffer::Range&gt; ret;
+	
+	std::map&lt;int, CL_Font&gt;::const_iterator curfnt;
+	if (range.start &gt; 0)
+		curfnt = get_font_for(range.start-1);
+	else
+		curfnt = font_markers.begin();
+	
+	//Move the beginning of the input range to the beginning of the line
+	while (range.start &gt; 0)
+	{
+		//If curfnt isnt the font of range.start-1, make it that font
+		if (curfnt-&gt;first &gt; range.start-1)
+			--curfnt;
+		
+		if (is_linebreak(range.start-1, curfnt-&gt;second))
+			break;
+		
+		--range.start;
+	}
+	
+	//Advance until we've passed the end of the range and hit the linebreak at or after that
+	std::map&lt;int, CL_Font&gt;::const_iterator nextfnt = curfnt;
+	++nextfnt;
+	for (int idx = range.start;; ++idx)
+	{
+		//If curfnt isnt the font of idx, make it that font
+		if (nextfnt != font_markers.end() &amp;&amp; idx &gt;= nextfnt-&gt;first)
+		{
+			curfnt = nextfnt;
+			++nextfnt;
+		}
+		
+		//If this glyph is the last glyph on a line...
+		if (is_linebreak(idx, curfnt-&gt;second))
+		{
+			//Add a line range to the return value
+			if (ret.size() == 0)
+				ret.push_back(CL_GlyphBuffer::Range(range.start, idx+1));
+			else
+				ret.push_back(CL_GlyphBuffer::Range((ret.end()-1)-&gt;end, idx+1));
+			
+			if (idx &gt;= range.end)
+				break;
+		}
+	}
+
+	return ret;
+}
+
+CL_GlyphBuffer::Range CL_GlyphBuffer::get_line(int idx) const
+{
+	CL_GlyphBuffer::Range ret(idx, idx);
+	
+	std::map&lt;int, CL_Font&gt;::const_iterator idxfnt;
+	if (idx &gt; 0)
+		idxfnt = get_font_for(idx-1);
+	else
+		idxfnt = font_markers.begin();
+
+	std::map&lt;int, CL_Font&gt;::const_iterator curfnt = idxfnt;
+	
+	//Move the range start back to the beginning of the line
+	while (ret.start &gt; 0)
+	{
+		//If curfnt isnt the font of range.start-1, make it that font
+		if (curfnt-&gt;first &gt; ret.start-1)
+			--curfnt;
+		
+		if (is_linebreak(ret.start-1, curfnt-&gt;second))
+			break;
+		
+		--ret.start;
+	}
+	
+	//Move the range end to the end of the line
+	curfnt = idxfnt;
+	std::map&lt;int, CL_Font&gt;::const_iterator nextfnt = curfnt;
+	++nextfnt;
+	while (1)
+	{
+		//If curfnt isnt the font of idx, make it that font
+		if (nextfnt != font_markers.end() &amp;&amp; idx &gt;= nextfnt-&gt;first)
+		{
+			curfnt = nextfnt;
+			++nextfnt;
+		}
+		
+		//If ret.end is the last glyph on the line, then we're done
+		if (is_linebreak(ret.end, curfnt-&gt;second)) {
+			++ret.end;
+			break;
+		}
+		
+		++ret.end;
+	}
+	
+	return ret;
+}
+
+//Utility function for add(), puts a map into another map with a key offset
+template &lt;typename T&gt;
+void add_map_range(
+	const std::map&lt;int, T&gt;&amp; src,
+	std::map&lt;int, T&gt;&amp; dest,
+	CL_GlyphBuffer::Range range,
+	int offset)
+{
+	const typename std::map&lt;int, T&gt;::const_iterator end = src.upper_bound(range.end);
+	for (typename std::map&lt;int, T&gt;::const_iterator it = src.lower_bound(range.start); it != end; ++it)
+		dest[it-&gt;first + offset] = it-&gt;second;
+}
+
+CL_GlyphBuffer &amp;CL_GlyphBuffer::add(
+	const CL_GlyphBuffer &amp;other,
+	Range range,
+	int x,
+	int y)
+{
+	//Offset to make copied font markers/effects apply to after the end of the new buffer
+	const int offset = glyphs.size();
+
+	glyphs.reserve(glyphs.size() + other.glyphs.size());
+	
+	if ((x == 0) &amp;&amp; (y == 0))
+	{
+		for (
+			std::vector&lt;Glyph&gt;::const_iterator it = other.glyphs.begin() + range.start;
+			it != other.glyphs.begin() + range.end;
+			++it)
+		{
+			glyphs.push_back(*it);
+		}
+	}
+	else
+	{
+		for (
+			std::vector&lt;Glyph&gt;::const_iterator it = other.glyphs.begin() + range.start;
+			it != other.glyphs.begin() + range.end;
+			++it)
+		{
+			glyphs.push_back(Glyph(CL_Point(it-&gt;pos.x + x, it-&gt;pos.y + y), it-&gt;character));
+		}
+	}
+	
+	add_map_range(other.font_markers, font_markers, range, offset);
+	add_map_range(other.color_effects, color_effects, range, offset);
+	add_map_range(other.scale_x_effects, scale_x_effects, range, offset);
+	add_map_range(other.scale_y_effects, scale_y_effects, range, offset);
+	add_map_range(other.angle_effects, angle_effects, range, offset);
+	
+	return *this;
+}
+
+CL_GlyphBuffer &amp;CL_GlyphBuffer::remove(Range range)
+{
+	range.verify(*this);
+	
+	//Remove the elements themselves
+	glyphs.erase(glyphs.begin() + range.start, glyphs.begin() + range.end);
+	
+	//Remove any map entries associated with the range, slide back any map entries after the range
+	cut_range(font_markers, range.start, range.end);
+	cut_range(color_effects, range.start, range.end);
+	cut_range(scale_x_effects, range.start, range.end);
+	cut_range(scale_y_effects, range.start, range.end);
+	cut_range(angle_effects, range.start, range.end);
+
+	return *this;
+}
+
+CL_GlyphBuffer &amp;CL_GlyphBuffer::change_font(const CL_Font &amp;font)
+{
+	font_markers[glyphs.size()] = font;
+	return *this;
+}
+
+void CL_GlyphBuffer::clear()
+{
+	glyphs.clear();
+	font_markers.clear();
+	angle_effects.clear();
+	scale_x_effects.clear();
+	scale_y_effects.clear();
+	color_effects.clear();
+}
+
+void CL_GlyphBuffer::justify_left(CL_GlyphBuffer::Range range, int left)
+{
+	range.verify(*this);
+	std::vector&lt;CL_GlyphBuffer::Range&gt; ranges = get_lines(range);
+	
+	for (std::vector&lt;CL_GlyphBuffer::Range&gt;::iterator it = ranges.begin(); it != ranges.end(); ++it)
+	{
+		CL_GlyphBuffer::Range vis_range = *it;
+		CL_Rect line_rect = internal_rect(vis_range);
+		int offset = left - line_rect.left;
+		
+		for (int glyph = it-&gt;start; glyph != it-&gt;end; ++glyph)
+			glyphs[glyph].pos.x += offset;
+	}
+}
+
+void CL_GlyphBuffer::justify_center(CL_GlyphBuffer::Range range, int center)
+{
+	range.verify(*this);
+	std::vector&lt;CL_GlyphBuffer::Range&gt; ranges = get_lines(range);
+	
+	for (std::vector&lt;CL_GlyphBuffer::Range&gt;::iterator it = ranges.begin(); it != ranges.end(); ++it)
+	{
+		CL_GlyphBuffer::Range vis_range = *it;
+		vis_range.remove_invis_both(*this);
+		CL_Rect line_rect = internal_rect(vis_range);
+		int offset = center - ((line_rect.left + line_rect.right)/2);
+		
+		for (int glyph = it-&gt;start; glyph != it-&gt;end; ++glyph)
+			glyphs[glyph].pos.x += offset;
+	}
+}
+
+void CL_GlyphBuffer::justify_right(CL_GlyphBuffer::Range range, int right)
+{
+	range.verify(*this);
+	std::vector&lt;CL_GlyphBuffer::Range&gt; ranges = get_lines(range);
+	
+	for (std::vector&lt;CL_GlyphBuffer::Range&gt;::iterator it = ranges.begin(); it != ranges.end(); ++it)
+	{
+		CL_GlyphBuffer::Range vis_range = *it;
+		vis_range.remove_invis_right(*this);
+		CL_Rect line_rect = internal_rect(vis_range);
+		int offset = right - line_rect.right;
+		
+		for (int glyph = it-&gt;start; glyph != it-&gt;end; ++glyph)
+			glyphs[glyph].pos.x += offset;
+	}
+}
+
+void CL_GlyphBuffer::set_angle(float angle)
+{
+	while(angle &gt;= 360.0f)
+		angle -= 360.0f;
+	while(angle &lt; 0.0f)
+		angle += 360.0f;
+	
+	rot_angle = angle;
+}
+
+void CL_GlyphBuffer::Iter::get_scale_eff(float&amp; x, float&amp; y) const
+{
+	const std::map&lt;int, float&gt;&amp; scale_x_effects = pgb-&gt;get_scale_x_effects();
+	std::map&lt;int, float&gt;::const_iterator x_eff = scale_x_effects.find(glyph_num);
+	if (x_eff != scale_x_effects.end())
+		x = x_eff-&gt;second;
+	else
+		x = 1.0;
+	
+	const std::map&lt;int, float&gt;&amp; scale_y_effects = pgb-&gt;get_scale_y_effects();
+	std::map&lt;int, float&gt;::const_iterator y_eff = scale_y_effects.find(glyph_num);
+	if (y_eff != scale_y_effects.end())
+		y = y_eff-&gt;second;
+	else
+		y = 1.0;
+}
+
+float CL_GlyphBuffer::Iter::get_angle_eff() const
+{
+	const std::map&lt;int, float&gt;&amp; angle_effects = pgb-&gt;get_angle_effects();
+	std::map&lt;int, float&gt;::const_iterator ang_eff = angle_effects.find(glyph_num);
+	if (ang_eff != angle_effects.end())
+		return ang_eff-&gt;second;
+	else
+		return 0.0;
+}
+
+CL_Color CL_GlyphBuffer::Iter::get_color_eff(const CL_Font&amp; fnt) const
+{
+	const std::map&lt;int, CL_Color&gt;&amp; color_effects = pgb-&gt;get_color_effects();
+	std::map&lt;int, CL_Color&gt;::const_iterator col_eff = color_effects.find(glyph_num);
+	if (col_eff != color_effects.end())
+		return col_eff-&gt;second;
+	else
+		return fnt.get_color();
+}
+
+const CL_Font&amp; CL_GlyphBuffer::Iter::get_font() const
+{
+	std::map&lt;int, CL_Font&gt;::const_iterator it = pgb-&gt;get_font_for(glyph_num);
+	if (it == pgb-&gt;get_font_markers().end())
+		throw CL_Error(&quot;No font in the font markers map to draw the glyph(s) with&quot;);
+	return it-&gt;second;
+}
+
+bool CL_GlyphBuffer::is_linebreak(int idx, const CL_Font&amp; fnt) const
+{
+	const unsigned int chr = glyphs[idx].character;
+	
+	//This glyph and the glyph after it are on different lines if:
+	if (
+	//...this is the last glyph of the buffer, which makes it the last glyph of the last line
+	idx == static_cast&lt;int&gt;(glyphs.size()-1) ||
+	//...this glyph is a manual newline character ('\n')
+	chr == '\n' || 
+	//...the next glyph's left side is to the left of this glyph's right side
+	glyphs[idx+1].pos.x &lt; glyphs[idx].pos.x + fnt.get_width(chr)
+	)
+		return true;
+
+	return false;
+}
+
+CL_Point CL_GlyphBuffer::i2e_offset(CL_Rect src, CL_Rect dest) const
+{
+	//Align the source rectangle to the origin
+	CL_Point retVal(-src.left, -src.top);
+	retVal -= calc_origin(trans_origin, CL_Size(src.get_width(), src.get_height()));
+	
+	//Align the origin to the dest rectangle
+	retVal.x += dest.left;
+	retVal.y += dest.top;
+	retVal += calc_origin(trans_origin, CL_Size(dest.get_width(), dest.get_height()));
+	
+	//Apply the translation offsets
+	retVal.x -= trans_x;
+	retVal.y -= trans_y;
+	
+	return retVal;
+}
+
+CL_Point CL_GlyphBuffer::get_scale_hotspot(CL_Rect irect) const
+{
+	CL_Point scale_hotspot(irect.left, irect.top);
+	scale_hotspot += calc_origin(trans_origin, irect.get_size());
+	scale_hotspot.x += trans_x;
+	scale_hotspot.y += trans_y;
+	
+	return scale_hotspot;
+}
+
+CL_Point CL_GlyphBuffer::get_rot_hotspot(CL_Rect irect) const
+{
+	CL_Point rot_hotspot(irect.left, irect.top);
+	rot_hotspot += calc_origin(rot_origin, irect.get_size());
+	rot_hotspot.x += rot_x;
+	rot_hotspot.y += rot_y;
+	
+	return rot_hotspot;
+}
+
+void CL_GlyphBuffer::draw_glyphs(
+	Range range,
+	CL_Point offset,
+	CL_Rect irect,
+	CL_GraphicContext* gc) const
+{
+	range.verify(*this);
+	
+	if (gc == 0)
+		gc = CL_Display::get_current_window()-&gt;get_gc();
+	
+	CL_Point rot_hotspot;
+	CL_Point scale_hotspot(0,0);
+	
+	//True if we're doing total GlyphBuffer rotation
+	bool rotate = false;
+	if (rot_angle != 0.0)
+	{
+		rotate = true;
+		if (irect == CL_Rect(0,0,0,0))
+			irect = internal_rect();
+		rot_hotspot = get_rot_hotspot(irect);
+	}
+	
+	//True if we're doing total GlyphBuffer scaling
+	bool scale = false;
+	if (scale_x != 1.0 || scale_y != 1.0)
+	{
+		scale = true;
+		if (irect == CL_Rect(0,0,0,0))
+			irect = internal_rect();
+		scale_hotspot = get_scale_hotspot(irect);
+	}
+	
+	//For every glyph in the buffer...
+	for (Iter it(*this, range); !it.at_end(range); ++it)
+	{
+		std::vector&lt;Glyph&gt;::const_iterator glyph = glyphs.begin() + it.get_glyph_num(); //Reference to the glyph vector element
+		CL_Point draw_pos(glyph-&gt;pos);
+		
+		//Apply GB scaling if enabled
+		if (scale)
+		{
+			//The offset from scale_hotspot to the new drawing position
+			CL_Point scale_offset = draw_pos - scale_hotspot;
+			scale_offset.x = (int)(scale_offset.x*scale_x);
+			scale_offset.y = (int)(scale_offset.y*scale_y);
+			
+			draw_pos = scale_hotspot + scale_offset;
+		}
+		
+		//Apply GB rotation if enabled
+		if (rotate)
+			draw_pos = draw_pos.rotate(rot_hotspot, rot_angle);
+		
+		//Move the glyph into the dest rectangle
+		draw_pos += offset;
+		
+		//We reimplement get_font_for() here so that we can get a mutable iterator
+		//That's because there's no such thing as a mutable method 
+		std::map&lt;int, CL_Font&gt;::iterator fntiter = font_markers.upper_bound(it.get_glyph_num());
+		if (fntiter == font_markers.begin())
+			throw CL_Error(&quot;No font in the font markers map to draw the glyph(s) with&quot;);
+		CL_Font&amp; font = (--fntiter)-&gt;second;
+		
+		if (font.is_glyph(glyph-&gt;character))
+		{
+			//Record the font's original color and scale
+			CL_Color orig_color = font.get_color();
+			float orig_scale_x, orig_scale_y;
+			font.get_scale(orig_scale_x, orig_scale_y);
+			
+			//Temporarily set the Font's color and scale to the current glyph's properties
+			CL_Color eff_color = it.get_color_eff(font);
+			float scale_eff_x, scale_eff_y;
+			it.get_scale_eff(scale_eff_x, scale_eff_y);
+			
+			//If there's any scale effect or scale property, apply it
+			if (eff_color != orig_color)
+				font.set_color(eff_color);
+			if (scale_x != 1.0 || scale_eff_x != 1.0 || scale_y != 1.0 || scale_eff_y != 1.0)
+				font.set_scale(scale_eff_x * scale_x * orig_scale_x, scale_eff_y * scale_y * orig_scale_y);
+			
+			//Draw the glyph, using the current angle
+			font.draw_character(draw_pos.x, draw_pos.y, glyph-&gt;character, it.get_angle_eff() + rot_angle, gc);
+			
+			//Restore the original values, if they were changed
+			if (eff_color != orig_color)
+				font.set_color(orig_color);
+			if (scale_x != 1.0 || scale_eff_x != 1.0 || scale_y != 1.0 || scale_eff_y != 1.0)
+				font.set_scale(orig_scale_x, orig_scale_y);
+		}
+	}
+}

Added: trunk/clanlib/Display/graphic_context.cpp
===================================================================
--- trunk/clanlib/Display/graphic_context.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/graphic_context.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,452 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/graphic_context.h&quot;
+#include &quot;API/Display/surface.h&quot;
+#include &quot;graphic_context_generic.h&quot;
+#include &quot;surface_generic.h&quot;
+#include &quot;surface_target.h&quot;
+
+#include &quot;triangle_params.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_GraphicContext construction:
+
+CL_GraphicContext::CL_GraphicContext()
+: impl(0)
+{
+}
+
+CL_GraphicContext::CL_GraphicContext(const CL_GraphicContext &amp;copy)
+: impl(copy.impl)
+{
+	if (impl) impl-&gt;add_ref();
+}
+
+CL_GraphicContext::CL_GraphicContext(CL_GraphicContext_Generic *impl)
+: impl(impl)
+{
+	if (impl) impl-&gt;add_ref();
+}
+
+CL_GraphicContext::~CL_GraphicContext()
+{
+	if (impl) impl-&gt;release_ref();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_GraphicContext attributes:
+
+int CL_GraphicContext::get_width() const
+{
+	return impl-&gt;get_width();
+}
+
+int CL_GraphicContext::get_height() const
+{
+	return impl-&gt;get_height();
+}
+
+const CL_Rect &amp;CL_GraphicContext::get_cliprect() const
+{
+	return impl-&gt;get_cliprect();
+}
+
+const CL_Matrix4x4 &amp;CL_GraphicContext::get_modelview() const
+{
+	return impl-&gt;get_modelview();
+}
+
+CL_Color CL_GraphicContext::get_pixel(int x, int y) const
+{
+	return impl-&gt;get_pixel(x, y);
+}
+
+CL_PixelBuffer CL_GraphicContext::get_pixeldata(const CL_Rect&amp; rect, int i) const
+{
+	return impl-&gt;get_pixeldata(rect, i);
+}
+
+CL_Size CL_GraphicContext::get_max_surface_size() const
+{
+	return impl-&gt;get_max_surface_size();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_GraphicContext operations:
+
+CL_GraphicContext &amp;CL_GraphicContext::operator =(const CL_GraphicContext &amp;copy)
+{
+	if (impl) impl-&gt;release_ref();
+	impl = copy.impl;
+	if (impl) impl-&gt;add_ref();
+	return *this;
+}
+
+void CL_GraphicContext::flush()
+{
+	impl-&gt;flush();
+}
+
+void CL_GraphicContext::set_cliprect(const CL_Rect &amp;rect)
+{
+	if (rect.right &lt; rect.left || rect.bottom &lt; rect.top)
+	{
+		static CL_Rect null_rect(0,0,0,0);
+		impl-&gt;set_cliprect(null_rect);
+	}
+	impl-&gt;set_cliprect(rect);
+}
+
+void CL_GraphicContext::push_cliprect(const CL_Rect &amp;rect)
+{
+	if (rect.right &lt; rect.left || rect.bottom &lt; rect.top)
+	{
+		static CL_Rect null_rect(0,0,0,0);
+		impl-&gt;push_cliprect(null_rect);
+	}
+	impl-&gt;push_cliprect(rect);
+}
+
+void CL_GraphicContext::push_cliprect()
+{
+	impl-&gt;push_cliprect();
+}
+
+void CL_GraphicContext::pop_cliprect()
+{
+	impl-&gt;pop_cliprect();
+}
+
+void CL_GraphicContext::draw_pixel(int x, int y, const CL_Color &amp;color)
+{
+	impl-&gt;draw_pixel(x, y, color);
+}
+
+void CL_GraphicContext::draw_line(float x1, float y1, float x2, float y2, const CL_Color &amp;color)
+{
+	impl-&gt;draw_line(x1, y1, x2, y2, color);
+}
+
+void CL_GraphicContext::draw_lines(int count, double *vertices, const CL_Color &amp;color)
+{
+	impl-&gt;draw_lines(count, vertices, color);
+}
+
+void CL_GraphicContext::draw_rect(const CL_Rectf &amp;rect, const CL_Color &amp;color)
+{
+	impl-&gt;draw_rect(rect, color);
+}
+
+void CL_GraphicContext::fill_rect(const CL_Rectf &amp;rect, const CL_Gradient &amp;gradient)
+{
+	impl-&gt;fill_rect(rect, gradient);
+}
+
+void CL_GraphicContext::fill_rect(const CL_Rectf &amp;rect, const CL_Color &amp;color)
+{
+	impl-&gt;fill_rect(rect, color);
+}
+
+void CL_GraphicContext::draw_quad(const CL_Quad &amp;quad, const CL_Color &amp;color)
+{
+	impl-&gt;draw_quad(quad, color);
+}
+
+void CL_GraphicContext::fill_quad(const CL_Quad &amp;quad, const
+	CL_Gradient &amp;gradient)
+{
+	impl-&gt;fill_quad(quad, gradient);
+}
+
+void CL_GraphicContext::fill_quad(const CL_Quad &amp;quad, const CL_Color
+&amp;color)
+{
+	impl-&gt;fill_quad(quad, color);
+}
+
+//: Draw a triangle using the specified color.
+void CL_GraphicContext::draw_triangle(
+		double x1, double y1,
+		double x2, double y2,
+		double x3, double y3,
+		const CL_Color &amp;color)
+{
+	CL_TriangleParams params;
+
+	double vertice_array[] = {x1, y1, 0, x2, y2, 0, x3, y3, 0};
+
+	params.count = 1;
+	params.vertices = vertice_array;
+	params.single_color = &color;
+	params.fill = false;
+
+	impl-&gt;draw_triangles( &amp;params );
+}
+
+//: Draw a filled triangle using the specified color gradient.
+void CL_GraphicContext::fill_triangle(
+		double x1, double y1,
+		double x2, double y2,
+		double x3, double y3,
+		const CL_Gradient &amp;grad)
+{
+	CL_TriangleParams params;
+
+	double vertice_array[] = {x1, y1, 0, x2, y2, 0, x3, y3, 0};
+	
+/*	double color_array[] = {
+		grad.top_left.get_red()/256.0,
+		grad.top_left.get_green()/256.0,
+		grad.top_left.get_blue()/256.0,
+		grad.top_left.get_alpha()/256.0,
+		grad.top_right.get_red()/256.0,
+		grad.top_right.get_green()/256.0,
+		grad.top_right.get_blue()/256.0,
+		grad.top_right.get_alpha()/256.0,
+		grad.bottom_left.get_red()/256.0,
+		grad.bottom_left.get_green()/256.0,
+		grad.bottom_left.get_blue()/256.0,
+		grad.bottom_left.get_alpha()/256.0};
+*/
+	unsigned char color_array[] = {
+		grad.top_left.get_red(),
+		grad.top_left.get_green(),
+		grad.top_left.get_blue(),
+		grad.top_left.get_alpha(),
+		grad.top_right.get_red(),
+		grad.top_right.get_green(),
+		grad.top_right.get_blue(),
+		grad.top_right.get_alpha(),
+		grad.bottom_left.get_red(),
+		grad.bottom_left.get_green(),
+		grad.bottom_left.get_blue(),
+		grad.bottom_left.get_alpha()};
+
+	params.count = 1;
+	params.vertices = vertice_array;
+	params.uchar_color = color_array;
+ 	params.fill = true;
+
+	impl-&gt;draw_triangles( &amp;params );	
+}
+
+//: Draw triangles.
+//- double color array, range: 0-1
+//- double (0-1) texture coordinates
+void CL_GraphicContext::draw_trianglesd(
+		unsigned int count,
+		bool fill,
+		double *vertices,
+		double *color,
+		double *uv,
+		CL_Surface *surface )
+{
+	CL_TriangleParams params;
+
+	params.count = count;
+	params.vertices = vertices;
+	params.color = color;
+	params.uv = uv;
+	params.fill = fill;
+
+	if( surface != 0 )
+		params.texture = surface-&gt;impl-&gt;target;
+
+	impl-&gt;draw_triangles( &amp;params );	
+}
+
+//: Draw triangles (optionally colored and uv-mapped).
+//- single color
+//- double (0-1) texture coordinates
+void CL_GraphicContext::draw_trianglesd(
+		unsigned int count,
+		bool fill,
+		double *vertices,
+		const CL_Color &amp;color,
+		double *uv,
+		CL_Surface *surface)
+{
+	CL_TriangleParams params;
+
+	params.count = count;
+	params.vertices = vertices;
+	params.single_color = &color;
+	params.uv = uv;
+	params.fill = fill;
+
+	if( surface != 0 )
+		params.texture = surface-&gt;impl-&gt;target;
+
+	impl-&gt;draw_triangles( &amp;params );	
+}
+
+//: Draw triangles (optionally colored and uv-mapped).
+//- uchar color array, range: 0-255
+//- integer (pixel) texture coordinates
+void CL_GraphicContext::draw_triangles(
+		unsigned int count,
+		bool fill,
+		double *vertices,
+		unsigned char *color,
+		int *uv,
+		CL_Surface *surface )
+{
+	CL_TriangleParams params;
+
+	params.count = count;
+	params.vertices = vertices;
+	params.uchar_color = color;
+	params.int_uv = uv;
+	params.fill = fill;
+
+	if( surface != 0 )
+		params.texture = surface-&gt;impl-&gt;target;
+
+	impl-&gt;draw_triangles( &amp;params );	
+}
+
+//: Draw triangles (optionally colored and uv-mapped).
+//- single color
+//- integer (pixel) texture coordinates
+void CL_GraphicContext::draw_triangles(
+		unsigned int count,
+		bool fill,
+		double *vertices,
+		const CL_Color &amp;color,
+		int *uv,
+		CL_Surface *surface )
+{
+	CL_TriangleParams params;
+
+	params.count = count;
+	params.vertices = vertices;
+	params.single_color = &color;
+	params.int_uv = uv;
+	params.fill = fill;
+
+	if( surface != 0 )
+		params.texture = surface-&gt;impl-&gt;target;
+
+	impl-&gt;draw_triangles( &amp;params );	
+}
+
+void CL_GraphicContext::clear(const CL_Color &amp;color)
+{
+	impl-&gt;clear(color);
+}
+
+void CL_GraphicContext::set_modelview(const CL_Matrix4x4 &amp;matrix)
+{
+	impl-&gt;set_modelview(matrix);
+}
+
+void CL_GraphicContext::add_modelview(const CL_Matrix4x4 &amp;matrix)
+{
+	impl-&gt;add_modelview(matrix);
+}
+
+void CL_GraphicContext::push_modelview()
+{
+	impl-&gt;push_modelview();
+}
+
+void CL_GraphicContext::set_translate(double x, double y, double z)
+{
+	impl-&gt;set_translate(x, y, z);
+}
+
+void CL_GraphicContext::add_translate(double x, double y, double z)
+{
+	impl-&gt;add_translate(x, y, z);
+}
+
+void CL_GraphicContext::push_translate(double x, double y, double z)
+{
+	impl-&gt;push_translate(x, y, z);
+}
+
+void CL_GraphicContext::set_rotate(double angle, double x, double y, double z)
+{
+	impl-&gt;set_rotate(angle, x, y, z);
+}
+
+void CL_GraphicContext::add_rotate(double angle, double x, double y, double z)
+{
+	impl-&gt;add_rotate(angle, x, y, z);
+}
+
+void CL_GraphicContext::push_rotate(double angle, double x, double y, double z)
+{
+	impl-&gt;push_rotate(angle, x, y, z);
+}
+
+void CL_GraphicContext::set_scale(double x, double y, double z)
+{
+	impl-&gt;set_scale(x, y, z);
+}
+
+void CL_GraphicContext::add_scale(double x, double y, double z)
+{
+	impl-&gt;add_scale(x, y, z);
+}
+
+void CL_GraphicContext::push_scale(double x, double y, double z)
+{
+	impl-&gt;push_scale(x, y, z);
+}
+
+void CL_GraphicContext::pop_modelview()
+{
+	impl-&gt;pop_modelview();
+}
+
+void CL_GraphicContext::clear_stencil(int value)
+{
+	impl-&gt;clear_stencil(value);
+}
+
+void CL_GraphicContext::enable_stencil_write(bool enabled, bool visible, float alpha_limit)
+{
+	impl-&gt;enable_stencil_write(enabled, visible, alpha_limit);
+}
+
+void CL_GraphicContext::enable_stencil_test(bool enabled, CL_StencilFunc func, int ref)
+{
+	impl-&gt;enable_stencil_test(enabled, func, ref);
+}
+
+void CL_GraphicContext::set_stencil_operation(CL_StencilOp pass, CL_StencilOp fail, CL_StencilFunc func, int ref)
+{
+	impl-&gt;set_stencil_operation(pass, fail, func, ref);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Implementation:

Added: trunk/clanlib/Display/graphic_context_generic.cpp
===================================================================
--- trunk/clanlib/Display/graphic_context_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/graphic_context_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,226 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;graphic_context_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_GraphicContext_Generic construction:
+
+CL_GraphicContext_Generic::CL_GraphicContext_Generic()
+: ref_count(0)
+{
+	cliprects.push_front(CL_Rect(0,0,0,0));
+	modelviews.push_front(CL_Matrix4x4(true));
+}
+
+CL_GraphicContext_Generic::~CL_GraphicContext_Generic()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_GraphicContext_Generic attributes:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_GraphicContext_Generic operations:
+
+void CL_GraphicContext_Generic::add_ref()
+{
+	ref_count++;
+}
+
+void CL_GraphicContext_Generic::release_ref()
+{
+	ref_count--;
+	if (ref_count == 0) delete this;
+}
+
+void CL_GraphicContext_Generic::set_cliprect(const CL_Rect &amp;rect)
+{
+	cliprects.front() = rect;
+}
+
+void CL_GraphicContext_Generic::push_cliprect(const CL_Rect &amp;rect)
+{
+	cliprects.push_front(cliprects.front().calc_union(rect));
+}
+
+void CL_GraphicContext_Generic::push_cliprect()
+{
+	cliprects.push_front(cliprects.front());
+}
+
+void CL_GraphicContext_Generic::pop_cliprect()
+{
+	cliprects.pop_front();
+}
+
+void CL_GraphicContext_Generic::set_modelview(const CL_Matrix4x4 &amp;matrix)
+{
+	modelviews.front() = matrix;
+	modelview_changed();
+}
+
+void CL_GraphicContext_Generic::add_modelview(const CL_Matrix4x4 &amp;matrix)
+{
+	set_modelview(modelviews.front().multiply(matrix));
+}
+
+void CL_GraphicContext_Generic::push_modelview()
+{
+	CL_Matrix4x4 m = modelviews.front();
+	modelviews.push_front(m);
+}
+
+void CL_GraphicContext_Generic::set_translate(double x, double y, double z)
+{
+	CL_Matrix4x4 matrix(true);
+	matrix[12] = x;
+	matrix[13] = y;
+	matrix[14] = z;
+	set_modelview(matrix);
+}
+
+void CL_GraphicContext_Generic::add_translate(double x, double y, double z)
+{
+	CL_Matrix4x4 matrix(true);
+	matrix[12] = x;
+	matrix[13] = y;
+	matrix[14] = z;
+	add_modelview(matrix);
+}
+
+void CL_GraphicContext_Generic::push_translate(double x, double y, double z)
+{
+	push_modelview();
+	add_translate(x, y, z);
+}
+
+void CL_GraphicContext_Generic::set_rotate(double angle, double x, double y, double z)
+{
+	double len2 = x*x+y*y+z*z;
+	if (len2 != 1.0)
+	{
+		double len = sqrt(len2);
+		x /= len;
+		y /= len;
+		z /= len;
+	}
+
+	double c = cos(angle*3.14159265/180);
+	double s = sin(angle*3.14159265/180);
+
+	CL_Matrix4x4 matrix(true);
+	matrix[0] = x*x*(1-c)+c;
+	matrix[1] = y*x*(1-c)+z*s;
+	matrix[2] = x*z*(1-c)-y*s;
+
+	matrix[4] = x*y*(1-c)-z*s;
+	matrix[5] = y*y*(1-c)+c;
+	matrix[6] = y*z*(1-c)+x*s;
+
+	matrix[8] = x*z*(1-c)+y*s;
+	matrix[9] = y*z*(1-c)-x*s;
+	matrix[10] = z*z*(1-c)+c;
+
+	set_modelview(matrix);
+}
+
+void CL_GraphicContext_Generic::add_rotate(double angle, double x, double y, double z)
+{
+	double len2 = x*x+y*y+z*z;
+	if (len2 != 1.0)
+	{
+		double len = sqrt(len2);
+		x /= len;
+		y /= len;
+		z /= len;
+	}
+
+	double c = cos(angle*3.14159265/180);
+	double s = sin(angle*3.14159265/180);
+
+	CL_Matrix4x4 matrix(true);
+	matrix[0] = x*x*(1-c)+c;
+	matrix[1] = y*x*(1-c)+z*s;
+	matrix[2] = x*z*(1-c)-y*s;
+
+	matrix[4] = x*y*(1-c)-z*s;
+	matrix[5] = y*y*(1-c)+c;
+	matrix[6] = y*z*(1-c)+x*s;
+
+	matrix[8] = x*z*(1-c)+y*s;
+	matrix[9] = y*z*(1-c)-x*s;
+	matrix[10] = z*z*(1-c)+c;
+
+	add_modelview(matrix);
+}
+
+void CL_GraphicContext_Generic::push_rotate(double angle, double x, double y, double z)
+{
+	push_modelview();
+	add_rotate(angle, x, y, z);
+}
+
+void CL_GraphicContext_Generic::set_scale(double x, double y, double z)
+{
+	CL_Matrix4x4 matrix(true);
+	matrix[0] = x;
+	matrix[5] = y;
+	matrix[10] = z;
+	set_modelview(matrix);
+}
+
+void CL_GraphicContext_Generic::add_scale(double x, double y, double z)
+{
+	CL_Matrix4x4 matrix(true);
+	matrix[0] = x;
+	matrix[5] = y;
+	matrix[10] = z;
+	add_modelview(matrix);
+}
+
+void CL_GraphicContext_Generic::push_scale(double x, double y, double z)
+{
+	push_modelview();
+	add_scale(x, y, z);
+}
+
+void CL_GraphicContext_Generic::pop_modelview()
+{
+	modelviews.pop_front();
+	if (modelviews.empty())
+	{
+		modelviews.push_front(CL_Matrix4x4(true));
+	}
+	modelview_changed();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_GraphicContext_Generic implementation:

Added: trunk/clanlib/Display/graphic_context_generic.h
===================================================================
--- trunk/clanlib/Display/graphic_context_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/graphic_context_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,237 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_graphic_context_generic
+#define header_graphic_context_generic
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/signals.h&quot;
+#include &quot;API/Core/Math/point.h&quot;
+#include &quot;API/Core/Math/rect.h&quot;
+#include &quot;API/Core/Math/quad.h&quot;
+#include &quot;API/Core/Math/matrix4x4.h&quot;
+#include &quot;API/Display/pixel_buffer.h&quot;
+#include &quot;API/Display/stencil_func.h&quot;
+
+class CL_Color;
+class CL_Gradient;
+class CL_Surface_Target;
+struct CL_TriangleParams;
+
+//: Implementation interface for the graphic context.
+class CL_API_DISPLAY CL_GraphicContext_Generic
+{
+//! Construction:
+public:
+	CL_GraphicContext_Generic();
+
+	virtual ~CL_GraphicContext_Generic();
+
+//! Attributes:
+public:
+	//: Returns the current width of the context.
+	virtual int get_width() const=0;
+
+	//: Returns the current height of the context.
+	virtual int get_height() const=0;
+
+	//: Returns the current clipping rectangle used on the graphic context.
+	virtual const CL_Rect &amp;get_cliprect() const { return cliprects.front(); }
+
+	//: Returns the current effective modelview matrix.
+	virtual const CL_Matrix4x4 &amp;get_modelview() const { return modelviews.front(); }
+
+	//: Returns the color at position (x,y).
+	virtual CL_Color get_pixel(int x, int y) const=0;
+
+	virtual CL_PixelBuffer get_pixeldata(const CL_Rect&amp; rect, int i = 0) const=0;
+
+	//: Returns the maximum size of a surface this displaywindow supports.
+	virtual CL_Size get_max_surface_size() const { return CL_Size(0,0); }
+
+// Operations:
+public:
+	void add_ref();
+
+	void release_ref();
+
+	//: Flushes current rendering batch.
+	//- &lt;p&gt;With the OpenGL target, this causes the graphic context to end its current
+	//- active glBegin()/glEnd() pair, making it possible to call other OpenGL calls.&lt;/p&gt;
+	virtual void flush() { return; }
+
+	//: Draw a pixel at (x, y) using the specified color.
+	virtual void draw_pixel(int x, int y, const CL_Color &amp;color)=0;
+
+	//: Draw a line from (x1, y1) to (x2, y2) using the specified color.
+	virtual void draw_line(float x1, float y1, float x2, float y2, const CL_Color &amp;color)=0;
+
+	//: Draw a chain of lines using the specified color.
+	virtual void draw_lines(int count, double *vertices, const CL_Color &amp;color)=0;
+
+	//: Draw a rectangle using the specified color.
+	virtual void draw_rect(const CL_Rectf &amp;rect, const CL_Color &amp;color)=0;
+
+	//: Draw a gradient rectangle using the specified gradient.
+	virtual void fill_rect(const CL_Rectf &amp;rect, const CL_Gradient &amp;gradient)=0;
+
+	//: Draw a filled rectangle using the specified color.
+	virtual void fill_rect(const CL_Rectf &amp;rect, const CL_Color &amp;color)=0;
+	
+	//: Draw a quad using the specified color.
+	virtual void draw_quad(const CL_Quad &amp;quad, const CL_Color &amp;color)=0;
+
+	//: Draw a gradient quad using the specified gradient.
+	virtual void fill_quad(const CL_Quad &amp;quad, const CL_Gradient &amp;gradient)=0;
+
+	//: Draw a filled quad using the specified color.
+	virtual void fill_quad(const CL_Quad &amp;quad, const CL_Color &amp;color)=0;
+
+	//: Draw triangles (optionally colored and uv-mapped).
+	virtual void draw_triangles(CL_TriangleParams *params)=0;
+
+	//: Clears the whole context using the specified color.
+	virtual void clear(const CL_Color &amp;color)=0;
+
+	//: Set the current clipping rectangle.
+	virtual void set_cliprect(const CL_Rect &amp;rect);
+
+	//: Push current clipping rectangle to stack; then set clipping rectangle to the
+	//: union of the current rectangle and the passed rectangle.
+	virtual void push_cliprect(const CL_Rect &amp;rect);
+
+	//: Push current clipping rectangle to the stack.
+	virtual void push_cliprect();
+
+	//: Pop current clipping rectangle from the stack.
+	virtual void pop_cliprect();
+
+	//: Called every time the active modelview have changed.
+	virtual void modelview_changed()=0;
+
+	//: Sets the model view matrix to a new matrix.
+	void set_modelview(const CL_Matrix4x4 &amp;matrix);
+
+	//: Multiplies the passed matrix onto the model view matrix.
+	void add_modelview(const CL_Matrix4x4 &amp;matrix);
+
+	//: Pushes current model view matrix onto the model view stack.
+	void push_modelview();
+
+	//: Sets a translate offset matrix, ignoring any earlier modelview settings.
+	//- &lt;p&gt; This offset will affect any subsequent display operations on the current
+	//- displaycard, by translating the position of the display operation with the offset.&lt;/p&gt;
+	void set_translate(double x, double y, double z = 0.0);
+
+	//: Adds the translate offset.
+	//- &lt;p&gt; This offset will affect any subsequent display operations on the current
+	//- displaycard, by translating the position of the display operation with the offset.
+	//- The offset will be offset by any previous offsets pushed onto the stack,
+	//- eg. it inherits the previous offset. &lt;/p&gt;
+	void add_translate(double x, double y, double z = 0.0);
+	
+	//: Push translation offset onto model view stack.
+	//- &lt;p&gt;This function is a convenience function for calling push_modelview, then add_translate.&lt;/p&gt;
+	//- &lt;p&gt; This offset will affect any subsequent display operations on the current
+	//- displaycard, by translating the position of the display operation with the offset.
+	//- The offset will be offset by any previous offsets pushed onto the stack,
+	//- eg. it inherits the previous offset. &lt;/p&gt;
+	void push_translate(double x, double y, double z = 0.0);
+
+	//: Sets a rotation matrix, ignoring any earlier model view settings.
+	void set_rotate(double angle, double x = 0.0, double y = 0.0, double z = 1.0);
+
+	//: Adds a rotation matrix to existing model view.
+	void add_rotate(double angle, double x = 0.0, double y = 0.0, double z = 1.0);
+
+	//: Pushes a rotation matrix onto model view stack.
+	void push_rotate(double angle, double x = 0.0, double y = 0.0, double z = 1.0);
+
+	//: Sets a scale matrix, ignoring any earlier model view settings.
+	void set_scale(double x, double y, double z = 1.0);
+
+	//: Adds a scale matrix to existing model view.
+	void add_scale(double x, double y, double z = 1.0);
+
+	//: Pushes a scale matrix onto model view stack.
+	void push_scale(double x, double y, double z = 1.0);
+
+	//: Pops last pushed model view matrix off the stack and makes it the active one.
+	void pop_modelview();
+
+	//: Clear the stencil buffer
+	//param int value : value to clear to. Default: 0
+	virtual void clear_stencil(int value)=0;
+
+	//: Set stencil test function when writing to stencil, and operations to do when a test passes or fails
+	//param CL_StencilOp pass : Modification to stencil buffer when a test passes.
+	//param CL_StencilOp fail : Modification to stencil buffer when a test fails.
+	//param CL_StencilFunc func : Type of test to do when writing to stencil.
+	//param int ref : value compared to stencil contents. Default: 1
+	virtual void set_stencil_operation(CL_StencilOp pass, CL_StencilOp fail, CL_StencilFunc func, int ref)=0;
+
+	//: Enables writing to the stencil buffer 
+	//param bool enabled : Enables/disables stencil testing.
+	//param bool visible : Enables/disables color buffer writing if stencil writing is enabled. Default: true.
+	//param float alpha_limit : Only pixels with alpha &gt;= alpha limit are drawn to the stencil buffer.
+	virtual void enable_stencil_write(bool enabled, bool visible, float alpha_limit)=0;
+
+	//: Enables stencil buffer testing
+	//- &lt;p&gt; Individual pixels are tested against the values in the stencil buffer, and
+	//- drawn depending on the comparison result. This can be used for masking and
+	//- boolean operations on bitmaps &lt;/p&gt;
+	//param bool enabled : Enables/disables stencil testing.
+	//param int func : Type of comparison. Default: lequal (pass if ref &lt;= stencil)
+	//param int ref : Reference value that the stencil is compared with. Default: 1
+	virtual void enable_stencil_test(bool enabled, CL_StencilFunc func, int ref)=0;
+
+//! Implementation:
+protected:
+	std::list&lt;CL_Rect&gt; cliprects;
+
+	std::list&lt;CL_Matrix4x4&gt; modelviews;
+
+private:
+	int ref_count;
+};
+
+#endif

Added: trunk/clanlib/Display/input_buffer.cpp
===================================================================
--- trunk/clanlib/Display/input_buffer.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/input_buffer.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,136 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/input_buffer.h&quot;
+#include &quot;API/Display/input_context.h&quot;
+#include &quot;input_buffer_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputBuffer construction:
+
+CL_InputBuffer::CL_InputBuffer()
+: impl(new CL_InputBuffer_Generic)
+{
+	impl-&gt;add_ref();
+}
+
+CL_InputBuffer::CL_InputBuffer(CL_InputDevice &amp;device)
+: impl(new CL_InputBuffer_Generic)
+{
+	add_device(device);
+	impl-&gt;add_ref();
+}
+
+CL_InputBuffer::CL_InputBuffer(CL_InputContext *ic)
+: impl(new CL_InputBuffer_Generic)
+{
+	add_devices(ic);
+	impl-&gt;add_ref();
+}
+
+CL_InputBuffer::CL_InputBuffer(const CL_InputBuffer &amp;copy)
+: impl(copy.impl)
+{
+	if (impl) impl-&gt;add_ref();
+}
+
+CL_InputBuffer::~CL_InputBuffer()
+{
+	if (impl) impl-&gt;release_ref();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputBuffer attributes:
+
+int CL_InputBuffer::keys_left() const
+{
+	return impl-&gt;buffer.size();
+}
+
+CL_InputEvent CL_InputBuffer::peek_key() const
+{
+	if (impl-&gt;buffer.empty()) return CL_InputEvent();
+	return impl-&gt;buffer.front();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputBuffer operations:
+
+CL_InputBuffer &amp;CL_InputBuffer::operator =(const CL_InputBuffer &amp;copy)
+{
+	if (impl) impl-&gt;release_ref();
+	impl = copy.impl;
+	if (impl) impl-&gt;add_ref();
+	return *this;
+}
+
+void CL_InputBuffer::add_device(CL_InputDevice &amp;device)
+{
+	impl-&gt;slots.connect(device.sig_key_down(), impl, &amp;CL_InputBuffer_Generic::on_key_down);
+	impl-&gt;slots.connect(device.sig_key_up(), impl, &amp;CL_InputBuffer_Generic::on_key_up);
+}
+
+void CL_InputBuffer::add_devices(CL_InputContext *ic)
+{
+	for (int k = 0; k &lt; ic-&gt;get_keyboard_count(); k++)
+	{
+		impl-&gt;slots.connect(ic-&gt;get_keyboard(k).sig_key_down(), impl, &amp;CL_InputBuffer_Generic::on_key_down);
+		impl-&gt;slots.connect(ic-&gt;get_keyboard(k).sig_key_up(), impl, &amp;CL_InputBuffer_Generic::on_key_up);
+	}
+
+	for (int m = 0; m &lt; ic-&gt;get_mouse_count(); m++)
+	{
+		impl-&gt;slots.connect(ic-&gt;get_mouse(m).sig_key_down(), impl, &amp;CL_InputBuffer_Generic::on_key_down);
+		impl-&gt;slots.connect(ic-&gt;get_mouse(m).sig_key_up(), impl, &amp;CL_InputBuffer_Generic::on_key_up);
+	}
+
+	for (int j = 0; j &lt; ic-&gt;get_joystick_count(); j++)
+	{
+		impl-&gt;slots.connect(ic-&gt;get_joystick(j).sig_key_down(), impl, &amp;CL_InputBuffer_Generic::on_key_down);
+		impl-&gt;slots.connect(ic-&gt;get_joystick(j).sig_key_up(), impl, &amp;CL_InputBuffer_Generic::on_key_up);
+	}
+}
+
+CL_InputEvent CL_InputBuffer::pop_key()
+{
+	if (impl-&gt;buffer.empty()) return CL_InputEvent();
+
+	CL_InputEvent k = impl-&gt;buffer.front();
+	impl-&gt;buffer.pop();
+	return k;
+}
+
+void CL_InputBuffer::clear()
+{
+	impl-&gt;buffer = std::queue&lt;CL_InputEvent&gt;();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputBuffer implementation:

Added: trunk/clanlib/Display/input_buffer_generic.h
===================================================================
--- trunk/clanlib/Display/input_buffer_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/input_buffer_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,68 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_input_buffer_generic
+#define header_input_buffer_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;queue&gt;
+#include &quot;API/Display/input_event.h&quot;
+#include &quot;API/signals.h&quot;
+
+class CL_InputBuffer_Generic
+{
+//! Construction:
+public:
+	CL_InputBuffer_Generic() : ref_count(0) { return; }
+
+//! Attributes:
+public:
+	std::queue&lt;CL_InputEvent&gt; buffer;
+
+	CL_SlotContainer slots;
+
+//! Operations:
+public:
+	void add_ref() { ref_count++; }
+
+	void release_ref() { ref_count--; if (ref_count == 0) delete this; }
+
+	void on_key_down(const CL_InputEvent &amp;key) { buffer.push(key); }
+
+	void on_key_up(const CL_InputEvent &amp;key) { buffer.push(key); }
+
+//! Implementation:
+private:
+	int ref_count;
+};
+
+#endif

Added: trunk/clanlib/Display/input_button.cpp
===================================================================
--- trunk/clanlib/Display/input_button.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/input_button.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,114 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/input_button.h&quot;
+#include &quot;input_button_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputButton construction:
+
+CL_InputButton::CL_InputButton()
+: impl(new CL_InputButton_Generic)
+{
+}
+
+CL_InputButton::CL_InputButton(const CL_InputButton &amp;copy)
+: impl(new CL_InputButton_Generic)
+{
+	// TODO:
+}
+
+CL_InputButton::~CL_InputButton()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputButton attributes:
+
+int CL_InputButton::peek_pressed() const
+{
+	return impl-&gt;presses;
+}
+
+CL_InputEvent CL_InputButton::peek_key() const
+{
+	// TODO:
+	return CL_InputEvent();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputButton operations:
+
+CL_InputButton &amp;CL_InputButton::operator =(const CL_InputButton &amp;copy)
+{
+	// TODO:
+	return *this;
+}
+
+void CL_InputButton::bind(const CL_KeyBinding &amp;key)
+{
+	impl-&gt;bind(key);
+}
+
+void CL_InputButton::unbind(const CL_KeyBinding &amp;key)
+{
+	impl-&gt;unbind(key);
+}
+
+void CL_InputButton::unbind_all()
+{
+	impl-&gt;bindings.clear();
+}
+
+const std::list&lt;CL_KeyBinding&gt; &amp;CL_InputButton::get_bindings() const
+{
+	return impl-&gt;bindings;
+}
+
+int CL_InputButton::pop_pressed()
+{
+	int presses = impl-&gt;presses;
+	impl-&gt;presses = 0;
+	return presses;
+}
+
+CL_InputEvent CL_InputButton::pop_key()
+{
+	impl-&gt;presses = 0;
+	return CL_InputEvent();
+}
+
+void CL_InputButton::clear()
+{
+	impl-&gt;presses = 0;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputButton implementation:

Added: trunk/clanlib/Display/input_button_generic.cpp
===================================================================
--- trunk/clanlib/Display/input_button_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/input_button_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,76 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;input_button_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputButton_Generic construction:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputButton_Generic attributes:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputButton_Generic operations:
+
+void CL_InputButton_Generic::bind(const CL_KeyBinding &amp;key)
+{
+	bindings.push_back(key);
+	
+	slots.connect(key.get_device().sig_key_down(), this, &amp;CL_InputButton_Generic::on_input_down);
+}
+
+void CL_InputButton_Generic::unbind(const CL_KeyBinding &amp;key)
+{
+	// TODO: Remove slot
+	
+	bindings.remove(key);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputButton_Generic implementation:
+
+void CL_InputButton_Generic::on_input_down(const CL_InputEvent &amp;key)
+{
+	for(std::list&lt;CL_KeyBinding&gt;::iterator it = bindings.begin(); it != bindings.end();it++)
+	{
+		if(key.id == it-&gt;get_keycode())
+		{
+			presses++;
+			return;
+		}
+	}
+}
+
+void CL_InputButton_Generic::on_input_up(const CL_InputEvent &amp;key)
+{
+	// TODO:
+	// What needs to be done exactly?
+	// --MSR April 22, 2003
+}

Added: trunk/clanlib/Display/input_button_generic.h
===================================================================
--- trunk/clanlib/Display/input_button_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/input_button_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,67 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_inputbutton_generic
+#define header_inputbutton_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Display/input_event.h&quot;
+#include &quot;API/Display/key_binding.h&quot;
+#include &quot;API/signals.h&quot;
+
+#include &lt;list&gt;
+
+class CL_InputButton_Generic
+{
+//! Construction:
+public:
+	CL_InputButton_Generic() { return; }
+
+//! Attributes:
+public:
+	int presses;
+	std::list&lt;CL_KeyBinding&gt; bindings;
+
+//! Operations:
+public:
+	void bind(const CL_KeyBinding &amp;key);
+	void unbind(const CL_KeyBinding &amp;key);
+
+//! Implementation:
+private:
+	CL_SlotContainer slots;
+
+	void on_input_down(const CL_InputEvent &amp;key);
+	void on_input_up(const CL_InputEvent &amp;key);
+};
+
+#endif

Added: trunk/clanlib/Display/input_context.cpp
===================================================================
--- trunk/clanlib/Display/input_context.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/input_context.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,138 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Display/input_context.h&quot;
+#include &quot;input_context_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputContext Construction:
+
+CL_InputContext::CL_InputContext() : impl(new CL_InputContext_Generic)
+{
+	impl-&gt;add_ref();
+}
+
+CL_InputContext::CL_InputContext(const CL_InputContext &amp;copy) : impl(copy.impl)
+{
+	if (impl) impl-&gt;add_ref();
+}
+
+CL_InputContext::~CL_InputContext()
+{
+	if (impl) impl-&gt;release_ref();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputContext Attributes:
+
+int CL_InputContext::get_keyboard_count() const
+{
+	return impl-&gt;keyboards.size();
+}
+
+int CL_InputContext::get_mouse_count() const
+{
+	return impl-&gt;mice.size();
+}
+
+int CL_InputContext::get_joystick_count() const
+{
+	return impl-&gt;joysticks.size();
+}
+
+CL_InputDevice &amp;CL_InputContext::get_keyboard(int keyboard)
+{
+	return impl-&gt;keyboards[keyboard];
+}
+
+CL_InputDevice &amp;CL_InputContext::get_mouse(int mouse)
+{
+	return impl-&gt;mice[mouse];
+}
+
+CL_InputDevice &amp;CL_InputContext::get_joystick(int joystick)
+{
+	return impl-&gt;joysticks[joystick];
+}
+
+CL_InputDevice &amp;CL_InputContext::get_device(const std::string&amp; devicename)
+{
+	size_t i;
+	for (i = 0; i &lt; impl-&gt;joysticks.size(); ++i)
+		if (impl-&gt;joysticks[i].get_device_name() == devicename)
+			return impl-&gt;joysticks[i];
+
+	for (i = 0; i &lt; impl-&gt;keyboards.size(); ++i)
+		if (impl-&gt;keyboards[i].get_device_name() == devicename)
+			return impl-&gt;keyboards[i];
+
+	for (i = 0; i &lt; impl-&gt;mice.size(); ++i)
+		if (impl-&gt;mice[i].get_device_name() == devicename)
+			return impl-&gt;mice[i];
+
+	throw CL_Error(&quot;Couldn't find CL_InputDevice named '&quot; + devicename + &quot;'&quot;);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputContext operations:
+
+CL_InputContext &amp;CL_InputContext::operator =(CL_InputContext &amp;copy)
+{
+	if (impl == copy.impl) return *this;
+	if (impl) impl-&gt;release_ref();
+	impl = copy.impl;
+	if (impl) impl-&gt;add_ref();
+	return *this;
+}
+
+void CL_InputContext::clear()
+{
+	impl-&gt;clear();
+}
+
+void CL_InputContext::add_keyboard(const CL_InputDevice &amp;keyboard)
+{
+	impl-&gt;add_keyboard(keyboard);
+}
+
+void CL_InputContext::add_mouse(const CL_InputDevice &amp;mouse)
+{
+	impl-&gt;add_mouse(mouse);
+}
+
+void CL_InputContext::add_joystick(const CL_InputDevice &amp;joystick)
+{
+	impl-&gt;add_joystick(joystick);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputContext implementation:
+

Added: trunk/clanlib/Display/input_context_generic.cpp
===================================================================
--- trunk/clanlib/Display/input_context_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/input_context_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,86 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;input_context_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputContext_Generic construction:
+
+CL_InputContext_Generic::CL_InputContext_Generic()
+: ref_count(0)
+{
+}
+
+CL_InputContext_Generic::~CL_InputContext_Generic()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputContext_Generic attributes:
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputContext_Generic operations:
+
+void CL_InputContext_Generic::add_ref()
+{
+	ref_count++;
+}
+
+void CL_InputContext_Generic::release_ref()
+{
+	ref_count--;
+	if (ref_count == 0) delete this;
+}
+
+void CL_InputContext_Generic::clear()
+{
+	keyboards.clear();
+	mice.clear();
+	joysticks.clear();
+}
+
+void CL_InputContext_Generic::add_keyboard(const CL_InputDevice &amp;keyboard)
+{
+	keyboards.push_back(keyboard);
+}
+
+void CL_InputContext_Generic::add_mouse(const CL_InputDevice &amp;mouse)
+{
+	mice.push_back(mouse);
+}
+
+void CL_InputContext_Generic::add_joystick(const CL_InputDevice &amp;joystick)
+{
+	joysticks.push_back(joystick);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputContext_Generic implementation:

Added: trunk/clanlib/Display/input_context_generic.h
===================================================================
--- trunk/clanlib/Display/input_context_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/input_context_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,82 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_input_context_generic
+#define header_input_context_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;vector&gt;
+#include &quot;API/Display/input_device.h&quot;
+
+class CL_InputEvent;
+
+//: Input events interface.
+class CL_InputContext_Generic
+{
+//! Construction:
+public:
+	CL_InputContext_Generic();
+
+	~CL_InputContext_Generic();
+
+//! Attributes:
+public:
+	std::vector&lt;CL_InputDevice&gt; keyboards;
+
+	std::vector&lt;CL_InputDevice&gt; mice;
+
+	std::vector&lt;CL_InputDevice&gt; joysticks;
+
+//! Operations:
+public:
+	void add_ref();
+
+	void release_ref();
+
+	//: Removes all devices from this input context.
+	void clear();
+
+	//: Adds a new keyboard to the input context.
+	void add_keyboard(const CL_InputDevice &amp;keyboard);
+
+	//: Adds a new mouse to the input context.
+	void add_mouse(const CL_InputDevice &amp;mouse);
+
+	//: Adds a new joystick to the input context.
+	void add_joystick(const CL_InputDevice &amp;joystick);
+
+//! Implementation:
+private:
+	int ref_count;
+};
+
+#endif

Added: trunk/clanlib/Display/input_device.cpp
===================================================================
--- trunk/clanlib/Display/input_device.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/input_device.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,178 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/input_device.h&quot;
+#include &quot;input_device_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice construction:
+
+CL_InputDevice::CL_InputDevice()
+: impl(0)
+{
+}
+
+CL_InputDevice::CL_InputDevice(const CL_InputDevice &amp;copy)
+: impl(copy.impl)
+{
+	if (impl) impl-&gt;add_ref();
+}
+
+CL_InputDevice::~CL_InputDevice()
+{
+	if (impl) impl-&gt;release_ref();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice attributes:
+
+CL_InputDevice::Type CL_InputDevice::get_type() const
+{
+	return impl-&gt;type;
+}
+
+std::string CL_InputDevice::get_key_name(int id) const
+{
+	return impl-&gt;get_key_name(id);
+}
+
+int CL_InputDevice::get_x() const
+{
+	return impl-&gt;get_x();
+}
+
+int CL_InputDevice::get_y() const
+{
+	return impl-&gt;get_y();
+}
+
+bool CL_InputDevice::get_keycode(int keycode) const
+{
+	return impl-&gt;get_keycode(keycode);
+}
+
+std::string CL_InputDevice::keyid_to_string(int keycode) const
+{
+	return impl-&gt;keyid_to_string(keycode);
+}
+
+int CL_InputDevice::string_to_keyid(const std::string &amp;str) const
+{
+	return impl-&gt;string_to_keyid(str);
+}
+
+float CL_InputDevice::get_axis(int index) const
+{
+	return impl-&gt;get_axis(index);
+}
+
+std::string CL_InputDevice::get_name() const
+{
+	return impl-&gt;get_name();
+}
+
+std::string CL_InputDevice::get_device_name() const
+{
+	return impl-&gt;get_device_name();
+}
+
+int CL_InputDevice::get_axis_count() const
+{
+	return impl-&gt;get_axis_count();
+}
+
+int CL_InputDevice::get_button_count() const
+{
+	return impl-&gt;get_button_count();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice operations:
+
+CL_InputDevice &amp;CL_InputDevice::operator =(const CL_InputDevice &amp;copy)
+{
+	if (impl) impl-&gt;release_ref();
+	impl = copy.impl;
+	if (impl) impl-&gt;add_ref();
+
+	return *this;
+}
+
+void CL_InputDevice::set_position(int x, int y)
+{
+	impl-&gt;set_position(x, y);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice signals:
+
+CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;CL_InputDevice::sig_key_down()
+{
+	return impl-&gt;sig_key_down;
+}
+
+CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;CL_InputDevice::sig_key_up()
+{
+	return impl-&gt;sig_key_up;
+}
+
+CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;CL_InputDevice::sig_key_dblclk()
+{
+	return impl-&gt;sig_key_dblclk;
+}
+
+CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;CL_InputDevice::sig_pointer_move()
+{
+	return impl-&gt;sig_pointer_move;
+}
+
+CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;CL_InputDevice::sig_axis_move()
+{
+	return impl-&gt;sig_axis_move;
+}
+
+CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;CL_InputDevice::sig_ball_move()
+{
+	return impl-&gt;sig_ball_move;
+}
+
+CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;CL_InputDevice::sig_move()
+{
+	return impl-&gt;sig_pointer_move;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice implementation:
+
+CL_InputDevice::CL_InputDevice(CL_InputDevice_Generic *impl)
+: impl(impl)
+{
+	if (impl) impl-&gt;add_ref();
+}

Added: trunk/clanlib/Display/input_device_generic.cpp
===================================================================
--- trunk/clanlib/Display/input_device_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/input_device_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,330 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;input_device_generic.h&quot;
+#include &quot;API/Display/keys.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &lt;map&gt;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_Generic construction:
+
+CL_InputDevice_Generic::CL_InputDevice_Generic()
+: ref_count(0)
+{
+}
+
+CL_InputDevice_Generic::~CL_InputDevice_Generic()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_Generic attributes:
+
+std::string CL_InputDevice_Generic::keyid_to_string(int keycode) const
+{
+	switch (keycode)
+	{
+	case CL_KEY_BACKSPACE: return &quot;backspace&quot;;
+	case CL_KEY_TAB: return &quot;tab&quot;;
+	case CL_KEY_CLEAR: return &quot;clear&quot;;
+	case CL_KEY_RETURN: return &quot;return&quot;;
+#ifdef WIN32
+	case CL_KEY_SHIFT: return &quot;shift&quot;;
+	case CL_KEY_CONTROL: return &quot;control&quot;;
+#endif
+
+#if !defined(__CYGWIN__) &amp;&amp; !defined(__MINGW32__)
+	case CL_KEY_KANJI: return &quot;kanji&quot;;
+	case CL_KEY_CONVERT: return &quot;convert&quot;;
+	case CL_KEY_NONCONVERT: return &quot;nonconvert&quot;;
+#endif
+	case CL_KEY_MENU: return &quot;menu&quot;;
+	case CL_KEY_PAUSE: return &quot;pause&quot;;
+	case CL_KEY_ESCAPE: return &quot;escape&quot;;
+	case CL_KEY_SPACE: return &quot;space&quot;;
+	case CL_KEY_PRIOR: return &quot;prior&quot;;
+	case CL_KEY_NEXT: return &quot;next&quot;;
+	case CL_KEY_END: return &quot;end&quot;;
+	case CL_KEY_HOME: return &quot;home&quot;;
+	case CL_KEY_LEFT: return &quot;left&quot;;
+	case CL_KEY_UP: return &quot;up&quot;;
+	case CL_KEY_RIGHT: return &quot;right&quot;;
+	case CL_KEY_DOWN: return &quot;down&quot;;
+	case CL_KEY_SELECT: return &quot;select&quot;;
+	case CL_KEY_PRINT: return &quot;print&quot;;
+	case CL_KEY_EXECUTE: return &quot;execute&quot;;
+	case CL_KEY_INSERT: return &quot;insert&quot;;
+	case CL_KEY_DELETE: return &quot;delete&quot;;
+	case CL_KEY_HELP: return &quot;help&quot;;
+	case CL_KEY_0: return &quot;0&quot;;
+	case CL_KEY_1: return &quot;1&quot;;
+	case CL_KEY_2: return &quot;2&quot;;
+	case CL_KEY_3: return &quot;3&quot;;
+	case CL_KEY_4: return &quot;4&quot;;
+	case CL_KEY_5: return &quot;5&quot;;
+	case CL_KEY_6: return &quot;6&quot;;
+	case CL_KEY_7: return &quot;7&quot;;
+	case CL_KEY_8: return &quot;8&quot;;
+	case CL_KEY_9: return &quot;9&quot;;
+	case CL_KEY_A: return &quot;a&quot;;
+	case CL_KEY_B: return &quot;b&quot;;
+	case CL_KEY_C: return &quot;c&quot;;
+	case CL_KEY_D: return &quot;d&quot;;
+	case CL_KEY_E: return &quot;e&quot;;
+	case CL_KEY_F: return &quot;f&quot;;
+	case CL_KEY_G: return &quot;g&quot;;
+	case CL_KEY_H: return &quot;h&quot;;
+	case CL_KEY_I: return &quot;i&quot;;
+	case CL_KEY_J: return &quot;j&quot;;
+	case CL_KEY_K: return &quot;k&quot;;
+	case CL_KEY_L: return &quot;l&quot;;
+	case CL_KEY_M: return &quot;m&quot;;
+	case CL_KEY_N: return &quot;n&quot;;
+	case CL_KEY_O: return &quot;o&quot;;
+	case CL_KEY_P: return &quot;p&quot;;
+	case CL_KEY_Q: return &quot;q&quot;;
+	case CL_KEY_R: return &quot;r&quot;;
+	case CL_KEY_S: return &quot;s&quot;;
+	case CL_KEY_T: return &quot;t&quot;;
+	case CL_KEY_U: return &quot;u&quot;;
+	case CL_KEY_V: return &quot;v&quot;;
+	case CL_KEY_W: return &quot;w&quot;;
+	case CL_KEY_X: return &quot;x&quot;;
+	case CL_KEY_Y: return &quot;y&quot;;
+	case CL_KEY_Z: return &quot;z&quot;;
+	case CL_KEY_LWIN: return &quot;lwin&quot;;
+	case CL_KEY_RWIN: return &quot;rwin&quot;;
+	case CL_KEY_NUMPAD0: return &quot;numpad0&quot;;
+	case CL_KEY_NUMPAD1: return &quot;numpad1&quot;;
+	case CL_KEY_NUMPAD2: return &quot;numpad2&quot;;
+	case CL_KEY_NUMPAD3: return &quot;numpad3&quot;;
+	case CL_KEY_NUMPAD4: return &quot;numpad4&quot;;
+	case CL_KEY_NUMPAD5: return &quot;numpad5&quot;;
+	case CL_KEY_NUMPAD6: return &quot;numpad6&quot;;
+	case CL_KEY_NUMPAD7: return &quot;numpad7&quot;;
+	case CL_KEY_NUMPAD8: return &quot;numpad8&quot;;
+	case CL_KEY_NUMPAD9: return &quot;numpad9&quot;;
+	case CL_KEY_MULTIPLY: return &quot;multiply&quot;;
+	case CL_KEY_ADD: return &quot;add&quot;;
+#ifndef __APPLE__
+	case CL_KEY_SEPARATOR: return &quot;separator&quot;;
+#endif
+	case CL_KEY_SUBTRACT: return &quot;subtract&quot;;
+	case CL_KEY_DECIMAL: return &quot;decimal&quot;;
+	case CL_KEY_DIVIDE: return &quot;divide&quot;;
+	case CL_KEY_F1: return &quot;f1&quot;;
+	case CL_KEY_F2: return &quot;f2&quot;;
+	case CL_KEY_F3: return &quot;f3&quot;;
+	case CL_KEY_F4: return &quot;f4&quot;;
+	case CL_KEY_F5: return &quot;f5&quot;;
+	case CL_KEY_F6: return &quot;f6&quot;;
+	case CL_KEY_F7: return &quot;f7&quot;;
+	case CL_KEY_F8: return &quot;f8&quot;;
+	case CL_KEY_F9: return &quot;f9&quot;;
+	case CL_KEY_F10: return &quot;f10&quot;;
+	case CL_KEY_F11: return &quot;f11&quot;;
+	case CL_KEY_F12: return &quot;f12&quot;;
+	case CL_KEY_F13: return &quot;f13&quot;;
+	case CL_KEY_F14: return &quot;f14&quot;;
+	case CL_KEY_F15: return &quot;f15&quot;;
+	case CL_KEY_F16: return &quot;f16&quot;;
+	case CL_KEY_F17: return &quot;f17&quot;;
+	case CL_KEY_F18: return &quot;f18&quot;;
+	case CL_KEY_F19: return &quot;f19&quot;;
+	case CL_KEY_F20: return &quot;f20&quot;;
+	case CL_KEY_F21: return &quot;f21&quot;;
+	case CL_KEY_F22: return &quot;f22&quot;;
+	case CL_KEY_F23: return &quot;f23&quot;;
+	case CL_KEY_F24: return &quot;f24&quot;;
+	case CL_KEY_NUMLOCK: return &quot;numlock&quot;;
+	case CL_KEY_SCROLL: return &quot;scroll&quot;;
+	case CL_KEY_LSHIFT: return &quot;lshift&quot;;
+	case CL_KEY_RSHIFT: return &quot;rshift&quot;;
+	case CL_KEY_LCONTROL: return &quot;lcontrol&quot;;
+	case CL_KEY_RCONTROL: return &quot;rcontrol&quot;;
+	case CL_KEY_LMENU: return &quot;lmenu&quot;;
+	case CL_KEY_RMENU: return &quot;rmenu&quot;;
+	default:
+		return CL_String::format(&quot;key_%1&quot;, keycode);
+	}
+}
+
+int CL_InputDevice_Generic::string_to_keyid(const std::string &amp;str) const
+{
+	if (str.substr(0, 4) == &quot;key_&quot;)
+	{
+		return CL_String::to_int(str.substr(4));
+	}
+
+	static std::map&lt;std::string, int&gt; string_to_id;
+	static bool first_call = true;
+	if (first_call)
+	{
+		first_call = false;
+		string_to_id[&quot;backspace&quot;] = CL_KEY_BACKSPACE;
+		string_to_id[&quot;tab&quot;] = CL_KEY_TAB;
+		string_to_id[&quot;clear&quot;] = CL_KEY_CLEAR;
+		string_to_id[&quot;return&quot;] = CL_KEY_RETURN;
+#ifdef WIN32
+		string_to_id[&quot;shift&quot;] = CL_KEY_SHIFT;
+		string_to_id[&quot;control&quot;] = CL_KEY_CONTROL;
+#endif
+
+#if !defined(__CYGWIN__) &amp;&amp; !defined(__MINGW32__)
+		string_to_id[&quot;kanji&quot;] = CL_KEY_KANJI;
+		string_to_id[&quot;convert&quot;] = CL_KEY_CONVERT;
+		string_to_id[&quot;nonconvert&quot;] = CL_KEY_NONCONVERT;
+#endif
+		string_to_id[&quot;menu&quot;] = CL_KEY_MENU;
+		string_to_id[&quot;pause&quot;] = CL_KEY_PAUSE;
+		string_to_id[&quot;escape&quot;] = CL_KEY_ESCAPE;
+		string_to_id[&quot;space&quot;] = CL_KEY_SPACE;
+		string_to_id[&quot;prior&quot;] = CL_KEY_PRIOR;
+		string_to_id[&quot;next&quot;] = CL_KEY_NEXT;
+		string_to_id[&quot;end&quot;] = CL_KEY_END;
+		string_to_id[&quot;home&quot;] = CL_KEY_HOME;
+		string_to_id[&quot;left&quot;] = CL_KEY_LEFT;
+		string_to_id[&quot;up&quot;] = CL_KEY_UP;
+		string_to_id[&quot;right&quot;] = CL_KEY_RIGHT;
+		string_to_id[&quot;down&quot;] = CL_KEY_DOWN;
+		string_to_id[&quot;select&quot;] = CL_KEY_SELECT;
+		string_to_id[&quot;print&quot;] = CL_KEY_PRINT;
+		string_to_id[&quot;execute&quot;] = CL_KEY_EXECUTE;
+		string_to_id[&quot;insert&quot;] = CL_KEY_INSERT;
+		string_to_id[&quot;delete&quot;] = CL_KEY_DELETE;
+		string_to_id[&quot;help&quot;] = CL_KEY_HELP;
+		string_to_id[&quot;0&quot;] = CL_KEY_0;
+		string_to_id[&quot;1&quot;] = CL_KEY_1;
+		string_to_id[&quot;2&quot;] = CL_KEY_2;
+		string_to_id[&quot;3&quot;] = CL_KEY_3;
+		string_to_id[&quot;4&quot;] = CL_KEY_4;
+		string_to_id[&quot;5&quot;] = CL_KEY_5;
+		string_to_id[&quot;6&quot;] = CL_KEY_6;
+		string_to_id[&quot;7&quot;] = CL_KEY_7;
+		string_to_id[&quot;8&quot;] = CL_KEY_8;
+		string_to_id[&quot;9&quot;] = CL_KEY_9;
+		string_to_id[&quot;a&quot;] = CL_KEY_A;
+		string_to_id[&quot;b&quot;] = CL_KEY_B;
+		string_to_id[&quot;c&quot;] = CL_KEY_C;
+		string_to_id[&quot;d&quot;] = CL_KEY_D;
+		string_to_id[&quot;e&quot;] = CL_KEY_E;
+		string_to_id[&quot;f&quot;] = CL_KEY_F;
+		string_to_id[&quot;g&quot;] = CL_KEY_G;
+		string_to_id[&quot;h&quot;] = CL_KEY_H;
+		string_to_id[&quot;i&quot;] = CL_KEY_I;
+		string_to_id[&quot;j&quot;] = CL_KEY_J;
+		string_to_id[&quot;k&quot;] = CL_KEY_K;
+		string_to_id[&quot;l&quot;] = CL_KEY_L;
+		string_to_id[&quot;m&quot;] = CL_KEY_M;
+		string_to_id[&quot;n&quot;] = CL_KEY_N;
+		string_to_id[&quot;o&quot;] = CL_KEY_O;
+		string_to_id[&quot;p&quot;] = CL_KEY_P;
+		string_to_id[&quot;q&quot;] = CL_KEY_Q;
+		string_to_id[&quot;r&quot;] = CL_KEY_R;
+		string_to_id[&quot;s&quot;] = CL_KEY_S;
+		string_to_id[&quot;t&quot;] = CL_KEY_T;
+		string_to_id[&quot;u&quot;] = CL_KEY_U;
+		string_to_id[&quot;v&quot;] = CL_KEY_V;
+		string_to_id[&quot;w&quot;] = CL_KEY_W;
+		string_to_id[&quot;x&quot;] = CL_KEY_X;
+		string_to_id[&quot;y&quot;] = CL_KEY_Y;
+		string_to_id[&quot;z&quot;] = CL_KEY_Z;
+		string_to_id[&quot;lwin&quot;] = CL_KEY_LWIN;
+		string_to_id[&quot;rwin&quot;] = CL_KEY_RWIN;
+		string_to_id[&quot;numpad0&quot;] = CL_KEY_NUMPAD0;
+		string_to_id[&quot;numpad1&quot;] = CL_KEY_NUMPAD1;
+		string_to_id[&quot;numpad2&quot;] = CL_KEY_NUMPAD2;
+		string_to_id[&quot;numpad3&quot;] = CL_KEY_NUMPAD3;
+		string_to_id[&quot;numpad4&quot;] = CL_KEY_NUMPAD4;
+		string_to_id[&quot;numpad5&quot;] = CL_KEY_NUMPAD5;
+		string_to_id[&quot;numpad6&quot;] = CL_KEY_NUMPAD6;
+		string_to_id[&quot;numpad7&quot;] = CL_KEY_NUMPAD7;
+		string_to_id[&quot;numpad8&quot;] = CL_KEY_NUMPAD8;
+		string_to_id[&quot;numpad9&quot;] = CL_KEY_NUMPAD9;
+		string_to_id[&quot;multiply&quot;] = CL_KEY_MULTIPLY;
+		string_to_id[&quot;add&quot;] = CL_KEY_ADD;
+		string_to_id[&quot;separator&quot;] = CL_KEY_SEPARATOR;
+		string_to_id[&quot;subtract&quot;] = CL_KEY_SUBTRACT;
+		string_to_id[&quot;decimal&quot;] = CL_KEY_DECIMAL;
+		string_to_id[&quot;divide&quot;] = CL_KEY_DIVIDE;
+		string_to_id[&quot;f1&quot;] = CL_KEY_F1;
+		string_to_id[&quot;f2&quot;] = CL_KEY_F2;
+		string_to_id[&quot;f3&quot;] = CL_KEY_F3;
+		string_to_id[&quot;f4&quot;] = CL_KEY_F4;
+		string_to_id[&quot;f5&quot;] = CL_KEY_F5;
+		string_to_id[&quot;f6&quot;] = CL_KEY_F6;
+		string_to_id[&quot;f7&quot;] = CL_KEY_F7;
+		string_to_id[&quot;f8&quot;] = CL_KEY_F8;
+		string_to_id[&quot;f9&quot;] = CL_KEY_F9;
+		string_to_id[&quot;f10&quot;] = CL_KEY_F10;
+		string_to_id[&quot;f11&quot;] = CL_KEY_F11;
+		string_to_id[&quot;f12&quot;] = CL_KEY_F12;
+		string_to_id[&quot;f13&quot;] = CL_KEY_F13;
+		string_to_id[&quot;f14&quot;] = CL_KEY_F14;
+		string_to_id[&quot;f15&quot;] = CL_KEY_F15;
+		string_to_id[&quot;f16&quot;] = CL_KEY_F16;
+		string_to_id[&quot;f17&quot;] = CL_KEY_F17;
+		string_to_id[&quot;f18&quot;] = CL_KEY_F18;
+		string_to_id[&quot;f19&quot;] = CL_KEY_F19;
+		string_to_id[&quot;f20&quot;] = CL_KEY_F20;
+		string_to_id[&quot;f21&quot;] = CL_KEY_F21;
+		string_to_id[&quot;f22&quot;] = CL_KEY_F22;
+		string_to_id[&quot;f23&quot;] = CL_KEY_F23;
+		string_to_id[&quot;f24&quot;] = CL_KEY_F24;
+		string_to_id[&quot;numlock&quot;] = CL_KEY_NUMLOCK;
+		string_to_id[&quot;scroll&quot;] = CL_KEY_SCROLL;
+		string_to_id[&quot;lshift&quot;] = CL_KEY_LSHIFT;
+		string_to_id[&quot;rshift&quot;] = CL_KEY_RSHIFT;
+		string_to_id[&quot;lcontrol&quot;] = CL_KEY_LCONTROL;
+		string_to_id[&quot;rcontrol&quot;] = CL_KEY_RCONTROL;
+		string_to_id[&quot;lmenu&quot;] = CL_KEY_LMENU;
+		string_to_id[&quot;rmenu&quot;] = CL_KEY_RMENU;
+	}
+
+	return string_to_id[str];
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_Generic operations:
+
+void CL_InputDevice_Generic::add_ref()
+{
+	ref_count++;
+}
+
+void CL_InputDevice_Generic::release_ref()
+{
+	ref_count--;
+	if (ref_count == 0) delete this;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_Generic implementation:

Added: trunk/clanlib/Display/input_device_generic.h
===================================================================
--- trunk/clanlib/Display/input_device_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/input_device_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,125 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_input_device_generic
+#define header_input_device_generic
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Display/input_device.h&quot;
+
+class CL_API_DISPLAY CL_InputDevice_Generic
+{
+//! Construction:
+public:
+	CL_InputDevice_Generic();
+
+	virtual ~CL_InputDevice_Generic();
+
+//! Attributes:
+public:
+	//: The input device type.
+	CL_InputDevice::Type type;
+
+	//: Returns the x position of the device.
+	virtual int get_x() const { return 0; }
+
+	//: Returns the y position of the device.
+	virtual int get_y() const { return 0; }
+
+	//: Returns true if the passed key code is down for this device.
+	virtual bool get_keycode(int keycode) const { return false; }
+
+	//: Key name for specified identifier (A, B, C, Space, Enter, Backspace).
+	virtual std::string get_key_name(int id) const = 0;
+
+	//: Returns a generic string name for the specified key code. 
+	virtual std::string keyid_to_string(int keycode) const;
+
+	//: Returns the key code for the specified generic string key name.
+	virtual int string_to_keyid(const std::string &amp;str) const;
+
+	//: Returns the the current position of a joystick axis.
+	virtual float get_axis(int index) const = 0;
+
+	//: Returns the human-readable name of the device (i.e. 'Microsoft Sidewinder 3D').
+	virtual std::string get_name() const = 0;
+
+	//: Return the hardware id/device for this device (i.e. '/dev/input/js0')
+	virtual std::string get_device_name() const { return &quot;&quot;; }
+
+	//: Returns the number of axes available on this device.
+	virtual int get_axis_count() const = 0;
+
+	//: Returns the number of buttons available on this device.
+	//- &lt;p&gt;If used on a keyboard, this function returns -1.&lt;/p&gt;
+	virtual int get_button_count() const = 0;
+
+//! Operations:
+public:
+	//: Sets the position of the device.
+	//- &lt;p&gt;Only valid for mouse.&lt;/p&gt;
+	virtual void set_position(int x, int y) {};
+
+	void add_ref();
+
+	void release_ref();
+
+//! Signals:
+public:
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; sig_key_down;
+
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; sig_key_up;
+
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; sig_key_dblclk;
+
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; sig_pointer_move;
+
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; sig_axis_move;
+
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; sig_ball_move;
+
+//! Implementation:
+private:
+	int ref_count;
+};
+
+#endif

Added: trunk/clanlib/Display/input_event.cpp
===================================================================
--- trunk/clanlib/Display/input_event.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/input_event.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,44 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/input_event.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputEvent construction:
+
+CL_InputEvent::CL_InputEvent()
+	: id(-1), type(CL_InputEvent::no_key), 
+	  repeat_count(0)
+{
+}
+
+CL_InputEvent::~CL_InputEvent()
+{
+}

Added: trunk/clanlib/Display/joystick.cpp
===================================================================
--- trunk/clanlib/Display/joystick.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/joystick.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,87 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/joystick.h&quot;
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Display/display_window.h&quot;
+#include &quot;API/Display/input_context.h&quot;
+#include &quot;API/Display/input_device.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Joystick construction:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Joystick attributes:
+
+#define get_ic() CL_Display::get_current_window()-&gt;get_ic()
+
+int CL_Joystick::get_device_count()
+{
+	return get_ic()-&gt;get_joystick_count();
+}
+
+CL_InputDevice &amp;CL_Joystick::get_device(int joystick)
+{
+	return get_ic()-&gt;get_joystick(joystick);
+}
+
+bool CL_Joystick::get_keycode(int keycode, int joystick)
+{
+	return get_ic()-&gt;get_joystick(joystick).get_keycode(keycode);
+}
+
+std::string CL_Joystick::get_key_name(int id)
+{
+	return get_ic()-&gt;get_joystick().get_key_name(id);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Joystick operations:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Joystick signals:
+
+CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;CL_Joystick::sig_key_down(int joystick)
+{
+	return get_ic()-&gt;get_joystick(joystick).sig_key_down();
+}
+
+CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;CL_Joystick::sig_key_up(int joystick)
+{
+	return get_ic()-&gt;get_joystick(joystick).sig_key_up();
+}
+
+CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;CL_Joystick::sig_move(int joystick)
+{
+	return get_ic()-&gt;get_joystick(joystick).sig_move();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Joystick implementation:

Added: trunk/clanlib/Display/key_binding.cpp
===================================================================
--- trunk/clanlib/Display/key_binding.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/key_binding.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,113 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/key_binding.h&quot;
+#include &quot;key_binding_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_KeyBinding construction:
+
+CL_KeyBinding::CL_KeyBinding()
+: impl(new CL_KeyBinding_Generic)
+{
+}
+
+CL_KeyBinding::CL_KeyBinding(int keycode, const CL_InputDevice &amp;device)
+: impl(new CL_KeyBinding_Generic)
+{
+	set_keycode(keycode);
+	set_device(device);
+}
+
+CL_KeyBinding::CL_KeyBinding(const CL_KeyBinding &amp;copy)
+: impl(new CL_KeyBinding_Generic)
+{
+	set_keycode(copy.get_keycode());
+	set_device(copy.get_device());
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_KeyBinding attributes:
+
+bool CL_KeyBinding::operator ==(const CL_KeyBinding &amp;other) const
+{
+	// TODO: Check if inputdevices also match
+	return other.get_keycode() == get_keycode();
+}
+
+bool CL_KeyBinding::operator &lt;(const CL_KeyBinding &amp;other) const
+{
+	// TODO: Check if inputdevices also match
+	return other.get_keycode() &lt; get_keycode();
+}
+
+bool CL_KeyBinding::operator &gt;(const CL_KeyBinding &amp;other) const
+{
+	// TODO: Check if inputdevices also match
+	return other.get_keycode() &gt; get_keycode();
+}
+
+CL_InputDevice &amp;CL_KeyBinding::get_device() const
+{
+	return impl-&gt;device;
+}
+
+int CL_KeyBinding::get_keycode() const
+{
+	return impl-&gt;keycode;
+}
+
+std::string CL_KeyBinding::get_key_name() const
+{
+	return &quot;TODO&quot;;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_KeyBinding operations:
+
+CL_KeyBinding &amp;CL_KeyBinding::operator =(const CL_KeyBinding &amp;copy)
+{
+	set_keycode(copy.get_keycode());
+	set_device(copy.get_device());
+	return *this;
+}
+
+void CL_KeyBinding::set_keycode(int keycode)
+{
+	impl-&gt;keycode = keycode;
+}
+
+void CL_KeyBinding::set_device(const CL_InputDevice &amp;device)
+{
+	impl-&gt;device = device;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_KeyBinding implementation:

Added: trunk/clanlib/Display/key_binding_generic.h
===================================================================
--- trunk/clanlib/Display/key_binding_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/key_binding_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,57 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_keybinding_generic
+#define header_keybinding_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Display/input_device.h&quot;
+
+class CL_KeyBinding_Generic
+{
+//! Construction:
+public:
+	CL_KeyBinding_Generic() { keycode = 0; device = 0; }
+
+//! Attributes:
+public:
+	int keycode;
+	CL_InputDevice device;
+
+//! Operations:
+public:
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/Display/keyboard.cpp
===================================================================
--- trunk/clanlib/Display/keyboard.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/keyboard.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,82 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/keyboard.h&quot;
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Display/display_window.h&quot;
+#include &quot;API/Display/input_context.h&quot;
+#include &quot;API/Display/input_device.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Keyboard construction:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Keyboard attributes:
+
+#define get_ic() CL_Display::get_current_window()-&gt;get_ic()
+
+int CL_Keyboard::get_device_count()
+{
+	return get_ic()-&gt;get_keyboard_count();
+}
+
+CL_InputDevice &amp;CL_Keyboard::get_device(int keyboard)
+{
+	return get_ic()-&gt;get_keyboard(keyboard);
+}
+	
+bool CL_Keyboard::get_keycode(int keycode, int keyboard)
+{
+	return get_ic()-&gt;get_keyboard(keyboard).get_keycode(keycode);
+}
+
+std::string CL_Keyboard::get_key_name(int id)
+{
+	return get_ic()-&gt;get_keyboard().get_key_name(id);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Keyboard operations:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Keyboard signals:
+
+CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;CL_Keyboard::sig_key_down(int keyboard)
+{
+	return get_ic()-&gt;get_keyboard(keyboard).sig_key_down();
+}
+
+CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;CL_Keyboard::sig_key_up(int keyboard)
+{
+	return get_ic()-&gt;get_keyboard(keyboard).sig_key_up();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Input implementation:

Added: trunk/clanlib/Display/mouse.cpp
===================================================================
--- trunk/clanlib/Display/mouse.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/mouse.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,122 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/mouse.h&quot;
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Display/display_window.h&quot;
+#include &quot;API/Display/input_context.h&quot;
+#include &quot;API/Display/input_device.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Mouse construction:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Mouse attributes:
+
+#define get_ic() CL_Display::get_current_window()-&gt;get_ic()
+
+int CL_Mouse::get_device_count()
+{
+	return get_ic()-&gt;get_mouse_count();
+}
+
+CL_InputDevice &amp;CL_Mouse::get_device(int mouse)
+{
+	return get_ic()-&gt;get_mouse(mouse);
+}
+
+int CL_Mouse::get_x(int mouse)
+{
+	return get_ic()-&gt;get_mouse(mouse).get_x();
+}
+	
+int CL_Mouse::get_y(int mouse)
+{
+	return get_ic()-&gt;get_mouse(mouse).get_y();
+}
+	
+bool CL_Mouse::get_keycode(int keycode, int mouse)
+{
+	return get_ic()-&gt;get_mouse(mouse).get_keycode(keycode);
+}
+
+std::string CL_Mouse::get_key_name(int id)
+{
+	return get_ic()-&gt;get_mouse().get_key_name(id);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Mouse operations:
+
+void CL_Mouse::set_position(int x, int y, int mouse)
+{
+	get_ic()-&gt;get_mouse(mouse).set_position(x, y);
+}
+
+void CL_Mouse::show()
+{
+	CL_Display::get_current_window()-&gt;show_cursor();
+}
+
+void CL_Mouse::hide()
+{
+	CL_Display::get_current_window()-&gt;hide_cursor();
+}
+
+void CL_Mouse::set_cursor(const CL_Sprite &amp;sprite)
+{
+	CL_Display::get_current_window()-&gt;set_cursor(sprite);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Mouse signals:
+
+CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;CL_Mouse::sig_key_down(int mouse)
+{
+	return get_ic()-&gt;get_mouse(mouse).sig_key_down();
+}
+
+CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;CL_Mouse::sig_key_up(int mouse)
+{
+	return get_ic()-&gt;get_mouse(mouse).sig_key_up();
+}
+
+CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;CL_Mouse::sig_key_dblclk(int mouse)
+{
+	return get_ic()-&gt;get_mouse(mouse).sig_key_dblclk();
+}
+
+CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;CL_Mouse::sig_move(int mouse)
+{
+	return get_ic()-&gt;get_mouse(mouse).sig_move();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Mouse implementation:

Added: trunk/clanlib/Display/pixel_buffer.cpp
===================================================================
--- trunk/clanlib/Display/pixel_buffer.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/pixel_buffer.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,350 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/pixel_buffer.h&quot;
+#include &quot;API/Core/IOData/datatypes.h&quot;
+#include &quot;pixel_buffer_generic.h&quot;
+#include &quot;pixel_buffer_memory.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_PixelBuffer construction:
+
+CL_PixelBuffer::CL_PixelBuffer(CL_PixelBuffer_Generic *impl)
+: impl(impl)
+{
+	if (impl) impl-&gt;add_ref();
+}
+
+CL_PixelBuffer::CL_PixelBuffer(int width, int height, int pitch, const CL_PixelFormat &amp;format, void *data)
+: impl(new CL_PixelBuffer_Memory(width, height, pitch, format, data))
+{
+	impl-&gt;add_ref();
+}
+
+CL_PixelBuffer::CL_PixelBuffer(int width, int height, int pitch, const CL_PixelFormat &amp;format, const CL_Palette &amp;palette, void *data)
+: impl(new CL_PixelBuffer_Memory(width, height, pitch, format, palette, data))
+{
+	impl-&gt;add_ref();
+}
+
+CL_PixelBuffer::CL_PixelBuffer()
+: impl(0)
+{
+}
+
+CL_PixelBuffer::CL_PixelBuffer(const CL_PixelBuffer &amp;copy)
+: impl(copy.impl)
+{
+	if (impl) impl-&gt;add_ref();
+}
+
+CL_PixelBuffer::~CL_PixelBuffer()
+{
+	if (impl) impl-&gt;release_ref();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_PixelBuffer attributes:
+
+const CL_PixelFormat &amp;CL_PixelBuffer::get_format() const
+{
+	return impl-&gt;format;
+}
+
+const CL_Palette &amp;CL_PixelBuffer::get_palette() const
+{
+	return impl-&gt;palette;
+}
+
+int CL_PixelBuffer::get_width() const
+{
+	return impl-&gt;width;
+}
+
+int CL_PixelBuffer::get_height() const
+{
+	return impl-&gt;height;
+}
+
+unsigned int CL_PixelBuffer::get_pitch() const
+{
+	return impl-&gt;pitch;
+}
+
+void *CL_PixelBuffer::get_data()
+{
+	return impl-&gt;get_data();
+}
+
+CL_Color CL_PixelBuffer::get_pixel(int x, int y)
+{
+	CL_Color color;
+
+	lock();
+	
+	cl_uint8* buf = static_cast&lt;cl_uint8*&gt;(impl-&gt;get_data());
+	CL_PixelFormat format = get_format();
+
+	if (format.get_type() == pixelformat_index)
+	{
+		color = impl-&gt;palette[int(buf[y*impl-&gt;pitch + x])];
+	}
+	else if (format.get_type() == pixelformat_rgba)
+	{
+		int depth = format.get_depth ();
+
+		cl_uint8 *pos = &amp;buf[y * impl-&gt;pitch + x * ((depth + 7)/8)];
+
+		if (8 == depth)
+		{
+			cl_uint8 value = *pos;
+
+			color = CL_Color ((value &amp; format.get_red_mask ()) &gt;&gt; format.get_mask_shift (format.get_red_mask ()),
+							  (value &amp; format.get_green_mask ()) &gt;&gt; format.get_mask_shift (format.get_green_mask ()),
+							  (value &amp; format.get_blue_mask ()) &gt;&gt; format.get_mask_shift (format.get_blue_mask ()),
+							  (value &amp; format.get_alpha_mask ()) &gt;&gt; format.get_mask_shift (format.get_alpha_mask ()));
+		}
+		else if (16 == depth)
+		{
+			cl_uint16 value = *((cl_uint16*)pos);
+
+			color = CL_Color ((value &amp; format.get_red_mask ()) &gt;&gt; format.get_mask_shift (format.get_red_mask ()),
+							  (value &amp; format.get_green_mask ()) &gt;&gt; format.get_mask_shift (format.get_green_mask ()),
+							  (value &amp; format.get_blue_mask ()) &gt;&gt; format.get_mask_shift (format.get_blue_mask ()),
+							  (value &amp; format.get_alpha_mask ()) &gt;&gt; format.get_mask_shift (format.get_alpha_mask ()));
+		}
+		else if (24 == depth)
+		{
+			cl_uint32 value = ((*pos) &lt;&lt; 16) +
+				              ((*(pos + 1)) &lt;&lt; 8) +
+							  *(pos + 2);
+
+			color = CL_Color ((value &amp; format.get_red_mask ()) &gt;&gt; format.get_mask_shift (format.get_red_mask ()),
+							  (value &amp; format.get_green_mask ()) &gt;&gt; format.get_mask_shift (format.get_green_mask ()),
+							  (value &amp; format.get_blue_mask ()) &gt;&gt; format.get_mask_shift (format.get_blue_mask ()),
+							  (value &amp; format.get_alpha_mask ()) &gt;&gt; format.get_mask_shift (format.get_alpha_mask ()));
+		}
+		else if (32 == depth)
+		{
+			cl_uint32 value = *((cl_uint32*)pos);
+
+			color = CL_Color ((value &amp; format.get_red_mask ()) &gt;&gt; format.get_mask_shift (format.get_red_mask ()),
+							  (value &amp; format.get_green_mask ()) &gt;&gt; format.get_mask_shift (format.get_green_mask ()),
+							  (value &amp; format.get_blue_mask ()) &gt;&gt; format.get_mask_shift (format.get_blue_mask ()),
+							  (value &amp; format.get_alpha_mask ()) &gt;&gt; format.get_mask_shift (format.get_alpha_mask ()));
+		}
+	}
+	unlock();
+
+	return color;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_PixelBuffer operations:
+
+CL_PixelBuffer &amp;CL_PixelBuffer::operator =(const CL_PixelBuffer &amp;copy)
+{
+	if (impl) impl-&gt;release_ref();
+	impl = copy.impl;
+	if (impl) impl-&gt;add_ref();
+	return *this;
+}
+
+CL_PixelBuffer::operator bool() const
+{
+  return (impl != 0);
+}
+
+void CL_PixelBuffer::lock()
+{
+	impl-&gt;lock_count++;
+	if (impl-&gt;lock_count == 1) impl-&gt;perform_lock();
+}
+
+void CL_PixelBuffer::unlock()
+{
+	impl-&gt;lock_count--;
+	if (impl-&gt;lock_count == 0) impl-&gt;perform_unlock();
+}
+
+void CL_PixelBuffer::convert(CL_PixelBuffer target)
+{
+	target.lock();
+
+	convert(
+		target.get_data(),
+		target.get_format(),
+		target.get_pitch(),
+		CL_Rect(
+			0, 0,
+			target.get_width(), target.get_height()));
+
+	target.unlock();
+}
+
+void CL_PixelBuffer::convert(
+	void *buffer,
+	const CL_PixelFormat &amp;format,
+	int dest_pitch,
+	const CL_Rect &amp;dest_rect,
+	const CL_Rect &amp;src_rect)
+{
+	lock();
+
+	bool null_src = false;
+	if (src_rect.left == 0 &amp;&amp; src_rect.top == 0 &amp;&amp; src_rect.right == 0 &amp;&amp; src_rect.bottom == 0)
+	{
+		null_src = true;
+	}
+
+	if (format.get_type() == pixelformat_index)
+	{
+		throw CL_Error(&quot;Converting to indexed pixelformats not supported.&quot;);
+	}
+
+	if (null_src == false &amp;&amp; dest_rect.get_size() != src_rect.get_size())
+	{
+		throw CL_Error(&quot;Source and destination rects must have same size. Scaled converting not supported.&quot;);
+	}
+
+	char *src_data = (char *) get_data();
+	char *dest_data = (char *) buffer;
+	if (null_src == false) src_data += src_rect.top*get_pitch() + src_rect.left*((get_format().get_depth()+7)/8);
+	dest_data += dest_rect.top*dest_pitch + dest_rect.left*((format.get_depth()+7)/8);
+
+	if (get_format().get_type() == pixelformat_index)
+	{
+		CL_PixelBuffer_Generic::convert_pal(
+			src_data,
+			get_format(),
+			get_pitch(),
+			get_palette(),
+			dest_data,
+			format,
+			dest_pitch,
+			dest_rect.get_size());
+	}
+	else
+	{
+		CL_PixelBuffer_Generic::convert(
+			src_data,
+			get_format(),
+			get_pitch(),
+			dest_data,
+			format,
+			dest_pitch,
+			dest_rect.get_size());
+	}
+
+	unlock();
+}
+
+void CL_PixelBuffer::convert_line(void *buffer, const CL_PixelFormat &amp;format, int y)
+{
+	convert(
+		buffer,
+		format,
+		(format.get_depth()+7)/8*get_width(),
+		CL_Rect(0, 0, get_width(), 1),
+		CL_Rect(0, y, get_width(), 1));
+}
+
+CL_PixelBuffer CL_PixelBuffer::to_format(const CL_PixelFormat &amp;format)
+{
+	lock();
+	CL_PixelBuffer result(get_width(), get_height(), get_width()*((format.get_depth()+7)/8), format);
+	convert(result);
+	unlock();
+	return result;
+}
+
+void CL_PixelBuffer::set_colorkey(bool enabled, unsigned int colorkey)
+{
+	impl-&gt;format.enable_colorkey(enabled);
+	impl-&gt;format.set_colorkey(colorkey);
+}
+
+void CL_PixelBuffer::draw_pixel(int x, int y, const CL_Color &amp;color)
+{
+	lock();
+
+	cl_uint8* buf = static_cast&lt;cl_uint8*&gt;(impl-&gt;get_data());
+	CL_PixelFormat format = get_format();
+
+	if (format.get_type() == pixelformat_index)
+	{
+		throw CL_Error(&quot;Direct settings of CL_Colors pixels in paletted mode is not supported.&quot;);
+	}
+	else if (format.get_type() == pixelformat_rgba)
+	{
+		int depth = format.get_depth ();
+		int bytes_per_pixel = (depth + 7)/8;
+		cl_uint8 *pos = &amp;buf[y * impl-&gt;pitch + x * bytes_per_pixel];
+
+		int red_shift = format.get_mask_shift(format.get_red_mask()),
+			green_shift = format.get_mask_shift(format.get_green_mask()),
+			blue_shift = format.get_mask_shift(format.get_blue_mask()),
+			alpha_shift = format.get_mask_shift(format.get_alpha_mask());
+
+		switch (bytes_per_pixel)
+		{
+		case 4:
+		case 3:
+			{
+				cl_uint32 c = (color.get_red() &lt;&lt; red_shift) | (color.get_green() &lt;&lt; green_shift) | (color.get_blue() &lt;&lt; blue_shift) | (color.get_alpha() &lt;&lt; alpha_shift);
+				memcpy (pos, &amp;c, bytes_per_pixel);
+			}
+			break;
+
+		case 2:
+			{
+				cl_uint16 c = (color.get_red() &lt;&lt; red_shift) | (color.get_green() &lt;&lt; green_shift) | (color.get_blue() &lt;&lt; blue_shift) | (color.get_alpha() &lt;&lt; alpha_shift);
+				memcpy (pos, &amp;c, bytes_per_pixel);
+			}
+			break;
+
+		case 1:
+			{
+				cl_uint8 c = (color.get_red() &lt;&lt; red_shift) | (color.get_green() &lt;&lt; green_shift) | (color.get_blue() &lt;&lt; blue_shift) | (color.get_alpha() &lt;&lt; alpha_shift);
+				*pos = c;
+			}
+			break;
+
+		default:
+			throw CL_Error(&quot;Unsuported pixel format depth for draw_pixel.&quot;);
+		}
+
+	}
+	unlock();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_PixelBuffer implementation:

Added: trunk/clanlib/Display/pixel_buffer_generic.cpp
===================================================================
--- trunk/clanlib/Display/pixel_buffer_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/pixel_buffer_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,292 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/pixel_buffer.h&quot;
+#include &quot;API/Core/IOData/cl_endian.h&quot;
+#include &quot;pixel_buffer_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_PixelBuffer_Generic construction:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_PixelBuffer_Generic operations:
+
+void CL_PixelBuffer_Generic::convert(void* in_buffer, const CL_PixelFormat&amp; in_pf, int in_pitch, void* out_buffer, const CL_PixelFormat&amp; out_pf, int out_pitch, const CL_Size&amp; size)
+{
+	cl_assert(in_pf.get_type() == pixelformat_rgba);
+	cl_assert(out_pf.get_type() == pixelformat_rgba);
+	
+	const int in_bpp = in_pf.get_depth()/8;
+	const int out_bpp = out_pf.get_depth()/8;
+
+	cl_assert(in_bpp &lt;= 4 &amp;&amp; in_bpp &gt;= 1);
+	cl_assert(out_bpp &lt;= 4 &amp;&amp; out_bpp &gt;=1);
+	
+	char* in_p = static_cast&lt;char*&gt;(in_buffer);
+	char* out_p = static_cast&lt;char*&gt;(out_buffer);
+
+	if (in_pf == out_pf)
+	{
+		const int in_line_bytes = in_bpp*size.width;
+		for (int y = 0; y &lt; size.height; y++, in_p += in_pitch, out_p += out_pitch)
+			memcpy(out_p, in_p, in_line_bytes);
+	}
+	else
+	{
+		const int in_r_shift = CL_PixelFormat::get_mask_shift(in_pf.get_red_mask());
+		const int in_g_shift = CL_PixelFormat::get_mask_shift(in_pf.get_green_mask());
+		const int in_b_shift = CL_PixelFormat::get_mask_shift(in_pf.get_blue_mask());
+		const int in_a_shift = CL_PixelFormat::get_mask_shift(in_pf.get_alpha_mask());
+
+		const int in_r_bits = CL_PixelFormat::get_mask_bits(in_pf.get_red_mask());
+		const int in_g_bits = CL_PixelFormat::get_mask_bits(in_pf.get_green_mask());
+		const int in_b_bits = CL_PixelFormat::get_mask_bits(in_pf.get_blue_mask());
+		const int in_a_bits = CL_PixelFormat::get_mask_bits(in_pf.get_alpha_mask());
+
+		const int in_r_bitmask = CL_PixelFormat::get_bitmask(in_r_bits, 0);
+		const int in_g_bitmask = CL_PixelFormat::get_bitmask(in_g_bits, 0);
+		const int in_b_bitmask = CL_PixelFormat::get_bitmask(in_b_bits, 0);
+		const int in_a_bitmask = CL_PixelFormat::get_bitmask(in_a_bits, 0);
+
+		const int out_r_shift = CL_PixelFormat::get_mask_shift(out_pf.get_red_mask());
+		const int out_g_shift = CL_PixelFormat::get_mask_shift(out_pf.get_green_mask());
+		const int out_b_shift = CL_PixelFormat::get_mask_shift(out_pf.get_blue_mask());
+		const int out_a_shift = CL_PixelFormat::get_mask_shift(out_pf.get_alpha_mask());
+
+		const int out_r_bits = CL_PixelFormat::get_mask_bits(out_pf.get_red_mask());
+		const int out_g_bits = CL_PixelFormat::get_mask_bits(out_pf.get_green_mask());
+		const int out_b_bits = CL_PixelFormat::get_mask_bits(out_pf.get_blue_mask());
+		const int out_a_bits = CL_PixelFormat::get_mask_bits(out_pf.get_alpha_mask());
+
+		const bool in_has_ck = in_pf.has_colorkey();
+		unsigned int in_ck = 0;
+		if (in_has_ck)
+			in_ck = in_pf.get_colorkey();
+		const bool out_has_ck = out_pf.has_colorkey();
+		unsigned int out_ck = 0;
+		if (out_has_ck)
+			out_ck = out_pf.get_colorkey();
+		
+		for (int y = 0; y &lt; size.height; y++, in_p += in_pitch, out_p += out_pitch)
+		{
+			char* in_p2 = in_p;
+			char* out_p2 = out_p;
+			for (int x = 0; x &lt; size.width; x++, in_p2 += in_bpp, out_p2 += out_bpp)
+			{
+				unsigned int in_pixel = 0;
+				memcpy(&amp;in_pixel, in_p2, in_bpp);
+				
+				if (CL_Endian::is_system_big())
+				{
+					for (int bpp=4; bpp &amp;&amp; in_bpp &lt; bpp; bpp--)
+						in_pixel &gt;&gt;= 8;
+				}
+
+				// decode
+				unsigned int in_r = 0, in_g = 0, in_b = 0, in_a = 0xffffffff;
+				if (in_r_bitmask)
+				{
+					in_r = ((in_pixel &gt;&gt; in_r_shift) &amp; in_r_bitmask);
+					if (in_r &amp; 1)
+						in_r = (in_r &lt;&lt; (32 - in_r_bits)) | CL_PixelFormat::get_bitmask(32 - in_r_bits, 0);
+					else
+						in_r &lt;&lt;= 32 - in_r_bits;
+				}
+				if (in_g_bitmask)
+				{
+					in_g = ((in_pixel &gt;&gt; in_g_shift) &amp; in_g_bitmask);
+					if (in_g &amp; 1)
+						in_g = (in_g &lt;&lt; (32 - in_g_bits)) | CL_PixelFormat::get_bitmask(32 - in_g_bits, 0);
+					else
+						in_g &lt;&lt;= 32 - in_g_bits;
+				}
+				if (in_b_bitmask)
+				{
+					in_b = ((in_pixel &gt;&gt; in_b_shift) &amp; in_b_bitmask);
+					if (in_b &amp; 1)
+						in_b = (in_b &lt;&lt; (32 - in_b_bits)) | CL_PixelFormat::get_bitmask(32 - in_b_bits, 0);
+					else
+						in_b &lt;&lt;= 32 - in_b_bits;
+				}
+				if (in_a_bitmask)
+				{
+					in_a = ((in_pixel &gt;&gt; in_a_shift) &amp; in_a_bitmask);
+					if (in_a &amp; 1)
+						in_a = (in_a &lt;&lt; (32 - in_a_bits)) | CL_PixelFormat::get_bitmask(32 - in_a_bits, 0);
+					else
+						in_a &lt;&lt;= 32 - in_a_bits;
+				}
+
+				unsigned int out_pixel;
+				bool encode;
+				if (!out_a_bits &amp;&amp; (in_a == 0) &amp;&amp; out_has_ck)
+				{
+					out_pixel = out_ck;
+					encode = false;
+				}
+				else if (in_has_ck &amp;&amp; (in_pixel == in_ck))
+				{
+					if (out_has_ck)
+					{
+						out_pixel = out_ck;
+						encode = false;
+					}
+					else
+					{
+						in_a = 0;
+						encode = true;
+					}
+				}	
+				else
+					encode = true;
+
+				// encode
+				if (encode)
+				{
+					out_pixel = 0;
+					if (out_r_bits)
+						out_pixel |= (in_r &gt;&gt; (32 - out_r_bits)) &lt;&lt; out_r_shift;
+					if (out_g_bits)
+						out_pixel |= (in_g &gt;&gt; (32 - out_g_bits)) &lt;&lt; out_g_shift;
+					if (out_b_bits)
+						out_pixel |= (in_b &gt;&gt; (32 - out_b_bits)) &lt;&lt; out_b_shift;
+					if (out_a_bits)
+						out_pixel |= (in_a &gt;&gt; (32 - out_a_bits)) &lt;&lt; out_a_shift;
+				}
+
+				memcpy(out_p2, &amp;out_pixel, out_bpp);
+			}
+		}
+	}
+}
+
+void CL_PixelBuffer_Generic::convert_pal(void* in_buffer, const CL_PixelFormat&amp; in_pf, int in_pitch, const CL_Palette&amp; in_pal, void* out_buffer, const CL_PixelFormat&amp; out_pf, int out_pitch, const CL_Size&amp; size)
+{
+	cl_assert(in_pf.get_type() == pixelformat_index);
+	cl_assert(out_pf.get_type() == pixelformat_rgba);
+
+	const int in_bpp = in_pf.get_depth()/8;
+	const int out_bpp = out_pf.get_depth()/8;
+	char* in_p = static_cast&lt;char*&gt;(in_buffer);
+	char* out_p = static_cast&lt;char*&gt;(out_buffer);
+
+	const int out_r_shift = CL_PixelFormat::get_mask_shift(out_pf.get_red_mask());
+	const int out_g_shift = CL_PixelFormat::get_mask_shift(out_pf.get_green_mask());
+	const int out_b_shift = CL_PixelFormat::get_mask_shift(out_pf.get_blue_mask());
+	const int out_a_shift = CL_PixelFormat::get_mask_shift(out_pf.get_alpha_mask());
+
+	const int out_r_bits = CL_PixelFormat::get_mask_bits(out_pf.get_red_mask());
+	const int out_g_bits = CL_PixelFormat::get_mask_bits(out_pf.get_green_mask());
+	const int out_b_bits = CL_PixelFormat::get_mask_bits(out_pf.get_blue_mask());
+	const int out_a_bits = CL_PixelFormat::get_mask_bits(out_pf.get_alpha_mask());
+
+	const bool in_has_ck = in_pf.has_colorkey();
+	unsigned int in_ck = 0;
+	if (in_has_ck)
+		in_ck = in_pf.get_colorkey();
+	const bool out_has_ck = out_pf.has_colorkey();
+	unsigned int out_ck = 0;
+	if (out_has_ck)
+		out_ck = out_pf.get_colorkey();
+	
+	for (int y = 0; y &lt; size.height; y++, in_p += in_pitch, out_p += out_pitch)
+	{
+		char* in_p2 = in_p;
+		char* out_p2 = out_p;
+		for (int x = 0; x &lt; size.width; x++, in_p2 += in_bpp, out_p2 += out_bpp)
+		{
+			unsigned int in_pixel = 0;
+			memcpy(&amp;in_pixel, in_p2, in_bpp);
+			SWAP_IF_BIG(in_pixel);
+
+			// decode
+			unsigned int in_r = 0, in_g = 0, in_b = 0, in_a = 0xffffffff;
+			in_r = in_pal.colors[in_pixel].get_red();
+			if (in_r &amp; 1)
+				in_r = (in_r &lt;&lt; (32 - 8)) | CL_PixelFormat::get_bitmask(32 - 8, 0);
+			else
+				in_r &lt;&lt;= 32 - 8;
+			in_g = in_pal.colors[in_pixel].get_green();
+			if (in_g &amp; 1)
+				in_g = (in_g &lt;&lt; (32 - 8)) | CL_PixelFormat::get_bitmask(32 - 8, 0);
+			else
+				in_g &lt;&lt;= 32 - 8;
+			in_b = in_pal.colors[in_pixel].get_blue();
+			if (in_b &amp; 1)
+				in_b = (in_b &lt;&lt; (32 - 8)) | CL_PixelFormat::get_bitmask(32 - 8, 0);
+			else
+				in_b &lt;&lt;= 32 - 8;
+			in_a = in_pal.colors[in_pixel].get_alpha();
+			if (in_a &amp; 1)
+				in_a = (in_a &lt;&lt; (32 - 8)) | CL_PixelFormat::get_bitmask(32 - 8, 0);
+			else
+				in_a &lt;&lt;= 32 - 8;
+
+			unsigned int out_pixel;
+			bool encode;
+			if (!out_a_bits &amp;&amp; (in_a == 0) &amp;&amp; out_has_ck)
+			{
+				out_pixel = out_ck;
+				encode = false;
+			}
+			else if (in_has_ck &amp;&amp; (in_pixel == in_ck))
+			{
+				if (out_has_ck)
+				{
+					out_pixel = out_ck;
+					encode = false;
+				}
+				else
+				{
+					in_a = 0;
+					encode = true;
+				}
+			}	
+			else
+				encode = true;
+
+			// encode
+			if (encode)
+			{
+				out_pixel = 0;
+				if (out_r_bits)
+					out_pixel |= (in_r &gt;&gt; (32 - out_r_bits)) &lt;&lt; out_r_shift;
+				if (out_g_bits)
+					out_pixel |= (in_g &gt;&gt; (32 - out_g_bits)) &lt;&lt; out_g_shift;
+				if (out_b_bits)
+					out_pixel |= (in_b &gt;&gt; (32 - out_b_bits)) &lt;&lt; out_b_shift;
+				if (out_a_bits)
+					out_pixel |= (in_a &gt;&gt; (32 - out_a_bits)) &lt;&lt; out_a_shift;
+			}
+
+			memcpy(out_p2, &amp;out_pixel, out_bpp);
+		}
+	}
+}

Added: trunk/clanlib/Display/pixel_buffer_generic.h
===================================================================
--- trunk/clanlib/Display/pixel_buffer_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/pixel_buffer_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,116 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_pixel_buffer_generic
+#define header_pixel_buffer_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Display/pixel_format.h&quot;
+#include &quot;API/Display/palette.h&quot;
+
+//: Pixel data implementation interface.
+class CL_PixelBuffer_Generic
+{
+//! Construction:
+public:
+	CL_PixelBuffer_Generic() : lock_count(0), ref_count(0) { return; }
+
+	virtual ~CL_PixelBuffer_Generic() { return; }
+
+//! Attributes:
+public:
+	//: Buffer pixel format description.
+	CL_PixelFormat format;
+
+	//: Palette, if 8 bpp pixel format.
+	CL_Palette palette;
+
+	//: Buffer scanline pitch.
+	unsigned int pitch;
+
+	//: Buffer width.
+	int width;
+
+	//: Buffer height.
+	int height;
+
+	//: Lock reference count.
+	int lock_count;
+
+//! Operations:
+public:
+	//: Returns a pointer to the beginning of the pixel buffer. Pointer
+	//: is only valid inside a lock/unlock session.
+	virtual void *get_data()=0;
+
+	//: Reference counted lock function. Allocate pixel buffer in this function. 
+	virtual void perform_lock()=0;
+
+	//: Reference counted unlock function. Free pixel buffer in this function.
+	virtual void perform_unlock()=0;
+
+	int add_ref() { return ++ref_count; }
+
+	int release_ref()
+	{
+		ref_count--;
+		if (ref_count == 0) { delete this; return 0; }
+		return ref_count;
+	}
+	
+	//: Converts between two RGBA formats.
+	static void convert(
+		void* in_buffer,
+		const CL_PixelFormat&amp; in_pf,
+		int in_pitch,
+		void* out_buffer,
+		const CL_PixelFormat&amp; out_pf,
+		int out_pitch,
+		const CL_Size&amp; size);
+
+	//: Converts from palette format to RGBA.
+	static void convert_pal(
+		void* in_buffer,
+		const CL_PixelFormat&amp; in_pf,
+		int in_pitch,
+		const CL_Palette&amp; in_pal,
+		void* out_buffer,
+		const CL_PixelFormat&amp; out_pf,
+		int out_pitch,
+		const CL_Size&amp; size);
+
+//! Implementation:
+private:
+	int ref_count;
+};
+
+#endif

Added: trunk/clanlib/Display/pixel_buffer_memory.cpp
===================================================================
--- trunk/clanlib/Display/pixel_buffer_memory.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/pixel_buffer_memory.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,100 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;pixel_buffer_memory.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_PixelBuffer_Memory construction:
+
+CL_PixelBuffer_Memory::CL_PixelBuffer_Memory(
+	int width, int height, int pitch, const CL_PixelFormat &amp;format, void *data_ptr)
+{
+	CL_PixelBuffer_Generic::width = width;
+	CL_PixelBuffer_Generic::height = height;
+	CL_PixelBuffer_Generic::pitch = pitch;
+	CL_PixelBuffer_Generic::format = format;
+
+	if (data_ptr)
+	{
+		delete_data = false;
+		data = (unsigned char *) data_ptr;
+	}
+	else
+	{
+		delete_data = true;
+		data = new unsigned char[pitch*height];
+	}
+}
+
+CL_PixelBuffer_Memory::CL_PixelBuffer_Memory(
+	int width, int height, int pitch, const CL_PixelFormat &amp;format, const CL_Palette &amp;palette, void *data_ptr)
+{
+	CL_PixelBuffer_Generic::width = width;
+	CL_PixelBuffer_Generic::height = height;
+	CL_PixelBuffer_Generic::pitch = pitch;
+	CL_PixelBuffer_Generic::format = format;
+	CL_PixelBuffer_Generic::palette = palette;
+
+	if (data_ptr)
+	{
+		delete_data = false;
+		data = (unsigned char *) data_ptr;
+	}
+	else
+	{
+		delete_data = true;
+		data = new unsigned char[pitch*height];
+	}
+}
+
+CL_PixelBuffer_Memory::~CL_PixelBuffer_Memory()
+{
+	if (delete_data) delete[] data;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_PixelBuffer_Memory operations:
+
+void *CL_PixelBuffer_Memory::get_data()
+{
+	return data;
+}
+
+void CL_PixelBuffer_Memory::perform_lock()
+{
+}
+
+void CL_PixelBuffer_Memory::perform_unlock()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_PixelBuffer_Memory implementation:
+

Added: trunk/clanlib/Display/pixel_buffer_memory.h
===================================================================
--- trunk/clanlib/Display/pixel_buffer_memory.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/pixel_buffer_memory.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,70 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_pixel_buffer_memory
+#define header_pixel_buffer_memory
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Display/pixel_buffer.h&quot;
+#include &quot;pixel_buffer_generic.h&quot;
+
+//: Memory pixel data implementation.
+class CL_PixelBuffer_Memory : public CL_PixelBuffer_Generic
+{
+//! Construction:
+public:
+	CL_PixelBuffer_Memory(int width, int height, int pitch, const CL_PixelFormat &amp;format, void *data = 0);
+
+	CL_PixelBuffer_Memory(int width, int height, int pitch, const CL_PixelFormat &amp;format, const CL_Palette &amp;palette, void *data = 0);
+
+	virtual ~CL_PixelBuffer_Memory();
+
+//! Operations:
+public:
+	//: Returns a pointer to the beginning of the pixel buffer. Pointer
+	//: is only valid inside a lock/unlock session.
+	virtual void *get_data();
+
+	//: Reference counted lock function. Allocate pixel buffer in this function. 
+	virtual void perform_lock();
+
+	//: Reference counted unlock function. Free pixel buffer in this function.
+	virtual void perform_unlock();
+
+//! Implementation:
+private:
+	unsigned char *data;
+
+	bool delete_data;
+};
+
+#endif

Added: trunk/clanlib/Display/pixel_format.cpp
===================================================================
--- trunk/clanlib/Display/pixel_format.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/pixel_format.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,171 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/pixel_format.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_PixelFormat construction:
+
+CL_PixelFormat::CL_PixelFormat()
+: type(pixelformat_rgba), colorkey_enabled(false), colorkey(0), red_mask(0), green_mask(0), blue_mask(0), alpha_mask(0), depth(0)
+{
+}
+
+CL_PixelFormat::CL_PixelFormat(const CL_PixelFormat &amp;copy)
+{
+	colorkey_enabled = copy.colorkey_enabled;
+	colorkey = copy.colorkey;
+	red_mask = copy.red_mask;
+	green_mask = copy.green_mask;
+	blue_mask = copy.blue_mask;
+	alpha_mask = copy.alpha_mask;
+	depth = copy.depth;
+	type = copy.type;
+}
+
+CL_PixelFormat::CL_PixelFormat(
+	int depth,
+	unsigned int red_mask,
+	unsigned int green_mask,
+	unsigned int blue_mask,
+	unsigned int alpha_mask,
+	bool use_colorkey,
+	unsigned int colorkey,
+	CL_PixelFormatType type)
+: type(type), colorkey_enabled(use_colorkey), colorkey(colorkey), red_mask(red_mask), green_mask(green_mask), blue_mask(blue_mask), alpha_mask(alpha_mask), depth(depth)
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_PixelFormat attributes:
+
+bool CL_PixelFormat::operator ==(const CL_PixelFormat &amp;other) const
+{
+	if (type != other.type) return false;
+	if (type == pixelformat_index)
+	{
+		if (
+			depth != other.depth ||
+			colorkey_enabled != other.colorkey_enabled
+			)
+			return false;
+		if (colorkey_enabled &amp;&amp; colorkey != other.colorkey)
+			return false;
+		return true;
+	}
+	else if (type == pixelformat_rgba)
+	{
+		if (
+			depth != other.depth ||
+			red_mask != other.red_mask ||
+			green_mask != other.green_mask ||
+			blue_mask != other.blue_mask ||
+			alpha_mask != other.alpha_mask ||
+			colorkey_enabled != other.colorkey_enabled
+			)
+			return false;
+		if (colorkey_enabled &amp;&amp; colorkey != other.colorkey)
+			return false;
+		return true;
+	}
+	else
+		return false;
+}
+
+bool CL_PixelFormat::operator !=(const CL_PixelFormat &amp;other) const
+{
+	return !( *this == other );
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_PixelFormat statics:
+
+int CL_PixelFormat::get_mask_shift(unsigned int mask)
+{
+	if (mask == 0)
+		return 0;
+
+	for (int shift = 0; shift &lt; 32; shift++)
+	{
+		if (mask &amp; 1)
+			return shift;
+		else
+			mask &gt;&gt;= 1;
+	}
+	return 0;
+}
+
+int CL_PixelFormat::get_mask_bits(unsigned int mask)
+{
+	if (mask == 0)
+		return 0;
+
+	const int shift = get_mask_shift(mask);
+	mask &gt;&gt;= shift;
+
+	int bits;
+	for (bits = 0; bits &lt; (32 - shift); bits++)
+	{
+		if (!(mask &amp; 1))
+			return bits;
+		else
+			mask &gt;&gt;= 1;
+	}
+	return bits;
+}
+
+unsigned int CL_PixelFormat::get_bitmask(int bits, int shift)
+{
+	unsigned int mask = 0;
+	for (int i = 0; i &lt; bits; i++)
+		mask |= 1 &lt;&lt; i;
+	return mask &lt;&lt; shift;
+}
+
+CL_PixelFormat CL_PixelFormat::rgba8888(32, 0xff000000, 0x00ff0000, 0x0000ff00, 0x000000ff);
+
+CL_PixelFormat CL_PixelFormat::rgb888(24, 0xff0000, 0x00ff00, 0x0000ff, 0x000000);
+
+CL_PixelFormat CL_PixelFormat::rgba4444(16, 0xf000, 0x0f00, 0x00f0, 0x000f);
+
+CL_PixelFormat CL_PixelFormat::rgb555(16, 0x7c00, 0x03e0, 0x001f, 0x0000);
+
+CL_PixelFormat CL_PixelFormat::rgb565(16, 0xf800, 0x07e0, 0x001f, 0x0000);
+
+CL_PixelFormat CL_PixelFormat::abgr8888(32, 0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000);
+
+CL_PixelFormat CL_PixelFormat::bgr888(24, 0x0000ff, 0x00ff00, 0xff0000, 0x000000);
+
+CL_PixelFormat CL_PixelFormat::abgr4444(16, 0x000f, 0x00f0, 0x0f00, 0xf000);
+
+CL_PixelFormat CL_PixelFormat::bgr555(16, 0x001f, 0x03e0, 0x7c00, 0x0000);
+
+CL_PixelFormat CL_PixelFormat::bgr565(16, 0x001f, 0x07e0, 0xf800, 0x0000);

Added: trunk/clanlib/Display/resourcedata_collisionoutline.cpp
===================================================================
--- trunk/clanlib/Display/resourcedata_collisionoutline.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/resourcedata_collisionoutline.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,108 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;API/Display/Providers/provider_factory.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/Display/pixel_buffer.h&quot;
+#include &quot;API/Display/pixel_format.h&quot;
+#include &quot;Display/Collision/collision_outline_generic.h&quot;
+#include &quot;API/Display/Collision/outline_provider_file.h&quot;
+#include &quot;Display/resourcedata_collisionoutline.h&quot;
+#include &quot;API/Display/Collision/outline_provider_bitmap.h&quot;
+
+//////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData_CollisionOutline construction:
+
+CL_ResourceData_CollisionOutline::CL_ResourceData_CollisionOutline(CL_Resource &amp;resource)
+: CL_ResourceData(resource)
+{
+	resource.attach_data(&quot;collisionoutline&quot;, this);
+}
+
+CL_ResourceData_CollisionOutline::~CL_ResourceData_CollisionOutline()
+{
+}
+	
+//////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData_Outline attributes:
+
+
+//////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData_Outline implementation:
+
+void CL_ResourceData_CollisionOutline::on_load()
+{
+	CL_Resource resource = get_resource();
+	std::string filename = resource.get_element().get_attribute(&quot;file&quot;);
+	int alpha_limit = atoi( (resource.get_element().get_attribute(&quot;alpha_value&quot;,&quot;128&quot;)).c_str());
+	std::string accuracy_str = resource.get_element().get_attribute(&quot;accuracy&quot;,&quot;medium&quot;);
+	CL_OutlineAccuracy accuracy;
+
+	if(accuracy_str == &quot;high&quot;)
+		accuracy = accuracy_high;
+	else if(accuracy_str == &quot;medium&quot;)
+		accuracy = accuracy_medium;
+	else if(accuracy_str == &quot;low&quot;)
+		accuracy = accuracy_low;
+	else if(accuracy_str == &quot;poor&quot;)
+		accuracy = accuracy_poor;
+    else
+		accuracy = accuracy_raw;
+
+	CL_CollisionOutline_Generic *outline;
+
+	if( CL_String::right(filename, 3) == &quot;out&quot; )
+	{
+		outline = new CL_CollisionOutline_Generic(
+			new CL_OutlineProviderFile(filename,resource.get_manager().get_resource_provider()), accuracy_raw);
+	}
+	else
+	{
+		CL_PixelBuffer pbuf = CL_ProviderFactory::load(filename,&quot;&quot;,resource.get_manager().get_resource_provider());
+		outline = new CL_CollisionOutline_Generic(
+			new CL_OutlineProviderBitmap(pbuf, alpha_limit), accuracy );
+	}
+
+	CL_CollisionOutline *collision_outline_tmp = 
+		new CL_CollisionOutline(outline-&gt;contours,outline-&gt;width,outline-&gt;height);
+	collision_outline = *collision_outline_tmp;
+
+	delete collision_outline_tmp;
+
+	collision_outline.calculate_radius();
+	
+	delete outline;
+}
+	
+void CL_ResourceData_CollisionOutline::on_unload()
+{
+	collision_outline = CL_CollisionOutline();
+}

Added: trunk/clanlib/Display/resourcedata_collisionoutline.h
===================================================================
--- trunk/clanlib/Display/resourcedata_collisionoutline.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/resourcedata_collisionoutline.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,62 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_resourcedata_collisionoutline
+#define header_resourcedata_collisionoutline
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/Resources/resourcedata.h&quot;
+#include &quot;API/Core/Resources/resource.h&quot;
+#include &quot;API/Display/Collision/collision_outline.h&quot;
+
+class CL_ResourceData_CollisionOutline : public CL_ResourceData
+{
+//! Construction:
+public:
+	CL_ResourceData_CollisionOutline(CL_Resource &amp;resource);
+	
+	virtual ~CL_ResourceData_CollisionOutline();
+	
+//! Attributes:
+public:
+	CL_CollisionOutline &amp;get_CollisionOutline() { return collision_outline; }
+
+//! Implementation:
+private:
+	void on_load();
+	
+	void on_unload();
+
+	CL_CollisionOutline collision_outline;
+};
+
+#endif

Added: trunk/clanlib/Display/resourcedata_font.cpp
===================================================================
--- trunk/clanlib/Display/resourcedata_font.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/resourcedata_font.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,159 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;resourcedata_font.h&quot;
+#include &quot;API/Display/sprite.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+
+//////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData_Font construction:
+
+CL_ResourceData_Font::CL_ResourceData_Font(CL_Resource &amp;resource)
+: CL_ResourceData(resource)
+{
+	resource.attach_data(&quot;font&quot;, this);
+}
+	
+CL_ResourceData_Font::~CL_ResourceData_Font()
+{
+}
+	
+//////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData_Font implementation:
+
+void CL_ResourceData_Font::on_load()
+{
+	CL_Resource resource = get_resource();
+	CL_ResourceManager manager = resource.get_manager();
+	
+	CL_DomElement system_element = resource.get_element().named_item(&quot;system&quot;).to_element();
+	CL_DomElement bitmap_element = resource.get_element().named_item(&quot;bitmap&quot;).to_element();
+	
+	// First check if it's a system font
+	if (!system_element.is_null())
+	{
+		if (!system_element.has_attribute(&quot;height&quot;))
+			throw CL_Error(&quot;System font resource &quot; + resource.get_name() + &quot; has no 'height' attribute.&quot;);
+		
+		const std::string font_name = system_element.get_attribute(&quot;font_name&quot;);
+		const int height = CL_String::to_int(system_element.get_attribute(&quot;height&quot;));
+		int width = 0;
+
+		bool bold = false;
+		bool italic = false;
+		bool underline = false;
+		bool strikeout = false;
+		
+		if (system_element.has_attribute(&quot;width&quot;))
+			width = CL_String::to_int(system_element.get_attribute(&quot;width&quot;));
+		
+		if (system_element.has_attribute(&quot;bold&quot;))
+			bold = (CL_String::to_int(system_element.get_attribute(&quot;bold&quot;)) != 0);
+		
+		if (system_element.has_attribute(&quot;italic&quot;))
+			italic = (CL_String::to_int(system_element.get_attribute(&quot;italic&quot;)) != 0);
+		
+		if (system_element.has_attribute(&quot;underline&quot;))
+			underline = (CL_String::to_int(system_element.get_attribute(&quot;underline&quot;)) != 0);
+		
+		if (system_element.has_attribute(&quot;strikeout&quot;))
+			strikeout = (CL_String::to_int(system_element.get_attribute(&quot;strikeout&quot;)) != 0);
+		
+		if (system_element.has_attribute(&quot;letters&quot;))
+		{
+			font = CL_Font(
+				font_name,
+				system_element.get_attribute(&quot;letters&quot;),
+				height,
+				width,
+				bold,
+				italic,
+				underline,
+				strikeout);
+		}
+		else
+		{
+			font = CL_Font(
+				font_name,
+				height,
+				width,
+				bold,
+				italic,
+				underline,
+				strikeout);
+		}
+	} 
+	else if (!bitmap_element.is_null())
+	{
+		if (!bitmap_element.has_attribute(&quot;glyphs&quot;)) 
+			throw CL_Error(&quot;Font resource &quot; + resource.get_name() + &quot; has no 'glyphs' attribute.&quot;);
+		
+		if (!bitmap_element.has_attribute(&quot;letters&quot;)) 
+			throw CL_Error(&quot;Font resource &quot; + resource.get_name() + &quot; has no 'letters' attribute.&quot;);
+		
+		//Set most values to CL_Font defaults, then we can override them with options if they exist
+		const CL_Sprite spr_glyphs(bitmap_element.get_attribute(&quot;glyphs&quot;), &amp;manager);
+		const std::string letters = bitmap_element.get_attribute(&quot;letters&quot;);
+		int spacelen = -1;
+		bool monospace = false;
+		
+		if (bitmap_element.has_attribute(&quot;spacelen&quot;))
+			spacelen = CL_String::to_int(bitmap_element.get_attribute(&quot;spacelen&quot;));
+		
+		if (bitmap_element.has_attribute(&quot;monospace&quot;))
+			monospace = (CL_String::to_int(bitmap_element.get_attribute(&quot;monospace&quot;)) != 0);
+		
+		font = CL_Font(
+			spr_glyphs,
+			letters,
+			spacelen,
+			monospace);
+	}
+	else
+	{
+		throw CL_Error(CL_String::format(&quot;Font resource %1 did not have a &lt;system&gt; or &lt;bitmap&gt; child element!&quot;, resource.get_name()));
+	}
+	
+	if (resource.get_element().has_attribute(&quot;width_offset&quot;))
+		font.set_width_offset(CL_String::to_int(resource.get_element().get_attribute(&quot;width_offset&quot;)));
+		
+	if (resource.get_element().has_attribute(&quot;height_offset&quot;))
+		font.set_height_offset(CL_String::to_int(resource.get_element().get_attribute(&quot;height_offset&quot;)));
+	
+	if (resource.get_element().has_attribute(&quot;delims&quot;))
+		font.set_delims(resource.get_element().get_attribute(&quot;delims&quot;));
+}
+
+void CL_ResourceData_Font::on_unload()
+{
+	font = CL_Font();
+}

Added: trunk/clanlib/Display/resourcedata_font.h
===================================================================
--- trunk/clanlib/Display/resourcedata_font.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/resourcedata_font.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,62 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_resourcedata_font
+#define header_resourcedata_font
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/Resources/resourcedata.h&quot;
+#include &quot;API/Core/Resources/resource.h&quot;
+#include &quot;API/Display/font.h&quot;
+
+class CL_ResourceData_Font : public CL_ResourceData
+{
+//! Construction:
+public:
+	CL_ResourceData_Font(CL_Resource &amp;resource);
+	
+	virtual ~CL_ResourceData_Font();
+	
+//! Attributes:
+public:
+	CL_Font &amp;get_font() { return font; }
+
+//! Implementation:
+private:
+	void on_load();
+	
+	void on_unload();
+
+	CL_Font font;
+};
+
+#endif

Added: trunk/clanlib/Display/resourcedata_sprite.cpp
===================================================================
--- trunk/clanlib/Display/resourcedata_sprite.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/resourcedata_sprite.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,201 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;resourcedata_sprite.h&quot;
+#include &quot;API/Display/sprite_description.h&quot;
+#include &quot;API/Display/pixel_buffer.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+
+//////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData_Sprite construction:
+
+CL_ResourceData_Sprite::CL_ResourceData_Sprite(CL_Resource &amp;resource)
+: CL_ResourceData_SpriteDescription(resource, &quot;sprite&quot;)
+{
+}
+
+CL_ResourceData_Sprite::~CL_ResourceData_Sprite()
+{
+}
+
+//////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData_Sprite attributes:
+
+
+//////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData_Sprite implementation:
+
+void CL_ResourceData_Sprite::on_load()
+{
+	// &lt;sprite name=&quot;string&quot; id=&quot;integer&quot; base_angle=&quot;integer&quot; pack_texture=&quot;[yes,no] description=&quot;walking_man&quot;&gt;
+
+	CL_Resource resource = get_resource();
+	CL_SpriteDescription desc = load_description();
+
+	bool pack_texture = resource.get_element().get_attribute(&quot;pack_texture&quot;, &quot;yes&quot;) == &quot;yes&quot;;
+
+	// Create sprite from spritedescription
+	sprite = CL_Sprite(desc, pack_texture);
+
+	// Load base angle
+	float base_angle = (float)atof(resource.get_element().get_attribute(&quot;base_angle&quot;, &quot;0&quot;).c_str());
+	sprite.set_base_angle(base_angle);
+
+	// Load id
+	int id = atoi(resource.get_element().get_attribute(&quot;id&quot;, &quot;0&quot;).c_str());
+	sprite.set_id(id);
+
+	// Load play options	
+	CL_DomNode cur_node;
+	for (
+		cur_node = resource.get_element().get_first_child();
+		!cur_node.is_null();
+		cur_node = cur_node.get_next_sibling())
+	{
+		if (!cur_node.is_element()) continue;
+		CL_DomElement cur_element = cur_node.to_element();
+
+		// &lt;color red=&quot;float&quot; green=&quot;float&quot; blue=&quot;float&quot; alpha=&quot;float&quot; /&gt;
+		std::string tag_name = cur_element.get_tag_name();
+		if (tag_name == &quot;color&quot;)
+		{
+			float r = (float)atof(cur_element.get_attribute(&quot;red&quot;, &quot;1.0&quot;).c_str());
+			float g = (float)atof(cur_element.get_attribute(&quot;green&quot;,&quot;1.0&quot;).c_str());
+			float b = (float)atof(cur_element.get_attribute(&quot;blue&quot;, &quot;1.0&quot;).c_str());
+			float a = (float)atof(cur_element.get_attribute(&quot;alpha&quot;, &quot;1.0&quot;).c_str());
+			sprite.set_color(r,g,b,a);
+		}
+		// &lt;animation speed=&quot;integer&quot; loop=&quot;[yes,no]&quot; pingpong=&quot;[yes,no]&quot; direction=&quot;[backward,forward]&quot; on_finish=&quot;[blank,last_frame,first_frame]&quot;/&gt;
+		else if (tag_name == &quot;animation&quot;)
+		{
+			float delay = (float)atof(cur_element.get_attribute(&quot;speed&quot;, &quot;60&quot;).c_str()) / 1000.0f;
+			int frame_count = sprite.get_frame_count();
+			for(int i=0; i&lt;frame_count; ++i)
+				sprite.set_frame_delay(i, delay);
+
+			sprite.set_play_loop((cur_element.get_attribute(&quot;loop&quot;, &quot;yes&quot;)) == &quot;yes&quot;);
+			sprite.set_play_pingpong((cur_element.get_attribute(&quot;pingpong&quot;, &quot;no&quot;)) == &quot;yes&quot;);
+			sprite.set_play_backward((cur_element.get_attribute(&quot;direction&quot;, &quot;forward&quot;)) == &quot;backward&quot;);
+
+			std::string on_finish = cur_element.get_attribute(&quot;on_finish&quot;, &quot;blank&quot;);
+			if(on_finish == &quot;first_frame&quot;)
+				sprite.set_show_on_finish(CL_Sprite::show_first_frame);
+			else if(on_finish == &quot;last_frame&quot;)
+				sprite.set_show_on_finish(CL_Sprite::show_last_frame);
+			else
+				sprite.set_show_on_finish(CL_Sprite::show_blank);
+		}
+		// &lt;scale x=&quot;float&quot; y=&quot;float /&gt;
+		else if (tag_name == &quot;scale&quot;)
+		{
+			float x = (float)atof(cur_element.get_attribute(&quot;x&quot;, &quot;1.0&quot;).c_str());
+			float y = (float)atof(cur_element.get_attribute(&quot;y&quot;, &quot;1.0&quot;).c_str());
+			sprite.set_scale(x, y);
+		}
+		// &lt;translation origin=&quot;string&quot; x=&quot;integer&quot; y=&quot;integer&quot; /&gt;
+		else if (tag_name == &quot;translation&quot;)
+		{
+			std::string hotspot = cur_element.get_attribute(&quot;origin&quot;, &quot;top_left&quot;);
+			CL_Origin origin;
+
+			if(hotspot == &quot;center&quot;)
+				origin = origin_center;
+			else if(hotspot == &quot;top_center&quot;)
+				origin = origin_top_center;
+			else if(hotspot == &quot;top_right&quot;)
+				origin = origin_top_right;
+			else if(hotspot == &quot;center_left&quot;)
+				origin = origin_center_left;
+			else if(hotspot == &quot;center_right&quot;)
+				origin = origin_center_right;
+			else if(hotspot == &quot;bottom_left&quot;)
+				origin = origin_bottom_left;
+			else if(hotspot == &quot;bottom_center&quot;)
+				origin = origin_bottom_center;
+			else if(hotspot == &quot;bottom_right&quot;)
+				origin = origin_bottom_right;
+			else
+				origin = origin_top_left;
+
+			int xoffset = atoi(cur_element.get_attribute(&quot;x&quot;, &quot;0&quot;).c_str());
+			int yoffset = atoi(cur_element.get_attribute(&quot;y&quot;, &quot;0&quot;).c_str());
+
+			sprite.set_alignment(origin, xoffset, yoffset);
+		}
+		// &lt;rotation origin=&quot;string&quot; x=&quot;integer&quot; y=&quot;integer&quot; /&gt;
+		else if (tag_name == &quot;rotation&quot;)
+		{
+			std::string hotspot = cur_element.get_attribute(&quot;origin&quot;, &quot;center&quot;);
+			CL_Origin origin;
+
+			if(hotspot == &quot;top_left&quot;)
+				origin = origin_top_left;
+			else if(hotspot == &quot;top_center&quot;)
+				origin = origin_top_center;
+			else if(hotspot == &quot;top_right&quot;)
+				origin = origin_top_right;
+			else if(hotspot == &quot;center_left&quot;)
+				origin = origin_center_left;
+			else if(hotspot == &quot;center_right&quot;)
+				origin = origin_center_right;
+			else if(hotspot == &quot;bottom_left&quot;)
+				origin = origin_bottom_left;
+			else if(hotspot == &quot;bottom_center&quot;)
+				origin = origin_bottom_center;
+			else if(hotspot == &quot;bottom_right&quot;)
+				origin = origin_bottom_right;
+			else
+				origin = origin_center;
+
+			int xoffset = atoi(cur_element.get_attribute(&quot;x&quot;, &quot;0&quot;).c_str());
+			int yoffset = atoi(cur_element.get_attribute(&quot;y&quot;, &quot;0&quot;).c_str());
+
+			sprite.set_rotation_hotspot(origin, xoffset, yoffset);
+		}
+		// &lt;frame nr=&quot;integer&quot; speed=&quot;integer&quot; x=&quot;integer&quot; y=&quot;integer&quot; /&gt;
+		else if (tag_name == &quot;frame&quot;)
+		{
+			int nr = atoi(cur_element.get_attribute(&quot;nr&quot;, &quot;0&quot;).c_str());
+			float delay = (float)atof(cur_element.get_attribute(&quot;speed&quot;, &quot;60&quot;).c_str()) / 1000.0f;
+			int yoffset = atoi(cur_element.get_attribute(&quot;y&quot;, &quot;0&quot;).c_str());
+			int xoffset = atoi(cur_element.get_attribute(&quot;x&quot;, &quot;0&quot;).c_str());
+
+			sprite.set_frame_delay(nr, delay);
+			sprite.set_frame_offset(nr, CL_Point(xoffset, yoffset));
+		}
+	}
+}
+	
+void CL_ResourceData_Sprite::on_unload()
+{
+	sprite = CL_Sprite();
+}

Added: trunk/clanlib/Display/resourcedata_sprite.h
===================================================================
--- trunk/clanlib/Display/resourcedata_sprite.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/resourcedata_sprite.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,63 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_resourcedata_sprite
+#define header_resourcedata_sprite
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/Resources/resourcedata.h&quot;
+#include &quot;API/Core/Resources/resource.h&quot;
+#include &quot;API/Display/sprite.h&quot;
+#include &quot;resourcedata_sprite_description.h&quot;
+
+class CL_ResourceData_Sprite : public CL_ResourceData_SpriteDescription
+{
+//! Construction:
+public:
+	CL_ResourceData_Sprite(CL_Resource &amp;resource);
+	
+	virtual ~CL_ResourceData_Sprite();
+	
+//! Attributes:
+public:
+	CL_Sprite &amp;get_sprite() { return sprite; }
+
+//! Implementation:
+private:
+	void on_load();
+	
+	void on_unload();
+
+	CL_Sprite sprite;
+};
+
+#endif

Added: trunk/clanlib/Display/resourcedata_sprite_description.cpp
===================================================================
--- trunk/clanlib/Display/resourcedata_sprite_description.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/resourcedata_sprite_description.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,242 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;resourcedata_sprite_description.h&quot;
+#include &quot;API/Display/sprite_description.h&quot;
+#include &quot;API/Display/pixel_buffer.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;API/Display/Providers/provider_factory.h&quot;
+
+//////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData_SpriteDescription construction:
+
+CL_ResourceData_SpriteDescription::CL_ResourceData_SpriteDescription(CL_Resource &amp;resource, const std::string &amp;type)
+: CL_ResourceData(resource)
+{
+	resource.attach_data(type, this);
+}
+	
+CL_ResourceData_SpriteDescription::~CL_ResourceData_SpriteDescription()
+{
+}
+	
+//////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData_SpriteDescription attributes:
+
+//////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData_SpriteDescription operations:
+
+CL_SpriteDescription CL_ResourceData_SpriteDescription::load_description()
+{
+	CL_Resource resource = get_resource();
+	CL_SpriteDescription desc;
+
+	std::string str_keep_pixelbuffer;
+	std::string str_force_16bit;
+
+	std::string load_description = resource.get_element().get_attribute(&quot;description&quot;, &quot;&quot;);
+	if(load_description != &quot;&quot;)
+	{
+		CL_Resource global_resource = resource.get_manager().get_resource(load_description);
+		add_images(desc, global_resource);
+
+		if (global_resource.get_element().has_attribute(&quot;keep_pixelbuffer&quot;))
+			str_keep_pixelbuffer = global_resource.get_element().get_attribute(&quot;keep_pixelbuffer&quot;, &quot;false&quot;);
+		if (global_resource.get_element().has_attribute(&quot;force_16bit&quot;))
+			str_force_16bit = global_resource.get_element().get_attribute(&quot;force_16bit&quot;, &quot;false&quot;);
+	}
+
+	if (resource.get_element().has_attribute(&quot;keep_pixelbuffer&quot;))
+		str_keep_pixelbuffer = resource.get_element().get_attribute(&quot;keep_pixelbuffer&quot;, &quot;false&quot;);
+	if (resource.get_element().has_attribute(&quot;force_16bit&quot;))
+		str_force_16bit = resource.get_element().get_attribute(&quot;force_16bit&quot;, &quot;false&quot;);
+
+	bool keep_pixelbuffer = CL_String::to_bool(str_keep_pixelbuffer);
+	bool force_16bit = CL_String::to_bool(str_force_16bit);
+
+	desc.set_surface_flag(keep_pixelbuffer * CL_Surface::flag_keep_pixelbuffer | force_16bit * CL_Surface::flag_force_16bit);
+
+	add_images(desc, resource);
+
+	if (desc.get_frames().empty()) throw CL_Error(&quot;Sprite resource contained no frames!&quot;);
+
+	return desc;
+}
+
+//////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData_SpriteDescription implementation:
+
+void CL_ResourceData_SpriteDescription::add_images(CL_SpriteDescription &amp;desc, CL_Resource &amp;resource)
+{
+	CL_DomNode cur_node;
+
+	for (
+		cur_node = resource.get_element().get_first_child();
+		!cur_node.is_null();
+		cur_node = cur_node.get_next_sibling())
+	{
+		if (!cur_node.is_element()) continue;
+
+		CL_DomElement cur_element = cur_node.to_element();
+		if (cur_element.get_tag_name() == &quot;image&quot;)
+		{
+			std::string image_name = cur_element.get_attribute(&quot;file&quot;);
+			CL_PixelBuffer image = load_image(image_name);
+
+			CL_DomNode cur_child ( cur_element.get_first_child() );
+			if( cur_child.is_null() ) 
+			{
+				desc.add_frame(image);
+			}
+			else do
+			{
+				CL_DomElement cur_child_elemnt = cur_child.to_element();
+				if( cur_child.get_node_name() == &quot;grid&quot; )
+				{
+					int xpos = 0;
+					int ypos = 0;
+					int xarray = 1;
+					int yarray = 1;
+					int array_skipframes = 0;
+					int xspacing = 0;
+					int yspacing = 0;
+
+					std::vector&lt;std::string&gt; image_size = CL_String::tokenize(cur_child_elemnt.get_attribute(&quot;size&quot;), &quot;,&quot;);
+					int width = 0;
+					if (image_size.size() &gt; 0)
+						width = atoi(image_size[0].c_str());
+					int height = 0;
+					if (image_size.size() &gt; 1)
+						height = atoi(image_size[1].c_str());
+
+					if (cur_child_elemnt.has_attribute(&quot;pos&quot;))
+					{
+						std::vector&lt;std::string&gt; image_pos = CL_String::tokenize(cur_child_elemnt.get_attribute(&quot;pos&quot;), &quot;,&quot;);
+						xpos = atoi(image_pos[0].c_str());
+						ypos = atoi(image_pos[1].c_str());
+					}
+
+					if (cur_child_elemnt.has_attribute(&quot;array&quot;))
+					{
+						std::vector&lt;std::string&gt; image_array = CL_String::tokenize(cur_child_elemnt.get_attribute(&quot;array&quot;), &quot;,&quot;);
+											if (image_array.size() == 2)
+											  {
+												xarray = atoi(image_array[0].c_str());
+												yarray = atoi(image_array[1].c_str());
+											  }
+											else
+											  {
+												throw CL_Error(&quot;Resource '&quot; + resource.get_name() + &quot;' has incorrect array attribute, must be \&quot;X,Y\&quot;!&quot;); 
+											  }
+					}
+
+					if (cur_child_elemnt.has_attribute(&quot;array_skipframes&quot;))
+					{
+						array_skipframes = atoi(cur_child_elemnt.get_attribute(&quot;array_skipframes&quot;).c_str());
+					}
+
+					if (cur_child_elemnt.has_attribute(&quot;spacing&quot;))
+					{
+						std::vector&lt;std::string&gt; image_spacing = CL_String::tokenize(cur_child_elemnt.get_attribute(&quot;spacing&quot;), &quot;,&quot;);
+						xspacing = atoi(image_spacing[0].c_str());
+						yspacing = atoi(image_spacing[1].c_str());
+					}
+
+					desc.add_gridclipped_frames(
+						image,
+						xpos, ypos,
+						width, height,
+						xarray, yarray,
+						array_skipframes,
+						xspacing, yspacing);
+				}
+				else if( cur_child.get_node_name() == &quot;palette&quot; )
+				{
+					int xpos = 0;
+					int ypos = 0;
+
+					if (cur_child_elemnt.has_attribute(&quot;pos&quot;))
+					{
+						std::vector&lt;std::string&gt; image_pos = CL_String::tokenize(cur_child_elemnt.get_attribute(&quot;pos&quot;), &quot;,&quot;);
+						xpos = atoi(image_pos[0].c_str());
+						ypos = atoi(image_pos[1].c_str());
+					}
+
+					desc.add_paletteclipped_frames(
+						image,
+						xpos, ypos);
+				}
+				else if( cur_child.get_node_name() == &quot;alpha&quot; )
+				{
+					int xpos = 0;
+					int ypos = 0;
+					float trans_limit = 0.05f;
+
+					if (cur_child_elemnt.has_attribute(&quot;pos&quot;))
+					{
+						std::vector&lt;std::string&gt; image_pos = CL_String::tokenize(cur_child_elemnt.get_attribute(&quot;pos&quot;), &quot;,&quot;);
+						xpos = atoi(image_pos[0].c_str());
+						ypos = atoi(image_pos[1].c_str());
+					}
+
+					if (cur_child_elemnt.has_attribute(&quot;trans_limit&quot;))
+					{
+						trans_limit = (float)atof(cur_child_elemnt.get_attribute(&quot;trans_limit&quot;).c_str());
+					}
+
+					if (cur_child_elemnt.has_attribute(&quot;free&quot;))
+					{
+						desc.add_alphaclipped_frames_free(
+							image,
+							xpos, ypos,
+							trans_limit);
+					}
+					else
+					{
+						desc.add_alphaclipped_frames(
+							image,
+							xpos, ypos,
+							trans_limit);
+					}
+				}
+
+				cur_child = cur_child.get_next_sibling();
+				
+			} while(!cur_child.is_null());
+		}
+	}
+}
+
+CL_PixelBuffer CL_ResourceData_SpriteDescription::load_image(const std::string &amp;filename)
+{
+	return CL_ProviderFactory::load(filename, &quot;&quot;, get_resource().get_manager().get_resource_provider());
+}

Added: trunk/clanlib/Display/resourcedata_sprite_description.h
===================================================================
--- trunk/clanlib/Display/resourcedata_sprite_description.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/resourcedata_sprite_description.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,64 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_resourcedata_sprite_description
+#define header_resourcedata_sprite_description
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/Resources/resourcedata.h&quot;
+#include &quot;API/Core/Resources/resource.h&quot;
+#include &quot;API/Display/sprite_description.h&quot;
+
+class CL_ResourceData_SpriteDescription : public CL_ResourceData
+{
+//! Construction:
+public:
+	CL_ResourceData_SpriteDescription(CL_Resource &amp;resource, const std::string &amp;type = &quot;sprite_description&quot;);
+	
+	virtual ~CL_ResourceData_SpriteDescription();
+	
+//! Attributes:
+public:
+
+//! Operations:
+public:
+	//: Loads a sprite description based on the resource description.
+	CL_SpriteDescription load_description();
+
+//! Implementation:
+private:
+	CL_PixelBuffer load_image(const std::string &amp;filename);
+
+	void add_images(CL_SpriteDescription &amp;desc, CL_Resource &amp;resource);
+};
+
+#endif

Added: trunk/clanlib/Display/resourcedata_surface.cpp
===================================================================
--- trunk/clanlib/Display/resourcedata_surface.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/resourcedata_surface.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,123 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;resourcedata_surface.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;API/Display/Providers/provider_factory.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/Display/pixel_buffer.h&quot;
+#include &quot;API/Display/pixel_format.h&quot;
+
+//////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData_Surface construction:
+
+CL_ResourceData_Surface::CL_ResourceData_Surface(CL_Resource &amp;resource)
+: CL_ResourceData(resource)
+{
+	resource.attach_data(&quot;surface&quot;, this);
+}
+
+CL_ResourceData_Surface::~CL_ResourceData_Surface()
+{
+}
+	
+//////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData_Surface attributes:
+
+
+//////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData_Surface implementation:
+
+void CL_ResourceData_Surface::on_load()
+{
+	CL_Resource resource = get_resource();
+	std::string name = resource.get_element().get_attribute(&quot;file&quot;);
+	std::string image_format = resource.get_element().get_attribute(&quot;format&quot;);
+	std::string keep_pixelbuffer = resource.get_element().get_attribute(&quot;keep_pixelbuffer&quot;, &quot;false&quot;);
+	std::string force_16bit = resource.get_element().get_attribute(&quot;force_16bit&quot;, &quot;false&quot;);
+
+	int flag = CL_Surface::flag_none;
+	if(CL_String::to_bool(keep_pixelbuffer) == true)
+		flag |= CL_Surface::flag_keep_pixelbuffer;
+	if(CL_String::to_bool(force_16bit) == true)
+		flag |= CL_Surface::flag_force_16bit;
+
+	CL_PixelBuffer image = CL_ProviderFactory::load(name, image_format, resource.get_manager().get_resource_provider());
+
+	// now check if we just need a portion of the surface
+	int xpos = -1, ypos = -1, width = -1, height = -1;
+	if (resource.get_element().has_attribute(&quot;pos&quot;))
+	{
+		std::vector&lt;std::string&gt; image_pos = CL_String::tokenize(resource.get_element().get_attribute(&quot;pos&quot;), &quot;,&quot;);
+		
+		xpos = atoi(image_pos[0].c_str());
+		ypos = atoi(image_pos[1].c_str());
+		
+		// if only the position is given, we need the complete image from that point
+		width = image.get_width() - xpos;
+		height = image.get_height() - ypos;
+	}
+	if (resource.get_element().has_attribute(&quot;size&quot;))
+	{
+		std::vector&lt;std::string&gt; image_pos = CL_String::tokenize(resource.get_element().get_attribute(&quot;pos&quot;), &quot;,&quot;);
+		
+		xpos = atoi(image_pos[0].c_str());
+		ypos = atoi(image_pos[1].c_str());
+
+		// if no position is given, we only need the upperleft corner
+		if( xpos == -1 || ypos == -1 )
+		{
+			xpos = 0;
+			ypos = 0;
+		}
+	}
+
+	// if we only need a portion, convert the image
+	if (xpos != -1 &amp;&amp; ypos != -1 &amp;&amp; width != -1 &amp;&amp; height != -1)
+	{
+		CL_PixelBuffer chopped_image( width, height, image.get_format().get_depth()*width, image.get_format(), NULL );
+		chopped_image.lock();
+		image.convert( 
+			chopped_image.get_data(), 
+			chopped_image.get_format(), 
+			image.get_format().get_depth()*width, 
+			CL_Rect(0,0,width,height), 
+			CL_Rect(xpos,ypos,xpos+width,ypos+height) );
+		chopped_image.unlock();
+		image = chopped_image;
+	}
+
+	surface = CL_Surface(image, flag);
+}
+	
+void CL_ResourceData_Surface::on_unload()
+{
+	surface = CL_Surface();
+}

Added: trunk/clanlib/Display/resourcedata_surface.h
===================================================================
--- trunk/clanlib/Display/resourcedata_surface.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/resourcedata_surface.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,62 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_resourcedata_surface
+#define header_resourcedata_surface
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/Resources/resourcedata.h&quot;
+#include &quot;API/Core/Resources/resource.h&quot;
+#include &quot;API/Display/surface.h&quot;
+
+class CL_ResourceData_Surface : public CL_ResourceData
+{
+//! Construction:
+public:
+	CL_ResourceData_Surface(CL_Resource &amp;resource);
+	
+	virtual ~CL_ResourceData_Surface();
+	
+//! Attributes:
+public:
+	CL_Surface &amp;get_surface() { return surface; }
+
+//! Implementation:
+private:
+	void on_load();
+	
+	void on_unload();
+
+	CL_Surface surface;
+};
+
+#endif

Added: trunk/clanlib/Display/resourcedata_text_styler.cpp
===================================================================
--- trunk/clanlib/Display/resourcedata_text_styler.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/resourcedata_text_styler.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,96 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;resourcedata_text_styler.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+
+#include &lt;string&gt;
+#include &lt;map&gt;
+
+//////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData_TextStyler construction:
+
+CL_ResourceData_TextStyler::CL_ResourceData_TextStyler(CL_Resource &amp;resource)
+: CL_ResourceData(resource)
+{
+	resource.attach_data(&quot;text_styler&quot;, this);
+}
+	
+CL_ResourceData_TextStyler::~CL_ResourceData_TextStyler()
+{
+}
+	
+//////////////////////////////////////////////////////////////////////////////
+// CL_ResourceData_TextStyler implementation:
+
+void CL_ResourceData_TextStyler::on_load()
+{
+	CL_Resource resource = get_resource();
+	CL_ResourceManager manager = resource.get_manager();
+
+	ts = CL_TextStyler();
+	std::map&lt;std::string, CL_Font&gt;&amp; fnt_map = ts.get_fonts();
+	
+	for (
+		CL_DomNode cur_node = resource.get_element().get_first_child();
+		!cur_node.is_null();
+		cur_node = cur_node.get_next_sibling())
+	{
+		if (!cur_node.is_element()) continue;
+		
+		CL_DomElement cur_element = cur_node.to_element();
+		if (
+			cur_element.get_tag_name() == &quot;font&quot;
+			&amp;&amp; cur_element.has_attribute(&quot;name&quot;)
+			&amp;&amp; cur_element.has_attribute(&quot;font&quot;))
+		{
+			if (manager.exists(cur_element.get_attribute(&quot;font&quot;)))
+			{
+				fnt_map[cur_element.get_attribute(&quot;name&quot;)] =
+					CL_Font(cur_element.get_attribute(&quot;font&quot;), &amp;manager);
+			}
+			else
+			{
+				throw CL_Error(std::string(&quot;CL_TextStyler: Unable to find sub-font named &quot;) + cur_element.get_attribute(&quot;font&quot;));
+			}
+		}
+		else
+		{
+			throw CL_Error(&quot;CL_TextStyler: Unknown sub-element of a text_styler resource&quot;);
+		}
+	}
+}
+
+void CL_ResourceData_TextStyler::on_unload()
+{
+	ts = CL_TextStyler();
+}

Added: trunk/clanlib/Display/resourcedata_text_styler.h
===================================================================
--- trunk/clanlib/Display/resourcedata_text_styler.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/resourcedata_text_styler.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,62 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_resourcedata_text_styler
+#define header_resourcedata_text_styler
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/Resources/resourcedata.h&quot;
+#include &quot;API/Core/Resources/resource.h&quot;
+#include &quot;API/Display/text_styler.h&quot;
+
+class CL_ResourceData_TextStyler : public CL_ResourceData
+{
+//! Construction:
+public:
+	CL_ResourceData_TextStyler(CL_Resource &amp;resource);
+	
+	virtual ~CL_ResourceData_TextStyler();
+	
+//! Attributes:
+public:
+	CL_TextStyler &amp;get_text_styler() { return ts; }
+
+//! Implementation:
+private:
+	void on_load();
+	
+	void on_unload();
+
+	CL_TextStyler ts;
+};
+
+#endif

Added: trunk/clanlib/Display/setupdisplay.cpp
===================================================================
--- trunk/clanlib/Display/setupdisplay.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/setupdisplay.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,118 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/Providers/provider_type_register.h&quot;
+#include &quot;API/Display/Providers/pcx_provider.h&quot;
+#include &quot;API/Display/Providers/targa_provider.h&quot;
+#include &quot;API/Display/Providers/jpeg_provider.h&quot;
+#include &quot;API/Display/Providers/png_provider.h&quot;
+#include &quot;API/Display/setupdisplay.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;resourcedata_surface.h&quot;
+#include &quot;resourcedata_sprite.h&quot;
+#include &quot;resourcedata_sprite_description.h&quot;
+#include &quot;resourcedata_font.h&quot;
+#include &quot;resourcedata_text_styler.h&quot;
+#include &quot;resourcedata_collisionoutline.h&quot;
+
+static int init_count = 0;
+static CL_Slot slot_resource_added;
+
+static CL_ProviderType_Register&lt;CL_PCXProvider&gt; *pcx_provider = NULL;
+static CL_ProviderType_Register&lt;CL_TargaProvider&gt; *tga_provider = NULL;
+static CL_ProviderType_Register&lt;CL_TargaProvider&gt; *targa_provider = NULL;
+static CL_ProviderType_Register&lt;CL_JPEGProvider&gt; *jpeg_provider = NULL;
+static CL_ProviderType_Register&lt;CL_JPEGProvider&gt; *jpg_provider = NULL;
+static CL_ProviderType_Register&lt;CL_PNGProvider&gt; *png_provider = NULL;
+
+static void clandisplay_resource_added(CL_Resource &amp;resource)
+{
+	std::string type = resource.get_type();
+	
+	if (type == &quot;surface&quot;) new CL_ResourceData_Surface(resource);
+	if (type == &quot;sprite&quot;) new CL_ResourceData_Sprite(resource);
+	if (type == &quot;description&quot;) new CL_ResourceData_SpriteDescription(resource);
+	if (type == &quot;font&quot;) new CL_ResourceData_Font(resource);
+	if (type == &quot;text_styler&quot;) new CL_ResourceData_TextStyler(resource);
+	if (type == &quot;collisionoutline&quot;) new CL_ResourceData_CollisionOutline(resource);
+}
+
+CL_SetupDisplay::CL_SetupDisplay(bool register_resources_only)
+{
+	CL_SetupDisplay::init(register_resources_only);
+}
+
+CL_SetupDisplay::~CL_SetupDisplay()
+{
+	CL_SetupDisplay::deinit();
+}
+
+void CL_SetupDisplay::init(bool register_resources_only)
+{
+	init_count++;
+	if (init_count != 1) return;
+
+	slot_resource_added = CL_ResourceManager::sig_resource_added().connect(&amp;clandisplay_resource_added);
+
+	pcx_provider   = new CL_ProviderType_Register&lt;CL_PCXProvider&gt;(&quot;pcx&quot;);
+	tga_provider   = new CL_ProviderType_Register&lt;CL_TargaProvider&gt;(&quot;tga&quot;);
+	targa_provider = new CL_ProviderType_Register&lt;CL_TargaProvider&gt;(&quot;targa&quot;);
+	jpeg_provider  = new CL_ProviderType_Register&lt;CL_JPEGProvider&gt;(&quot;jpeg&quot;);
+	jpg_provider   = new CL_ProviderType_Register&lt;CL_JPEGProvider&gt;(&quot;jpg&quot;);
+	png_provider   = new CL_ProviderType_Register&lt;CL_PNGProvider&gt;(&quot;png&quot;);
+	
+	if (register_resources_only) return;
+}
+
+void CL_SetupDisplay::deinit()
+{
+	init_count--;
+	if (init_count != 0) return;
+
+	delete pcx_provider;
+	pcx_provider = NULL;
+
+	delete tga_provider;
+	tga_provider = NULL;
+
+	delete targa_provider;
+	targa_provider = NULL;
+
+	delete jpeg_provider;
+	jpeg_provider = NULL;
+
+	delete jpg_provider;
+	jpg_provider = NULL;
+
+	delete png_provider;
+	png_provider = NULL;
+
+	slot_resource_added = CL_Slot();
+}

Added: trunk/clanlib/Display/sprite.cpp
===================================================================
--- trunk/clanlib/Display/sprite.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/sprite.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,989 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/pixel_format.h&quot;
+#include &quot;API/Display/pixel_buffer.h&quot;
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Display/display_window.h&quot;
+#include &quot;API/Display/sprite.h&quot;
+#include &quot;API/Display/sprite_description.h&quot;
+#include &quot;API/Display/sprite_packer.h&quot;
+#include &quot;API/Display/surface.h&quot;
+#include &quot;API/Display/graphic_context.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/System/log.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;sprite_generic.h&quot;
+#include &quot;resourcedata_sprite.h&quot;
+#include &quot;display_target.h&quot;
+#include &quot;surface_generic.h&quot;
+
+#include &lt;math.h&gt;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Sprite construction:
+
+CL_Sprite::CL_Sprite(const std::string &amp;resource_id, CL_ResourceManager *manager)
+: impl(0)
+{
+	resource = manager-&gt;get_resource(resource_id);
+	resource.load();
+
+	CL_ResourceData_Sprite *data =
+		(CL_ResourceData_Sprite *) resource.get_data(&quot;sprite&quot;);
+
+	if (!data)
+		throw CL_Error(&quot;Resource '&quot; + resource_id + &quot;' is not of type 'sprite'&quot;);
+
+	impl = new CL_Sprite_Generic;
+	if (data-&gt;get_sprite().impl)
+	{
+		*impl = *data-&gt;get_sprite().impl;
+		restart();
+	}
+}
+
+CL_Sprite::CL_Sprite(const CL_SpriteDescription &amp;spritedescription, bool pack_texture)
+: impl(new CL_Sprite_Generic)
+{
+	if (pack_texture &amp;&amp; CL_DisplayTarget::current()-&gt;enable_packer())
+	{
+		// Fetch max texture size
+		CL_DisplayWindow *window = CL_Display::get_current_window();
+		CL_Size max_surface_size = window-&gt;get_gc()-&gt;get_max_surface_size();
+
+		// Pack frames into textures
+		CL_SpritePacker packer(spritedescription);
+		if(packer.pack(max_surface_size.width, max_surface_size.height) == false)
+			throw CL_Error(&quot;Couldn't pack all frames into textures&quot;);
+
+		// Fetch texture, description-frame and packed-frame lists
+		const std::list&lt;CL_SpriteDescription::FramePair&gt; &amp;frames = spritedescription.get_frames();
+		std::list&lt;CL_SpriteDescription::FramePair&gt;::const_iterator it_frames;
+
+		// Lock all pixelbuffers to avoid multiple loadings of same pb's:
+		for (it_frames = frames.begin(); it_frames != frames.end(); ++it_frames)
+		{
+			CL_PixelBuffer buffer = (*it_frames).first;
+			buffer.lock();
+		}
+		
+		const std::list&lt;CL_SpritePacker::TexturePair&gt; &amp;packed_frames = packer.get_frames();
+		std::list&lt;CL_SpritePacker::TexturePair&gt;::const_iterator it_packed_frames;
+		
+		const std::vector&lt;CL_Size&gt; &amp;texture_sizes = packer.get_texture_sizes();
+
+		std::vector&lt;CL_Surface&gt; surfaces;
+			
+		// Set up a pixelbuffer format
+		CL_PixelFormat format;
+		format.set_depth(32);
+		format.enable_colorkey(false);
+		format.set_alpha_mask(0xFF000000);
+		format.set_blue_mask (0x00FF0000);
+		format.set_green_mask(0x0000FF00);
+		format.set_red_mask  (0x000000FF);
+
+		// Create all the textures needed for packing
+//		CL_Log::log(&quot;debug&quot;, &quot;New sprite:&quot;);
+		for(unsigned int i = 0; i &lt; texture_sizes.size(); i++)
+		{
+			int width = texture_sizes[i].width;
+			int height = texture_sizes[i].height;
+			
+			CL_PixelBuffer buffer(width, height, 4 * width, format);
+			buffer.lock();
+
+//			CL_Log::log(&quot;debug&quot;, &quot;- Packing texture %1x%2&quot;, width, height);
+
+			// Copy frames into this texture
+			for(it_frames = frames.begin(), it_packed_frames = packed_frames.begin();
+				it_frames != frames.end();
+				++it_frames, ++it_packed_frames)
+			{
+				if((*it_packed_frames).first == static_cast&lt;int&gt;(i))	// Frame uses this buffer
+				{
+					CL_PixelBuffer src = (*it_frames).first;
+					CL_PixelBuffer dest = buffer;
+
+					CL_Rect src_rect  = (*it_frames).second;
+					CL_Rect dest_rect = (*it_packed_frames).second;
+
+					// Remove border around image:
+					dest_rect.left++;
+					dest_rect.right--;
+					dest_rect.top++;
+					dest_rect.bottom--;
+					
+					src.convert(dest.get_data(), format, dest.get_pitch(), dest_rect, src_rect);
+
+					int x, y;
+					int dest_pitch = dest.get_pitch();
+					unsigned char *data_bytes = (unsigned char*) dest.get_data();
+
+					// Make transparent pixels grey:
+					for (y=dest_rect.top; y&lt;dest_rect.bottom; y++)
+					{
+						unsigned int *line = (unsigned int *) (data_bytes+y*dest_pitch);
+						for (x=dest_rect.left; x&lt;dest_rect.right; x++)
+						{
+							// Test for transparent pixels surrounded by non transparent ones
+							if ((line[x] &amp; 0xff000000) == 0)
+							{
+								int r=0,g=0,b=0,n=0;
+                                if(x &lt; dest_rect.right-1) {
+									if((line[x+1] &amp; 0xff000000) != 0)
+									{
+										r+= (line[x+1] &amp; 0x00ff0000) &gt;&gt; 16;
+										g+= (line[x+1] &amp; 0x0000ff00) &gt;&gt; 8;
+										b+= (line[x+1] &amp; 0x000000ff);
+										n++;
+									}
+								}
+								if(x &gt; 0) {
+									if((line[x-1] &amp; 0xff000000) != 0)
+									{
+										r+= (line[x-1] &amp; 0x00ff0000) &gt;&gt; 16;
+										g+= (line[x-1] &amp; 0x0000ff00) &gt;&gt; 8;
+										b+= (line[x-1] &amp; 0x000000ff);
+										n++;
+									}
+								}
+								if(y &lt; dest_rect.bottom-1) {
+									line = (unsigned int *) (data_bytes+(y+1)*dest_pitch);
+									if((line[x] &amp; 0xff000000) != 0)
+									{
+										r+= (line[x] &amp; 0x00ff0000) &gt;&gt; 16;
+										g+= (line[x] &amp; 0x0000ff00) &gt;&gt; 8;
+										b+= (line[x] &amp; 0x000000ff);
+										n++;
+									}
+								}
+								if(y &gt; 0) {
+									line = (unsigned int *) (data_bytes+(y-1)*dest_pitch);
+									if((line[x] &amp; 0xff000000) != 0)
+									{
+										r+= (line[x] &amp; 0x00ff0000) &gt;&gt; 16;
+										g+= (line[x] &amp; 0x0000ff00) &gt;&gt; 8;
+										b+= (line[x] &amp; 0x000000ff);
+										n++;
+									}
+								}
+
+								line = (unsigned int *) (data_bytes+y*dest_pitch);
+								if(n&gt;0)
+								{
+									// Set colour to the avarage of the found pixels
+									line[x] = ( ((r/n)&lt;&lt;16) | ((g/n)&lt;&lt;8) | (b/n) );
+								}
+								else line[x] = 0x007f7f7f;
+							}
+						}
+					}
+
+					// Copy pixels in border area:
+					unsigned int *top_line = (unsigned int *) (data_bytes+(dest_rect.top-1)*dest_pitch);
+					unsigned int *next_line = (unsigned int *) (data_bytes+dest_rect.top*dest_pitch);
+					unsigned int *bottom_line = (unsigned int *) (data_bytes+(dest_rect.bottom)*dest_pitch);
+					unsigned int *prev_line = (unsigned int *) (data_bytes+(dest_rect.bottom-1)*dest_pitch);
+					for (x=dest_rect.left; x&lt;dest_rect.right; x++)
+					{
+						top_line[x] = next_line[x];
+						bottom_line[x] = prev_line[x];
+					}
+					for (y=dest_rect.top; y&lt;dest_rect.bottom; y++)
+					{
+						unsigned int *line = (unsigned int *) (data_bytes+y*dest_pitch);
+						line[dest_rect.left-1] = line[dest_rect.left];
+						line[dest_rect.right] = line[dest_rect.right-1];
+					}
+					#define dest_pixel(x,y) (*((unsigned int *) (data_bytes+(y)*dest_pitch)+x))
+					dest_pixel(dest_rect.left-1, dest_rect.top-1) = dest_pixel(dest_rect.left, dest_rect.top);
+					dest_pixel(dest_rect.right, dest_rect.top-1) = dest_pixel(dest_rect.right-1, dest_rect.top);
+					dest_pixel(dest_rect.left-1, dest_rect.bottom) = dest_pixel(dest_rect.left, dest_rect.bottom-1);
+					dest_pixel(dest_rect.right, dest_rect.bottom) = dest_pixel(dest_rect.right-1, dest_rect.bottom-1);
+				}
+			}
+			
+			// Create CL_Surface
+			surfaces.push_back(CL_Surface(buffer, spritedescription.get_surface_flag()));
+			
+			// Clean up
+			buffer.unlock();
+		}
+
+		// Create SpriteFrames
+		for(it_frames = frames.begin(), it_packed_frames = packed_frames.begin();
+			it_frames != frames.end();
+			++it_frames, ++it_packed_frames)
+		{
+			CL_Sprite_Generic::SpriteFrame frame;
+			
+			frame.surface = surfaces[(*it_packed_frames).first];
+			frame.position = (*it_packed_frames).second;
+			frame.delay = 0.06f;
+			frame.offset = CL_Point(0, 0);
+			
+			// Remove border around image:
+			frame.position.left++;
+			frame.position.right--;
+			frame.position.top++;
+			frame.position.bottom--;
+			
+			impl-&gt;frames.push_back(frame);
+		}
+
+		// Unlock all pixelbuffers:
+		for (it_frames = frames.begin(); it_frames != frames.end(); ++it_frames)
+		{
+			CL_PixelBuffer buffer = (*it_frames).first;
+			buffer.unlock();
+		}
+	}
+	else
+	{
+		// Create SpriteFrames
+		const std::list&lt;CL_SpriteDescription::FramePair&gt; &amp;frames = spritedescription.get_frames();
+		std::list&lt;CL_SpriteDescription::FramePair&gt;::const_iterator it_frames;
+		std::map&lt;CL_PixelBuffer, CL_Surface&gt; surfaces;
+
+		for(it_frames = frames.begin();
+			it_frames != frames.end();
+			++it_frames)
+		{	
+			CL_Sprite_Generic::SpriteFrame frame;
+
+			std::map&lt;CL_PixelBuffer, CL_Surface&gt;::iterator i = surfaces.find((*it_frames).first);
+			if (i == surfaces.end())
+			{
+				frame.surface  = CL_Surface((*it_frames).first);
+				surfaces[(*it_frames).first] = frame.surface;
+			}
+			else
+			{
+				frame.surface = i-&gt;second;
+			}
+
+			frame.position = (*it_frames).second;
+			frame.delay = 0.06f;
+			frame.offset = CL_Point(0, 0);
+
+			impl-&gt;frames.push_back(frame);
+		}
+	}
+	
+	restart();
+}
+
+CL_Sprite::CL_Sprite(const CL_Sprite &amp;sprite)
+: impl(0)
+{
+	if (sprite.impl)
+	{
+		impl = new CL_Sprite_Generic;
+		*impl = *sprite.impl;
+	
+		resource = sprite.resource;
+		resource.load();
+	}
+}
+
+CL_Sprite::CL_Sprite()
+: impl(0)
+{
+}
+
+CL_Sprite::~CL_Sprite()
+{
+	delete impl;
+	resource.unload();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Sprite attributes:
+
+float CL_Sprite::get_angle() const
+{
+	return impl-&gt;angle;
+}
+
+float CL_Sprite::get_angle_pitch() const
+{
+	return impl-&gt;angle_pitch;
+}
+
+float CL_Sprite::get_angle_yaw() const
+{
+	return impl-&gt;angle_yaw;
+}
+
+float CL_Sprite::get_base_angle() const
+{
+	return impl-&gt;base_angle;
+}
+
+void CL_Sprite::get_scale(float &amp;x, float &amp;y) const
+{
+	x = impl-&gt;scale_x;
+	y = impl-&gt;scale_y;
+}
+
+float CL_Sprite::get_alpha() const
+{
+	return impl-&gt;alpha;
+}
+
+void CL_Sprite::get_color(float &amp;red, float &amp;green, float &amp;blue, float &amp;alpha) const
+{
+	red = impl-&gt;red;
+	green = impl-&gt;green;
+	blue = impl-&gt;blue;
+	alpha = impl-&gt;alpha;
+}
+
+void CL_Sprite::get_blend_func(CL_BlendFunc &amp;src, CL_BlendFunc &amp;dest) const
+{
+	src  = impl-&gt;blend_src;
+	dest = impl-&gt;blend_dest;
+}
+
+void CL_Sprite::get_alignment(CL_Origin &amp;origin, int &amp;x, int &amp;y) const
+{
+	origin = impl-&gt;translation_origin;
+	x = impl-&gt;translation_hotspot.x;
+	y = impl-&gt;translation_hotspot.y;
+}
+
+void CL_Sprite::get_rotation_hotspot(CL_Origin &amp;origin, int &amp;x, int &amp;y) const
+{
+	origin = impl-&gt;rotation_origin;
+	x = impl-&gt;rotation_hotspot.x;
+	y = impl-&gt;rotation_hotspot.y;
+}
+
+int CL_Sprite::get_current_frame() const
+{
+	return impl-&gt;current_frame;
+}
+
+int CL_Sprite::get_frame_count() const
+{
+	if (!impl) return 0;
+	return impl-&gt;frames.size();
+}
+
+float CL_Sprite::get_frame_delay(int frameno) const
+{
+	CL_Sprite_Generic::SpriteFrame *frame = impl-&gt;get_frame(frameno);
+	if(frame)
+		return frame-&gt;delay;
+	else
+		return 0;
+}
+
+CL_Point CL_Sprite::get_frame_offset(int frameno) const
+{
+	CL_Sprite_Generic::SpriteFrame *frame = impl-&gt;get_frame(frameno);
+	if(frame)
+		return frame-&gt;offset;
+	else
+		return CL_Point(0, 0);
+}
+
+CL_Size CL_Sprite::get_frame_size(int frameno) const
+{
+	CL_Sprite_Generic::SpriteFrame *frame = impl-&gt;get_frame(frameno);
+	if(frame)
+		return CL_Size(frame-&gt;position.get_width(), frame-&gt;position.get_height());
+	else
+		return CL_Size(0, 0);
+}
+
+int CL_Sprite::get_width() const
+{
+	return impl-&gt;get_frame(impl-&gt;current_frame)-&gt;position.get_width();
+}
+
+int CL_Sprite::get_height() const
+{
+	return impl-&gt;get_frame(impl-&gt;current_frame)-&gt;position.get_height();
+}
+
+CL_Surface CL_Sprite::get_frame_surface(int frameno) const
+{
+	CL_Sprite_Generic::SpriteFrame *frame = impl-&gt;get_frame(frameno);
+	if (frame)
+		return frame-&gt;surface;
+	else
+		return CL_Surface();
+}
+
+CL_PixelBuffer CL_Sprite::get_frame_pixeldata(int frameno) const
+{
+	CL_Sprite_Generic::SpriteFrame *frame = impl-&gt;get_frame(frameno);
+	if (frame)
+	{
+		CL_PixelBuffer pb = frame-&gt;surface.get_pixeldata();
+		int w = get_width();
+		int h = get_height();
+		// Make sure dimensions are the same as this sprite.
+		// pb will always be larger than, or equal to the sprite's size
+		if (w != pb.get_width() || h != pb.get_height())
+		{
+			int p = pb.get_pitch();
+			int bytes_per_pixel = (pb.get_format().get_depth() + 7)/8;
+			CL_PixelBuffer new_pb(w, h, p, pb.get_format());
+			unsigned char *src_bytes = (unsigned char*) pb.get_data();
+			unsigned char *dest_bytes = (unsigned char*) new_pb.get_data();
+			for (int y = 0; y &lt; h; y++)
+				for (int x = 0; x &lt; w * bytes_per_pixel; x++)
+					dest_bytes[y * p + x] = src_bytes[y * p + x];
+			return new_pb;
+		}
+		else
+			return pb;
+	}
+	else
+		return CL_PixelBuffer();
+}
+
+int CL_Sprite::get_id() const
+{
+	return impl-&gt;id;
+}
+
+bool CL_Sprite::is_null() const
+{
+	return (impl == 0);
+}
+
+bool CL_Sprite::is_play_loop() const
+{
+	return impl-&gt;play_loop;
+}
+
+bool CL_Sprite::is_play_backward() const
+{
+	return impl-&gt;play_backward;
+}
+
+bool CL_Sprite::is_play_pingpong() const
+{
+	return impl-&gt;play_pingpong;
+}
+
+CL_Sprite::ShowOnFinish CL_Sprite::get_show_on_finish() const
+{
+	return impl-&gt;show_on_finish;
+}
+
+bool CL_Sprite::is_finished() const
+{
+	return impl-&gt;finished;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Sprite operations:
+
+CL_Sprite &amp;CL_Sprite::operator =(const CL_Sprite &amp;copy)
+{
+	resource.unload();
+	if (impl) delete impl;
+	impl = 0;
+	if (copy.impl)
+	{
+		impl = new CL_Sprite_Generic;
+		*impl = *copy.impl;
+	}
+	resource = copy.resource;
+	resource.load();
+	return *this;
+}
+
+CL_Sprite::operator bool() const
+{
+  return (impl != 0);
+}
+
+void CL_Sprite::set_image_data(const CL_Sprite &amp;image_source)
+{
+	if(!impl)
+		impl = new CL_Sprite_Generic;
+
+	impl-&gt;frames = image_source.impl-&gt;frames;
+
+	impl-&gt;id = image_source.get_id();
+	impl-&gt;play_loop = image_source.is_play_loop();
+	impl-&gt;play_backward = image_source.is_play_backward();
+	impl-&gt;play_pingpong = image_source.is_play_pingpong();
+	impl-&gt;base_angle = image_source.get_base_angle();
+
+	restart();
+}
+
+void CL_Sprite::draw(
+	float x,
+	float y,
+	CL_GraphicContext *gc)
+{
+	if(impl-&gt;finished == false || impl-&gt;show_on_finish != show_blank)
+	{
+		CL_Sprite_Generic::SpriteFrame &amp;frame = impl-&gt;frames[impl-&gt;current_frame];
+
+		if (gc == 0) gc = CL_Display::get_current_window()-&gt;get_gc();
+
+		static CL_Surface_DrawParams2 params2;
+		params2.srcX = frame.position.left;
+		params2.srcY = frame.position.top;
+		params2.srcWidth = frame.position.get_width();
+		params2.srcHeight = frame.position.get_height();
+		params2.destX = x;
+		params2.destY = y;
+		params2.destZ = 0.0;
+		params2.red = impl-&gt;red;
+		params2.green = impl-&gt;green;
+		params2.blue = impl-&gt;blue;
+		params2.alpha = impl-&gt;alpha;
+		params2.blend_src = impl-&gt;blend_src;
+		params2.blend_dest = impl-&gt;blend_dest;
+		params2.blendfunc_src_alpha  = impl-&gt;blendfunc_src_alpha;
+		params2.blendfunc_dest_alpha = impl-&gt;blendfunc_dest_alpha;
+		params2.scale_x = impl-&gt;scale_x;
+		params2.scale_y = impl-&gt;scale_y;
+		params2.translate_origin = impl-&gt;translation_origin;
+		params2.translate_x = impl-&gt;translation_hotspot.x + frame.offset.x;
+		params2.translate_y = impl-&gt;translation_hotspot.y + frame.offset.y;
+		params2.rotate_angle = impl-&gt;angle - impl-&gt;base_angle;
+		params2.rotate_pitch = impl-&gt;angle_pitch;
+		params2.rotate_yaw = impl-&gt;angle_yaw;
+		params2.rotate_origin = impl-&gt;rotation_origin;
+		params2.rotate_x = impl-&gt;rotation_hotspot.x + frame.offset.x;
+		params2.rotate_y = impl-&gt;rotation_hotspot.y + frame.offset.y;
+
+		frame.surface.draw(params2,
+                                   gc);
+	}
+}
+
+
+void CL_Sprite::draw_subpixel(
+					 float x,
+					 float y,
+					 CL_GraphicContext *gc)
+{
+	if(impl-&gt;finished == false || impl-&gt;show_on_finish != show_blank)
+	{
+		CL_Sprite_Generic::SpriteFrame &amp;frame = impl-&gt;frames[impl-&gt;current_frame];
+
+		if (gc == 0) gc = CL_Display::get_current_window()-&gt;get_gc();
+
+		static CL_Surface_DrawParams2 params2;
+		params2.srcX = frame.position.left;
+		params2.srcY = frame.position.top;
+		params2.srcWidth = frame.position.get_width();
+		params2.srcHeight = frame.position.get_height();
+		params2.destX = x;
+		params2.destY = y;
+		params2.destZ = 0.0;
+		params2.red = impl-&gt;red;
+		params2.green = impl-&gt;green;
+		params2.blue = impl-&gt;blue;
+		params2.alpha = impl-&gt;alpha;
+		params2.blend_src = impl-&gt;blend_src;
+		params2.blend_dest = impl-&gt;blend_dest;
+		params2.blendfunc_src_alpha  = impl-&gt;blendfunc_src_alpha;
+		params2.blendfunc_dest_alpha = impl-&gt;blendfunc_dest_alpha;
+		params2.scale_x = impl-&gt;scale_x;
+		params2.scale_y = impl-&gt;scale_y;
+		params2.translate_origin = impl-&gt;translation_origin;
+		params2.translate_x = impl-&gt;translation_hotspot.x + frame.offset.x;
+		params2.translate_y = impl-&gt;translation_hotspot.y + frame.offset.y;
+		params2.rotate_angle = impl-&gt;angle - impl-&gt;base_angle;
+		params2.rotate_pitch = impl-&gt;angle_pitch;
+		params2.rotate_yaw = impl-&gt;angle_yaw;
+		params2.rotate_origin = impl-&gt;rotation_origin;
+		params2.rotate_x = impl-&gt;rotation_hotspot.x + frame.offset.x;
+		params2.rotate_y = impl-&gt;rotation_hotspot.y + frame.offset.y;
+		params2.sub_pixel_accuracy = true;
+
+		frame.surface.draw(params2,
+			gc);
+	}
+}
+
+void CL_Sprite::draw(
+	const CL_Rect &amp;dest,
+	CL_GraphicContext *gc)
+{
+	if(impl-&gt;finished == false || impl-&gt;show_on_finish != show_blank)
+	{
+		CL_Sprite_Generic::SpriteFrame &amp;frame = impl-&gt;frames[impl-&gt;current_frame];
+		
+		if (gc == 0) gc = CL_Display::get_current_window()-&gt;get_gc();
+
+		static CL_Surface_DrawParams2 params2;
+		params2.srcX = frame.position.left;
+		params2.srcY = frame.position.top;
+		params2.srcWidth = frame.position.get_width();
+		params2.srcHeight = frame.position.get_height();
+		params2.destX = dest.left;
+		params2.destY = dest.top;
+		params2.destZ = 0.0;
+		params2.red = impl-&gt;red;
+		params2.green = impl-&gt;green;
+		params2.blue = impl-&gt;blue;
+		params2.alpha = impl-&gt;alpha;
+		params2.blend_src = impl-&gt;blend_src;
+		params2.blend_dest = impl-&gt;blend_dest;
+		params2.blendfunc_src_alpha  = impl-&gt;blendfunc_src_alpha;
+		params2.blendfunc_dest_alpha = impl-&gt;blendfunc_dest_alpha;
+		params2.scale_x = dest.get_width()/float(frame.position.get_width());
+		params2.scale_y = dest.get_height()/float(frame.position.get_height());
+		params2.translate_origin = impl-&gt;translation_origin;
+		params2.translate_x = impl-&gt;translation_hotspot.x + frame.offset.x;
+		params2.translate_y = impl-&gt;translation_hotspot.y + frame.offset.y;
+		params2.rotate_angle = impl-&gt;angle - impl-&gt;base_angle;
+		params2.rotate_pitch = impl-&gt;angle_pitch;
+		params2.rotate_yaw = impl-&gt;angle_yaw;
+		params2.rotate_origin = impl-&gt;rotation_origin;
+		params2.rotate_x = impl-&gt;rotation_hotspot.x + frame.offset.x;
+		params2.rotate_y = impl-&gt;rotation_hotspot.y + frame.offset.y;
+
+		frame.surface.draw(
+			params2,
+			gc);
+	}
+}
+
+void CL_Sprite::draw(
+					 const CL_Rectf &amp;dest,
+					 CL_GraphicContext *gc)
+{
+	if(impl-&gt;finished == false || impl-&gt;show_on_finish != show_blank)
+	{
+		CL_Sprite_Generic::SpriteFrame &amp;frame = impl-&gt;frames[impl-&gt;current_frame];
+
+		if (gc == 0) gc = CL_Display::get_current_window()-&gt;get_gc();
+
+		static CL_Surface_DrawParams2 params2;
+		params2.srcX = frame.position.left;
+		params2.srcY = frame.position.top;
+		params2.srcWidth = frame.position.get_width();
+		params2.srcHeight = frame.position.get_height();
+		params2.destX = dest.left;
+		params2.destY = dest.top;
+		params2.destZ = 0.0;
+		params2.red = impl-&gt;red;
+		params2.green = impl-&gt;green;
+		params2.blue = impl-&gt;blue;
+		params2.alpha = impl-&gt;alpha;
+		params2.blend_src = impl-&gt;blend_src;
+		params2.blend_dest = impl-&gt;blend_dest;
+		params2.blendfunc_src_alpha  = impl-&gt;blendfunc_src_alpha;
+		params2.blendfunc_dest_alpha = impl-&gt;blendfunc_dest_alpha;
+		params2.scale_x = dest.get_width()/float(frame.position.get_width());
+		params2.scale_y = dest.get_height()/float(frame.position.get_height());
+		params2.translate_origin = impl-&gt;translation_origin;
+		params2.translate_x = impl-&gt;translation_hotspot.x + frame.offset.x;
+		params2.translate_y = impl-&gt;translation_hotspot.y + frame.offset.y;
+		params2.rotate_angle = impl-&gt;angle - impl-&gt;base_angle;
+		params2.rotate_pitch = impl-&gt;angle_pitch;
+		params2.rotate_yaw = impl-&gt;angle_yaw;
+		params2.rotate_origin = impl-&gt;rotation_origin;
+		params2.rotate_x = impl-&gt;rotation_hotspot.x + frame.offset.x;
+		params2.rotate_y = impl-&gt;rotation_hotspot.y + frame.offset.y;
+		params2.sub_pixel_accuracy = true;
+
+		frame.surface.draw(
+			params2,
+			gc);
+	}
+}
+
+float CL_Sprite::update(float time_elapsed)
+{
+	if(time_elapsed == 0)
+		time_elapsed = impl-&gt;calc_time_elapsed();
+
+	int total_frames = impl-&gt;frames.size();
+	if(total_frames &lt; 2 || impl-&gt;finished)
+		return time_elapsed;
+
+	CL_Sprite_Generic::SpriteFrame *frame = &amp;impl-&gt;frames[impl-&gt;current_frame];
+
+	impl-&gt;update_time += time_elapsed;
+	while(impl-&gt;update_time &gt; frame-&gt;delay)
+	{
+		impl-&gt;update_time -= frame-&gt;delay;
+		impl-&gt;current_frame += impl-&gt;delta_frame;
+
+		// Beginning or end of loop ?
+		if(impl-&gt;current_frame &gt;= total_frames || impl-&gt;current_frame &lt; 0)
+		{
+			if(impl-&gt;play_loop == false)
+			{
+				int delta_frame = impl-&gt;play_backward ? -1 : 1;
+				if(delta_frame != impl-&gt;delta_frame || impl-&gt;play_pingpong == false)
+				{
+					finish();
+					return time_elapsed;
+				}
+			}
+				
+			if(impl-&gt;play_pingpong == true)
+			{
+				impl-&gt;delta_frame = -impl-&gt;delta_frame;	// Change direction
+				if(impl-&gt;delta_frame &gt; 0)
+					impl-&gt;current_frame = 1;
+				else
+					impl-&gt;current_frame = total_frames - 2;
+			}
+			else // Restart
+				impl-&gt;current_frame = impl-&gt;play_backward ? total_frames - 1 : 0;
+		}
+	}
+
+	return time_elapsed;
+}
+
+void CL_Sprite::set_angle(float angle)
+{
+	impl-&gt;angle = angle;
+
+	if (impl-&gt;angle &gt;= 0)
+		impl-&gt;angle = (float)fmod(impl-&gt;angle, 360.0f);
+	else
+		impl-&gt;angle = (float)fmod (impl-&gt;angle, 360.0f) + 360.0f;
+}
+
+void CL_Sprite::set_angle_pitch(float angle)
+{
+	impl-&gt;angle_pitch = angle;
+
+	if (impl-&gt;angle_pitch &gt;= 0)
+		impl-&gt;angle_pitch = (float)fmod(impl-&gt;angle_pitch, 360.0f);
+	else
+		impl-&gt;angle_pitch = (float)fmod (impl-&gt;angle_pitch, 360.0f) + 360.0f;
+}
+
+void CL_Sprite::set_angle_yaw(float angle)
+{
+	impl-&gt;angle_yaw = angle;
+
+	if (impl-&gt;angle_yaw &gt;= 0)
+		impl-&gt;angle_yaw = (float)fmod(impl-&gt;angle_yaw, 360.0f);
+	else
+		impl-&gt;angle_yaw = (float)fmod (impl-&gt;angle_yaw, 360.0f) + 360.0f;
+}
+
+void CL_Sprite::rotate(float angle)
+{
+	impl-&gt;angle += angle;
+
+	if (impl-&gt;angle &gt;= 0)
+		impl-&gt;angle = (float)fmod(impl-&gt;angle, 360.0f);
+	else
+		impl-&gt;angle = (float)fmod(impl-&gt;angle, 360.0f) + 360.0f;
+}
+
+void CL_Sprite::rotate_pitch(float angle)
+{
+	impl-&gt;angle_pitch += angle;
+
+	if (impl-&gt;angle_pitch &gt;= 0)
+		impl-&gt;angle_pitch = (float)fmod(impl-&gt;angle_pitch, 360.0f);
+	else
+		impl-&gt;angle_pitch = (float)fmod(impl-&gt;angle_pitch, 360.0f) + 360.0f;
+}
+
+void CL_Sprite::rotate_yaw(float angle)
+{
+	impl-&gt;angle_yaw += angle;
+
+	if (impl-&gt;angle_yaw &gt;= 0)
+		impl-&gt;angle_yaw = (float)fmod(impl-&gt;angle_yaw, 360.0f);
+	else
+		impl-&gt;angle_yaw = (float)fmod(impl-&gt;angle_yaw, 360.0f) + 360.0f;
+}
+
+void CL_Sprite::set_base_angle(float angle)
+{
+	impl-&gt;base_angle = angle;
+
+	while (impl-&gt;base_angle &lt; 0.0f)
+		impl-&gt;base_angle += 360.0f;
+	while (impl-&gt;base_angle &gt; 360.0f)
+		impl-&gt;base_angle -= 360.0f;
+}
+
+void CL_Sprite::set_scale(float x, float y)
+{
+	impl-&gt;scale_x = x;
+	impl-&gt;scale_y = y;
+}
+
+void CL_Sprite::set_alpha(float alpha)
+{
+	impl-&gt;alpha = alpha;
+}
+
+void CL_Sprite::set_color(float r, float g, float b, float a)
+{
+	impl-&gt;red = r;
+	impl-&gt;green = g;
+	impl-&gt;blue = b;
+	impl-&gt;alpha = a;
+}
+
+void CL_Sprite::set_blend_func(CL_BlendFunc src, CL_BlendFunc dest)
+{
+	impl-&gt;blend_src        = src;
+	impl-&gt;blend_dest       = dest;
+	impl-&gt;blendfunc_src_alpha  = src;
+	impl-&gt;blendfunc_dest_alpha = dest;
+}
+
+void CL_Sprite::set_blend_func_separate(CL_BlendFunc src, CL_BlendFunc dest, 
+                                        CL_BlendFunc src_alpha, CL_BlendFunc dest_alpha)
+{
+	impl-&gt;blend_src        = src;
+	impl-&gt;blend_dest       = dest;
+	impl-&gt;blendfunc_src_alpha  = src_alpha;
+	impl-&gt;blendfunc_dest_alpha = dest_alpha;
+}
+
+void CL_Sprite::set_alignment(CL_Origin origin, int x, int y)
+{
+	impl-&gt;translation_origin = origin;
+	impl-&gt;translation_hotspot.x = x;
+	impl-&gt;translation_hotspot.y = y;
+}
+
+void CL_Sprite::set_rotation_hotspot(CL_Origin origin, int x, int y)
+{
+	impl-&gt;rotation_origin = origin;
+	impl-&gt;rotation_hotspot.x = x;
+	impl-&gt;rotation_hotspot.y = y;
+}
+
+void CL_Sprite::set_frame(unsigned int frame)
+{
+	if(frame &lt; 0)
+		impl-&gt;current_frame = 0;
+	else if(frame &gt;= impl-&gt;frames.size())
+		impl-&gt;current_frame = impl-&gt;frames.size() - 1;
+	else
+		impl-&gt;current_frame = frame;
+}
+
+void CL_Sprite::set_frame_delay(int frameno, float delay)
+{
+	CL_Sprite_Generic::SpriteFrame *frame = impl-&gt;get_frame(frameno);
+	if(frame)
+		frame-&gt;delay = delay;
+}
+
+void CL_Sprite::set_frame_offset(int frameno, CL_Point offset)
+{
+	CL_Sprite_Generic::SpriteFrame *frame = impl-&gt;get_frame(frameno);
+	if(frame)
+		frame-&gt;offset = offset;
+}
+
+void CL_Sprite::set_id(int id)
+{
+	impl-&gt;id = id;
+}
+
+void CL_Sprite::finish()
+{
+	impl-&gt;finished = true;
+	if(impl-&gt;show_on_finish == CL_Sprite::show_first_frame)
+		impl-&gt;current_frame = 0;
+	else
+		impl-&gt;current_frame = impl-&gt;frames.size() - 1;
+
+	impl-&gt;sig_animation_finished();
+}
+
+void CL_Sprite::restart()
+{
+	impl-&gt;update_time = 0;
+	impl-&gt;last_time = 0;
+	impl-&gt;finished = false;
+	impl-&gt;current_frame = impl-&gt;play_backward ? impl-&gt;frames.size() - 1 : 0;
+	impl-&gt;delta_frame = impl-&gt;play_backward ? -1 : 1;
+}
+
+void CL_Sprite::set_play_loop(bool loop)
+{
+	impl-&gt;play_loop = loop;
+}
+
+void CL_Sprite::set_play_pingpong(bool pingpong)
+{
+	impl-&gt;play_pingpong = pingpong;
+}
+
+void CL_Sprite::set_play_backward(bool backward)
+{
+	impl-&gt;play_backward = backward;
+}
+
+void CL_Sprite::set_show_on_finish(CL_Sprite::ShowOnFinish show_on_finish)
+{
+	impl-&gt;show_on_finish = show_on_finish;
+}
+
+void CL_Sprite::add_frame(CL_Surface surface, const CL_Rect&amp; rect, float delay, CL_Point offset)
+{
+	if (!impl)
+		impl = new CL_Sprite_Generic;
+	
+	CL_Sprite_Generic::SpriteFrame frame;
+			
+	frame.surface  = surface;
+        if (rect == CL_Rect(0,0,0,0))
+          frame.position = CL_Rect(CL_Point(0, 0), CL_Size(surface.get_width(), surface.get_height()));
+        else
+          frame.position = rect;
+	frame.delay    = delay;
+	frame.offset   = offset;
+			
+	impl-&gt;frames.push_back(frame);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Sprite signals:
+
+CL_Signal_v0 &amp;CL_Sprite::sig_animation_finished()
+{
+	return impl-&gt;sig_animation_finished;
+}

Added: trunk/clanlib/Display/sprite_description.cpp
===================================================================
--- trunk/clanlib/Display/sprite_description.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/sprite_description.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,426 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/sprite_description.h&quot;
+#include &quot;API/Display/pixel_buffer.h&quot;
+#include &quot;API/Display/pixel_format.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;sprite_description_generic.h&quot;
+#include &quot;resourcedata_sprite_description.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_SpriteDescription construction:
+
+CL_SpriteDescription::CL_SpriteDescription(const std::string &amp;resource_id, CL_ResourceManager *resources)
+: impl(0)
+{
+	CL_Resource &amp;resource = resources-&gt;get_resource(resource_id);
+
+	CL_ResourceData_SpriteDescription *data =
+		(CL_ResourceData_SpriteDescription *) resource.get_data(&quot;sprite&quot;);
+
+	if (!data)
+		throw CL_Error(&quot;Resource '&quot; + resource_id + &quot;' is not of type 'sprite'&quot;);
+
+	CL_SpriteDescription desc = data-&gt;load_description();
+	impl = desc.impl;
+	impl-&gt;add_ref();
+}
+
+CL_SpriteDescription::CL_SpriteDescription()
+: impl(new CL_SpriteDescription_Generic)
+{
+	impl-&gt;add_ref();
+}
+
+CL_SpriteDescription::CL_SpriteDescription(const CL_SpriteDescription &amp;copy)
+: impl(copy.impl)
+{
+	impl-&gt;add_ref();
+}
+
+CL_SpriteDescription::~CL_SpriteDescription()
+{
+	if (impl-&gt;release_ref() == 0)
+	{
+		delete impl;
+	}
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_SpriteDescription attributes:
+
+const std::list&lt;CL_SpriteDescription::FramePair&gt; &amp;CL_SpriteDescription::get_frames() const
+{
+	return impl-&gt;frames;
+}
+
+int CL_SpriteDescription::get_surface_flag() const
+{
+	return impl-&gt;flag;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_SpriteDescription operations:
+
+CL_SpriteDescription &amp;CL_SpriteDescription::operator =(const CL_SpriteDescription &amp;copy)
+{
+	if (impl-&gt;release_ref() == 0)
+	{
+		delete impl;
+	}
+
+	impl = copy.impl;
+	impl-&gt;add_ref();
+
+	return *this;
+}
+
+void CL_SpriteDescription::set_surface_flag(int flag)
+{
+	impl-&gt;flag = flag;
+}
+
+void CL_SpriteDescription::add_frame(CL_PixelBuffer provider)
+{
+	provider.lock();
+	impl-&gt;frames.push_back(FramePair(provider, CL_Rect(0, 0, provider.get_width(), provider.get_height())));
+	provider.unlock();
+}
+
+void CL_SpriteDescription::add_gridclipped_frames(
+	CL_PixelBuffer provider,
+	int xpos, int ypos,
+	int width, int height,
+	int xarray, int yarray,
+	int array_skipframes,
+	int xspace, int yspace)
+{
+	// TODO: Check if positions are within bounds of provider
+	
+	int ystart = ypos;
+	for(int y = 0; y &lt; yarray; y++)
+	{
+		int xstart = xpos;
+		for(int x = 0; x &lt; xarray; x++)
+		{
+			if (y == yarray -1 &amp;&amp; x &gt;= xarray - array_skipframes)
+				break;
+
+			impl-&gt;frames.push_back(FramePair(provider, CL_Rect(xstart, ystart, xstart + width, ystart + height)));
+			xstart += width + xspace;
+		}
+		ystart += height + yspace;
+	}
+}
+
+void CL_SpriteDescription::add_alphaclipped_frames(CL_PixelBuffer provider, int xpos, int ypos, float trans_limit)
+{
+	provider.lock();
+
+	CL_PixelFormat format;
+	format.set_red_mask(0xff000000);
+	format.set_green_mask(0x00ff0000);
+	format.set_blue_mask(0x0000ff00);
+	format.set_alpha_mask(0x000000ff);
+	format.set_depth(32);
+	format.enable_colorkey(false);
+	
+	CL_PixelBuffer alpha_buffer(
+		provider.get_width(),
+		provider.get_height(),
+		provider.get_width()*4,
+		format);
+
+	provider.convert(alpha_buffer);
+	provider.unlock();
+
+	int begin=0;
+	bool prev_trans=true;
+
+	int alpha_width = alpha_buffer.get_width();
+	int alpha_height = alpha_buffer.get_height();
+	bool found_opaque = false;
+	bool found_trans = false;
+
+	int *opaque_row = new int[alpha_width];
+	memset(opaque_row, 0, alpha_width*sizeof(int));
+
+	int cut_top = 0;
+	int cut_bottom = alpha_height;
+		
+	alpha_buffer.lock();
+	char *data = (char *) alpha_buffer.get_data();
+		
+	for (int y=0; y &lt; alpha_height; y++)
+	{
+		bool opaque_line = false;
+		unsigned int *line = (unsigned int *) (data + alpha_buffer.get_pitch()*y);
+		for (int x=0; x &lt; alpha_width; x++)
+		{
+			if ((line[x] &amp; 255) &gt; trans_limit*255)
+			{
+				opaque_row[x] = 1;
+				opaque_line = true;
+				found_opaque = true;
+			}
+		}
+			
+		if (opaque_line == false) // cut something of top or bottom
+		{
+			if (found_opaque)
+			{
+				cut_bottom--;
+				found_trans = true;
+			}
+			else
+				cut_top ++;
+		}
+		else if (found_trans)
+		{
+			found_trans = false;
+			cut_bottom = alpha_height;
+		}
+	}
+	
+	alpha_buffer.unlock();
+
+	if (cut_top &gt;= cut_bottom)
+		throw CL_Error(&quot;Font image contained only alpha!&quot;);
+
+	for(int x=0; x &lt; alpha_width; x++)
+	{
+		if(opaque_row[x] &amp;&amp; prev_trans)
+		{
+			begin = x;
+			prev_trans = false;
+		}
+		else if (!opaque_row[x] &amp;&amp; !prev_trans)
+		{
+			impl-&gt;frames.push_back(
+				FramePair(provider, CL_Rect(begin, cut_top, x+1, cut_bottom)));
+
+			prev_trans = true;
+		}
+	}
+		
+	if (!prev_trans)
+	{
+		impl-&gt;frames.push_back(
+			FramePair(provider, CL_Rect(begin, cut_top, alpha_width, cut_bottom)));
+	}
+
+	delete[] opaque_row;
+}
+
+void CL_SpriteDescription::add_alphaclipped_frames_free(CL_PixelBuffer provider, int xpos, int ypos, float trans_limit)
+{
+	provider.lock();
+
+	CL_PixelFormat format;
+	format.set_red_mask(0xff000000);
+	format.set_green_mask(0x00ff0000);
+	format.set_blue_mask(0x0000ff00);
+	format.set_alpha_mask(0x000000ff);
+	format.set_depth(32);
+	format.enable_colorkey(false);
+
+	CL_PixelBuffer alpha_buffer(
+		provider.get_width(),
+		provider.get_height(),
+		provider.get_width()*4,
+		format);
+
+	provider.convert(alpha_buffer);
+	provider.unlock();
+
+	int width = alpha_buffer.get_width();
+	int height = alpha_buffer.get_height();
+
+	int *explored = new int[width*height];
+	memset(explored, 0, width*height*sizeof(int));
+
+	alpha_buffer.lock();
+	unsigned int *data = (unsigned int *) alpha_buffer.get_data();
+	int x1, y1, x2, y2;
+	bool more;
+
+	for (int y=ypos; y &lt; height; y++)
+	{
+		for (int x=xpos; x &lt; width; x++)
+		{
+			if (explored[y*width+x] == 1) continue;
+			explored[y*width+x] = 1;
+			if ((data[y*width+x] &amp; 255) &lt;= trans_limit*255) continue;
+			// initialize the bounding box to the current pixel
+			x1 = x2 = x;
+			y1 = y2 = y;
+			more = true;
+			while (more)
+			{
+				// assume that there are NO opaque pixels around the current 
+				// bounding box
+				more = false;
+				// scan under the current bounding box and see if there any 
+				// non-transparent pixels
+				for (int i = x1; i &lt;= x2; i++)
+				{
+					if (y2 + 1 &lt; height)
+					{
+						explored[(y2+1)*width+i] = 1;
+						if ((data[(y2+1)*width+i] &amp; 255) &gt; trans_limit*255)
+						{
+							more = true; 
+							y2 = y2 + 1;
+						}
+					}
+					// no need to check above the bounding box, becuase we are scanning
+					// from TOP to bottom, hence we will hit the first pixel from the 
+					// top and there won't be anything above it.
+// 					if (y1 - 1 &gt;= 0)
+// 					{
+// 						explored[(y1-1)*w+i] = 1;
+// 						if ((data[(y1-1)*w+i] &amp; 255) &gt; trans_limit*255)
+// 						{
+// 							more = true; 
+// 							y1 = y1 - 1;
+// 						}
+// 					}
+				}
+				// now scan the left and right sides of the current bounding box
+				for (int j = y1; j &lt;= y2; j++)
+				{
+					// scan the right side
+					if (x2 + 1 &lt; width)
+					{
+						explored[j*width + x2+1] = 1;
+						if ((data[j*width + x2+1] &amp; 255) &gt; trans_limit*255)
+						{
+							more = true; 
+							x2 = x2 + 1;
+						}
+					}
+					// scan the left side
+					if (x1 - 1 &gt;= 0)
+					{
+						explored[j*width + x1-1] = 1;
+						if ((data[j*width + x1-1] &amp; 255) &gt; trans_limit*255)
+						{
+							more = true; 
+							x1 = x1 - 1;
+						}
+					}
+				} // end scanning left&amp;right
+			} // end while (more)
+			// mark all pixels in the bounding box as being explored
+			for (int i = x1; i &lt;= x2; i++)
+				for (int j = y1; j &lt;= y2; j++)
+					explored[j*width+i] = 1;
+			impl-&gt;frames.push_back(
+				FramePair(provider, CL_Rect(x1, y1, x2, y2)));
+		} // end for (int x=xpos; x &lt; width; x++)
+	} // end for (int y=ypos; y &lt; height; y++)
+	alpha_buffer.unlock();
+
+	delete[] explored;
+}
+
+void CL_SpriteDescription::add_paletteclipped_frames(CL_PixelBuffer provider, int xpos, int ypos)
+{
+	provider.lock();
+
+	if (provider.get_format().get_depth() != 8)
+	{
+		provider.unlock();
+		throw CL_Error(&quot;Paletteclipped frames only works on PAL8 (256 colours) images.&quot;);
+	}
+		
+	unsigned char *surface_data = (unsigned char *) provider.get_data();
+
+	// Find height
+	int height;
+	for (height = ypos; height &lt; provider.get_height(); height++)
+	{
+		if (surface_data[height * provider.get_pitch() + xpos] == 255)
+		{
+			height -= ypos;
+			break;
+		}
+	}
+	
+	int org_x = xpos;
+	bool next_line = false;
+	bool found;
+	
+	do
+	{
+		// Find width
+		int width;
+		int provider_width = provider.get_width();
+		found = false;
+		for (width = xpos; width &lt; provider_width; width++)
+		{
+			if (surface_data[ypos * provider.get_pitch() + width] == 254)
+			{
+				found = true;
+				width -= xpos;
+				break;
+			}
+			else if (surface_data[ypos * provider.get_pitch() + width] == 253)
+			{
+				found = true;
+				width -= xpos;
+				next_line = true;
+				break;
+			}
+		}
+		
+		// Cut frame if found
+		if(found)
+		{
+			impl-&gt;frames.push_back(FramePair(provider, CL_Rect(xpos, ypos, xpos + width, ypos + height)));
+			
+			xpos += width + 1;
+
+			if (next_line)
+			{
+				xpos = org_x;
+				ypos += height + 1;
+				next_line = false;
+			}
+		}
+	} while(found);
+
+	provider.unlock();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_SpriteDescription implementation:

Added: trunk/clanlib/Display/sprite_description_generic.h
===================================================================
--- trunk/clanlib/Display/sprite_description_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/sprite_description_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,60 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_sprite_description_generic
+#define header_sprite_description_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Display/sprite_description.h&quot;
+
+class CL_SpriteDescription_Generic
+{
+//! Construction:
+public:
+	CL_SpriteDescription_Generic() : ref_count(0), flag(CL_Surface::flag_none) { return; }
+
+//! Attributes:
+public:
+	int ref_count;
+
+	int flag;
+
+	std::list&lt;CL_SpriteDescription::FramePair&gt; frames;
+
+//! Operations:
+public:
+	int add_ref() { return ++ref_count; }
+
+	int release_ref() { return --ref_count; }
+};
+
+#endif

Added: trunk/clanlib/Display/sprite_generic.cpp
===================================================================
--- trunk/clanlib/Display/sprite_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/sprite_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,139 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Core/System/system.h&quot;
+#include &quot;sprite_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Sprite_Generic construction:
+
+CL_Sprite_Generic::CL_Sprite_Generic() :
+	angle(0.0f),
+	angle_pitch(0.0f),
+	angle_yaw(0.0f),
+	base_angle(0.0f),
+	scale_x(1.0f),
+	scale_y(1.0f),
+	red(1.0f),
+	green(1.0f),
+	blue(1.0f),
+	alpha(1.0f),
+
+	blend_src           (blend_src_alpha),
+	blend_dest          (blend_one_minus_src_alpha),
+	blendfunc_src_alpha (blend_src_alpha),
+	blendfunc_dest_alpha(blend_one_minus_src_alpha),
+
+	translation_hotspot(0,0),
+	rotation_hotspot(0,0),
+	translation_origin(origin_top_left),
+	rotation_origin(origin_center),
+	current_frame(0),
+	delta_frame(1),
+	update_time(0),
+	last_time(0),
+	id(0),
+	finished(false),
+	play_loop(true),
+	play_backward(false),
+	play_pingpong(false),
+	show_on_finish(CL_Sprite::show_blank)
+{
+}
+
+CL_Sprite_Generic::~CL_Sprite_Generic()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Sprite_Generic attributes:
+
+CL_Sprite_Generic::SpriteFrame *CL_Sprite_Generic::get_frame(unsigned int index)
+{
+	if(index &gt;= 0 &amp;&amp; index &lt; frames.size())
+		return &amp;frames[index];
+	else
+		return NULL;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Sprite_Generic operations:
+
+CL_Sprite_Generic &amp;CL_Sprite_Generic::operator =(const CL_Sprite_Generic &amp;copy)
+{
+	angle = copy.angle;
+	angle_pitch = copy.angle_pitch;
+	angle_yaw = copy.angle_yaw;
+	base_angle = copy.base_angle;
+	scale_x = copy.scale_x;
+	scale_y = copy.scale_y;
+	red = copy.red;
+	green = copy.green;
+	blue = copy.blue;
+	alpha = copy.alpha;
+	blend_src  = copy.blend_src;
+	blend_dest = copy.blend_dest;
+	blendfunc_src_alpha  = copy.blendfunc_src_alpha;
+	blendfunc_dest_alpha = copy.blendfunc_dest_alpha;
+	translation_hotspot = copy.translation_hotspot;
+	rotation_hotspot = copy.rotation_hotspot;
+	translation_origin = copy.translation_origin;
+	rotation_origin = copy.rotation_origin;
+	current_frame = copy.current_frame;
+	delta_frame = copy.delta_frame;
+	update_time = copy.update_time;
+	last_time = copy.last_time;
+	id = copy.id;
+	finished = copy.finished;
+	play_loop = copy.play_loop;
+	play_backward = copy.play_backward;
+	play_pingpong = copy.play_pingpong;
+	show_on_finish = copy.show_on_finish;
+
+	frames = copy.frames;
+
+	return *this;
+}
+
+float CL_Sprite_Generic::calc_time_elapsed()
+{
+	// Calculate amount of time since last frame
+	float new_time = (float)CL_System::get_time();
+	if(last_time == 0)
+		last_time = new_time;
+
+	float delta_time = (new_time - last_time) / 1000.0f;
+	last_time = new_time;
+
+	return delta_time;
+}
+ 
+/////////////////////////////////////////////////////////////////////////////
+// CL_Sprite_Generic implementation:

Added: trunk/clanlib/Display/sprite_generic.h
===================================================================
--- trunk/clanlib/Display/sprite_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/sprite_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,119 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_sprite_generic
+#define header_sprite_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Display/surface.h&quot;
+#include &quot;API/Display/blend_func.h&quot;
+#include &quot;API/Core/Math/origin.h&quot;
+#include &quot;API/Display/sprite.h&quot;
+#include &quot;API/Core/Math/point.h&quot;
+#include &quot;API/Core/Math/rect.h&quot;
+
+#include &lt;vector&gt;
+
+class CL_Sprite_Generic
+{
+//! Construction:
+public:
+	CL_Sprite_Generic();
+
+	virtual ~CL_Sprite_Generic();
+
+public:
+	class SpriteFrame
+	{
+	public:
+		//: Image data
+		CL_Surface surface;
+
+		//: Position in surface that frame is located at.
+		CL_Rect position;
+
+		//: Draw offset 
+		CL_Point offset;
+
+		//: Animation delay
+		float delay;
+	};
+
+//! Attributes:
+public:
+	SpriteFrame *get_frame(unsigned int index);
+	
+	float angle, angle_pitch, angle_yaw;
+	float base_angle;
+	float scale_x, scale_y;
+
+	float red,green,blue,alpha;
+
+	CL_BlendFunc blend_src;
+	CL_BlendFunc blend_dest;
+	CL_BlendFunc blendfunc_src_alpha;
+	CL_BlendFunc blendfunc_dest_alpha;
+
+	CL_Point translation_hotspot;
+	CL_Point rotation_hotspot;
+	CL_Origin translation_origin;
+	CL_Origin rotation_origin;
+
+	short current_frame;
+	short delta_frame;
+
+	float update_time;
+	float last_time;
+
+	int id;
+	
+	bool finished;
+	bool play_loop;
+	bool play_backward;
+	bool play_pingpong;
+	CL_Sprite::ShowOnFinish show_on_finish;
+
+	std::vector&lt;SpriteFrame&gt; frames;
+
+//! Operations:
+public:
+	//: Copy assignment operator.
+	CL_Sprite_Generic &amp;operator =(const CL_Sprite_Generic &amp;copy);
+
+	float calc_time_elapsed();
+
+//! Signals:
+public:
+	CL_Signal_v0 sig_animation_finished;
+};
+
+#endif

Added: trunk/clanlib/Display/sprite_packer.cpp
===================================================================
--- trunk/clanlib/Display/sprite_packer.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/sprite_packer.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,163 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/sprite_description.h&quot;
+#include &quot;API/Display/sprite_packer.h&quot;
+#include &quot;API/Display/pixel_buffer.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/System/log.h&quot;
+#include &quot;sprite_packer_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_SpritePacker construction:
+
+CL_SpritePacker::CL_SpritePacker(const CL_SpriteDescription &amp;description)
+: impl(new CL_SpritePacker_Generic(description))
+{
+}
+
+CL_SpritePacker::~CL_SpritePacker()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_SpritePacker attributes:
+
+const std::vector&lt;CL_Size&gt; &amp;CL_SpritePacker::get_texture_sizes() const
+{
+	return impl-&gt;texture_sizes;
+}
+
+const std::list&lt;CL_SpritePacker::TexturePair&gt; &amp;CL_SpritePacker::get_frames() const
+{
+	return impl-&gt;packed_frames;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_SpritePacker operations:
+
+bool CL_SpritePacker::pack(int max_width, int max_height, int min_width, int min_height, int max_textures)
+{
+	// Fetch all frames from SpriteDescription.
+	std::list&lt;CL_SpriteDescription::FramePair&gt;::const_iterator it_frames;
+	const std::list&lt;CL_SpriteDescription::FramePair&gt; &amp;frames = impl-&gt;description.get_frames();
+
+	std::list&lt;TexturePair&gt;::iterator it_packed_frames;
+
+	// Make a new list with just as many elements as spritedescription.
+	// A texture index of -1 means the texture hasn't been packed yet.
+	for(int i = frames.size(); i &gt; 0; i--)
+		impl-&gt;packed_frames.push_back(TexturePair(-1, CL_Rect()));
+
+	// Initial values for texture-size
+	int width = min_width;
+	int height = min_height;
+	impl-&gt;texture_sizes.push_back(CL_Size(width, height));
+
+	CL_SpritePacker_Generic::Node root;
+	int current_texture = 0;
+	bool all_fit;
+	do
+	{
+		root.rect = CL_Rect(0, 0, width, height);
+		all_fit = true;
+		
+		// Pack all frames!
+		for(it_frames = frames.begin(), it_packed_frames = impl-&gt;packed_frames.begin();
+			it_frames != frames.end();
+			++it_frames, ++it_packed_frames)
+		{
+			if((*it_frames).second.get_width() &gt; max_width || (*it_frames).second.get_height() &gt; max_height)
+			{
+#ifdef _DEBUG
+				CL_Log::log(&quot;debug&quot;, &quot;Error: Trying to pack sprite larger than the maximum&quot;);
+				CL_Log::log(&quot;debug&quot;, &quot;Width: %1, Max Width %2&quot;, (*it_frames).second.get_width(), max_width);
+				CL_Log::log(&quot;debug&quot;, &quot;Height: %1, Max Height %2&quot;, (*it_frames).second.get_height(), max_height);
+#endif
+				return false;
+			}
+			
+			if((*it_packed_frames).first == -1)	// Frame not yet been packed.
+			{
+				CL_SpritePacker_Generic::Node *node = root.insert(*it_frames);
+
+				if(node)	// Frame was packed ok.
+				{
+					(*it_packed_frames).first = current_texture;
+					(*it_packed_frames).second = node-&gt;rect;
+				}
+				else	// Frame couldn't fit into current texture.
+					all_fit = false;
+			}
+		}
+		
+		if(all_fit == false)	// All textures didnt fit.
+		{
+			// A maximum texture-size ?
+			if((width == height &amp;&amp; (width * 2) &lt;= max_width) || (height * 2) &lt;= max_height)
+			{
+				if(width == height &amp;&amp; (width * 2) &lt;= max_width)
+					width *= 2;
+				else
+					height *= 2;
+
+				// Clear current texture.
+				for(it_packed_frames = impl-&gt;packed_frames.begin();
+					it_packed_frames != impl-&gt;packed_frames.end();
+					++it_packed_frames)
+				{
+					if((*it_packed_frames).first == current_texture)
+						(*it_packed_frames).first = -1;
+				}
+				
+				impl-&gt;texture_sizes[current_texture] = CL_Size(width, height);
+			}
+			else
+			{
+				current_texture++;
+
+				// Check if we still have textures available.
+				if(current_texture &gt;= max_textures &amp;&amp; max_textures != -1)
+					return false;
+
+				// Start a minimum size for next texture.
+				width = min_width;
+				height = min_height;
+
+				impl-&gt;texture_sizes.push_back(CL_Size(width, height));
+			}
+							
+			root.clear();
+		}
+	} while(all_fit == false);
+
+	return true;
+}

Added: trunk/clanlib/Display/sprite_packer_generic.cpp
===================================================================
--- trunk/clanlib/Display/sprite_packer_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/sprite_packer_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,137 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;API/Display/pixel_buffer.h&quot;
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;sprite_packer_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_SpritePacker_Generic construction:
+
+CL_SpritePacker_Generic::CL_SpritePacker_Generic(const CL_SpriteDescription &amp;desc)
+: description(desc)
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_SpritePacker_Generic::Node implementation:
+
+CL_SpritePacker_Generic::Node::Node()
+{
+	child[0] = NULL;
+	child[1] = NULL;
+
+	image = NULL;
+}
+
+CL_SpritePacker_Generic::Node::Node(const CL_Rect &amp;new_rect)
+{
+	rect = new_rect;
+
+	child[0] = NULL;
+	child[1] = NULL;
+
+	image = NULL;
+}
+
+CL_SpritePacker_Generic::Node::~Node()
+{
+	clear();
+}
+
+void CL_SpritePacker_Generic::Node::clear()
+{
+	if(child[0])
+	{
+		delete child[0];
+		child[0] = NULL;
+	}
+	if(child[1])
+	{
+		delete child[1];
+		child[1] = NULL;
+	}
+	image = NULL;
+}
+
+CL_SpritePacker_Generic::Node *CL_SpritePacker_Generic::Node::insert(CL_SpriteDescription::FramePair new_image)
+{
+	// If we're not a leaf
+	if(child[0] &amp;&amp; child[1])
+	{
+		// Try inserting into first child
+		Node *new_node = child[0]-&gt;insert(new_image);
+		if(new_node != NULL)
+			return new_node;
+        
+		// No room, insert into second
+		return child[1]-&gt;insert(new_image);
+	}
+	else
+	{
+		// If there's already a texture here, return
+		if (image)
+			return NULL;
+
+		int image_width  = new_image.second.get_width()  + 2;
+		int image_height = new_image.second.get_height() + 2;
+		
+		// If we're too small, return
+		if (image_width &gt; rect.get_width() || image_height &gt; rect.get_height())
+			return NULL;
+
+		// If we're just right, accept
+		if (image_width == rect.get_width() &amp;&amp; image_height == rect.get_height())
+		{
+			image      = new_image.first;
+			image_rect = new_image.second;
+			image_rect.right  += 2;
+			image_rect.bottom += 2;
+			return this;
+		}
+        
+		// Otherwise, decide which way to split
+		int dw = rect.get_width() - image_width;
+		int dh = rect.get_height() - image_height;
+        
+		if (dw &gt; dh)
+		{
+			child[0] = new Node(CL_Rect(rect.left, rect.top, rect.left + image_width, rect.bottom));
+			child[1] = new Node(CL_Rect(rect.left + image_width, rect.top, rect.right, rect.bottom));
+		}
+		else
+		{
+			child[0] = new Node(CL_Rect(rect.left, rect.top, rect.right, rect.top + image_height));
+			child[1] = new Node(CL_Rect(rect.left, rect.top + image_height, rect.right, rect.bottom));
+		}
+        
+		// Insert into first child we created
+		return child[0]-&gt;insert(new_image);
+	}
+}

Added: trunk/clanlib/Display/sprite_packer_generic.h
===================================================================
--- trunk/clanlib/Display/sprite_packer_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/sprite_packer_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,78 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_sprite_packer_generic
+#define header_sprite_packer_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/Math/size.h&quot;
+#include &quot;API/Core/Math/rect.h&quot;
+#include &quot;API/Display/sprite_description.h&quot;
+#include &quot;API/Display/surface.h&quot;
+#include &quot;API/Display/sprite_packer.h&quot;
+
+// Stuff to improve:
+// - Sort the textures after size before inserting - might do wonders
+
+class CL_SpritePacker_Generic
+{
+//! Construction:
+public:
+	CL_SpritePacker_Generic(const CL_SpriteDescription &amp;description);
+
+	class Node
+	{
+	public:
+		Node();
+		Node(const CL_Rect &amp;rect);
+		~Node();
+
+		Node *insert(CL_SpriteDescription::FramePair image);
+		void clear();
+		
+		Node *child[2];
+		CL_Rect rect;
+	    
+	    CL_PixelBuffer image;
+	    CL_Rect image_rect;
+	};
+
+//! Attributes:
+public:
+	const CL_SpriteDescription &description;
+
+	std::vector&lt;CL_Size&gt; texture_sizes;
+	std::list&lt;CL_SpritePacker::TexturePair&gt; packed_frames;
+};
+
+#endif
+

Added: trunk/clanlib/Display/surface.cpp
===================================================================
--- trunk/clanlib/Display/surface.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/surface.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,513 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Display/display_window.h&quot;
+#include &quot;API/Display/surface.h&quot;
+#include &quot;API/Display/graphic_context.h&quot;
+#include &quot;API/Display/Providers/provider_factory.h&quot;
+#include &quot;API/Display/pixel_buffer.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;surface_generic.h&quot;
+#include &quot;surface_target.h&quot;
+#include &quot;display_target.h&quot;
+#include &quot;resourcedata_surface.h&quot;
+#include &quot;graphic_context_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Surface construction:
+
+CL_Surface::CL_Surface()
+: impl(new CL_Surface_Generic(0))
+{
+	impl-&gt;add_ref();
+}
+
+CL_Surface::CL_Surface(
+	CL_PixelBuffer provider,
+	int flag)
+: impl(0)
+{
+	impl = new CL_Surface_Generic(
+		CL_DisplayTarget::current()-&gt;create_surface(provider, flag));
+
+	impl-&gt;add_ref();
+}
+
+CL_Surface::CL_Surface(
+	const std::string &amp;resource_id,
+	CL_ResourceManager *manager)
+: impl(0)
+{
+	resource = manager-&gt;get_resource(resource_id);
+
+	if (resource.get_type() != &quot;surface&quot; )
+		throw CL_Error(&quot;Resource '&quot; + resource_id + &quot;' is not of type 'surface'&quot;);
+
+	resource.load();
+
+	CL_ResourceData_Surface *data =
+		(CL_ResourceData_Surface *) resource.get_data(&quot;surface&quot;);
+
+	if (!data)
+		throw CL_Error(&quot;Resource '&quot; + resource_id + &quot;' is not of type 'surface'&quot;);
+
+	impl = data-&gt;get_surface().impl;
+	impl-&gt;add_ref();
+}
+
+CL_Surface::CL_Surface(const std::string &amp;filename, int flag)
+: impl(0)
+{
+	operator =(CL_Surface(CL_ProviderFactory::load(filename), flag));
+}
+
+CL_Surface::CL_Surface(const CL_Surface &amp;copy)
+: impl(copy.impl)
+{
+	impl-&gt;add_ref();
+	resource = copy.resource;
+	resource.load();
+}
+
+CL_Surface::~CL_Surface()
+{
+	if (impl) impl-&gt;release_ref();
+	resource.unload();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Surface attributes:
+
+int CL_Surface::get_width() const
+{
+	return impl-&gt;target-&gt;get_width();
+}
+	
+int CL_Surface::get_height() const
+{
+	return impl-&gt;target-&gt;get_height();
+}
+
+float CL_Surface::get_angle() const
+{
+	return impl-&gt;angle;
+}
+
+void CL_Surface::get_scale(float &amp;x, float &amp;y) const
+{
+	x = impl-&gt;scale_x;
+	y = impl-&gt;scale_y;
+}
+
+float CL_Surface::get_alpha() const
+{
+	return impl-&gt;alpha;
+}
+
+void CL_Surface::get_color(float &amp;red, float &amp;green, float &amp;blue, float &amp;alpha) const
+{
+	red = impl-&gt;red;
+	green = impl-&gt;green;
+	blue = impl-&gt;blue;
+	alpha = impl-&gt;alpha;
+}
+
+void CL_Surface::get_blend_func(CL_BlendFunc &amp;src, CL_BlendFunc &amp;dest) const
+{
+	src  = impl-&gt;blend_src;
+	dest = impl-&gt;blend_dest;
+}
+
+void CL_Surface::get_alignment(CL_Origin &amp;origin, int &amp;x, int &amp;y) const
+{
+	x = (int)impl-&gt;translation_hotspot.x;
+	y = (int)impl-&gt;translation_hotspot.y;
+	origin = impl-&gt;translation_origin;
+}
+
+void CL_Surface::get_rotation_hotspot(CL_Origin &amp;origin, int &amp;x, int &amp;y) const
+{
+	x = (int)impl-&gt;rotation_hotspot.x;
+	y = (int)impl-&gt;rotation_hotspot.y;
+	origin = impl-&gt;rotation_origin;
+}
+
+CL_PixelBuffer CL_Surface::get_pixeldata() const
+{
+	return impl-&gt;target-&gt;get_pixeldata();
+}
+	
+/////////////////////////////////////////////////////////////////////////////
+// CL_Surface operations:
+
+CL_Surface &amp;CL_Surface::operator =(const CL_Surface &amp;copy)
+{
+	if (&amp;copy == this)
+		return *this;
+	resource.unload();
+	if (impl) impl-&gt;release_ref();
+	impl = copy.impl;
+	if (impl) impl-&gt;add_ref();
+	resource = copy.resource;
+	resource.load();
+	return *this;
+}
+
+CL_Surface::operator bool() const
+{
+  return (impl-&gt;target != 0);
+}
+
+void CL_Surface::set_pixeldata(CL_PixelBuffer &amp;pixeldata)
+{
+	set_pixeldata(CL_Point(0,0), CL_Rect(0,0,pixeldata.get_width(),pixeldata.get_height()), pixeldata);
+}
+	
+void CL_Surface::set_pixeldata(int x, int y, CL_PixelBuffer &amp;pixeldata)
+{
+	set_pixeldata(CL_Point(x,y), CL_Rect(0,0,pixeldata.get_width(),pixeldata.get_height()), pixeldata);
+}
+	
+void CL_Surface::set_pixeldata(const CL_Point &amp;pos, CL_PixelBuffer &amp;pixeldata)
+{
+	set_pixeldata(pos, CL_Rect(0,0,pixeldata.get_width(),pixeldata.get_height()), pixeldata);
+}
+	
+void CL_Surface::set_pixeldata(const CL_Point &amp;pos, const CL_Rect &amp;src_rect, CL_PixelBuffer &amp;pixeldata)
+{
+	impl-&gt;target-&gt;set_pixeldata(pos, src_rect, pixeldata);
+}
+
+void CL_Surface::draw(
+	const CL_Surface_DrawParams1&amp; params1,
+	CL_GraphicContext *gc)
+{
+	if (gc == 0) gc = CL_Display::get_current_window()-&gt;get_gc();
+	impl-&gt;target-&gt;draw(
+		impl,
+		params1,
+		gc);
+}
+
+void CL_Surface::draw(
+	const CL_Surface_DrawParams2&amp; params2,
+	CL_GraphicContext *gc)
+{
+	if (gc == 0) gc = CL_Display::get_current_window()-&gt;get_gc();
+	impl-&gt;target-&gt;draw(
+		impl,
+		params2,
+		gc);
+}
+
+void CL_Surface::draw(
+	float x,
+	float y,
+	CL_GraphicContext *gc)
+{
+	static CL_Surface_DrawParams2 params2;
+	params2.srcX = 0;
+	params2.srcY = 0;
+	params2.srcWidth = impl-&gt;target-&gt;get_width();
+	params2.srcHeight = impl-&gt;target-&gt;get_height();
+	params2.destX = x;
+	params2.destY = y;
+	params2.destZ = 0.0;
+	params2.red = impl-&gt;red;
+	params2.green = impl-&gt;green;
+	params2.blue = impl-&gt;blue;
+	params2.alpha = impl-&gt;alpha;
+
+	params2.blend_src = impl-&gt;blend_src;
+	params2.blend_dest = impl-&gt;blend_dest;
+	params2.blendfunc_src_alpha = impl-&gt;blendfunc_src_alpha;
+	params2.blendfunc_dest_alpha = impl-&gt;blendfunc_dest_alpha;
+
+	params2.scale_x = impl-&gt;scale_x;
+	params2.scale_y = impl-&gt;scale_y;
+	params2.translate_origin = impl-&gt;translation_origin;
+	params2.translate_x = int(impl-&gt;translation_hotspot.x);
+	params2.translate_y = int(impl-&gt;translation_hotspot.y);
+	params2.rotate_angle = impl-&gt;angle;
+	params2.rotate_pitch = impl-&gt;angle_pitch;
+	params2.rotate_yaw = impl-&gt;angle_yaw;
+	params2.rotate_origin = impl-&gt;rotation_origin;
+	params2.rotate_x = int(impl-&gt;rotation_hotspot.x);
+	params2.rotate_y = int(impl-&gt;rotation_hotspot.y);
+
+	draw(params2, gc);
+}
+
+void CL_Surface::draw(
+	const CL_Rect &amp;dest,
+	CL_GraphicContext *gc)
+{
+	static CL_Surface_DrawParams2 params2;
+	params2.srcX = 0;
+	params2.srcY = 0;
+	params2.srcWidth = impl-&gt;target-&gt;get_width();
+	params2.srcHeight = impl-&gt;target-&gt;get_height();
+	params2.destX = dest.left;
+	params2.destY = dest.top;
+	params2.destZ = 0.0;
+	params2.red = impl-&gt;red;
+	params2.green = impl-&gt;green;
+	params2.blue = impl-&gt;blue;
+	params2.alpha = impl-&gt;alpha;
+
+	params2.blend_src = impl-&gt;blend_src;
+	params2.blend_dest = impl-&gt;blend_dest;
+	params2.blendfunc_src_alpha = impl-&gt;blendfunc_src_alpha;
+	params2.blendfunc_dest_alpha = impl-&gt;blendfunc_dest_alpha;
+
+	params2.scale_x = dest.get_width()/float(impl-&gt;target-&gt;get_width());
+	params2.scale_y = dest.get_height()/float(impl-&gt;target-&gt;get_height());
+	params2.translate_origin = impl-&gt;translation_origin;
+	params2.translate_x = int(impl-&gt;translation_hotspot.x);
+	params2.translate_y = int(impl-&gt;translation_hotspot.y);
+	params2.rotate_angle = impl-&gt;angle;
+	params2.rotate_pitch = impl-&gt;angle_pitch;
+	params2.rotate_yaw = impl-&gt;angle_yaw;
+	params2.rotate_origin = impl-&gt;rotation_origin;
+	params2.rotate_x = int(impl-&gt;rotation_hotspot.x);
+	params2.rotate_y = int(impl-&gt;rotation_hotspot.y);
+
+	draw(params2, gc);
+}
+
+void CL_Surface::draw(
+	const CL_Rect &amp;src,
+	const CL_Rect &amp;dest,
+	CL_GraphicContext *gc)
+{
+	static CL_Surface_DrawParams2 params2;
+	params2.srcX = src.left;
+	params2.srcY = src.top;
+	params2.srcWidth = src.get_width();
+	params2.srcHeight = src.get_height();
+	params2.destX = dest.left;
+	params2.destY = dest.top;
+	params2.destZ = 0.0;
+	params2.red = impl-&gt;red;
+	params2.green = impl-&gt;green;
+	params2.blue = impl-&gt;blue;
+	params2.alpha = impl-&gt;alpha;
+
+	params2.blend_src = impl-&gt;blend_src;
+	params2.blend_dest = impl-&gt;blend_dest;
+	params2.blendfunc_src_alpha = impl-&gt;blendfunc_src_alpha;
+	params2.blendfunc_dest_alpha = impl-&gt;blendfunc_dest_alpha;
+
+	params2.scale_x = dest.get_width()/float(src.get_width());
+	params2.scale_y = dest.get_height()/float(src.get_height());
+	params2.translate_origin = impl-&gt;translation_origin;
+	params2.translate_x = int(impl-&gt;translation_hotspot.x);
+	params2.translate_y = int(impl-&gt;translation_hotspot.y);
+	params2.rotate_angle = impl-&gt;angle;
+	params2.rotate_pitch = impl-&gt;angle_pitch;
+	params2.rotate_yaw = impl-&gt;angle_yaw;
+	params2.rotate_origin = impl-&gt;rotation_origin;
+	params2.rotate_x = int(impl-&gt;rotation_hotspot.x);
+	params2.rotate_y = int(impl-&gt;rotation_hotspot.y);
+	
+	draw(params2, gc);
+}
+
+void CL_Surface::draw(
+					  const CL_Rectf &amp;src,
+					  const CL_Rectf &amp;dest,
+					  CL_GraphicContext *gc)
+{
+	static CL_Surface_DrawParams2 params2;
+	params2.srcX = int(src.left);
+	params2.srcY = int(src.top);
+	params2.srcWidth = int(src.get_width());
+	params2.srcHeight = int(src.get_height());
+	params2.destX = dest.left;
+	params2.destY = dest.top;
+	params2.destZ = 0.0;
+	params2.red = impl-&gt;red;
+	params2.green = impl-&gt;green;
+	params2.blue = impl-&gt;blue;
+	params2.alpha = impl-&gt;alpha;
+
+	params2.blend_src = impl-&gt;blend_src;
+	params2.blend_dest = impl-&gt;blend_dest;
+	params2.blendfunc_src_alpha = impl-&gt;blendfunc_src_alpha;
+	params2.blendfunc_dest_alpha = impl-&gt;blendfunc_dest_alpha;
+
+	params2.scale_x = dest.get_width()/float(src.get_width());
+	params2.scale_y = dest.get_height()/float(src.get_height());
+	params2.translate_origin = impl-&gt;translation_origin;
+	params2.translate_x = int(impl-&gt;translation_hotspot.x);
+	params2.translate_y = int(impl-&gt;translation_hotspot.y);
+	params2.rotate_angle = impl-&gt;angle;
+	params2.rotate_pitch = impl-&gt;angle_pitch;
+	params2.rotate_yaw = impl-&gt;angle_yaw;
+	params2.rotate_origin = impl-&gt;rotation_origin;
+	params2.rotate_x = int(impl-&gt;rotation_hotspot.x);
+	params2.rotate_y = int(impl-&gt;rotation_hotspot.y);
+	params2.sub_pixel_accuracy = true;
+
+	draw(params2, gc);
+}
+
+void CL_Surface::set_angle(float angle)
+{
+	impl = impl-&gt;copy_on_write();
+	impl-&gt;angle = angle;
+
+	while(impl-&gt;angle &gt;= 360.0f)
+		impl-&gt;angle -= 360.0f;
+	while(impl-&gt;angle &lt; 0.0f)
+		impl-&gt;angle += 360.0f;
+}
+
+void CL_Surface::set_angle_pitch(float angle)
+{
+	impl = impl-&gt;copy_on_write();
+	impl-&gt;angle_pitch = angle;
+
+	while(impl-&gt;angle_pitch &gt;= 360.0f)
+		impl-&gt;angle_pitch -= 360.0f;
+	while(impl-&gt;angle_pitch &lt; 0.0f)
+		impl-&gt;angle_pitch += 360.0f;
+}
+
+void CL_Surface::set_angle_yaw(float angle)
+{
+	impl = impl-&gt;copy_on_write();
+	impl-&gt;angle_yaw = angle;
+
+	while(impl-&gt;angle_yaw &gt;= 360.0f)
+		impl-&gt;angle_yaw -= 360.0f;
+	while(impl-&gt;angle_yaw &lt; 0.0f)
+		impl-&gt;angle_yaw += 360.0f;
+}
+
+void CL_Surface::rotate(float angle)
+{
+	impl = impl-&gt;copy_on_write();
+	impl-&gt;angle += angle;
+
+	while(impl-&gt;angle &gt;= 360.0f)
+		impl-&gt;angle -= 360.0f;
+	while(impl-&gt;angle &lt; 0.0f)
+		impl-&gt;angle += 360.0f;
+}
+
+void CL_Surface::rotate_pitch(float angle)
+{
+	impl = impl-&gt;copy_on_write();
+	impl-&gt;angle_pitch += angle;
+
+	while(impl-&gt;angle_pitch &gt;= 360.0f)
+		impl-&gt;angle_pitch -= 360.0f;
+	while(impl-&gt;angle_pitch &lt; 0.0f)
+		impl-&gt;angle_pitch += 360.0f;
+}
+
+void CL_Surface::rotate_yaw(float angle)
+{
+	impl = impl-&gt;copy_on_write();
+	impl-&gt;angle_yaw += angle;
+
+	while(impl-&gt;angle_yaw &gt;= 360.0f)
+		impl-&gt;angle_yaw -= 360.0f;
+	while(impl-&gt;angle_yaw &lt; 0.0f)
+		impl-&gt;angle_yaw += 360.0f;
+}
+
+void CL_Surface::set_scale(float x, float y)
+{
+	impl = impl-&gt;copy_on_write();
+	impl-&gt;scale_x = x;
+	impl-&gt;scale_y = y;
+}
+
+void CL_Surface::set_alpha(float alpha)
+{
+	impl = impl-&gt;copy_on_write();
+	impl-&gt;alpha = alpha;
+}
+
+void CL_Surface::set_color(float r, float g, float b, float a)
+{
+	impl = impl-&gt;copy_on_write();
+	impl-&gt;red   = r;
+	impl-&gt;green = g;
+	impl-&gt;blue  = b;
+	impl-&gt;alpha = a;
+}
+
+void CL_Surface::set_blend_func_separate(CL_BlendFunc src, CL_BlendFunc dest,
+													  CL_BlendFunc src_alpha, CL_BlendFunc dest_alpha)
+{
+	impl = impl-&gt;copy_on_write();
+	impl-&gt;blend_src        = src;
+	impl-&gt;blend_dest       = dest; 
+	impl-&gt;blendfunc_src_alpha  = src_alpha;
+	impl-&gt;blendfunc_dest_alpha = dest_alpha; 
+}
+
+void CL_Surface::set_blend_func(CL_BlendFunc src, CL_BlendFunc dest)
+{
+	impl = impl-&gt;copy_on_write();
+	impl-&gt;blend_src        = src;
+	impl-&gt;blend_dest       = dest;
+	impl-&gt;blendfunc_src_alpha  = src;
+	impl-&gt;blendfunc_dest_alpha = dest;	
+}
+
+void CL_Surface::set_alignment(CL_Origin origin, int x, int y)
+{
+	impl = impl-&gt;copy_on_write();
+	impl-&gt;translation_hotspot.x = (float)x;
+	impl-&gt;translation_hotspot.y = (float)y;
+	impl-&gt;translation_origin = origin;
+}
+
+void CL_Surface::set_rotation_hotspot(CL_Origin origin, int x, int y)
+{
+	impl = impl-&gt;copy_on_write();
+	impl-&gt;rotation_hotspot.x = (float)x;
+	impl-&gt;rotation_hotspot.y = (float)y;
+	impl-&gt;rotation_origin = origin;
+}
+
+int CL_Surface::get_handle()
+{
+	return impl-&gt;target-&gt;get_handle();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Surface implementation:

Added: trunk/clanlib/Display/surface_generic.cpp
===================================================================
--- trunk/clanlib/Display/surface_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/surface_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,122 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;surface_generic.h&quot;
+#include &quot;surface_target.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Surface_Generic construction:
+
+CL_Surface_Generic::CL_Surface_Generic(CL_Surface_Target *target) :
+	target(target),
+	angle(0.0f),
+	angle_pitch(0.0f),
+	angle_yaw(0.0f),
+	scale_x(1.0f),
+	scale_y(1.0f),
+	red(1.0f),
+	green(1.0f),
+	blue(1.0f),
+	alpha(1.0f),
+	blend_src(blend_src_alpha),
+	blend_dest(blend_one_minus_src_alpha),
+	blendfunc_src_alpha (blend_src_alpha),
+	blendfunc_dest_alpha(blend_one_minus_src_alpha),
+	translation_hotspot(0,0),
+	rotation_hotspot(0,0),
+	translation_origin(origin_top_left),
+	rotation_origin(origin_center),
+	ref_count(0)
+{
+	if (target) target-&gt;add_ref();
+}	
+
+CL_Surface_Generic::~CL_Surface_Generic()
+{
+	if (target) target-&gt;release_ref();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Surface_Generic attributes:
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Surface_Generic operations:
+
+CL_Surface_Generic &amp;CL_Surface_Generic::operator =(const CL_Surface_Generic &amp;copy)
+{
+	if (target) target-&gt;release_ref();
+	target = copy.target;
+	angle = copy.angle;
+	angle_pitch = copy.angle_pitch;
+	angle_yaw = copy.angle_yaw;
+	scale_x = copy.scale_x;
+	scale_y = copy.scale_y;
+	alpha   = copy.alpha;
+
+	blend_src        = copy.blend_src;
+	blend_dest       = copy.blend_dest;
+	blendfunc_src_alpha  = copy.blendfunc_src_alpha;
+	blendfunc_dest_alpha = copy.blendfunc_dest_alpha;
+
+	translation_hotspot = copy.translation_hotspot;
+	rotation_hotspot    = copy.rotation_hotspot;
+	translation_origin  = copy.translation_origin;
+	rotation_origin     = copy.rotation_origin;
+
+	if (target) target-&gt;add_ref();
+
+	return *this;
+}
+
+CL_Surface_Generic *CL_Surface_Generic::copy_on_write()
+{
+	if (ref_count == 1) return this;
+
+	CL_Surface_Generic *copy = new CL_Surface_Generic(0);
+	*copy = *this;
+	copy-&gt;add_ref();
+	release_ref();
+	return copy;
+}
+
+void CL_Surface_Generic::release_ref()
+{
+	ref_count--;
+	if (ref_count == 0) delete this;
+}
+
+void CL_Surface_Generic::add_ref()
+{
+	ref_count++;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Surface_Generic implementation:

Added: trunk/clanlib/Display/surface_generic.h
===================================================================
--- trunk/clanlib/Display/surface_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/surface_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,94 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_surface_generic
+#define header_surface_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/Math/origin.h&quot;
+#include &quot;API/Display/blend_func.h&quot;
+#include &quot;API/Core/Math/point.h&quot;
+
+class CL_Surface_Target;
+
+class CL_Surface_Generic
+{
+//! Construction:
+public:
+	CL_Surface_Generic(CL_Surface_Target *target);
+
+	virtual ~CL_Surface_Generic();
+
+//! Attributes:
+public:
+	//: Shared data object between surfaces.
+	CL_Surface_Target *target;
+
+	float angle, angle_pitch, angle_yaw;
+
+	float scale_x, scale_y;
+
+	float red, green, blue, alpha;
+
+	CL_BlendFunc blend_src;
+	
+	CL_BlendFunc blend_dest;
+
+	CL_BlendFunc blendfunc_src_alpha;
+	
+	CL_BlendFunc blendfunc_dest_alpha;
+
+	CL_Pointf translation_hotspot;
+
+	CL_Pointf rotation_hotspot;
+
+	CL_Origin translation_origin;
+
+	CL_Origin rotation_origin;
+
+//! Operations:
+public:
+	//: Copy assignment operator.
+	CL_Surface_Generic &amp;operator =(const CL_Surface_Generic &amp;copy);
+
+	CL_Surface_Generic *copy_on_write();
+
+	void release_ref();
+
+	void add_ref();
+
+//! Implementation:
+private:
+	int ref_count;
+};
+
+#endif

Added: trunk/clanlib/Display/surface_target.cpp
===================================================================
--- trunk/clanlib/Display/surface_target.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/surface_target.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,272 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;surface_target.h&quot;
+#include &quot;API/Display/surface.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Surface_Target construction:
+
+CL_Surface_Target::CL_Surface_Target()
+: ref_count(0)
+{
+}
+
+CL_Surface_Target::~CL_Surface_Target()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Surface_Target attributes:
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Surface_Target operations:
+
+void CL_Surface_Target::draw(
+	CL_Surface_Generic *attributes,
+	const CL_Surface_DrawParams2&amp; params2,
+	CL_GraphicContext *context)
+{
+	static CL_Surface_TargetDrawParams1 t_params1;
+
+	// Find size of surface:
+	float size_width  = (float) params2.srcWidth;
+	float size_height = (float) params2.srcHeight;
+
+	// Calculate translation hotspot
+	CL_Pointf translation_hotspot = calc_hotspot(
+		params2.translate_origin,
+		(float) params2.translate_x,
+		(float) params2.translate_y,
+		size_width,
+		size_height);
+
+	// Calculate rotation hotspot:
+	t_params1.rotation_hotspot = calc_hotspot(
+		params2.rotate_origin,
+		(float) params2.rotate_x,
+		(float) params2.rotate_y,
+		size_width,
+		size_height);
+
+	if (!params2.sub_pixel_accuracy)
+	{
+		// Avoid linear smoothing:
+		translation_hotspot.x = float(int(translation_hotspot.x));
+		translation_hotspot.y = float(int(translation_hotspot.y));
+		t_params1.rotation_hotspot.x = float(int(t_params1.rotation_hotspot.x));
+		t_params1.rotation_hotspot.y = float(int(t_params1.rotation_hotspot.y));
+	}
+
+	// Find top left point of destination rectangle and map rotation hotspot to screen coordinates:
+	if (params2.scale_x == 1.0 &amp;&amp; params2.scale_y == 1.0)
+	{
+		t_params1.destWidth = params2.srcWidth;
+		t_params1.destHeight = params2.srcHeight;
+		t_params1.pixDestX = params2.destX-translation_hotspot.x;
+		t_params1.pixDestY = params2.destY-translation_hotspot.y;
+		t_params1.rotation_hotspot.x += float(t_params1.pixDestX);
+		t_params1.rotation_hotspot.y += float(t_params1.pixDestY);
+	}
+	else
+	{
+		t_params1.destWidth = params2.srcWidth * params2.scale_x;
+		t_params1.destHeight = params2.srcHeight * params2.scale_y;
+		t_params1.pixDestX = params2.destX-translation_hotspot.x * params2.scale_x;
+		t_params1.pixDestY = params2.destY-translation_hotspot.y * params2.scale_y;
+		t_params1.rotation_hotspot.x = float(t_params1.pixDestX + t_params1.rotation_hotspot.x * params2.scale_x);
+		t_params1.rotation_hotspot.y = float(t_params1.pixDestY + t_params1.rotation_hotspot.y * params2.scale_y);
+	}
+
+	draw(
+		attributes,
+		params2,
+		&amp;t_params1,
+		context);
+}
+
+void CL_Surface_Target::draw(
+	CL_Surface_Generic *attributes,
+	const CL_Surface_DrawParams2&amp; params2,
+	CL_Surface_TargetDrawParams1 *t_params1,
+	CL_GraphicContext *context)
+{
+	static CL_Surface_DrawParams1 params1;
+
+	// Calculate unit vectors for rotated surface:
+	// (cached for speed reasons)
+	static double vect_rotate_x[2] = { 1.0, 0.0 };
+	static double vect_rotate_y[2] = { 0.0, 1.0 };
+	static double last_angle = 0.0;
+
+	if (last_angle != params2.rotate_angle)
+	{
+		if (params2.rotate_angle == 0.0)
+		{
+			vect_rotate_x[0] = 1.0;
+			vect_rotate_x[1] = 0.0;
+			vect_rotate_y[0] = 0.0;
+			vect_rotate_y[1] = 1.0;
+		}
+		else if (params2.rotate_angle == 90.0)
+		{
+			vect_rotate_x[0] = 0.0;
+			vect_rotate_x[1] = 1.0;
+			vect_rotate_y[0] = -1.0;
+			vect_rotate_y[1] = 0.0;
+		}
+		else if (params2.rotate_angle == 180.0)
+		{
+			vect_rotate_x[0] = -1.0;
+			vect_rotate_x[1] = 0.0;
+			vect_rotate_y[0] = 0.0;
+			vect_rotate_y[1] = -1.0;
+		}
+		else if (params2.rotate_angle == 270.0)
+		{
+			vect_rotate_x[0] = 0.0;
+			vect_rotate_x[1] = -1.0;
+			vect_rotate_y[0] = 1.0;
+			vect_rotate_y[1] = 0.0;
+		}
+		else
+		{
+			double angle_rad = 3.1415926f*params2.rotate_angle/180;
+			vect_rotate_x[0] = cos(angle_rad);
+			vect_rotate_x[1] = sin(angle_rad);
+			vect_rotate_y[0] = cos(3.1415926f/2+angle_rad);
+			vect_rotate_y[1] = sin(3.1415926f/2+angle_rad);
+		}
+	}
+
+	// Calculate final source rectangle points for render:
+
+	params1.srcX[0] = params2.srcX;
+	params1.srcY[0] = params2.srcY;
+	params1.srcX[1] = params2.srcX+params2.srcWidth;
+	params1.srcY[1] = params2.srcY;
+	params1.srcX[2] = params2.srcX+params2.srcWidth;
+	params1.srcY[2] = params2.srcY+params2.srcHeight;
+	params1.srcX[3] = params2.srcX;
+	params1.srcY[3] = params2.srcY+params2.srcHeight;
+
+	// Calculate final destination rectangle points for surface rectangle:
+
+	if (params2.rotate_angle == 0.0)
+	{
+		params1.destX[0] = t_params1-&gt;pixDestX;
+		params1.destY[0] = t_params1-&gt;pixDestY;
+		params1.destX[1] = t_params1-&gt;pixDestX+t_params1-&gt;destWidth;
+		params1.destY[1] = t_params1-&gt;pixDestY;
+		params1.destX[2] = t_params1-&gt;pixDestX+t_params1-&gt;destWidth;
+		params1.destY[2] = t_params1-&gt;pixDestY+t_params1-&gt;destHeight;
+		params1.destX[3] = t_params1-&gt;pixDestX;
+		params1.destY[3] = t_params1-&gt;pixDestY+t_params1-&gt;destHeight;
+	}
+	else
+	{
+		// roll
+		params1.destX[0] = calc_rotate_x(t_params1-&gt;pixDestX, t_params1-&gt;pixDestY, t_params1-&gt;rotation_hotspot.x, t_params1-&gt;rotation_hotspot.y, vect_rotate_x[0], vect_rotate_y[0]);
+		params1.destY[0] = calc_rotate_y(t_params1-&gt;pixDestX, t_params1-&gt;pixDestY, t_params1-&gt;rotation_hotspot.x, t_params1-&gt;rotation_hotspot.y, vect_rotate_x[1], vect_rotate_y[1]);
+		params1.destX[1] = calc_rotate_x(t_params1-&gt;pixDestX+t_params1-&gt;destWidth, t_params1-&gt;pixDestY, t_params1-&gt;rotation_hotspot.x, t_params1-&gt;rotation_hotspot.y, vect_rotate_x[0], vect_rotate_y[0]);
+		params1.destY[1] = calc_rotate_y(t_params1-&gt;pixDestX+t_params1-&gt;destWidth, t_params1-&gt;pixDestY, t_params1-&gt;rotation_hotspot.x, t_params1-&gt;rotation_hotspot.y, vect_rotate_x[1], vect_rotate_y[1]);
+		params1.destX[2] = calc_rotate_x(t_params1-&gt;pixDestX+t_params1-&gt;destWidth, t_params1-&gt;pixDestY+t_params1-&gt;destHeight, t_params1-&gt;rotation_hotspot.x, t_params1-&gt;rotation_hotspot.y, vect_rotate_x[0], vect_rotate_y[0]);
+		params1.destY[2] = calc_rotate_y(t_params1-&gt;pixDestX+t_params1-&gt;destWidth, t_params1-&gt;pixDestY+t_params1-&gt;destHeight, t_params1-&gt;rotation_hotspot.x, t_params1-&gt;rotation_hotspot.y, vect_rotate_x[1], vect_rotate_y[1]);
+		params1.destX[3] = calc_rotate_x(t_params1-&gt;pixDestX, t_params1-&gt;pixDestY+t_params1-&gt;destHeight, t_params1-&gt;rotation_hotspot.x, t_params1-&gt;rotation_hotspot.y, vect_rotate_x[0], vect_rotate_y[0]);
+		params1.destY[3] = calc_rotate_y(t_params1-&gt;pixDestX, t_params1-&gt;pixDestY+t_params1-&gt;destHeight, t_params1-&gt;rotation_hotspot.x, t_params1-&gt;rotation_hotspot.y, vect_rotate_x[1], vect_rotate_y[1]);
+	}
+	
+	// pitch
+	if (params2.rotate_pitch != 0.0)
+	{
+		double pitch_rad = sin(3.1415926f/2 + (3.1415926f*params2.rotate_pitch/180));
+		params1.destY[0] = (params1.destY[0] - t_params1-&gt;rotation_hotspot.y) * pitch_rad + t_params1-&gt;rotation_hotspot.y;
+		params1.destY[1] = (params1.destY[1] - t_params1-&gt;rotation_hotspot.y) * pitch_rad + t_params1-&gt;rotation_hotspot.y;
+		params1.destY[2] = (params1.destY[2] - t_params1-&gt;rotation_hotspot.y) * pitch_rad + t_params1-&gt;rotation_hotspot.y;
+		params1.destY[3] = (params1.destY[3] - t_params1-&gt;rotation_hotspot.y) * pitch_rad + t_params1-&gt;rotation_hotspot.y;
+	}
+	// yaw
+	if (params2.rotate_yaw != 0.0)
+	{
+		double yaw_rad = cos(3.1415926f*params2.rotate_yaw/180);
+		params1.destX[0] = (params1.destX[0] - t_params1-&gt;rotation_hotspot.x) * yaw_rad + t_params1-&gt;rotation_hotspot.x;
+		params1.destX[1] = (params1.destX[1] - t_params1-&gt;rotation_hotspot.x) * yaw_rad + t_params1-&gt;rotation_hotspot.x;
+		params1.destX[2] = (params1.destX[2] - t_params1-&gt;rotation_hotspot.x) * yaw_rad + t_params1-&gt;rotation_hotspot.x;
+		params1.destX[3] = (params1.destX[3] - t_params1-&gt;rotation_hotspot.x) * yaw_rad + t_params1-&gt;rotation_hotspot.x;
+	}
+
+	params1.red[0] = params2.red;
+	params1.red[1] = params2.red;
+	params1.red[2] = params2.red;
+	params1.red[3] = params2.red;
+	params1.green[0] = params2.green;
+	params1.green[1] = params2.green;
+	params1.green[2] = params2.green;
+	params1.green[3] = params2.green;
+	params1.blue[0] = params2.blue;
+	params1.blue[1] = params2.blue;
+	params1.blue[2] = params2.blue;
+	params1.blue[3] = params2.blue;
+	params1.alpha[0] = params2.alpha;
+	params1.alpha[1] = params2.alpha;
+	params1.alpha[2] = params2.alpha;
+	params1.alpha[3] = params2.alpha;
+
+	params1.destZ = params2.destZ;
+	params1.blend_src        = params2.blend_src;
+	params1.blend_dest       = params2.blend_dest;
+	params1.blendfunc_src_alpha  = params2.blendfunc_src_alpha;
+	params1.blendfunc_dest_alpha = params2.blendfunc_dest_alpha;
+	params1.sub_pixel_accuracy = params2.sub_pixel_accuracy;
+
+	// Draw the surface:
+	draw(attributes,
+		  params1,
+		  context);
+}
+
+void CL_Surface_Target::add_ref()
+{
+	ref_count++;
+}
+
+void CL_Surface_Target::release_ref()
+{
+	ref_count--;
+	if (ref_count == 0) delete this;
+}
+
+int CL_Surface_Target::get_handle() {
+	return -1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Implementation:

Added: trunk/clanlib/Display/surface_target.h
===================================================================
--- trunk/clanlib/Display/surface_target.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/surface_target.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,198 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_surface_target
+#define header_surface_target
+
+#ifdef CL_API_DLL
+#ifdef CL_DISPLAY_EXPORT
+#define CL_API_DISPLAY __declspec(dllexport)
+#else
+#define CL_API_DISPLAY __declspec(dllimport)
+#endif
+#else
+#define CL_API_DISPLAY
+#endif
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/Math/origin.h&quot;
+#include &quot;API/Display/blend_func.h&quot;
+
+class CL_PixelBuffer;
+class CL_Surface_Generic;
+class CL_GraphicContext;
+class CL_Point;
+class CL_Pointf;
+class CL_Sizef;
+class CL_Rect;
+struct CL_Surface_DrawParams1;
+struct CL_Surface_DrawParams2;
+
+struct CL_Surface_TargetDrawParams1
+{
+	double pixDestX;
+	double pixDestY;
+	double destWidth;
+	double destHeight;
+	CL_Pointf rotation_hotspot;
+};
+
+class CL_API_DISPLAY CL_Surface_Target
+{
+//! Construction:
+public:
+	CL_Surface_Target();
+
+	virtual ~CL_Surface_Target();
+
+//! Attributes:
+public:
+	//: Returns the width.
+	virtual int get_width() const=0;
+	
+	//: Returns the height.
+	virtual int get_height() const=0;
+
+	//: Returns a pixelbuffer object for accessing surface data.
+	virtual CL_PixelBuffer get_pixeldata()=0;
+
+//! Operations:
+public:
+	//: Uploads pixel data to surface.
+	//!param pos: Position on surface where pixel data should be put.
+	//!param src_rect: Part of pixelbuffer that should be uploaded.
+	//!param pixeldata: CL_PixelBuffer containing the image to be uploaded.
+	virtual void set_pixeldata(const CL_Point &amp;pos, const CL_Rect &amp;src_rect, CL_PixelBuffer &amp;pixeldata)=0;
+
+	//: Draw surface on screen.
+	virtual void draw(
+		CL_Surface_Generic *attributes,
+		const CL_Surface_DrawParams1&amp; params1,
+		CL_GraphicContext *gc)=0;
+
+	//: Draw surface on screen.
+	void draw(
+		CL_Surface_Generic *attributes,
+		const CL_Surface_DrawParams2&amp; params2,
+		CL_GraphicContext *context);
+
+	virtual void draw(
+		CL_Surface_Generic *attributes,
+		const CL_Surface_DrawParams2&amp; params2,
+		CL_Surface_TargetDrawParams1 *target_params1,
+		CL_GraphicContext *context);
+
+	void add_ref();
+
+	void release_ref();
+
+	//  Get the surface handle
+	virtual int get_handle();
+	
+	// inlined this function for performance reasons.
+	static inline CL_Pointf calc_hotspot(CL_Origin origin, float hotspot_x, float hotspot_y, float size_width, float size_height)
+	{
+		switch(origin)
+		{
+		case origin_top_left:
+		default:
+			return CL_Pointf(-hotspot_x, hotspot_y);
+			break;
+		case origin_top_center:
+			return CL_Pointf(size_width / 2 - hotspot_x, -hotspot_y);
+			break;
+		case origin_top_right:
+			return CL_Pointf(size_width - hotspot_x, -hotspot_y);
+			break;
+		case origin_center_left:
+			return CL_Pointf(-hotspot_x, size_height / 2 - hotspot_y);
+			break;
+		case origin_center:
+			return CL_Pointf(size_width / 2 - hotspot_x, size_height / 2 - hotspot_y);
+			break;
+		case origin_center_right:
+			return CL_Pointf(size_width - hotspot_x, size_height / 2 - hotspot_y);
+			break;
+		case origin_bottom_left:
+			return CL_Pointf(-hotspot_x, size_height - hotspot_y);
+			break;
+		case origin_bottom_center:
+			return CL_Pointf(size_width / 2 - hotspot_x, size_height - hotspot_y);
+			break;
+		case origin_bottom_right:
+			return CL_Pointf(size_width - hotspot_x, size_height - hotspot_y);
+			break;
+		}
+	}
+
+	#define calc_rotate_x(px,py,rotation_hotspot_x,rotation_hotspot_y,rotate_x_x,rotate_y_x) \
+		(rotation_hotspot_x + (px-rotation_hotspot_x) * rotate_x_x + (py-rotation_hotspot_y) * rotate_y_x)
+
+	#define calc_rotate_y(px,py,rotation_hotspot_x,rotation_hotspot_y,rotate_x_y,rotate_y_y) \
+		(rotation_hotspot_y + (px-rotation_hotspot_x) * rotate_x_y + (py-rotation_hotspot_y) * rotate_y_y)
+
+/*
+
+	double calc_rotate_x(
+		const double &amp;px,
+		const double &amp;py,
+		const double &amp;rotation_hotspot_x,
+		const double &amp;rotation_hotspot_y,
+		const double &amp;rotate_x_x,
+		const double &amp;rotate_y_x)
+	{
+		return 
+			rotation_hotspot_x +
+			(px-rotation_hotspot_x) * rotate_x_x +
+			(py-rotation_hotspot_y) * rotate_y_x;
+	}
+
+	double calc_rotate_y(
+		const double &amp;px,
+		const double &amp;py,
+		const double &amp;rotation_hotspot_x,
+		const double &amp;rotation_hotspot_y,
+		const double &amp;rotate_x_y,
+		const double &amp;rotate_y_y)
+	{
+		return 
+			rotation_hotspot_y +
+			(px-rotation_hotspot_x) * rotate_x_y +
+			(py-rotation_hotspot_y) * rotate_y_y;
+	}
+*/
+//! Implementation:
+private:
+	int ref_count;
+};
+
+#endif

Added: trunk/clanlib/Display/text_styler.cpp
===================================================================
--- trunk/clanlib/Display/text_styler.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/text_styler.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,501 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/Display/font.h&quot;
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Display/display_window.h&quot;
+#include &quot;API/Display/text_styler.h&quot;
+#include &quot;API/Display/graphic_context.h&quot;
+#include &quot;API/Display/glyph_buffer.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/Resources/resource.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+
+#include &quot;resourcedata_text_styler.h&quot;
+
+#include &lt;algorithm&gt;
+#include &lt;list&gt;
+#include &lt;map&gt;
+#include &lt;stack&gt;
+#include &lt;vector&gt;
+
+//Used in draw_to_gb
+//Returns the font for a given state of font tags, scale tags, and color tags
+CL_Font get_font(
+	const CL_TextStyler&amp; ts,
+	const std::list&lt;std::string&gt;&amp; fnttags,
+	const std::list&lt;std::pair&lt;float, float&gt; &gt;&amp; scaletags,
+	const std::stack&lt;CL_Color&gt;&amp; colorstack)
+{
+	std::map&lt;std::string, CL_Font&gt;::const_iterator fntit = ts.get_fonts().end();
+	
+	//Find the top-most font tag that corresponds with an existing font in the TextStyler
+	for (std::list&lt;std::string&gt;::const_iterator it = fnttags.begin(); it != fnttags.end(); ++it) {
+		if ((fntit = ts.get_fonts().find(*it)) != ts.get_fonts().end()) break;
+	}
+	
+	//Can't find a font tag that corresponds, find the default font
+	if (fntit == ts.get_fonts().end())
+		fntit = ts.get_fonts().find(&quot;default&quot;);
+	
+	//If there's no default font, and no matching font tags, barf
+	if (fntit == ts.get_fonts().end())
+		throw CL_Error(&quot;CL_TextStyler error: No default font and no matching tagged fonts&quot;);
+	
+	CL_Font fnt = fntit-&gt;second;
+	
+	if (!colorstack.empty())
+		fnt.set_color(colorstack.top());
+	
+	float scale_x, scale_y;
+	ts.get_scale(scale_x, scale_y);
+	for(std::list&lt;std::pair&lt;float, float&gt; &gt;::const_iterator it2 = scaletags.begin(); it2 != scaletags.end(); ++it2)
+	{
+		scale_x *= it2-&gt;first;
+		scale_y *= it2-&gt;second;
+	}
+	
+	if (scale_x != 1.0 || scale_y != 1.0)
+	{
+		float fntx, fnty;
+		fnt.get_scale(fntx, fnty);
+		fnt.set_scale(scale_x * fntx, scale_y * fnty);
+	}
+	
+	return fnt;
+}
+
+//Adds/removes from a font tag stack based on a given tag
+void apply_font_tag(
+	std::list&lt;std::string&gt;&amp; fnttags, 
+	std::string::const_iterator start,
+	std::string::const_iterator end)
+{
+	//Exclude the marker characters and only deal with the contents of the tag
+	++start;
+	--end;
+	
+	//Check if its a tag to open or close a block
+	if (*start != '/')
+	{
+		fnttags.push_front(std::string(start, end));
+	}
+	else
+	{
+		//Exclude the '/'
+		++start;
+		
+		//Check each entry in the font tag stack until we find a match with this tag's contents to remove
+		for (std::list&lt;std::string&gt;::iterator it = fnttags.begin(); it != fnttags.end(); ++it)
+		{
+			if (end - start == static_cast&lt;int&gt;(it-&gt;size()) &amp;&amp; std::equal(start, end, it-&gt;begin())) {
+				fnttags.erase(it);
+				break;
+			}
+		}
+	}
+}
+
+//Adds/removes from the justification stack based on a given tag
+void apply_justif_tag(
+	std::stack&lt;unsigned char&gt;&amp; justifstack,
+	std::map&lt;int, unsigned char&gt;&amp; justifmarkers,
+	int glyph_cnt,
+	std::string::const_iterator start,
+	std::string::const_iterator end)
+{
+	//Exclude the tag opener
+	++start;
+	
+	//Apply this tag to the stack
+	//Scope closing tag
+	if (*start == '/' &amp;&amp; !justifstack.empty())
+	{
+		justifstack.pop();
+	}
+	else
+	{
+		//Move past the &quot;j &quot; at the beginning of the tag and add the justif to the stack
+		justifstack.push(*(start+2));
+	}
+	
+	//Record the new entry in the justif markers map
+	if (justifstack.empty())
+		justifmarkers[glyph_cnt] = 'l';
+	else
+		justifmarkers[glyph_cnt] = justifstack.top();
+}
+
+//Adds/removes from a scale stack based on a given tag
+void apply_scale_tag(
+	std::list&lt;std::pair&lt;float, float&gt; &gt;&amp; scaletags,
+	std::string::const_iterator start,
+	std::string::const_iterator end)
+{
+	//Exclude the marker characters and only deal with the contents of the tag
+	++start;
+	--end;
+	
+	//Check if its a tag to open or close a block
+	if (*start != '/')
+	{
+		//Move past the &quot;s &quot; at the beginning of the tag's inside
+		start += 2;
+		
+		//If there's a space in there, then x and y specified seperately
+		std::string::const_iterator spc_pos = std::find(start, end, ' ');
+		if (spc_pos == end)
+		{
+			//No space, so just convert and insert the number as both x and y
+			float val = CL_String::to_float(std::string(start, end));
+			scaletags.push_front(std::pair&lt;float, float&gt;(val, val));
+		}
+		else
+		{
+			//Insert the two numbers as x and y respectively
+			scaletags.push_front(std::pair&lt;float, float&gt;(
+				CL_String::to_float(std::string(start, spc_pos)),
+				CL_String::to_float(std::string(spc_pos+1, end))
+			));
+		}
+	}
+	else if (!scaletags.empty())
+	{
+		scaletags.pop_front();
+	}
+}
+
+//Adds removes from a color stack based on a given tag
+void apply_color_tag(
+	std::stack&lt;CL_Color&gt;&amp; colorstack,
+	std::string::const_iterator start,
+	std::string::const_iterator end)
+{
+	//Exclude the marker characters and only deal with the contents of the tag
+	++start;
+	--end;
+	
+	//Check if its a tag to open or close a block
+	if (*start != '/')
+	{	
+		//Move past the &quot;c &quot; at the beginning of the tag contents
+		start += 2;
+		
+		//Depending on how many spaces there are, we can tell if this is a named color, 3 part, or 4 part (w/ alpha)
+		switch (std::count(start, end, ' ')) {
+			case 0:
+				{
+					colorstack.push(CL_Color::find_color(std::string(start, end)));
+					break;
+				}
+			case 2:
+				{
+					//RGB specified, grab them and set alpha to default
+					CL_Color col;
+					
+					std::string::const_iterator colstart = start;
+					std::string::const_iterator colend = std::find(colstart, end, ' ');
+					col.set_red(CL_String::to_int(std::string(colstart, colend)));
+					colstart = colend+1;
+					colend = std::find(colstart, end, ' ');
+					col.set_green(CL_String::to_int(std::string(colstart, colend)));
+					colstart = colend+1;
+					colend = end;
+					col.set_blue(CL_String::to_int(std::string(colstart, colend)));
+					col.set_alpha(255);
+					
+					colorstack.push(col);
+				}
+				break;
+			case 3:
+				{
+					//RGBA specified
+					CL_Color col;
+					
+					std::string::const_iterator colstart = start;
+					std::string::const_iterator colend = std::find(colstart, end, ' ');
+					col.set_red(CL_String::to_int(std::string(colstart, colend)));
+					colstart = colend+1;
+					colend = std::find(colstart, end, ' ');
+					col.set_green(CL_String::to_int(std::string(colstart, colend)));
+					colstart = colend+1;
+					colend = std::find(colstart, end, ' ');
+					col.set_blue(CL_String::to_int(std::string(colstart, colend)));
+					colstart = colend+1;
+					colend = end;
+					col.set_alpha(CL_String::to_int(std::string(colstart, colend)));
+					
+					colorstack.push(col);
+				}
+				break;
+			default:
+				throw CL_Error(&quot;CL_TextStyler: Invalid color tag specified!&quot;);
+				break;
+		}
+	}
+	else if (!colorstack.empty())
+	{
+		colorstack.pop();
+	}
+}
+
+CL_TextStyler::CL_TextStyler() :
+	scale_x(1.0f), 
+	scale_y(1.0f), 
+	trans_origin(origin_top_left),
+	trans_x(0), 
+	trans_y(0) 
+{
+}
+
+CL_TextStyler::CL_TextStyler(const CL_TextStyler&amp; other) :
+	resource(other.resource), 
+	scale_x(other.scale_x), 
+	scale_y(other.scale_y), 
+	trans_origin(other.trans_origin),
+	trans_x(other.trans_x), trans_y(other.trans_y),
+	fonts(other.fonts)
+{
+	resource.load();
+}
+
+CL_TextStyler::CL_TextStyler(const std::string &amp;resource_id, CL_ResourceManager* manager)
+{
+	CL_Resource res = manager-&gt;get_resource(resource_id);
+	res.load();
+	CL_ResourceData_TextStyler* data = (CL_ResourceData_TextStyler*)res.get_data(&quot;text_styler&quot;);
+	operator=(data-&gt;get_text_styler());
+	resource = res;
+}
+
+int CL_TextStyler::get_height() const
+{
+	std::map&lt;std::string, CL_Font&gt;::const_iterator x = fonts.find(&quot;default&quot;);
+	if (x != fonts.end())
+		return x-&gt;second.get_height();
+	else
+		throw CL_Error(&quot;CL_TextStyler error: Argument-less get_height() method requires a 'default' font, but there isn't one&quot;);
+}
+
+CL_Size CL_TextStyler::get_size(
+	std::string::const_iterator start,
+	std::string::const_iterator end,
+	CL_Size max_size) const
+{
+	CL_GlyphBuffer gb;
+	draw_to_gb(start, end, gb, max_size);
+	return gb.get_size();
+}
+
+CL_Rect CL_TextStyler::bounding_rect(
+	CL_Rect dest,
+	std::string::const_iterator start,
+	std::string::const_iterator end) const
+{
+	CL_GlyphBuffer gb;
+	draw_to_gb(start, end, gb, dest.get_size());
+	gb.set_alignment(trans_origin, trans_x, trans_y);
+	return gb.bounding_rect(dest);
+}
+
+CL_TextStyler&amp; CL_TextStyler::operator =(const CL_TextStyler&amp; other)
+{
+	resource.unload();
+
+	scale_x = other.scale_x;
+	scale_y = other.scale_y;
+	trans_origin = other.trans_origin;
+	trans_x = other.trans_x;
+	trans_y = other.trans_y;
+	resource = other.resource;
+	fonts = other.fonts;
+	
+	resource = other.resource;
+	resource.load();
+	
+	return *this;
+}
+
+int CL_TextStyler::draw(
+	CL_Rect dest,
+	std::string::const_iterator start,
+	std::string::const_iterator end,
+	CL_GraphicContext *context) const
+{
+	if (context == 0)
+		context = CL_Display::get_current_window()-&gt;get_gc();
+	
+	CL_GlyphBuffer gb;
+	int ret = draw_to_gb(start, end, gb, dest.get_size());
+	gb.set_alignment(trans_origin, trans_x, trans_y);
+	
+	if (trans_origin == origin_top_left)
+		gb.fixed_draw(dest.left - trans_x, dest.top - trans_y, context);
+	else
+		gb.draw(dest, context);
+	
+	return ret;
+}
+
+int CL_TextStyler::draw_to_gb(
+	std::string::const_iterator start,
+	std::string::const_iterator end,
+	CL_GlyphBuffer&amp; gb,
+	CL_Size max_size) const
+{
+	std::list&lt;std::string&gt; fnttags; //Stack of open font tags, beginning is top
+	std::list&lt;std::pair&lt;float, float&gt; &gt; scaletags; //Stack of open scale tags, beginning is top
+	std::stack&lt;CL_Color&gt; colorstack; //Stack of color tags, overrides existing CL_Font color
+	std::stack&lt;unsigned char&gt; justifstack; //l for left, c for center, r for right; represents current justif tag state
+	std::map&lt;int, unsigned char&gt; justifmarkers; //Same letter connotations as above, marks places where justif will be changed later
+	
+	const int orig_size = gb.get_glyphs().size(); //So we can calculate the return value easily
+	const std::string tagopns = &quot;{[&quot;; //Characters that serve as tag openers
+	
+	//Left-justify the last line of the existing buffer, if there is one
+	if (orig_size != 0)
+	{
+		CL_GlyphBuffer::Range last_line = gb.get_line(gb.get_glyphs().size()-1);
+		gb.justify_left(last_line);
+	}
+	
+	//Go through the source string in chunks (a chunk either being a tag, a bit of text, or an escaped tag opener)
+	for (std::string::const_iterator it = start; it != end;)
+	{
+		//If it is a tag opening character...
+		if (tagopns.find(*it) != std::string::npos)
+		{
+			//Barf if the last character of the input is a tag opener
+			if (it == end-1)
+				throw CL_Error(&quot;CL_TextStyler error: Incomplete tag, bailing out&quot;);
+			
+			//If it's escaped, then draw it by itself and move over both characters
+			if (*(it+1) == *it)
+			{
+				const int glyph_cnt =
+					get_font(*this, fnttags, scaletags, colorstack).draw_to_gb(std::string(1, *it), gb, max_size);
+				if (glyph_cnt != 1)
+					break;
+				
+				it += 2;
+			}
+			else
+			{
+				unsigned char eotchr;
+				if (*it == '{')
+					eotchr = '}';
+				else
+					eotchr = ']';
+				
+				std::string::const_iterator tag_end = std::find(it, end, eotchr);
+				if (tag_end == end)
+					throw CL_Error(&quot;CL_TextStyler error: Incomplete tag, bailing out&quot;);
+				if (tag_end == it+1 || (*(it+1) == '/' &amp;&amp; tag_end == it+2))
+					throw CL_Error(&quot;CL_TextStyler error: Empty tag, bailing out&quot;);
+				
+				++tag_end;
+				
+				if (*it == '{')
+					apply_font_tag(fnttags, it, tag_end);
+				else if (*(it+1) == 's' || (*(it+1) == '/' &amp;&amp; *(it+2) == 's'))
+					apply_scale_tag(scaletags, it, tag_end);
+				else if (*(it+1) == 'j' || (*(it+1) == '/' &amp;&amp; *(it+2) == 'j'))
+					apply_justif_tag(justifstack, justifmarkers, gb.get_glyphs().size(), it, tag_end);
+				else if (*(it+1) == 'c' || (*(it+1) == '/' &amp;&amp; *(it+2) == 'c'))
+					apply_color_tag(colorstack, it, tag_end);
+				else if (*(it+1) == 'n')
+					get_font(*this, fnttags, scaletags, colorstack).draw_to_gb(std::string(&quot;\n&quot;), gb, max_size);
+				else
+					throw CL_Error(&quot;CL_TextStyler error: Unknown tag, bailing out&quot;);
+				
+				it = tag_end;
+			}
+		}
+		else
+		{
+			std::string::const_iterator chunk_end = std::find_first_of(it, end, tagopns.begin(), tagopns.end());
+			
+			const int glyph_cnt = get_font(*this, fnttags, scaletags, colorstack).draw_to_gb(it, chunk_end, gb, max_size);
+			
+			if (glyph_cnt != chunk_end - it)
+				break;
+			it = chunk_end;
+		}
+	}
+	
+	//The column passed to justify_right (and, halved, to justify_center)
+	int right_side;
+	if (max_size.width != 0)
+		right_side = max_size.width;
+	else
+		right_side = gb.get_width();
+	
+	//Apply justification markers that were added based on any justif tags
+	for (std::map&lt;int, unsigned char&gt;::iterator x = justifmarkers.begin(); x != justifmarkers.end(); ++x)
+	{
+		std::map&lt;int, unsigned char&gt;::iterator y = x;
+		++y;
+		
+		//Get the range that this tag applies to
+		CL_GlyphBuffer::Range prerange; //Range before line boundary calculation
+		prerange.start = x-&gt;first;
+		if (y == justifmarkers.end())
+			prerange.end = gb.get_glyphs().size();
+		else
+			prerange.end = y-&gt;first;
+		
+		std::vector&lt;CL_GlyphBuffer::Range&gt; lines = gb.get_lines(prerange);
+		
+		if (lines.size() != 0)
+		{
+			//Range after line boundary calculation
+			CL_GlyphBuffer::Range range(lines.begin()-&gt;start, (lines.end()-1)-&gt;end);
+			
+			switch (x-&gt;second)
+			{
+				case 'l':
+					gb.justify_left(range);
+					break;
+				case 'c':
+					gb.justify_center(range, right_side/2);
+					break;
+				case 'r':
+					gb.justify_right(range, right_side);
+					break;
+				default:
+					throw CL_Error(&quot;CL_TextStyler error: Unknown justification tag&quot;);
+					break;
+			}
+		}
+	}
+	
+	return gb.get_glyphs().size() - orig_size;
+}

Added: trunk/clanlib/Display/triangle_params.h
===================================================================
--- trunk/clanlib/Display/triangle_params.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Display/triangle_params.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,67 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_triangle_params
+#define header_triangle_params
+
+class CL_Surface_Target;
+class CL_Color;
+
+struct CL_TriangleParams
+{
+	CL_TriangleParams() :
+		count(0),
+		fill(true),
+		color_range_zero2one(false),
+		uv_range_zero2one(false),
+		vertices(0),
+		color(0),
+		uchar_color(0),
+		uv(0),
+		int_uv(0),
+		texture(0),
+		single_color(0)
+	{
+		return;
+	}
+
+	unsigned int count;
+	bool fill;
+	bool color_range_zero2one;
+	bool uv_range_zero2one;
+	double *vertices;
+	double *color;
+	unsigned char *uchar_color;
+	double *uv;
+	int *int_uv;
+	CL_Surface_Target *texture;
+	const CL_Color *single_color;
+};
+
+#endif

Added: trunk/clanlib/GL/AGL/display_window_opengl.cpp
===================================================================
--- trunk/clanlib/GL/AGL/display_window_opengl.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/AGL/display_window_opengl.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,1007 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &lt;iostream&gt;
+#include &lt;cstdio&gt;
+#include &lt;errno.h&gt;
+
+#include &quot;display_window_opengl.h&quot;
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;Display/display_window_generic.h&quot;
+#include &quot;API/Core/System/keep_alive.h&quot;
+#include &quot;../graphic_context_opengl.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/System/log.h&quot;
+#include &quot;GL/gl_state_checker.h&quot;
+#include &quot;GL/AGL/input_device_mackeyboard.h&quot;
+#include &quot;GL/AGL/input_device_macmouse.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/GL/opengl_window_description.h&quot;
+#include &quot;API/GL/opengl_state.h&quot;
+#include &quot;API/GL/opengl_wrap.h&quot;
+#include &quot;API/Display/keys.h&quot;
+#include &quot;API/Display/input_device.h&quot;
+#include &quot;API/Display/input_event.h&quot;
+#include &quot;../opengl_window_description_generic.h&quot;
+#include &lt;unistd.h&gt;
+
+AGLContext CL_DisplayWindow_OpenGL::share_context = 0;
+
+int CL_DisplayWindow_OpenGL::disp_ref_count = 0;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_DisplayWindow_OpenGL::CL_DisplayWindow_OpenGL() :
+	left_ctrl_down(false), left_alt_down(false), left_shift_down(false),
+	right_ctrl_down(false), right_alt_down(false), right_shift_down(false),
+	fullscreen(false), fullscreen_width(0), fullscreen_height(0),
+	saved_position(0, 0, 0, 0),
+	context(0), win_context(0),
+	fs_context(0), window_ref(0)
+{
+	static bool first_call = true;
+	if (first_call)
+	{
+		// Enable key-up:
+		SetEventMask(everyEvent);
+		target_ref = GetEventDispatcherTarget();
+		first_call = false;
+	}
+
+	gc = CL_GraphicContext(new CL_GraphicContext_OpenGL(this));
+}
+
+CL_DisplayWindow_OpenGL::~CL_DisplayWindow_OpenGL()
+{
+//	if(fullscreen)
+//		set_windowed();
+	destroy_window();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+int CL_DisplayWindow_OpenGL::get_width() const
+{
+	Rect rect;
+	GetWindowPortBounds(window_ref, &amp;rect);
+	return rect.right-rect.left;
+}
+
+int CL_DisplayWindow_OpenGL::get_height() const
+{
+	Rect rect;
+	GetWindowPortBounds(window_ref, &amp;rect);
+	return rect.bottom-rect.top;
+}
+
+bool CL_DisplayWindow_OpenGL::is_fullscreen() const
+{
+	return fullscreen;
+}
+
+bool CL_DisplayWindow_OpenGL::has_focus() const
+{
+	return focus;
+}
+
+CL_PixelBuffer CL_DisplayWindow_OpenGL::get_buffer(int i) const
+{
+	if (i == 0) 
+	{
+		return gc.get_pixeldata(CL_Rect(0, 0, get_width(), get_height()), CL_FRONT);
+	}
+	else
+	{
+		return gc.get_pixeldata(CL_Rect(0, 0, get_width(), get_height()), CL_BACK);
+	}
+}
+
+int CL_DisplayWindow_OpenGL::get_buffer_count() const
+{
+	return 2;
+}
+
+CL_GraphicContext *CL_DisplayWindow_OpenGL::get_gc()
+{
+	return &gc;
+}
+
+CL_Size CL_DisplayWindow_OpenGL::get_max_surface_size() const
+{
+	CLint max_texture_size;
+	clGetIntegerv(CL_MAX_TEXTURE_SIZE, &amp;max_texture_size);
+	return CL_Size(max_texture_size, max_texture_size);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_DisplayWindow_OpenGL::create_window(const CL_DisplayWindowDescription &amp;desc)
+{
+	OSStatus result;
+
+	const CL_OpenGLWindowDescription_Generic *gl_desc = 0;
+	gl_desc = dynamic_cast&lt;const CL_OpenGLWindowDescription_Generic*&gt;(desc.impl.get());
+
+	fullscreen_width = desc.get_size().width;
+	fullscreen_height = desc.get_size().height;
+
+	disp_ref_count++;
+
+	GLint gl_attribs_single[] =
+	{
+		AGL_RGBA,
+		AGL_RED_SIZE, 4,
+		AGL_GREEN_SIZE, 4,
+		AGL_BLUE_SIZE, 4,
+		AGL_DEPTH_SIZE, 16,
+		AGL_NONE
+	};
+
+	GLint gl_attribs[32];
+	int i = 0;
+	
+	if( gl_desc )
+	{
+		if( gl_desc-&gt;rgba ) gl_attribs[i++] = AGL_RGBA;
+		if( gl_desc-&gt;doublebuffer ) gl_attribs[i++] = AGL_DOUBLEBUFFER;
+		//if( gl_desc-&gt;stereo ) gl_attribs[i++] = AGL_STEREO;
+		gl_attribs[i++] = AGL_BUFFER_SIZE;
+		gl_attribs[i++] = gl_desc-&gt;buffer_size;
+		gl_attribs[i++] = AGL_LEVEL;
+		gl_attribs[i++] = gl_desc-&gt;level;
+		gl_attribs[i++] = AGL_AUX_BUFFERS;
+		gl_attribs[i++] = gl_desc-&gt;aux_buffers;
+		gl_attribs[i++] = AGL_RED_SIZE; 
+		gl_attribs[i++] = gl_desc-&gt;red_size;
+		gl_attribs[i++] = AGL_GREEN_SIZE;
+		gl_attribs[i++] = gl_desc-&gt;green_size;
+		gl_attribs[i++] = AGL_BLUE_SIZE;
+		gl_attribs[i++] = gl_desc-&gt;blue_size;
+		gl_attribs[i++] = AGL_DEPTH_SIZE;
+		gl_attribs[i++] = gl_desc-&gt;depth_size;
+		gl_attribs[i++] = AGL_STENCIL_SIZE;
+		gl_attribs[i++] = gl_desc-&gt;stencil_size;
+		gl_attribs[i++] = AGL_ACCUM_RED_SIZE;
+		gl_attribs[i++] = gl_desc-&gt;accum_red_size;
+		gl_attribs[i++] = AGL_ACCUM_GREEN_SIZE;
+		gl_attribs[i++] = gl_desc-&gt;accum_green_size;
+		gl_attribs[i++] = AGL_ACCUM_BLUE_SIZE;
+		gl_attribs[i++] = gl_desc-&gt;accum_blue_size;
+		gl_attribs[i++] = AGL_ACCUM_ALPHA_SIZE;
+		gl_attribs[i++] = gl_desc-&gt;accum_alpha_size;
+		gl_attribs[i++] = AGL_ACCUM_RED_SIZE;
+		gl_attribs[i++] = gl_desc-&gt;accum_red_size;
+//		gl_attribs[i++] = AGL_FULLSCREEN;
+	}
+	else
+	{
+		gl_attribs[i++] = AGL_RGBA;
+		gl_attribs[i++] = AGL_NO_RECOVERY;
+		gl_attribs[i++] = AGL_DOUBLEBUFFER;
+		gl_attribs[i++] = AGL_DEPTH_SIZE;
+		gl_attribs[i++] = 16;
+	} 
+/*	
+	else
+	{
+		gl_attribs[i++] = AGL_RGBA;
+		gl_attribs[i++] = AGL_DOUBLEBUFFER;
+		gl_attribs[i++] = AGL_RED_SIZE;
+		gl_attribs[i++] = 4;
+		gl_attribs[i++] = AGL_GREEN_SIZE;
+		gl_attribs[i++] = 4;
+		gl_attribs[i++] = AGL_BLUE_SIZE;
+		gl_attribs[i++] = 4;
+		gl_attribs[i++] = AGL_DEPTH_SIZE;
+		gl_attribs[i++] = 16;
+//		gl_attribs[i++] = AGL_FULLSCREEN;
+	}
+*/
+
+	gl_attribs[i] = AGL_NONE;
+
+	CGDirectDisplayID display = CGMainDisplayID();
+	GDHandle gdhDisplay, *pgdhDisplay;
+	int numDisplay;
+
+	pgdhDisplay = &gdhDisplay;
+	
+	if (noErr == DMGetGDeviceByDisplayID ((DisplayIDType)display, pgdhDisplay, false)) 
+		numDisplay = 1;	
+	else 
+	{
+		pgdhDisplay = 0;
+		numDisplay = 0;
+	}
+		
+	AGLPixelFormat pixelformat;	
+	pixelformat = aglChoosePixelFormat(pgdhDisplay, numDisplay, gl_attribs);
+	win_context = aglCreateContext(pixelformat, share_context);
+	if (!share_context) share_context = win_context;
+	aglDestroyPixelFormat(pixelformat);
+	gl_attribs[i++] = AGL_FULLSCREEN;
+	gl_attribs[i] = AGL_NONE;
+	pixelformat = aglChoosePixelFormat(pgdhDisplay, numDisplay, gl_attribs);
+	fs_context = aglCreateContext(pixelformat, win_context);
+	aglDestroyPixelFormat(pixelformat);
+
+	if (!(win_context &amp;&amp; fs_context)) 
+	{
+		printf(&quot;Requested visual not supported by your OpenGL implementation. Falling back on singlebuffered Visual!\n&quot;);
+		pixelformat = aglChoosePixelFormat(0, 0, gl_attribs_single);
+		win_context = aglCreateContext(pixelformat, share_context);
+		aglDestroyPixelFormat(pixelformat);
+		fs_context = 0;
+	}
+
+	WindowAttributes style = kWindowCloseBoxAttribute | kWindowStandardHandlerAttribute;
+	if (desc.get_allow_resize()) style |= kWindowResizableAttribute | kWindowFullZoomAttribute;
+	Rect window_rect;
+	SetRect(&amp;window_rect, 50, 50, 50+desc.get_size().width, 50+desc.get_size().height);
+	result = CreateNewWindow(kDocumentWindowClass, style, &amp;window_rect, &amp;window_ref);
+	if (result != noErr)
+		printf(&quot;Could not create window, due to error %d\n&quot;, (int)result);
+
+	// set title of window:
+	set_title(desc.get_title());
+
+	// Set standard arrow cursor:
+	InitCursor(); // do we need to do this? -- iMBN, 13. may 2004
+	
+	// Create input devices for window:
+	keyboard = CL_InputDevice(new CL_InputDevice_MacKeyboard(this));
+	mouse	= CL_InputDevice(new CL_InputDevice_MacMouse(this));
+
+	get_ic()-&gt;clear();
+	get_ic()-&gt;add_keyboard(keyboard);
+	get_ic()-&gt;add_mouse(mouse);
+
+//	buffer_front = CL_PixelBuffer(new CL_PixelBuffer_OpenGL_Frame(CL_FRONT, gc));
+//	buffer_back = CL_PixelBuffer(new CL_PixelBuffer_OpenGL_Frame(CL_BACK, gc));
+
+	if (!aglSetDrawable(win_context, GetWindowPort(window_ref)))
+	{
+		printf(&quot;Unable to set drawable&quot;);
+	}
+	
+	if (desc.is_fullscreen())
+		set_fullscreen(desc.get_size().width, desc.get_size().height, desc.get_bpp(), desc.get_refresh_rate());
+	else {
+		fullscreen = true;  // not really, but need to fool set_windowed
+		set_windowed();
+	}
+
+	ShowWindow(window_ref);
+}
+
+void CL_DisplayWindow_OpenGL::install_event_handler(EventTargetRef targ_ref, int remove_only) 
+{
+	static EventHandlerUPP window_handler_proc = 0;
+	if (window_handler_proc == 0)
+		window_handler_proc = NewEventHandlerUPP(&amp;CL_DisplayWindow_OpenGL::on_window_event);
+	
+	static EventHandlerRef current_handler = 0;
+	if (current_handler != 0)
+		RemoveEventHandler(current_handler);
+	
+	if (remove_only) return;
+	
+	EventTypeSpec events[20];
+	events[0].eventClass = kEventClassKeyboard;
+	events[0].eventKind = kEventRawKeyDown;
+	events[1].eventClass = kEventClassKeyboard;
+	events[1].eventKind = kEventRawKeyRepeat;
+	events[2].eventClass = kEventClassKeyboard;
+	events[2].eventKind = kEventRawKeyUp;
+	events[3].eventClass = kEventClassMouse;
+	events[3].eventKind = kEventMouseDown;
+	events[4].eventClass = kEventClassMouse;
+	events[4].eventKind = kEventMouseUp;
+	events[5].eventClass = kEventClassMouse;
+	events[5].eventKind = kEventMouseMoved;
+	events[6].eventClass = kEventClassMouse;
+	events[6].eventKind = kEventMouseWheelMoved;
+	events[7].eventClass = kEventClassWindow;
+	events[7].eventKind = kEventWindowCollapsing;
+	events[8].eventClass = kEventClassWindow;
+	events[8].eventKind = kEventWindowDrawContent;
+	events[9].eventClass = kEventClassWindow;
+	events[9].eventKind = kEventWindowShown;
+	events[10].eventClass = kEventClassWindow;
+	events[10].eventKind = kEventWindowClose;
+	events[11].eventClass = kEventClassWindow;
+	events[11].eventKind = kEventWindowActivated;
+	events[12].eventClass = kEventClassWindow;
+	events[12].eventKind = kEventWindowDeactivated;
+	events[13].eventClass = kEventClassWindow;
+	events[13].eventKind = kEventWindowBoundsChanged;
+	events[14].eventClass = kEventClassWindow;
+	events[14].eventKind = kEventWindowZoomed;
+	events[15].eventClass = kEventClassWindow;
+	events[15].eventKind = kEventWindowFocusAcquired;
+	events[16].eventClass = kEventClassWindow;
+	events[16].eventKind = kEventWindowFocusRelinquish;
+	events[17].eventClass = kEventClassMouse;
+	events[17].eventKind = kEventMouseDragged;
+	events[18].eventClass = kEventClassKeyboard;
+	events[18].eventKind = kEventRawKeyModifiersChanged;
+
+	InstallEventHandler(targ_ref, window_handler_proc, 19, events, this, &amp;current_handler);
+}
+
+void CL_DisplayWindow_OpenGL::destroy_window()
+{
+	install_event_handler(0, 1);
+
+	if (context)
+		aglSetCurrentContext(0);
+
+	if (fs_context)
+	{
+		aglDestroyContext(fs_context);
+		fs_context = 0;
+	}
+
+	if (win_context)
+	{
+		aglDestroyContext(win_context);
+		win_context = 0;
+	}
+
+	keyboard = CL_InputDevice();
+	mouse = CL_InputDevice();
+	get_ic()-&gt;clear();
+
+	if (window_ref)
+		ReleaseWindow(window_ref);
+	window_ref = 0;
+}
+
+void CL_DisplayWindow_OpenGL::flip(int interval)
+{
+	CL_GLStateChecker::from_gc(get_gc())-&gt;flush();
+
+	if (interval != -1)
+	{
+		GLint param = interval;
+		aglSetInteger(context, AGL_SWAP_INTERVAL, &amp;param);
+	}
+
+	aglSwapBuffers(context);
+}
+
+void CL_DisplayWindow_OpenGL::set_fullscreen(int width, int height, int bpp, int refresh_rate)
+{
+	if(fullscreen)
+		return;
+
+	CGCaptureAllDisplays();
+	
+	aglSetCurrentContext(fs_context);
+	aglSetFullScreen(fs_context, width, height, refresh_rate, 0);
+
+	context = fs_context;
+	install_event_handler(GetApplicationEventTarget());
+	
+	fullscreen = true;
+	focus = true;
+
+	//After toggling to the fullscreen context, nothing is going draw unless
+	//we reapply the GL states/properties -mrfun 6-2-2006
+	CL_GLStateChecker::from_gc(get_gc())-&gt;reinitialize_asap();
+}
+
+void CL_DisplayWindow_OpenGL::set_windowed()
+{
+	if(!fullscreen)
+		return;
+
+	if (context == fs_context)
+	{
+	    aglSetDrawable(fs_context, 0);
+	}
+	
+	CGReleaseAllDisplays();
+	aglSetCurrentContext(win_context);
+	aglUpdateContext(win_context);
+	install_event_handler(GetWindowEventTarget(window_ref));
+
+	fullscreen = false;
+	context = win_context;
+	focus = IsWindowHilited(window_ref);
+	
+	//After toggling to the fullscreen context, nothing is going draw unless
+	//we reapply the GL states/properties -mrfun 6-2-2006
+	CL_GLStateChecker::from_gc(get_gc())-&gt;reinitialize_asap();
+	
+}
+
+void CL_DisplayWindow_OpenGL::set_title(const std::string &amp;title)
+{
+	CFStringRef s = CFStringCreateWithCString(0, title.c_str(), kCFStringEncodingISOLatin1);
+	SetWindowTitleWithCFString(window_ref, s);
+	CFRelease(s);
+}
+
+void CL_DisplayWindow_OpenGL::set_position(const CL_Rect &amp;pos)
+{
+	set_position(pos.left, pos.top);
+	set_size(pos.get_width(), pos.get_height());
+}
+
+void CL_DisplayWindow_OpenGL::set_position(int x, int y)
+{
+	MoveWindow(window_ref, x, y, false);
+}
+
+void CL_DisplayWindow_OpenGL::set_size(int width, int height)
+{
+	fullscreen_width = width;
+	fullscreen_height = height;
+	SizeWindow(window_ref, width, height, true);
+	sig_resize(width, height);
+}
+
+void CL_DisplayWindow_OpenGL::set_buffer_count(int flipping_buffers)
+{
+// Not implemented.
+// We can't change how many buffer we use in OpenGL, the drivers pick for us
+	CL_Log::log(&quot;debug&quot;, &quot;CL_DisplayWindow_OpenGL::set_buffer_count is not implemented&quot;);
+}
+
+void CL_DisplayWindow_OpenGL::update(const CL_Rect &amp;rect)
+{
+	CL_OpenGLState state(get_gc());
+	state.set_active();
+	state.setup_2d();
+
+	clReadBuffer(CL_BACK);
+
+	if(clGetError() == CL_NO_ERROR)		// Check if we got more than 1 buffer.
+	{
+		float raster_pos[4];
+
+		clGetFloatv(CL_CURRENT_RASTER_POSITION, raster_pos);
+
+		clDrawBuffer(CL_FRONT);
+		clRasterPos3f(rect.left, rect.bottom, raster_pos[2]);
+
+		clCopyPixels(rect.top, rect.left, rect.get_width(), rect.get_height(), CL_COLOR);
+
+		// Return to drawing to the back buffer
+		clDrawBuffer(CL_BACK);
+	}
+}
+
+void CL_DisplayWindow_OpenGL::show_system_cursor()
+{
+	ShowCursor();
+}
+
+void CL_DisplayWindow_OpenGL::hide_system_cursor()
+{
+	// Should be replaced by a function only hiding it over this window, if possible.
+	HideCursor();
+}
+
+void CL_DisplayWindow_OpenGL::cursor_changed()
+{
+}
+
+void CL_DisplayWindow_OpenGL::keep_alive()
+{
+	EventRef theEvent;
+
+	while(ReceiveNextEvent(0, NULL,kEventDurationNoWait,true,&amp;theEvent)== noErr)
+	{
+		SendEventToEventTarget (theEvent, target_ref);
+		ReleaseEvent(theEvent);
+	}
+}
+
+int CL_DisplayWindow_OpenGL::clkey_to_keycode(int clkey)
+{
+	switch (clkey)
+	{
+	case CL_KEY_A:				return 0;
+	case CL_KEY_S:				return 1;
+	case CL_KEY_D:				return 2;
+	case CL_KEY_F:				return 3;
+	case CL_KEY_H:				return 4;
+	case CL_KEY_G:				return 5;
+	case CL_KEY_Z:				return 6;
+	case CL_KEY_X:				return 7;
+	case CL_KEY_C:				return 8;
+	case CL_KEY_V:				return 9;
+	case CL_KEY_B:				return 11;
+	case CL_KEY_Q:				return 12;
+	case CL_KEY_W:				return 13;
+	case CL_KEY_E:				return 14;
+	case CL_KEY_R:				return 15;
+	case CL_KEY_Y:				return 16;
+	case CL_KEY_T:				return 17;
+	case CL_KEY_1:				return 18;
+	case CL_KEY_2:				return 19;
+	case CL_KEY_3:				return 20;
+	case CL_KEY_4:				return 21;
+	case CL_KEY_6:				return 22;
+	case CL_KEY_5:				return 23;
+	case CL_KEY_EQUALS:			return 24;
+	case CL_KEY_9:				return 25;
+	case CL_KEY_7:				return 26;
+	case CL_KEY_SUBTRACT:		return 27;
+	case CL_KEY_8:				return 28;
+	case CL_KEY_0:				return 29;
+	// case CL_KEY_UMLAU:		return 30; // key next to key next to P  ??
+	case CL_KEY_O:				return 31;
+	case CL_KEY_U:				return 32;
+	// case CL_KEY_AA:			return 33; // key next to P  ??
+	case CL_KEY_I:				return 34;
+	case CL_KEY_P:				return 35;
+	case CL_KEY_ENTER:			return 36;
+	case CL_KEY_L:				return 37;
+	case CL_KEY_J:				return 38;
+	case CL_KEY_QUOTE:			return 39;
+	case CL_KEY_K:				return 40;
+	case CL_KEY_SEMICOLON:		return 41;
+	case CL_KEY_COMMA:			return 43;
+	case CL_KEY_DIVIDE:			return 44;
+	case CL_KEY_N:				return 45;
+	case CL_KEY_M:				return 46;
+	case CL_KEY_PERIOD:			return 47;
+	case CL_KEY_TAB:			return 48;
+	case CL_KEY_SPACE:			return 49;
+	case CL_KEY_TILDE:			return 50;
+	case CL_KEY_BACKSPACE:		return 51;
+	case CL_KEY_ESCAPE:			return 53;
+	case CL_KEY_SHIFT:			return 56;
+	case CL_KEY_MENU:			return 58;
+	case CL_KEY_CONTROL:		return 59;
+	case CL_KEY_NUMPAD_DECIMAL:	return 65;
+	case CL_KEY_NUMPAD_MULTIPLY:return 67;
+	case CL_KEY_NUMPAD_ADD:		return 69;
+	case CL_KEY_NUMPAD_DIVIDE:	return 75;
+	case CL_KEY_NUMPAD_ENTER:	return 76;
+	case CL_KEY_NUMPAD_SUBTRACT:return 78;
+	case CL_KEY_NUMPAD_EQUALS:	return 81;
+	case CL_KEY_NUMPAD_0:		return 82;
+	case CL_KEY_NUMPAD_1:		return 83;
+	case CL_KEY_NUMPAD_2:		return 84;
+	case CL_KEY_NUMPAD_3:		return 85;
+	case CL_KEY_NUMPAD_4:		return 86;
+	case CL_KEY_NUMPAD_5:		return 87;
+	case CL_KEY_NUMPAD_6:		return 88;
+	case CL_KEY_NUMPAD_7:		return 89;
+	case CL_KEY_NUMPAD_8:		return 91;
+	case CL_KEY_NUMPAD_9:		return 92;
+	case CL_KEY_F5:				return 96;
+	case CL_KEY_F6:				return 97;
+	case CL_KEY_F7:				return 98;
+	case CL_KEY_F3:				return 99;
+	case CL_KEY_F8:				return 100;
+	case CL_KEY_F9:				return 101;
+	case CL_KEY_F10:			return 109;
+	case CL_KEY_F12:			return 111;
+	case CL_KEY_HOME:			return 115;
+	case CL_KEY_PAGE_UP:		return 116;
+	case CL_KEY_DELETE:			return 117;
+	case CL_KEY_F4:				return 118;
+	case CL_KEY_END:			return 119;
+	case CL_KEY_F2:				return 120;
+	case CL_KEY_PAGE_DOWN:		return 121;
+	case CL_KEY_F1:				return 122;
+	case CL_KEY_LEFT:			return 123;
+	case CL_KEY_RIGHT:			return 124;
+	case CL_KEY_DOWN:			return 125;
+	case CL_KEY_UP:				return 126;
+	default:					return clkey - 0x10000;
+	}
+	return 0;
+}
+
+std::set&lt;int&gt; CL_DisplayWindow_OpenGL::modifiercode_to_clkeys(int m)
+{
+	std::set&lt;int&gt; r;
+	if (m &amp; shiftKey)		r.insert(CL_KEY_SHIFT);
+	if (m &amp; optionKey)		r.insert(CL_KEY_OPTION);
+	if (m &amp; controlKey)		r.insert(CL_KEY_CONTROL);
+	if (m &amp; rightShiftKey)	r.insert(CL_KEY_RSHIFT);
+	if (m &amp; rightControlKey)r.insert(CL_KEY_RCONTROL);
+	if (m &amp; cmdKey)			r.insert(CL_KEY_COMMAND);
+	if (m &amp; alphaLock)		r.insert(CL_KEY_CAPSLOCK);
+	//if (m &amp; rightOptionKey)	r.insert([right option key]);
+	return r;
+}
+
+int CL_DisplayWindow_OpenGL::keycode_to_clkey(int keycode)
+{
+	switch (keycode)
+	{
+	case 0:			return CL_KEY_A;
+	case 1:			return CL_KEY_S;
+	case 2:			return CL_KEY_D;
+	case 3:			return CL_KEY_F;
+	case 4:			return CL_KEY_H;
+	case 5:			return CL_KEY_G;
+	case 6:			return CL_KEY_Z;
+	case 7:			return CL_KEY_X;
+	case 8:			return CL_KEY_C;
+	case 9:			return CL_KEY_V;
+	case 11:		return CL_KEY_B;
+	case 12:		return CL_KEY_Q;
+	case 13:		return CL_KEY_W;
+	case 14:		return CL_KEY_E;
+	case 15:		return CL_KEY_R;
+	case 17:		return CL_KEY_T;
+	case 16:		return CL_KEY_Y;
+	case 18:		return CL_KEY_1;
+	case 19:		return CL_KEY_2;
+	case 20:		return CL_KEY_3;
+	case 21:		return CL_KEY_4;
+	case 22:		return CL_KEY_6;
+	case 23:		return CL_KEY_5;
+	case 24:		return CL_KEY_EQUALS;
+	case 25:		return CL_KEY_9;
+	case 26:		return CL_KEY_7;
+	case 27:		return CL_KEY_SUBTRACT;
+	case 28:		return CL_KEY_8;
+	case 29:		return CL_KEY_0;
+	// case 30:		return CL_KEY_UMLAU; // key next to key next to P  ??
+	case 31:		return CL_KEY_O;
+	case 32:		return CL_KEY_U;
+	// case 33:		return CL_KEY_AA; // key next to P  ??
+	case 34:		return CL_KEY_I;
+	case 35:		return CL_KEY_P;
+	case 36:		return CL_KEY_ENTER;
+	case 37:		return CL_KEY_L;
+	case 38:		return CL_KEY_J;
+	case 39:		return CL_KEY_QUOTE;
+	case 40:		return CL_KEY_K;
+	case 41:		return CL_KEY_SEMICOLON;
+	case 43:		return CL_KEY_COMMA;
+	case 44:		return CL_KEY_DIVIDE;
+	case 45:		return CL_KEY_N;
+	case 46:		return CL_KEY_M;
+	case 47:		return CL_KEY_PERIOD;
+	case 48:		return CL_KEY_TAB;
+	case 49:		return CL_KEY_SPACE;
+	case 50:		return CL_KEY_TILDE;
+	case 51:		return CL_KEY_BACKSPACE;
+	case 53:		return CL_KEY_ESCAPE;
+	case 65:		return CL_KEY_NUMPAD_DECIMAL;
+	case 67:		return CL_KEY_NUMPAD_MULTIPLY;
+	case 69:		return CL_KEY_NUMPAD_ADD;
+	case 75:		return CL_KEY_NUMPAD_DIVIDE;
+	case 76:		return CL_KEY_NUMPAD_ENTER;
+	case 78:		return CL_KEY_NUMPAD_SUBTRACT;
+	case 82:		return CL_KEY_NUMPAD_0;
+	case 83:		return CL_KEY_NUMPAD_1;
+	case 84:		return CL_KEY_NUMPAD_2;
+	case 85:		return CL_KEY_NUMPAD_3;
+	case 86:		return CL_KEY_NUMPAD_4;
+	case 87:		return CL_KEY_NUMPAD_5;
+	case 88:		return CL_KEY_NUMPAD_6;
+	case 89:		return CL_KEY_NUMPAD_7;
+	case 91:		return CL_KEY_NUMPAD_8;
+	case 92:		return CL_KEY_NUMPAD_9;
+	case 96:		return CL_KEY_F5;
+	case 97:		return CL_KEY_F6;
+	case 98:		return CL_KEY_F7;
+	case 99:		return CL_KEY_F3;
+	case 100:		return CL_KEY_F8;
+	case 101:		return CL_KEY_F9;
+	case 109:		return CL_KEY_F10;
+	case 111:		return CL_KEY_F12;
+	case 115:		return CL_KEY_HOME;
+	case 116:		return CL_KEY_PAGE_UP;
+	case 118:		return CL_KEY_F4;
+	case 119:		return CL_KEY_END;
+	case 120:		return CL_KEY_F2;
+	case 121:		return CL_KEY_PAGE_DOWN;
+	case 122:		return CL_KEY_F1;
+	case 123:		return CL_KEY_LEFT;
+	case 124:		return CL_KEY_RIGHT;
+	case 125:		return CL_KEY_DOWN;
+	case 126:		return CL_KEY_UP;
+	default:		return keycode + 0x10000;
+	}
+}
+
+OSStatus CL_DisplayWindow_OpenGL::on_window_event(EventHandlerCallRef call_ref, EventRef event_ref, void *user_data)
+{
+	CL_DisplayWindow_OpenGL *self = (CL_DisplayWindow_OpenGL *) user_data;
+
+	OSStatus result = CallNextEventHandler(call_ref, event_ref);
+
+	UInt32 event_class = GetEventClass(event_ref);
+	UInt32 event_kind = GetEventKind(event_ref);
+	
+	if (event_class == kEventClassKeyboard)
+	{
+		Point mouse_pos;
+		UInt32 key_modifiers = 0;
+		UInt32 click_count = 0;
+		UInt32 key_code = 0;
+                
+		// Todo:
+		// KeyboardLayoutRef layout;
+		// KLGetCurrentKeyboardLayout(&amp;layout);
+		// KLGetKeyboardLayoutProperty(layout, kKLuchrData, &amp;data);
+		// call UCKeyTranslate to get unicode string for keys being pressed.
+
+		GetMouse(&amp;mouse_pos);
+		GetEventParameter(event_ref, kEventParamKeyModifiers, typeUInt32, 0, sizeof(UInt32), 0, &amp;key_modifiers);
+		GetEventParameter(event_ref, kEventParamKeyCode, typeUInt32, 0, sizeof(UInt32), 0, &amp;key_code);
+		GetEventParameter(event_ref, kEventParamClickCount, typeUInt32, 0, sizeof(UInt32), 0, &amp;click_count);
+
+		if (!self-&gt;fullscreen) {
+			Rect wbounds;
+			GetWindowBounds(self-&gt;window_ref, kWindowContentRgn, &amp;wbounds);
+			mouse_pos.h -= wbounds.left;
+			mouse_pos.v -= wbounds.top;
+		}
+
+		static unsigned long state = 0;
+		static Ptr keymap = nil;
+		Ptr new_keymap;
+
+		// Get the current keyboard map resource
+		new_keymap = (Ptr)GetScriptManagerVariable(smKCHRCache);
+		if (new_keymap != keymap)
+		{
+			keymap = new_keymap;
+			state = 0;
+		}
+
+		CL_InputEvent event;
+		event.str = KeyTranslate(keymap, key_code|key_modifiers, &amp;state) &amp; 0xffff;
+		event.device = self-&gt;keyboard;
+		event.mouse_pos = CL_Point(mouse_pos.h, mouse_pos.v);
+		event.repeat_count = click_count;
+
+		self-&gt;mouse_pos = event.mouse_pos; // if kEventParamMouseLocation is not valid here, reverse this.
+		
+		switch (event_kind)
+		{
+		case kEventRawKeyModifiersChanged:
+			{
+				std::set&lt;int&gt; current_keys = modifiercode_to_clkeys(key_modifiers);
+				for (std::set&lt;int&gt;::iterator i=current_keys.begin(); i!=current_keys.end(); i++)
+				{
+					if (!self-&gt;prev_modifier_keys.count(*i))
+					{
+						event.id = *i;
+						event.type = CL_InputEvent::pressed;
+						self-&gt;keyboard.sig_key_down().call(event);
+					}
+				}
+				for (std::set&lt;int&gt;::iterator i=self-&gt;prev_modifier_keys.begin(); i!=self-&gt;prev_modifier_keys.end(); i++)
+				{
+					if (!current_keys.count(*i))
+					{
+						event.id = *i;
+						event.type = CL_InputEvent::released;
+						self-&gt;keyboard.sig_key_up().call(event);
+					}
+				}
+				self-&gt;prev_modifier_keys = current_keys;
+				return noErr;
+			}
+		
+		case kEventRawKeyDown:
+			// first tests for cmd-q(12) or cmd-w(13) to close the window if needed
+			if ((key_modifiers &amp; cmdKey) &amp;&amp; (key_code==12 || key_code==13))
+			{
+				EventRef close_event;
+				CreateEvent(NULL, kEventClassWindow, kEventWindowClose, 0, kEventAttributeNone, &amp;close_event);
+				EventTargetRef target = GetWindowEventTarget(self-&gt;window_ref);
+				SendEventToEventTarget(close_event, target);
+				return noErr;
+			}
+			else
+			{
+				event.id = keycode_to_clkey(key_code);
+				event.type = CL_InputEvent::pressed;
+				self-&gt;keyboard.sig_key_down().call(event);
+				return noErr;
+			}
+			
+		case kEventRawKeyRepeat:
+			event.id = keycode_to_clkey(key_code);
+			event.type = CL_InputEvent::pressed;
+			self-&gt;keyboard.sig_key_down().call(event);
+			return noErr;
+			
+		case kEventRawKeyUp:
+			event.id = keycode_to_clkey(key_code);
+			event.type = CL_InputEvent::released;
+			self-&gt;keyboard.sig_key_up().call(event);
+			return noErr;
+		}
+	}
+	else if (event_class == kEventClassMouse)
+	{
+		Point mouse_pos;
+		EventMouseButton mouse_button;
+		UInt32 key_modifiers = 0;
+
+		GetEventParameter(event_ref, kEventParamMouseLocation, typeQDPoint, 0, sizeof(Point), 0, &amp;mouse_pos);
+		GetEventParameter(event_ref, kEventParamMouseButton, typeMouseButton, 0, sizeof(EventMouseButton), 0, &amp;mouse_button);
+		GetEventParameter(event_ref, kEventParamKeyModifiers, typeUInt32, 0, sizeof(UInt32), 0, &amp;key_modifiers);
+				
+		if (!self-&gt;fullscreen) {
+			Rect wbounds;
+			GetWindowBounds(self-&gt;window_ref, kWindowContentRgn, &amp;wbounds);
+			mouse_pos.h -= wbounds.left;
+			mouse_pos.v -= wbounds.top;
+		}
+
+		CL_InputEvent event;
+		event.id = mouse_button-1;
+		event.device = self-&gt;mouse;
+		event.mouse_pos = CL_Point(mouse_pos.h, mouse_pos.v);
+
+		// Simulate second mouse button.
+		if ((key_modifiers &amp; controlKey) &amp;&amp; (event.id == CL_MOUSE_LEFT))
+			event.id = CL_MOUSE_RIGHT;
+
+		self-&gt;mouse_pos = event.mouse_pos;
+
+		switch (event_kind)
+		{
+		case kEventMouseDown:
+			self-&gt;mouse_states[event.id] = true;
+			event.type = CL_InputEvent::pressed;
+			self-&gt;mouse.sig_key_down().call(event);
+			return noErr;
+			
+		case kEventMouseUp:
+			self-&gt;mouse_states[event.id] = false;
+			event.type = CL_InputEvent::released;
+			self-&gt;mouse.sig_key_up().call(event);
+			return noErr;
+			
+		case kEventMouseMoved:
+		case kEventMouseDragged:
+			self-&gt;mouse.sig_pointer_move().call(event);
+			return noErr;
+
+		case kEventMouseWheelMoved:
+			//Note, this is not properly handling large quick wheel movements, but the implementation on other
+			//platforms don't seem to either so I will do it their way for consistancy - mrfun
+			
+			EventMouseWheelAxis axis;
+			GetEventParameter(event_ref, kEventParamMouseWheelAxis, typeMouseWheelAxis, NULL, sizeof(axis), NULL, &amp;axis);
+
+			if (axis == kEventMouseWheelAxisY)
+			{
+			
+			long wheel_delta = 0;
+			GetEventParameter(event_ref, kEventParamMouseWheelDelta, typeLongInteger, 0, sizeof(long), 0, &amp;wheel_delta);
+			
+			//Ok, let me explain this bIgnoreThisOne thing.  We are being passed two identical wheel events for every wheel movement -
+			//This behavior is also in the apple example app GLCarbonAGLWindow and I can't figure out a way to get it to send only one
+			//event or a difference in the events. (like a press and release tag differentiating them)
+
+			//So the hack solution is to simply ignore every other mouse wheel event.  This way, programs behave the same on every
+			//platform instead of wheel zooming being twice as fast on macs.
+
+			//If anybody has a better solution or finds a problem here please feel free to dig in. -mrfun
+			
+			static bool bIgnoreThisOne = true;
+			bIgnoreThisOne = !bIgnoreThisOne;
+			
+			if (bIgnoreThisOne)
+				if (wheel_delta)
+				{
+					if (wheel_delta &gt; 0)
+					{
+						event.id = CL_MOUSE_WHEEL_UP;
+					} else
+					{
+						event.id = CL_MOUSE_WHEEL_DOWN;
+					}
+			
+					//sending both the down and up event, like the linux version
+					event.type = CL_InputEvent::pressed;
+					self-&gt;mouse.sig_key_down().call(event);
+					event.type = CL_InputEvent::released;
+					self-&gt;mouse.sig_key_up().call(event);
+				} else
+				{
+				//handle the X axis someday?
+				}
+			}
+			
+			return noErr;
+		}
+	}
+	else if (event_class == kEventClassWindow)
+	{
+		switch (event_kind)
+		{
+		case kEventWindowCollapsing:
+			break;
+
+		case kEventWindowDrawContent:
+			{
+				if (!self-&gt;fullscreen) 
+				{
+					Rect rectPort;
+					GetWindowPortBounds(self-&gt;window_ref, &amp;rectPort);
+					self-&gt;sig_paint(
+						CL_Rect(
+							rectPort.left,
+							rectPort.top,
+							rectPort.right,
+							rectPort.bottom));
+				}
+			}
+			break;
+			
+		case kEventWindowShown: // called on initial show (not on un-minimize)
+			break;
+			
+		case kEventWindowClose:
+			self-&gt;sig_window_close();
+			return noErr;
+
+		case kEventWindowActivated:
+		case kEventWindowFocusAcquired:
+			self-&gt;focus = true;
+			self-&gt;sig_got_focus();
+			return noErr;
+			
+		case kEventWindowDeactivated:
+		case kEventWindowFocusRelinquish:
+			self-&gt;focus = false;
+			self-&gt;sig_lost_focus();
+			return noErr;
+			
+		case kEventWindowBoundsChanged:
+			{
+				if (!self-&gt;fullscreen) {
+					Rect rectPort;
+					GetWindowPortBounds (self-&gt;window_ref, &amp;rectPort);
+					self-&gt;set_size(rectPort.right-rectPort.left, rectPort.bottom-rectPort.top);
+				}
+			}
+			return noErr;
+			
+		case kEventWindowZoomed:
+			// when maximized, but kEventWindowBoundsChanged is also called
+			break;
+		}
+	}
+
+	return result;
+}

Added: trunk/clanlib/GL/AGL/display_window_opengl.h
===================================================================
--- trunk/clanlib/GL/AGL/display_window_opengl.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/AGL/display_window_opengl.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,229 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_display_window_opengl
+#define header_display_window_opengl
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;map&gt;
+#include &lt;stack&gt;
+#include &lt;set&gt;
+
+#include &quot;API/Core/System/keep_alive.h&quot;
+
+#include &quot;API/Display/graphic_context.h&quot;
+#include &quot;API/Display/pixel_buffer.h&quot;
+#include &quot;API/Display/input_device.h&quot;
+#include &quot;API/Display/input_context.h&quot;
+#include &quot;API/Display/display_window_description.h&quot;
+
+#include &quot;Display/display_window_generic.h&quot;
+
+#include &lt;AGL/agl.h&gt;
+#include &lt;OpenGL/gl.h&gt;
+#include &lt;OpenGL/glu.h&gt;
+#include &lt;OpenGL/glext.h&gt;
+
+class CL_DisplayWindow_OpenGL : public CL_DisplayWindow_Generic, CL_KeepAlive
+{
+//! Construction:
+public:
+	CL_DisplayWindow_OpenGL();
+
+	virtual ~CL_DisplayWindow_OpenGL();
+
+//! Attributes:
+public:
+	//: Returns the width of this window.
+	virtual int get_width() const;
+
+	//: Returns the height of this window.
+	virtual int get_height() const;
+
+	//: Returns true if fullscreen window.
+	virtual bool is_fullscreen() const;
+
+	//: Returns true if window got focus.
+	virtual bool has_focus() const;
+
+	//: Returns pixelbuffer interfaces for flipping buffers.
+	virtual CL_PixelBuffer get_buffer(int i) const;
+
+	//: Returns the amount of flipping buffers.
+	virtual int get_buffer_count() const;
+
+	//: Returns the graphic context of this window.
+	virtual CL_GraphicContext *get_gc();
+
+	//: Returns the input context of this window.
+	virtual CL_InputContext *get_ic() { return &amp;input_context; }
+
+	//: Returns the maximum size of a surface this displaywindow supports.
+	CL_Size get_max_surface_size() const;
+	
+	//: Returns the AGLDrawable for this window.
+	AGLDrawable get_drawable() { return GetWindowPort(window_ref); }
+	
+	//: Returns the window handle.
+	WindowRef get_window_ref() { return window_ref; }
+
+	//: Returns the AGL rendering context for this window.
+	AGLContext get_context() { return context; }
+
+	//: Input context for all input devices associated with this window.
+	CL_InputContext input_context;
+
+	//: Input device for the keyboard.
+	CL_InputDevice keyboard;
+
+	//: Input device for the mouse.
+	CL_InputDevice mouse;
+
+	//: Converts a MacOSX keycode into a CL_KEY_XX.
+	static int keycode_to_clkey(int keycode);
+
+	//: Converts a MacOSX modifier keycode into a CL_KEY_XX.
+	static std::set&lt;int&gt; modifiercode_to_clkeys(int modifiercode);
+
+	//: Converts a CL_KEY_XX to a MacOSX keycode.
+	static int clkey_to_keycode(int clkey);	
+
+	//: State information about misc key modifiers.
+	bool left_ctrl_down, left_alt_down, left_shift_down;
+	bool right_ctrl_down, right_alt_down, right_shift_down;
+
+	//: handle of the first created context. Used for sharing
+	//: textures and display lists between rendering contexts.
+	static AGLContext share_context;
+
+	// Current mouse position
+	CL_Point mouse_pos;
+
+	// Current mouse button states
+	bool mouse_states[5];
+
+//! Operations:
+public:
+	//: Set window to fullscreen.
+	virtual void set_fullscreen(int width, int height, int bpp, int refresh_rate);
+
+	//: Restore to windowed mode.
+	virtual void set_windowed();
+
+	//: Change title on window.
+	virtual void set_title(const std::string &amp;title);
+
+	//: Set window position and size.
+	virtual void set_position(const CL_Rect &amp;pos);
+
+	//: Set window position.
+	virtual void set_position(int x, int y);
+
+	//: Set window size.
+	virtual void set_size(int width, int height);
+
+	//: Change the buffer count in the flipping system.
+	virtual void set_buffer_count(int flipping_buffers);
+
+	//: Copy a region of the backbuffer to the frontbuffer.
+	virtual void update(const CL_Rect &amp;rect);
+
+	//: Flip the backbuffer to front.
+	virtual void flip(int interval);
+
+	//: Make system cursor visible over window.
+	virtual void show_system_cursor();
+
+	//: Make system cursor invisible over window.
+	virtual void hide_system_cursor();
+
+	//: Create a window.
+	virtual void create_window(const CL_DisplayWindowDescription &amp;desc);
+
+	//: Called by ClanLib keep alive pump.
+	virtual void keep_alive();
+
+//! Signals:
+public:
+
+//! Implementation:
+private:
+	//: Signal that a new cursor CL_Sprite is available
+	void cursor_changed();
+
+	//: Destroy current window handles.
+	void destroy_window();
+	
+	//: Event handler for window.
+	static OSStatus on_window_event(EventHandlerCallRef call_ref, EventRef event_ref, void *user_data);
+
+	void install_event_handler(EventTargetRef targ_ref, int remove_only=0);
+	
+	//: True if currently in full screen mode.
+	bool fullscreen;
+
+	//: Width and height, if in full screen mode.
+	int fullscreen_width, fullscreen_height;
+
+	//: Saved position of window when going fullscreen. This is the
+	//: position the window receives when leaving fullscreen again.
+	CL_Rect saved_position;
+
+	// OpenGL compatible gc.
+	CL_GraphicContext gc;
+
+	//: AGL rendering context handle.
+	AGLContext context;
+	
+	//: Window mode context.
+	AGLContext win_context;
+	
+	//: Fullscreen context.
+	AGLContext fs_context;
+	
+	//: Window reference.
+	WindowRef window_ref;
+	
+	//: Target for EventDispatcher
+	EventTargetRef target_ref;
+	
+	static int disp_ref_count;
+
+	//: Whether we have window focus or not
+	bool focus;
+	
+	//: The previous state of the modifier keys
+	std::set&lt;int&gt; prev_modifier_keys;
+};
+
+#endif
+

Added: trunk/clanlib/GL/AGL/input_device_mackeyboard.cpp
===================================================================
--- trunk/clanlib/GL/AGL/input_device_mackeyboard.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/AGL/input_device_mackeyboard.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,251 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &lt;cstdio&gt;
+#include &quot;API/Display/input_device.h&quot;
+#include &quot;API/Display/input_event.h&quot;
+#include &quot;API/Display/keys.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;input_device_mackeyboard.h&quot;
+#include &quot;display_window_opengl.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_MacKeyboard construction:
+
+CL_InputDevice_MacKeyboard::CL_InputDevice_MacKeyboard(CL_DisplayWindow_OpenGL *owner) :
+	owner(owner)
+{
+	type = CL_InputDevice::keyboard;
+
+//	slot_xevent = owner-&gt;sig_xevent.connect(
+//		this, &amp;CL_InputDevice_MacKeyboard::on_xevent);
+}
+
+CL_InputDevice_MacKeyboard::~CL_InputDevice_MacKeyboard()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_MacKeyboard attributes:
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_MacKeyboard operations:
+
+std::string CL_InputDevice_MacKeyboard::get_key_name(int virtual_key) const
+{
+	switch (virtual_key)
+	{
+	case CL_KEY_A:				return &quot;A&quot;;
+	case CL_KEY_S:				return &quot;S&quot;;
+	case CL_KEY_D:				return &quot;D&quot;;
+	case CL_KEY_F:				return &quot;F&quot;;
+	case CL_KEY_H:				return &quot;H&quot;;
+	case CL_KEY_G:				return &quot;G&quot;;
+	case CL_KEY_Z:				return &quot;Z&quot;;
+	case CL_KEY_X:				return &quot;X&quot;;
+	case CL_KEY_C:				return &quot;C&quot;;
+	case CL_KEY_V:				return &quot;V&quot;;
+	case CL_KEY_B:				return &quot;B&quot;;
+	case CL_KEY_Q:				return &quot;Q&quot;;
+	case CL_KEY_W:				return &quot;W&quot;;
+	case CL_KEY_E:				return &quot;E&quot;;
+	case CL_KEY_R:				return &quot;R&quot;;
+	case CL_KEY_Y:				return &quot;Y&quot;;
+	case CL_KEY_T:				return &quot;T&quot;;
+	case CL_KEY_1:				return &quot;1&quot;;
+	case CL_KEY_2:				return &quot;2&quot;;
+	case CL_KEY_3:				return &quot;3&quot;;
+	case CL_KEY_4:				return &quot;4&quot;;
+	case CL_KEY_6:				return &quot;6&quot;;
+	case CL_KEY_5:				return &quot;5&quot;;
+	case CL_KEY_EQUALS:			return &quot;=&quot;;
+	case CL_KEY_9:				return &quot;9&quot;;
+	case CL_KEY_7:				return &quot;7&quot;;
+	case CL_KEY_SUBTRACT:		return &quot;-&quot;;
+	case CL_KEY_8:				return &quot;8&quot;;
+	case CL_KEY_0:				return &quot;0&quot;;
+	case CL_KEY_O:				return &quot;O&quot;;
+	case CL_KEY_U:				return &quot;U&quot;;
+	case CL_KEY_I:				return &quot;I&quot;;
+	case CL_KEY_P:				return &quot;P&quot;;
+	case CL_KEY_ENTER:			return &quot;Return&quot;;
+	case CL_KEY_L:				return &quot;L&quot;;
+	case CL_KEY_J:				return &quot;J&quot;;
+	case CL_KEY_QUOTE:			return &quot;\'&quot;;
+	case CL_KEY_K:				return &quot;K&quot;;
+	case CL_KEY_SEMICOLON:		return &quot;;&quot;;
+	case CL_KEY_COMMA:			return &quot;,&quot;;
+	case CL_KEY_DIVIDE:			return &quot;/&quot;;
+	case CL_KEY_N:				return &quot;N&quot;;
+	case CL_KEY_M:				return &quot;M&quot;;
+	case CL_KEY_PERIOD:			return &quot;.&quot;;
+	case CL_KEY_TAB:			return &quot;Tab&quot;;
+	case CL_KEY_SPACE:			return &quot;Space&quot;;
+	case CL_KEY_TILDE:			return &quot;~&quot;;
+	case CL_KEY_BACKSPACE:		return &quot;Backspace&quot;;
+	case CL_KEY_ESCAPE:			return &quot;Escape&quot;;
+	case CL_KEY_SHIFT:			return &quot;Shift&quot;;
+	case CL_KEY_MENU:			return &quot;Option&quot;;
+	case CL_KEY_CONTROL:		return &quot;Control&quot;;
+	case CL_KEY_NUMPAD_DECIMAL:	return &quot;Numpad .&quot;;
+	case CL_KEY_NUMPAD_MULTIPLY:return &quot;Numpad *&quot;;
+	case CL_KEY_NUMPAD_ADD:		return &quot;Numpad +&quot;;
+	case CL_KEY_NUMPAD_DIVIDE:	return &quot;Numpad /&quot;;
+	case CL_KEY_NUMPAD_ENTER:	return &quot;Numpad Enter&quot;;
+	case CL_KEY_NUMPAD_SUBTRACT:return &quot;Numpad -&quot;;
+	case CL_KEY_NUMPAD_EQUALS:	return &quot;Numpad =&quot;;
+	case CL_KEY_NUMPAD_0:		return &quot;Numpad 0&quot;;
+	case CL_KEY_NUMPAD_1:		return &quot;Numpad 1&quot;;
+	case CL_KEY_NUMPAD_2:		return &quot;Numpad 2&quot;;
+	case CL_KEY_NUMPAD_3:		return &quot;Numpad 3&quot;;
+	case CL_KEY_NUMPAD_4:		return &quot;Numpad 4&quot;;
+	case CL_KEY_NUMPAD_5:		return &quot;Numpad 5&quot;;
+	case CL_KEY_NUMPAD_6:		return &quot;Numpad 6&quot;;
+	case CL_KEY_NUMPAD_7:		return &quot;Numpad 7&quot;;
+	case CL_KEY_NUMPAD_8:		return &quot;Numpad 8&quot;;
+	case CL_KEY_NUMPAD_9:		return &quot;Numpad 9&quot;;
+	case CL_KEY_F5:				return &quot;F5&quot;;
+	case CL_KEY_F6:				return &quot;F6&quot;;
+	case CL_KEY_F7:				return &quot;F7&quot;;
+	case CL_KEY_F3:				return &quot;F3&quot;;
+	case CL_KEY_F8:				return &quot;F8&quot;;
+	case CL_KEY_F9:				return &quot;F9&quot;;
+	case CL_KEY_F10:			return &quot;F10&quot;;
+	case CL_KEY_F12:			return &quot;F12&quot;;
+	case CL_KEY_HOME:			return &quot;Home&quot;;
+	case CL_KEY_PAGE_UP:		return &quot;Page Up&quot;;
+	case CL_KEY_DELETE:			return &quot;Delete&quot;;
+	case CL_KEY_F4:				return &quot;F4&quot;;
+	case CL_KEY_END:			return &quot;End&quot;;
+	case CL_KEY_F2:				return &quot;F2&quot;;
+	case CL_KEY_PAGE_DOWN:		return &quot;Page Down&quot;;
+	case CL_KEY_F1:				return &quot;F1&quot;;
+	case CL_KEY_LEFT:			return &quot;Left&quot;;
+	case CL_KEY_RIGHT:			return &quot;Right&quot;;
+	case CL_KEY_DOWN:			return &quot;Down&quot;;
+	case CL_KEY_UP:				return &quot;Up&quot;;
+	case CL_KEY_RSHIFT:			return &quot;RShift&quot;;
+	case CL_KEY_RCONTROL:		return &quot;RControl&quot;;
+	case CL_KEY_COMMAND:		return &quot;Command&quot;;
+	case CL_KEY_CAPSLOCK:		return &quot;Caps Lock&quot;;
+	default:					return CL_String::format(&quot;Unknown %1&quot;, virtual_key);
+	}
+}
+
+bool CL_InputDevice_MacKeyboard::get_keycode(int clkey) const
+{
+	// Ignore all key events when we don't have focus
+	if(!owner-&gt;has_focus())
+		return false;
+
+	int code = CL_DisplayWindow_OpenGL::clkey_to_keycode(clkey);
+	if (code &lt; 0 || code &gt;= 128)
+		return false;
+
+	KeyMap key_map;
+	GetKeys(key_map);
+	unsigned char *k = (unsigned char *) key_map;
+	return k[code/8] &amp; (1 &lt;&lt; (code%8));
+}
+
+float CL_InputDevice_MacKeyboard::get_axis(int index) const
+{
+	return 0.0f;
+}
+
+std::string CL_InputDevice_MacKeyboard::get_name() const
+{
+	return &quot;System Keyboard&quot;;
+}
+
+int CL_InputDevice_MacKeyboard::get_axis_count() const
+{
+	return 0;
+}
+
+int CL_InputDevice_MacKeyboard::get_button_count() const
+{
+	return -1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_MacKeyboard implementation:
+/*
+void CL_InputDevice_MacKeyboard::on_xevent(XEvent &amp;event)
+{
+	// Only handle keyboard events.
+	if (event.type != KeyPress &amp;&amp; event.type != KeyRelease) return;
+
+	// Figure out what key it was:
+	KeySym sym = XLookupKeysym(&amp;event.xkey, 0);
+
+	// set state of modifier keys
+	bool key_state = false;
+	if (event.type == KeyPress)
+		key_state = true;
+	
+	switch(sym)
+	{
+		case CL_KEY_LCONTROL: owner-&gt;left_ctrl_down = key_state; break;
+		case CL_KEY_LMENU: owner-&gt;left_alt_down = key_state; break;
+		case CL_KEY_LSHIFT: owner-&gt;left_shift_down = key_state; break;
+		case CL_KEY_RCONTROL: owner-&gt;right_ctrl_down = key_state; break;
+		case CL_KEY_RMENU: owner-&gt;right_alt_down = key_state; break;
+		case CL_KEY_RSHIFT: owner-&gt;right_shift_down = key_state; break;
+	}
+	
+	// Setup event structure for ClanLib:
+	CL_InputEvent key;
+	key.type = CL_InputEvent::released;
+	if (event.type == KeyPress) key.type = CL_InputEvent::pressed;
+	key.id = sym;
+	key.device = owner-&gt;keyboard;
+	key.repeat_count = 0;
+	key.left_alt = owner-&gt;left_alt_down;
+	key.left_ctrl = owner-&gt;left_ctrl_down;
+	key.left_shift = owner-&gt;left_shift_down;
+	key.right_alt = owner-&gt;right_alt_down;
+	key.right_ctrl = owner-&gt;right_ctrl_down;
+	key.right_shift = owner-&gt;right_shift_down;
+	
+	// Need to somehow get proper character sequence from X11. This code
+	// wont keep proper track of deadkeys:
+	char buf[11];
+	buf[10] = 0;
+	XLookupString(&amp;event.xkey, buf, 10, 0, 0);
+	if (strlen(buf) &gt; 0) key.str = std::string(buf, 1);
+
+	// Emit it.
+	if (key.type == CL_InputEvent::pressed)
+		owner-&gt;keyboard.sig_key_down().call(key);
+	else
+		owner-&gt;keyboard.sig_key_up().call(key);
+}
+*/

Added: trunk/clanlib/GL/AGL/input_device_mackeyboard.h
===================================================================
--- trunk/clanlib/GL/AGL/input_device_mackeyboard.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/AGL/input_device_mackeyboard.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,79 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_input_device_mackeyboard
+#define header_input_device_mackeyboard
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;Display/input_device_generic.h&quot;
+#include &quot;API/signals.h&quot;
+
+class CL_DisplayWindow_OpenGL;
+
+class CL_InputDevice_MacKeyboard : public CL_InputDevice_Generic
+{
+//!Construction:
+public:
+	CL_InputDevice_MacKeyboard(CL_DisplayWindow_OpenGL *owner);
+
+	virtual ~CL_InputDevice_MacKeyboard();
+
+//!Attributes:
+public:
+
+//!Operations:
+public:
+	//: Key name for specified identifier (A, B, C, Space, Enter, Backspace).
+	std::string get_key_name(int id) const;
+  
+	//: Returns true if the passed key code is down for this device.
+	bool get_keycode(int keycode) const;
+
+	//: Returns the the current position of a joystick axis.
+	virtual float get_axis(int index) const;
+
+	//: Returns the name of the device (i.e. 'Microsoft Sidewinder 3D').
+	virtual std::string get_name() const;
+
+	//: Returns the number of axes available on this device.
+	virtual int get_axis_count() const;
+
+	//: Returns the number of buttons available on this device.
+	//- &lt;p&gt;If used on a keyboard, this function returns -1.&lt;/p&gt;
+	virtual int get_button_count() const;
+
+//!Implementation:
+private:
+	CL_DisplayWindow_OpenGL *owner;
+};
+
+#endif

Added: trunk/clanlib/GL/AGL/input_device_macmouse.cpp
===================================================================
--- trunk/clanlib/GL/AGL/input_device_macmouse.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/AGL/input_device_macmouse.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,118 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &lt;cstdio&gt;
+
+#include &quot;API/Display/input_device.h&quot;
+#include &quot;API/Display/input_event.h&quot;
+#include &quot;input_device_macmouse.h&quot;
+
+#include &quot;../../GL/AGL/display_window_opengl.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_MacMouse construction:
+
+CL_InputDevice_MacMouse::CL_InputDevice_MacMouse(CL_DisplayWindow_OpenGL *owner) :
+	owner(owner)
+{
+	type = CL_InputDevice::mouse;
+	
+	for( int i=0; i&lt;5; i++)
+		owner-&gt;mouse_states[i] = false;
+}
+
+CL_InputDevice_MacMouse::~CL_InputDevice_MacMouse()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_MacMouse attributes:
+
+int CL_InputDevice_MacMouse::get_x() const
+{
+	return owner-&gt;mouse_pos.x;
+}
+
+int CL_InputDevice_MacMouse::get_y() const
+{
+	return owner-&gt;mouse_pos.y;
+}
+
+bool CL_InputDevice_MacMouse::get_keycode(int keycode) const
+{
+	if( keycode &gt;= 0 &amp;&amp; keycode &lt; 5 )
+		return owner-&gt;mouse_states[keycode];
+	return false;
+}
+
+float CL_InputDevice_MacMouse::get_axis(int index) const
+{
+	return 0.0f;
+}
+
+std::string CL_InputDevice_MacMouse::get_name() const
+{
+	return &quot;System Mouse&quot;;
+}
+
+int CL_InputDevice_MacMouse::get_axis_count() const
+{
+	return 0;
+}
+
+int CL_InputDevice_MacMouse::get_button_count() const
+{
+	return 1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_MacMouse operations:
+
+std::string CL_InputDevice_MacMouse::get_key_name(int id) const
+{
+	switch (id)
+	{
+	case 0: return &quot;Mouse left&quot;;
+	case 1: return &quot;Mouse right&quot;;
+	case 2: return &quot;Mouse middle&quot;;
+	case 3: return &quot;Mouse wheel up&quot;;
+	case 4: return &quot;Mouse wheel down&quot;;
+	}
+
+	char buf[256];
+	sprintf(buf, &quot;Mouse button %d&quot;, id);
+	return buf;
+}
+
+void CL_InputDevice_MacMouse::set_position(int x, int y)
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_MacMouse implementation:

Added: trunk/clanlib/GL/AGL/input_device_macmouse.h
===================================================================
--- trunk/clanlib/GL/AGL/input_device_macmouse.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/AGL/input_device_macmouse.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,84 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_input_device_macmouse
+#define header_input_device_macmouse
+
+#include &quot;Display/input_device_generic.h&quot;
+#include &quot;API/signals.h&quot;
+#include &quot;API/Core/Math/point.h&quot;
+
+class CL_DisplayWindow_OpenGL;
+
+class CL_InputDevice_MacMouse : public CL_InputDevice_Generic
+{
+//!Construction:
+public:
+	CL_InputDevice_MacMouse(CL_DisplayWindow_OpenGL *owner);
+
+	virtual ~CL_InputDevice_MacMouse();
+
+//!Attributes:
+public:
+	//: Returns the x position of the device.
+	virtual int get_x() const;
+
+	//: Returns the y position of the device.
+	virtual int get_y() const;
+
+	//: Returns true if the passed key code is down for this device.
+	virtual bool get_keycode(int keycode) const;
+
+	//: Returns the the current position of a joystick axis.
+	virtual float get_axis(int index) const;
+
+	//: Returns the name of the device (i.e. 'Microsoft Sidewinder 3D').
+	virtual std::string get_name() const;
+
+	//: Returns the number of axes available on this device.
+	virtual int get_axis_count() const;
+
+	//: Returns the number of buttons available on this device.
+	//- &lt;p&gt;If used on a keyboard, this function returns -1.&lt;/p&gt;
+	virtual int get_button_count() const;
+
+//!Operations:
+public:
+	//: Key name for specified identifier (A, B, C, Space, Enter, Backspace).
+	virtual std::string get_key_name(int id) const;
+
+	//: Sets the position of the device.
+	virtual void set_position(int x, int y);
+
+//!Implementation:
+private:
+	CL_DisplayWindow_OpenGL *owner;
+};
+
+#endif

Added: trunk/clanlib/GL/GLX/display_window_opengl.cpp
===================================================================
--- trunk/clanlib/GL/GLX/display_window_opengl.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/GLX/display_window_opengl.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,860 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &lt;cstdio&gt;
+#include &lt;errno.h&gt;
+
+#include &quot;display_window_opengl.h&quot;
+#include &quot;input_device_linuxjoystick.h&quot;
+#include &quot;input_device_linuxusbmouse.h&quot;
+#include &quot;input_device_linuxevent.h&quot;
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;Display/display_window_generic.h&quot;
+#include &quot;API/Core/System/keep_alive.h&quot;
+#include &quot;API/Core/System/system.h&quot;
+#include &quot;../graphic_context_opengl.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/System/log.h&quot;
+#include &quot;GL/gl_state_checker.h&quot;
+#include &quot;GL/GLX/input_device_x11keyboard.h&quot;
+#include &quot;GL/GLX/input_device_x11mouse.h&quot;
+#include &quot;GL/GLX/input_device_xinput.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/GL/opengl_window_description.h&quot;
+#include &quot;API/GL/opengl_state.h&quot;
+#include &quot;API/GL/opengl_wrap.h&quot;
+#include &quot;../opengl_window_description_generic.h&quot;
+#include &lt;unistd.h&gt;
+#include &lt;X11/extensions/XInput.h&gt;
+
+GLXContext CL_DisplayWindow_OpenGL::share_context = 0;
+
+Display *CL_DisplayWindow_OpenGL::disp = 0;
+
+int CL_DisplayWindow_OpenGL::disp_ref_count = 0;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_DisplayWindow_OpenGL::CL_DisplayWindow_OpenGL() :
+	left_ctrl_down(false), left_alt_down(false), left_shift_down(false),
+	right_ctrl_down(false), right_alt_down(false), right_shift_down(false),
+	fullscreen(false), fullscreen_width(0), fullscreen_height(0),
+	saved_position(0, 0, 0, 0),
+	context(0),
+	window(0)
+{
+	gc = CL_GraphicContext(new CL_GraphicContext_OpenGL(this));
+}
+
+CL_DisplayWindow_OpenGL::~CL_DisplayWindow_OpenGL()
+{
+	if(fullscreen)
+		set_windowed();
+	destroy_window();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+int CL_DisplayWindow_OpenGL::get_width() const
+{
+	XWindowAttributes attr;
+	XGetWindowAttributes(disp, window, &amp;attr);
+
+	return attr.width;
+}
+
+int CL_DisplayWindow_OpenGL::get_height() const
+{
+	XWindowAttributes attr;
+	XGetWindowAttributes(disp, window, &amp;attr);
+
+	return attr.height;
+}
+
+bool CL_DisplayWindow_OpenGL::is_fullscreen() const
+{
+	return fullscreen;
+}
+
+bool CL_DisplayWindow_OpenGL::has_focus() const
+{
+	return focus;
+}
+
+CL_PixelBuffer CL_DisplayWindow_OpenGL::get_buffer(int i) const
+{
+	if (i == 0) 
+	{
+		return gc.get_pixeldata(CL_Rect(0, 0, get_width(), get_height()), CL_FRONT);
+	}
+	else
+	{
+		return gc.get_pixeldata(CL_Rect(0, 0, get_width(), get_height()), CL_BACK);
+	}
+}
+
+int CL_DisplayWindow_OpenGL::get_buffer_count() const
+{
+	return 2;
+}
+
+CL_GraphicContext *CL_DisplayWindow_OpenGL::get_gc()
+{
+	return &gc;
+}
+
+Display *CL_DisplayWindow_OpenGL::get_hwnd()
+{
+	return disp;
+}
+
+CL_Size CL_DisplayWindow_OpenGL::get_max_surface_size() const
+{
+	CLint max_texture_size;
+	clGetIntegerv(CL_MAX_TEXTURE_SIZE, &amp;max_texture_size);
+	return CL_Size(max_texture_size, max_texture_size);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_DisplayWindow_OpenGL::create_window(const CL_DisplayWindowDescription &amp;desc)
+{
+	const CL_OpenGLWindowDescription_Generic *gl_desc = 0;
+	gl_desc = dynamic_cast&lt;const CL_OpenGLWindowDescription_Generic*&gt;(desc.impl.get());
+
+	fullscreen_width  = desc.get_size().width;
+	fullscreen_height = desc.get_size().height;
+
+	XVisualInfo *vi;
+	Colormap cmap;
+
+	if (disp == 0)
+	{
+		disp = XOpenDisplay(0);
+		if (disp == 0) throw CL_Error(&quot;Could not open X11 display!&quot;);
+	}
+	disp_ref_count++;
+
+	int gl_attribs_single[] =
+	{
+		GLX_RGBA,
+		GLX_RED_SIZE, 4,
+		GLX_GREEN_SIZE, 4,
+		GLX_BLUE_SIZE, 4,
+		GLX_DEPTH_SIZE, 16,
+		None
+	};
+
+	int gl_attribs[32];
+	int i = 0;
+	
+	if( gl_desc )
+	{
+		if( gl_desc-&gt;rgba ) gl_attribs[i++] = GLX_RGBA;
+		if( gl_desc-&gt;doublebuffer ) gl_attribs[i++] = GLX_DOUBLEBUFFER;
+		if( gl_desc-&gt;stereo ) gl_attribs[i++] = GLX_STEREO;
+		gl_attribs[i++] = GLX_BUFFER_SIZE;
+		gl_attribs[i++] = gl_desc-&gt;buffer_size;
+		gl_attribs[i++] = GLX_LEVEL;
+		gl_attribs[i++] = gl_desc-&gt;level;
+		gl_attribs[i++] = GLX_AUX_BUFFERS;
+		gl_attribs[i++] = gl_desc-&gt;aux_buffers;
+		gl_attribs[i++] = GLX_RED_SIZE; 
+		gl_attribs[i++] = gl_desc-&gt;red_size;
+		gl_attribs[i++] = GLX_GREEN_SIZE;
+		gl_attribs[i++] = gl_desc-&gt;green_size;
+		gl_attribs[i++] = GLX_BLUE_SIZE;
+		gl_attribs[i++] = gl_desc-&gt;blue_size;
+		gl_attribs[i++] = GLX_DEPTH_SIZE;
+		gl_attribs[i++] = gl_desc-&gt;depth_size;
+		gl_attribs[i++] = GLX_STENCIL_SIZE;
+		gl_attribs[i++] = gl_desc-&gt;stencil_size;
+		gl_attribs[i++] = GLX_ACCUM_RED_SIZE;
+		gl_attribs[i++] = gl_desc-&gt;accum_red_size;
+		gl_attribs[i++] = GLX_ACCUM_GREEN_SIZE;
+		gl_attribs[i++] = gl_desc-&gt;accum_green_size;
+		gl_attribs[i++] = GLX_ACCUM_BLUE_SIZE;
+		gl_attribs[i++] = gl_desc-&gt;accum_blue_size;
+		gl_attribs[i++] = GLX_ACCUM_ALPHA_SIZE;
+		gl_attribs[i++] = gl_desc-&gt;accum_alpha_size;
+		gl_attribs[i++] = GLX_ACCUM_RED_SIZE;
+		gl_attribs[i++] = gl_desc-&gt;accum_red_size;
+		gl_attribs[i++] = None;
+	}
+	else
+	{
+		gl_attribs[i++] = GLX_RGBA;
+		gl_attribs[i++] = GLX_DOUBLEBUFFER;
+		gl_attribs[i++] = GLX_RED_SIZE;
+		gl_attribs[i++] = 4;
+		gl_attribs[i++] = GLX_GREEN_SIZE;
+		gl_attribs[i++] = 4;
+		gl_attribs[i++] = GLX_BLUE_SIZE;
+		gl_attribs[i++] = 4;
+		gl_attribs[i++] = GLX_DEPTH_SIZE;
+		gl_attribs[i++] = 16;
+		gl_attribs[i++] = None;
+	}
+
+	// get an appropriate visual
+	vi = glXChooseVisual(disp, DefaultScreen(disp), gl_attribs);
+	
+	if (vi == NULL)
+	{
+		vi = glXChooseVisual(disp, window, gl_attribs_single);
+		printf(&quot;Requested visual not supported by your OpenGL implementation. Falling back on singlebuffered Visual!\n&quot;);
+	}
+
+	// create a GLX context
+	context = glXCreateContext(disp, vi, share_context, True);
+
+	if( share_context == NULL )
+		share_context = context;
+
+	glXGetConfig(disp, vi, GLX_BUFFER_SIZE, &amp;glx_bpp);
+
+	// create a color map
+	cmap = XCreateColormap( disp, RootWindow(disp, vi-&gt;screen), vi-&gt;visual, AllocNone);
+
+	attributes.colormap = cmap;
+	attributes.border_pixel = 0;
+	attributes.override_redirect = False;
+
+	// create a window in window mode
+	attributes.event_mask =
+		ExposureMask |
+		KeyPressMask |
+		KeyReleaseMask |
+		ButtonPressMask |
+		ButtonReleaseMask |
+		StructureNotifyMask |
+		PointerMotionMask |
+		EnterWindowMask |
+		LeaveWindowMask |
+		FocusChangeMask;
+
+	window = XCreateWindow(disp, RootWindow(disp, vi-&gt;screen),
+		0, 0, desc.get_size().width, desc.get_size().height, 0, vi-&gt;depth, InputOutput, vi-&gt;visual,
+		CWBorderPixel | CWColormap | CWOverrideRedirect | CWEventMask, &amp;attributes);
+	
+	XSelectInput(disp, window,
+		FocusChangeMask | KeyPressMask | KeyReleaseMask
+		| PropertyChangeMask | StructureNotifyMask |
+		KeymapStateMask | ButtonPressMask | ButtonReleaseMask | PointerMotionMask);
+
+	// set title of window:
+	set_title(desc.get_title());
+	
+	// setup size hints:
+	XSizeHints size_hints;
+	memset(&amp;size_hints, 0, sizeof(XSizeHints));
+	size_hints.width       = desc.get_size().width;
+	size_hints.height      = desc.get_size().height;
+	size_hints.base_width  = desc.get_size().width;
+	size_hints.base_height = desc.get_size().height;
+	size_hints.min_width   = size_hints.width;
+	size_hints.min_height  = size_hints.height;
+	size_hints.max_width   = size_hints.width;
+	size_hints.max_height  = size_hints.height;
+	size_hints.flags       = PSize|PBaseSize;
+	if (!desc.get_allow_resize()) size_hints.flags |= PMinSize | PMaxSize;
+	XSetWMNormalHints(disp, window, &amp;size_hints);
+
+	// handle wm_delete_events if in windowed mode:
+	Atom wm_delete = XInternAtom(disp, &quot;WM_DELETE_WINDOW&quot;, True);
+	XSetWMProtocols(disp, window, &amp;wm_delete, 1);
+
+	// make window visible:
+	XMapRaised(disp, window);
+
+	if (!glXIsDirect(disp, context))
+		printf(&quot;No hardware acceleration available. I hope you got a really fast machine..\n&quot;);
+
+	// Create input devices for window:
+	keyboard = CL_InputDevice(new CL_InputDevice_X11Keyboard(this));
+	mouse    = CL_InputDevice(new CL_InputDevice_X11Mouse(this));
+
+	get_ic()-&gt;clear();
+	get_ic()-&gt;add_keyboard(keyboard);
+	get_ic()-&gt;add_mouse(mouse);
+
+	setup_joysticks();
+// 	setup_usb_mice();
+//	setup_xinput();
+//	setup_event();
+
+	XSync(disp, True);
+	
+	focus = true;
+	
+	system_cursor = XCreateFontCursor(disp, XC_left_ptr);
+	char *data = (char*)malloc(64); // 8x8
+	memset(data, 0, 64);
+
+	XColor black_color;
+	memset(&amp;black_color, 0, sizeof(black_color));
+
+	cursor_bitmap = XCreateBitmapFromData(disp, window, data, 8, 8);
+	hidden_cursor = XCreatePixmapCursor(disp, cursor_bitmap, cursor_bitmap, &amp;black_color, &amp;black_color, 0,0 );
+	
+	if (desc.is_fullscreen())
+		set_fullscreen(desc.get_size().width, desc.get_size().height, desc.get_bpp(), desc.get_refresh_rate());
+}
+
+void
+CL_DisplayWindow_OpenGL::setup_event()
+{
+	char pathname[256];
+	bool done = false;
+
+	for(int i = 0; !done; ++i)
+	{
+		snprintf(pathname, sizeof(pathname), &quot;/dev/input/event%d&quot;, i);
+		if (access(pathname, R_OK) == 0)
+		{
+			try
+			{
+				get_ic()-&gt;add_mouse(CL_InputDevice(new CL_InputDevice_LinuxEvent(this, pathname)));
+			}
+			catch (CL_Error&amp; err)
+			{
+				CL_Log::log(&quot;debug&quot;, &quot;EvDev Error: %1&quot;, err.message);
+				done = true;
+			}
+		}
+		else
+		{
+			CL_Log::log(&quot;debug&quot;, &quot;EvDev Error: %1: %2&quot;, pathname, strerror(errno));
+			done = true;
+		}
+	}
+}
+
+void CL_DisplayWindow_OpenGL::setup_usb_mice()
+{
+	char pathname[256];
+	bool done = false;
+
+	for(int i = 0; !done; ++i)
+	{
+		snprintf(pathname, sizeof(pathname), &quot;/dev/input/mouse%d&quot;, i);
+		if (access(pathname, R_OK) == 0)
+		{
+			try
+			{
+				get_ic()-&gt;add_mouse(CL_InputDevice(new CL_InputDevice_LinuxUSBMouse(this, pathname)));
+			}
+			catch (CL_Error&amp; err)
+			{
+				CL_Log::log(&quot;debug&quot;, &quot;Mouse Error: %1&quot;, err.message);
+				done = true;
+			}
+		}
+		else
+		{
+			CL_Log::log(&quot;debug&quot;, &quot;Mouse Error: %1: %2&quot;, pathname, strerror(errno));
+			done = true;
+		}
+	}
+}
+
+void CL_DisplayWindow_OpenGL::setup_joysticks()
+{
+	// This could need some improvments, it doesn't look for
+	// /dev/input/jsX for example
+	char pathname[256];
+	char joydev[256];
+	bool done = false;
+
+	CL_Log::log(&quot;debug&quot;, &quot;Setting up joystick&quot;);
+
+	if (access(&quot;/dev/input/&quot;, R_OK | X_OK) == 0)
+	{
+		strcpy(joydev, &quot;/dev/input/js%d&quot;);
+	} 
+	else
+	{
+		strcpy(joydev, &quot;/dev/js%d&quot;);
+	}
+
+	for(int i = 0; !done; ++i)
+	{
+		snprintf(pathname, sizeof(pathname), joydev, i);
+		
+		if (access(pathname, R_OK) == 0)
+		{
+			try
+			{
+				get_ic()-&gt;add_joystick(CL_InputDevice(new CL_InputDevice_LinuxJoystick(pathname)));
+			} 
+			catch (CL_Error&amp; err)
+			{
+				CL_Log::log(&quot;debug&quot;, &quot;Joystick Error: %1&quot;, err.message);
+				done = true;
+			}
+		}
+		else
+		{
+			CL_Log::log(&quot;debug&quot;, &quot;Joystick Error: %1: %2&quot;, pathname, strerror(errno));
+			done = true;
+		}
+	}
+}
+
+
+Bool
+CL_DisplayWindow_OpenGL::xinput_is_present()
+{
+	XExtensionVersion	*version;
+	Bool		present;
+    
+	version = XGetExtensionVersion(disp, INAME);
+
+	if (version &amp;&amp; (version != (XExtensionVersion*) NoSuchExtension)) {
+		present = version-&gt;present;
+		XFree(version);
+		return present;
+	} else {
+		return False;
+	}
+}
+
+void
+CL_DisplayWindow_OpenGL::setup_xinput()
+{
+	if (!xinput_is_present())
+	{
+		CL_Log::log(&quot;debug&quot;, &quot;XInput extentsion not found&quot;);
+	}
+	else
+	{
+		XDeviceInfo		*info;
+		int			loop;
+
+		int		num_devices;
+    
+		info = XListInputDevices(disp, &amp;num_devices);
+	
+		for(loop=0; loop&lt;num_devices; loop++) {
+			// FIXME: Xinput isn't necesarrily a mouse, could be anything
+			if (info[loop].use == IsXExtensionDevice)
+			{
+				get_ic()-&gt;add_mouse(CL_InputDevice(new CL_InputDevice_XInput(this, info + loop)));
+			}
+		}
+	}
+}
+
+void CL_DisplayWindow_OpenGL::destroy_window()
+{
+	set_windowed();
+
+	if (context)
+	{
+		if (!glXMakeCurrent(disp, None, NULL))
+		{
+			printf(&quot;Could not release drawing context.\n&quot;);
+		}
+
+		glXDestroyContext(disp, context);
+		context = NULL;
+	}
+
+	keyboard = CL_InputDevice();
+	mouse = CL_InputDevice();
+	get_ic()-&gt;clear();
+
+	if (window) XDestroyWindow(disp, window);
+	window = 0;
+	
+	if (disp_ref_count &gt; 0)
+	{
+		disp_ref_count--;
+		if (disp_ref_count == 0)
+		{
+			XCloseDisplay(disp);
+			disp = 0;
+		}
+	}
+}
+
+void CL_DisplayWindow_OpenGL::on_xevent(XEvent &amp;event)
+{
+	//Disabled for now
+}
+
+void CL_DisplayWindow_OpenGL::flip(int interval)
+{
+	CL_GLStateChecker::from_gc(get_gc())-&gt;flush();
+	
+	if (interval != -1)
+	{
+		typedef int (*ptr_glXSwapIntervalSGI)(int interval);
+		ptr_glXSwapIntervalSGI glXSwapIntervalSGI = (ptr_glXSwapIntervalSGI) CL_OpenGL::get_proc_address(&quot;glXSwapIntervalSGI&quot;);
+		if (glXSwapIntervalSGI)
+		{
+			glXSwapIntervalSGI(interval);
+		}
+	}
+	
+	XSync(disp,False);
+	glXSwapBuffers(disp, window);
+}
+
+void CL_DisplayWindow_OpenGL::set_fullscreen(int width, int height, int bpp, int refresh_rate)
+{
+	if(fullscreen)
+		return;
+
+	// Vid-mode Switching
+	XF86VidModeModeLine cur_mode;
+
+	XF86VidModeGetModeLine(disp, 0, &amp;dotclock, &amp;cur_mode);
+
+	old_mode.dotclock   = dotclock;
+	old_mode.hdisplay   = cur_mode.hdisplay;
+	old_mode.hsyncstart = cur_mode.hsyncstart;
+	old_mode.hsyncend   = cur_mode.hsyncend;
+	old_mode.htotal     = cur_mode.htotal;
+	old_mode.vdisplay   = cur_mode.vdisplay;
+	old_mode.vsyncstart = cur_mode.vsyncstart;
+	old_mode.vsyncend   = cur_mode.vsyncend;
+	old_mode.vtotal     = cur_mode.vtotal;
+	old_mode.flags      = cur_mode.flags;
+	old_mode.privsize   = 0;
+
+	int num_modes;
+	XF86VidModeModeInfo **modes;
+	XF86VidModeGetAllModeLines(disp, 0, &amp;num_modes, &amp;modes);
+
+	std::list&lt;XF86VidModeModeInfo *&gt; usable_modes;
+	for(int i = 0; i &lt; num_modes; i++)
+	{
+		if(modes[i]-&gt;hdisplay == width &amp;&amp; modes[i]-&gt;vdisplay == height)
+		{
+			CL_Log::log(&quot;debug&quot;, &quot;Useable fullscreen mode found: %1x%2&quot;, width, height);
+			usable_modes.push_back(modes[i]);
+		}
+	}
+	
+	if (usable_modes.empty())
+	{
+		CL_Log::log(&quot;debug&quot;, &quot;No useable fullscreen modes available!&quot;);
+	}
+	else 
+	{	
+		if(!width)
+			width = get_width();
+
+		if(!height)
+			height = get_height();
+	
+		if(!bpp)
+			bpp = glx_bpp;
+
+		//Hide Window
+		if (0)
+		{  // FIXME: allow_override doesn't play together with
+			// GrabPointer, not sure what is wrong but it simply doesn't
+			// work.
+			//
+			// The code outside the 'if(0)' as it is now, works mostly,
+			// however it doesn't work when the window or a part of it is
+			// outside of the screen, since the window isn't moved
+			// fullscreen will only show half the window, shouldn't be a
+			// problem for most of the time, but will be tricky if the
+			// window has equal size as the desktop.
+
+			// Move the window into the right position, this must happen
+			// BEFORE we remove control from the window manager
+			XMoveResizeWindow(disp, window, 0, 0, width, height);
+
+			// Move the mouse and switch moves
+			XWarpPointer(disp, None, None, 0, 0, 0, 0, width/2, height/2);
+
+			XUnmapWindow(disp, window);
+			{ // Wait for window to disapear
+				XEvent event;
+				do {
+					XMaskEvent(disp, StructureNotifyMask, &amp;event);
+				} while ( (event.type != UnmapNotify) || (event.xunmap.event != window) );
+			}
+			// Turn off WM control
+			attributes.override_redirect = True;
+			XChangeWindowAttributes(disp, window, CWBorderPixel | CWColormap | CWOverrideRedirect, &amp;attributes);
+
+			// Re-appear window
+			XMapRaised(disp, window);
+		}
+
+		// Get input focus
+		//XSetInputFocus(disp,window, RevertToNone, CurrentTime);
+		while (1) 
+		{
+			int result = XGrabPointer(disp, window, True, 0, 
+											  GrabModeAsync, GrabModeAsync, window, None, CurrentTime);
+			if ( result == GrabSuccess ) {
+				break;
+			}
+			CL_System::sleep(100);
+		}
+
+		XF86VidModeGetViewPort(disp, DefaultScreen(disp), &amp;old_x, &amp;old_y);
+
+		XF86VidModeSwitchToMode(disp, 0, *(usable_modes.begin()));
+		Window child_window;
+		int x, y;
+		// Get the windows absolute position (aka relative to
+		// the root window)
+		XTranslateCoordinates(disp, window, DefaultRootWindow(disp), 
+									 0, 0, &amp;x, &amp;y, &amp;child_window);
+	
+		XF86VidModeSetViewPort(disp, DefaultScreen(disp), x, y);
+		
+		XSync(disp, True);
+
+		fullscreen = true;
+	}
+}
+
+void CL_DisplayWindow_OpenGL::set_windowed()
+{
+	if(!fullscreen)
+		return;
+
+	if (0)
+	{ // FIXME: See FIXME in set_fullscreen
+		// Hide window
+		XUnmapWindow(disp, window);
+		XSync(disp, True);
+
+		// Turn on WM control 
+		attributes.override_redirect = False;
+		XChangeWindowAttributes(disp, window, CWBorderPixel | CWColormap | CWOverrideRedirect, &amp;attributes);
+
+		XMoveResizeWindow(disp, window, 0, 0, fullscreen_width, fullscreen_height);
+
+		XMapRaised(disp, window);
+		XSync(disp, True);
+	}
+
+	fullscreen = false;
+
+	// Only restore mode if we ever switched mode.
+	if (old_x != -1 || old_y != -1)
+	{
+		XF86VidModeSwitchToMode(disp, 0, &amp;old_mode);
+		XF86VidModeSetViewPort(disp, 0, old_x, old_y);
+	}
+
+	XUngrabPointer(disp, CurrentTime);
+
+	XSync(disp, True);
+}
+
+void CL_DisplayWindow_OpenGL::set_title(const std::string &amp;title)
+{
+	XSetStandardProperties(disp, window, title.c_str(), title.c_str(), None, NULL, 0, NULL);
+}
+
+void CL_DisplayWindow_OpenGL::set_position(const CL_Rect &amp;pos)
+{
+	set_position(pos.left, pos.top);
+	XResizeWindow(disp, window, pos.get_width(), pos.get_height());
+	set_size(pos.get_width(), pos.get_height());
+}
+
+void CL_DisplayWindow_OpenGL::set_position(int x, int y)
+{
+	XMoveWindow(disp, window, x, y);
+}
+
+void CL_DisplayWindow_OpenGL::set_size(int width, int height)
+{
+	fullscreen_width = width;
+	fullscreen_height = height;
+
+	sig_resize(width, height);
+}
+
+void CL_DisplayWindow_OpenGL::set_buffer_count(int flipping_buffers)
+{
+// Not implemented.
+// We can't change how many buffer we use in OpenGL, the drivers pick for us
+	CL_Log::log(&quot;debug&quot;, &quot;CL_DisplayWindow_OpenGL::set_buffer_count is not implemented&quot;);
+}
+
+void CL_DisplayWindow_OpenGL::update(const CL_Rect &amp;rect)
+{
+	CL_OpenGLState state(get_gc());
+	state.set_active();
+	state.setup_2d();
+	
+	CLboolean is_doublebuffered = CL_FALSE;
+	clGetBooleanv(CL_DOUBLEBUFFER, &amp;is_doublebuffered);
+	if (is_doublebuffered)
+	{
+		clReadBuffer(CL_BACK);
+		
+		float raster_pos[4];
+		clGetFloatv(CL_CURRENT_RASTER_POSITION, raster_pos);
+
+		clDrawBuffer(CL_FRONT);
+		clRasterPos3f(rect.left, rect.bottom, raster_pos[2]);
+
+		clCopyPixels(rect.top, rect.left, rect.get_width(), rect.get_height(), CL_COLOR);
+
+		clDrawBuffer(CL_BACK);
+	}
+}
+
+void CL_DisplayWindow_OpenGL::show_system_cursor()
+{
+	XDefineCursor(disp, window, system_cursor);
+}
+
+void CL_DisplayWindow_OpenGL::hide_system_cursor()
+{
+	XDefineCursor(disp, window, hidden_cursor);
+}
+
+void CL_DisplayWindow_OpenGL::cursor_changed()
+{
+// We have to extract the data from the cursor in order to display it
+
+// At this point nothing more than hiding/unhiding the system cursor is supported
+// I'm waiting for the release of XFree86 4.3, which has the Xcursor extension library.
+// This will greatly simplify this, so I don't want to start implenting this.
+// --MSR, Nov. 13, 2002
+}
+
+void CL_DisplayWindow_OpenGL::keep_alive()
+{
+	XEvent event, next_event;
+	CL_Rect *rect;
+	
+	for (int i=XPending(disp); i&gt;0; i--)
+	{
+		XNextEvent(disp, &amp;event);
+		switch(event.type)
+		{
+			//Resize or Move
+			case ConfigureNotify:
+				#ifdef DEBUG
+					CL_Log::log(&quot;debug&quot;, &quot;ConfigureNotify Event received&quot;);
+				#endif
+				set_size(event.xconfigure.width,event.xconfigure.height);
+				break;
+			case ClientMessage:
+				#ifdef DEBUG
+					CL_Log::log(&quot;debug&quot;, &quot;Received ClientMessage, sending close signal&quot;);
+				#endif
+				sig_window_close();
+				break;
+			case Expose:
+				// Repaint notification
+				// Could be more efficient if we checked ahead for other
+				// repaint notifications
+				#ifdef DEBUG
+					CL_Log::log(&quot;debug&quot;, &quot;Expose Event received&quot;);
+				#endif
+				rect = new CL_Rect(event.xexpose.x, event.xexpose.y,
+					event.xexpose.x + event.xexpose.width, event.xexpose.y + event.xexpose.height);
+				sig_paint(*rect);
+				delete rect;
+				break;
+			case FocusIn:
+				#ifdef DEBUG
+					CL_Log::log(&quot;debug&quot;, &quot;Focus In&quot;);
+				#endif
+				focus = true;
+				sig_got_focus();
+				break;
+			case FocusOut:
+				#ifdef DEBUG
+					CL_Log::log(&quot;debug&quot;, &quot;Focus Out&quot;);
+				#endif
+				focus = false;
+				sig_lost_focus();
+				break;
+			case KeyRelease:
+				if( XEventsQueued( disp, QueuedAfterReading ) )
+				{
+					XPeekEvent( disp, &amp;next_event );
+					if( next_event.type == KeyPress &amp;&amp;
+						next_event.xkey.window == event.xkey.window &amp;&amp;
+						next_event.xkey.keycode == event.xkey.keycode &amp;&amp;
+						next_event.xkey.time == event.xkey.time )
+					{
+						// Do not report anything for this event
+						break;
+					}
+				}
+			case KeyPress:
+			case KeymapNotify:
+			case ButtonPress:
+			case ButtonRelease:
+			case MotionNotify:
+				sig_xevent(event);
+				break;
+			case PropertyNotify:
+				#ifdef DEBUG
+				// This looks to be mostly useless
+				// I'm getting a lot of WM messages that aren't really useful.
+				// --MSR, April 5, 2003
+				/*
+					if(event.xproperty.state == PropertyNewValue)
+					{
+						CL_Log::log(&quot;debug&quot;, &quot;%1 has a new value&quot;, XGetAtomName(disp, event.xproperty.atom));
+					}
+				*/
+				#endif
+				break;
+				
+			#ifdef DEBUG
+			case EnterNotify:
+			case LeaveNotify:
+				CL_Log::log(&quot;debug&quot;, &quot;The mouse has left or entered the window&quot;);
+				break;
+//			default:
+				//			CL_Log::log(&quot;debug&quot;, &quot;Unhandled event type: %1&quot;, event.type);
+			#endif
+		default:
+			sig_unknown_xevent(event);
+			break;
+		}
+	}
+}
+
+// Local Variables: ***
+// mode: clanlib ***
+// End: ***

Added: trunk/clanlib/GL/GLX/display_window_opengl.h
===================================================================
--- trunk/clanlib/GL/GLX/display_window_opengl.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/GLX/display_window_opengl.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,248 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_display_window_opengl
+#define header_display_window_opengl
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;map&gt;
+#include &lt;stack&gt;
+
+#include &quot;API/Core/System/keep_alive.h&quot;
+
+#include &quot;API/Display/graphic_context.h&quot;
+#include &quot;API/Display/pixel_buffer.h&quot;
+#include &quot;API/Display/input_device.h&quot;
+#include &quot;API/Display/input_context.h&quot;
+#include &quot;API/Display/display_window_description.h&quot;
+
+#include &quot;Display/display_window_generic.h&quot;
+
+#include &lt;X11/Xlib.h&gt;
+#include &lt;X11/Xutil.h&gt;
+#include &lt;X11/cursorfont.h&gt;
+
+#include &lt;X11/extensions/xf86vmode.h&gt;
+#include &lt;X11/extensions/XInput.h&gt;
+
+#include &lt;GL/glu.h&gt;
+#include &lt;GL/glx.h&gt;
+
+class CL_DisplayWindow_OpenGL : public CL_DisplayWindow_Generic, CL_KeepAlive
+{
+//! Construction:
+public:
+	CL_DisplayWindow_OpenGL();
+
+	virtual ~CL_DisplayWindow_OpenGL();
+
+//! Attributes:
+public:
+	//: Returns the width of this window.
+	virtual int get_width() const;
+
+	//: Returns the height of this window.
+	virtual int get_height() const;
+
+	//: Returns true if fullscreen window.
+	virtual bool is_fullscreen() const;
+
+	//: Returns true if window got focus.
+	virtual bool has_focus() const;
+
+	//: Returns const versions of the pixelbuffer interfaces.
+	virtual CL_PixelBuffer get_buffer(int i) const;
+
+	//: Returns the amount of flipping buffers.
+	virtual int get_buffer_count() const;
+
+	//: Returns the graphic context of this window.
+	virtual CL_GraphicContext *get_gc();
+
+	//: Returns the input context of this window.
+	virtual CL_InputContext *get_ic() { return &amp;input_context; }
+
+	//: Returns the maximum size of a surface this displaywindow supports.
+	CL_Size get_max_surface_size() const;
+
+	//: Returns the GLX rendering context for this window.
+	GLXContext get_context() { return context; }
+
+	//: Returns the X11 display handle.
+	static Display *get_display() { return disp; }
+
+	//: Handle to X11 window handle.
+	Window get_window() { return window; }
+
+	//: Input context for all input devices associated with this window.
+	CL_InputContext input_context;
+
+	//: Input device for the keyboard.
+	CL_InputDevice keyboard;
+
+	//: Input device for the mouse.
+	CL_InputDevice mouse;
+
+	//: State information about misc key modifiers.
+	bool left_ctrl_down, left_alt_down, left_shift_down;
+	bool right_ctrl_down, right_alt_down, right_shift_down;
+
+	//: handle of the first created context. Used for sharing
+	//: textures and display lists between rendering contexts.
+	static GLXContext share_context;
+
+//! Operations:
+public:
+	//: Set window to fullscreen.
+	virtual void set_fullscreen(int width, int height, int bpp, int refresh_rate);
+
+	//: Restore to windowed mode.
+	virtual void set_windowed();
+
+	//: Change title on window.
+	virtual void set_title(const std::string &amp;title);
+
+	//: Set window position and size.
+	virtual void set_position(const CL_Rect &amp;pos);
+
+	//: Set window position.
+	virtual void set_position(int x, int y);
+
+	//: Set window size.
+	virtual void set_size(int width, int height);
+
+	//: Change the buffer count in the flipping system.
+	virtual void set_buffer_count(int flipping_buffers);
+
+	//: Copy a region of the backbuffer to the frontbuffer.
+	virtual void update(const CL_Rect &amp;rect);
+
+	//: Flip the backbuffer to front.
+	virtual void flip(int interval);
+
+	//: Make system cursor visible over window.
+	virtual void show_system_cursor();
+
+	//: Make system cursor invisible over window.
+	virtual void hide_system_cursor();
+
+	//: Create a window.
+	virtual void create_window(const CL_DisplayWindowDescription &amp;desc);
+
+	//: Called by ClanLib keep alive pump.
+	virtual void keep_alive();
+
+	//: Return the X display handle
+	virtual Display *get_hwnd();
+
+//! Signals:
+public:
+	//: Signal emitted when x11 events are to be processed.
+	CL_Signal_v1&lt;XEvent &amp;&gt; sig_xevent;
+
+	CL_Signal_v1&lt;XEvent &amp;&gt; sig_unknown_xevent;
+
+//! Implementation:
+private:
+	//: Initializes all joysticks
+	void setup_joysticks();
+	
+	//: Initializes additional USB mice
+	void setup_usb_mice();
+
+	//: Initialize extended X11 input devices (graphic tablet, etc.)
+	void setup_xinput();
+	
+	//: Initialize /dev/input/event* devices
+	void setup_event();
+
+	Bool xinput_is_present();
+
+	//: Signal that a new cursor CL_Sprite is available
+	void cursor_changed();
+
+	//: Destroy current window handles.
+	void destroy_window();
+
+	//: X Event handler for the window
+	void on_xevent(XEvent &amp;event);
+
+	//: True if currently in full screen mode.
+	bool fullscreen;
+
+	//: Width and height, if in full screen mode.
+	int fullscreen_width, fullscreen_height;
+
+	//: Bits per pixel in the openGL Context.
+	//: May not correspond to bit depth on screen
+	int glx_bpp;
+
+	//: Saved position of window when going fullscreen. This is the
+	//: position the window receives when leaving fullscreen again.
+	CL_Rect saved_position;
+
+	// OpenGL compatible gc.
+	CL_GraphicContext gc;
+
+	//: GLX rendering context handle.
+	GLXContext context;
+	
+	//: X11 Display handle.
+	static Display *disp;
+
+	static int disp_ref_count;
+
+	//: Handle to X11 window.
+	Window window;
+
+	//: Attributes used to create window.
+	XSetWindowAttributes attributes;
+	
+	//: Whether we have window focus or not
+	bool focus;
+
+	//: Attributes to switch between windowed and fullscreen
+	int dotclock;
+	XF86VidModeModeInfo old_mode;
+	int old_x, old_y;
+
+	//: X Event slot
+	CL_Slot slot_xevent;
+	
+	Cursor system_cursor;
+	Cursor hidden_cursor;
+	Pixmap cursor_bitmap;
+	
+};
+
+#endif
+

Added: trunk/clanlib/GL/GLX/input_device_linuxevent.cpp
===================================================================
--- trunk/clanlib/GL/GLX/input_device_linuxevent.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/GLX/input_device_linuxevent.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,352 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &lt;assert.h&gt;
+#include &lt;linux/input.h&gt;
+#include &lt;sys/ioctl.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;iostream&gt;
+#include &lt;errno.h&gt;
+
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/Display/input_event.h&quot;
+#include &quot;input_device_linuxevent.h&quot;
+
+// FIXME: These three should be in linux/input.h
+#define MSC_RAW			0x03
+#define MSC_SCAN		0x04
+#define MSC_MAX			0x07
+
+
+#ifndef EV_SYN
+#define EV_SYN 0
+#endif
+
+#define BITS_PER_LONG (sizeof(long) * 8)
+#define NBITS(x) ((((x)-1)/BITS_PER_LONG)+1)
+#define OFF(x)  ((x)%BITS_PER_LONG)
+#define BIT(x)  (1UL&lt;&lt;OFF(x))
+#define LONG(x) ((x)/BITS_PER_LONG)
+#define test_bit(bit, array)	((array[LONG(bit)] &gt;&gt; OFF(bit)) &amp; 1)
+
+static char *events[EV_MAX + 1] = { NULL };
+static char **names[EV_MAX + 1] = { NULL }; 
+
+CL_InputDevice_LinuxEvent::CL_InputDevice_LinuxEvent(CL_DisplayWindow_Generic* parent_, 
+																	  const std::string&amp; device_)
+  : parent(parent_),
+	 device(device_) 
+{
+	fd = open(device.c_str(), O_RDONLY | O_NONBLOCK);
+
+	if (fd == -1)
+	{
+		throw CL_Error(strerror(errno));
+	}
+
+	if (ioctl(fd, EVIOCGVERSION, &amp;version)) 
+	{
+		throw CL_Error(&quot;CL_InputDevice_LinuxEvent: can't get version&quot;);
+	}
+
+#if 0
+	if (0)
+	{ // FIXME: Some versions of linux don't have these structs, use arrays there
+		struct input_id id;
+		ioctl(fd, EVIOCGID, &amp;id);
+		printf(&quot;Input device ID: bus 0x%x vendor 0x%x product 0x%x version 0x%x\n&quot;,
+				 id.bustype, id.vendor, id.product, id.vendor);
+	}
+#endif
+
+	{  // Get the human readable name
+		char c_name[256] = &quot;Unknown&quot;;
+		ioctl(fd, EVIOCGNAME(sizeof(c_name)), c_name);
+		name = c_name;
+	}
+
+	{
+		unsigned long bit[EV_MAX][NBITS(KEY_MAX)];
+		memset(bit, 0, sizeof(bit));
+		ioctl(fd, EVIOCGBIT(0, EV_MAX), bit[0]);
+
+		for (int i = 0; i &lt; EV_MAX; i++)
+		{
+			if (test_bit(i, bit[0])) 
+			{
+				//printf(&quot;  Event type %d (%s)\n&quot;, i, events[i] ? events[i] : &quot;?&quot;);
+				
+				if (!i) continue;
+
+				ioctl(fd, EVIOCGBIT(i, KEY_MAX), bit[i]);
+				for (int j = 0; j &lt; KEY_MAX; j++) 
+				{
+					if (test_bit(j, bit[i])) 
+					{
+						if (i == EV_KEY) 
+						{ // Found something that might be a button
+							buttons.push_back(Button(j));
+						} 
+						else if (i == EV_ABS) 
+						{ // Found something that might be an axis
+#if 0
+							// FIXME: Some Linuxes don't have these struct
+							struct input_absinfo absinfo;
+							ioctl(fd, EVIOCGABS(j), &amp;absinfo);
+							// FIXME: we are ignoring absinfo.fuzz and absinfo.flat, not sure what they are good for
+							axes.push_back(Axis(j, absinfo.minimum, absinfo.maximum, absinfo.value));
+#else
+							int absinfo[5];
+							ioctl(fd, EVIOCGABS(j), &amp;absinfo);
+							// FIXME: we are ignoring absinfo.fuzz and absinfo.flat, not sure what they are good for
+							axes.push_back(Axis(j, absinfo[1], absinfo[2], absinfo[0]));
+#endif
+						}
+						else if (i == EV_REL) 
+						{ // Found something mouse/ball like
+							balls.push_back(Ball(j));
+						}
+					}
+				}
+			}
+		}
+	}
+}
+
+int
+CL_InputDevice_LinuxEvent::get_ball_index_by_code(int code)
+{
+	for(std::vector&lt;Ball&gt;::size_type i = 0; i != balls.size(); ++i)
+	{
+		if (balls[i].code == code)
+		{
+			return i;
+		}
+	}
+	return -1;
+}
+
+int
+CL_InputDevice_LinuxEvent::get_button_index_by_code(int code)
+{
+	for(std::vector&lt;Button&gt;::size_type i = 0; i != buttons.size(); ++i)
+	{
+		if (buttons[i].code == code)
+		{
+			return i;
+		}
+	}
+	return -1;
+}
+
+int
+CL_InputDevice_LinuxEvent::get_axis_index_by_code(int code)
+{
+	for(std::vector&lt;Axis&gt;::size_type i = 0; i != axes.size(); ++i)
+	{
+		if (axes[i].code == code)
+		{
+			return i;
+		}
+	}
+	return -1;
+}
+
+void
+CL_InputDevice_LinuxEvent::keep_alive()
+{
+	struct input_event ev[64];
+	
+	int rd = read(fd, ev, sizeof(struct input_event) * 64);
+
+	if (rd &gt;= (int) sizeof(struct input_event))
+	{
+		for (int i = 0; i &lt; rd / (int)sizeof(struct input_event); ++i)
+		{
+			switch (ev[i].type)
+			{
+			case EV_ABS:
+			{
+				int axis_index = get_axis_index_by_code(ev[i].code);
+				if (axis_index != -1)
+				{
+					axes[axis_index].pos = ev[i].value;
+
+					CL_InputEvent e; 
+					
+					e.device   = CL_InputDevice(this);
+					e.type     = CL_InputEvent::axis_moved;
+					e.id       = axis_index;
+					e.axis_pos = axes[axis_index].get_posf();
+					e.repeat_count = 0;
+
+					sig_axis_move(e);
+				}
+			}
+			break;
+
+			case EV_REL:
+			{
+				int ball_index = get_ball_index_by_code(ev[i].code);
+
+				balls[ball_index].pos += ev[i].value;
+
+				CL_InputEvent e; 
+				
+				e.device       = CL_InputDevice(this);
+				e.type         = CL_InputEvent::ball_moved;
+				e.id           = ball_index;
+				e.mouse_pos.x  = ev[i].value;
+				e.mouse_pos.y  = 0;
+				e.axis_pos     = 0;
+				e.repeat_count = 0;
+
+				sig_ball_move(e);
+			}
+			break;
+
+			case EV_KEY:
+			{
+				int button_index = get_button_index_by_code(ev[i].code);
+
+				buttons[button_index].pressed = ev[i].value;
+
+				CL_InputEvent e; 
+			
+				e.device = CL_InputDevice(this);
+				e.id     = button_index;
+				e.repeat_count = 0;
+
+				if (ev[i].value)
+				{
+					e.type = CL_InputEvent::pressed;
+					sig_key_down(e);
+				}
+				else
+				{
+					e.type = CL_InputEvent::released;
+					sig_key_up(e);
+				}
+			}
+			break;
+
+			default:
+				if (0) 
+				{
+					if (ev[i].type == EV_SYN) 
+					{
+						printf(&quot;Event: time %ld.%06ld, -------------- %s ------------\n&quot;,
+								 ev[i].time.tv_sec, ev[i].time.tv_usec, ev[i].code ? &quot;Config Sync&quot; : &quot;Report Sync&quot; );
+					}
+					else if (ev[i].type == EV_MSC &amp;&amp; (ev[i].code == MSC_RAW || ev[i].code == MSC_SCAN)) 
+					{
+						printf(&quot;Event: time %ld.%06ld, type %d (%s), code %d (%s), value %02x\n&quot;,
+								 ev[i].time.tv_sec, ev[i].time.tv_usec, ev[i].type,
+								 events[ev[i].type] ? events[ev[i].type] : &quot;?&quot;,
+								 ev[i].code,
+								 names[ev[i].type] ? (names[ev[i].type][ev[i].code] ? names[ev[i].type][ev[i].code] : &quot;?&quot;) : &quot;?&quot;,
+								 ev[i].value);
+					} 
+					else 
+					{
+						printf(&quot;Event: time %ld.%06ld, type %d (%s), code %d (%s), value %d\n&quot;,
+								 ev[i].time.tv_sec, ev[i].time.tv_usec, ev[i].type,
+								 events[ev[i].type] ? events[ev[i].type] : &quot;?&quot;,
+								 ev[i].code,
+								 names[ev[i].type] ? (names[ev[i].type][ev[i].code] ? names[ev[i].type][ev[i].code] : &quot;?&quot;) : &quot;?&quot;,
+								 ev[i].value);
+					}	
+				}
+				break;
+			}
+		}
+	}
+}
+
+CL_InputDevice_LinuxEvent::~CL_InputDevice_LinuxEvent()
+{
+	close(fd);
+}
+
+std::string
+CL_InputDevice_LinuxEvent::get_key_name(int num) const
+{
+	// FIXME: copy enum2string code from evtest here
+	return CL_String::from_int(num);
+}
+
+float
+CL_InputDevice_LinuxEvent::get_axis(int num)   const
+{
+	assert(num &gt;= 0 &amp;&amp; num &lt; int(axes.size()));
+	return axes[num].pos;
+}
+
+bool
+CL_InputDevice_LinuxEvent::get_keycode(int num) const
+{
+	if (num &gt;= 0 &amp;&amp; num &lt; int(buttons.size()) )
+	{
+		return buttons[num].pressed;
+	} 
+	else 
+	{
+		return false;
+	}
+}
+
+int
+CL_InputDevice_LinuxEvent::get_axis_count() const
+{
+	return axes.size();
+}
+
+int
+CL_InputDevice_LinuxEvent::get_button_count() const
+{
+	return buttons.size();
+}
+
+std::string
+CL_InputDevice_LinuxEvent::get_name() const 
+{
+	return name; 
+}
+
+std::string
+CL_InputDevice_LinuxEvent::get_device_name() const 
+{ 
+	return &quot;linuxevent:&quot; + device; 
+}
+
+// Local Variables: ***
+// mode: clanlib ***
+// End: ***

Added: trunk/clanlib/GL/GLX/input_device_linuxevent.h
===================================================================
--- trunk/clanlib/GL/GLX/input_device_linuxevent.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/GLX/input_device_linuxevent.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,121 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_input_device_linuxevent
+#define header_input_device_linuxevent
+
+#include &quot;API/Core/Math/point.h&quot;
+#include &quot;API/Core/System/keep_alive.h&quot;
+#include &quot;../../Display/input_device_generic.h&quot;
+#include &quot;../../Display/display_window_generic.h&quot;
+
+class CL_InputDevice_LinuxEvent : public CL_InputDevice_Generic,
+											 public CL_KeepAlive
+{
+private: 
+	// Absolute Input Event
+	struct Axis
+	{
+		Axis(int code_, int min_, int max_, int pos_)
+			: code(code_), min(min_), max(max_), pos(pos_) {}
+
+		int code;
+		int min;
+		int max;
+		int pos;
+
+		inline float get_posf() const {
+			return float(pos - min)/(max - min) * 2.0f - 1.0f;
+		}
+	};
+	
+	// Relative Input Event
+	struct Ball 
+	{
+		Ball(int code_)
+			: code(code_),
+			  pos(0)
+		{}
+		
+		int code;
+		int pos;
+	};
+
+	// Key Input Event
+	struct Button
+	{
+		Button(int code_)
+			: code(code_),
+			  pressed(false)
+		{}
+
+		int code;
+		bool pressed;
+	};
+
+	CL_DisplayWindow_Generic* parent;
+
+	int fd;
+	int version;
+
+	std::vector&lt;Axis&gt;   axes;
+	std::vector&lt;Button&gt; buttons;
+	std::vector&lt;Ball&gt;   balls;
+
+	std::string name;
+	std::string device;
+
+public:
+	CL_InputDevice_LinuxEvent(CL_DisplayWindow_Generic* parent, const std::string&amp; device);
+	~CL_InputDevice_LinuxEvent();
+
+	std::string get_key_name(int num) const;
+
+	float get_axis(int num)   const;
+	bool  get_keycode(int num) const;
+
+	std::string get_name() const;
+	std::string get_device_name() const;
+
+   int get_axis_count() const;
+   int get_button_count() const;
+
+	void keep_alive();	
+
+private:
+	int get_ball_index_by_code(int code);
+	int get_button_index_by_code(int code);
+	int get_axis_index_by_code(int code);
+};
+
+#endif 
+
+// Local Variables: ***
+// mode: clanlib ***
+// End: ***

Added: trunk/clanlib/GL/GLX/input_device_linuxjoystick.cpp
===================================================================
--- trunk/clanlib/GL/GLX/input_device_linuxjoystick.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/GLX/input_device_linuxjoystick.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,152 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &lt;sys/ioctl.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;linux/joystick.h&gt;
+#include &lt;iostream&gt;
+#include &lt;errno.h&gt;
+
+#include &quot;API/Core/Math/point.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Display/input_event.h&quot;
+
+#include &quot;input_device_linuxjoystick.h&quot;
+
+CL_InputDevice_LinuxJoystick::CL_InputDevice_LinuxJoystick(const std::string&amp; device_)
+	: device(device_)
+{
+	type = CL_InputDevice::joystick;
+
+	fd = open(device.c_str(), O_RDONLY | O_NONBLOCK);
+
+	if (fd == -1)
+	{
+		throw CL_Error(strerror(errno));
+	}
+
+	char number_of_axes;
+	char number_of_buttons;
+
+	ioctl(fd, JSIOCGBUTTONS, &amp;number_of_buttons );
+	ioctl(fd, JSIOCGAXES,    &amp;number_of_axes );
+  
+	char name_cstr[256];
+	if (ioctl(fd, JSIOCGNAME(sizeof(name_cstr)), name_cstr) &lt; 0)
+		strncpy(name_cstr, &quot;Unknown&quot;, sizeof(name_cstr));
+
+	name = name_cstr;
+
+	axes_states.resize(number_of_axes);
+	button_states.resize(number_of_buttons);
+}
+
+CL_InputDevice_LinuxJoystick::~CL_InputDevice_LinuxJoystick()
+{
+	close(fd);
+}
+
+void
+CL_InputDevice_LinuxJoystick::process_event(struct js_event event)
+{
+	// We don't threat JS_EVENT_INIT special, so this should do
+	if (event.type &amp; JS_EVENT_BUTTON) 
+	{
+		button_states[event.number] = event.value;
+		send_button_event(event);
+	}
+	else if (event.type &amp; JS_EVENT_AXIS) 
+	{
+		axes_states[event.number] = float(event.value)/32767;
+		send_axis_event(event);
+	}
+}
+
+void
+CL_InputDevice_LinuxJoystick::send_button_event(const struct js_event&amp; event)
+{
+	CL_InputEvent e; 
+			
+	e.device = CL_InputDevice(this);
+	e.id     = event.number;
+	e.repeat_count = 0;
+
+	if (event.value)
+	{
+		e.type = CL_InputEvent::pressed;
+		sig_key_down(e);
+	}
+	else
+	{
+		e.type = CL_InputEvent::released;
+		sig_key_up(e);
+	}
+}
+
+void
+CL_InputDevice_LinuxJoystick::send_axis_event(const struct js_event&amp; event)
+{
+	CL_InputEvent e; 
+		
+	e.device   = CL_InputDevice(this);
+	e.type     = CL_InputEvent::axis_moved;
+	e.id       = event.number;
+	e.axis_pos = float(event.value)/32767;
+	e.repeat_count = 0;
+
+	sig_axis_move(e);
+}
+
+void
+CL_InputDevice_LinuxJoystick::keep_alive()
+{
+	struct js_event event;
+
+	while (read(fd, &amp;event, sizeof(struct js_event)) != -1)
+	{
+		process_event(event);
+	}
+	/* EAGAIN is returned when the queue is empty */
+	if (errno != EAGAIN) {
+		throw CL_Error(strerror(errno));
+	}
+}
+
+std::string
+CL_InputDevice_LinuxJoystick::get_key_name(int num) const
+{
+	return CL_String::from_int(num);
+}
+
+// Local Variables: ***
+// mode: clanlib ***
+// End: ***
+

Added: trunk/clanlib/GL/GLX/input_device_linuxjoystick.h
===================================================================
--- trunk/clanlib/GL/GLX/input_device_linuxjoystick.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/GLX/input_device_linuxjoystick.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,79 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_input_device_linuxjoystick
+#define header_input_device_linuxjoystick
+
+#include &lt;vector&gt;
+#include &lt;string&gt;
+
+#include &quot;API/Core/Math/point.h&quot;
+#include &quot;API/Core/System/keep_alive.h&quot;
+#include &quot;../../Display/input_device_generic.h&quot;
+
+class CL_InputDevice_LinuxJoystick : public CL_InputDevice_Generic,
+												 public CL_KeepAlive
+{
+private:
+	int fd;
+	std::string device;
+	std::string name;
+
+	std::vector&lt;float&gt; axes_states;
+	std::vector&lt;bool&gt;  button_states;
+
+public:
+	CL_InputDevice_LinuxJoystick(const std::string&amp; device);
+	~CL_InputDevice_LinuxJoystick();
+
+	std::string get_key_name(int num) const;
+
+	float get_axis(int num)   const { return axes_states[num]; }
+	bool  get_keycode(int num) const { return button_states[num]; }
+	
+	int get_axis_count()   const { return axes_states.size(); }
+	int get_button_count() const { return button_states.size(); }
+
+	std::string get_name() const { return name; }
+	std::string get_device_name() const { return &quot;linuxjoystick:&quot; + device; }
+
+	void process_event(struct js_event event);
+	void keep_alive();
+
+private:
+	void send_button_event(const struct js_event&amp; event);
+	void send_axis_event(const struct js_event&amp; event);
+};
+
+#endif
+
+// Local Variables: ***
+// mode: clanlib ***
+// End: ***
+

Added: trunk/clanlib/GL/GLX/input_device_linuxusbmouse.cpp
===================================================================
--- trunk/clanlib/GL/GLX/input_device_linuxusbmouse.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/GLX/input_device_linuxusbmouse.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,198 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &lt;sys/ioctl.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;iostream&gt;
+#include &lt;errno.h&gt;
+
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Display/keys.h&quot;
+#include &quot;API/Display/input_event.h&quot;
+#include &quot;API/Display/input_device.h&quot;
+#include &quot;display_window_opengl.h&quot;
+#include &quot;input_device_linuxusbmouse.h&quot;
+
+CL_InputDevice_LinuxUSBMouse::CL_InputDevice_LinuxUSBMouse(CL_DisplayWindow_Generic* parent, 
+																			  const std::string&amp; dev)
+	: parent(parent),
+	  device(dev),
+	  buttons(5)
+{
+	type = CL_InputDevice::mouse;
+
+	fd = open (device.c_str (), O_RDWR | O_NONBLOCK);
+
+	if (fd == -1)
+	{
+		throw CL_Error(strerror(errno));
+	}
+
+	init_explorer_ps2();
+
+	char data[4];
+	read(fd, data, sizeof (data));
+	read(fd, data, sizeof (data));
+	read(fd, data, sizeof (data));
+}
+
+CL_InputDevice_LinuxUSBMouse::~CL_InputDevice_LinuxUSBMouse()
+{
+	close(fd);
+}
+
+void CL_InputDevice_LinuxUSBMouse::init_explorer_ps2()
+{
+	// Microsoft init sequence for Explorer mouse (wheel + 5 buttons)
+	static unsigned char data[] = { 0xF3, 0xC8, 
+											  0xF3, 0xC8,
+											  0xF3, 0x50 };
+  	write(fd, data, sizeof(data));
+}
+
+bool
+CL_InputDevice_LinuxUSBMouse::get_keycode(int keycode) const
+{
+	if (keycode &gt; 0 &amp;&amp; keycode &lt; int(buttons.size()))
+		return buttons[keycode];
+	else
+		return false;
+}
+
+void
+CL_InputDevice_LinuxUSBMouse::keep_alive()
+{
+	unsigned char data[4];
+	while (read(fd, data, sizeof (data)) &gt; 0)
+	{		
+		// Mouse Move:
+		int delta_x = (data[0] &amp; 0x10) ? data[1]-256 : data[1];
+		int delta_y = (data[0] &amp; 0x20) ? data[2]-256 : data[2];
+
+		if (delta_x != 0 || delta_y != 0)
+		{
+			mouse_pos.x += delta_x;
+			mouse_pos.y -= delta_y; // y-axis is reversed on-screen
+
+			if (mouse_pos.x &lt; 0) 
+				mouse_pos.x = 0;
+			else if (mouse_pos.x &gt; parent-&gt;get_width())
+				mouse_pos.x =  parent-&gt;get_width() - 1;
+
+			if (mouse_pos.y &lt; 0) 
+				mouse_pos.y = 0;
+			else if (mouse_pos.y &gt; parent-&gt;get_height()) 
+				mouse_pos.y = parent-&gt;get_height() - 1;
+
+			send_ball_move(delta_x, delta_y);
+			send_pointer_move(mouse_pos);
+		}
+
+		// Scrollwheel move
+		int delta_z = (data[3] &amp; 0x08) ? (data[3] &amp; 0x0F)-16 : (data[3] &amp; 0x0F);
+
+		if (delta_z &gt; 0)
+		{
+			while (delta_z != 0)
+			{
+				--delta_z;
+				send_key_event(CL_MOUSE_WHEEL_DOWN, true);
+				send_key_event(CL_MOUSE_WHEEL_DOWN, false);
+			}
+		} 
+		else if (delta_z &lt; 0)
+		{
+			while (delta_z != 0)
+			{
+				++delta_z;
+				send_key_event(CL_MOUSE_WHEEL_UP, true);
+				send_key_event(CL_MOUSE_WHEEL_UP, false);
+			}
+		}
+
+		// Button event
+		std::vector&lt;bool&gt; new_state(5);
+
+		new_state[0] = ((data[0] &amp;  1)&gt;0);
+		new_state[1] = ((data[0] &amp;  2)&gt;0);
+		new_state[2] = ((data[0] &amp;  4)&gt;0);
+		new_state[3] = ((data[3] &amp; 16)&gt;0);
+		new_state[4] = ((data[3] &amp; 32)&gt;0);
+
+		for (int i = 0; i &lt; 5; ++i)
+		{
+			if (new_state[i] != buttons[i])
+			{
+				send_key_event(i&lt;3?i:i+2, new_state[i]);
+			}
+		}
+
+		buttons = new_state;
+	}
+}
+
+void
+CL_InputDevice_LinuxUSBMouse::send_pointer_move(const CL_Point&amp; pos)
+{
+	CL_InputEvent event;
+	event.type      = CL_InputEvent::pointer_moved;
+	event.device    = CL_InputDevice(this);
+	event.mouse_pos = pos;
+	sig_pointer_move(event);
+}
+
+void
+CL_InputDevice_LinuxUSBMouse::send_ball_move(int delta_x, int delta_y)
+{
+	CL_InputEvent event;
+	event.type      = CL_InputEvent::ball_moved;
+	event.device    = CL_InputDevice(this);
+	event.mouse_pos = CL_Point(delta_x, delta_y);
+	sig_ball_move(event);
+}
+
+void
+CL_InputDevice_LinuxUSBMouse::send_key_event(int key, bool press)
+{
+	CL_InputEvent event;
+	event.type      = press ? CL_InputEvent::pressed : CL_InputEvent::released;
+	event.id        = key;
+	event.device    = CL_InputDevice(this);
+	event.mouse_pos = mouse_pos;
+
+	if (press)
+		sig_key_down(event);
+	else
+		sig_key_up(event);
+}
+
+// Local Variables: ***
+// mode: clanlib ***
+// End: ***

Added: trunk/clanlib/GL/GLX/input_device_linuxusbmouse.h
===================================================================
--- trunk/clanlib/GL/GLX/input_device_linuxusbmouse.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/GLX/input_device_linuxusbmouse.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,95 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_input_device_usbmouse
+#define header_input_device_usbmouse
+
+#include &quot;API/Core/Math/point.h&quot;
+#include &quot;API/Core/System/keep_alive.h&quot;
+#include &quot;../../Display/input_device_generic.h&quot;
+
+class CL_DisplayWindow_Generic;
+
+class CL_InputDevice_LinuxUSBMouse : public CL_InputDevice_Generic,
+												 public CL_KeepAlive
+{
+private:
+	CL_DisplayWindow_Generic* parent;
+	std::string device;
+	int fd;
+
+	std::vector&lt;bool&gt; buttons;
+	CL_Point mouse_pos;
+public:
+	CL_InputDevice_LinuxUSBMouse(CL_DisplayWindow_Generic* parent, 
+										  const std::string&amp; dev);
+	~CL_InputDevice_LinuxUSBMouse();
+
+	//: Returns the x position of the device.
+	int get_x() const { return mouse_pos.x; }
+
+	//: Returns the y position of the device.
+	int get_y() const { return mouse_pos.y; }
+
+	//: Returns true if the passed key code is down for this device.
+	bool get_keycode(int keycode) const;
+	
+	std::string get_key_name(int id) const { return &quot;mouse-button&quot;; };
+
+	virtual float get_axis(int index) const { return 0; }
+
+	//: Returns the name of the device (i.e. 'Microsoft Sidewinder 3D').
+	std::string get_name() const { return &quot;Linux USB Mouse&quot;; }
+
+	//: Return the hardware id/device for this device (i.e. '/dev/input/js0')
+	std::string get_device_name() const { return &quot;linuxmouse:&quot; + device; }
+
+	//: Returns the number of axes available on this device.
+	int get_axis_count() const { return 0; }
+
+	//: Returns the number of buttons available on this device.
+	//- &lt;p&gt;If used on a keyboard, this function returns -1.&lt;/p&gt;
+	int get_button_count() const { return 0; }
+
+private:
+        void send_pointer_move(const CL_Point&amp; pos);
+        void send_ball_move(int delta_x, int delta_y);
+        void send_key_event(int key, bool press);
+        
+	//: Init device to Microsoft Explorer so that all buttons are accessible
+	void init_explorer_ps2();
+
+	void keep_alive();
+};
+
+#endif
+
+// Local Variables: ***
+// mode: clanlib ***
+// End: ***

Added: trunk/clanlib/GL/GLX/input_device_x11keyboard.cpp
===================================================================
--- trunk/clanlib/GL/GLX/input_device_x11keyboard.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/GLX/input_device_x11keyboard.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,173 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &lt;cstdio&gt;
+#include &quot;API/Display/input_device.h&quot;
+#include &quot;API/Display/input_event.h&quot;
+#include &quot;API/Display/keys.h&quot;
+#include &quot;input_device_x11keyboard.h&quot;
+#include &quot;../../GL/GLX/display_window_opengl.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_X11Keyboard construction:
+
+CL_InputDevice_X11Keyboard::CL_InputDevice_X11Keyboard(CL_DisplayWindow_OpenGL *owner) :
+	owner(owner)
+{
+	type = CL_InputDevice::keyboard;
+
+	slot_xevent = owner-&gt;sig_xevent.connect(
+		this, &amp;CL_InputDevice_X11Keyboard::on_xevent);
+
+	current_keys_down.clear();
+}
+
+CL_InputDevice_X11Keyboard::~CL_InputDevice_X11Keyboard()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_X11Keyboard attributes:
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_X11Keyboard operations:
+
+std::string CL_InputDevice_X11Keyboard::get_key_name(int virtual_key) const
+{
+	// Look up key name:
+	char *name = XKeysymToString(virtual_key);
+	if (name &amp;&amp; name[0] != 0) return name;
+
+	// Unknown. Return something at least :)
+	char buffer[256];
+	snprintf(buffer, 256, &quot;Unknown %d&quot;, virtual_key);
+	return buffer;
+}
+
+bool CL_InputDevice_X11Keyboard::get_keycode(int keysym) const
+{
+	// Ignore all key events when we don't have focus
+	if(!owner-&gt;has_focus())
+		return false;
+
+	char keyboard_state[32];
+
+	KeyCode code = XKeysymToKeycode(owner-&gt;get_display(), keysym);
+	XQueryKeymap(owner-&gt;get_display(), keyboard_state);
+
+	return keyboard_state[code/8] &amp; (1 &lt;&lt; code%8);
+}
+
+float CL_InputDevice_X11Keyboard::get_axis(int index) const
+{
+	return 0.0f;
+}
+
+std::string CL_InputDevice_X11Keyboard::get_name() const
+{
+	return &quot;System Keyboard&quot;;
+}
+
+std::string CL_InputDevice_X11Keyboard::get_device_name() const
+{
+  return &quot;x11:CoreKeyboard&quot;;
+}
+
+int CL_InputDevice_X11Keyboard::get_axis_count() const
+{
+	return 0;
+}
+
+int CL_InputDevice_X11Keyboard::get_button_count() const
+{
+	return -1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_X11Keyboard implementation:
+
+void CL_InputDevice_X11Keyboard::on_xevent(XEvent &amp;event)
+{
+	// Only handle keyboard events.
+	if (event.type != KeyPress &amp;&amp; event.type != KeyRelease) return;
+
+	// Figure out what key it was:
+	KeySym sym = XLookupKeysym(&amp;event.xkey, 0);
+
+	// set state of modifier keys
+	bool key_state = false;
+	if (event.type == KeyPress)
+		key_state = true;
+	
+	switch(sym)
+	{
+		case CL_KEY_LCONTROL: owner-&gt;left_ctrl_down = key_state; break;
+		case CL_KEY_LMENU: owner-&gt;left_alt_down = key_state; break;
+		case CL_KEY_LSHIFT: owner-&gt;left_shift_down = key_state; break;
+		case CL_KEY_RCONTROL: owner-&gt;right_ctrl_down = key_state; break;
+		case CL_KEY_RMENU: owner-&gt;right_alt_down = key_state; break;
+		case CL_KEY_RSHIFT: owner-&gt;right_shift_down = key_state; break;
+	}
+	
+	// Setup event structure for ClanLib:
+	CL_InputEvent key;
+	key.type = CL_InputEvent::released;
+	if (event.type == KeyPress) key.type = CL_InputEvent::pressed;
+	key.id = sym;
+	key.device = owner-&gt;keyboard;
+	if(current_keys_down.find(sym) == current_keys_down.end())
+	{
+		key.repeat_count = 0;
+		current_keys_down.insert(KeyDownCounter(sym,0));
+	}
+	else
+	{
+		current_keys_down[sym]++;
+		key.repeat_count = current_keys_down[sym];
+	}
+	
+	// Need to somehow get proper character sequence from X11. This code
+	// wont keep proper track of deadkeys:
+	char buf[11];
+	buf[10] = 0;
+	XLookupString(&amp;event.xkey, buf, 10, 0, 0);
+	if (strlen(buf) &gt; 0) key.str = std::string(buf, 1);
+
+	// Emit it.
+	if (key.type == CL_InputEvent::pressed)
+	{
+		owner-&gt;keyboard.sig_key_down().call(key);
+	}
+	else
+	{
+		owner-&gt;keyboard.sig_key_up().call(key);
+		current_keys_down.erase(sym);
+	}
+}

Added: trunk/clanlib/GL/GLX/input_device_x11keyboard.h
===================================================================
--- trunk/clanlib/GL/GLX/input_device_x11keyboard.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/GLX/input_device_x11keyboard.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,95 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_input_device_x11keyboard
+#define header_input_device_x11keyboard
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;Display/input_device_generic.h&quot;
+#include &quot;API/signals.h&quot;
+
+#include &lt;X11/Xlib.h&gt;
+#include &lt;X11/Xutil.h&gt;
+
+#include &lt;map&gt;
+
+class CL_DisplayWindow_OpenGL;
+
+class CL_InputDevice_X11Keyboard : public CL_InputDevice_Generic
+{
+//!Construction:
+public:
+	CL_InputDevice_X11Keyboard(CL_DisplayWindow_OpenGL *owner);
+
+	virtual ~CL_InputDevice_X11Keyboard();
+
+//!Attributes:
+public:
+
+//!Operations:
+public:
+	//: Key name for specified identifier (A, B, C, Space, Enter, Backspace).
+	std::string get_key_name(int id) const;
+  
+	//: Returns true if the passed key code is down for this device.
+	bool get_keycode(int keycode) const;
+
+	//: Returns the the current position of a joystick axis.
+	virtual float get_axis(int index) const;
+
+	//: Returns the name of the device (i.e. 'Microsoft Sidewinder 3D').
+	virtual std::string get_name() const;
+
+	//: Return the hardware id/device for this device (i.e. '/dev/input/js0')
+	virtual std::string get_device_name() const;
+
+	//: Returns the number of axes available on this device.
+	virtual int get_axis_count() const;
+
+	//: Returns the number of buttons available on this device.
+	//- &lt;p&gt;If used on a keyboard, this function returns -1.&lt;/p&gt;
+	virtual int get_button_count() const;
+
+//!Implementation:
+private:
+	void on_xevent(XEvent &amp;event);
+	
+	CL_Slot slot_xevent;
+
+	CL_DisplayWindow_OpenGL *owner;
+
+	std::map&lt;KeySym,int&gt; current_keys_down;
+	typedef std::pair&lt;KeySym,int&gt; KeyDownCounter;
+
+};
+
+#endif

Added: trunk/clanlib/GL/GLX/input_device_x11mouse.cpp
===================================================================
--- trunk/clanlib/GL/GLX/input_device_x11mouse.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/GLX/input_device_x11mouse.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,226 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &lt;cstdio&gt;
+
+#include &quot;API/Display/input_device.h&quot;
+#include &quot;API/Display/input_event.h&quot;
+#include &quot;input_device_x11mouse.h&quot;
+
+#include &quot;../../GL/GLX/display_window_opengl.h&quot;
+
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_X11Mouse construction:
+
+CL_InputDevice_X11Mouse::CL_InputDevice_X11Mouse(CL_DisplayWindow_OpenGL *owner) :
+	mouse_pos(-1,-1), time_at_last_press(0), last_press_id(-1), owner(owner)
+{
+	type = CL_InputDevice::mouse;
+	
+	for( int i=0; i&lt;5; i++)
+		key_states[i] = false;
+	
+	slot_xevent = owner-&gt;sig_xevent.connect(
+		this, &amp;CL_InputDevice_X11Mouse::on_xevent);
+}
+
+CL_InputDevice_X11Mouse::~CL_InputDevice_X11Mouse()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_X11Mouse attributes:
+
+int CL_InputDevice_X11Mouse::get_x() const
+{
+	return mouse_pos.x;
+}
+
+int CL_InputDevice_X11Mouse::get_y() const
+{
+	return mouse_pos.y;
+}
+
+bool CL_InputDevice_X11Mouse::get_keycode(int keycode) const
+{
+	if( keycode &gt;= 0 &amp;&amp; keycode &lt; 5 )
+		return key_states[keycode];
+	return false;
+}
+
+float CL_InputDevice_X11Mouse::get_axis(int index) const
+{
+	return 0.0f;
+}
+
+std::string CL_InputDevice_X11Mouse::get_name() const
+{
+	return &quot;System Mouse&quot;;
+}
+
+std::string CL_InputDevice_X11Mouse::get_device_name() const
+{
+  return &quot;x11:CorePointer&quot;;
+}
+
+int CL_InputDevice_X11Mouse::get_axis_count() const
+{
+	return 0;
+}
+
+int CL_InputDevice_X11Mouse::get_button_count() const
+{
+	return -1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_X11Mouse operations:
+
+std::string CL_InputDevice_X11Mouse::get_key_name(int id) const
+{
+	switch (id)
+	{
+	case 0: return &quot;Mouse left&quot;;
+	case 1: return &quot;Mouse right&quot;;
+	case 2: return &quot;Mouse middle&quot;;
+	case 3: return &quot;Mouse wheel up&quot;;
+	case 4: return &quot;Mouse wheel down&quot;;
+	}
+
+	char buf[256];
+	sprintf(buf, &quot;Mouse button %d&quot;, id);
+	return buf;
+}
+
+void CL_InputDevice_X11Mouse::set_position(int x, int y)
+{
+	XWarpPointer(
+		owner-&gt;get_display(),
+		None,
+		owner-&gt;get_window(),
+		0, 0,
+		0, 0,
+		x, y);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_InputDevice_X11Mouse implementation:
+
+void CL_InputDevice_X11Mouse::on_xevent(XEvent &amp;event)
+{
+	// Only handle mouse events.
+	if (event.type != ButtonPress
+		&amp;&amp; event.type != ButtonRelease
+		&amp;&amp; event.type != MotionNotify )
+		return;
+	
+	if (event.type == ButtonPress || event.type == ButtonRelease )
+		received_mouse_input(event);
+	else
+		received_mouse_move(event);
+}
+
+void CL_InputDevice_X11Mouse::received_mouse_input(XEvent &amp;e)
+{
+	XButtonEvent event = (XButtonEvent&amp;)e;
+	
+	int id = 0;
+	bool down = false;
+	int repeat_count = 0;
+	
+	mouse_pos.x = event.x;
+	mouse_pos.y = event.y;
+
+	Time time_change = event.time - time_at_last_press;
+	
+	switch(event.button)
+	{
+		case 1: id = 0; break; // left
+		case 3: id = 1; break; // right
+		case 2: id = 2; break; // middle
+		default: id = event.button-1;
+	}
+	
+	if (event.type == ButtonPress)
+	{
+		time_at_last_press = event.time;
+		last_press_id = id;
+	}
+	
+	CL_InputEvent::Type event_type = CL_InputEvent::released;
+	
+	if (event.type == ButtonPress)
+	{
+		event_type = CL_InputEvent::pressed;
+		down = true;
+		if(time_change &lt; 500)
+			repeat_count = 2;
+	}
+	
+	if( id &gt;= 0 &amp;&amp; id &lt; 5 )
+		key_states[id] = down;
+
+	// Prepare event to be emitted:
+	CL_InputEvent key;
+	key.id        = id;
+	key.type      = event_type;
+	key.device    = owner-&gt;mouse;
+	key.mouse_pos = mouse_pos;
+	key.repeat_count = repeat_count;
+	// Emit message:
+	if(repeat_count &gt; 1)
+	{
+		owner-&gt;mouse.sig_key_dblclk().call(key);
+	}
+	else if (down)
+	{
+		owner-&gt;mouse.sig_key_down().call(key);
+	}
+	else
+		owner-&gt;mouse.sig_key_up().call(key);
+}
+
+void CL_InputDevice_X11Mouse::received_mouse_move(XEvent &amp;e)
+{
+	XMotionEvent event = (XMotionEvent&amp;)e;
+	
+	mouse_pos.x = event.x;
+	mouse_pos.y = event.y;
+	
+	// Prepare event to be emitted:
+	CL_InputEvent key;
+	key.type      = CL_InputEvent::moved;
+	key.device    = owner-&gt;mouse;
+	key.mouse_pos = mouse_pos;
+	
+	// Fire off signal
+	owner-&gt;mouse.sig_move().call(key);
+}

Added: trunk/clanlib/GL/GLX/input_device_x11mouse.h
===================================================================
--- trunk/clanlib/GL/GLX/input_device_x11mouse.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/GLX/input_device_x11mouse.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,103 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_input_device_x11mouse
+#define header_input_device_x11mouse
+
+#include &quot;Display/input_device_generic.h&quot;
+#include &quot;API/signals.h&quot;
+#include &quot;API/Core/Math/point.h&quot;
+
+#include &lt;X11/Xlib.h&gt;
+#include &lt;X11/Xutil.h&gt;
+
+class CL_DisplayWindow_OpenGL;
+
+class CL_InputDevice_X11Mouse : public CL_InputDevice_Generic
+{
+//!Construction:
+public:
+	CL_InputDevice_X11Mouse(CL_DisplayWindow_OpenGL *owner);
+
+	virtual ~CL_InputDevice_X11Mouse();
+
+//!Attributes:
+public:
+	//: Returns the x position of the device.
+	virtual int get_x() const;
+
+	//: Returns the y position of the device.
+	virtual int get_y() const;
+
+	//: Returns true if the passed key code is down for this device.
+	virtual bool get_keycode(int keycode) const;
+
+	//: Returns the the current position of a joystick axis.
+	virtual float get_axis(int index) const;
+
+	//: Returns the name of the device (i.e. 'Microsoft Sidewinder 3D').
+	virtual std::string get_name() const;
+
+	//: Return the hardware id/device for this device (i.e. '/dev/input/js0')
+	virtual std::string get_device_name() const;
+
+	//: Returns the number of axes available on this device.
+	virtual int get_axis_count() const;
+
+	//: Returns the number of buttons available on this device.
+	//- &lt;p&gt;If used on a keyboard, this function returns -1.&lt;/p&gt;
+	virtual int get_button_count() const;
+
+//!Operations:
+public:
+	//: Key name for specified identifier (A, B, C, Space, Enter, Backspace).
+	virtual std::string get_key_name(int id) const;
+
+	//: Sets the position of the device.
+	virtual void set_position(int x, int y);
+
+//!Implementation:
+private:
+	void on_xevent(XEvent &amp;event);
+	
+	void received_mouse_input(XEvent &amp;event);
+	void received_mouse_move(XEvent &amp;event);
+	
+	CL_Slot slot_xevent;
+	
+	CL_Point mouse_pos;
+	Time time_at_last_press;
+	int last_press_id;
+
+	bool key_states[5];
+	
+	CL_DisplayWindow_OpenGL *owner;
+};
+
+#endif

Added: trunk/clanlib/GL/GLX/input_device_xinput.cpp
===================================================================
--- trunk/clanlib/GL/GLX/input_device_xinput.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/GLX/input_device_xinput.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,427 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &lt;iostream&gt;
+#include &quot;API/Core/System/log.h&quot;
+#include &quot;API/Display/input_device.h&quot;
+#include &quot;API/Display/input_event.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;input_device_xinput.h&quot;
+#include &quot;display_window_opengl.h&quot;
+
+#define INVALID_EVENT_TYPE	-1
+
+CL_InputDevice_XInput::CL_InputDevice_XInput(CL_DisplayWindow_OpenGL *owner_, 
+															XDeviceInfo* info)
+	: owner(owner_),
+	  name(info-&gt;name),
+	  absolute(false),
+	  num_keys   (0),
+	  motion_type        (INVALID_EVENT_TYPE),
+	  button_press_type  (INVALID_EVENT_TYPE),
+	  button_release_type(INVALID_EVENT_TYPE),
+	  key_press_type     (INVALID_EVENT_TYPE),
+	  key_release_type   (INVALID_EVENT_TYPE),
+	  proximity_in_type  (INVALID_EVENT_TYPE),
+	  proximity_out_type (INVALID_EVENT_TYPE)
+
+{
+  type = CL_InputDevice::tablet;  
+
+  //info = find_device_info(owner-&gt;get_display(), name.c_str(), True);
+  //if (!info)
+  // throw CL_Error(&quot;CL_InputDeviceXInput Error: Couldn't find device: &quot; + name);
+
+  get_info(info);
+
+  if (!register_events(owner-&gt;get_display(), info, name.c_str(), True))
+  {
+	  CL_Log::log(&quot;debug&quot;, &quot;CL_InputDeviceXInput: Couldn't find device: &quot; + name);
+  }
+  else
+  {
+	  slot_xevent = owner-&gt;sig_unknown_xevent.connect(this, &amp;CL_InputDevice_XInput::on_xevent);
+  }
+}
+
+CL_InputDevice_XInput::~CL_InputDevice_XInput()
+{
+	
+}
+
+void
+CL_InputDevice_XInput::get_info(XDeviceInfo	*info)
+{
+	int			i,j;
+	XAnyClassPtr	any;
+	XKeyInfoPtr		k;
+	XButtonInfoPtr	b;
+	XValuatorInfoPtr	v;
+	XAxisInfoPtr	a;
+
+	//printf(&quot;\&quot;%s\&quot;\tid=%ld\t[%s]\n&quot;, info-&gt;name, info-&gt;id,
+	//		 (info-&gt;use == IsXExtensionDevice) ? &quot;XExtensionDevice&quot; :
+//			 ((info-&gt;use == IsXPointer) ? &quot;XPointer&quot; : &quot;XKeyboard&quot;));
+
+	if (info-&gt;num_classes &gt; 0) {
+		any = (XAnyClassPtr) (info-&gt;inputclassinfo);
+		for (i=0; i&lt;info-&gt;num_classes; i++) {
+			switch (any-&gt;c_class) {
+			case KeyClass:
+				k = (XKeyInfoPtr) any;
+				//printf(&quot;\tNum_keys is %d\n&quot;, k-&gt;num_keys);
+				//printf(&quot;\tMin_keycode is %d\n&quot;, k-&gt;min_keycode);
+				//printf(&quot;\tMax_keycode is %d\n&quot;, k-&gt;max_keycode);
+
+				num_keys = k-&gt;num_keys;
+				break;
+
+			case ButtonClass:
+				b = (XButtonInfoPtr) any;
+				//printf(&quot;\tNum_buttons is %d\n&quot;, b-&gt;num_buttons);
+
+				buttons.resize(b-&gt;num_buttons, false);
+				break;
+
+			case ValuatorClass:
+				v = (XValuatorInfoPtr) any;
+				a = (XAxisInfoPtr) ((char *) v + 
+										  sizeof (XValuatorInfo));
+
+				//printf(&quot;\tNum_axes is %d\n&quot;, v-&gt;num_axes);
+				//printf(&quot;\tMode is %s\n&quot;, (v-&gt;mode == Absolute) ? &quot;Absolute&quot; : &quot;Relative&quot;);
+				//printf(&quot;\tMotion_buffer is %ld\n&quot;, v-&gt;motion_buffer);
+
+				absolute = (v-&gt;mode == Absolute);
+
+				for (j=0; j&lt;v-&gt;num_axes; j++, a++) 
+				{
+					//printf(&quot;\tAxis %d :\n&quot;, j);
+					//printf(&quot;\t\tMin_value is %d\n&quot;, a-&gt;min_value);
+					//printf(&quot;\t\tMax_value is %d\n&quot;, a-&gt;max_value);
+					//printf (&quot;\t\tResolution is %d\n&quot;, a-&gt;resolution);
+					
+					axis.push_back(AxisInfo(a-&gt;min_value, a-&gt;max_value, a-&gt;resolution));
+				}
+
+				break;
+		
+			default:
+				printf (&quot;unknown class\n&quot;);
+			}
+			any = (XAnyClassPtr) ((char *) any + any-&gt;length);
+		}
+	}
+}
+
+XDeviceInfo*
+CL_InputDevice_XInput::find_device_info(Display	*display,
+													 const char		*name,
+													 Bool		only_extended)
+{
+	// FIXME: Not really needed could simply pass XDeviceInfo to the
+	// constructor, might however make a nicer interface
+	XDeviceInfo	*devices;
+	int		loop;
+	int		num_devices;
+	int		len = strlen(name);
+	Bool     is_id = True;
+	XID		id = 0;
+    
+	for(loop=0; loop&lt;len; loop++) {
+		if (!isdigit(name[loop])) {
+			is_id = False;
+			break;
+		}
+	}
+
+	if (is_id) {
+		id = atoi(name);
+	}
+    
+	devices = XListInputDevices(display, &amp;num_devices);
+
+	for(loop=0; loop&lt;num_devices; loop++) {
+		if ((!only_extended || (devices[loop].use == IsXExtensionDevice)) &amp;&amp;
+			 ((!is_id &amp;&amp; strcmp(devices[loop].name, name) == 0) ||
+			  (is_id &amp;&amp; devices[loop].id == id))) {
+			return &amp;devices[loop];
+		}
+	}
+	return NULL;
+}
+
+int
+CL_InputDevice_XInput::register_events(Display		*dpy,
+													XDeviceInfo	*info,
+													const char		*dev_name,
+													Bool		handle_proximity)
+{
+	int             number = 0;	/* number of events registered */
+	XEventClass     event_list[7];
+	int             i;
+	XDevice         *device;
+	Window          root_win;
+	unsigned long   screen;
+	XInputClassInfo *ip;
+
+	screen   = DefaultScreen(dpy);
+	root_win = RootWindow(dpy, screen);
+
+	device = XOpenDevice(dpy, info-&gt;id);
+
+	if (!device) {
+		fprintf(stderr, &quot;unable to open device %s\n&quot;, dev_name);
+		return 0;
+	}
+    
+	if (device-&gt;num_classes &gt; 0) {
+		for (ip = device-&gt;classes, i=0; i&lt;info-&gt;num_classes; ip++, i++) {
+			switch (ip-&gt;input_class) {
+			case KeyClass:
+				DeviceKeyPress  (device, key_press_type,   event_list[number]); number++;
+				DeviceKeyRelease(device, key_release_type, event_list[number]); number++;
+				break;
+
+			case ButtonClass:
+				DeviceButtonPress  (device, button_press_type,   event_list[number]); number++;
+				DeviceButtonRelease(device, button_release_type, event_list[number]); number++;
+				break;
+
+			case ValuatorClass:
+				DeviceMotionNotify(device, motion_type, event_list[number]); number++;
+				if (handle_proximity) {
+					ProximityIn (device, proximity_in_type,  event_list[number]); number++;
+					ProximityOut(device, proximity_out_type, event_list[number]); number++;
+				}
+				break;
+		
+			default:
+				fprintf(stderr, &quot;unknown class\n&quot;);
+				break;
+			}
+		}
+
+		if (XSelectExtensionEvent(dpy, root_win, event_list, number)) {
+			fprintf(stderr, &quot;error selecting extended events\n&quot;);
+			return 0;
+		}
+	}
+
+	//std::cout &lt;&lt; &quot;### Registered events: &quot; &lt;&lt; number &lt;&lt; std::endl;
+	return number;
+}
+
+void
+CL_InputDevice_XInput::on_xevent(XEvent &amp;event)
+{
+	if (0)
+		std::cout &lt;&lt; this &lt;&lt; &quot; event: &quot; 
+					 &lt;&lt; event.type &lt;&lt; &quot; Defs: &quot;
+					 &lt;&lt; motion_type &lt;&lt; &quot; &quot; 
+					 &lt;&lt; button_press_type &lt;&lt; &quot; &quot; 
+					 &lt;&lt; button_release_type &lt;&lt; &quot; &quot; 
+					 &lt;&lt; key_press_type &lt;&lt; &quot; &quot; 
+					 &lt;&lt; key_release_type &lt;&lt; &quot; &quot; 
+					 &lt;&lt; proximity_out_type &lt;&lt; &quot; &quot; 
+					 &lt;&lt; proximity_in_type &lt;&lt; &quot; &quot; 
+					 &lt;&lt; std::endl;
+
+	std::vector&lt;AxisInfo&gt; old_axis = axis;
+	std::vector&lt;bool&gt;     old_buttons = buttons;
+
+  	if (event.type == motion_type) 
+	{
+		XDeviceMotionEvent *motion = (XDeviceMotionEvent *) &event;
+
+		//printf(&quot;motion &quot;);
+	    
+		for(int loop=0; loop&lt;motion-&gt;axes_count; loop++) {
+			//printf(&quot;a[%d]=%d &quot;, motion-&gt;first_axis + loop, motion-&gt;axis_data[loop]);
+			axis[loop + motion-&gt;first_axis].pos = motion-&gt;axis_data[loop];
+		}
+		//printf(&quot;\n&quot;);
+	} 
+	else if ((event.type == button_press_type) ||
+				(event.type == button_release_type)) 
+	{
+		int	loop;
+		XDeviceButtonEvent *button = (XDeviceButtonEvent *) &event;
+	    
+		//printf(&quot;button %s %d &quot;, (event.type == button_release_type) ? &quot;release&quot; : &quot;press  &quot;, button-&gt;button);
+
+		buttons[button-&gt;button] = (event.type == button_press_type);
+	    
+		for(loop=0; loop&lt;button-&gt;axes_count; loop++) {
+			//printf(&quot;a[%d]=%d &quot;, button-&gt;first_axis + loop, button-&gt;axis_data[loop]);
+			axis[loop + button-&gt;first_axis].pos = button-&gt;axis_data[loop];
+		}
+		//printf(&quot;\n&quot;);
+	} 
+	else if ((event.type == key_press_type) ||
+				(event.type == key_release_type)) 
+	{
+		int	loop;
+		XDeviceKeyEvent *key = (XDeviceKeyEvent *) &event;
+	    
+		//printf(&quot;key %s %d &quot;, (event.type == key_release_type) ? &quot;release&quot; : &quot;press  &quot;, key-&gt;keycode);
+	    
+		for(loop=0; loop&lt;key-&gt;axes_count; loop++) {
+			//printf(&quot;a[%d]=%d &quot;, key-&gt;first_axis + loop, key-&gt;axis_data[loop]);
+			axis[loop + key-&gt;first_axis].pos = key-&gt;axis_data[loop];
+		}
+		//printf(&quot;\n&quot;);
+	}
+	else if ((event.type == proximity_out_type) ||
+				(event.type == proximity_in_type))
+	{
+		int	loop;
+		XProximityNotifyEvent *prox = (XProximityNotifyEvent *) &event;
+	    
+		//printf(&quot;proximity %s &quot;, (event.type == proximity_in_type) ? &quot;in &quot; : &quot;out&quot;);
+	    
+		for(loop=0; loop&lt;prox-&gt;axes_count; loop++) {
+			//printf(&quot;a[%d]=%d &quot;, prox-&gt;first_axis + loop, prox-&gt;axis_data[loop]);
+			axis[loop + prox-&gt;first_axis].pos = prox-&gt;axis_data[loop];
+		}
+		//printf(&quot;\n&quot;);
+	}
+	else 
+	{
+		//printf(&quot;CL_InputDevice_XInput: what's that %d\n&quot;, event.type);
+	}
+
+
+	for (std::vector&lt;bool&gt;::size_type i = 0; i &lt; buttons.size(); ++i)
+	{
+		if (buttons[i] != old_buttons[i])
+		{
+			CL_InputEvent ie;
+			
+			ie.id           = i;
+			ie.type         = CL_InputEvent::pressed;
+			ie.device       = CL_InputDevice(this);
+			ie.mouse_pos    = CL_Point(0, 0);
+			ie.axis_pos     = 0;
+			ie.repeat_count = false;
+
+			sig_axis_move(ie);
+		}
+	}
+
+	for (std::vector&lt;AxisInfo&gt;::size_type i = 0; i &lt; axis.size(); ++i)
+	{
+		if (axis[i].pos != old_axis[i].pos)
+		{
+			CL_InputEvent ie;
+			
+			ie.id           = i;
+			ie.type         = CL_InputEvent::axis_moved;
+			ie.device       = CL_InputDevice(this);
+			ie.mouse_pos    = CL_Point(0, 0);
+			ie.axis_pos     = get_axis(i);
+			ie.repeat_count = false;
+
+			sig_axis_move(ie);
+		}
+	}
+}
+
+int
+CL_InputDevice_XInput::get_x() const
+{
+	return 0;
+}
+
+int
+CL_InputDevice_XInput::get_y() const
+{
+	return 0;
+}
+
+bool
+CL_InputDevice_XInput::get_keycode(int keycode) const
+{
+	if (keycode &gt;=0 &amp;&amp; keycode &lt; int(buttons.size()))
+	{
+		return buttons[keycode];
+	}
+	else
+	{
+		return false;
+	}
+}
+
+std::string
+CL_InputDevice_XInput::get_key_name(int id) const
+{
+	return &quot;button&quot; + CL_String::from_int(id);
+}
+
+float
+CL_InputDevice_XInput::get_axis(int index) const
+{
+	if (index &gt;= 0 &amp;&amp; index &lt; get_axis_count())
+	{
+		return float(axis[index].pos)/(axis[index].max_value - axis[index].min_value);
+	}
+	else
+	{
+		return 0.0f;
+	}
+}
+
+int
+CL_InputDevice_XInput::get_axis_count() const
+{
+	return axis.size();
+}
+
+std::string
+CL_InputDevice_XInput::get_name() const
+{
+	return name;
+}
+
+std::string
+CL_InputDevice_XInput::get_device_name() const
+{
+	return &quot;xinput:&quot; + name;
+}
+
+int
+CL_InputDevice_XInput::get_button_count() const
+{
+	return buttons.size();
+}
+
+// Local Variables: ***
+// mode: clanlib ***
+// End: ***

Added: trunk/clanlib/GL/GLX/input_device_xinput.h
===================================================================
--- trunk/clanlib/GL/GLX/input_device_xinput.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/GLX/input_device_xinput.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,146 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_input_device_xinput
+#define header_input_device_xinput
+
+#include &quot;Display/input_device_generic.h&quot;
+#include &quot;API/signals.h&quot;
+#include &quot;API/Core/Math/point.h&quot;
+#include &lt;X11/Xlib.h&gt;
+#include &lt;X11/Xutil.h&gt;
+#include &lt;X11/extensions/XInput.h&gt;
+
+class CL_DisplayWindow_OpenGL;
+
+class CL_InputDevice_XInput : public CL_InputDevice_Generic
+{
+	//!Construction:
+public:
+	CL_InputDevice_XInput(CL_DisplayWindow_OpenGL *owner,
+								 XDeviceInfo* info);
+
+	virtual ~CL_InputDevice_XInput();
+
+	//!Attributes:
+public:
+	//: Returns the x position of the device.
+	virtual int get_x() const;
+
+	//: Returns the y position of the device.
+	virtual int get_y() const;
+
+	//: Returns true if the passed key code is down for this device.
+	virtual bool get_keycode(int keycode) const;
+
+	//: Key name for specified identifier (A, B, C, Space, Enter, Backspace).
+	virtual std::string get_key_name(int id) const;
+
+	//: Returns the the current position of a joystick axis.
+	virtual float get_axis(int index) const;
+
+	//: Returns the number of axes available on this device.
+	virtual int get_axis_count() const;
+
+	//: Returns the name of the device (i.e. 'Microsoft Sidewinder 3D').
+	virtual std::string get_name() const;
+
+	//: Return the hardware id/device for this device (i.e. '/dev/input/js0')
+	virtual std::string get_device_name() const;
+
+	//: Returns the number of buttons available on this device.
+	//- &lt;p&gt;If used on a keyboard, this function returns -1.&lt;/p&gt;
+	virtual int get_button_count() const;
+
+	//!Operations:
+public:
+
+	//!Implementation:
+private:
+	int register_events(Display		*dpy,
+							  XDeviceInfo	*info,
+							  const char		*dev_name,
+							  Bool		handle_proximity);
+
+	XDeviceInfo* find_device_info(Display	*display,
+											const char		*name,
+											Bool		only_extended);
+
+	void get_info(XDeviceInfo	*info);
+
+	void on_xevent(XEvent &amp;event);
+	
+	void received_mouse_input(XEvent &amp;event);
+	void received_mouse_move(XEvent &amp;event);
+	
+	CL_DisplayWindow_OpenGL *owner;
+	std::string name;
+	CL_Slot slot_xevent;
+
+	//: true: Device is a absolute pointing device, false: relative
+	bool absolute;
+
+	struct AxisInfo
+	{
+		int min_value;
+		int max_value;
+		int resolution;
+		int pos;
+
+		AxisInfo(int min_value_, int max_value_, int resolution_)
+			: min_value(min_value_), max_value(max_value_), resolution(resolution_), pos(0)
+		{}
+	};
+
+	std::vector&lt;bool&gt; buttons;
+
+	std::vector&lt;AxisInfo&gt; axis;
+
+	int num_keys;	
+	
+	CL_Point mouse_pos;
+	Time time_at_last_press;
+	int last_press_id;
+
+	bool key_states[5];
+
+	int           motion_type;
+	int           button_press_type;
+	int           button_release_type;
+	int           key_press_type;
+	int           key_release_type;
+	int           proximity_in_type;
+	int           proximity_out_type;
+};
+
+#endif
+
+// Local Variables: ***
+// mode: clanlib ***
+// End: ***

Added: trunk/clanlib/GL/Makefile.am
===================================================================
--- trunk/clanlib/GL/Makefile.am	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/Makefile.am	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,66 @@
+lib_LTLIBRARIES = libclanGL.la
+
+libclanGL_la_SOURCES = \
+graphic_context_opengl.cpp \
+graphic_context_opengl.h \
+gl_state_checker.cpp \
+pixel_buffer_opengl_texture.cpp \
+pixel_buffer_opengl_texture.h \
+opengl.cpp \
+opengl_target.cpp \
+opengl_target.h \
+opengl_window.cpp \
+opengl_window_description.cpp \
+opengl_window_description_generic.h \
+setupgl.cpp \
+opengl_surface.cpp \
+surface_target_opengl.cpp \
+surface_target_opengl.h \
+canvas_opengl.cpp \
+canvas_opengl.h \
+opengl_state.cpp \
+opengl_state_generic.cpp \
+opengl_state_generic.h \
+opengl_state_data.cpp \
+viewpoint.cpp \
+light_source.cpp \
+shader_object.cpp \
+program_object.cpp \
+program_attribute.cpp \
+program_uniform.cpp \
+texture.cpp
+
+if WIN32
+libclanGL_la_SOURCES += \
+WGL/display_window_opengl.h \
+WGL/display_window_opengl.cpp
+else
+libclanGL_la_SOURCES += \
+GLX/display_window_opengl.h \
+GLX/display_window_opengl.cpp \
+GLX/input_device_linuxjoystick.cpp \
+GLX/input_device_linuxjoystick.h \
+GLX/input_device_linuxevent.cpp \
+GLX/input_device_linuxevent.h \
+GLX/input_device_linuxusbmouse.cpp \
+GLX/input_device_linuxusbmouse.h \
+GLX/display_window_opengl.h \
+GLX/input_device_x11mouse.cpp \
+GLX/input_device_x11mouse.h \
+GLX/input_device_x11keyboard.cpp \
+GLX/input_device_x11keyboard.h \
+GLX/input_device_xinput.cpp \
+GLX/input_device_xinput.h
+libclanGL_la_LIBADD = -lXxf86vm -lXi -lGLU -lGL 
+endif
+
+EXTRA_DIST = \
+ WGL/displaycard_opengl_win32.cpp \
+ WGL/displaycard_opengl_win32.h   \
+ WGL/setupgl_win32.cpp
+
+libclanGL_la_LDFLAGS = \
+  -release $(LT_RELEASE) \
+  -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE)
+
+# EOF #

Added: trunk/clanlib/GL/WGL/display_window_opengl.cpp
===================================================================
--- trunk/clanlib/GL/WGL/display_window_opengl.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/WGL/display_window_opengl.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,348 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;display_window_opengl.h&quot;
+#include &quot;GL/graphic_context_opengl.h&quot;
+#include &quot;GL/gl_state_checker.h&quot;
+#include &quot;API/Display/display_window_description.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/GL/opengl_state.h&quot;
+#include &quot;API/GL/opengl_wrap.h&quot;
+#include &quot;API/GL/opengl_window_description.h&quot;
+#include &quot;GL/opengl_window_description_generic.h&quot;
+
+#ifndef AC_SRC_ALPHA
+#define AC_SRC_ALPHA 1
+#endif
+
+#ifndef ULW_OPAQUE
+#define ULW_OPAQUE 0
+#endif
+
+#ifndef ULW_COLORKEY
+#define ULW_COLORKEY 1
+#endif
+
+#ifndef ULW_ALPHA
+#define ULW_ALPHA 2
+#endif
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_DisplayWindow_OpenGL::CL_DisplayWindow_OpenGL()
+{
+	layered_dc = 0;
+	layered_bitmap = 0;
+	context = 0;
+	hdc = 0;
+	gc = CL_GraphicContext(new CL_GraphicContext_OpenGL(this));
+	user32_dll = 0;
+}
+
+CL_DisplayWindow_OpenGL::~CL_DisplayWindow_OpenGL()
+{
+	destroy_window();
+	if (layered_bitmap)
+	{
+		SelectObject(layered_dc, layered_orig_bitmap);
+		DeleteObject(layered_bitmap);
+	}
+	if (layered_dc) DeleteDC(layered_dc);
+	if (user32_dll) FreeLibrary(user32_dll);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+CL_GraphicContext *CL_DisplayWindow_OpenGL::get_gc()
+{
+	return &gc;
+}
+
+CL_PixelBuffer CL_DisplayWindow_OpenGL::get_buffer(int i) const
+{
+	if (i == 0) 
+	{
+		return gc.get_pixeldata(CL_Rect(0, 0, get_width(), get_height()), CL_FRONT);
+	}
+	else
+	{
+		return gc.get_pixeldata(CL_Rect(0, 0, get_width(), get_height()), CL_BACK);
+	}
+}
+
+int CL_DisplayWindow_OpenGL::get_buffer_count() const
+{
+	return 2;
+}
+
+HDC CL_DisplayWindow_OpenGL::get_dc()
+{
+	if (layered_dc) return layered_dc;
+	return hdc;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_DisplayWindow_OpenGL::create_window(const CL_DisplayWindowDescription &amp;desc)
+{
+	if (desc.is_fullscreen())
+	{
+		set_videomode(desc.get_size().width, desc.get_size().height, desc.get_bpp(), desc.get_refresh_rate());
+	}
+	else
+	{
+		restore_videomode();
+	}
+
+	CL_DisplayWindow_Win32::create_window(desc);
+
+	if (context) return; // OpenGL already setup for this window
+
+	// Setup OpenGL:
+
+	hdc = GetDC(get_hwnd());
+	
+	PIXELFORMATDESCRIPTOR pfd;
+	memset(&amp;pfd, 0, sizeof(PIXELFORMATDESCRIPTOR));
+	pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR);
+	pfd.nVersion = 1;
+	pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL;
+
+	const CL_OpenGLWindowDescription_Generic *gldesc = dynamic_cast&lt;const CL_OpenGLWindowDescription_Generic*&gt;(desc.impl.get());
+	if (gldesc)
+	{
+		pfd.iPixelType = (gldesc-&gt;rgba) ? PFD_TYPE_RGBA : PFD_TYPE_COLORINDEX;
+		if (gldesc-&gt;doublebuffer) pfd.dwFlags |= PFD_DOUBLEBUFFER;
+		if (gldesc-&gt;stereo) pfd.dwFlags |= PFD_STEREO;
+		pfd.cColorBits = gldesc-&gt;buffer_size;
+		pfd.iLayerType = gldesc-&gt;level; // MSDN docs say this one is ignored! -- mbn 12. jan 2004
+		pfd.cAuxBuffers = gldesc-&gt;aux_buffers;
+		pfd.cRedBits = gldesc-&gt;red_size;
+		pfd.cGreenBits = gldesc-&gt;green_size;
+		pfd.cBlueBits = gldesc-&gt;blue_size;
+		pfd.cAlphaBits = gldesc-&gt;alpha_size;
+		pfd.cDepthBits = gldesc-&gt;depth_size;
+		pfd.cStencilBits = gldesc-&gt;stencil_size;
+		pfd.cAccumRedBits = gldesc-&gt;accum_red_size;
+		pfd.cAccumGreenBits = gldesc-&gt;accum_green_size;
+		pfd.cAccumBlueBits = gldesc-&gt;accum_blue_size;
+		pfd.cAccumAlphaBits = gldesc-&gt;accum_alpha_size;
+		// gldesc dont have an accum bits, so trying to calculate it:
+		pfd.cAccumBits = (pfd.cAccumRedBits + pfd.cAccumGreenBits + pfd.cAccumBlueBits + pfd.cAccumAlphaBits + 7) / 8;
+		pfd.cAccumBits *= 8;
+		
+	}
+	else
+	{
+		pfd.iPixelType = PFD_TYPE_RGBA;
+		pfd.iLayerType = PFD_MAIN_PLANE;
+		pfd.dwFlags |= PFD_DOUBLEBUFFER;
+		pfd.cColorBits = 24;
+		pfd.cDepthBits = 16;
+		pfd.cStencilBits = 8;
+	}
+
+	if (desc.is_layered())
+	{
+		pfd.cAlphaBits = 8;
+		pfd.dwFlags |= PFD_DRAW_TO_BITMAP | PFD_DOUBLEBUFFER_DONTCARE;
+	}
+
+	if (desc.is_layered())
+	{
+		if (user32_dll == 0)
+		{
+			user32_dll = LoadLibrary(&quot;user32.dll&quot;);
+			if (user32_dll == 0) throw CL_Error(&quot;Unable to load user32.dll!&quot;);
+
+			ptr_UpdateLayeredWindow = (PtrUpdateLayeredWindow) GetProcAddress(user32_dll, &quot;UpdateLayeredWindow&quot;);
+			if (ptr_UpdateLayeredWindow == 0)
+			{
+				FreeLibrary(user32_dll);
+				user32_dll = 0;
+				throw CL_Error(&quot;Layered windows require Windows 2000 or Windows XP!&quot;);
+			}
+		}
+
+		layered_dc = CreateCompatibleDC(hdc);
+		cl_assert(layered_dc != 0);
+
+		layered_bitmap = CreateCompatibleBitmap(hdc, desc.get_size().width, desc.get_size().height);
+		cl_assert(layered_bitmap != 0);
+		layered_orig_bitmap = (HBITMAP) SelectObject(layered_dc, layered_bitmap);
+	}
+
+	int pixelformat = ChoosePixelFormat(get_dc(), &amp;pfd);
+	SetPixelFormat(get_dc(), pixelformat, &amp;pfd);
+
+	context = wglCreateContext(get_dc());
+	cl_assert(context != NULL);
+
+	if (!opengl_contexts.empty()) wglShareLists(opengl_contexts.back(), context);
+	opengl_contexts.push_back(context);
+
+	ShowWindow(get_hwnd(), SW_SHOW);
+	UpdateWindow(get_hwnd());
+}
+
+void CL_DisplayWindow_OpenGL::destroy_window()
+{
+	if (context)
+	{
+		wglMakeCurrent(0, 0);
+		wglDeleteContext(context);
+		context = 0;
+		opengl_contexts.remove(context);
+	}
+
+	if (layered_bitmap)
+	{
+		SelectObject(layered_dc, layered_orig_bitmap);
+		DeleteObject(layered_bitmap);
+
+		layered_bitmap = 0;
+	}
+
+	if (layered_dc) DeleteDC(layered_dc);
+	layered_dc = 0;
+
+	if (is_fullscreen()) restore_videomode();
+	CL_DisplayWindow_Win32::destroy_window();
+}
+
+bool CL_DisplayWindow_OpenGL::received_event(UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+	switch (uMsg)
+	{
+	case WM_DESTROY:
+		if (context)
+		{
+			wglMakeCurrent(0, 0);
+			wglDeleteContext(context);
+			context = 0;
+			opengl_contexts.remove(context);
+		}
+		break;
+	}
+
+	return CL_DisplayWindow_Win32::received_event(uMsg, wParam, lParam);
+}
+
+void CL_DisplayWindow_OpenGL::flip(int interval)
+{
+	CL_GLStateChecker::from_gc(get_gc())-&gt;flush();
+	CL_DisplayWindow_Win32::flip(interval);
+
+	if (interval != -1)
+	{
+		typedef BOOL (APIENTRY *ptr_wglSwapIntervalEXT)(int interval);
+		ptr_wglSwapIntervalEXT wglSwapIntervalEXT = (ptr_wglSwapIntervalEXT) wglGetProcAddress(&quot;wglSwapIntervalEXT&quot;);
+		if (wglSwapIntervalEXT)
+		{
+			wglSwapIntervalEXT(interval);
+		}
+	}
+
+	BOOL retval = SwapBuffers(get_dc());
+
+	repaint_layered();
+}
+
+void CL_DisplayWindow_OpenGL::update(const CL_Rect &amp;rect)
+{
+	CL_OpenGLState state(get_gc());
+	state.set_active();
+	state.setup_2d(true);
+
+	CLboolean isDoubleBuffered = CL_TRUE;
+	clGetBooleanv(CL_DOUBLEBUFFER, &amp;isDoubleBuffered);
+	if (isDoubleBuffered)
+	{
+		clReadBuffer(CL_BACK);
+		CLfloat raster_pos[4];
+
+		clGetFloatv(CL_CURRENT_RASTER_POSITION, raster_pos);
+
+		clDrawBuffer(CL_FRONT);
+		clRasterPos3f((CLfloat)rect.left, (CLfloat)(get_height()-rect.bottom), raster_pos[2]);
+
+		clCopyPixels(rect.left, get_height()-rect.bottom, rect.get_width(), rect.get_height(), CL_COLOR);
+
+		clFlush();
+
+		// Return to drawing to the back buffer
+		clDrawBuffer(CL_BACK);
+	}
+
+	repaint_layered();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Implementation:
+
+void CL_DisplayWindow_OpenGL::repaint_layered()
+{
+	if (layered_dc == 0) return; // Not a layered window.
+	if (ptr_UpdateLayeredWindow == 0) return; // Not supported on this platform.
+
+	POINT layer_src_position;
+	layer_src_position.x = 0;
+	layer_src_position.y = 0;
+
+	POINT layer_dest_position;
+	layer_dest_position.x = get_layer_position().left;
+	layer_dest_position.y = get_layer_position().top;
+
+	SIZE layer_size;
+	layer_size.cx = get_width();
+	layer_size.cy = get_height();
+
+	BLENDFUNCTION blendfunc;
+	blendfunc.BlendOp = AC_SRC_OVER;
+	blendfunc.BlendFlags = 0;
+	blendfunc.SourceConstantAlpha = 255;
+	blendfunc.AlphaFormat = AC_SRC_ALPHA;
+
+	ptr_UpdateLayeredWindow(
+		get_hwnd(),
+		hdc,
+		&amp;layer_dest_position,
+		&amp;layer_size,
+		layered_dc,
+		&amp;layer_src_position,
+		RGB(0,0,0),
+		&amp;blendfunc,
+		ULW_COLORKEY/*ULW_ALPHA*/);
+}
+
+std::list&lt;HGLRC&gt; CL_DisplayWindow_OpenGL::opengl_contexts;

Added: trunk/clanlib/GL/WGL/display_window_opengl.h
===================================================================
--- trunk/clanlib/GL/WGL/display_window_opengl.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/WGL/display_window_opengl.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,126 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_display_window_opengl
+#define header_display_window_opengl
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef WIN32
+#include &lt;windows.h&gt;
+#endif
+
+#include &quot;Display/Win32/display_window_win32.h&quot;
+#include &quot;API/Display/graphic_context.h&quot;
+#include &quot;API/Display/pixel_buffer.h&quot;
+
+#include &lt;GL/glu.h&gt;
+#include &lt;stack&gt;
+
+class CL_DisplayWindow_OpenGL : public CL_DisplayWindow_Win32
+{
+//! Construction:
+public:
+	CL_DisplayWindow_OpenGL();
+
+	virtual ~CL_DisplayWindow_OpenGL();
+
+//! Attributes:
+public:
+	//: Returns the gc of this window.
+	virtual CL_GraphicContext *get_gc();
+
+	//: Returns pixel buffer of frame buffer.
+	virtual CL_PixelBuffer get_buffer(int i) const;
+
+	//: Returns the number of frame buffers.
+	virtual int get_buffer_count() const;
+
+	//: OpenGL rendering context for this window.
+	HGLRC get_context() { return context; }
+
+	//: Device context for this window.
+	HDC get_dc();
+
+	static std::list&lt;HGLRC&gt; opengl_contexts;
+
+//! Operations:
+public:
+	//: Called when a window is to be created.
+	virtual void create_window(const CL_DisplayWindowDescription &amp;desc);
+
+	//: Called when a window is destroyed.
+	virtual void destroy_window();
+
+	//: Called when window receives a windows event.
+	virtual bool received_event(UINT uMsg, WPARAM wParam, LPARAM lParam);
+
+	//: Flip opengl buffers.
+	virtual void flip(int interval);
+
+	//: Copy a region of the backbuffer to the frontbuffer.
+	virtual void update(const CL_Rect &amp;rect);
+
+//! Implementation:
+private:
+	//: Repaint layered window.
+	void repaint_layered();
+
+	//: OpenGL compatible gc.
+	CL_GraphicContext gc;
+
+	//: OpenGL rendering context for this window.
+	HGLRC context;
+
+	//: Device context for this window.
+	HDC hdc;
+
+	//: Device context to layered bitmap.
+	HDC layered_dc;
+
+	//: Layered bitmap.
+	HBITMAP layered_bitmap;
+
+	//: Original bitmap selected into the layered DC.
+	HBITMAP layered_orig_bitmap;
+
+	//: Layered window, user32.dll dll handle.
+	HMODULE user32_dll;
+
+	//: Layered window, function pointer for UpdateLayeredWindow.
+	typedef BOOL (WINAPI *PtrUpdateLayeredWindow)(
+	  HWND, HDC, POINT *, SIZE *, HDC, POINT *, COLORREF, BLENDFUNCTION *, DWORD);
+
+	PtrUpdateLayeredWindow ptr_UpdateLayeredWindow;
+};
+
+#endif
+

Added: trunk/clanlib/GL/canvas_opengl.cpp
===================================================================
--- trunk/clanlib/GL/canvas_opengl.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/canvas_opengl.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,432 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;canvas_opengl.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Display/pixel_buffer.h&quot;
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Display/display_window.h&quot;
+#include &quot;API/Display/graphic_context.h&quot;
+#include &quot;API/GL/opengl_state.h&quot;
+#include &quot;API/GL/opengl_wrap.h&quot;
+#ifdef WIN32
+#include &quot;WGL/display_window_opengl.h&quot;
+#else
+#ifdef __APPLE__
+#include &quot;AGL/display_window_opengl.h&quot;
+#else
+#include &quot;GLX/display_window_opengl.h&quot;
+#endif
+#endif
+#include &quot;graphic_context_opengl.h&quot;
+#include &quot;surface_target_opengl.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Canvas_OpenGL construction:
+
+CL_Canvas_OpenGL::CL_Canvas_OpenGL()
+{
+	CL_OpenGLState state(CL_Display::get_current_window()-&gt;get_gc());
+	state.set_active();
+
+	selected_surface = 0;
+	gc = 0;
+	pbuffer = 0;
+	pbuffer_context = 0;
+
+#ifdef WIN32
+	pbuffer_dc = 0;
+
+	if (wglCreatePbufferARB == 0)
+	{
+		wglCreatePbufferARB = (ptr_wglCreatePbufferARB) wglGetProcAddress(&quot;wglCreatePbufferARB&quot;);
+		wglCreatePbufferARB = (ptr_wglCreatePbufferARB) wglGetProcAddress(&quot;wglCreatePbufferARB&quot;);
+		wglGetPbufferDCARB = (ptr_wglGetPbufferDCARB) wglGetProcAddress(&quot;wglGetPbufferDCARB&quot;);
+		wglReleasePbufferDCARB = (ptr_wglReleasePbufferDCARB) wglGetProcAddress(&quot;wglReleasePbufferDCARB&quot;);
+		wglDestroyPbufferARB = (ptr_wglDestroyPbufferARB) wglGetProcAddress(&quot;wglDestroyPbufferARB&quot;);
+		wglQueryPbufferARB = (ptr_wglQueryPbufferARB) wglGetProcAddress(&quot;wglQueryPbufferARB&quot;);
+	}
+#else
+#ifndef __APPLE__
+	if (glXCreateGLXPbufferSGIX == 0)
+	{
+		glXCreateGLXPbufferSGIX = (ptr_glXCreateGLXPbufferSGIX) CL_OpenGL::get_proc_address(&quot;glXCreateGLXPbufferSGIX&quot;);
+		glXDestroyGLXPbufferSGIX = (ptr_glXDestroyGLXPbufferSGIX) CL_OpenGL::get_proc_address(&quot;glXDestroyGLXPbufferSGIX&quot;);
+		glXQueryGLXPbufferSGIX = (ptr_glXQueryGLXPbufferSGIX) CL_OpenGL::get_proc_address(&quot;glXQueryGLXPbufferSGIX&quot;);
+		glXSelectEventSGIX = (ptr_glXSelectEventSGIX) CL_OpenGL::get_proc_address(&quot;glXSelectEventSGIX&quot;);
+		glXGetSelectedEventSGIX = (ptr_glXGetSelectedEventSGIX) CL_OpenGL::get_proc_address(&quot;glXGetSelectedEventSGIX&quot;);
+
+		glXChooseFBConfigSGIX = (ptr_glXChooseFBConfigSGIX) CL_OpenGL::get_proc_address(&quot;glXChooseFBConfigSGIX&quot;);
+		glXCreateContextWithConfigSGIX = (ptr_glXCreateContextWithConfigSGIX) CL_OpenGL::get_proc_address(&quot;glXCreateContextWithConfigSGIX&quot;);
+	}
+#endif
+#endif
+
+	pbuffer_changed = false;
+	texture_changed = true;
+}
+
+CL_Canvas_OpenGL::~CL_Canvas_OpenGL()
+{
+	delete gc;
+
+	CL_OpenGLState state(CL_Display::get_current_window()-&gt;get_gc());
+	state.set_active();
+#ifdef WIN32
+	if (pbuffer_context) wglDeleteContext(pbuffer_context);
+	if (pbuffer_dc) wglReleasePbufferDCARB(pbuffer, pbuffer_dc);
+	if (pbuffer) wglDestroyPbufferARB(pbuffer);
+#else
+#ifdef __APPLE__
+	if (pbuffer) aglDestroyPBuffer(pbuffer);
+	if (pbuffer_context) aglDestroyContext(pbuffer_context);
+#else
+	if (pbuffer_context) glXDestroyContext(CL_DisplayWindow_OpenGL::get_display(), pbuffer_context);
+	if (pbuffer) glXDestroyGLXPbufferSGIX(CL_DisplayWindow_OpenGL::get_display(), pbuffer);
+#endif
+#endif
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Canvas_OpenGL attributes:
+
+CL_GraphicContext *CL_Canvas_OpenGL::get_gc()
+{
+	if (selected_surface == 0) return 0;
+
+	if (gc == 0)
+	{
+		// Create working pbuffer:
+#ifdef WIN32
+		if (wglCreatePbufferARB == 0)
+		{
+			throw CL_Error(&quot;WGL_ARB_pbuffer OpenGL extension not supported by this card&quot;);
+		}
+
+		int attribList[1] = { 0 };
+
+		PIXELFORMATDESCRIPTOR pfd =
+		{
+			sizeof(PIXELFORMATDESCRIPTOR),  // size of this pfd 
+			1,                              // version number
+			// PFD_DRAW_TO_WINDOW |            // support window
+			PFD_SUPPORT_OPENGL //|            // support OpenGL
+			//PFD_DOUBLEBUFFER |              // double buffered
+			//PFD_DEPTH_DONTCARE
+			,             // do you care about a zbuffer?
+			PFD_TYPE_RGBA,                  // RGBA type
+			24,                             // 24-bit color depth
+			0, 0, 0, 0, 0, 0,               // color bits ignored
+			8,                              // no alpha buffer
+			0,                              // shift bit ignored
+			0,                              // no accumulation buffer
+			0, 0, 0, 0,                     // accum bits ignored
+			0,                              // z-buffer
+			0,                              // no stencil buffer
+			0,                              // no auxiliary buffer
+			PFD_MAIN_PLANE,                 // main layer
+			0,                              // reserved
+			0, 0, 0                         // layer masks ignored
+		};
+
+		int pixelformat = ChoosePixelFormat(wglGetCurrentDC(), &amp;pfd);
+
+//		int pixelformat = GetPixelFormat(wglGetCurrentDC());
+
+		pbuffer = wglCreatePbufferARB(
+			wglGetCurrentDC(),
+			pixelformat,
+			selected_surface-&gt;surface_size.width,
+			selected_surface-&gt;surface_size.height,
+			attribList);
+		pbuffer_dc = wglGetPbufferDCARB(pbuffer);
+		pbuffer_context = wglCreateContext(pbuffer_dc);
+
+		if (!CL_DisplayWindow_OpenGL::opengl_contexts.empty())
+		{
+			wglShareLists(CL_DisplayWindow_OpenGL::opengl_contexts.back(), pbuffer_context);
+		}
+#else
+#ifdef __APPLE__
+		GLint attrib[] = { AGL_RGBA, AGL_NO_RECOVERY, AGL_DEPTH_SIZE, 24, AGL_CLOSEST_POLICY, AGL_NONE };
+		AGLPixelFormat pixelformat = aglChoosePixelFormat(NULL, 0, attrib);
+		if (AGL_NO_ERROR != aglGetError())
+			throw CL_Error(&quot;Could not choose canvas pixel format: &quot; + std::string((const char*)aglErrorString(aglGetError())));
+
+		pbuffer_context = aglCreateContext(pixelformat, CL_DisplayWindow_OpenGL::share_context);
+		if (AGL_NO_ERROR != aglGetError())
+			throw CL_Error(&quot;Could not create canvas gl context: &quot; + std::string((const char*)aglErrorString(aglGetError())));
+
+		if (GL_FALSE==aglCreatePBuffer(
+				selected_surface-&gt;surface_size.width,
+				selected_surface-&gt;surface_size.height,
+				GL_TEXTURE_RECTANGLE_EXT, //GL_TEXTURE_2D,
+				GL_RGBA,
+				0,
+				&amp;pbuffer)
+			) throw CL_Error(&quot;Could not create canvas PBuffer: &quot; + std::string((const char*)aglErrorString(aglGetError())));
+
+		aglSetPBuffer(pbuffer_context, pbuffer, 0, 0, aglGetVirtualScreen(CL_DisplayWindow_OpenGL::share_context));
+		if (AGL_NO_ERROR != aglGetError())
+			throw CL_Error(&quot;Could not set up canvas PBuffer: &quot; + std::string((const char*)aglErrorString(aglGetError())));
+#else
+   int scrnum;
+   GLXFBConfig *fbconfig;
+   XVisualInfo *visinfo;
+   int nitems;
+
+   int attrib[] = {
+      GLX_DOUBLEBUFFER,  False,
+      GLX_RED_SIZE,      1,
+      GLX_GREEN_SIZE,    1,
+      GLX_BLUE_SIZE,     1,
+      GLX_DEPTH_SIZE,    1,
+      GLX_RENDER_TYPE,   GLX_RGBA_BIT,
+      GLX_DRAWABLE_TYPE, GLX_PBUFFER_BIT | GLX_WINDOW_BIT,
+      None
+   };
+   int pbufAttrib[] = {
+     GLX_PBUFFER_WIDTH,   selected_surface-&gt;surface_size.width,
+     GLX_PBUFFER_HEIGHT,  selected_surface-&gt;surface_size.height,
+     GLX_LARGEST_PBUFFER, False,
+     None
+   };
+
+
+   scrnum   = DefaultScreen( CL_DisplayWindow_OpenGL::get_display() );
+
+   fbconfig = glXChooseFBConfig(CL_DisplayWindow_OpenGL::get_display(),
+                                scrnum,
+                                attrib,
+                                &amp;nitems);
+   if (NULL == fbconfig) {
+      fprintf(stderr,&quot;Error: couldn't get fbconfig\n&quot;);
+      exit(1);
+   }
+
+   pbuffer = glXCreatePbuffer(CL_DisplayWindow_OpenGL::get_display(), fbconfig[0], pbufAttrib);
+
+   visinfo = glXGetVisualFromFBConfig(CL_DisplayWindow_OpenGL::get_display(), fbconfig[0]);
+   if (!visinfo) {
+      fprintf(stderr, &quot;Error: couldn't get an RGBA, double-buffered visual\n&quot;);
+      exit(1);
+   }
+
+   pbuffer_context = glXCreateContext( CL_DisplayWindow_OpenGL::get_display(), visinfo, 
+                                       dynamic_cast&lt;CL_GraphicContext_OpenGL*&gt;(CL_Display::get_current_window()-&gt;get_gc()-&gt;impl)-&gt;get_context(), GL_TRUE );
+   if (!pbuffer_context) {
+      fprintf(stderr, &quot;Error: glXCreateContext failed\n&quot;);
+      exit(1);
+   }
+
+   XFree(fbconfig);
+   XFree(visinfo);
+
+#endif
+#endif
+
+		// Create GC interface for it:
+		gc = new CL_GraphicContext(new CL_GraphicContext_OpenGL(this));
+		gc-&gt;set_cliprect(CL_Rect(0, 0, selected_surface-&gt;surface_size.width, selected_surface-&gt;surface_size.height));
+
+		// Download surface to pbuffer:
+		pbuffer_changed = false;
+		texture_changed = true;
+		sync_pbuffer();
+	}
+
+	return gc;
+}
+
+CL_PixelBuffer CL_Canvas_OpenGL::get_pixeldata(const CL_Rect &amp;area)
+{
+	if (selected_surface)
+		return selected_surface-&gt;get_pixeldata ();
+	else
+		return CL_PixelBuffer();
+}
+
+int CL_Canvas_OpenGL::get_width() const
+{
+	if (selected_surface) return selected_surface-&gt;get_width();
+	return 0;
+}
+	
+int CL_Canvas_OpenGL::get_height() const
+{
+	if (selected_surface) return selected_surface-&gt;get_height();
+	return 0;
+}
+	
+/////////////////////////////////////////////////////////////////////////////
+// CL_Canvas_OpenGL operations:
+
+void CL_Canvas_OpenGL::set_pixeldata(const CL_Point &amp;dest, const CL_Rect &amp;src, const CL_PixelBuffer &amp;data)
+{
+}
+
+void CL_Canvas_OpenGL::select_surface(CL_Surface_Generic *surface)
+{
+	if (selected_surface)
+	{
+		sync_texture();
+		selected_surface-&gt;selected_canvas = 0;
+	}
+	if (surface == 0)
+	{
+		selected_surface = 0;
+		pbuffer_changed = false;
+		texture_changed = false;
+	}
+	else
+	{
+		selected_surface = (CL_Surface_Target_OpenGL *) surface-&gt;target;
+		selected_surface-&gt;selected_canvas = this;
+		pbuffer_changed = false;
+		texture_changed = true;
+		// alloc_pbuffer();
+	}
+}
+	
+void CL_Canvas_OpenGL::sync_surface()
+{
+	sync_texture();
+}
+
+void CL_Canvas_OpenGL::sync_pbuffer()
+{
+	if (texture_changed &amp;&amp; gc != 0)
+	{
+		CL_OpenGLState state(gc);
+		state.set_active();
+
+		// Setup down/up 2d projection matrix:
+		clMatrixMode(CL_PROJECTION);
+		clLoadIdentity();
+
+		CLdouble viewport[4];
+		clGetDoublev(CL_VIEWPORT, viewport);
+
+		CLdouble width = viewport[2];
+		CLdouble height = viewport[3];
+		gluOrtho2D(0.0, width, 0.0, height);
+
+		clMatrixMode(CL_MODELVIEW);
+		clLoadIdentity();
+
+		// Copy texture to pbuffer:
+		clEnable(CL_TEXTURE_2D);
+		clBindTexture(CL_TEXTURE_2D, selected_surface-&gt;handle);
+		clMatrixMode(CL_TEXTURE);
+		CLdouble scale_matrix[16];
+		memset(scale_matrix, 0, sizeof(CLdouble)*16);
+		scale_matrix[0] = 1.0f/float(selected_surface-&gt;texture_size.width);
+		scale_matrix[5] = 1.0f/float(selected_surface-&gt;texture_size.height);
+		scale_matrix[10] = 1.0f;
+		scale_matrix[15] = 1.0f;
+		clLoadMatrixd(scale_matrix);
+		clMatrixMode(CL_MODELVIEW);
+
+		clBegin(CL_QUADS);
+		clColor3f(1.0f, 1.0f, 1.0f);
+		clTexCoord2f(float(selected_surface-&gt;surface_size.width), 0.0f);
+		clVertex2f(float(selected_surface-&gt;surface_size.width), 0.0f);
+		clTexCoord2f(float(selected_surface-&gt;surface_size.width), float(selected_surface-&gt;surface_size.height));
+		clVertex2f(float(selected_surface-&gt;surface_size.width), float(selected_surface-&gt;surface_size.height));
+		clTexCoord2f(0.0f, float(selected_surface-&gt;surface_size.height));
+		clVertex2f(0.0f, float(selected_surface-&gt;surface_size.height));
+		clTexCoord2f(0.0f, 0.0f);
+		clVertex2f(0.0f, 0.0f);
+		clEnd();
+#ifdef __APPLE__
+		clFlush();
+#endif
+	}
+	texture_changed = false;
+}
+
+void CL_Canvas_OpenGL::sync_texture()
+{
+	if (pbuffer_changed &amp;&amp; gc != 0)
+	{
+		CL_OpenGLState state(gc);
+		state.set_active();
+
+		// Copy pbuffer to texture:
+		clEnable(CL_TEXTURE_2D);
+		clBindTexture(CL_TEXTURE_2D, selected_surface-&gt;handle);
+		clCopyTexSubImage2D(
+			CL_TEXTURE_2D,
+			0,
+			0, 0,
+			0, 0,
+			selected_surface-&gt;surface_size.width, selected_surface-&gt;surface_size.height);
+#ifdef __APPLE__
+		clFlush();
+#endif
+	}
+	pbuffer_changed = false;
+}
+
+void CL_Canvas_OpenGL::set_pbuffer_modified()
+{
+	pbuffer_changed = true;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Canvas_OpenGL implementation:
+
+#ifdef WIN32
+CL_Canvas_OpenGL::ptr_wglCreatePbufferARB CL_Canvas_OpenGL::wglCreatePbufferARB = 0;
+
+CL_Canvas_OpenGL::ptr_wglGetPbufferDCARB CL_Canvas_OpenGL::wglGetPbufferDCARB = 0;
+
+CL_Canvas_OpenGL::ptr_wglReleasePbufferDCARB CL_Canvas_OpenGL::wglReleasePbufferDCARB = 0;
+
+CL_Canvas_OpenGL::ptr_wglDestroyPbufferARB CL_Canvas_OpenGL::wglDestroyPbufferARB = 0;
+
+CL_Canvas_OpenGL::ptr_wglQueryPbufferARB CL_Canvas_OpenGL::wglQueryPbufferARB = 0;
+#else
+#ifndef __APPLE__
+CL_Canvas_OpenGL::ptr_glXCreateGLXPbufferSGIX CL_Canvas_OpenGL::glXCreateGLXPbufferSGIX = 0;
+
+CL_Canvas_OpenGL::ptr_glXDestroyGLXPbufferSGIX CL_Canvas_OpenGL::glXDestroyGLXPbufferSGIX = 0;
+
+CL_Canvas_OpenGL::ptr_glXQueryGLXPbufferSGIX CL_Canvas_OpenGL::glXQueryGLXPbufferSGIX = 0;
+
+CL_Canvas_OpenGL::ptr_glXSelectEventSGIX CL_Canvas_OpenGL::glXSelectEventSGIX = 0;
+
+CL_Canvas_OpenGL::ptr_glXGetSelectedEventSGIX CL_Canvas_OpenGL::glXGetSelectedEventSGIX = 0;
+
+CL_Canvas_OpenGL::ptr_glXChooseFBConfigSGIX CL_Canvas_OpenGL::glXChooseFBConfigSGIX = 0;
+	
+CL_Canvas_OpenGL::ptr_glXCreateContextWithConfigSGIX CL_Canvas_OpenGL::glXCreateContextWithConfigSGIX = 0;
+#endif
+#endif

Added: trunk/clanlib/GL/canvas_opengl.h
===================================================================
--- trunk/clanlib/GL/canvas_opengl.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/canvas_opengl.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,252 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_canvas_opengl
+#define header_canvas_opengl
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef WIN32
+#include &lt;windows.h&gt;
+#endif
+
+#include &quot;Display/canvas_generic.h&quot;
+
+#ifdef WIN32
+	#ifndef WGL_DRAW_TO_PBUFFER_ARB
+		#define WGL_DRAW_TO_PBUFFER_ARB     0x202D
+		#define WGL_MAX_PBUFFER_PIXELS_ARB  0x202E
+		#define WGL_MAX_PBUFFER_WIDTH_ARB   0x202F
+		#define WGL_MAX_PBUFFER_HEIGHT_ARB  0x2030
+		#define WGL_PBUFFER_LARGEST_ARB     0x2033
+		#define WGL_PBUFFER_WIDTH_ARB       0x2034
+		#define WGL_PBUFFER_HEIGHT_ARB      0x2035
+		#define WGL_PBUFFER_LOST_ARB        0x2036
+
+	    DECLARE_HANDLE(HPBUFFERARB);
+	#endif
+#else
+	#ifdef __APPLE__
+		#include &quot;AGL/display_window_opengl.h&quot;
+		#include &lt;AGL/agl.h&gt;
+	#else
+		#include &quot;GLX/display_window_opengl.h&quot;
+		#ifndef GLX_MAX_PBUFFER_WIDTH_SGIX
+			#define GLX_MAX_PBUFFER_WIDTH_SGIX  0x8016
+			#define GLX_MAX_PBUFFER_HEIGHT_SGIX 0x8017
+			#define GLX_MAX_PBUFFER_PIXELS_SGIX 0x8018
+			#define GLX_PBUFFER_BIT_SGIX        0x00000004
+			#define GLX_WIDTH_SGIX              0x801D
+			#define GLX_HEIGHT_SGIX             0x801E
+			#define GLX_EVENT_MASK_SGIX         0x801F
+			#define GLX_DAMAGED_SGIX            0x8020
+			#define GLX_SAVED_SGIX              0x8021
+		#endif
+		#ifndef GLX_DRAWABLE_TYPE_SGIX
+			#define GLX_DRAWABLE_TYPE_SGIX      0x8010
+			#define GLX_RENDER_TYPE_SGIX        0x8011
+			#define GLX_X_RENDERABLE_SGIX       0x8012
+			typedef __GLXFBConfigRec *  GLXFBConfigSGIX;
+		#endif
+	#endif
+#endif
+
+class CL_Surface_Target_OpenGL;
+
+class CL_Canvas_OpenGL : public CL_Canvas_Generic
+{
+//! Construction:
+public:
+	CL_Canvas_OpenGL();
+
+	virtual ~CL_Canvas_OpenGL();
+
+//! Attributes:
+public:
+	virtual CL_GraphicContext *get_gc();
+
+	virtual CL_PixelBuffer get_pixeldata(const CL_Rect &amp;area);
+
+	virtual int get_width() const;
+	
+	virtual int get_height() const;
+	
+#ifdef WIN32
+	HPBUFFERARB get_pbuffer() { return pbuffer; }
+
+	HGLRC get_pbuffer_context() { return pbuffer_context; }
+
+	HDC get_pbuffer_dc() { return pbuffer_dc; }
+#else
+#ifdef __APPLE__
+	AGLPbuffer get_pbuffer() { return pbuffer; }
+	
+	AGLContext get_pbuffer_context() { return pbuffer_context; }
+#else
+	GLXPbuffer get_pbuffer() { return pbuffer; }
+
+	GLXContext get_pbuffer_context() { return pbuffer_context; }
+#endif
+#endif
+
+//! Operations:
+public:
+	virtual void set_pixeldata(const CL_Point &amp;dest, const CL_Rect &amp;src, const CL_PixelBuffer &amp;data);
+
+	virtual void select_surface(CL_Surface_Generic *surface);
+	
+	virtual void sync_surface();
+
+	void sync_pbuffer();
+
+	void sync_texture();
+
+	void set_pbuffer_modified();
+
+//! Implementation:
+private:
+	CL_Surface_Target_OpenGL *selected_surface;
+
+	CL_GraphicContext *gc;
+
+	//: OpenGL ARB PBuffer sync flags:
+	bool pbuffer_changed, texture_changed;
+
+#ifdef WIN32
+	HPBUFFERARB pbuffer;
+
+	HGLRC pbuffer_context;
+
+	HDC pbuffer_dc;
+#else
+#ifdef __APPLE__
+	AGLPbuffer pbuffer;
+	AGLContext pbuffer_context;
+#else
+	GLXPbuffer pbuffer;
+
+	GLXContext pbuffer_context;
+#endif
+#endif
+
+	// OpenGL pbuffer binding evilness:
+#ifdef WIN32
+	typedef HPBUFFERARB (APIENTRY *ptr_wglCreatePbufferARB)(
+		HDC hDC,
+		int iPixelFormat,
+		int iWidth,
+		int iHeight,
+		const int *piAttribList);
+
+	typedef HDC (APIENTRY *ptr_wglGetPbufferDCARB)(
+		HPBUFFERARB hPbuffer);
+
+	typedef int (APIENTRY *ptr_wglReleasePbufferDCARB)(
+		HPBUFFERARB hPbuffer,
+		HDC hDC);
+
+	typedef BOOL (APIENTRY *ptr_wglDestroyPbufferARB)(
+		HPBUFFERARB hPbuffer);
+
+	typedef BOOL (APIENTRY *ptr_wglQueryPbufferARB)(
+		HPBUFFERARB hPbuffer,
+		int iAttribute,
+		int *piValue);
+
+	static ptr_wglCreatePbufferARB wglCreatePbufferARB;
+
+	static ptr_wglGetPbufferDCARB wglGetPbufferDCARB;
+
+	static ptr_wglReleasePbufferDCARB wglReleasePbufferDCARB;
+
+	static ptr_wglDestroyPbufferARB wglDestroyPbufferARB;
+
+	static ptr_wglQueryPbufferARB wglQueryPbufferARB;
+#else
+#ifndef __APPLE__
+	typedef GLXPbuffer (*ptr_glXCreateGLXPbufferSGIX)(
+		Display *dpy,
+		GLXFBConfig config,
+		unsigned int width,
+		unsigned int height,
+		int *attrib_list);
+
+	typedef void (*ptr_glXDestroyGLXPbufferSGIX)(
+		Display *dpy,
+		GLXPbuffer pbuf);
+
+	typedef void (*ptr_glXQueryGLXPbufferSGIX)(
+		Display *dpy,
+		GLXPbuffer pbuf,
+		int attribute,
+		unsigned int *value);
+
+	typedef void (*ptr_glXSelectEventSGIX)(
+		Display *dpy,
+		GLXDrawable drawable,
+		unsigned long mask);
+
+	typedef void (*ptr_glXGetSelectedEventSGIX)(
+		Display *dpy,
+		GLXDrawable drawable,
+		unsigned long *mask);
+
+	typedef GLXFBConfigSGIX *(*ptr_glXChooseFBConfigSGIX)(
+		Display *dpy,
+		int screen,
+		const int *attrib_list,
+		int *nelements);
+
+	typedef GLXContext (*ptr_glXCreateContextWithConfigSGIX)(
+		Display *dpy,
+		GLXFBConfig config,
+		int render_type,
+		GLXContext share_list,
+		Bool direct);
+
+	static ptr_glXCreateGLXPbufferSGIX glXCreateGLXPbufferSGIX;
+
+	static ptr_glXDestroyGLXPbufferSGIX glXDestroyGLXPbufferSGIX;
+
+	static ptr_glXQueryGLXPbufferSGIX glXQueryGLXPbufferSGIX;
+
+	static ptr_glXSelectEventSGIX glXSelectEventSGIX;
+
+	static ptr_glXGetSelectedEventSGIX glXGetSelectedEventSGIX;
+	
+	static ptr_glXChooseFBConfigSGIX glXChooseFBConfigSGIX;
+	
+	static ptr_glXCreateContextWithConfigSGIX glXCreateContextWithConfigSGIX;
+#endif
+#endif
+};
+
+#endif

Added: trunk/clanlib/GL/fillmode.h
===================================================================
--- trunk/clanlib/GL/fillmode.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/fillmode.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,47 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_fillmode
+#define header_fillmode
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+enum CL_FillMode
+{
+	fillmode_line,
+	fillmode_point,
+	fillmode_solid
+};
+
+#endif
+
+
+

Added: trunk/clanlib/GL/gl_state.h
===================================================================
--- trunk/clanlib/GL/gl_state.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/gl_state.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,76 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_gl_state
+#define header_gl_state
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef WIN32
+#include &lt;windows.h&gt;
+#endif
+
+#include &quot;API/GL/opengl.h&quot;
+#include &quot;API/Display/blend_func.h&quot;
+#include &quot;API/Display/gradient.h&quot;
+#include &quot;API/Core/Math/point.h&quot;
+
+#include &quot;fillmode.h&quot;
+
+class CL_GLState
+{
+//! Construction:
+public:
+	CL_GLState() : 
+		color_range_zero2one(false),
+		uv_range_zero2one(false),
+		sub_pixel_accuracy(false)
+	{
+		return;
+	};
+
+//! Attributes:
+public:
+	CLfloat color[4];
+
+	int texture_handle;
+
+	CL_BlendFunc blendfunc[4];
+
+	CL_FillMode fillmode;
+
+	bool color_range_zero2one;
+	bool uv_range_zero2one;
+	bool sub_pixel_accuracy;
+	
+};
+
+#endif

Added: trunk/clanlib/GL/gl_state_checker.cpp
===================================================================
--- trunk/clanlib/GL/gl_state_checker.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/gl_state_checker.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,924 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;Display/surface_target.h&quot;
+#include &quot;Display/triangle_params.h&quot;
+#include &quot;GL/gl_state.h&quot;
+#include &quot;GL/gl_state_checker.h&quot;
+#include &quot;API/Display/blend_func.h&quot;
+#include &quot;API/Display/color.h&quot;
+#include &quot;API/Display/graphic_context.h&quot;
+#include &quot;API/Core/Math/rect.h&quot;
+#include &quot;API/Core/Math/point.h&quot;
+#include &quot;API/GL/opengl_state.h&quot;
+#include &quot;graphic_context_opengl.h&quot;
+#include &quot;API/GL/opengl_wrap.h&quot;
+
+// Using 0.38 for the texture matrix instead of 0.375 - reduces some slight smooth (rounding errors?)
+#define cl_pixelcenter_constant 0.38
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_GLStateChecker construction:
+
+CL_GLStateChecker::CL_GLStateChecker(CL_GraphicContext_OpenGL *gc_opengl)
+: opengl_state(0), gc_opengl(gc_opengl), first_call(true)
+{
+	internal_state.blendfunc[0] = blend_src_alpha;
+	internal_state.blendfunc[1] = blend_one_minus_src_alpha;
+	internal_state.blendfunc[2] = blend_src_alpha;
+	internal_state.blendfunc[3] = blend_one_minus_src_alpha;
+
+	internal_state.color[0] = 255;
+	internal_state.color[1] = 255;
+	internal_state.color[2] = 255;
+	internal_state.color[3] = 255;
+
+	// -2 since we want to force the first render to set enable/disable_2d
+	internal_state.texture_handle = -2;
+
+	internal_state.fillmode = fillmode_solid;
+	
+	primitive = CL_DONT_CARE;
+	primitive_count = 0;
+
+	stencil_op_pass = CL_INCR;
+	stencil_op_fail = CL_KEEP;	
+	stencil_write_ref = 0;
+	stencil_func_write = CL_ALWAYS;
+
+	opengl_state = new CL_OpenGLState(gc_opengl);
+	opengl_state-&gt;attach_data(this);
+
+	tri_use_uv = false;
+	tri_use_color = false;
+
+	color_array_enabled = false;	
+	color_array_range_zero2one = false;
+	uv_array_range_zero2one = false;
+}
+
+CL_GLStateChecker::~CL_GLStateChecker()
+{
+	delete opengl_state;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_GLStateChecker operations:
+
+CL_GLStateChecker *CL_GLStateChecker::from_gc(CL_GraphicContext *gc)
+{
+	CL_GraphicContext_OpenGL *gl_impl = (CL_GraphicContext_OpenGL *) gc-&gt;impl;
+	return gl_impl-&gt;state_checker;
+}
+
+void CL_GLStateChecker::add_clear(
+	const CL_Color &amp;color)
+{
+	flush();
+	clClearColor(color.get_red() / 255.0f, color.get_green() / 255.0f, color.get_blue() / 255.0f, color.get_alpha() / 255.0f);
+	clClear(CL_COLOR_BUFFER_BIT);
+}
+
+void CL_GLStateChecker::add_pixel(
+	const CL_GLState &amp;state,
+	int x, int y)
+{
+	set_state(state, CL_POINTS);
+	clVertex2i(x, y);
+}
+
+void CL_GLStateChecker::add_line(
+	const CL_GLState &amp;state,
+	float x1, float y1, float x2, float y2)
+{
+	set_state(state, CL_LINES);
+	clVertex2f(x1, y1);
+	clVertex2f(x2, y2);
+}
+
+void CL_GLStateChecker::add_lines(
+	const CL_GLState &amp;state,
+	unsigned int count,
+	double *vertices)
+{
+	set_state(state, CL_LINE_STRIP);
+
+	// todo: add batching
+
+	clVertexPointer( 2, CL_DOUBLE, 0, vertices );
+	clDrawArrays(CL_LINE_STRIP, 0, count);
+}
+
+void CL_GLStateChecker::add_gradient(
+	const CL_GLState &amp;state,
+	const CL_Rectf &amp;position,
+	const CL_Gradient &amp;gradient)
+{
+	set_state(state, CL_GRADIENT);
+	add_quad_vertices( state, position.left, position.top, position.right, position.bottom );
+
+	int a = primitive_count*16;
+
+	// Bottom left vertex
+	b_color_array[a++] = gradient.bottom_left.get_red();
+	b_color_array[a++] = gradient.bottom_left.get_green();
+	b_color_array[a++] = gradient.bottom_left.get_blue();
+	b_color_array[a++] = gradient.bottom_left.get_alpha();
+
+	// Bottom right vertex
+	b_color_array[a++] = gradient.bottom_right.get_red();
+	b_color_array[a++] = gradient.bottom_right.get_green();
+	b_color_array[a++] = gradient.bottom_right.get_blue();
+	b_color_array[a++] = gradient.bottom_right.get_alpha();
+
+	// Top right vertex
+	b_color_array[a++] = gradient.top_right.get_red();
+	b_color_array[a++] = gradient.top_right.get_green();
+	b_color_array[a++] = gradient.top_right.get_blue();
+	b_color_array[a++] = gradient.top_right.get_alpha();
+
+	// Top left vertex
+	b_color_array[a++] = gradient.top_left.get_red();
+	b_color_array[a++] = gradient.top_left.get_green();
+	b_color_array[a++] = gradient.top_left.get_blue();
+	b_color_array[a++] = gradient.top_left.get_alpha();
+
+	primitive_count++;
+
+	if( primitive_count == MAX_QUAD_COUNT )
+		flush();
+}
+
+void CL_GLStateChecker::add_gradient(
+	const CL_GLState &amp;state,
+	const CL_Quad &amp;quad,
+	const CL_Gradient &amp;gradient)
+{
+	set_state(state, CL_GRADIENT);
+	add_quad_vertices( state, (double)quad.x1, (double)quad.y1, (double)quad.x2, (double)quad.y2, (double)quad.x3, (double)quad.y3, (double)quad.x4, (double)quad.y4 );
+
+	int a = primitive_count*16;
+
+	// Top left vertex
+	b_color_array[a++] = gradient.top_left.get_red();
+	b_color_array[a++] = gradient.top_left.get_green();
+	b_color_array[a++] = gradient.top_left.get_blue();
+	b_color_array[a++] = gradient.top_left.get_alpha();
+
+	// Top right vertex
+	b_color_array[a++]  = gradient.top_right.get_red();
+	b_color_array[a++]  = gradient.top_right.get_green();
+	b_color_array[a++] =	gradient.top_right.get_blue();
+	b_color_array[a++] =	gradient.top_right.get_alpha();
+
+	// Bottom right vertex
+	b_color_array[a++] = gradient.bottom_right.get_red();
+	b_color_array[a++] = gradient.bottom_right.get_green();
+	b_color_array[a++] = gradient.bottom_right.get_blue();
+	b_color_array[a++] = gradient.bottom_right.get_alpha();
+
+	// Bottom left vertex
+	b_color_array[a++] = gradient.bottom_left.get_red();
+	b_color_array[a++] = gradient.bottom_left.get_green();
+	b_color_array[a++] = gradient.bottom_left.get_blue();
+	b_color_array[a++] = gradient.bottom_left.get_alpha();
+
+	primitive_count++;
+
+	if( primitive_count == MAX_QUAD_COUNT )
+		flush();
+}
+
+void CL_GLStateChecker::add_quad_vertices( 
+	const CL_GLState &amp;state,
+	double px1,
+	double py1,
+	double px2,
+	double py2 )
+{
+	int b = primitive_count * 8; // 8 values per quad
+
+	vertex_array[b+0] = px1;
+	vertex_array[b+1] = py2;
+	vertex_array[b+2] = px2;
+	vertex_array[b+3] = py2;
+	vertex_array[b+4] = px2;
+	vertex_array[b+5] = py1;
+	vertex_array[b+6] = px1;
+	vertex_array[b+7] = py1;
+}
+
+// used only by add_gradient with CL_Quad
+void CL_GLStateChecker::add_quad_vertices( 
+	const CL_GLState &amp;state,
+	double px1,
+	double py1,
+	double px2,
+	double py2,
+	double px3,
+	double py3,
+	double px4,
+	double py4 )
+{
+	int b = primitive_count * 8; // 8 values per quad
+
+	vertex_array[b+0] = px1;
+	vertex_array[b+1] = py1;
+	vertex_array[b+2] = px2;
+	vertex_array[b+3] = py2;
+	vertex_array[b+4] = px3;
+	vertex_array[b+5] = py3;
+	vertex_array[b+6] = px4;
+	vertex_array[b+7] = py4;
+}
+
+void CL_GLStateChecker::add_quad(
+	const CL_GLState &amp;state,
+	double px1,
+	double py1,
+	double px2,
+	double py2,
+	int tx1,
+	int ty1,
+	int tx2,
+	int ty2)
+{
+	set_state(state, CL_QUADS);
+
+	if( internal_state.texture_handle != -1 )
+	{
+		int a = primitive_count * 8; // offset in array. 8 values per quad 
+		
+		i_uv_array[a+0] = tx1;
+		i_uv_array[a+1] = ty2;
+		i_uv_array[a+2] = tx2;
+		i_uv_array[a+3] = ty2;
+		i_uv_array[a+4] = tx2;
+		i_uv_array[a+5] = ty1;
+		i_uv_array[a+6] = tx1;
+		i_uv_array[a+7] = ty1;
+	}
+
+	add_quad_vertices( state, px1, py1, px2, py2 );
+	
+	primitive_count++;
+		
+	if( primitive_count == MAX_QUAD_COUNT )
+		flush();
+}
+
+void CL_GLStateChecker::add_quad(
+	const CL_GLState &amp;state,
+	const double destX[4],
+	const double destY[4],
+	const int tx[4],
+	const int ty[4])
+{
+	set_state(state, CL_QUADS);
+
+	int a = primitive_count * 8; // offset in array. 8 values per quad 
+
+	if( internal_state.texture_handle != -1 )
+	{
+		i_uv_array[a+0] = tx[0];
+		i_uv_array[a+1] = ty[0];
+		i_uv_array[a+2] = tx[1];
+		i_uv_array[a+3] = ty[1];
+		i_uv_array[a+4] = tx[2];
+		i_uv_array[a+5] = ty[2];
+		i_uv_array[a+6] = tx[3];
+		i_uv_array[a+7] = ty[3];
+	}
+
+	vertex_array[a+0] = destX[0];
+	vertex_array[a+1] = destY[0];
+	vertex_array[a+2] = destX[1];
+	vertex_array[a+3] = destY[1];
+	vertex_array[a+4] = destX[2];
+	vertex_array[a+5] = destY[2];
+	vertex_array[a+6] = destX[3];
+	vertex_array[a+7] = destY[3];
+
+	primitive_count++;
+		
+	if( primitive_count == MAX_QUAD_COUNT )
+		flush();
+}
+
+void CL_GLStateChecker::add_triangles(
+	const CL_GLState &amp;state,
+	CL_TriangleParams *params )
+{
+	tri_use_color = (params-&gt;single_color == 0);
+
+	set_state(state, CL_TRIANGLES);
+
+	tri_use_uv = ((params-&gt;uv != 0) || (params-&gt;int_uv != 0));
+
+	primitive_texture = params-&gt;texture;
+
+	// make sure used texture isn't deleted before drawing is complete
+	if( primitive_texture )
+		primitive_texture-&gt;add_ref();
+	
+	if( primitive_count + params-&gt;count &gt; MAX_QUAD_COUNT )
+	{
+		if( params-&gt;count &gt; 2*MAX_QUAD_COUNT-1 )
+		{
+			flush();
+
+			// vertex pointer
+			clVertexPointer( 3, CL_DOUBLE, 0, params-&gt;vertices );
+			
+			// texcoord pointer
+			if( tri_use_uv )
+			{
+				if( uv_array_range_zero2one )
+					clTexCoordPointer( 2, CL_DOUBLE, 0, params-&gt;uv );
+				else
+					clTexCoordPointer( 2, CL_INT, 0, params-&gt;int_uv );
+			}
+
+			// color pointer
+			if( color_array_enabled )
+			{
+				if( color_array_range_zero2one )
+					clColorPointer( 4, CL_DOUBLE, 0, params-&gt;color );
+				else
+					clColorPointer( 4, CL_UNSIGNED_BYTE, 0, params-&gt;uchar_color );
+			}
+
+			// Draw it!
+			clDrawArrays(CL_TRIANGLES, 0, 3*params-&gt;count);
+
+			if( primitive_texture )
+				primitive_texture-&gt;release_ref();
+
+			return;
+		}
+
+		unsigned int fit = MAX_QUAD_COUNT - primitive_count;
+		
+		memcpy( vertex_array+primitive_count*3*3, params-&gt;vertices, sizeof(double)*fit*3*3 );
+
+		if( params-&gt;uv )
+			memcpy( d_uv_array+primitive_count*3*2, params-&gt;uv, sizeof(double)*fit*3*2 );
+		if( params-&gt;int_uv )
+			memcpy( i_uv_array+primitive_count*2*3, params-&gt;int_uv, sizeof(int)*fit*2*3 );
+
+		if( params-&gt;color )
+			memcpy( d_color_array+primitive_count*3*4, params-&gt;color, sizeof(double)*fit*3*4 );
+		if( params-&gt;uchar_color )
+			memcpy( b_color_array+primitive_count*4*3, params-&gt;uchar_color, sizeof(unsigned char)*fit*4*3 );
+
+		primitive_count += fit;
+		
+		flush();
+
+		// make sure used texture isn't deleted before drawing is complete
+		// need to renew ref, becaues flush released it.
+		if( primitive_texture )
+			primitive_texture-&gt;add_ref();
+		
+		memcpy( vertex_array, params-&gt;vertices+fit*3*3, sizeof(double)*(params-&gt;count-fit)*3*3 );
+
+		if( params-&gt;uv )
+			memcpy( d_uv_array+primitive_count*3*2, params-&gt;uv+fit*3*2, sizeof(double)*(params-&gt;count-fit)*3*2 );
+		if( params-&gt;int_uv )
+			memcpy( i_uv_array+primitive_count*3*2, params-&gt;int_uv+fit*3*2, sizeof(int)*(params-&gt;count-fit)*3*2 );
+
+		if( params-&gt;color )
+			memcpy( d_color_array+primitive_count*3*4, params-&gt;color+fit*3*4, sizeof(double)*(params-&gt;count-fit)*3*4 );
+		if( params-&gt;uchar_color )
+			memcpy( b_color_array+primitive_count*3*4, params-&gt;uchar_color+fit*3*4, sizeof(double)*(params-&gt;count-fit)*3*4 );
+		
+		primitive_count += params-&gt;count-fit;
+	}
+	else
+	{
+		memcpy( vertex_array+primitive_count*3*3, params-&gt;vertices, sizeof(double)*params-&gt;count*3*3 );
+
+		if( params-&gt;uv )
+			memcpy( d_uv_array+primitive_count*2*3, params-&gt;uv, sizeof(double)*params-&gt;count*2*3 );
+		if( params-&gt;int_uv )
+			memcpy( i_uv_array+primitive_count*2*3, params-&gt;int_uv, sizeof(int)*params-&gt;count*2*3 );
+
+		if( params-&gt;color )
+			memcpy( d_color_array+primitive_count*4*3, params-&gt;color, sizeof(double)*params-&gt;count*4*3 );
+		if( params-&gt;uchar_color )
+			memcpy( b_color_array+primitive_count*4*3, params-&gt;uchar_color, sizeof(unsigned char)*params-&gt;count*4*3 );
+
+		primitive_count += params-&gt;count;
+	}
+}
+
+void CL_GLStateChecker::flush(bool rebind_texture) const
+{
+	opengl_state-&gt;set_active();
+
+	if (primitive == CL_LINES || primitive == CL_POINTS )
+	{
+		clEnd();
+		primitive = CL_DONT_CARE; // carefull... CL_POINTS is defined as 0x0000
+	}
+
+	if( primitive_count != 0 )
+	{
+		////////////////////////////////////////////////////
+		// vertice array
+		
+		int elements_per_vertex = 2;
+
+		if( primitive == CL_TRIANGLES )
+			elements_per_vertex = 3;
+
+		clVertexPointer( elements_per_vertex, CL_DOUBLE, 0, vertex_array );
+
+		////////////////////////////////////////////////////
+		//  tex coord (uv) array
+
+		if( primitive == CL_TRIANGLES )
+		{
+			if( tri_use_uv )
+			{
+				if( uv_array_range_zero2one )
+					clTexCoordPointer( 2, CL_DOUBLE, 0, d_uv_array );
+				else
+					clTexCoordPointer( 2, CL_INT, 0, i_uv_array );
+			}
+		}
+		else
+		{
+			clTexCoordPointer( 2, CL_INT, 0, i_uv_array );
+		}
+
+		////////////////////////////////////////////////////
+		// color array
+
+		if( primitive == CL_GRADIENT )
+		{
+			clColorPointer( 4, CL_UNSIGNED_BYTE, 0, b_color_array );
+		}
+		else if( primitive == CL_TRIANGLES )
+		{
+			if( color_array_enabled )
+			{
+				if( color_array_range_zero2one )
+				{
+					clColorPointer( 4, CL_DOUBLE, 0, d_color_array );
+				}
+				else
+				{
+					clColorPointer( 4, CL_UNSIGNED_BYTE, 0, b_color_array );
+				}
+			}
+		}
+
+		////////////////////////////////////////////////////
+		// DRAW IT!
+
+		if( primitive == CL_QUADS || primitive == CL_GRADIENT )
+		{
+			clDrawArrays(CL_QUADS, 0, 4*primitive_count);
+		}
+		else if( primitive == CL_TRIANGLES )
+		{
+			if( uv_array_range_zero2one )
+			{
+				clMatrixMode(CL_TEXTURE);
+				clPushMatrix();
+				clLoadIdentity();		
+			}
+
+			clDrawArrays(CL_TRIANGLES, 0, 3*primitive_count);
+
+			if( uv_array_range_zero2one )
+			{
+				clPopMatrix();
+				clMatrixMode(CL_MODELVIEW);
+			}
+
+			if( primitive_texture )
+				primitive_texture-&gt;release_ref();
+		}
+
+		primitive_count = 0;
+	}
+
+	if( rebind_texture )
+		internal_state.texture_handle = -2;
+}
+
+CL_Color CL_GLStateChecker::get_pixel(int x, int y) const
+{
+	flush();
+
+	CLdouble viewport[4];
+	clGetDoublev(CL_VIEWPORT, viewport);
+	CLdouble height = viewport[3];
+
+	CL_Color pixel;
+	clReadPixels(x, (int)height-y, 1, 1, CL_RGB, CL_UNSIGNED_BYTE, &amp;pixel.color);
+	pixel.set_alpha( 255 );
+	return pixel;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLStateData:
+
+void CL_GLStateChecker::on_save()
+{
+	flush();
+}
+
+void CL_GLStateChecker::on_load()
+{
+	gc_opengl-&gt;sync_gc();
+/*
+	// restore opengl states
+	clBlendFunc(internal_state.blendfunc[0], internal_state.blendfunc[1]);
+	clColor4fv(internal_state.color);
+	if (internal_state.texture_handle == -2 || internal_state.texture_handle == -1)
+	{
+		clDisable(CL_TEXTURE_2D);
+	}
+	else
+	{
+		clEnable(CL_TEXTURE_2D);
+		clBindTexture(CL_TEXTURE_2D, internal_state.texture_handle);
+		CLint texture_width = 1, texture_height = 1;
+		clGetTexLevelParameteriv(CL_TEXTURE_2D, 0, CL_TEXTURE_WIDTH, &amp;texture_width);
+		clGetTexLevelParameteriv(CL_TEXTURE_2D, 0, CL_TEXTURE_HEIGHT, &amp;texture_height);
+		clMatrixMode(CL_TEXTURE);
+		CLdouble scale_matrix[16];
+		memset(scale_matrix, 0, sizeof(CLdouble)*16);
+		scale_matrix[0] = 1.0/texture_width;
+		scale_matrix[5] = 1.0/texture_height;
+		scale_matrix[10] = 1.0;
+		scale_matrix[15] = 1.0;
+		clLoadMatrixd(scale_matrix);
+		clMatrixMode(CL_MODELVIEW);
+	}
+*/
+}
+
+void CL_GLStateChecker::on_flush()
+{
+	flush();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_GLStateTree implementation:
+
+void CL_GLStateChecker::set_state(const CL_GLState &amp;state, CLenum new_primitive)
+{
+	opengl_state-&gt;set_active();
+
+	if (first_call)
+	{
+		opengl_state-&gt;setup_2d(gc_opengl-&gt;is_canvas_target());
+		clEnableClientState(CL_VERTEX_ARRAY);
+		clEnableClientState(CL_TEXTURE_COORD_ARRAY);
+		clDisableClientState(CL_COLOR_ARRAY);
+		set_blendfunc(internal_state);
+		clColor4fv(internal_state.color);
+		clEnable(CL_TEXTURE_2D);
+		clEnable(CL_BLEND);
+		clTexEnvf(CL_TEXTURE_ENV, CL_TEXTURE_ENV_MODE, CL_MODULATE);
+		first_call = false;
+	}
+
+	/////////////////////////////////////////////////////
+	// texturing
+
+	if (internal_state.texture_handle != state.texture_handle)
+	{
+		internal_state.texture_handle = state.texture_handle;
+		
+		flush();
+
+		if(state.texture_handle == -1)
+		{
+			clDisable(CL_TEXTURE_2D);
+			clDisableClientState(CL_TEXTURE_COORD_ARRAY);
+		}
+		else
+		{
+			// Bind texture and convert internal texture coordinates to be
+			// in pixels.
+			clEnable(CL_TEXTURE_2D);
+			clBindTexture(CL_TEXTURE_2D, (CLuint)state.texture_handle);
+			clTexEnvf(CL_TEXTURE_ENV, CL_TEXTURE_ENV_MODE, CL_MODULATE);
+			CLint texture_width = 1, texture_height = 1;
+			clGetTexLevelParameteriv(CL_TEXTURE_2D, 0, CL_TEXTURE_WIDTH, &amp;texture_width);
+			clGetTexLevelParameteriv(CL_TEXTURE_2D, 0, CL_TEXTURE_HEIGHT, &amp;texture_height);
+			clMatrixMode(CL_TEXTURE);
+			CLdouble scale_matrix[16];
+			memset(scale_matrix, 0, sizeof(CLdouble)*16);
+			scale_matrix[0] = 1.0/texture_width;
+			scale_matrix[5] = 1.0/texture_height;
+			scale_matrix[10] = 1.0;
+			scale_matrix[15] = 1.0;
+			clLoadMatrixd(scale_matrix);
+
+			
+			if (!state.sub_pixel_accuracy)
+			{
+				// Sync texture coordinates with screen coordinates for GL_LINEAR sampling:
+				clTranslated(cl_pixelcenter_constant, cl_pixelcenter_constant, 0.0);
+			}
+
+			clMatrixMode(CL_MODELVIEW);
+
+			clEnableClientState(CL_TEXTURE_COORD_ARRAY);
+		}
+	}
+
+	/////////////////////////////////////////////////////
+	// blendfuncs
+	
+	if (internal_state.blendfunc[0] != state.blendfunc[0] || 
+		 internal_state.blendfunc[1] != state.blendfunc[1] ||
+		 internal_state.blendfunc[2] != state.blendfunc[2] ||
+		 internal_state.blendfunc[3] != state.blendfunc[3])
+	{
+		flush();
+
+		internal_state.blendfunc[0] = state.blendfunc[0];
+		internal_state.blendfunc[1] = state.blendfunc[1];
+		internal_state.blendfunc[2] = state.blendfunc[2];
+		internal_state.blendfunc[3] = state.blendfunc[3];
+
+		set_blendfunc(state);
+	}
+
+	/////////////////////////////////////////////////////
+	// fillmode 
+
+	if (internal_state.fillmode != state.fillmode )
+	{
+		flush();
+		internal_state.fillmode = state.fillmode;
+		set_fillmode(state);
+	}
+
+	/////////////////////////////////////////////////////
+	// color
+
+	if (internal_state.color[0] != state.color[0] ||
+		internal_state.color[1] != state.color[1] ||
+		internal_state.color[2] != state.color[2] ||
+		internal_state.color[3] != state.color[3])
+	{
+		flush();
+
+		internal_state.color[0] = state.color[0];
+		internal_state.color[1] = state.color[1];
+		internal_state.color[2] = state.color[2];
+		internal_state.color[3] = state.color[3];
+
+		clColor4fv(state.color);
+	}
+
+	// Set vertex array client states for color array.
+	if( new_primitive == CL_TRIANGLES )
+	{
+		if( tri_use_color != color_array_enabled )
+		{
+			flush();
+
+			if( tri_use_color )
+				clEnableClientState(CL_COLOR_ARRAY);
+			else
+				clDisableClientState(CL_COLOR_ARRAY);
+
+			color_array_enabled = tri_use_color;
+		}
+
+		if( state.color_range_zero2one != color_array_range_zero2one )
+		{
+			flush();
+			color_array_range_zero2one = state.color_range_zero2one;
+		}
+
+		if( state.uv_range_zero2one != uv_array_range_zero2one )
+		{
+			flush();
+			uv_array_range_zero2one = state.uv_range_zero2one;
+		}
+
+	}
+	else if( new_primitive == CL_GRADIENT )
+	{
+		if( !color_array_enabled )
+		{
+			flush();
+			clEnableClientState(CL_COLOR_ARRAY);
+			color_array_enabled = true;
+		}
+	}
+	else
+	{
+		if( color_array_enabled )
+		{
+			flush();
+			clDisableClientState(CL_COLOR_ARRAY);
+			color_array_enabled = false;
+		}
+	}
+
+
+	/////////////////////////////////////////////////////
+	// primitive
+
+	if ( primitive != new_primitive )
+	{
+		flush();
+
+		if ( new_primitive == CL_LINES || new_primitive == CL_POINTS )
+			clBegin(new_primitive);
+
+		primitive = new_primitive;
+	}
+}
+
+void CL_GLStateChecker::set_fillmode(const CL_GLState &amp;state)
+{
+	switch( state.fillmode )
+	{
+	case fillmode_line:
+		clPolygonMode( CL_FRONT_AND_BACK, CL_LINE );
+		break;
+	case fillmode_point:
+		clPolygonMode( CL_FRONT_AND_BACK, CL_POINT );
+		break;
+	case fillmode_solid:
+		clPolygonMode( CL_FRONT_AND_BACK, CL_FILL );
+		break;
+	}
+}
+
+void CL_GLStateChecker::set_blendfunc(const CL_GLState &amp;state)
+{
+	CLenum blendfunc[4];
+	for(int i = 0; i &lt; 4; ++i)
+	{			
+		switch (state.blendfunc[i])
+		{
+		case blend_zero:
+			blendfunc[i] = CL_ZERO;
+			break;
+		case blend_one:
+			blendfunc[i] = CL_ONE;
+			break;
+		case blend_dest_color:
+			blendfunc[i] = CL_DST_COLOR;
+			break;
+		case blend_src_color:
+			blendfunc[i] = CL_SRC_COLOR;
+			break;
+		case blend_one_minus_dest_color:
+			blendfunc[i] = CL_ONE_MINUS_DST_COLOR;
+			break;
+		case blend_one_minus_src_color:
+			blendfunc[i] = CL_ONE_MINUS_SRC_COLOR;
+			break;
+		case blend_src_alpha:
+			blendfunc[i] = CL_SRC_ALPHA;
+			break;
+		case blend_one_minus_src_alpha:
+			blendfunc[i] = CL_ONE_MINUS_SRC_ALPHA;
+			break;
+		case blend_dst_alpha:
+			blendfunc[i] = CL_DST_ALPHA;
+			break;
+		case blend_one_minus_dest_alpha:
+			blendfunc[i] = CL_ONE_MINUS_DST_ALPHA;
+			break;
+		case blend_src_alpha_saturate:
+			blendfunc[i] = CL_SRC_ALPHA_SATURATE;
+			break;
+		case blend_constant_color:
+			blendfunc[i] = CL_CONSTANT_COLOR;
+			break;
+		case blend_constant_alpha:
+			blendfunc[i] = CL_CONSTANT_ALPHA;
+			break;
+		case blend_one_minus_constant_color:
+			blendfunc[i] = CL_ONE_MINUS_CONSTANT_COLOR;
+			break;
+		case blend_one_minus_constant_alpha:
+			blendfunc[i] = CL_ONE_MINUS_CONSTANT_ALPHA;
+			break;
+		}
+	}
+
+	if (blendfunc[0] == blendfunc[2] &amp;&amp; blendfunc[1] == blendfunc[3])
+	{
+		clBlendFunc(blendfunc[0], blendfunc[1]);
+	}
+	else
+	{
+		clBlendFuncSeparate(blendfunc[0], blendfunc[1], blendfunc[2], blendfunc[3]);
+	}
+}
+
+void CL_GLStateChecker::clear_stencil(int value)
+{
+	opengl_state-&gt;set_active();
+	
+	flush();
+	
+	clClearStencil(value);
+	clClear(CL_STENCIL_BUFFER_BIT);
+}
+
+void CL_GLStateChecker::enable_stencil_write(bool enabled, bool visible, double alpha_limit)
+{
+	opengl_state-&gt;set_active();
+
+	flush();
+
+	if( enabled )
+	{
+		if( !visible )
+			clColorMask(0,0,0,0);
+
+		clEnable(CL_STENCIL_TEST);
+		clStencilFunc(stencil_func_write, stencil_write_ref, 255);
+		clStencilOp(stencil_op_fail, CL_KEEP, stencil_op_pass); // CL_KEEP: action for stencil-pass &amp; z-fail
+		clEnable(CL_ALPHA_TEST);
+		clAlphaFunc(CL_GEQUAL, alpha_limit);
+	}
+	else
+	{
+		clColorMask(1,1,1,1);
+		clDisable(CL_STENCIL_TEST);
+		clDisable(CL_ALPHA_TEST);  
+	}
+}
+
+void CL_GLStateChecker::enable_stencil_test(bool enabled, CL_StencilFunc func, int ref)
+{
+	opengl_state-&gt;set_active();
+
+	flush();
+
+	int stencil_func = 0;
+
+	switch( func )
+	{
+		case stencil_never: stencil_func = CL_NEVER; break;
+		case stencil_less: stencil_func = CL_LESS; break;
+		case stencil_lequal: stencil_func = CL_LEQUAL; break;
+		case stencil_greater: stencil_func = CL_GREATER; break;
+		case stencil_gequal: stencil_func = CL_GEQUAL; break;
+		case stencil_equal: stencil_func = CL_EQUAL; break;
+		case stencil_notequal: stencil_func = CL_NOTEQUAL; break;
+		case stencil_always: stencil_func = CL_ALWAYS; break;
+		default: stencil_func = CL_LEQUAL;
+	}
+
+	if( enabled )
+	{
+		clEnable(CL_STENCIL_TEST);	
+		clStencilFunc(stencil_func, ref, 255); 
+		clStencilOp(CL_KEEP, CL_KEEP, CL_KEEP);
+	}
+	else
+	{
+		clDisable(CL_STENCIL_TEST);	
+	}
+}
+
+void CL_GLStateChecker::reinitialize_asap()
+{
+	first_call = true;	
+}

Added: trunk/clanlib/GL/gl_state_checker.h
===================================================================
--- trunk/clanlib/GL/gl_state_checker.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/gl_state_checker.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,215 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_gl_state_checker
+#define header_gl_state_checker
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/GL/opengl_state_data.h&quot;
+#include &quot;API/Display/stencil_func.h&quot;
+
+#ifdef WIN32
+#include &lt;windows.h&gt;
+#endif 
+
+#include &lt;stack&gt;
+#include &quot;gl_state.h&quot;
+
+class CL_Quad;
+class CL_Rect;
+class CL_Rectf;
+class CL_Pointf;
+class CL_Color;
+class CL_GraphicContext;
+class CL_OpenGLState;
+class CL_GraphicContext_OpenGL;
+class CL_Surface_Target;
+struct CL_TriangleParams;
+
+class CL_GLStateChecker : private CL_OpenGLStateData
+{
+//! Construction:
+public:
+	CL_GLStateChecker(CL_GraphicContext_OpenGL *gc_opengl);
+
+	~CL_GLStateChecker();
+
+//! Attributes:
+public:
+	CL_OpenGLState *opengl_state;
+
+	CL_GraphicContext_OpenGL *gc_opengl;
+
+	CLint stencil_op_pass;
+	CLint stencil_op_fail;
+	CLint stencil_func_write;
+	CLint stencil_write_ref;
+
+//! Operations:
+public:
+	static CL_GLStateChecker *from_gc(CL_GraphicContext *gc);
+
+	//: clear the screen. 
+	void add_clear(
+		const CL_Color &amp;color);
+
+	//: add a pixel
+	void add_pixel(
+		const CL_GLState &amp;state,
+		int x, int y);
+
+	//: add a line
+	void add_line(
+		const CL_GLState &amp;state,
+		float x1, float y1, float x2, float y2);
+
+	//: add lines
+	void add_lines(
+		const CL_GLState &amp;state,
+		unsigned int count,
+		double *vertices);
+
+	//: add a gradient filled rectangle.
+	void add_gradient(
+		const CL_GLState &amp;state,
+		const CL_Rectf &amp;position,
+		const CL_Gradient &amp;gradient);
+	
+	//: add a gradient filled quad.
+	void add_gradient(
+		const CL_GLState &amp;state,
+		const CL_Quad &amp;quad,
+		const CL_Gradient &amp;gradient);
+
+	//: add a textured quad.
+	void add_quad(
+		const CL_GLState &amp;state,
+		double px1,
+		double py1,
+		double px2,
+		double py2,
+		int tx1,
+		int ty1,
+		int tx2,
+		int ty2);
+
+	//: add a textured quad.
+	void add_quad(
+		const CL_GLState &amp;state,
+		const double destX[4],
+		const double destY[4],
+		const int tx[4],
+		const int ty[4]);
+
+	//: add triangles (optionally colored and uv-mapped).
+	void add_triangles( const CL_GLState &amp;state, CL_TriangleParams *params);
+
+	//: Renders state tree objects.
+	void flush(bool rebind_texture=false) const;
+
+	//: Reads a pixel from opengl context.
+	CL_Color get_pixel(int x, int y) const;
+
+	//: Clears the Stencil buffer
+	void clear_stencil(int value);
+
+	//: Enable writing to stencil buffer
+	void enable_stencil_write(bool enabled, bool visible, double alpha_limit);
+
+	//: Enable testing pixels to be drawn with stencil buffer
+	void enable_stencil_test(bool enabled, CL_StencilFunc func, int ref);
+
+	void reinitialize_asap(); //MacOS needed method after toggling windowed/fullscreen mode
+
+//! CL_OpenGLStateData:
+private:
+	//: Save state information needed to restore this OpenGL state.
+	virtual void on_save();
+
+	//: Load state information and setup OpenGL to this state.
+	virtual void on_load();
+
+	//: Flush current rendering batch.
+	virtual void on_flush();
+
+//! Implementation:
+private:
+	inline void add_quad_vertices(const CL_GLState &amp;state, double px1, double py1, double px2, double py2 );
+	
+	inline void add_quad_vertices(const CL_GLState &amp;state, double px1, double py1, double px2, double py2, double px3, double py3, double px4, double py4 );
+
+	void set_state(const CL_GLState &amp;state, CLenum primitive);
+
+	//: set_state helper.
+	void set_blendfunc(const CL_GLState &amp;state);
+
+	void set_fillmode(const CL_GLState &amp;state);
+
+	mutable CL_GLState internal_state;
+
+	mutable CLenum primitive;
+
+	// Primitive texture.
+	// Store pointer to surface used for texturing primitives (triangle)
+	// Used for inc/dec of reference counting of the surface.
+	// Makes sure the texture isn't free'ed before draw operations are completed.
+	CL_Surface_Target *primitive_texture;
+
+	// Number of quads that can be drawn at once.
+	// If more are drawn, a flush() will take place.
+	#define MAX_QUAD_COUNT 256
+
+	// Need to distinguish gradients from plain quads.
+	// This can be whatever except CL_QUADS, CL_LINES or CL_POINTS.
+	#define CL_GRADIENT 0x1337
+
+	//: keep track of how many primitives to draw.
+	mutable int primitive_count;
+
+	CLdouble vertex_array[MAX_QUAD_COUNT*3*4];
+	CLint i_uv_array[MAX_QUAD_COUNT*2*4];
+	CLdouble d_uv_array[MAX_QUAD_COUNT*2*4];
+	CLdouble d_color_array[MAX_QUAD_COUNT*4*4];
+	CLubyte b_color_array[MAX_QUAD_COUNT*4*4];
+
+	bool tri_use_uv;
+	bool tri_use_color;
+	
+	bool first_call;
+	
+	bool color_array_enabled;
+
+	bool color_array_range_zero2one;
+	bool uv_array_range_zero2one;
+};
+
+#endif

Added: trunk/clanlib/GL/graphic_context_opengl.cpp
===================================================================
--- trunk/clanlib/GL/graphic_context_opengl.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/graphic_context_opengl.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,559 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;Display/display_window_generic.h&quot;
+#include &quot;Display/triangle_params.h&quot;
+#include &quot;graphic_context_opengl.h&quot;
+#include &quot;canvas_opengl.h&quot;
+#include &quot;surface_target_opengl.h&quot;
+#include &quot;API/Display/color.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/System/log.h&quot;
+#include &quot;API/GL/opengl_state.h&quot;
+#include &quot;GL/gl_state_checker.h&quot;
+#include &quot;API/GL/opengl.h&quot;
+#include &quot;API/GL/opengl_wrap.h&quot;
+#ifdef WIN32
+#include &quot;WGL/display_window_opengl.h&quot;
+#else
+#include &quot;GLX/display_window_opengl.h&quot;
+#endif
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_GraphicContext_OpenGL construction:
+
+CL_GraphicContext_OpenGL::CL_GraphicContext_OpenGL(CL_DisplayWindow_Generic *window)
+	: state_checker(0), window(window), canvas_target(0), max_texture_size(0)
+{
+	slots.connect(window-&gt;sig_resize, this, &amp;CL_GraphicContext_OpenGL::on_resize);
+
+	state_checker = new CL_GLStateChecker(this);
+}
+
+CL_GraphicContext_OpenGL::CL_GraphicContext_OpenGL(CL_Canvas_OpenGL *canvas_target)
+	: state_checker(0), window(0), canvas_target(canvas_target), max_texture_size(0)
+{
+	state_checker = new CL_GLStateChecker(this);
+}
+
+CL_GraphicContext_OpenGL::~CL_GraphicContext_OpenGL()
+{
+	delete state_checker;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_GraphicContext_OpenGL attributes:
+
+int CL_GraphicContext_OpenGL::get_width() const
+{
+	if (canvas_target) return canvas_target-&gt;get_width();
+	return window-&gt;get_width();
+}
+
+int CL_GraphicContext_OpenGL::get_height() const
+{
+	if (canvas_target) return canvas_target-&gt;get_height();
+	return window-&gt;get_height();
+}
+
+CL_Color CL_GraphicContext_OpenGL::get_pixel(int x, int y) const
+{
+	return state_checker-&gt;get_pixel(static_cast&lt;int&gt;(x+get_modelview().get_origin_x()),
+                                    static_cast&lt;int&gt;(y+get_modelview().get_origin_y()));
+}
+
+CL_PixelBuffer CL_GraphicContext_OpenGL::get_pixeldata(const CL_Rect&amp; rect, int frame) const
+{
+	state_checker-&gt;opengl_state-&gt;set_active();
+	state_checker-&gt;opengl_state-&gt;set_active();
+	state_checker-&gt;opengl_state-&gt;setup_2d();
+
+	int width;
+	if (rect.get_width() == 0) 
+		width = get_width();
+	else
+		width = rect.get_width();
+
+	int height;
+	if (rect.get_height() == 0) 
+		height = get_height();
+	else
+		height = rect.get_height();
+
+	CLint align;
+	clGetIntegerv(CL_PACK_ALIGNMENT, &amp;align);
+	int pitch  = static_cast&lt;int&gt;((width*4+align-1)/align) * align;
+
+	CL_PixelBuffer buffer(width, height, pitch, CL_PixelFormat::abgr8888);
+
+	// Keep the current read buffer, so we can reset it after we are done
+	CLint old_frame;
+	clGetIntegerv(CL_READ_BUFFER, &amp;old_frame);
+
+	buffer.lock();
+	clReadBuffer(frame);
+	clReadPixels(rect.left, rect.top, width, height, CL_RGBA, CL_UNSIGNED_BYTE, buffer.get_data());
+
+	// OpenGL gives us the image upside down, so we flip it
+	unsigned char* buf = static_cast&lt;unsigned char*&gt;(buffer.get_data());
+	unsigned char*  tmp = new unsigned char[pitch];
+	for(int y = 0; y &lt; height/2; ++y)
+	{
+      memcpy(tmp, buf + ((height-y-1) * pitch), sizeof(unsigned char) * pitch);
+      memcpy(buf + ((height-y-1) * pitch), buf + (y * pitch), sizeof(unsigned char) * pitch);
+      memcpy(buf + (y * pitch), tmp, sizeof(unsigned char) * pitch);
+	}
+	delete tmp;
+
+	buffer.unlock();
+	clReadBuffer(old_frame);
+
+	return buffer;
+}
+
+CL_Size CL_GraphicContext_OpenGL::get_max_surface_size() const
+{
+	if (max_texture_size == 0)
+	{
+		state_checker-&gt;opengl_state-&gt;set_active();
+		max_texture_size = 512;
+		clGetIntegerv(CL_MAX_TEXTURE_SIZE, &amp;max_texture_size);
+	}
+	return CL_Size(max_texture_size, max_texture_size);
+}
+
+#ifdef WIN32
+
+HDC CL_GraphicContext_OpenGL::get_drawable()
+{
+	if (window) return ((CL_DisplayWindow_OpenGL *) window)-&gt;get_dc();
+	return canvas_target-&gt;get_pbuffer_dc();
+}
+
+HGLRC CL_GraphicContext_OpenGL::get_context()
+{
+	if (window) return ((CL_DisplayWindow_OpenGL *) window)-&gt;get_context();
+	return canvas_target-&gt;get_pbuffer_context();
+}
+
+#else
+#ifdef __APPLE__
+
+/*
+AGLDrawable CL_GraphicContext_OpenGL::get_drawable()
+{
+	if (window) return ((CL_DisplayWindow_OpenGL *) window)-&gt;get_drawable();
+	return canvas_target-&gt;get_pbuffer();
+}
+*/
+
+AGLContext CL_GraphicContext_OpenGL::get_context()
+{
+	if (window) return ((CL_DisplayWindow_OpenGL *) window)-&gt;get_context();
+	return canvas_target-&gt;get_pbuffer_context();
+}
+
+#else
+
+Display *CL_GraphicContext_OpenGL::get_display()
+{
+	if (window) return ((CL_DisplayWindow_OpenGL *) window)-&gt;get_display();
+	return CL_DisplayWindow_OpenGL::get_display();
+}
+
+GLXDrawable CL_GraphicContext_OpenGL::get_drawable()
+{
+	if (window) return ((CL_DisplayWindow_OpenGL *) window)-&gt;get_window();
+	return canvas_target-&gt;get_pbuffer();
+}
+
+GLXContext CL_GraphicContext_OpenGL::get_context()
+{
+	if (window) return ((CL_DisplayWindow_OpenGL *) window)-&gt;get_context();
+	return canvas_target-&gt;get_pbuffer_context();
+}
+
+#endif
+#endif
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_GraphicContext_OpenGL operations:
+
+void CL_GraphicContext_OpenGL::draw_pixel(int x, int y, const CL_Color &amp;color)
+{
+	CL_GLState state;
+	state.texture_handle = -1; // disable texture
+	state.color[0] = color.get_red()/255.0f;
+	state.color[1] = color.get_green()/255.0f;
+	state.color[2] = color.get_blue()/255.0f;
+	state.color[3] = color.get_alpha()/255.0f;
+	state.blendfunc[0] = blend_src_alpha;
+	state.blendfunc[1] = blend_one_minus_src_alpha;
+	state.blendfunc[2] = blend_src_alpha;
+	state.blendfunc[3] = blend_one_minus_src_alpha;
+	state.fillmode = fillmode_solid;
+	
+	state_checker-&gt;add_pixel(state, x, y);
+}
+
+void CL_GraphicContext_OpenGL::draw_line(float x1, float y1, float x2, float y2, const CL_Color &amp;color)
+{
+	CL_GLState state;
+	state.texture_handle = -1; // disable texture
+	state.color[0] = color.get_red()/255.0f;
+	state.color[1] = color.get_green()/255.0f;
+	state.color[2] = color.get_blue()/255.0f;
+	state.color[3] = color.get_alpha()/255.0f;
+	state.blendfunc[0] = blend_src_alpha;
+	state.blendfunc[1] = blend_one_minus_src_alpha;
+	state.blendfunc[2] = blend_src_alpha;
+	state.blendfunc[3] = blend_one_minus_src_alpha;
+	state.fillmode = fillmode_solid;
+
+	state_checker-&gt;add_line(state, x1, y1, x2, y2);
+}
+
+void CL_GraphicContext_OpenGL::draw_lines(int count, double *vertices, const CL_Color &amp;color)
+{
+	CL_GLState state;
+	state.texture_handle = -1; // disable texture
+	state.color[0] = color.get_red()/255.0f;
+	state.color[1] = color.get_green()/255.0f;
+	state.color[2] = color.get_blue()/255.0f;
+	state.color[3] = color.get_alpha()/255.0f;
+	state.blendfunc[0] = blend_src_alpha;
+	state.blendfunc[1] = blend_one_minus_src_alpha;
+	state.blendfunc[2] = blend_src_alpha;
+	state.blendfunc[3] = blend_one_minus_src_alpha;
+
+	state.fillmode = fillmode_solid;
+
+	state_checker-&gt;add_lines(state, count, vertices);
+}
+
+void CL_GraphicContext_OpenGL::draw_rect(const CL_Rectf &amp;rect, const CL_Color &amp;color)
+{
+	CL_GLState state;
+	state.texture_handle = -1; // disable texture
+	state.color[0] = color.get_red()/255.0f;
+	state.color[1] = color.get_green()/255.0f;
+	state.color[2] = color.get_blue()/255.0f;
+	state.color[3] = color.get_alpha()/255.0f;
+	state.blendfunc[0] = blend_src_alpha;
+	state.blendfunc[1] = blend_one_minus_src_alpha;
+	state.blendfunc[2] = blend_src_alpha;
+	state.blendfunc[3] = blend_one_minus_src_alpha;
+
+	state.fillmode = fillmode_solid;
+
+	state_checker-&gt;add_line(state, rect.left, rect.top, rect.right, rect.top);
+	state_checker-&gt;add_line(state, rect.right - 1, rect.top + 1, rect.right - 1, rect.bottom);
+	state_checker-&gt;add_line(state, rect.left, rect.bottom - 1, rect.right - 1, rect.bottom - 1);
+	state_checker-&gt;add_line(state, rect.left, rect.top + 1, rect.left, rect.bottom - 1);
+
+	// draw rect without filling... just lines
+/*	state.fillmode = fillmode_line;
+
+	state_checker-&gt;add_quad(
+		state,
+		rect.left,
+		rect.top,
+//		rect.right,
+//		rect.bottom,
+		rect.right - 1,
+		rect.bottom - 1,
+		0,0,1,1);
+*/
+}
+
+void CL_GraphicContext_OpenGL::fill_rect(const CL_Rectf &amp;rect, const CL_Color &amp;color)
+{
+	CL_GLState state;
+	state.texture_handle = -1;
+	state.color[0] = color.get_red()/255.0f;
+	state.color[1] = color.get_green()/255.0f;
+	state.color[2] = color.get_blue()/255.0f;
+	state.color[3] = color.get_alpha()/255.0f;
+	state.blendfunc[0] = blend_src_alpha;
+	state.blendfunc[1] = blend_one_minus_src_alpha;
+	state.blendfunc[2] = blend_src_alpha;
+	state.blendfunc[3] = blend_one_minus_src_alpha;
+
+	state.fillmode = fillmode_solid;
+
+	state_checker-&gt;add_quad(
+		state,
+		rect.left,
+		rect.top,
+		rect.right,
+		rect.bottom,
+		0,
+		0,
+		1,
+		1);
+}
+
+void CL_GraphicContext_OpenGL::fill_rect(const CL_Rectf &amp;rect, const CL_Gradient &amp;gradient)
+{
+	CL_GLState state;
+	state.texture_handle = -1;
+	state.color[0] = gradient.top_left.get_red()/255.0f;
+	state.color[1] = gradient.top_left.get_green()/255.0f;
+	state.color[2] = gradient.top_left.get_blue()/255.0f;
+	state.color[3] = gradient.top_left.get_alpha()/255.0f;
+	state.blendfunc[0] = blend_src_alpha;
+	state.blendfunc[1] = blend_one_minus_src_alpha;
+	state.blendfunc[2] = blend_src_alpha;
+	state.blendfunc[3] = blend_one_minus_src_alpha;
+
+	state.fillmode = fillmode_solid;
+
+	CL_Rectf pos(rect.left, rect.top, rect.right, rect.bottom);
+	state_checker-&gt;add_gradient(state, pos, gradient);
+}
+
+void CL_GraphicContext_OpenGL::draw_quad(const CL_Quad &amp;quad, const CL_Color &amp;color)
+{
+	CL_GLState state;
+	state.texture_handle = -1; // disable texture
+	state.color[0] = color.get_red()/255.0f;
+	state.color[1] = color.get_green()/255.0f;
+	state.color[2] = color.get_blue()/255.0f;
+	state.color[3] = color.get_alpha()/255.0f;
+	state.blendfunc[0] = blend_src_alpha;
+	state.blendfunc[1] = blend_one_minus_src_alpha;
+	state.blendfunc[2] = blend_src_alpha;
+	state.blendfunc[3] = blend_one_minus_src_alpha;
+	state.fillmode = fillmode_line;
+
+	double qx[4] = { quad.x1, quad.x2, quad.x3, quad.x4 };
+	double qy[4] = { quad.y1, quad.y2, quad.y3, quad.y4 };
+	int tx[4] = { quad.x1, quad.x2, quad.x3, quad.x4 };
+	int ty[4] = { quad.y1, quad.y2, quad.y3, quad.y4 };
+
+	state_checker-&gt;add_quad(
+		state,
+		qx, qy,
+		tx, ty);
+}
+
+void CL_GraphicContext_OpenGL::fill_quad(const CL_Quad &amp;quad, const CL_Color &amp;color)
+{
+	CL_GLState state;
+	state.texture_handle = -1;
+	state.color[0] = color.get_red()/255.0f;
+	state.color[1] = color.get_green()/255.0f;
+	state.color[2] = color.get_blue()/255.0f;
+	state.color[3] = color.get_alpha()/255.0f;
+	state.blendfunc[0] = blend_src_alpha;
+	state.blendfunc[1] = blend_one_minus_src_alpha;
+	state.blendfunc[2] = blend_src_alpha;
+	state.blendfunc[3] = blend_one_minus_src_alpha;
+	state.fillmode = fillmode_solid;
+
+	double qx[4] = { quad.x1, quad.x2, quad.x3, quad.x4 };
+	double qy[4] = { quad.y1, quad.y2, quad.y3, quad.y4 };
+	int tx[4] = { quad.x1, quad.x2, quad.x3, quad.x4 };
+	int ty[4] = { quad.y1, quad.y2, quad.y3, quad.y4 };
+
+	state_checker-&gt;add_quad(
+		state,
+		qx, qy,
+		tx, ty);
+}
+
+void CL_GraphicContext_OpenGL::fill_quad(const CL_Quad &amp;quad, const CL_Gradient &amp;gradient)
+{
+	CL_GLState state;
+	state.texture_handle = -1;
+	state.color[0] = gradient.top_left.get_red()/255.0f;
+	state.color[1] = gradient.top_left.get_green()/255.0f;
+	state.color[2] = gradient.top_left.get_blue()/255.0f;
+	state.color[3] = gradient.top_left.get_alpha()/255.0f;
+	state.blendfunc[0] = blend_src_alpha;
+	state.blendfunc[1] = blend_one_minus_src_alpha;
+	state.blendfunc[2] = blend_src_alpha;
+	state.blendfunc[3] = blend_one_minus_src_alpha;
+	state.fillmode = fillmode_solid;
+
+	state_checker-&gt;add_gradient(state, quad, gradient);
+}
+
+void CL_GraphicContext_OpenGL::draw_triangles(
+	CL_TriangleParams *params )
+{
+	CL_GLState state;
+
+	state.fillmode = params-&gt;fill ? fillmode_solid : fillmode_line;
+
+	if( params-&gt;texture )
+	{
+		CL_Surface_Target_OpenGL *ogl_tex = dynamic_cast&lt;CL_Surface_Target_OpenGL*&gt;(params-&gt;texture);
+
+		if( ogl_tex )
+		{
+			state.texture_handle = ogl_tex-&gt;handle;
+		}
+		else
+			state.texture_handle = -1;
+	}
+	else
+		state.texture_handle = -1;
+
+	if( params-&gt;single_color )
+	{
+		state.color[0] = params-&gt;single_color-&gt;get_red()/255.0;
+		state.color[1] = params-&gt;single_color-&gt;get_green()/255.0;
+		state.color[2] = params-&gt;single_color-&gt;get_blue()/255.0;
+		state.color[3] = params-&gt;single_color-&gt;get_alpha()/255.0;
+	}
+
+	state.blendfunc[0] = blend_src_alpha;
+	state.blendfunc[1] = blend_one_minus_src_alpha;
+	state.blendfunc[2] = blend_src_alpha;
+	state.blendfunc[3] = blend_one_minus_src_alpha;
+
+	state.color_range_zero2one = (params-&gt;color != 0);
+	state.uv_range_zero2one = (params-&gt;uv != 0);
+	
+	state_checker-&gt;add_triangles(state, params);
+}
+
+
+void CL_GraphicContext_OpenGL::clear(const CL_Color &amp;color)
+{
+	state_checker-&gt;add_clear(color);
+}
+
+void CL_GraphicContext_OpenGL::sync_gc()
+{
+	if (canvas_target)
+	{
+		canvas_target-&gt;sync_pbuffer();
+		canvas_target-&gt;set_pbuffer_modified();
+	}
+}
+
+
+void CL_GraphicContext_OpenGL::clear_stencil(int value)
+{
+	state_checker-&gt;clear_stencil(value);	
+}
+
+void CL_GraphicContext_OpenGL::set_stencil_operation(CL_StencilOp pass, CL_StencilOp fail, CL_StencilFunc func, int ref)
+{
+	switch( pass )
+	{
+		case stencil_keep: state_checker-&gt;stencil_op_pass = CL_KEEP; break;
+		case stencil_zero: state_checker-&gt;stencil_op_pass = CL_ZERO; break;
+		case stencil_replace: state_checker-&gt;stencil_op_pass = CL_REPLACE; break;
+		case stencil_incr: state_checker-&gt;stencil_op_pass = CL_INCR; break;
+		case stencil_decr: state_checker-&gt;stencil_op_pass = CL_DECR; break;
+		case stencil_invert: state_checker-&gt;stencil_op_pass = CL_INVERT; break;
+		default: state_checker-&gt;stencil_op_pass = CL_KEEP;
+	}		
+
+	switch( fail )
+	{
+		case stencil_keep: state_checker-&gt;stencil_op_fail = CL_KEEP; break;
+		case stencil_zero: state_checker-&gt;stencil_op_fail = CL_ZERO; break;
+		case stencil_replace: state_checker-&gt;stencil_op_fail = CL_REPLACE; break;
+		case stencil_incr: state_checker-&gt;stencil_op_fail = CL_INCR; break;
+		case stencil_decr: state_checker-&gt;stencil_op_fail = CL_DECR; break;
+		case stencil_invert: state_checker-&gt;stencil_op_fail = CL_INVERT; break;
+		default: state_checker-&gt;stencil_op_fail = CL_KEEP;
+	}
+
+	switch( func )
+	{
+		case stencil_never: state_checker-&gt;stencil_func_write = CL_NEVER; break;
+		case stencil_less: state_checker-&gt;stencil_func_write = CL_LESS; break;
+		case stencil_lequal: state_checker-&gt;stencil_func_write = CL_LEQUAL; break;
+		case stencil_greater: state_checker-&gt;stencil_func_write = CL_GREATER; break;
+		case stencil_gequal: state_checker-&gt;stencil_func_write = CL_GEQUAL; break;
+		case stencil_equal: state_checker-&gt;stencil_func_write = CL_EQUAL; break;
+		case stencil_notequal: state_checker-&gt;stencil_func_write = CL_NOTEQUAL; break;
+		case stencil_always: state_checker-&gt;stencil_func_write = CL_ALWAYS; break;
+		default: state_checker-&gt;stencil_func_write = CL_ALWAYS;
+	}
+	
+	state_checker-&gt;stencil_write_ref = ref;	
+}
+
+void CL_GraphicContext_OpenGL::enable_stencil_write(bool enabled, bool visible, float alpha_limit)
+{
+	state_checker-&gt;enable_stencil_write(enabled, visible, (double)alpha_limit);
+}
+
+void CL_GraphicContext_OpenGL::enable_stencil_test(bool enabled, CL_StencilFunc func, int ref)
+{
+	state_checker-&gt;enable_stencil_test(enabled, func, ref);
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_GraphicContext_OpenGL implementation:
+
+void CL_GraphicContext_OpenGL::set_cliprect(const CL_Rect &amp;rect)
+{
+	CL_GraphicContext_Generic::set_cliprect(rect);
+	sig_update_scissor();
+}
+
+void CL_GraphicContext_OpenGL::push_cliprect(const CL_Rect &amp;rect)
+{
+	CL_GraphicContext_Generic::push_cliprect(rect);
+	sig_update_scissor();
+}
+
+void CL_GraphicContext_OpenGL::push_cliprect()
+{
+	CL_GraphicContext_Generic::push_cliprect();
+	sig_update_scissor();
+}
+
+void CL_GraphicContext_OpenGL::pop_cliprect()
+{
+	CL_GraphicContext_Generic::pop_cliprect();
+	sig_update_scissor();
+}
+
+void CL_GraphicContext_OpenGL::modelview_changed()
+{
+	sig_update_modelview();
+}
+
+void CL_GraphicContext_OpenGL::on_resize(int width, int height)
+{
+	cliprects.pop_back();
+	cliprects.push_back(CL_Rect(0, 0, width, height));
+	sig_update_viewport();
+}

Added: trunk/clanlib/GL/graphic_context_opengl.h
===================================================================
--- trunk/clanlib/GL/graphic_context_opengl.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/graphic_context_opengl.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,211 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_graphic_context_opengl
+#define header_graphic_context_opengl
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;Display/graphic_context_generic.h&quot;
+#include &quot;API/signals.h&quot;
+#ifndef WIN32
+#ifdef __APPLE__
+#include &lt;AGL/agl.h&gt;
+#else
+#include &lt;GL/glx.h&gt;
+#endif
+#endif
+#include &quot;API/GL/opengl.h&quot;
+
+class CL_DisplayWindow_Generic;
+class CL_Canvas_OpenGL;
+class CL_GLStateChecker;
+class CL_Surface_Target;
+
+//: OpenGL graphic context
+class CL_GraphicContext_OpenGL : public CL_GraphicContext_Generic
+{
+//! Construction:
+public:
+	CL_GraphicContext_OpenGL(CL_DisplayWindow_Generic *window);
+
+	CL_GraphicContext_OpenGL(CL_Canvas_OpenGL *canvas_target);
+
+	virtual ~CL_GraphicContext_OpenGL();
+
+//! Attributes:
+public:
+	//: Returns the current width of the context.
+	virtual int get_width() const;
+
+	//: Returns the current height of the context.
+	virtual int get_height() const;
+
+	//: Returns a pixel value at specified coordinates.
+	virtual CL_Color get_pixel(int x, int y) const;
+
+	virtual CL_PixelBuffer get_pixeldata(const CL_Rect&amp; rect = CL_Rect(0,0,0,0), int i = 0) const;
+
+	bool is_canvas_target() const { return (canvas_target != 0); }
+
+#ifdef WIN32
+	HDC get_drawable();
+
+	HGLRC get_context();
+#else
+#ifdef __APPLE__
+	//AGLDrawable get_drawable();
+	
+	AGLContext get_context();
+#else
+	Display *get_display();
+
+	GLXDrawable get_drawable();
+
+	GLXContext get_context();
+#endif
+#endif
+
+	//: Returns the maximum size of a surface this displaywindow supports.
+	virtual CL_Size get_max_surface_size() const;
+
+	//: Batched OpenGL 2D rendering.
+	CL_GLStateChecker *state_checker;
+
+	//: Signal emitted when OpenGL scissor needs to be updated.
+	CL_Signal_v0 sig_update_scissor;
+
+	//: Signal emitted when OpenGL modelview needs to be updated.
+	CL_Signal_v0 sig_update_modelview;
+
+	//: Signal emitted when OpenGL viewport needs to be updated.
+	CL_Signal_v0 sig_update_viewport;
+
+//! Operations:
+public:
+	//: Draw a pixel at (x, y) using the specified color.
+	virtual void draw_pixel(int x, int y, const CL_Color &amp;color);
+
+	//: Draw a line from (x1, y1) to (x2, y2) using the specified color.
+	virtual void draw_line(float x1, float y1, float x2, float y2, const CL_Color &amp;color);
+
+	//: Draw a chain of lines using the specified color.
+	virtual void draw_lines(int count, double *vertices, const CL_Color &amp;color);
+
+	//: Draw a rectangle using the specified color.
+	virtual void draw_rect(const CL_Rectf &amp;rect, const CL_Color &amp;color);
+
+	//: Draw a gradient rectangle using the specified gradient.
+	virtual void fill_rect(const CL_Rectf &amp;rect, const CL_Gradient &amp;gradient);
+
+	//: Draw a filled rectangle using the specified color.
+	virtual void fill_rect(const CL_Rectf &amp;rect, const CL_Color &amp;color);
+	
+	//: Draw a quad using the specified color.
+	virtual void draw_quad(const CL_Quad &amp;quad, const CL_Color &amp;color);
+
+	//: Draw a gradient quad using the specified gradient.
+	virtual void fill_quad(const CL_Quad &amp;quad, const CL_Gradient &amp;gradient);
+
+	//: Draw a filled quad using the specified color.
+	virtual void fill_quad(const CL_Quad &amp;quad, const CL_Color &amp;color);
+
+	//: Draw triangles (optionally colored and uv-mapped).
+	virtual void draw_triangles( CL_TriangleParams *params );
+
+	//: Clears the whole context using the specified color.
+	virtual void clear(const CL_Color &amp;color);
+
+	//: Set the current clipping rectangle.
+	virtual void set_cliprect(const CL_Rect &amp;rect);
+
+	//: Push current clipping rectangle to stack; then set clipping rectangle to the
+	//: union of the current rectangle and the passed rectangle.
+	virtual void push_cliprect(const CL_Rect &amp;rect);
+
+	//: Push current clipping rectangle to the stack.
+	virtual void push_cliprect();
+
+	//: Pop current clipping rectangle from the stack.
+	virtual void pop_cliprect();
+
+	//: Called every time the active modelview have changed.
+	virtual void modelview_changed();
+
+	//: Clears the stencil buffer contents.
+	//param int value: stencil buffer contents will be cleared to this value. Default: 0
+	virtual void clear_stencil(int value);
+
+	//: Set stencil test function when writing to stencil, and operations to do when a test passes or fails
+	//param CL_StencilOp pass : Modification to stencil buffer when a test passes.
+	//param CL_StencilOp fail : Modification to stencil buffer when a test fails.
+	//param CL_StencilFunc func : Type of test to do when writing to stencil.
+	//param int ref : value compared to stencil contents. Default: 1
+	virtual void set_stencil_operation(CL_StencilOp pass, CL_StencilOp fail, CL_StencilFunc func, int ref);
+
+	//: Enables writing to the stencil buffer 
+	//param bool enabled : Enables/disables stencil testing.
+	//param bool visible : Enables/disables color buffer writing if stencil writing is enabled. Default: true.
+	//param float alpha_limit : Only pixels with alpha &gt;= alpha limit are drawn to the stencil buffer.
+	virtual void enable_stencil_write(bool enabled, bool visible, float alpha_limit);
+
+	//: Enables stencil buffer testing
+	//- &lt;p&gt; Individual pixels are tested against the values in the stencil buffer, and
+	//- drawn depending on the comparison result. This can be used for masking and
+	//- boolean operations on bitmaps &lt;/p&gt;
+	//param bool enabled : Enables/disables stencil testing.
+	//param int func : Type of comparison. Default: lequal (pass if ref &lt;= stencil)
+	//param int ref : Reference value that the stencil is compared with. Default: 1
+	virtual void enable_stencil_test(bool enabled, CL_StencilFunc func, int ref);
+
+	void sync_gc();
+
+//! Implementation:
+private:
+	//: Called when window is resized.
+	void on_resize(int width, int height);
+
+	//: OpenGL window.
+	//- Can be null if attached to a surface instead.
+	CL_DisplayWindow_Generic *window;
+
+	//: OpenGL surface.
+	//- Can be null if attached to a window instead.
+	CL_Canvas_OpenGL *canvas_target;
+
+	//: Maximum allowed texture size for this graphic card.
+	mutable CLint max_texture_size;
+
+	//: Slots.
+	CL_SlotContainer slots;
+};
+
+#endif

Added: trunk/clanlib/GL/light_source.cpp
===================================================================
--- trunk/clanlib/GL/light_source.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/light_source.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,207 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/GL/light_source.h&quot;
+#include &quot;API/GL/opengl_wrap.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_LightSource construction:
+
+CL_LightSource::CL_LightSource() :
+	spot_exponent(0.0f), spot_cutoff(180.0f),
+	constant_attenuation(1.0f), linear_attenuation(0.0f), quadratic_attenuation(0.0f),
+	position(0.0f, 0.0f, -1.0f, 0.0f), spot_direction(0.0f, 0.0f, -1.0f)
+{
+	ambient[0] = 0.0f;
+	ambient[1] = 0.0f;
+	ambient[2] = 0.0f;
+	ambient[3] = 1.0f;
+	diffuse[0] = 1.0f;
+	diffuse[1] = 1.0f;
+	diffuse[2] = 1.0f;
+	diffuse[3] = 1.0f;
+	specular[0] = 1.0f;
+	specular[1] = 1.0f;
+	specular[2] = 1.0f;
+	specular[3] = 1.0f;
+}
+
+CL_LightSource::~CL_LightSource()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_LightSource attributes:
+
+float CL_LightSource::get_spot_exponent() const
+{
+	return spot_exponent;
+}
+
+float CL_LightSource::get_spot_cutoff() const
+{
+	return spot_cutoff;
+}
+
+float CL_LightSource::get_constant_attenuation() const
+{
+	return constant_attenuation;
+}
+
+float CL_LightSource::get_linear_attenuation() const
+{
+	return linear_attenuation;
+}
+
+float CL_LightSource::get_quadratic_attenuation() const
+{
+	return quadratic_attenuation;
+}
+
+void CL_LightSource::get_ambient_intensity(float &amp;red, float &amp;green, float &amp;blue, float &amp;alpha) const
+{
+	red = ambient[0];
+	green = ambient[1];
+	blue = ambient[2];
+	alpha = ambient[3];
+}
+
+void CL_LightSource::get_diffuse_intensity(float &amp;red, float &amp;green, float &amp;blue, float &amp;alpha) const
+{
+	red = diffuse[0];
+	green = diffuse[1];
+	blue = diffuse[2];
+	alpha = diffuse[3];
+}
+
+void CL_LightSource::get_specular_intensity(float &amp;red, float &amp;green, float &amp;blue, float &amp;alpha) const
+{
+	red = specular[0];
+	green = specular[1];
+	blue = specular[2];
+	alpha = specular[3];
+}
+
+CL_Vector CL_LightSource::get_position() const
+{
+	return position;
+}
+
+CL_Vector CL_LightSource::get_spot_direction() const
+{
+	return spot_direction;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_LightSource operations:
+
+void CL_LightSource::set_spot_exponent(float new_spot_exponent)
+{
+	spot_exponent = new_spot_exponent;
+}
+
+void CL_LightSource::set_spot_cutoff(float new_spot_cutoff)
+{
+	spot_cutoff = new_spot_cutoff;
+}
+
+void CL_LightSource::set_constant_attenuation(float new_constant_attenuation)
+{
+	constant_attenuation = new_constant_attenuation;
+}
+
+void CL_LightSource::set_linear_attenuation(float new_linear_attenuation)
+{
+	linear_attenuation = new_linear_attenuation;
+}
+
+void CL_LightSource::set_quadratic_attenuation(float new_quadratic_attenuation)
+{
+	quadratic_attenuation = new_quadratic_attenuation;
+}
+
+void CL_LightSource::set_ambient_intensity(float red, float green, float blue, float alpha)
+{
+	ambient[0] = red;
+	ambient[1] = green;
+	ambient[2] = blue;
+	ambient[3] = alpha;
+}
+
+void CL_LightSource::set_diffuse_intensity(float red, float green, float blue, float alpha)
+{
+	diffuse[0] = red;
+	diffuse[1] = green;
+	diffuse[2] = blue;
+	diffuse[3] = alpha;
+}
+
+void CL_LightSource::set_specular_intensity(float red, float green, float blue, float alpha)
+{
+	specular[0] = red;
+	specular[1] = green;
+	specular[2] = blue;
+	specular[3] = alpha;
+}
+
+void CL_LightSource::set_position(const CL_Vector &amp;new_position)
+{
+	position = new_position;
+}
+
+void CL_LightSource::set_spot_direction(const CL_Vector &amp;new_spot_direction)
+{
+	spot_direction = new_spot_direction;
+}
+
+void CL_LightSource::set_viewpoint(const CL_Viewpoint &amp;viewpoint)
+{
+	position = viewpoint.pos;
+	spot_direction = viewpoint.dir;
+}
+
+void CL_LightSource::setup_light(CLenum light_id)
+{
+	clLightf(light_id, CL_SPOT_EXPONENT, spot_exponent);
+	clLightf(light_id, CL_SPOT_CUTOFF, spot_cutoff);
+	clLightf(light_id, CL_CONSTANT_ATTENUATION, constant_attenuation);
+	clLightf(light_id, CL_LINEAR_ATTENUATION, linear_attenuation);
+	clLightf(light_id, CL_QUADRATIC_ATTENUATION, quadratic_attenuation);
+	clLightfv(light_id, CL_AMBIENT, ambient);
+	clLightfv(light_id, CL_DIFFUSE, diffuse);
+	clLightfv(light_id, CL_SPECULAR, specular);
+	CLfloat pos[4] = { position.x, position.y, position.z, position.w };
+	clLightfv(light_id, CL_POSITION, pos);
+	CLfloat spot_dir[3] = { spot_direction.x, spot_direction.y, spot_direction.z };
+	clLightfv(light_id, CL_SPOT_DIRECTION, spot_dir);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_LightSource implementation:

Added: trunk/clanlib/GL/opengl.cpp
===================================================================
--- trunk/clanlib/GL/opengl.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/opengl.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,352 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/GL/opengl.h&quot;
+#include &quot;API/GL/opengl_wrap.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/IOData/cl_endian.h&quot;
+
+#ifdef __APPLE__
+#include &lt;OpenGL/gl.h&gt;
+#else
+#include &lt;GL/gl.h&gt;
+#endif
+#include &lt;map&gt;
+
+#ifndef WIN32
+#ifdef __APPLE__
+#include &lt;AGL/agl.h&gt;
+#include &lt;Carbon/Carbon.h&gt;
+#else
+#define GLX_GLXEXT_PROTOTYPES
+#include &lt;GL/glx.h&gt;
+#endif
+#endif
+
+CL_ProcAddress *CL_OpenGL::get_proc_address(const std::string&amp; function_name)
+{
+#ifdef WIN32
+	return (void (*)())wglGetProcAddress(function_name.c_str());
+#else
+#ifdef __APPLE__
+	// Mac OS X don't have an OpenGL extension fetch function. Isn't that silly?
+
+	static CFBundleRef cl_gBundleRefOpenGL = 0;
+	if (cl_gBundleRefOpenGL == 0)
+	{
+		cl_gBundleRefOpenGL = CFBundleGetBundleWithIdentifier(CFSTR(&quot;com.apple.opengl&quot;));
+		if (cl_gBundleRefOpenGL == 0)
+			throw CL_Error(&quot;Unable to find com.apple.opengl bundle&quot;);
+	}
+
+	return (CL_ProcAddress *) CFBundleGetFunctionPointerForName(
+		cl_gBundleRefOpenGL,
+		CFStringCreateWithCStringNoCopy(
+			0,
+			function_name.c_str(),
+			CFStringGetSystemEncoding(),
+			0));
+#else
+#  ifdef HAVE_GLX_GETPROCADDRESSARB
+	return glXGetProcAddressARB((GLubyte*)function_name.c_str());
+#  else
+	return glXGetProcAddress((GLubyte*)function_name.c_str());
+#  endif
+#endif
+#endif
+}
+
+CL_GLFunctions *CL_OpenGL::functions = 0;
+
+bool CL_OpenGL::from_opengl_pixelformat(CLenum format, CLenum type, CL_PixelFormat &amp;pf)
+{
+	int bits_per_component;
+	if (type == CL_UNSIGNED_BYTE || type == CL_BYTE)
+		bits_per_component = 8;
+	else if (type == CL_SHORT || type == CL_UNSIGNED_SHORT)
+		bits_per_component = 16;
+	else if (type == CL_INT || type == CL_UNSIGNED_INT || type == CL_FLOAT)
+		bits_per_component = 32;
+	else
+		return false;
+
+	bool big = CL_Endian::is_system_big();
+
+	if (format == CL_COLOR_INDEX)
+	{
+		pf.set_type(pixelformat_index);
+		pf.set_depth(bits_per_component);
+	}
+	else if (format == CL_RED)
+	{
+		pf.set_depth(bits_per_component);
+		pf.set_red_mask(CL_PixelFormat::get_bitmask(bits_per_component, 0));
+	}
+	else if (format == CL_GREEN)
+	{
+		pf.set_depth(bits_per_component);
+		pf.set_green_mask(CL_PixelFormat::get_bitmask(bits_per_component, 0));
+	}
+	else if (format == CL_BLUE)
+	{
+		pf.set_depth(bits_per_component);
+		pf.set_blue_mask(CL_PixelFormat::get_bitmask(bits_per_component, 0));
+	}
+	else if (format == CL_ALPHA)
+	{
+		pf.set_depth(bits_per_component);
+		pf.set_alpha_mask(CL_PixelFormat::get_bitmask(bits_per_component, 0));
+	}
+	else if (format == CL_RGB)
+	{
+		if (bits_per_component * 3 &gt; 32)
+			return false;
+		pf.set_depth(bits_per_component * 3);
+		if (!big)
+		{
+			pf.set_red_mask(CL_PixelFormat::get_bitmask(bits_per_component, 0));
+			pf.set_green_mask(CL_PixelFormat::get_bitmask(bits_per_component, bits_per_component));
+			pf.set_blue_mask(CL_PixelFormat::get_bitmask(bits_per_component, bits_per_component * 2));
+		}
+		else
+		{
+			pf.set_red_mask(CL_PixelFormat::get_bitmask(bits_per_component, bits_per_component * 2));
+			pf.set_green_mask(CL_PixelFormat::get_bitmask(bits_per_component, bits_per_component));
+			pf.set_blue_mask(CL_PixelFormat::get_bitmask(bits_per_component, 0));
+		}
+	}
+	else if (format == CL_RGBA)
+	{
+		if (bits_per_component * 4 &gt; 32)
+			return false;
+		pf.set_depth(bits_per_component * 4);
+		if (!big)
+		{
+			pf.set_red_mask(CL_PixelFormat::get_bitmask(bits_per_component, 0));
+			pf.set_green_mask(CL_PixelFormat::get_bitmask(bits_per_component, bits_per_component));
+			pf.set_blue_mask(CL_PixelFormat::get_bitmask(bits_per_component, bits_per_component * 2));
+			pf.set_alpha_mask(CL_PixelFormat::get_bitmask(bits_per_component, bits_per_component * 3));
+		}
+		else
+		{
+			pf.set_red_mask(CL_PixelFormat::get_bitmask(bits_per_component, bits_per_component * 3));
+			pf.set_green_mask(CL_PixelFormat::get_bitmask(bits_per_component, bits_per_component * 2));
+			pf.set_blue_mask(CL_PixelFormat::get_bitmask(bits_per_component, bits_per_component));
+			pf.set_alpha_mask(CL_PixelFormat::get_bitmask(bits_per_component, 0));
+		}
+	}
+	else if (format == CL_BGR)
+	{
+		if (bits_per_component * 3 &gt; 32)
+			return false;
+		pf.set_depth(bits_per_component * 3);
+		if (!big)
+		{
+			pf.set_blue_mask(CL_PixelFormat::get_bitmask(bits_per_component, 0));
+			pf.set_green_mask(CL_PixelFormat::get_bitmask(bits_per_component, bits_per_component));
+			pf.set_red_mask(CL_PixelFormat::get_bitmask(bits_per_component, bits_per_component * 2));
+		}
+		else
+		{
+			pf.set_blue_mask(CL_PixelFormat::get_bitmask(bits_per_component, bits_per_component * 2));
+			pf.set_green_mask(CL_PixelFormat::get_bitmask(bits_per_component, bits_per_component));
+			pf.set_red_mask(CL_PixelFormat::get_bitmask(bits_per_component, 0));
+		}
+	}
+	else if (format == CL_BGRA)
+	{
+		if (bits_per_component * 4 &gt; 32)
+			return false;
+		pf.set_depth(bits_per_component * 4);
+		if (!big)
+		{
+			pf.set_blue_mask(CL_PixelFormat::get_bitmask(bits_per_component, 0));
+			pf.set_green_mask(CL_PixelFormat::get_bitmask(bits_per_component, bits_per_component));
+			pf.set_red_mask(CL_PixelFormat::get_bitmask(bits_per_component, bits_per_component * 2));
+			pf.set_alpha_mask(CL_PixelFormat::get_bitmask(bits_per_component, bits_per_component * 3));
+		}
+		else
+		{
+			pf.set_blue_mask(CL_PixelFormat::get_bitmask(bits_per_component, bits_per_component * 3));
+			pf.set_green_mask(CL_PixelFormat::get_bitmask(bits_per_component, bits_per_component * 2));
+			pf.set_red_mask(CL_PixelFormat::get_bitmask(bits_per_component, bits_per_component));
+			pf.set_alpha_mask(CL_PixelFormat::get_bitmask(bits_per_component, 0));
+		}
+	}
+	else
+		return false;
+
+	return true;
+}
+
+bool CL_OpenGL::to_opengl_pixelformat(const CL_PixelFormat &amp;pf, CLenum &amp;format, CLenum &amp;type)
+{
+	// indexed modes and colorkey requires special conversion to alpha and
+	// therefore no OpenGL mode has a direct conversion format
+	if (pf.has_colorkey() || pf.get_type() == pixelformat_index)
+		return false;
+
+	bool big = CL_Endian::is_system_big();
+
+	if (pf.get_type() == pixelformat_index)
+	{
+		format = CL_COLOR_INDEX;
+		if (pf.get_depth() == 8)
+			type = CL_UNSIGNED_BYTE;
+		else if (pf.get_depth() == 16)
+			type = CL_UNSIGNED_SHORT;
+		else if (pf.get_depth() == 32)
+			type = CL_UNSIGNED_INT;
+		else
+			return false;
+	}
+	else if (pf.get_type() == pixelformat_rgba)
+	{
+		const unsigned int rm = pf.get_red_mask(),
+			gm = pf.get_green_mask(),
+			bm = pf.get_blue_mask(),
+			am = pf.get_alpha_mask();
+
+		const int rms = pf.get_mask_shift(rm),
+			gms = pf.get_mask_shift(gm),
+			bms = pf.get_mask_shift(bm),
+			ams = pf.get_mask_shift(am);
+
+		const int rmb = pf.get_mask_bits(rm),
+			gmb = pf.get_mask_bits(gm),
+			bmb = pf.get_mask_bits(bm),
+			amb = pf.get_mask_bits(am);
+
+		typedef std::map&lt;int, CLenum&gt; BitsToTypeMap;
+		static BitsToTypeMap bits_to_type;
+		if (bits_to_type.empty())
+		{
+			// initialize it only once
+			bits_to_type[8] = CL_UNSIGNED_BYTE;
+			bits_to_type[16] = CL_UNSIGNED_SHORT;
+			bits_to_type[32] = CL_UNSIGNED_INT;
+		}
+
+		if (rm &amp;&amp; gm &amp;&amp; bm &amp;&amp; am)
+		{
+			// the bit number must be 8, 16 or 32 for component
+			// they all must have the same number of bits
+			if ((!(rmb == 8 || rmb == 16 || rmb == 32)) ||
+				(rmb != gmb || rmb != bmb || rmb != amb))
+				return false;
+
+			const int bits = rmb; // they all have the same bits
+
+			if (pf.get_depth() != bits * 4)
+				return false;
+
+			type = bits_to_type[bits];
+
+			if (!big &amp;&amp; rms == 0*bits &amp;&amp; gms == 1*bits &amp;&amp; bms == 2*bits &amp;&amp; ams == 3*bits)
+				format = CL_RGBA;
+			else if (!big &amp;&amp; ams == 0*bits &amp;&amp; bms == 1*bits &amp;&amp; gms == 2*bits &amp;&amp; rms == 3*bits)
+				format = CL_ABGR;
+			else if (big &amp;&amp; rms == 3*bits &amp;&amp; gms == 2*bits &amp;&amp; bms == 1*bits &amp;&amp; ams == 0*bits)
+				format = CL_RGBA;
+			else if (big &amp;&amp; ams == 3*bits &amp;&amp; bms == 2*bits &amp;&amp; gms == 1*bits &amp;&amp; rms == 0*bits)
+				format = CL_ABGR;
+			else
+				return false;
+		}
+		else if (rm &amp;&amp; gm &amp;&amp; bm &amp;&amp; !am)
+		{
+			// the bit number must be 8, 16 or 32 for component
+			// they all must have the same number of bits
+			if ((!(rmb == 8 || rmb == 16 || rmb == 32)) ||
+				(rmb != gmb || rmb != bmb))
+				return false;
+
+			const int bits = rmb; // they all have the same bits
+
+			if (pf.get_depth() != bits * 3)
+				return false;
+
+			type = bits_to_type[bits];
+
+			if (!big &amp;&amp; rms == 0*bits &amp;&amp; gms == 1*bits &amp;&amp; bms == 2*bits)
+				format = CL_RGB;
+			else if (!big &amp;&amp; bms == 0*bits &amp;&amp; gms == 1*bits &amp;&amp; rms == 2*bits)
+				format = CL_BGR;
+			else if (big &amp;&amp; rms == 2*bits &amp;&amp; gms == 1*bits &amp;&amp; bms == 0*bits)
+				format = CL_RGB;
+			else if (big &amp;&amp; bms == 2*bits &amp;&amp; gms == 1*bits &amp;&amp; rms == 0*bits)
+				format = CL_BGR;
+			else
+				return false;
+		}
+		else if (rm &amp;&amp; !gm &amp;&amp; !bm &amp;&amp; !am)
+		{
+			format = CL_RED;
+			if (rms != 0 || !bits_to_type.count(rmb))
+				return false;
+			if (pf.get_depth() != rmb)
+				return false;
+			type = bits_to_type[rmb];
+		}
+		else if (!rm &amp;&amp; gm &amp;&amp; !bm &amp;&amp; !am)
+		{
+			format = CL_GREEN;
+			if (gms != 0 || !bits_to_type.count(gmb))
+				return false;
+			if (pf.get_depth() != gmb)
+				return false;
+			type = bits_to_type[gmb];
+		}
+		else if (!rm &amp;&amp; !gm &amp;&amp; bm &amp;&amp; !am)
+		{
+			format = CL_BLUE;
+			if (bms != 0 || !bits_to_type.count(bmb))
+				return false;
+			if (pf.get_depth() != bmb)
+				return false;
+			type = bits_to_type[bmb];
+		}
+		else if (!rm &amp;&amp; !gm &amp;&amp; !bm &amp;&amp; am)
+		{
+			format = CL_ALPHA;
+			if (ams != 0 || !bits_to_type.count(amb))
+				return false;
+			if (pf.get_depth() != amb)
+				return false;
+			type = bits_to_type[amb];
+		}
+		else
+			return false;
+	}
+	else
+		return false;
+
+	return true;
+}

Added: trunk/clanlib/GL/opengl_state.cpp
===================================================================
--- trunk/clanlib/GL/opengl_state.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/opengl_state.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,101 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/GL/opengl_state.h&quot;
+#include &quot;opengl_state_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLState construction:
+
+CL_OpenGLState::CL_OpenGLState()
+{
+}
+
+CL_OpenGLState::CL_OpenGLState(CL_GraphicContext *gc)
+: impl(new CL_OpenGLState_Generic(gc))
+{
+}
+
+CL_OpenGLState::CL_OpenGLState(CL_GraphicContext_OpenGL *gc_opengl)
+: impl(new CL_OpenGLState_Generic(gc_opengl))
+{
+}
+
+CL_OpenGLState::CL_OpenGLState(const CL_OpenGLState &amp;copy) : impl(copy.impl)
+{
+}
+
+CL_OpenGLState::~CL_OpenGLState()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLState attributes:
+
+bool CL_OpenGLState::is_active() const
+{
+	return impl-&gt;is_active();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLState operations:
+
+void CL_OpenGLState::set_active()
+{
+	if (impl) impl-&gt;set_active();
+}
+
+void CL_OpenGLState::attach_data(CL_OpenGLStateData *data, bool delete_data)
+{
+	if (impl) impl-&gt;data_objects.push_back(std::pair&lt;CL_OpenGLStateData *, bool&gt;(data, delete_data));
+}
+
+void CL_OpenGLState::detach_data(CL_OpenGLStateData *data)
+{
+	if (impl == 0) return;
+
+	std::list&lt; std::pair&lt;CL_OpenGLStateData *, bool&gt; &gt;::iterator it;
+	for (it = impl-&gt;data_objects.begin(); it != impl-&gt;data_objects.end(); ++it)
+	{
+		if ((*it).first == data)
+		{
+			impl-&gt;data_objects.erase(it);
+			return;
+		}
+	}
+}
+
+void CL_OpenGLState::setup_2d(bool upside_down)
+{
+	impl-&gt;setup_2d(upside_down);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLState implementation:

Added: trunk/clanlib/GL/opengl_state_data.cpp
===================================================================
--- trunk/clanlib/GL/opengl_state_data.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/opengl_state_data.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,51 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/GL/opengl_state_data.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLStateData construction:
+
+CL_OpenGLStateData::CL_OpenGLStateData() : impl(0)
+{
+}
+
+CL_OpenGLStateData::~CL_OpenGLStateData()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLStateData attributes:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLStateData operations:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLStateData implementation:

Added: trunk/clanlib/GL/opengl_state_generic.cpp
===================================================================
--- trunk/clanlib/GL/opengl_state_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/opengl_state_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,1842 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;opengl_state_generic.h&quot;
+#include &quot;API/Display/graphic_context.h&quot;
+#include &quot;API/GL/opengl_state_data.h&quot;
+#include &quot;API/GL/opengl.h&quot;
+#include &quot;API/GL/opengl_wrap.h&quot;
+#include &quot;graphic_context_opengl.h&quot;
+#ifdef __APPLE__
+#include &lt;AGL/agl.h&gt;
+#include &lt;OpenGL/glu.h&gt;
+#else
+#include &lt;GL/glu.h&gt;
+#endif
+
+#include &lt;map&gt;
+
+#define cl_pixelcenter_constant 0.375
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLState_Generic construction:
+
+CL_OpenGLState_Generic::CL_OpenGLState_Generic(CL_GraphicContext *gc)
+: gc_opengl((CL_GraphicContext_OpenGL *) gc-&gt;impl), in_2d(false), is_upside_down(false), need_update_viewport(false)
+{
+	init();
+}
+
+CL_OpenGLState_Generic::CL_OpenGLState_Generic(CL_GraphicContext_OpenGL *gc_opengl)
+: gc_opengl(gc_opengl), in_2d(false), is_upside_down(false), need_update_viewport(false)
+{
+	init();
+}
+
+CL_OpenGLState_Generic::~CL_OpenGLState_Generic()
+{
+	if (active_state == this)
+	{
+		save();
+		active_state = 0;
+		#ifdef WIN32
+			set_context(gc_opengl-&gt;get_drawable(), 0);
+		#else
+		#ifdef __APPLE__
+			set_context(0);
+		#else
+			set_context(gc_opengl-&gt;get_display(), 0, 0);
+		#endif
+		#endif
+	}
+
+	std::list&lt; std::pair&lt;CL_OpenGLStateData *, bool&gt; &gt;::iterator it;
+	for (it = data_objects.begin(); it != data_objects.end(); ++it)
+	{
+		if ((*it).second) delete (*it).first;
+	}
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLState_Generic attributes:
+
+bool CL_OpenGLState_Generic::is_active() const
+{
+	return (active_state == this);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLState_Generic operations:
+
+void CL_OpenGLState_Generic::set_active()
+{
+	if (active_state == this) return;
+
+	// Cannot be made active yet. Throw exception instead?
+	if (gc_opengl-&gt;get_context() == 0) return;
+
+	if (active_state) active_state-&gt;save();
+	#ifdef WIN32
+		set_context(gc_opengl-&gt;get_drawable(), gc_opengl-&gt;get_context());
+	#else
+	#ifdef __APPLE__
+		set_context(gc_opengl-&gt;get_context());
+	#else
+		set_context(gc_opengl-&gt;get_display(), gc_opengl-&gt;get_drawable(), gc_opengl-&gt;get_context());
+	#endif
+	#endif
+	active_state = this;
+	active_state-&gt;load();
+}
+
+void CL_OpenGLState_Generic::setup_2d(bool upside_down)
+{
+	set_active();
+
+	in_2d = true;
+	is_upside_down = upside_down;
+
+	clMatrixMode(CL_PROJECTION);
+	clLoadIdentity();
+
+	CLdouble viewport[4];
+	clGetDoublev(CL_VIEWPORT, viewport);
+
+	CLdouble width = viewport[2];
+	CLdouble height = viewport[3];
+	if (upside_down) 
+		glOrtho(0, width, 0., height, -1000.0, 1000.0);
+	else
+		glOrtho(0.0, width, height, 0.0, -1000.0, 1000.0);
+
+	clMatrixMode(CL_MODELVIEW);
+	clLoadIdentity();
+	clTranslated(cl_pixelcenter_constant, cl_pixelcenter_constant, 0.0);
+	clMultMatrixd(gc_opengl-&gt;get_modelview());
+
+	clEnable(CL_SCISSOR_TEST);
+	on_update_scissor();
+
+//	if (surface_target) on_resize((int)width, (int)height);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLState_Generic implementation:
+
+void CL_OpenGLState_Generic::init()
+{
+	slots.connect(gc_opengl-&gt;sig_update_scissor, this, &amp;CL_OpenGLState_Generic::on_update_scissor);
+	slots.connect(gc_opengl-&gt;sig_update_modelview, this, &amp;CL_OpenGLState_Generic::on_update_modelview);
+	slots.connect(gc_opengl-&gt;sig_update_viewport, this, &amp;CL_OpenGLState_Generic::on_update_viewport);
+
+	state_texture_2d = CL_FALSE;
+	state_bind_texture_2d = 0;
+	state_blend = CL_FALSE;
+	state_fog = CL_FALSE;
+	state_depth_test = CL_FALSE;
+	state_scissor_test = CL_FALSE;
+	memset(state_viewport, 0, sizeof(CLint)*4);
+	memset(state_scissor_box, 0, sizeof(CLint)*4);
+	memset(state_clear_color, 0, sizeof(CLdouble)*4);
+	state_blendfunc_sfactor       = CL_ZERO;
+	state_blendfunc_dfactor       = CL_ZERO;
+	state_blendfunc_sfactor_alpha = CL_ZERO;
+	state_blendfunc_dfactor_alpha = CL_ZERO;
+	state_color[0] = 1.0;
+	state_color[1] = 1.0;
+	state_color[2] = 1.0;
+	state_color[3] = 1.0;
+	state_vertex_pointer_size = 0;
+	state_vertex_pointer_type = 0;
+	state_vertex_pointer_stride = 0;
+	state_vertex_pointer = 0;
+	state_color_pointer_size = 0;
+	state_color_pointer_type = 0;
+	state_color_pointer_stride = 0;
+	state_color_pointer = 0;
+	state_texcoord_pointer_size = 0;
+	state_texcoord_pointer_type = 0;
+	state_texcoord_pointer_stride = 0;
+	state_texcoord_pointer = 0;
+	state_vertex_array = CL_FALSE;
+	state_color_array = CL_FALSE;
+	state_texture_coord_array = CL_FALSE;
+	memset(state_matrix_texture, 0, sizeof(CLdouble)*16);
+	memset(state_matrix_projection, 0, sizeof(CLdouble)*16);
+	memset(state_matrix_modelview, 0, sizeof(CLdouble)*16);
+	state_matrix_texture[0] = 1.0;
+	state_matrix_texture[5] = 1.0;
+	state_matrix_texture[10] = 1.0;
+	state_matrix_texture[15] = 1.0;
+	state_matrix_projection[0] = 1.0;
+	state_matrix_projection[5] = 1.0;
+	state_matrix_projection[10] = 1.0;
+	state_matrix_projection[15] = 1.0;
+	state_matrix_modelview[0] = 1.0;
+	state_matrix_modelview[5] = 1.0;
+	state_matrix_modelview[10] = 1.0;
+	state_matrix_modelview[15] = 1.0;
+	state_matrix_mode = CL_MODELVIEW;
+	state_texture_env_mode = CL_MODULATE;
+	state_stencil_test = CL_FALSE;
+	state_stencil_func = CL_LEQUAL;
+	state_stencil_value_mask = 0;
+	state_stencil_ref = 0;
+	state_stencil_fail = CL_KEEP;
+	state_stencil_pass_depth_pass = CL_KEEP;
+	state_stencil_pass_depth_fail = CL_KEEP;
+	state_alpha_test = CL_FALSE;
+	state_alpha_test_func = CL_GEQUAL;
+	state_alpha_test_ref = 0.0;
+	state_polygon_mode[0] = CL_FRONT_AND_BACK;
+	state_polygon_mode[1] = CL_FILL;
+	memset(state_color_write_mask, 1, sizeof(CLboolean)*4);
+}
+
+void CL_OpenGLState_Generic::on_update_scissor()
+{
+	if (is_active() == false) return;
+	flush();
+
+	CLdouble viewport[4];
+	clGetDoublev(CL_VIEWPORT, viewport);
+
+	//CLdouble &amp;viewport_width  = viewport[2];
+	CLdouble &amp;viewport_height = viewport[3];
+
+	const CL_Rect &amp;clip = gc_opengl-&gt;get_cliprect();
+	int clip_width  = clip.get_width();
+	int clip_height = clip.get_height();
+
+	clScissor(clip.left, static_cast&lt;int&gt;(viewport_height - clip.top - clip_height), clip_width, clip_height);
+}
+
+void CL_OpenGLState_Generic::on_update_modelview()
+{
+	if (is_active() == false) return;
+	if (in_2d)
+	{
+		flush();
+		clLoadIdentity();
+		clTranslated(cl_pixelcenter_constant, cl_pixelcenter_constant, 0.0);
+		clMultMatrixd(gc_opengl-&gt;get_modelview());
+	}
+}
+
+void CL_OpenGLState_Generic::on_update_viewport()
+{
+	if (is_active() == false) return;
+	need_update_viewport = false;
+
+	CLint width = (CLint) gc_opengl-&gt;get_width();
+	CLint height = (CLint) gc_opengl-&gt;get_height();
+	clViewport(0, 0, width ,height );
+
+	if (in_2d)
+	{
+		on_update_scissor();
+
+		clMatrixMode(CL_PROJECTION);
+		clLoadIdentity();
+		if (is_upside_down)
+			glOrtho(0.0, width, 0.0, height, -1000.0, 1000.0);
+		else
+			glOrtho(0.0, width, height, 0.0, -1000.0, 1000.0);
+		clMatrixMode(CL_MODELVIEW);
+	}
+}
+
+void CL_OpenGLState_Generic::flush()
+{
+	std::list&lt; std::pair&lt;CL_OpenGLStateData *, bool&gt; &gt;::iterator it;
+	for (it = data_objects.begin(); it != data_objects.end(); ++it)
+	{
+		(*it).first-&gt;on_flush();
+	}
+}
+
+void CL_OpenGLState_Generic::save()
+{
+	std::list&lt; std::pair&lt;CL_OpenGLStateData *, bool&gt; &gt;::reverse_iterator it;
+	for (it = data_objects.rbegin(); it != data_objects.rend(); ++it)
+	{
+		(*it).first-&gt;on_save();
+	}
+
+	if (in_2d)
+	{
+		// todo: save 2d states.
+	}
+
+	state_texture_2d = clIsEnabled(CL_TEXTURE_2D);
+	clGetIntegerv(CL_TEXTURE_2D_BINDING, &amp;state_bind_texture_2d);
+	state_blend = clIsEnabled(CL_BLEND);
+	state_fog = clIsEnabled(CL_FOG);
+	state_depth_test = clIsEnabled(CL_DEPTH_TEST);
+	state_scissor_test = clIsEnabled(CL_SCISSOR_TEST);
+	clGetIntegerv(CL_VIEWPORT, state_viewport);
+	clGetIntegerv(CL_SCISSOR_BOX, state_scissor_box);
+	clGetDoublev(CL_COLOR_CLEAR_VALUE, state_clear_color);
+
+	clGetIntegerv(CL_BLEND_SRC,       &amp;state_blendfunc_sfactor);
+	clGetIntegerv(CL_BLEND_DST,       &amp;state_blendfunc_dfactor);
+	clGetIntegerv(CL_BLEND_SRC_ALPHA, &amp;state_blendfunc_sfactor_alpha);
+	clGetIntegerv(CL_BLEND_DST_ALPHA, &amp;state_blendfunc_dfactor_alpha);
+
+	clGetDoublev(CL_CURRENT_COLOR, state_color);
+	clGetIntegerv(CL_VERTEX_ARRAY_SIZE, &amp;state_vertex_pointer_size);
+	clGetIntegerv(CL_VERTEX_ARRAY_TYPE, &amp;state_vertex_pointer_type);
+	clGetIntegerv(CL_VERTEX_ARRAY_STRIDE, &amp;state_vertex_pointer_stride);
+	clGetPointerv(CL_VERTEX_ARRAY_POINTER, &amp;state_vertex_pointer);
+	clGetIntegerv(CL_COLOR_ARRAY_SIZE, &amp;state_color_pointer_size);
+	clGetIntegerv(CL_COLOR_ARRAY_TYPE, &amp;state_color_pointer_type);
+	clGetIntegerv(CL_COLOR_ARRAY_STRIDE, &amp;state_color_pointer_stride);
+	clGetPointerv(CL_COLOR_ARRAY_POINTER, &amp;state_color_pointer);
+	clGetIntegerv(CL_TEXTURE_COORD_ARRAY_SIZE, &amp;state_texcoord_pointer_size);
+	clGetIntegerv(CL_TEXTURE_COORD_ARRAY_TYPE, &amp;state_texcoord_pointer_type);
+	clGetIntegerv(CL_TEXTURE_COORD_ARRAY_STRIDE, &amp;state_texcoord_pointer_stride);
+	clGetPointerv(CL_TEXTURE_COORD_ARRAY_POINTER, &amp;state_texcoord_pointer);
+	state_vertex_array = clIsEnabled(CL_VERTEX_ARRAY);
+	state_color_array = clIsEnabled(CL_COLOR_ARRAY);
+	state_texture_coord_array = clIsEnabled(CL_TEXTURE_COORD_ARRAY);
+	clGetIntegerv(CL_MATRIX_MODE, &amp;state_matrix_mode);
+	clGetDoublev(CL_TEXTURE_MATRIX, state_matrix_texture);
+	clGetDoublev(CL_PROJECTION_MATRIX, state_matrix_projection);
+	clGetDoublev(CL_MODELVIEW_MATRIX, state_matrix_modelview);
+	clGetTexEnvfv(CL_TEXTURE_ENV, CL_TEXTURE_ENV_MODE, &amp;state_texture_env_mode);
+	state_stencil_test = clIsEnabled(CL_STENCIL_TEST);
+	clGetIntegerv(CL_STENCIL_VALUE_MASK, &amp;state_stencil_value_mask);
+	clGetIntegerv(CL_STENCIL_REF, &amp;state_stencil_ref);
+	clGetIntegerv(CL_STENCIL_FUNC, &amp;state_stencil_func);
+	clGetIntegerv(CL_STENCIL_FAIL, &amp;state_stencil_fail);
+	clGetIntegerv(CL_STENCIL_PASS_DEPTH_PASS, &amp;state_stencil_pass_depth_pass);
+	clGetIntegerv(CL_STENCIL_PASS_DEPTH_FAIL, &amp;state_stencil_pass_depth_fail);
+	state_alpha_test = clIsEnabled(CL_ALPHA_TEST);
+	clGetIntegerv(CL_ALPHA_TEST_FUNC, &amp;state_alpha_test_func);
+	clGetDoublev(CL_ALPHA_TEST_REF, &amp;state_alpha_test_ref);
+	clGetBooleanv(CL_COLOR_WRITEMASK, state_color_write_mask);
+	clGetIntegerv(CL_POLYGON_MODE, state_polygon_mode);
+}
+
+void CL_OpenGLState_Generic::load()
+{
+	// Make sure context exists
+	if (CL_OpenGL::functions == 0) 
+		return;
+
+	// If there's no viewport, set it up.
+	if (state_viewport[0] == 0 &amp;&amp; state_viewport[1] == 0 &amp;&amp; state_viewport[2] == 0 &amp;&amp; state_viewport[3] == 0)
+	{
+		state_viewport[2] = gc_opengl-&gt;get_width();
+		state_viewport[3] = gc_opengl-&gt;get_height();
+	}
+
+	if (state_texture_2d) clEnable(CL_TEXTURE_2D); else clDisable(CL_TEXTURE_2D);
+	if (state_texture_2d &amp;&amp; state_bind_texture_2d) clBindTexture(CL_TEXTURE_2D, state_bind_texture_2d);
+	if (state_blend) clEnable(CL_BLEND); else clDisable(CL_BLEND);
+	if (state_fog) clEnable(CL_FOG); else clDisable(CL_FOG);
+	if (state_depth_test) clEnable(CL_DEPTH_TEST); else clDisable(CL_DEPTH_TEST);
+	if (state_scissor_test) clEnable(CL_SCISSOR_TEST); else clDisable(CL_SCISSOR_TEST);
+	clViewport(state_viewport[0], state_viewport[1], state_viewport[2], state_viewport[3]);
+	clScissor(state_scissor_box[0], state_scissor_box[1], state_scissor_box[2], state_scissor_box[3]);
+	clClearColor((GLclampf) state_clear_color[0], (GLclampf) state_clear_color[1], (GLclampf) state_clear_color[2], (GLclampf) state_clear_color[3]);
+
+	if ( !clBlendFuncSeparate ||
+		 (state_blendfunc_sfactor == state_blendfunc_sfactor_alpha &amp;&amp;
+		  state_blendfunc_dfactor == state_blendfunc_dfactor_alpha) )
+	{
+		clBlendFunc(state_blendfunc_sfactor, state_blendfunc_dfactor);
+	}
+	else
+	{
+		clBlendFuncSeparate(state_blendfunc_sfactor, state_blendfunc_dfactor, state_blendfunc_sfactor_alpha, state_blendfunc_dfactor_alpha);
+	}
+
+	clColor4dv(state_color);
+	if (state_vertex_pointer) clVertexPointer(state_vertex_pointer_size, state_vertex_pointer_type, state_vertex_pointer_stride, state_vertex_pointer);
+	if (state_color_pointer) clColorPointer(state_color_pointer_size, state_color_pointer_type, state_color_pointer_stride, state_color_pointer);
+	if (state_texcoord_pointer) clTexCoordPointer(state_texcoord_pointer_size, state_texcoord_pointer_type, state_texcoord_pointer_stride, state_texcoord_pointer);
+	if (state_vertex_array) clEnableClientState(CL_VERTEX_ARRAY); else clDisableClientState(CL_VERTEX_ARRAY);
+	if (state_color_array) clEnableClientState(CL_COLOR_ARRAY); else clDisableClientState(CL_COLOR_ARRAY);
+	if (state_texture_coord_array) clEnableClientState(CL_TEXTURE_COORD_ARRAY); else clDisableClientState(CL_TEXTURE_COORD_ARRAY);
+
+	clMatrixMode(CL_TEXTURE);
+	clLoadMatrixd(state_matrix_texture);
+	clMatrixMode(CL_PROJECTION);
+	clLoadMatrixd(state_matrix_projection);
+	clMatrixMode(CL_MODELVIEW);
+	clLoadMatrixd(state_matrix_modelview);
+	clMatrixMode(state_matrix_mode);
+	clTexEnvf(CL_TEXTURE_ENV, CL_TEXTURE_ENV_MODE, state_texture_env_mode);
+
+	if (state_stencil_test) clEnable(CL_STENCIL_TEST); else clDisable(CL_STENCIL_TEST);
+	clStencilFunc(state_stencil_func, state_stencil_ref, state_stencil_value_mask);
+	clStencilOp(state_stencil_fail,state_stencil_pass_depth_fail,state_stencil_pass_depth_pass);
+	if (state_alpha_test) clEnable(CL_ALPHA_TEST); else clDisable(CL_ALPHA_TEST);
+	clAlphaFunc(state_alpha_test_func, state_alpha_test_ref);
+	clColorMask(state_color_write_mask[0],state_color_write_mask[1],state_color_write_mask[2],state_color_write_mask[3]);
+
+	clPolygonMode(CL_FRONT_AND_BACK, state_polygon_mode[1]);
+
+	if (need_update_viewport) on_update_viewport();
+	if (in_2d) setup_2d(is_upside_down);
+
+	std::list&lt; std::pair&lt;CL_OpenGLStateData *, bool&gt; &gt;::iterator it;
+	for (it = data_objects.begin(); it != data_objects.end(); ++it)
+	{
+		(*it).first-&gt;on_load();
+	}
+}
+
+#ifdef WIN32
+
+void CL_OpenGLState_Generic::set_context(HDC hdc, HGLRC context)
+{
+	if (cur_drawable != hdc &amp;&amp; cur_context != context)
+	{
+		wglMakeCurrent(hdc, context);
+		cur_drawable = hdc;
+		cur_context = context;
+
+		std::map&lt;std::pair&lt;HDC, HGLRC&gt;, CL_GLFunctions *&gt;::iterator it;
+		it = function_map.find(std::pair&lt;HDC, HGLRC&gt;(hdc, context));
+		if (it == function_map.end())
+		{
+			CL_GLFunctions *functions = setup_binds();
+			function_map[std::pair&lt;HDC, HGLRC&gt;(hdc, context)] = functions;
+			CL_OpenGL::functions = functions;
+		}
+		else
+		{
+			CL_OpenGL::functions = it-&gt;second;
+		}
+	}
+}
+
+#else
+#ifdef __APPLE__
+
+void CL_OpenGLState_Generic::set_context(AGLContext context)
+{
+	if (cur_context != context)
+	{
+		aglSetCurrentContext(context);
+		cur_context = context;
+
+		std::map&lt;AGLContext, CL_GLFunctions *&gt;::iterator it;
+		it = function_map.find(context);
+		if (it == function_map.end())
+		{
+			CL_GLFunctions *functions = setup_binds();
+			function_map[context] = functions;
+			CL_OpenGL::functions = functions;
+		}
+		else
+		{
+			CL_OpenGL::functions = it-&gt;second;
+		}
+	}
+}
+
+#else
+
+void CL_OpenGLState_Generic::set_context(Display *disp, GLXDrawable drawable, GLXContext context)
+{
+	if (disp == 0)
+		return;
+
+	if (cur_drawable != drawable &amp;&amp; cur_context != context)
+	{
+		glXMakeCurrent(disp, drawable, context);
+		cur_drawable = drawable;
+		cur_context = context;
+
+		std::map&lt;std::pair&lt;GLXDrawable, GLXContext&gt;, CL_GLFunctions *&gt;::iterator it;
+		it = function_map.find(std::pair&lt;GLXDrawable, GLXContext&gt;(drawable, context));
+		if (it == function_map.end())
+		{
+			CL_GLFunctions *functions = setup_binds();
+			function_map[std::pair&lt;GLXDrawable, GLXContext&gt;(drawable, context)] = functions;
+			CL_OpenGL::functions = functions;
+		}
+		else
+		{
+			CL_OpenGL::functions = it-&gt;second;
+		}
+	}
+}
+
+#endif
+#endif
+
+void CL_OpenGLState_Generic::clear_context (void)
+{
+	while (!function_map.empty())
+	{
+		delete function_map.begin()-&gt;second;
+		function_map.erase(function_map.begin());
+	}
+	CL_OpenGL::functions = 0;
+}
+
+#ifdef WIN32
+	HDC CL_OpenGLState_Generic::cur_drawable = 0;
+
+	HGLRC CL_OpenGLState_Generic::cur_context = 0;
+
+	std::map&lt;std::pair&lt;HDC, HGLRC&gt;, CL_GLFunctions *&gt; CL_OpenGLState_Generic::function_map;
+#else
+#ifdef __APPLE__
+	AGLContext CL_OpenGLState_Generic::cur_context = 0;
+	
+	std::map&lt;AGLContext, CL_GLFunctions *&gt; CL_OpenGLState_Generic::function_map;
+#else
+	GLXDrawable CL_OpenGLState_Generic::cur_drawable = 0;
+
+	GLXContext CL_OpenGLState_Generic::cur_context = 0;
+
+	std::map&lt;std::pair&lt;GLXDrawable, GLXContext&gt;, CL_GLFunctions *&gt; CL_OpenGLState_Generic::function_map;
+#endif
+#endif
+
+CL_OpenGLState_Generic *CL_OpenGLState_Generic::active_state = 0;
+
+CL_GLFunctions *CL_OpenGLState_Generic::setup_binds()
+{
+	CL_GLFunctions *functions = new CL_GLFunctions;
+	memset(functions, 0, sizeof(CL_GLFunctions));
+
+	// Binds for OpenGL 1.1:
+
+#ifdef GL_VERSION_1_1
+	functions-&gt;accum = (CL_GLFunctions::ptr_glAccum) &glAccum;
+	functions-&gt;alphaFunc = (CL_GLFunctions::ptr_glAlphaFunc) &glAlphaFunc;
+	functions-&gt;areTexturesResident = (CL_GLFunctions::ptr_glAreTexturesResident) &glAreTexturesResident;
+	functions-&gt;arrayElement = (CL_GLFunctions::ptr_glArrayElement) &glArrayElement;
+	functions-&gt;begin = (CL_GLFunctions::ptr_glBegin) &glBegin;
+	functions-&gt;bindTexture = (CL_GLFunctions::ptr_glBindTexture) &glBindTexture;
+	functions-&gt;bitmap = (CL_GLFunctions::ptr_glBitmap) &glBitmap;
+	functions-&gt;blendFunc = (CL_GLFunctions::ptr_glBlendFunc) &glBlendFunc;
+	functions-&gt;callList = (CL_GLFunctions::ptr_glCallList) &glCallList;
+	functions-&gt;callLists = (CL_GLFunctions::ptr_glCallLists) &glCallLists;
+	functions-&gt;clear = (CL_GLFunctions::ptr_glClear) &glClear;
+	functions-&gt;clearAccum = (CL_GLFunctions::ptr_glClearAccum) &glClearAccum;
+	functions-&gt;clearColor = (CL_GLFunctions::ptr_glClearColor) &glClearColor;
+	functions-&gt;clearDepth = (CL_GLFunctions::ptr_glClearDepth) &glClearDepth;
+	functions-&gt;clearIndex = (CL_GLFunctions::ptr_glClearIndex) &glClearIndex;
+	functions-&gt;clearStencil = (CL_GLFunctions::ptr_glClearStencil) &glClearStencil;
+	functions-&gt;clipPlane = (CL_GLFunctions::ptr_glClipPlane) &glClipPlane;
+	functions-&gt;color3b = (CL_GLFunctions::ptr_glColor3b) &amp;glColor3b;
+	functions-&gt;color3bv = (CL_GLFunctions::ptr_glColor3bv) &amp;glColor3bv;
+	functions-&gt;color3d = (CL_GLFunctions::ptr_glColor3d) &amp;glColor3d;
+	functions-&gt;color3dv = (CL_GLFunctions::ptr_glColor3dv) &amp;glColor3dv;
+	functions-&gt;color3f = (CL_GLFunctions::ptr_glColor3f) &amp;glColor3f;
+	functions-&gt;color3fv = (CL_GLFunctions::ptr_glColor3fv) &amp;glColor3fv;
+	functions-&gt;color3i = (CL_GLFunctions::ptr_glColor3i) &amp;glColor3i;
+	functions-&gt;color3iv = (CL_GLFunctions::ptr_glColor3iv) &amp;glColor3iv;
+	functions-&gt;color3s = (CL_GLFunctions::ptr_glColor3s) &amp;glColor3s;
+	functions-&gt;color3sv = (CL_GLFunctions::ptr_glColor3sv) &amp;glColor3sv;
+	functions-&gt;color3ub = (CL_GLFunctions::ptr_glColor3ub) &amp;glColor3ub;
+	functions-&gt;color3ubv = (CL_GLFunctions::ptr_glColor3ubv) &amp;glColor3ubv;
+	functions-&gt;color3ui = (CL_GLFunctions::ptr_glColor3ui) &amp;glColor3ui;
+	functions-&gt;color3uiv = (CL_GLFunctions::ptr_glColor3uiv) &amp;glColor3uiv;
+	functions-&gt;color3us = (CL_GLFunctions::ptr_glColor3us) &amp;glColor3us;
+	functions-&gt;color3usv = (CL_GLFunctions::ptr_glColor3usv) &amp;glColor3usv;
+	functions-&gt;color4b = (CL_GLFunctions::ptr_glColor4b) &amp;glColor4b;
+	functions-&gt;color4bv = (CL_GLFunctions::ptr_glColor4bv) &amp;glColor4bv;
+	functions-&gt;color4d = (CL_GLFunctions::ptr_glColor4d) &amp;glColor4d;
+	functions-&gt;color4dv = (CL_GLFunctions::ptr_glColor4dv) &amp;glColor4dv;
+	functions-&gt;color4f = (CL_GLFunctions::ptr_glColor4f) &amp;glColor4f;
+	functions-&gt;color4fv = (CL_GLFunctions::ptr_glColor4fv) &amp;glColor4fv;
+	functions-&gt;color4i = (CL_GLFunctions::ptr_glColor4i) &amp;glColor4i;
+	functions-&gt;color4iv = (CL_GLFunctions::ptr_glColor4iv) &amp;glColor4iv;
+	functions-&gt;color4s = (CL_GLFunctions::ptr_glColor4s) &amp;glColor4s;
+	functions-&gt;color4sv = (CL_GLFunctions::ptr_glColor4sv) &amp;glColor4sv;
+	functions-&gt;color4ub = (CL_GLFunctions::ptr_glColor4ub) &amp;glColor4ub;
+	functions-&gt;color4ubv = (CL_GLFunctions::ptr_glColor4ubv) &amp;glColor4ubv;
+	functions-&gt;color4ui = (CL_GLFunctions::ptr_glColor4ui) &amp;glColor4ui;
+	functions-&gt;color4uiv = (CL_GLFunctions::ptr_glColor4uiv) &amp;glColor4uiv;
+	functions-&gt;color4us = (CL_GLFunctions::ptr_glColor4us) &amp;glColor4us;
+	functions-&gt;color4usv = (CL_GLFunctions::ptr_glColor4usv) &amp;glColor4usv;
+	functions-&gt;colorMask = (CL_GLFunctions::ptr_glColorMask) &glColorMask;
+	functions-&gt;colorMaterial = (CL_GLFunctions::ptr_glColorMaterial) &glColorMaterial;
+	functions-&gt;colorPointer = (CL_GLFunctions::ptr_glColorPointer) &glColorPointer;
+	functions-&gt;copyPixels = (CL_GLFunctions::ptr_glCopyPixels) &glCopyPixels;
+	functions-&gt;copyTexImage1D = (CL_GLFunctions::ptr_glCopyTexImage1D) &amp;glCopyTexImage1D;
+	functions-&gt;copyTexImage2D = (CL_GLFunctions::ptr_glCopyTexImage2D) &amp;glCopyTexImage2D;
+	functions-&gt;copyTexSubImage1D = (CL_GLFunctions::ptr_glCopyTexSubImage1D) &amp;glCopyTexSubImage1D;
+	functions-&gt;copyTexSubImage2D = (CL_GLFunctions::ptr_glCopyTexSubImage2D) &amp;glCopyTexSubImage2D;
+	functions-&gt;cullFace = (CL_GLFunctions::ptr_glCullFace) &glCullFace;
+	functions-&gt;deleteLists = (CL_GLFunctions::ptr_glDeleteLists) &glDeleteLists;
+	functions-&gt;deleteTextures = (CL_GLFunctions::ptr_glDeleteTextures) &glDeleteTextures;
+	functions-&gt;depthFunc = (CL_GLFunctions::ptr_glDepthFunc) &glDepthFunc;
+	functions-&gt;depthMask = (CL_GLFunctions::ptr_glDepthMask) &glDepthMask;
+	functions-&gt;depthRange = (CL_GLFunctions::ptr_glDepthRange) &glDepthRange;
+	functions-&gt;disable = (CL_GLFunctions::ptr_glDisable) &glDisable;
+	functions-&gt;disableClientState = (CL_GLFunctions::ptr_glDisableClientState) &glDisableClientState;
+	functions-&gt;drawArrays = (CL_GLFunctions::ptr_glDrawArrays) &glDrawArrays;
+	functions-&gt;drawBuffer = (CL_GLFunctions::ptr_glDrawBuffer) &glDrawBuffer;
+	functions-&gt;drawElements = (CL_GLFunctions::ptr_glDrawElements) &glDrawElements;
+	functions-&gt;drawPixels = (CL_GLFunctions::ptr_glDrawPixels) &glDrawPixels;
+	functions-&gt;edgeFlag = (CL_GLFunctions::ptr_glEdgeFlag) &glEdgeFlag;
+	functions-&gt;edgeFlagPointer = (CL_GLFunctions::ptr_glEdgeFlagPointer) &glEdgeFlagPointer;
+	functions-&gt;edgeFlagv = (CL_GLFunctions::ptr_glEdgeFlagv) &glEdgeFlagv;
+	functions-&gt;enable = (CL_GLFunctions::ptr_glEnable) &glEnable;
+	functions-&gt;enableClientState = (CL_GLFunctions::ptr_glEnableClientState) &glEnableClientState;
+	functions-&gt;end = (CL_GLFunctions::ptr_glEnd) &glEnd;
+	functions-&gt;endList = (CL_GLFunctions::ptr_glEndList) &glEndList;
+	functions-&gt;evalCoord1d = (CL_GLFunctions::ptr_glEvalCoord1d) &amp;glEvalCoord1d;
+	functions-&gt;evalCoord1dv = (CL_GLFunctions::ptr_glEvalCoord1dv) &amp;glEvalCoord1dv;
+	functions-&gt;evalCoord1f = (CL_GLFunctions::ptr_glEvalCoord1f) &amp;glEvalCoord1f;
+	functions-&gt;evalCoord1fv = (CL_GLFunctions::ptr_glEvalCoord1fv) &amp;glEvalCoord1fv;
+	functions-&gt;evalCoord2d = (CL_GLFunctions::ptr_glEvalCoord2d) &amp;glEvalCoord2d;
+	functions-&gt;evalCoord2dv = (CL_GLFunctions::ptr_glEvalCoord2dv) &amp;glEvalCoord2dv;
+	functions-&gt;evalCoord2f = (CL_GLFunctions::ptr_glEvalCoord2f) &amp;glEvalCoord2f;
+	functions-&gt;evalCoord2fv = (CL_GLFunctions::ptr_glEvalCoord2fv) &amp;glEvalCoord2fv;
+	functions-&gt;evalMesh1 = (CL_GLFunctions::ptr_glEvalMesh1) &amp;glEvalMesh1;
+	functions-&gt;evalMesh2 = (CL_GLFunctions::ptr_glEvalMesh2) &amp;glEvalMesh2;
+	functions-&gt;evalPoint1 = (CL_GLFunctions::ptr_glEvalPoint1) &amp;glEvalPoint1;
+	functions-&gt;evalPoint2 = (CL_GLFunctions::ptr_glEvalPoint2) &amp;glEvalPoint2;
+	functions-&gt;feedbackBuffer = (CL_GLFunctions::ptr_glFeedbackBuffer) &glFeedbackBuffer;
+	functions-&gt;finish = (CL_GLFunctions::ptr_glFinish) &glFinish;
+	functions-&gt;flush = (CL_GLFunctions::ptr_glFlush) &glFlush;
+	functions-&gt;fogf = (CL_GLFunctions::ptr_glFogf) &glFogf;
+	functions-&gt;fogfv = (CL_GLFunctions::ptr_glFogfv) &glFogfv;
+	functions-&gt;fogi = (CL_GLFunctions::ptr_glFogi) &glFogi;
+	functions-&gt;fogiv = (CL_GLFunctions::ptr_glFogiv) &glFogiv;
+	functions-&gt;frontFace = (CL_GLFunctions::ptr_glFrontFace) &glFrontFace;
+	functions-&gt;frustum = (CL_GLFunctions::ptr_glFrustum) &glFrustum;
+	functions-&gt;genLists = (CL_GLFunctions::ptr_glGenLists) &glGenLists;
+	functions-&gt;genTextures = (CL_GLFunctions::ptr_glGenTextures) &glGenTextures;
+	functions-&gt;getBooleanv = (CL_GLFunctions::ptr_glGetBooleanv) &glGetBooleanv;
+	functions-&gt;getClipPlane = (CL_GLFunctions::ptr_glGetClipPlane) &glGetClipPlane;
+	functions-&gt;getDoublev = (CL_GLFunctions::ptr_glGetDoublev) &glGetDoublev;
+	functions-&gt;getError = (CL_GLFunctions::ptr_glGetError) &glGetError;
+	functions-&gt;getFloatv = (CL_GLFunctions::ptr_glGetFloatv) &glGetFloatv;
+	functions-&gt;getIntegerv = (CL_GLFunctions::ptr_glGetIntegerv) &glGetIntegerv;
+	functions-&gt;getLightfv = (CL_GLFunctions::ptr_glGetLightfv) &glGetLightfv;
+	functions-&gt;getLightiv = (CL_GLFunctions::ptr_glGetLightiv) &glGetLightiv;
+	functions-&gt;getMapdv = (CL_GLFunctions::ptr_glGetMapdv) &glGetMapdv;
+	functions-&gt;getMapfv = (CL_GLFunctions::ptr_glGetMapfv) &glGetMapfv;
+	functions-&gt;getMapiv = (CL_GLFunctions::ptr_glGetMapiv) &glGetMapiv;
+	functions-&gt;getMaterialfv = (CL_GLFunctions::ptr_glGetMaterialfv) &glGetMaterialfv;
+	functions-&gt;getMaterialiv = (CL_GLFunctions::ptr_glGetMaterialiv) &glGetMaterialiv;
+	functions-&gt;getPixelMapfv = (CL_GLFunctions::ptr_glGetPixelMapfv) &glGetPixelMapfv;
+	functions-&gt;getPixelMapuiv = (CL_GLFunctions::ptr_glGetPixelMapuiv) &glGetPixelMapuiv;
+	functions-&gt;getPixelMapusv = (CL_GLFunctions::ptr_glGetPixelMapusv) &glGetPixelMapusv;
+	functions-&gt;getPointerv = (CL_GLFunctions::ptr_glGetPointerv) &glGetPointerv;
+	functions-&gt;getPolygonStipple = (CL_GLFunctions::ptr_glGetPolygonStipple) &glGetPolygonStipple;
+	functions-&gt;getString = (CL_GLFunctions::ptr_glGetString) &glGetString;
+	functions-&gt;getTexEnvfv = (CL_GLFunctions::ptr_glGetTexEnvfv) &glGetTexEnvfv;
+	functions-&gt;getTexEnviv = (CL_GLFunctions::ptr_glGetTexEnviv) &glGetTexEnviv;
+	functions-&gt;getTexGendv = (CL_GLFunctions::ptr_glGetTexGendv) &glGetTexGendv;
+	functions-&gt;getTexGenfv = (CL_GLFunctions::ptr_glGetTexGenfv) &glGetTexGenfv;
+	functions-&gt;getTexGeniv = (CL_GLFunctions::ptr_glGetTexGeniv) &glGetTexGeniv;
+	functions-&gt;getTexImage = (CL_GLFunctions::ptr_glGetTexImage) &glGetTexImage;
+	functions-&gt;getTexLevelParameterfv = (CL_GLFunctions::ptr_glGetTexLevelParameterfv) &glGetTexLevelParameterfv;
+	functions-&gt;getTexLevelParameteriv = (CL_GLFunctions::ptr_glGetTexLevelParameteriv) &glGetTexLevelParameteriv;
+	functions-&gt;getTexParameterfv = (CL_GLFunctions::ptr_glGetTexParameterfv) &glGetTexParameterfv;
+	functions-&gt;getTexParameteriv = (CL_GLFunctions::ptr_glGetTexParameteriv) &glGetTexParameteriv;
+	functions-&gt;hint = (CL_GLFunctions::ptr_glHint) &glHint;
+	functions-&gt;indexMask = (CL_GLFunctions::ptr_glIndexMask) &glIndexMask;
+	functions-&gt;indexPointer = (CL_GLFunctions::ptr_glIndexPointer) &glIndexPointer;
+	functions-&gt;indexd = (CL_GLFunctions::ptr_glIndexd) &glIndexd;
+	functions-&gt;indexdv = (CL_GLFunctions::ptr_glIndexdv) &glIndexdv;
+	functions-&gt;indexf = (CL_GLFunctions::ptr_glIndexf) &glIndexf;
+	functions-&gt;indexfv = (CL_GLFunctions::ptr_glIndexfv) &glIndexfv;
+	functions-&gt;indexi = (CL_GLFunctions::ptr_glIndexi) &glIndexi;
+	functions-&gt;indexiv = (CL_GLFunctions::ptr_glIndexiv) &glIndexiv;
+	functions-&gt;indexs = (CL_GLFunctions::ptr_glIndexs) &glIndexs;
+	functions-&gt;indexsv = (CL_GLFunctions::ptr_glIndexsv) &glIndexsv;
+	functions-&gt;indexub = (CL_GLFunctions::ptr_glIndexub) &glIndexub;
+	functions-&gt;indexubv = (CL_GLFunctions::ptr_glIndexubv) &glIndexubv;
+	functions-&gt;initNames = (CL_GLFunctions::ptr_glInitNames) &glInitNames;
+	functions-&gt;interleavedArrays = (CL_GLFunctions::ptr_glInterleavedArrays) &glInterleavedArrays;
+	functions-&gt;isEnabled = (CL_GLFunctions::ptr_glIsEnabled) &glIsEnabled;
+	functions-&gt;isList = (CL_GLFunctions::ptr_glIsList) &glIsList;
+	functions-&gt;isTexture = (CL_GLFunctions::ptr_glIsTexture) &glIsTexture;
+	functions-&gt;lightModelf = (CL_GLFunctions::ptr_glLightModelf) &glLightModelf;
+	functions-&gt;lightModelfv = (CL_GLFunctions::ptr_glLightModelfv) &glLightModelfv;
+	functions-&gt;lightModeli = (CL_GLFunctions::ptr_glLightModeli) &glLightModeli;
+	functions-&gt;lightModeliv = (CL_GLFunctions::ptr_glLightModeliv) &glLightModeliv;
+	functions-&gt;lightf = (CL_GLFunctions::ptr_glLightf) &glLightf;
+	functions-&gt;lightfv = (CL_GLFunctions::ptr_glLightfv) &glLightfv;
+	functions-&gt;lighti = (CL_GLFunctions::ptr_glLighti) &glLighti;
+	functions-&gt;lightiv = (CL_GLFunctions::ptr_glLightiv) &glLightiv;
+	functions-&gt;lineStipple = (CL_GLFunctions::ptr_glLineStipple) &glLineStipple;
+	functions-&gt;lineWidth = (CL_GLFunctions::ptr_glLineWidth) &glLineWidth;
+	functions-&gt;listBase = (CL_GLFunctions::ptr_glListBase) &glListBase;
+	functions-&gt;loadIdentity = (CL_GLFunctions::ptr_glLoadIdentity) &glLoadIdentity;
+	functions-&gt;loadMatrixd = (CL_GLFunctions::ptr_glLoadMatrixd) &glLoadMatrixd;
+	functions-&gt;loadMatrixf = (CL_GLFunctions::ptr_glLoadMatrixf) &glLoadMatrixf;
+	functions-&gt;loadName = (CL_GLFunctions::ptr_glLoadName) &glLoadName;
+	functions-&gt;logicOp = (CL_GLFunctions::ptr_glLogicOp) &glLogicOp;
+	functions-&gt;map1d = (CL_GLFunctions::ptr_glMap1d) &amp;glMap1d;
+	functions-&gt;map1f = (CL_GLFunctions::ptr_glMap1f) &amp;glMap1f;
+	functions-&gt;map2d = (CL_GLFunctions::ptr_glMap2d) &amp;glMap2d;
+	functions-&gt;map2f = (CL_GLFunctions::ptr_glMap2f) &amp;glMap2f;
+	functions-&gt;mapGrid1d = (CL_GLFunctions::ptr_glMapGrid1d) &amp;glMapGrid1d;
+	functions-&gt;mapGrid1f = (CL_GLFunctions::ptr_glMapGrid1f) &amp;glMapGrid1f;
+	functions-&gt;mapGrid2d = (CL_GLFunctions::ptr_glMapGrid2d) &amp;glMapGrid2d;
+	functions-&gt;mapGrid2f = (CL_GLFunctions::ptr_glMapGrid2f) &amp;glMapGrid2f;
+	functions-&gt;materialf = (CL_GLFunctions::ptr_glMaterialf) &glMaterialf;
+	functions-&gt;materialfv = (CL_GLFunctions::ptr_glMaterialfv) &glMaterialfv;
+	functions-&gt;materiali = (CL_GLFunctions::ptr_glMateriali) &glMateriali;
+	functions-&gt;materialiv = (CL_GLFunctions::ptr_glMaterialiv) &glMaterialiv;
+	functions-&gt;matrixMode = (CL_GLFunctions::ptr_glMatrixMode) &glMatrixMode;
+	functions-&gt;multMatrixd = (CL_GLFunctions::ptr_glMultMatrixd) &glMultMatrixd;
+	functions-&gt;multMatrixf = (CL_GLFunctions::ptr_glMultMatrixf) &glMultMatrixf;
+	functions-&gt;newList = (CL_GLFunctions::ptr_glNewList) &glNewList;
+	functions-&gt;normal3b = (CL_GLFunctions::ptr_glNormal3b) &amp;glNormal3b;
+	functions-&gt;normal3bv = (CL_GLFunctions::ptr_glNormal3bv) &amp;glNormal3bv;
+	functions-&gt;normal3d = (CL_GLFunctions::ptr_glNormal3d) &amp;glNormal3d;
+	functions-&gt;normal3dv = (CL_GLFunctions::ptr_glNormal3dv) &amp;glNormal3dv;
+	functions-&gt;normal3f = (CL_GLFunctions::ptr_glNormal3f) &amp;glNormal3f;
+	functions-&gt;normal3fv = (CL_GLFunctions::ptr_glNormal3fv) &amp;glNormal3fv;
+	functions-&gt;normal3i = (CL_GLFunctions::ptr_glNormal3i) &amp;glNormal3i;
+	functions-&gt;normal3iv = (CL_GLFunctions::ptr_glNormal3iv) &amp;glNormal3iv;
+	functions-&gt;normal3s = (CL_GLFunctions::ptr_glNormal3s) &amp;glNormal3s;
+	functions-&gt;normal3sv = (CL_GLFunctions::ptr_glNormal3sv) &amp;glNormal3sv;
+	functions-&gt;normalPointer = (CL_GLFunctions::ptr_glNormalPointer) &glNormalPointer;
+	functions-&gt;ortho = (CL_GLFunctions::ptr_glOrtho) &glOrtho;
+	functions-&gt;passThrough = (CL_GLFunctions::ptr_glPassThrough) &glPassThrough;
+	functions-&gt;pixelMapfv = (CL_GLFunctions::ptr_glPixelMapfv) &glPixelMapfv;
+	functions-&gt;pixelMapuiv = (CL_GLFunctions::ptr_glPixelMapuiv) &glPixelMapuiv;
+	functions-&gt;pixelMapusv = (CL_GLFunctions::ptr_glPixelMapusv) &glPixelMapusv;
+	functions-&gt;pixelStoref = (CL_GLFunctions::ptr_glPixelStoref) &glPixelStoref;
+	functions-&gt;pixelStorei = (CL_GLFunctions::ptr_glPixelStorei) &glPixelStorei;
+	functions-&gt;pixelTransferf = (CL_GLFunctions::ptr_glPixelTransferf) &glPixelTransferf;
+	functions-&gt;pixelTransferi = (CL_GLFunctions::ptr_glPixelTransferi) &glPixelTransferi;
+	functions-&gt;pixelZoom = (CL_GLFunctions::ptr_glPixelZoom) &glPixelZoom;
+	functions-&gt;pointSize = (CL_GLFunctions::ptr_glPointSize) &glPointSize;
+	functions-&gt;polygonMode = (CL_GLFunctions::ptr_glPolygonMode) &glPolygonMode;
+	functions-&gt;polygonOffset = (CL_GLFunctions::ptr_glPolygonOffset) &glPolygonOffset;
+	functions-&gt;polygonStipple = (CL_GLFunctions::ptr_glPolygonStipple) &glPolygonStipple;
+	functions-&gt;popAttrib = (CL_GLFunctions::ptr_glPopAttrib) &glPopAttrib;
+	functions-&gt;popClientAttrib = (CL_GLFunctions::ptr_glPopClientAttrib) &glPopClientAttrib;
+	functions-&gt;popMatrix = (CL_GLFunctions::ptr_glPopMatrix) &glPopMatrix;
+	functions-&gt;popName = (CL_GLFunctions::ptr_glPopName) &glPopName;
+	functions-&gt;prioritizeTextures = (CL_GLFunctions::ptr_glPrioritizeTextures) &glPrioritizeTextures;
+	functions-&gt;pushAttrib = (CL_GLFunctions::ptr_glPushAttrib) &glPushAttrib;
+	functions-&gt;pushClientAttrib = (CL_GLFunctions::ptr_glPushClientAttrib) &glPushClientAttrib;
+	functions-&gt;pushMatrix = (CL_GLFunctions::ptr_glPushMatrix) &glPushMatrix;
+	functions-&gt;pushName = (CL_GLFunctions::ptr_glPushName) &glPushName;
+	functions-&gt;rasterPos2d = (CL_GLFunctions::ptr_glRasterPos2d) &amp;glRasterPos2d;
+	functions-&gt;rasterPos2dv = (CL_GLFunctions::ptr_glRasterPos2dv) &amp;glRasterPos2dv;
+	functions-&gt;rasterPos2f = (CL_GLFunctions::ptr_glRasterPos2f) &amp;glRasterPos2f;
+	functions-&gt;rasterPos2fv = (CL_GLFunctions::ptr_glRasterPos2fv) &amp;glRasterPos2fv;
+	functions-&gt;rasterPos2i = (CL_GLFunctions::ptr_glRasterPos2i) &amp;glRasterPos2i;
+	functions-&gt;rasterPos2iv = (CL_GLFunctions::ptr_glRasterPos2iv) &amp;glRasterPos2iv;
+	functions-&gt;rasterPos2s = (CL_GLFunctions::ptr_glRasterPos2s) &amp;glRasterPos2s;
+	functions-&gt;rasterPos2sv = (CL_GLFunctions::ptr_glRasterPos2sv) &amp;glRasterPos2sv;
+	functions-&gt;rasterPos3d = (CL_GLFunctions::ptr_glRasterPos3d) &amp;glRasterPos3d;
+	functions-&gt;rasterPos3dv = (CL_GLFunctions::ptr_glRasterPos3dv) &amp;glRasterPos3dv;
+	functions-&gt;rasterPos3f = (CL_GLFunctions::ptr_glRasterPos3f) &amp;glRasterPos3f;
+	functions-&gt;rasterPos3fv = (CL_GLFunctions::ptr_glRasterPos3fv) &amp;glRasterPos3fv;
+	functions-&gt;rasterPos3i = (CL_GLFunctions::ptr_glRasterPos3i) &amp;glRasterPos3i;
+	functions-&gt;rasterPos3iv = (CL_GLFunctions::ptr_glRasterPos3iv) &amp;glRasterPos3iv;
+	functions-&gt;rasterPos3s = (CL_GLFunctions::ptr_glRasterPos3s) &amp;glRasterPos3s;
+	functions-&gt;rasterPos3sv = (CL_GLFunctions::ptr_glRasterPos3sv) &amp;glRasterPos3sv;
+	functions-&gt;rasterPos4d = (CL_GLFunctions::ptr_glRasterPos4d) &amp;glRasterPos4d;
+	functions-&gt;rasterPos4dv = (CL_GLFunctions::ptr_glRasterPos4dv) &amp;glRasterPos4dv;
+	functions-&gt;rasterPos4f = (CL_GLFunctions::ptr_glRasterPos4f) &amp;glRasterPos4f;
+	functions-&gt;rasterPos4fv = (CL_GLFunctions::ptr_glRasterPos4fv) &amp;glRasterPos4fv;
+	functions-&gt;rasterPos4i = (CL_GLFunctions::ptr_glRasterPos4i) &amp;glRasterPos4i;
+	functions-&gt;rasterPos4iv = (CL_GLFunctions::ptr_glRasterPos4iv) &amp;glRasterPos4iv;
+	functions-&gt;rasterPos4s = (CL_GLFunctions::ptr_glRasterPos4s) &amp;glRasterPos4s;
+	functions-&gt;rasterPos4sv = (CL_GLFunctions::ptr_glRasterPos4sv) &amp;glRasterPos4sv;
+	functions-&gt;readBuffer = (CL_GLFunctions::ptr_glReadBuffer) &glReadBuffer;
+	functions-&gt;readPixels = (CL_GLFunctions::ptr_glReadPixels) &glReadPixels;
+	functions-&gt;rectd = (CL_GLFunctions::ptr_glRectd) &glRectd;
+	functions-&gt;rectdv = (CL_GLFunctions::ptr_glRectdv) &glRectdv;
+	functions-&gt;rectf = (CL_GLFunctions::ptr_glRectf) &glRectf;
+	functions-&gt;rectfv = (CL_GLFunctions::ptr_glRectfv) &glRectfv;
+	functions-&gt;recti = (CL_GLFunctions::ptr_glRecti) &glRecti;
+	functions-&gt;rectiv = (CL_GLFunctions::ptr_glRectiv) &glRectiv;
+	functions-&gt;rects = (CL_GLFunctions::ptr_glRects) &glRects;
+	functions-&gt;rectsv = (CL_GLFunctions::ptr_glRectsv) &glRectsv;
+	functions-&gt;renderMode = (CL_GLFunctions::ptr_glRenderMode) &glRenderMode;
+	functions-&gt;rotated = (CL_GLFunctions::ptr_glRotated) &glRotated;
+	functions-&gt;rotatef = (CL_GLFunctions::ptr_glRotatef) &glRotatef;
+	functions-&gt;scaled = (CL_GLFunctions::ptr_glScaled) &glScaled;
+	functions-&gt;scalef = (CL_GLFunctions::ptr_glScalef) &glScalef;
+	functions-&gt;scissor = (CL_GLFunctions::ptr_glScissor) &glScissor;
+	functions-&gt;selectBuffer = (CL_GLFunctions::ptr_glSelectBuffer) &glSelectBuffer;
+	functions-&gt;shadeModel = (CL_GLFunctions::ptr_glShadeModel) &glShadeModel;
+	functions-&gt;stencilFunc = (CL_GLFunctions::ptr_glStencilFunc) &glStencilFunc;
+	functions-&gt;stencilMask = (CL_GLFunctions::ptr_glStencilMask) &glStencilMask;
+	functions-&gt;stencilOp = (CL_GLFunctions::ptr_glStencilOp) &glStencilOp;
+	functions-&gt;texCoord1d = (CL_GLFunctions::ptr_glTexCoord1d) &amp;glTexCoord1d;
+	functions-&gt;texCoord1dv = (CL_GLFunctions::ptr_glTexCoord1dv) &amp;glTexCoord1dv;
+	functions-&gt;texCoord1f = (CL_GLFunctions::ptr_glTexCoord1f) &amp;glTexCoord1f;
+	functions-&gt;texCoord1fv = (CL_GLFunctions::ptr_glTexCoord1fv) &amp;glTexCoord1fv;
+	functions-&gt;texCoord1i = (CL_GLFunctions::ptr_glTexCoord1i) &amp;glTexCoord1i;
+	functions-&gt;texCoord1iv = (CL_GLFunctions::ptr_glTexCoord1iv) &amp;glTexCoord1iv;
+	functions-&gt;texCoord1s = (CL_GLFunctions::ptr_glTexCoord1s) &amp;glTexCoord1s;
+	functions-&gt;texCoord1sv = (CL_GLFunctions::ptr_glTexCoord1sv) &amp;glTexCoord1sv;
+	functions-&gt;texCoord2d = (CL_GLFunctions::ptr_glTexCoord2d) &amp;glTexCoord2d;
+	functions-&gt;texCoord2dv = (CL_GLFunctions::ptr_glTexCoord2dv) &amp;glTexCoord2dv;
+	functions-&gt;texCoord2f = (CL_GLFunctions::ptr_glTexCoord2f) &amp;glTexCoord2f;
+	functions-&gt;texCoord2fv = (CL_GLFunctions::ptr_glTexCoord2fv) &amp;glTexCoord2fv;
+	functions-&gt;texCoord2i = (CL_GLFunctions::ptr_glTexCoord2i) &amp;glTexCoord2i;
+	functions-&gt;texCoord2iv = (CL_GLFunctions::ptr_glTexCoord2iv) &amp;glTexCoord2iv;
+	functions-&gt;texCoord2s = (CL_GLFunctions::ptr_glTexCoord2s) &amp;glTexCoord2s;
+	functions-&gt;texCoord2sv = (CL_GLFunctions::ptr_glTexCoord2sv) &amp;glTexCoord2sv;
+	functions-&gt;texCoord3d = (CL_GLFunctions::ptr_glTexCoord3d) &amp;glTexCoord3d;
+	functions-&gt;texCoord3dv = (CL_GLFunctions::ptr_glTexCoord3dv) &amp;glTexCoord3dv;
+	functions-&gt;texCoord3f = (CL_GLFunctions::ptr_glTexCoord3f) &amp;glTexCoord3f;
+	functions-&gt;texCoord3fv = (CL_GLFunctions::ptr_glTexCoord3fv) &amp;glTexCoord3fv;
+	functions-&gt;texCoord3i = (CL_GLFunctions::ptr_glTexCoord3i) &amp;glTexCoord3i;
+	functions-&gt;texCoord3iv = (CL_GLFunctions::ptr_glTexCoord3iv) &amp;glTexCoord3iv;
+	functions-&gt;texCoord3s = (CL_GLFunctions::ptr_glTexCoord3s) &amp;glTexCoord3s;
+	functions-&gt;texCoord3sv = (CL_GLFunctions::ptr_glTexCoord3sv) &amp;glTexCoord3sv;
+	functions-&gt;texCoord4d = (CL_GLFunctions::ptr_glTexCoord4d) &amp;glTexCoord4d;
+	functions-&gt;texCoord4dv = (CL_GLFunctions::ptr_glTexCoord4dv) &amp;glTexCoord4dv;
+	functions-&gt;texCoord4f = (CL_GLFunctions::ptr_glTexCoord4f) &amp;glTexCoord4f;
+	functions-&gt;texCoord4fv = (CL_GLFunctions::ptr_glTexCoord4fv) &amp;glTexCoord4fv;
+	functions-&gt;texCoord4i = (CL_GLFunctions::ptr_glTexCoord4i) &amp;glTexCoord4i;
+	functions-&gt;texCoord4iv = (CL_GLFunctions::ptr_glTexCoord4iv) &amp;glTexCoord4iv;
+	functions-&gt;texCoord4s = (CL_GLFunctions::ptr_glTexCoord4s) &amp;glTexCoord4s;
+	functions-&gt;texCoord4sv = (CL_GLFunctions::ptr_glTexCoord4sv) &amp;glTexCoord4sv;
+	functions-&gt;texCoordPointer = (CL_GLFunctions::ptr_glTexCoordPointer) &glTexCoordPointer;
+	functions-&gt;texEnvf = (CL_GLFunctions::ptr_glTexEnvf) &glTexEnvf;
+	functions-&gt;texEnvfv = (CL_GLFunctions::ptr_glTexEnvfv) &glTexEnvfv;
+	functions-&gt;texEnvi = (CL_GLFunctions::ptr_glTexEnvi) &glTexEnvi;
+	functions-&gt;texEnviv = (CL_GLFunctions::ptr_glTexEnviv) &glTexEnviv;
+	functions-&gt;texGend = (CL_GLFunctions::ptr_glTexGend) &glTexGend;
+	functions-&gt;texGendv = (CL_GLFunctions::ptr_glTexGendv) &glTexGendv;
+	functions-&gt;texGenf = (CL_GLFunctions::ptr_glTexGenf) &glTexGenf;
+	functions-&gt;texGenfv = (CL_GLFunctions::ptr_glTexGenfv) &glTexGenfv;
+	functions-&gt;texGeni = (CL_GLFunctions::ptr_glTexGeni) &glTexGeni;
+	functions-&gt;texGeniv = (CL_GLFunctions::ptr_glTexGeniv) &glTexGeniv;
+	functions-&gt;texImage1D = (CL_GLFunctions::ptr_glTexImage1D) &amp;glTexImage1D;
+	functions-&gt;texImage2D = (CL_GLFunctions::ptr_glTexImage2D) &amp;glTexImage2D;
+	functions-&gt;texParameterf = (CL_GLFunctions::ptr_glTexParameterf) &glTexParameterf;
+	functions-&gt;texParameterfv = (CL_GLFunctions::ptr_glTexParameterfv) &glTexParameterfv;
+	functions-&gt;texParameteri = (CL_GLFunctions::ptr_glTexParameteri) &glTexParameteri;
+	functions-&gt;texParameteriv = (CL_GLFunctions::ptr_glTexParameteriv) &glTexParameteriv;
+	functions-&gt;texSubImage1D = (CL_GLFunctions::ptr_glTexSubImage1D) &amp;glTexSubImage1D;
+	functions-&gt;texSubImage2D = (CL_GLFunctions::ptr_glTexSubImage2D) &amp;glTexSubImage2D;
+	functions-&gt;translated = (CL_GLFunctions::ptr_glTranslated) &glTranslated;
+	functions-&gt;translatef = (CL_GLFunctions::ptr_glTranslatef) &glTranslatef;
+	functions-&gt;vertex2d = (CL_GLFunctions::ptr_glVertex2d) &amp;glVertex2d;
+	functions-&gt;vertex2dv = (CL_GLFunctions::ptr_glVertex2dv) &amp;glVertex2dv;
+	functions-&gt;vertex2f = (CL_GLFunctions::ptr_glVertex2f) &amp;glVertex2f;
+	functions-&gt;vertex2fv = (CL_GLFunctions::ptr_glVertex2fv) &amp;glVertex2fv;
+	functions-&gt;vertex2i = (CL_GLFunctions::ptr_glVertex2i) &amp;glVertex2i;
+	functions-&gt;vertex2iv = (CL_GLFunctions::ptr_glVertex2iv) &amp;glVertex2iv;
+	functions-&gt;vertex2s = (CL_GLFunctions::ptr_glVertex2s) &amp;glVertex2s;
+	functions-&gt;vertex2sv = (CL_GLFunctions::ptr_glVertex2sv) &amp;glVertex2sv;
+	functions-&gt;vertex3d = (CL_GLFunctions::ptr_glVertex3d) &amp;glVertex3d;
+	functions-&gt;vertex3dv = (CL_GLFunctions::ptr_glVertex3dv) &amp;glVertex3dv;
+	functions-&gt;vertex3f = (CL_GLFunctions::ptr_glVertex3f) &amp;glVertex3f;
+	functions-&gt;vertex3fv = (CL_GLFunctions::ptr_glVertex3fv) &amp;glVertex3fv;
+	functions-&gt;vertex3i = (CL_GLFunctions::ptr_glVertex3i) &amp;glVertex3i;
+	functions-&gt;vertex3iv = (CL_GLFunctions::ptr_glVertex3iv) &amp;glVertex3iv;
+	functions-&gt;vertex3s = (CL_GLFunctions::ptr_glVertex3s) &amp;glVertex3s;
+	functions-&gt;vertex3sv = (CL_GLFunctions::ptr_glVertex3sv) &amp;glVertex3sv;
+	functions-&gt;vertex4d = (CL_GLFunctions::ptr_glVertex4d) &amp;glVertex4d;
+	functions-&gt;vertex4dv = (CL_GLFunctions::ptr_glVertex4dv) &amp;glVertex4dv;
+	functions-&gt;vertex4f = (CL_GLFunctions::ptr_glVertex4f) &amp;glVertex4f;
+	functions-&gt;vertex4fv = (CL_GLFunctions::ptr_glVertex4fv) &amp;glVertex4fv;
+	functions-&gt;vertex4i = (CL_GLFunctions::ptr_glVertex4i) &amp;glVertex4i;
+	functions-&gt;vertex4iv = (CL_GLFunctions::ptr_glVertex4iv) &amp;glVertex4iv;
+	functions-&gt;vertex4s = (CL_GLFunctions::ptr_glVertex4s) &amp;glVertex4s;
+	functions-&gt;vertex4sv = (CL_GLFunctions::ptr_glVertex4sv) &amp;glVertex4sv;
+	functions-&gt;vertexPointer = (CL_GLFunctions::ptr_glVertexPointer) &glVertexPointer;
+	functions-&gt;viewport = (CL_GLFunctions::ptr_glViewport) &glViewport;
+#else
+	functions-&gt;accum = (CL_GLFunctions::ptr_glAccum) CL_OpenGL::get_proc_address(&quot;glAccum&quot;);
+	functions-&gt;alphaFunc = (CL_GLFunctions::ptr_glAlphaFunc) CL_OpenGL::get_proc_address(&quot;glAlphaFunc&quot;);
+	functions-&gt;areTexturesResident = (CL_GLFunctions::ptr_glAreTexturesResident) CL_OpenGL::get_proc_address(&quot;glAreTexturesResident&quot;);
+	functions-&gt;arrayElement = (CL_GLFunctions::ptr_glArrayElement) CL_OpenGL::get_proc_address(&quot;glArrayElement&quot;);
+	functions-&gt;begin = (CL_GLFunctions::ptr_glBegin) CL_OpenGL::get_proc_address(&quot;glBegin&quot;);
+	functions-&gt;bindTexture = (CL_GLFunctions::ptr_glBindTexture) CL_OpenGL::get_proc_address(&quot;glBindTexture&quot;);
+	functions-&gt;bitmap = (CL_GLFunctions::ptr_glBitmap) CL_OpenGL::get_proc_address(&quot;glBitmap&quot;);
+	functions-&gt;blendFunc = (CL_GLFunctions::ptr_glBlendFunc) CL_OpenGL::get_proc_address(&quot;glBlendFunc&quot;);
+	functions-&gt;callList = (CL_GLFunctions::ptr_glCallList) CL_OpenGL::get_proc_address(&quot;glCallList&quot;);
+	functions-&gt;callLists = (CL_GLFunctions::ptr_glCallLists) CL_OpenGL::get_proc_address(&quot;glCallLists&quot;);
+	functions-&gt;clear = (CL_GLFunctions::ptr_glClear) CL_OpenGL::get_proc_address(&quot;glClear&quot;);
+	functions-&gt;clearAccum = (CL_GLFunctions::ptr_glClearAccum) CL_OpenGL::get_proc_address(&quot;glClearAccum&quot;);
+	functions-&gt;clearColor = (CL_GLFunctions::ptr_glClearColor) CL_OpenGL::get_proc_address(&quot;glClearColor&quot;);
+	functions-&gt;clearDepth = (CL_GLFunctions::ptr_glClearDepth) CL_OpenGL::get_proc_address(&quot;glClearDepth&quot;);
+	functions-&gt;clearIndex = (CL_GLFunctions::ptr_glClearIndex) CL_OpenGL::get_proc_address(&quot;glClearIndex&quot;);
+	functions-&gt;clearStencil = (CL_GLFunctions::ptr_glClearStencil) CL_OpenGL::get_proc_address(&quot;glClearStencil&quot;);
+	functions-&gt;clipPlane = (CL_GLFunctions::ptr_glClipPlane) CL_OpenGL::get_proc_address(&quot;glClipPlane&quot;);
+	functions-&gt;color3b = (CL_GLFunctions::ptr_glColor3b) CL_OpenGL::get_proc_address(&quot;glColor3b&quot;);
+	functions-&gt;color3bv = (CL_GLFunctions::ptr_glColor3bv) CL_OpenGL::get_proc_address(&quot;glColor3bv&quot;);
+	functions-&gt;color3d = (CL_GLFunctions::ptr_glColor3d) CL_OpenGL::get_proc_address(&quot;glColor3d&quot;);
+	functions-&gt;color3dv = (CL_GLFunctions::ptr_glColor3dv) CL_OpenGL::get_proc_address(&quot;glColor3dv&quot;);
+	functions-&gt;color3f = (CL_GLFunctions::ptr_glColor3f) CL_OpenGL::get_proc_address(&quot;glColor3f&quot;);
+	functions-&gt;color3fv = (CL_GLFunctions::ptr_glColor3fv) CL_OpenGL::get_proc_address(&quot;glColor3fv&quot;);
+	functions-&gt;color3i = (CL_GLFunctions::ptr_glColor3i) CL_OpenGL::get_proc_address(&quot;glColor3i&quot;);
+	functions-&gt;color3iv = (CL_GLFunctions::ptr_glColor3iv) CL_OpenGL::get_proc_address(&quot;glColor3iv&quot;);
+	functions-&gt;color3s = (CL_GLFunctions::ptr_glColor3s) CL_OpenGL::get_proc_address(&quot;glColor3s&quot;);
+	functions-&gt;color3sv = (CL_GLFunctions::ptr_glColor3sv) CL_OpenGL::get_proc_address(&quot;glColor3sv&quot;);
+	functions-&gt;color3ub = (CL_GLFunctions::ptr_glColor3ub) CL_OpenGL::get_proc_address(&quot;glColor3ub&quot;);
+	functions-&gt;color3ubv = (CL_GLFunctions::ptr_glColor3ubv) CL_OpenGL::get_proc_address(&quot;glColor3ubv&quot;);
+	functions-&gt;color3ui = (CL_GLFunctions::ptr_glColor3ui) CL_OpenGL::get_proc_address(&quot;glColor3ui&quot;);
+	functions-&gt;color3uiv = (CL_GLFunctions::ptr_glColor3uiv) CL_OpenGL::get_proc_address(&quot;glColor3uiv&quot;);
+	functions-&gt;color3us = (CL_GLFunctions::ptr_glColor3us) CL_OpenGL::get_proc_address(&quot;glColor3us&quot;);
+	functions-&gt;color3usv = (CL_GLFunctions::ptr_glColor3usv) CL_OpenGL::get_proc_address(&quot;glColor3usv&quot;);
+	functions-&gt;color4b = (CL_GLFunctions::ptr_glColor4b) CL_OpenGL::get_proc_address(&quot;glColor4b&quot;);
+	functions-&gt;color4bv = (CL_GLFunctions::ptr_glColor4bv) CL_OpenGL::get_proc_address(&quot;glColor4bv&quot;);
+	functions-&gt;color4d = (CL_GLFunctions::ptr_glColor4d) CL_OpenGL::get_proc_address(&quot;glColor4d&quot;);
+	functions-&gt;color4dv = (CL_GLFunctions::ptr_glColor4dv) CL_OpenGL::get_proc_address(&quot;glColor4dv&quot;);
+	functions-&gt;color4f = (CL_GLFunctions::ptr_glColor4f) CL_OpenGL::get_proc_address(&quot;glColor4f&quot;);
+	functions-&gt;color4fv = (CL_GLFunctions::ptr_glColor4fv) CL_OpenGL::get_proc_address(&quot;glColor4fv&quot;);
+	functions-&gt;color4i = (CL_GLFunctions::ptr_glColor4i) CL_OpenGL::get_proc_address(&quot;glColor4i&quot;);
+	functions-&gt;color4iv = (CL_GLFunctions::ptr_glColor4iv) CL_OpenGL::get_proc_address(&quot;glColor4iv&quot;);
+	functions-&gt;color4s = (CL_GLFunctions::ptr_glColor4s) CL_OpenGL::get_proc_address(&quot;glColor4s&quot;);
+	functions-&gt;color4sv = (CL_GLFunctions::ptr_glColor4sv) CL_OpenGL::get_proc_address(&quot;glColor4sv&quot;);
+	functions-&gt;color4ub = (CL_GLFunctions::ptr_glColor4ub) CL_OpenGL::get_proc_address(&quot;glColor4ub&quot;);
+	functions-&gt;color4ubv = (CL_GLFunctions::ptr_glColor4ubv) CL_OpenGL::get_proc_address(&quot;glColor4ubv&quot;);
+	functions-&gt;color4ui = (CL_GLFunctions::ptr_glColor4ui) CL_OpenGL::get_proc_address(&quot;glColor4ui&quot;);
+	functions-&gt;color4uiv = (CL_GLFunctions::ptr_glColor4uiv) CL_OpenGL::get_proc_address(&quot;glColor4uiv&quot;);
+	functions-&gt;color4us = (CL_GLFunctions::ptr_glColor4us) CL_OpenGL::get_proc_address(&quot;glColor4us&quot;);
+	functions-&gt;color4usv = (CL_GLFunctions::ptr_glColor4usv) CL_OpenGL::get_proc_address(&quot;glColor4usv&quot;);
+	functions-&gt;colorMask = (CL_GLFunctions::ptr_glColorMask) CL_OpenGL::get_proc_address(&quot;glColorMask&quot;);
+	functions-&gt;colorMaterial = (CL_GLFunctions::ptr_glColorMaterial) CL_OpenGL::get_proc_address(&quot;glColorMaterial&quot;);
+	functions-&gt;colorPointer = (CL_GLFunctions::ptr_glColorPointer) CL_OpenGL::get_proc_address(&quot;glColorPointer&quot;);
+	functions-&gt;copyPixels = (CL_GLFunctions::ptr_glCopyPixels) CL_OpenGL::get_proc_address(&quot;glCopyPixels&quot;);
+	functions-&gt;copyTexImage1D = (CL_GLFunctions::ptr_glCopyTexImage1D) CL_OpenGL::get_proc_address(&quot;glCopyTexImage1D&quot;);
+	functions-&gt;copyTexImage2D = (CL_GLFunctions::ptr_glCopyTexImage2D) CL_OpenGL::get_proc_address(&quot;glCopyTexImage2D&quot;);
+	functions-&gt;copyTexSubImage1D = (CL_GLFunctions::ptr_glCopyTexSubImage1D) CL_OpenGL::get_proc_address(&quot;glCopyTexSubImage1D&quot;);
+	functions-&gt;copyTexSubImage2D = (CL_GLFunctions::ptr_glCopyTexSubImage2D) CL_OpenGL::get_proc_address(&quot;glCopyTexSubImage2D&quot;);
+	functions-&gt;cullFace = (CL_GLFunctions::ptr_glCullFace) CL_OpenGL::get_proc_address(&quot;glCullFace&quot;);
+	functions-&gt;deleteLists = (CL_GLFunctions::ptr_glDeleteLists) CL_OpenGL::get_proc_address(&quot;glDeleteLists&quot;);
+	functions-&gt;deleteTextures = (CL_GLFunctions::ptr_glDeleteTextures) CL_OpenGL::get_proc_address(&quot;glDeleteTextures&quot;);
+	functions-&gt;depthFunc = (CL_GLFunctions::ptr_glDepthFunc) CL_OpenGL::get_proc_address(&quot;glDepthFunc&quot;);
+	functions-&gt;depthMask = (CL_GLFunctions::ptr_glDepthMask) CL_OpenGL::get_proc_address(&quot;glDepthMask&quot;);
+	functions-&gt;depthRange = (CL_GLFunctions::ptr_glDepthRange) CL_OpenGL::get_proc_address(&quot;glDepthRange&quot;);
+	functions-&gt;disable = (CL_GLFunctions::ptr_glDisable) CL_OpenGL::get_proc_address(&quot;glDisable&quot;);
+	functions-&gt;disableClientState = (CL_GLFunctions::ptr_glDisableClientState) CL_OpenGL::get_proc_address(&quot;glDisableClientState&quot;);
+	functions-&gt;drawArrays = (CL_GLFunctions::ptr_glDrawArrays) CL_OpenGL::get_proc_address(&quot;glDrawArrays&quot;);
+	functions-&gt;drawBuffer = (CL_GLFunctions::ptr_glDrawBuffer) CL_OpenGL::get_proc_address(&quot;glDrawBuffer&quot;);
+	functions-&gt;drawElements = (CL_GLFunctions::ptr_glDrawElements) CL_OpenGL::get_proc_address(&quot;glDrawElements&quot;);
+	functions-&gt;drawPixels = (CL_GLFunctions::ptr_glDrawPixels) CL_OpenGL::get_proc_address(&quot;glDrawPixels&quot;);
+	functions-&gt;edgeFlag = (CL_GLFunctions::ptr_glEdgeFlag) CL_OpenGL::get_proc_address(&quot;glEdgeFlag&quot;);
+	functions-&gt;edgeFlagPointer = (CL_GLFunctions::ptr_glEdgeFlagPointer) CL_OpenGL::get_proc_address(&quot;glEdgeFlagPointer&quot;);
+	functions-&gt;edgeFlagv = (CL_GLFunctions::ptr_glEdgeFlagv) CL_OpenGL::get_proc_address(&quot;glEdgeFlagv&quot;);
+	functions-&gt;enable = (CL_GLFunctions::ptr_glEnable) CL_OpenGL::get_proc_address(&quot;glEnable&quot;);
+	functions-&gt;enableClientState = (CL_GLFunctions::ptr_glEnableClientState) CL_OpenGL::get_proc_address(&quot;glEnableClientState&quot;);
+	functions-&gt;end = (CL_GLFunctions::ptr_glEnd) CL_OpenGL::get_proc_address(&quot;glEnd&quot;);
+	functions-&gt;endList = (CL_GLFunctions::ptr_glEndList) CL_OpenGL::get_proc_address(&quot;glEndList&quot;);
+	functions-&gt;evalCoord1d = (CL_GLFunctions::ptr_glEvalCoord1d) CL_OpenGL::get_proc_address(&quot;glEvalCoord1d&quot;);
+	functions-&gt;evalCoord1dv = (CL_GLFunctions::ptr_glEvalCoord1dv) CL_OpenGL::get_proc_address(&quot;glEvalCoord1dv&quot;);
+	functions-&gt;evalCoord1f = (CL_GLFunctions::ptr_glEvalCoord1f) CL_OpenGL::get_proc_address(&quot;glEvalCoord1f&quot;);
+	functions-&gt;evalCoord1fv = (CL_GLFunctions::ptr_glEvalCoord1fv) CL_OpenGL::get_proc_address(&quot;glEvalCoord1fv&quot;);
+	functions-&gt;evalCoord2d = (CL_GLFunctions::ptr_glEvalCoord2d) CL_OpenGL::get_proc_address(&quot;glEvalCoord2d&quot;);
+	functions-&gt;evalCoord2dv = (CL_GLFunctions::ptr_glEvalCoord2dv) CL_OpenGL::get_proc_address(&quot;glEvalCoord2dv&quot;);
+	functions-&gt;evalCoord2f = (CL_GLFunctions::ptr_glEvalCoord2f) CL_OpenGL::get_proc_address(&quot;glEvalCoord2f&quot;);
+	functions-&gt;evalCoord2fv = (CL_GLFunctions::ptr_glEvalCoord2fv) CL_OpenGL::get_proc_address(&quot;glEvalCoord2fv&quot;);
+	functions-&gt;evalMesh1 = (CL_GLFunctions::ptr_glEvalMesh1) CL_OpenGL::get_proc_address(&quot;glEvalMesh1&quot;);
+	functions-&gt;evalMesh2 = (CL_GLFunctions::ptr_glEvalMesh2) CL_OpenGL::get_proc_address(&quot;glEvalMesh2&quot;);
+	functions-&gt;evalPoint1 = (CL_GLFunctions::ptr_glEvalPoint1) CL_OpenGL::get_proc_address(&quot;glEvalPoint1&quot;);
+	functions-&gt;evalPoint2 = (CL_GLFunctions::ptr_glEvalPoint2) CL_OpenGL::get_proc_address(&quot;glEvalPoint2&quot;);
+	functions-&gt;feedbackBuffer = (CL_GLFunctions::ptr_glFeedbackBuffer) CL_OpenGL::get_proc_address(&quot;glFeedbackBuffer&quot;);
+	functions-&gt;finish = (CL_GLFunctions::ptr_glFinish) CL_OpenGL::get_proc_address(&quot;glFinish&quot;);
+	functions-&gt;flush = (CL_GLFunctions::ptr_glFlush) CL_OpenGL::get_proc_address(&quot;glFlush&quot;);
+	functions-&gt;fogf = (CL_GLFunctions::ptr_glFogf) CL_OpenGL::get_proc_address(&quot;glFogf&quot;);
+	functions-&gt;fogfv = (CL_GLFunctions::ptr_glFogfv) CL_OpenGL::get_proc_address(&quot;glFogfv&quot;);
+	functions-&gt;fogi = (CL_GLFunctions::ptr_glFogi) CL_OpenGL::get_proc_address(&quot;glFogi&quot;);
+	functions-&gt;fogiv = (CL_GLFunctions::ptr_glFogiv) CL_OpenGL::get_proc_address(&quot;glFogiv&quot;);
+	functions-&gt;frontFace = (CL_GLFunctions::ptr_glFrontFace) CL_OpenGL::get_proc_address(&quot;glFrontFace&quot;);
+	functions-&gt;frustum = (CL_GLFunctions::ptr_glFrustum) CL_OpenGL::get_proc_address(&quot;glFrustum&quot;);
+	functions-&gt;genLists = (CL_GLFunctions::ptr_glGenLists) CL_OpenGL::get_proc_address(&quot;glGenLists&quot;);
+	functions-&gt;genTextures = (CL_GLFunctions::ptr_glGenTextures) CL_OpenGL::get_proc_address(&quot;glGenTextures&quot;);
+	functions-&gt;getBooleanv = (CL_GLFunctions::ptr_glGetBooleanv) CL_OpenGL::get_proc_address(&quot;glGetBooleanv&quot;);
+	functions-&gt;getClipPlane = (CL_GLFunctions::ptr_glGetClipPlane) CL_OpenGL::get_proc_address(&quot;glGetClipPlane&quot;);
+	functions-&gt;getDoublev = (CL_GLFunctions::ptr_glGetDoublev) CL_OpenGL::get_proc_address(&quot;glGetDoublev&quot;);
+	functions-&gt;getError = (CL_GLFunctions::ptr_glGetError) CL_OpenGL::get_proc_address(&quot;glGetError&quot;);
+	functions-&gt;getFloatv = (CL_GLFunctions::ptr_glGetFloatv) CL_OpenGL::get_proc_address(&quot;glGetFloatv&quot;);
+	functions-&gt;getIntegerv = (CL_GLFunctions::ptr_glGetIntegerv) CL_OpenGL::get_proc_address(&quot;glGetIntegerv&quot;);
+	functions-&gt;getLightfv = (CL_GLFunctions::ptr_glGetLightfv) CL_OpenGL::get_proc_address(&quot;glGetLightfv&quot;);
+	functions-&gt;getLightiv = (CL_GLFunctions::ptr_glGetLightiv) CL_OpenGL::get_proc_address(&quot;glGetLightiv&quot;);
+	functions-&gt;getMapdv = (CL_GLFunctions::ptr_glGetMapdv) CL_OpenGL::get_proc_address(&quot;glGetMapdv&quot;);
+	functions-&gt;getMapfv = (CL_GLFunctions::ptr_glGetMapfv) CL_OpenGL::get_proc_address(&quot;glGetMapfv&quot;);
+	functions-&gt;getMapiv = (CL_GLFunctions::ptr_glGetMapiv) CL_OpenGL::get_proc_address(&quot;glGetMapiv&quot;);
+	functions-&gt;getMaterialfv = (CL_GLFunctions::ptr_glGetMaterialfv) CL_OpenGL::get_proc_address(&quot;glGetMaterialfv&quot;);
+	functions-&gt;getMaterialiv = (CL_GLFunctions::ptr_glGetMaterialiv) CL_OpenGL::get_proc_address(&quot;glGetMaterialiv&quot;);
+	functions-&gt;getPixelMapfv = (CL_GLFunctions::ptr_glGetPixelMapfv) CL_OpenGL::get_proc_address(&quot;glGetPixelMapfv&quot;);
+	functions-&gt;getPixelMapuiv = (CL_GLFunctions::ptr_glGetPixelMapuiv) CL_OpenGL::get_proc_address(&quot;glGetPixelMapuiv&quot;);
+	functions-&gt;getPixelMapusv = (CL_GLFunctions::ptr_glGetPixelMapusv) CL_OpenGL::get_proc_address(&quot;glGetPixelMapusv&quot;);
+	functions-&gt;getPointerv = (CL_GLFunctions::ptr_glGetPointerv) CL_OpenGL::get_proc_address(&quot;glGetPointerv&quot;);
+	functions-&gt;getPolygonStipple = (CL_GLFunctions::ptr_glGetPolygonStipple) CL_OpenGL::get_proc_address(&quot;glGetPolygonStipple&quot;);
+	functions-&gt;getString = (CL_GLFunctions::ptr_glGetString) CL_OpenGL::get_proc_address(&quot;glGetString&quot;);
+	functions-&gt;getTexEnvfv = (CL_GLFunctions::ptr_glGetTexEnvfv) CL_OpenGL::get_proc_address(&quot;glGetTexEnvfv&quot;);
+	functions-&gt;getTexEnviv = (CL_GLFunctions::ptr_glGetTexEnviv) CL_OpenGL::get_proc_address(&quot;glGetTexEnviv&quot;);
+	functions-&gt;getTexGendv = (CL_GLFunctions::ptr_glGetTexGendv) CL_OpenGL::get_proc_address(&quot;glGetTexGendv&quot;);
+	functions-&gt;getTexGenfv = (CL_GLFunctions::ptr_glGetTexGenfv) CL_OpenGL::get_proc_address(&quot;glGetTexGenfv&quot;);
+	functions-&gt;getTexGeniv = (CL_GLFunctions::ptr_glGetTexGeniv) CL_OpenGL::get_proc_address(&quot;glGetTexGeniv&quot;);
+	functions-&gt;getTexImage = (CL_GLFunctions::ptr_glGetTexImage) CL_OpenGL::get_proc_address(&quot;glGetTexImage&quot;);
+	functions-&gt;getTexLevelParameterfv = (CL_GLFunctions::ptr_glGetTexLevelParameterfv) CL_OpenGL::get_proc_address(&quot;glGetTexLevelParameterfv&quot;);
+	functions-&gt;getTexLevelParameteriv = (CL_GLFunctions::ptr_glGetTexLevelParameteriv) CL_OpenGL::get_proc_address(&quot;glGetTexLevelParameteriv&quot;);
+	functions-&gt;getTexParameterfv = (CL_GLFunctions::ptr_glGetTexParameterfv) CL_OpenGL::get_proc_address(&quot;glGetTexParameterfv&quot;);
+	functions-&gt;getTexParameteriv = (CL_GLFunctions::ptr_glGetTexParameteriv) CL_OpenGL::get_proc_address(&quot;glGetTexParameteriv&quot;);
+	functions-&gt;hint = (CL_GLFunctions::ptr_glHint) CL_OpenGL::get_proc_address(&quot;glHint&quot;);
+	functions-&gt;indexMask = (CL_GLFunctions::ptr_glIndexMask) CL_OpenGL::get_proc_address(&quot;glIndexMask&quot;);
+	functions-&gt;indexPointer = (CL_GLFunctions::ptr_glIndexPointer) CL_OpenGL::get_proc_address(&quot;glIndexPointer&quot;);
+	functions-&gt;indexd = (CL_GLFunctions::ptr_glIndexd) CL_OpenGL::get_proc_address(&quot;glIndexd&quot;);
+	functions-&gt;indexdv = (CL_GLFunctions::ptr_glIndexdv) CL_OpenGL::get_proc_address(&quot;glIndexdv&quot;);
+	functions-&gt;indexf = (CL_GLFunctions::ptr_glIndexf) CL_OpenGL::get_proc_address(&quot;glIndexf&quot;);
+	functions-&gt;indexfv = (CL_GLFunctions::ptr_glIndexfv) CL_OpenGL::get_proc_address(&quot;glIndexfv&quot;);
+	functions-&gt;indexi = (CL_GLFunctions::ptr_glIndexi) CL_OpenGL::get_proc_address(&quot;glIndexi&quot;);
+	functions-&gt;indexiv = (CL_GLFunctions::ptr_glIndexiv) CL_OpenGL::get_proc_address(&quot;glIndexiv&quot;);
+	functions-&gt;indexs = (CL_GLFunctions::ptr_glIndexs) CL_OpenGL::get_proc_address(&quot;glIndexs&quot;);
+	functions-&gt;indexsv = (CL_GLFunctions::ptr_glIndexsv) CL_OpenGL::get_proc_address(&quot;glIndexsv&quot;);
+	functions-&gt;indexub = (CL_GLFunctions::ptr_glIndexub) CL_OpenGL::get_proc_address(&quot;glIndexub&quot;);
+	functions-&gt;indexubv = (CL_GLFunctions::ptr_glIndexubv) CL_OpenGL::get_proc_address(&quot;glIndexubv&quot;);
+	functions-&gt;initNames = (CL_GLFunctions::ptr_glInitNames) CL_OpenGL::get_proc_address(&quot;glInitNames&quot;);
+	functions-&gt;interleavedArrays = (CL_GLFunctions::ptr_glInterleavedArrays) CL_OpenGL::get_proc_address(&quot;glInterleavedArrays&quot;);
+	functions-&gt;isEnabled = (CL_GLFunctions::ptr_glIsEnabled) CL_OpenGL::get_proc_address(&quot;glIsEnabled&quot;);
+	functions-&gt;isList = (CL_GLFunctions::ptr_glIsList) CL_OpenGL::get_proc_address(&quot;glIsList&quot;);
+	functions-&gt;isTexture = (CL_GLFunctions::ptr_glIsTexture) CL_OpenGL::get_proc_address(&quot;glIsTexture&quot;);
+	functions-&gt;lightModelf = (CL_GLFunctions::ptr_glLightModelf) CL_OpenGL::get_proc_address(&quot;glLightModelf&quot;);
+	functions-&gt;lightModelfv = (CL_GLFunctions::ptr_glLightModelfv) CL_OpenGL::get_proc_address(&quot;glLightModelfv&quot;);
+	functions-&gt;lightModeli = (CL_GLFunctions::ptr_glLightModeli) CL_OpenGL::get_proc_address(&quot;glLightModeli&quot;);
+	functions-&gt;lightModeliv = (CL_GLFunctions::ptr_glLightModeliv) CL_OpenGL::get_proc_address(&quot;glLightModeliv&quot;);
+	functions-&gt;lightf = (CL_GLFunctions::ptr_glLightf) CL_OpenGL::get_proc_address(&quot;glLightf&quot;);
+	functions-&gt;lightfv = (CL_GLFunctions::ptr_glLightfv) CL_OpenGL::get_proc_address(&quot;glLightfv&quot;);
+	functions-&gt;lighti = (CL_GLFunctions::ptr_glLighti) CL_OpenGL::get_proc_address(&quot;glLighti&quot;);
+	functions-&gt;lightiv = (CL_GLFunctions::ptr_glLightiv) CL_OpenGL::get_proc_address(&quot;glLightiv&quot;);
+	functions-&gt;lineStipple = (CL_GLFunctions::ptr_glLineStipple) CL_OpenGL::get_proc_address(&quot;glLineStipple&quot;);
+	functions-&gt;lineWidth = (CL_GLFunctions::ptr_glLineWidth) CL_OpenGL::get_proc_address(&quot;glLineWidth&quot;);
+	functions-&gt;listBase = (CL_GLFunctions::ptr_glListBase) CL_OpenGL::get_proc_address(&quot;glListBase&quot;);
+	functions-&gt;loadIdentity = (CL_GLFunctions::ptr_glLoadIdentity) CL_OpenGL::get_proc_address(&quot;glLoadIdentity&quot;);
+	functions-&gt;loadMatrixd = (CL_GLFunctions::ptr_glLoadMatrixd) CL_OpenGL::get_proc_address(&quot;glLoadMatrixd&quot;);
+	functions-&gt;loadMatrixf = (CL_GLFunctions::ptr_glLoadMatrixf) CL_OpenGL::get_proc_address(&quot;glLoadMatrixf&quot;);
+	functions-&gt;loadName = (CL_GLFunctions::ptr_glLoadName) CL_OpenGL::get_proc_address(&quot;glLoadName&quot;);
+	functions-&gt;logicOp = (CL_GLFunctions::ptr_glLogicOp) CL_OpenGL::get_proc_address(&quot;glLogicOp&quot;);
+	functions-&gt;map1d = (CL_GLFunctions::ptr_glMap1d) CL_OpenGL::get_proc_address(&quot;glMap1d&quot;);
+	functions-&gt;map1f = (CL_GLFunctions::ptr_glMap1f) CL_OpenGL::get_proc_address(&quot;glMap1f&quot;);
+	functions-&gt;map2d = (CL_GLFunctions::ptr_glMap2d) CL_OpenGL::get_proc_address(&quot;glMap2d&quot;);
+	functions-&gt;map2f = (CL_GLFunctions::ptr_glMap2f) CL_OpenGL::get_proc_address(&quot;glMap2f&quot;);
+	functions-&gt;mapGrid1d = (CL_GLFunctions::ptr_glMapGrid1d) CL_OpenGL::get_proc_address(&quot;glMapGrid1d&quot;);
+	functions-&gt;mapGrid1f = (CL_GLFunctions::ptr_glMapGrid1f) CL_OpenGL::get_proc_address(&quot;glMapGrid1f&quot;);
+	functions-&gt;mapGrid2d = (CL_GLFunctions::ptr_glMapGrid2d) CL_OpenGL::get_proc_address(&quot;glMapGrid2d&quot;);
+	functions-&gt;mapGrid2f = (CL_GLFunctions::ptr_glMapGrid2f) CL_OpenGL::get_proc_address(&quot;glMapGrid2f&quot;);
+	functions-&gt;materialf = (CL_GLFunctions::ptr_glMaterialf) CL_OpenGL::get_proc_address(&quot;glMaterialf&quot;);
+	functions-&gt;materialfv = (CL_GLFunctions::ptr_glMaterialfv) CL_OpenGL::get_proc_address(&quot;glMaterialfv&quot;);
+	functions-&gt;materiali = (CL_GLFunctions::ptr_glMateriali) CL_OpenGL::get_proc_address(&quot;glMateriali&quot;);
+	functions-&gt;materialiv = (CL_GLFunctions::ptr_glMaterialiv) CL_OpenGL::get_proc_address(&quot;glMaterialiv&quot;);
+	functions-&gt;matrixMode = (CL_GLFunctions::ptr_glMatrixMode) CL_OpenGL::get_proc_address(&quot;glMatrixMode&quot;);
+	functions-&gt;multMatrixd = (CL_GLFunctions::ptr_glMultMatrixd) CL_OpenGL::get_proc_address(&quot;glMultMatrixd&quot;);
+	functions-&gt;multMatrixf = (CL_GLFunctions::ptr_glMultMatrixf) CL_OpenGL::get_proc_address(&quot;glMultMatrixf&quot;);
+	functions-&gt;newList = (CL_GLFunctions::ptr_glNewList) CL_OpenGL::get_proc_address(&quot;glNewList&quot;);
+	functions-&gt;normal3b = (CL_GLFunctions::ptr_glNormal3b) CL_OpenGL::get_proc_address(&quot;glNormal3b&quot;);
+	functions-&gt;normal3bv = (CL_GLFunctions::ptr_glNormal3bv) CL_OpenGL::get_proc_address(&quot;glNormal3bv&quot;);
+	functions-&gt;normal3d = (CL_GLFunctions::ptr_glNormal3d) CL_OpenGL::get_proc_address(&quot;glNormal3d&quot;);
+	functions-&gt;normal3dv = (CL_GLFunctions::ptr_glNormal3dv) CL_OpenGL::get_proc_address(&quot;glNormal3dv&quot;);
+	functions-&gt;normal3f = (CL_GLFunctions::ptr_glNormal3f) CL_OpenGL::get_proc_address(&quot;glNormal3f&quot;);
+	functions-&gt;normal3fv = (CL_GLFunctions::ptr_glNormal3fv) CL_OpenGL::get_proc_address(&quot;glNormal3fv&quot;);
+	functions-&gt;normal3i = (CL_GLFunctions::ptr_glNormal3i) CL_OpenGL::get_proc_address(&quot;glNormal3i&quot;);
+	functions-&gt;normal3iv = (CL_GLFunctions::ptr_glNormal3iv) CL_OpenGL::get_proc_address(&quot;glNormal3iv&quot;);
+	functions-&gt;normal3s = (CL_GLFunctions::ptr_glNormal3s) CL_OpenGL::get_proc_address(&quot;glNormal3s&quot;);
+	functions-&gt;normal3sv = (CL_GLFunctions::ptr_glNormal3sv) CL_OpenGL::get_proc_address(&quot;glNormal3sv&quot;);
+	functions-&gt;normalPointer = (CL_GLFunctions::ptr_glNormalPointer) CL_OpenGL::get_proc_address(&quot;glNormalPointer&quot;);
+	functions-&gt;ortho = (CL_GLFunctions::ptr_glOrtho) CL_OpenGL::get_proc_address(&quot;glOrtho&quot;);
+	functions-&gt;passThrough = (CL_GLFunctions::ptr_glPassThrough) CL_OpenGL::get_proc_address(&quot;glPassThrough&quot;);
+	functions-&gt;pixelMapfv = (CL_GLFunctions::ptr_glPixelMapfv) CL_OpenGL::get_proc_address(&quot;glPixelMapfv&quot;);
+	functions-&gt;pixelMapuiv = (CL_GLFunctions::ptr_glPixelMapuiv) CL_OpenGL::get_proc_address(&quot;glPixelMapuiv&quot;);
+	functions-&gt;pixelMapusv = (CL_GLFunctions::ptr_glPixelMapusv) CL_OpenGL::get_proc_address(&quot;glPixelMapusv&quot;);
+	functions-&gt;pixelStoref = (CL_GLFunctions::ptr_glPixelStoref) CL_OpenGL::get_proc_address(&quot;glPixelStoref&quot;);
+	functions-&gt;pixelStorei = (CL_GLFunctions::ptr_glPixelStorei) CL_OpenGL::get_proc_address(&quot;glPixelStorei&quot;);
+	functions-&gt;pixelTransferf = (CL_GLFunctions::ptr_glPixelTransferf) CL_OpenGL::get_proc_address(&quot;glPixelTransferf&quot;);
+	functions-&gt;pixelTransferi = (CL_GLFunctions::ptr_glPixelTransferi) CL_OpenGL::get_proc_address(&quot;glPixelTransferi&quot;);
+	functions-&gt;pixelZoom = (CL_GLFunctions::ptr_glPixelZoom) CL_OpenGL::get_proc_address(&quot;glPixelZoom&quot;);
+	functions-&gt;pointSize = (CL_GLFunctions::ptr_glPointSize) CL_OpenGL::get_proc_address(&quot;glPointSize&quot;);
+	functions-&gt;polygonMode = (CL_GLFunctions::ptr_glPolygonMode) CL_OpenGL::get_proc_address(&quot;glPolygonMode&quot;);
+	functions-&gt;polygonOffset = (CL_GLFunctions::ptr_glPolygonOffset) CL_OpenGL::get_proc_address(&quot;glPolygonOffset&quot;);
+	functions-&gt;polygonStipple = (CL_GLFunctions::ptr_glPolygonStipple) CL_OpenGL::get_proc_address(&quot;glPolygonStipple&quot;);
+	functions-&gt;popAttrib = (CL_GLFunctions::ptr_glPopAttrib) CL_OpenGL::get_proc_address(&quot;glPopAttrib&quot;);
+	functions-&gt;popClientAttrib = (CL_GLFunctions::ptr_glPopClientAttrib) CL_OpenGL::get_proc_address(&quot;glPopClientAttrib&quot;);
+	functions-&gt;popMatrix = (CL_GLFunctions::ptr_glPopMatrix) CL_OpenGL::get_proc_address(&quot;glPopMatrix&quot;);
+	functions-&gt;popName = (CL_GLFunctions::ptr_glPopName) CL_OpenGL::get_proc_address(&quot;glPopName&quot;);
+	functions-&gt;prioritizeTextures = (CL_GLFunctions::ptr_glPrioritizeTextures) CL_OpenGL::get_proc_address(&quot;glPrioritizeTextures&quot;);
+	functions-&gt;pushAttrib = (CL_GLFunctions::ptr_glPushAttrib) CL_OpenGL::get_proc_address(&quot;glPushAttrib&quot;);
+	functions-&gt;pushClientAttrib = (CL_GLFunctions::ptr_glPushClientAttrib) CL_OpenGL::get_proc_address(&quot;glPushClientAttrib&quot;);
+	functions-&gt;pushMatrix = (CL_GLFunctions::ptr_glPushMatrix) CL_OpenGL::get_proc_address(&quot;glPushMatrix&quot;);
+	functions-&gt;pushName = (CL_GLFunctions::ptr_glPushName) CL_OpenGL::get_proc_address(&quot;glPushName&quot;);
+	functions-&gt;rasterPos2d = (CL_GLFunctions::ptr_glRasterPos2d) CL_OpenGL::get_proc_address(&quot;glRasterPos2d&quot;);
+	functions-&gt;rasterPos2dv = (CL_GLFunctions::ptr_glRasterPos2dv) CL_OpenGL::get_proc_address(&quot;glRasterPos2dv&quot;);
+	functions-&gt;rasterPos2f = (CL_GLFunctions::ptr_glRasterPos2f) CL_OpenGL::get_proc_address(&quot;glRasterPos2f&quot;);
+	functions-&gt;rasterPos2fv = (CL_GLFunctions::ptr_glRasterPos2fv) CL_OpenGL::get_proc_address(&quot;glRasterPos2fv&quot;);
+	functions-&gt;rasterPos2i = (CL_GLFunctions::ptr_glRasterPos2i) CL_OpenGL::get_proc_address(&quot;glRasterPos2i&quot;);
+	functions-&gt;rasterPos2iv = (CL_GLFunctions::ptr_glRasterPos2iv) CL_OpenGL::get_proc_address(&quot;glRasterPos2iv&quot;);
+	functions-&gt;rasterPos2s = (CL_GLFunctions::ptr_glRasterPos2s) CL_OpenGL::get_proc_address(&quot;glRasterPos2s&quot;);
+	functions-&gt;rasterPos2sv = (CL_GLFunctions::ptr_glRasterPos2sv) CL_OpenGL::get_proc_address(&quot;glRasterPos2sv&quot;);
+	functions-&gt;rasterPos3d = (CL_GLFunctions::ptr_glRasterPos3d) CL_OpenGL::get_proc_address(&quot;glRasterPos3d&quot;);
+	functions-&gt;rasterPos3dv = (CL_GLFunctions::ptr_glRasterPos3dv) CL_OpenGL::get_proc_address(&quot;glRasterPos3dv&quot;);
+	functions-&gt;rasterPos3f = (CL_GLFunctions::ptr_glRasterPos3f) CL_OpenGL::get_proc_address(&quot;glRasterPos3f&quot;);
+	functions-&gt;rasterPos3fv = (CL_GLFunctions::ptr_glRasterPos3fv) CL_OpenGL::get_proc_address(&quot;glRasterPos3fv&quot;);
+	functions-&gt;rasterPos3i = (CL_GLFunctions::ptr_glRasterPos3i) CL_OpenGL::get_proc_address(&quot;glRasterPos3i&quot;);
+	functions-&gt;rasterPos3iv = (CL_GLFunctions::ptr_glRasterPos3iv) CL_OpenGL::get_proc_address(&quot;glRasterPos3iv&quot;);
+	functions-&gt;rasterPos3s = (CL_GLFunctions::ptr_glRasterPos3s) CL_OpenGL::get_proc_address(&quot;glRasterPos3s&quot;);
+	functions-&gt;rasterPos3sv = (CL_GLFunctions::ptr_glRasterPos3sv) CL_OpenGL::get_proc_address(&quot;glRasterPos3sv&quot;);
+	functions-&gt;rasterPos4d = (CL_GLFunctions::ptr_glRasterPos4d) CL_OpenGL::get_proc_address(&quot;glRasterPos4d&quot;);
+	functions-&gt;rasterPos4dv = (CL_GLFunctions::ptr_glRasterPos4dv) CL_OpenGL::get_proc_address(&quot;glRasterPos4dv&quot;);
+	functions-&gt;rasterPos4f = (CL_GLFunctions::ptr_glRasterPos4f) CL_OpenGL::get_proc_address(&quot;glRasterPos4f&quot;);
+	functions-&gt;rasterPos4fv = (CL_GLFunctions::ptr_glRasterPos4fv) CL_OpenGL::get_proc_address(&quot;glRasterPos4fv&quot;);
+	functions-&gt;rasterPos4i = (CL_GLFunctions::ptr_glRasterPos4i) CL_OpenGL::get_proc_address(&quot;glRasterPos4i&quot;);
+	functions-&gt;rasterPos4iv = (CL_GLFunctions::ptr_glRasterPos4iv) CL_OpenGL::get_proc_address(&quot;glRasterPos4iv&quot;);
+	functions-&gt;rasterPos4s = (CL_GLFunctions::ptr_glRasterPos4s) CL_OpenGL::get_proc_address(&quot;glRasterPos4s&quot;);
+	functions-&gt;rasterPos4sv = (CL_GLFunctions::ptr_glRasterPos4sv) CL_OpenGL::get_proc_address(&quot;glRasterPos4sv&quot;);
+	functions-&gt;readBuffer = (CL_GLFunctions::ptr_glReadBuffer) CL_OpenGL::get_proc_address(&quot;glReadBuffer&quot;);
+	functions-&gt;readPixels = (CL_GLFunctions::ptr_glReadPixels) CL_OpenGL::get_proc_address(&quot;glReadPixels&quot;);
+	functions-&gt;rectd = (CL_GLFunctions::ptr_glRectd) CL_OpenGL::get_proc_address(&quot;glRectd&quot;);
+	functions-&gt;rectdv = (CL_GLFunctions::ptr_glRectdv) CL_OpenGL::get_proc_address(&quot;glRectdv&quot;);
+	functions-&gt;rectf = (CL_GLFunctions::ptr_glRectf) CL_OpenGL::get_proc_address(&quot;glRectf&quot;);
+	functions-&gt;rectfv = (CL_GLFunctions::ptr_glRectfv) CL_OpenGL::get_proc_address(&quot;glRectfv&quot;);
+	functions-&gt;recti = (CL_GLFunctions::ptr_glRecti) CL_OpenGL::get_proc_address(&quot;glRecti&quot;);
+	functions-&gt;rectiv = (CL_GLFunctions::ptr_glRectiv) CL_OpenGL::get_proc_address(&quot;glRectiv&quot;);
+	functions-&gt;rects = (CL_GLFunctions::ptr_glRects) CL_OpenGL::get_proc_address(&quot;glRects&quot;);
+	functions-&gt;rectsv = (CL_GLFunctions::ptr_glRectsv) CL_OpenGL::get_proc_address(&quot;glRectsv&quot;);
+	functions-&gt;renderMode = (CL_GLFunctions::ptr_glRenderMode) CL_OpenGL::get_proc_address(&quot;glRenderMode&quot;);
+	functions-&gt;rotated = (CL_GLFunctions::ptr_glRotated) CL_OpenGL::get_proc_address(&quot;glRotated&quot;);
+	functions-&gt;rotatef = (CL_GLFunctions::ptr_glRotatef) CL_OpenGL::get_proc_address(&quot;glRotatef&quot;);
+	functions-&gt;scaled = (CL_GLFunctions::ptr_glScaled) CL_OpenGL::get_proc_address(&quot;glScaled&quot;);
+	functions-&gt;scalef = (CL_GLFunctions::ptr_glScalef) CL_OpenGL::get_proc_address(&quot;glScalef&quot;);
+	functions-&gt;scissor = (CL_GLFunctions::ptr_glScissor) CL_OpenGL::get_proc_address(&quot;glScissor&quot;);
+	functions-&gt;selectBuffer = (CL_GLFunctions::ptr_glSelectBuffer) CL_OpenGL::get_proc_address(&quot;glSelectBuffer&quot;);
+	functions-&gt;shadeModel = (CL_GLFunctions::ptr_glShadeModel) CL_OpenGL::get_proc_address(&quot;glShadeModel&quot;);
+	functions-&gt;stencilFunc = (CL_GLFunctions::ptr_glStencilFunc) CL_OpenGL::get_proc_address(&quot;glStencilFunc&quot;);
+	functions-&gt;stencilMask = (CL_GLFunctions::ptr_glStencilMask) CL_OpenGL::get_proc_address(&quot;glStencilMask&quot;);
+	functions-&gt;stencilOp = (CL_GLFunctions::ptr_glStencilOp) CL_OpenGL::get_proc_address(&quot;glStencilOp&quot;);
+	functions-&gt;texCoord1d = (CL_GLFunctions::ptr_glTexCoord1d) CL_OpenGL::get_proc_address(&quot;glTexCoord1d&quot;);
+	functions-&gt;texCoord1dv = (CL_GLFunctions::ptr_glTexCoord1dv) CL_OpenGL::get_proc_address(&quot;glTexCoord1dv&quot;);
+	functions-&gt;texCoord1f = (CL_GLFunctions::ptr_glTexCoord1f) CL_OpenGL::get_proc_address(&quot;glTexCoord1f&quot;);
+	functions-&gt;texCoord1fv = (CL_GLFunctions::ptr_glTexCoord1fv) CL_OpenGL::get_proc_address(&quot;glTexCoord1fv&quot;);
+	functions-&gt;texCoord1i = (CL_GLFunctions::ptr_glTexCoord1i) CL_OpenGL::get_proc_address(&quot;glTexCoord1i&quot;);
+	functions-&gt;texCoord1iv = (CL_GLFunctions::ptr_glTexCoord1iv) CL_OpenGL::get_proc_address(&quot;glTexCoord1iv&quot;);
+	functions-&gt;texCoord1s = (CL_GLFunctions::ptr_glTexCoord1s) CL_OpenGL::get_proc_address(&quot;glTexCoord1s&quot;);
+	functions-&gt;texCoord1sv = (CL_GLFunctions::ptr_glTexCoord1sv) CL_OpenGL::get_proc_address(&quot;glTexCoord1sv&quot;);
+	functions-&gt;texCoord2d = (CL_GLFunctions::ptr_glTexCoord2d) CL_OpenGL::get_proc_address(&quot;glTexCoord2d&quot;);
+	functions-&gt;texCoord2dv = (CL_GLFunctions::ptr_glTexCoord2dv) CL_OpenGL::get_proc_address(&quot;glTexCoord2dv&quot;);
+	functions-&gt;texCoord2f = (CL_GLFunctions::ptr_glTexCoord2f) CL_OpenGL::get_proc_address(&quot;glTexCoord2f&quot;);
+	functions-&gt;texCoord2fv = (CL_GLFunctions::ptr_glTexCoord2fv) CL_OpenGL::get_proc_address(&quot;glTexCoord2fv&quot;);
+	functions-&gt;texCoord2i = (CL_GLFunctions::ptr_glTexCoord2i) CL_OpenGL::get_proc_address(&quot;glTexCoord2i&quot;);
+	functions-&gt;texCoord2iv = (CL_GLFunctions::ptr_glTexCoord2iv) CL_OpenGL::get_proc_address(&quot;glTexCoord2iv&quot;);
+	functions-&gt;texCoord2s = (CL_GLFunctions::ptr_glTexCoord2s) CL_OpenGL::get_proc_address(&quot;glTexCoord2s&quot;);
+	functions-&gt;texCoord2sv = (CL_GLFunctions::ptr_glTexCoord2sv) CL_OpenGL::get_proc_address(&quot;glTexCoord2sv&quot;);
+	functions-&gt;texCoord3d = (CL_GLFunctions::ptr_glTexCoord3d) CL_OpenGL::get_proc_address(&quot;glTexCoord3d&quot;);
+	functions-&gt;texCoord3dv = (CL_GLFunctions::ptr_glTexCoord3dv) CL_OpenGL::get_proc_address(&quot;glTexCoord3dv&quot;);
+	functions-&gt;texCoord3f = (CL_GLFunctions::ptr_glTexCoord3f) CL_OpenGL::get_proc_address(&quot;glTexCoord3f&quot;);
+	functions-&gt;texCoord3fv = (CL_GLFunctions::ptr_glTexCoord3fv) CL_OpenGL::get_proc_address(&quot;glTexCoord3fv&quot;);
+	functions-&gt;texCoord3i = (CL_GLFunctions::ptr_glTexCoord3i) CL_OpenGL::get_proc_address(&quot;glTexCoord3i&quot;);
+	functions-&gt;texCoord3iv = (CL_GLFunctions::ptr_glTexCoord3iv) CL_OpenGL::get_proc_address(&quot;glTexCoord3iv&quot;);
+	functions-&gt;texCoord3s = (CL_GLFunctions::ptr_glTexCoord3s) CL_OpenGL::get_proc_address(&quot;glTexCoord3s&quot;);
+	functions-&gt;texCoord3sv = (CL_GLFunctions::ptr_glTexCoord3sv) CL_OpenGL::get_proc_address(&quot;glTexCoord3sv&quot;);
+	functions-&gt;texCoord4d = (CL_GLFunctions::ptr_glTexCoord4d) CL_OpenGL::get_proc_address(&quot;glTexCoord4d&quot;);
+	functions-&gt;texCoord4dv = (CL_GLFunctions::ptr_glTexCoord4dv) CL_OpenGL::get_proc_address(&quot;glTexCoord4dv&quot;);
+	functions-&gt;texCoord4f = (CL_GLFunctions::ptr_glTexCoord4f) CL_OpenGL::get_proc_address(&quot;glTexCoord4f&quot;);
+	functions-&gt;texCoord4fv = (CL_GLFunctions::ptr_glTexCoord4fv) CL_OpenGL::get_proc_address(&quot;glTexCoord4fv&quot;);
+	functions-&gt;texCoord4i = (CL_GLFunctions::ptr_glTexCoord4i) CL_OpenGL::get_proc_address(&quot;glTexCoord4i&quot;);
+	functions-&gt;texCoord4iv = (CL_GLFunctions::ptr_glTexCoord4iv) CL_OpenGL::get_proc_address(&quot;glTexCoord4iv&quot;);
+	functions-&gt;texCoord4s = (CL_GLFunctions::ptr_glTexCoord4s) CL_OpenGL::get_proc_address(&quot;glTexCoord4s&quot;);
+	functions-&gt;texCoord4sv = (CL_GLFunctions::ptr_glTexCoord4sv) CL_OpenGL::get_proc_address(&quot;glTexCoord4sv&quot;);
+	functions-&gt;texCoordPointer = (CL_GLFunctions::ptr_glTexCoordPointer) CL_OpenGL::get_proc_address(&quot;glTexCoordPointer&quot;);
+	functions-&gt;texEnvf = (CL_GLFunctions::ptr_glTexEnvf) CL_OpenGL::get_proc_address(&quot;glTexEnvf&quot;);
+	functions-&gt;texEnvfv = (CL_GLFunctions::ptr_glTexEnvfv) CL_OpenGL::get_proc_address(&quot;glTexEnvfv&quot;);
+	functions-&gt;texEnvi = (CL_GLFunctions::ptr_glTexEnvi) CL_OpenGL::get_proc_address(&quot;glTexEnvi&quot;);
+	functions-&gt;texEnviv = (CL_GLFunctions::ptr_glTexEnviv) CL_OpenGL::get_proc_address(&quot;glTexEnviv&quot;);
+	functions-&gt;texGend = (CL_GLFunctions::ptr_glTexGend) CL_OpenGL::get_proc_address(&quot;glTexGend&quot;);
+	functions-&gt;texGendv = (CL_GLFunctions::ptr_glTexGendv) CL_OpenGL::get_proc_address(&quot;glTexGendv&quot;);
+	functions-&gt;texGenf = (CL_GLFunctions::ptr_glTexGenf) CL_OpenGL::get_proc_address(&quot;glTexGenf&quot;);
+	functions-&gt;texGenfv = (CL_GLFunctions::ptr_glTexGenfv) CL_OpenGL::get_proc_address(&quot;glTexGenfv&quot;);
+	functions-&gt;texGeni = (CL_GLFunctions::ptr_glTexGeni) CL_OpenGL::get_proc_address(&quot;glTexGeni&quot;);
+	functions-&gt;texGeniv = (CL_GLFunctions::ptr_glTexGeniv) CL_OpenGL::get_proc_address(&quot;glTexGeniv&quot;);
+	functions-&gt;texImage1D = (CL_GLFunctions::ptr_glTexImage1D) CL_OpenGL::get_proc_address(&quot;glTexImage1D&quot;);
+	functions-&gt;texImage2D = (CL_GLFunctions::ptr_glTexImage2D) CL_OpenGL::get_proc_address(&quot;glTexImage2D&quot;);
+	functions-&gt;texParameterf = (CL_GLFunctions::ptr_glTexParameterf) CL_OpenGL::get_proc_address(&quot;glTexParameterf&quot;);
+	functions-&gt;texParameterfv = (CL_GLFunctions::ptr_glTexParameterfv) CL_OpenGL::get_proc_address(&quot;glTexParameterfv&quot;);
+	functions-&gt;texParameteri = (CL_GLFunctions::ptr_glTexParameteri) CL_OpenGL::get_proc_address(&quot;glTexParameteri&quot;);
+	functions-&gt;texParameteriv = (CL_GLFunctions::ptr_glTexParameteriv) CL_OpenGL::get_proc_address(&quot;glTexParameteriv&quot;);
+	functions-&gt;texSubImage1D = (CL_GLFunctions::ptr_glTexSubImage1D) CL_OpenGL::get_proc_address(&quot;glTexSubImage1D&quot;);
+	functions-&gt;texSubImage2D = (CL_GLFunctions::ptr_glTexSubImage2D) CL_OpenGL::get_proc_address(&quot;glTexSubImage2D&quot;);
+	functions-&gt;translated = (CL_GLFunctions::ptr_glTranslated) CL_OpenGL::get_proc_address(&quot;glTranslated&quot;);
+	functions-&gt;translatef = (CL_GLFunctions::ptr_glTranslatef) CL_OpenGL::get_proc_address(&quot;glTranslatef&quot;);
+	functions-&gt;vertex2d = (CL_GLFunctions::ptr_glVertex2d) CL_OpenGL::get_proc_address(&quot;glVertex2d&quot;);
+	functions-&gt;vertex2dv = (CL_GLFunctions::ptr_glVertex2dv) CL_OpenGL::get_proc_address(&quot;glVertex2dv&quot;);
+	functions-&gt;vertex2f = (CL_GLFunctions::ptr_glVertex2f) CL_OpenGL::get_proc_address(&quot;glVertex2f&quot;);
+	functions-&gt;vertex2fv = (CL_GLFunctions::ptr_glVertex2fv) CL_OpenGL::get_proc_address(&quot;glVertex2fv&quot;);
+	functions-&gt;vertex2i = (CL_GLFunctions::ptr_glVertex2i) CL_OpenGL::get_proc_address(&quot;glVertex2i&quot;);
+	functions-&gt;vertex2iv = (CL_GLFunctions::ptr_glVertex2iv) CL_OpenGL::get_proc_address(&quot;glVertex2iv&quot;);
+	functions-&gt;vertex2s = (CL_GLFunctions::ptr_glVertex2s) CL_OpenGL::get_proc_address(&quot;glVertex2s&quot;);
+	functions-&gt;vertex2sv = (CL_GLFunctions::ptr_glVertex2sv) CL_OpenGL::get_proc_address(&quot;glVertex2sv&quot;);
+	functions-&gt;vertex3d = (CL_GLFunctions::ptr_glVertex3d) CL_OpenGL::get_proc_address(&quot;glVertex3d&quot;);
+	functions-&gt;vertex3dv = (CL_GLFunctions::ptr_glVertex3dv) CL_OpenGL::get_proc_address(&quot;glVertex3dv&quot;);
+	functions-&gt;vertex3f = (CL_GLFunctions::ptr_glVertex3f) CL_OpenGL::get_proc_address(&quot;glVertex3f&quot;);
+	functions-&gt;vertex3fv = (CL_GLFunctions::ptr_glVertex3fv) CL_OpenGL::get_proc_address(&quot;glVertex3fv&quot;);
+	functions-&gt;vertex3i = (CL_GLFunctions::ptr_glVertex3i) CL_OpenGL::get_proc_address(&quot;glVertex3i&quot;);
+	functions-&gt;vertex3iv = (CL_GLFunctions::ptr_glVertex3iv) CL_OpenGL::get_proc_address(&quot;glVertex3iv&quot;);
+	functions-&gt;vertex3s = (CL_GLFunctions::ptr_glVertex3s) CL_OpenGL::get_proc_address(&quot;glVertex3s&quot;);
+	functions-&gt;vertex3sv = (CL_GLFunctions::ptr_glVertex3sv) CL_OpenGL::get_proc_address(&quot;glVertex3sv&quot;);
+	functions-&gt;vertex4d = (CL_GLFunctions::ptr_glVertex4d) CL_OpenGL::get_proc_address(&quot;glVertex4d&quot;);
+	functions-&gt;vertex4dv = (CL_GLFunctions::ptr_glVertex4dv) CL_OpenGL::get_proc_address(&quot;glVertex4dv&quot;);
+	functions-&gt;vertex4f = (CL_GLFunctions::ptr_glVertex4f) CL_OpenGL::get_proc_address(&quot;glVertex4f&quot;);
+	functions-&gt;vertex4fv = (CL_GLFunctions::ptr_glVertex4fv) CL_OpenGL::get_proc_address(&quot;glVertex4fv&quot;);
+	functions-&gt;vertex4i = (CL_GLFunctions::ptr_glVertex4i) CL_OpenGL::get_proc_address(&quot;glVertex4i&quot;);
+	functions-&gt;vertex4iv = (CL_GLFunctions::ptr_glVertex4iv) CL_OpenGL::get_proc_address(&quot;glVertex4iv&quot;);
+	functions-&gt;vertex4s = (CL_GLFunctions::ptr_glVertex4s) CL_OpenGL::get_proc_address(&quot;glVertex4s&quot;);
+	functions-&gt;vertex4sv = (CL_GLFunctions::ptr_glVertex4sv) CL_OpenGL::get_proc_address(&quot;glVertex4sv&quot;);
+	functions-&gt;vertexPointer = (CL_GLFunctions::ptr_glVertexPointer) CL_OpenGL::get_proc_address(&quot;glVertexPointer&quot;);
+	functions-&gt;viewport = (CL_GLFunctions::ptr_glViewport) CL_OpenGL::get_proc_address(&quot;glViewport&quot;);
+#endif
+
+	// Binds for OpenGL 1.2:
+
+#ifdef __APPLE__
+	functions-&gt;drawRangeElements = (CL_GLFunctions::ptr_glDrawRangeElementsEXT) &glDrawRangeElements;
+	functions-&gt;texImage3D = (CL_GLFunctions::ptr_glTexImage3DEXT) &amp;glTexImage3D;
+	functions-&gt;texSubImage3D = (CL_GLFunctions::ptr_glTexSubImage3DEXT) &amp;glTexSubImage3D;
+	functions-&gt;copyTexSubImage3D = (CL_GLFunctions::ptr_glCopyTexSubImage3DEXT) &amp;glCopyTexSubImage3D;
+	functions-&gt;colorTable = (CL_GLFunctions::ptr_glColorTableSGI) &glColorTable;
+	functions-&gt;copyColorTable = (CL_GLFunctions::ptr_glCopyColorTableSGI) &glCopyColorTable;
+	functions-&gt;colorTableParameteriv = (CL_GLFunctions::ptr_glColorTableParameterivSGI) &glColorTableParameteriv;
+	functions-&gt;colorTableParameterfv = (CL_GLFunctions::ptr_glColorTableParameterfvSGI) &glColorTableParameterfv;
+	functions-&gt;getColorTable = (CL_GLFunctions::ptr_glGetColorTableSGI) &glGetColorTable;
+	functions-&gt;getColorTableParameteriv = (CL_GLFunctions::ptr_glGetColorTableParameterivSGI) &glGetColorTableParameteriv;
+	functions-&gt;getColorTableParameterfv = (CL_GLFunctions::ptr_glGetColorTableParameterfvSGI) &glGetColorTableParameterfv;
+	functions-&gt;colorSubTable = (CL_GLFunctions::ptr_glColorSubTableEXT) &glColorSubTable;
+	functions-&gt;copyColorSubTable = (CL_GLFunctions::ptr_glCopyColorSubTableEXT) &glCopyColorSubTable;
+	functions-&gt;convolutionFilter1D = (CL_GLFunctions::ptr_glConvolutionFilter1DEXT) &amp;glConvolutionFilter1D;
+	functions-&gt;convolutionFilter2D = (CL_GLFunctions::ptr_glConvolutionFilter2DEXT) &amp;glConvolutionFilter2D;
+	functions-&gt;copyConvolutionFilter1D = (CL_GLFunctions::ptr_glCopyConvolutionFilter1DEXT) &amp;glCopyConvolutionFilter1D;
+	functions-&gt;copyConvolutionFilter2D = (CL_GLFunctions::ptr_glCopyConvolutionFilter2DEXT) &amp;glCopyConvolutionFilter2D;
+	functions-&gt;getConvolutionFilter = (CL_GLFunctions::ptr_glGetConvolutionFilterEXT) &glGetConvolutionFilter;
+	functions-&gt;separableFilter2D = (CL_GLFunctions::ptr_glSeparableFilter2DEXT) &amp;glSeparableFilter2D;
+	functions-&gt;getSeparableFilter = (CL_GLFunctions::ptr_glGetSeparableFilterEXT) &glGetSeparableFilter;
+	functions-&gt;convolutionParameteri = (CL_GLFunctions::ptr_glConvolutionParameteriEXT) &glConvolutionParameteri;
+	functions-&gt;convolutionParameteriv = (CL_GLFunctions::ptr_glConvolutionParameterivEXT) &glConvolutionParameteriv;
+	functions-&gt;convolutionParameterf = (CL_GLFunctions::ptr_glConvolutionParameterfEXT) &glConvolutionParameterf;
+	functions-&gt;convolutionParameterfv = (CL_GLFunctions::ptr_glConvolutionParameterfvEXT) &glConvolutionParameterfv;
+	functions-&gt;getConvolutionParameteriv = (CL_GLFunctions::ptr_glGetConvolutionParameterivEXT) &glGetConvolutionParameteriv;
+	functions-&gt;getConvolutionParameterfv = (CL_GLFunctions::ptr_glGetConvolutionParameterfvEXT) &glGetConvolutionParameterfv;
+	functions-&gt;histogram = (CL_GLFunctions::ptr_glHistogramEXT) &glHistogram;
+	functions-&gt;resetHistogram = (CL_GLFunctions::ptr_glResetHistogramEXT) &glResetHistogram;
+	functions-&gt;getHistogram = (CL_GLFunctions::ptr_glGetHistogramEXT) &glGetHistogram;
+	functions-&gt;getHistogramParameteriv = (CL_GLFunctions::ptr_glGetHistogramParameterivEXT) &glGetHistogramParameteriv;
+	functions-&gt;getHistogramParameterfv = (CL_GLFunctions::ptr_glGetHistogramParameterfvEXT) &glGetHistogramParameterfv;
+	functions-&gt;minmax = (CL_GLFunctions::ptr_glMinmaxEXT) &glMinmax;
+	functions-&gt;resetMinmax = (CL_GLFunctions::ptr_glResetMinmaxEXT) &glResetMinmax;
+	functions-&gt;getMinmax = (CL_GLFunctions::ptr_glGetMinmaxEXT) &glGetMinmax;
+	functions-&gt;getMinmaxParameteriv = (CL_GLFunctions::ptr_glGetMinmaxParameterivEXT) &glGetMinmaxParameteriv;
+	functions-&gt;getMinmaxParameterfv = (CL_GLFunctions::ptr_glGetMinmaxParameterfvEXT) &glGetMinmaxParameterfv;
+	functions-&gt;blendColor = (CL_GLFunctions::ptr_glBlendColorEXT) &glBlendColor;
+	functions-&gt;blendEquation = (CL_GLFunctions::ptr_glBlendEquationEXT) &glBlendEquation;
+#else
+	functions-&gt;drawRangeElements = (CL_GLFunctions::ptr_glDrawRangeElementsEXT) CL_OpenGL::get_proc_address(&quot;glDrawRangeElementsEXT&quot;);
+	functions-&gt;texImage3D = (CL_GLFunctions::ptr_glTexImage3DEXT) CL_OpenGL::get_proc_address(&quot;glTexImage3DEXT&quot;);
+	functions-&gt;texSubImage3D = (CL_GLFunctions::ptr_glTexSubImage3DEXT) CL_OpenGL::get_proc_address(&quot;glTexSubImage3DEXT&quot;);
+	functions-&gt;copyTexSubImage3D = (CL_GLFunctions::ptr_glCopyTexSubImage3DEXT) CL_OpenGL::get_proc_address(&quot;glCopyTexSubImage3DEXT&quot;);
+	functions-&gt;colorTable = (CL_GLFunctions::ptr_glColorTableSGI) CL_OpenGL::get_proc_address(&quot;glColorTableSGI&quot;);
+	functions-&gt;copyColorTable = (CL_GLFunctions::ptr_glCopyColorTableSGI) CL_OpenGL::get_proc_address(&quot;glCopyColorTableSGI&quot;);
+	functions-&gt;colorTableParameteriv = (CL_GLFunctions::ptr_glColorTableParameterivSGI) CL_OpenGL::get_proc_address(&quot;glColorTableParameterivSGI&quot;);
+	functions-&gt;colorTableParameterfv = (CL_GLFunctions::ptr_glColorTableParameterfvSGI) CL_OpenGL::get_proc_address(&quot;glColorTableParameterfvSGI&quot;);
+	functions-&gt;getColorTable = (CL_GLFunctions::ptr_glGetColorTableSGI) CL_OpenGL::get_proc_address(&quot;glGetColorTableSGI&quot;);
+	functions-&gt;getColorTableParameteriv = (CL_GLFunctions::ptr_glGetColorTableParameterivSGI) CL_OpenGL::get_proc_address(&quot;glGetColorTableParameterivSGI&quot;);
+	functions-&gt;getColorTableParameterfv = (CL_GLFunctions::ptr_glGetColorTableParameterfvSGI) CL_OpenGL::get_proc_address(&quot;glGetColorTableParameterfvSGI&quot;);
+	functions-&gt;colorSubTable = (CL_GLFunctions::ptr_glColorSubTableEXT) CL_OpenGL::get_proc_address(&quot;glColorSubTableEXT&quot;);
+	functions-&gt;copyColorSubTable = (CL_GLFunctions::ptr_glCopyColorSubTableEXT) CL_OpenGL::get_proc_address(&quot;glCopyColorSubTableEXT&quot;);
+	functions-&gt;convolutionFilter1D = (CL_GLFunctions::ptr_glConvolutionFilter1DEXT) CL_OpenGL::get_proc_address(&quot;glConvolutionFilter1DEXT&quot;);
+	functions-&gt;convolutionFilter2D = (CL_GLFunctions::ptr_glConvolutionFilter2DEXT) CL_OpenGL::get_proc_address(&quot;glConvolutionFilter2DEXT&quot;);
+	functions-&gt;copyConvolutionFilter1D = (CL_GLFunctions::ptr_glCopyConvolutionFilter1DEXT) CL_OpenGL::get_proc_address(&quot;glCopyConvolutionFilter1DEXT&quot;);
+	functions-&gt;copyConvolutionFilter2D = (CL_GLFunctions::ptr_glCopyConvolutionFilter2DEXT) CL_OpenGL::get_proc_address(&quot;glCopyConvolutionFilter2DEXT&quot;);
+	functions-&gt;getConvolutionFilter = (CL_GLFunctions::ptr_glGetConvolutionFilterEXT) CL_OpenGL::get_proc_address(&quot;glGetConvolutionFilterEXT&quot;);
+	functions-&gt;separableFilter2D = (CL_GLFunctions::ptr_glSeparableFilter2DEXT) CL_OpenGL::get_proc_address(&quot;glSeparableFilter2DEXT&quot;);
+	functions-&gt;getSeparableFilter = (CL_GLFunctions::ptr_glGetSeparableFilterEXT) CL_OpenGL::get_proc_address(&quot;glGetSeparableFilterEXT&quot;);
+	functions-&gt;convolutionParameteri = (CL_GLFunctions::ptr_glConvolutionParameteriEXT) CL_OpenGL::get_proc_address(&quot;glConvolutionParameteriEXT&quot;);
+	functions-&gt;convolutionParameteriv = (CL_GLFunctions::ptr_glConvolutionParameterivEXT) CL_OpenGL::get_proc_address(&quot;glConvolutionParameterivEXT&quot;);
+	functions-&gt;convolutionParameterf = (CL_GLFunctions::ptr_glConvolutionParameterfEXT) CL_OpenGL::get_proc_address(&quot;glConvolutionParameterfEXT&quot;);
+	functions-&gt;convolutionParameterfv = (CL_GLFunctions::ptr_glConvolutionParameterfvEXT) CL_OpenGL::get_proc_address(&quot;glConvolutionParameterfvEXT&quot;);
+	functions-&gt;getConvolutionParameteriv = (CL_GLFunctions::ptr_glGetConvolutionParameterivEXT) CL_OpenGL::get_proc_address(&quot;glGetConvolutionParameterivEXT&quot;);
+	functions-&gt;getConvolutionParameterfv = (CL_GLFunctions::ptr_glGetConvolutionParameterfvEXT) CL_OpenGL::get_proc_address(&quot;glGetConvolutionParameterfvEXT&quot;);
+	functions-&gt;histogram = (CL_GLFunctions::ptr_glHistogramEXT) CL_OpenGL::get_proc_address(&quot;glHistogramEXT&quot;);
+	functions-&gt;resetHistogram = (CL_GLFunctions::ptr_glResetHistogramEXT) CL_OpenGL::get_proc_address(&quot;glResetHistogramEXT&quot;);
+	functions-&gt;getHistogram = (CL_GLFunctions::ptr_glGetHistogramEXT) CL_OpenGL::get_proc_address(&quot;glGetHistogramEXT&quot;);
+	functions-&gt;getHistogramParameteriv = (CL_GLFunctions::ptr_glGetHistogramParameterivEXT) CL_OpenGL::get_proc_address(&quot;glGetHistogramParameterivEXT&quot;);
+	functions-&gt;getHistogramParameterfv = (CL_GLFunctions::ptr_glGetHistogramParameterfvEXT) CL_OpenGL::get_proc_address(&quot;glGetHistogramParameterfvEXT&quot;);
+	functions-&gt;minmax = (CL_GLFunctions::ptr_glMinmaxEXT) CL_OpenGL::get_proc_address(&quot;glMinmaxEXT&quot;);
+	functions-&gt;resetMinmax = (CL_GLFunctions::ptr_glResetMinmaxEXT) CL_OpenGL::get_proc_address(&quot;glResetMinmaxEXT&quot;);
+	functions-&gt;getMinmax = (CL_GLFunctions::ptr_glGetMinmaxEXT) CL_OpenGL::get_proc_address(&quot;glGetMinmaxEXT&quot;);
+	functions-&gt;getMinmaxParameteriv = (CL_GLFunctions::ptr_glGetMinmaxParameterivEXT) CL_OpenGL::get_proc_address(&quot;glGetMinmaxParameterivEXT&quot;);
+	functions-&gt;getMinmaxParameterfv = (CL_GLFunctions::ptr_glGetMinmaxParameterfvEXT) CL_OpenGL::get_proc_address(&quot;glGetMinmaxParameterfvEXT&quot;);
+	functions-&gt;blendColor = (CL_GLFunctions::ptr_glBlendColorEXT) CL_OpenGL::get_proc_address(&quot;glBlendColorEXT&quot;);
+	functions-&gt;blendEquation = (CL_GLFunctions::ptr_glBlendEquationEXT) CL_OpenGL::get_proc_address(&quot;glBlendEquationEXT&quot;);
+#endif
+
+	// Binds for OpenGL 1.2.1:
+
+#ifdef __APPLE__
+	functions-&gt;activeTexture = (CL_GLFunctions::ptr_glActiveTextureARB) &glActiveTexture;
+	functions-&gt;clientActiveTexture = (CL_GLFunctions::ptr_glClientActiveTextureARB) &glClientActiveTexture;
+	functions-&gt;multiTexCoord1d = (CL_GLFunctions::ptr_glMultiTexCoord1dARB) &amp;glMultiTexCoord1d;
+	functions-&gt;multiTexCoord1dv = (CL_GLFunctions::ptr_glMultiTexCoord1dvARB) &amp;glMultiTexCoord1dv;
+	functions-&gt;multiTexCoord1f = (CL_GLFunctions::ptr_glMultiTexCoord1fARB) &amp;glMultiTexCoord1f;
+	functions-&gt;multiTexCoord1fv = (CL_GLFunctions::ptr_glMultiTexCoord1fvARB) &amp;glMultiTexCoord1fv;
+	functions-&gt;multiTexCoord1i = (CL_GLFunctions::ptr_glMultiTexCoord1iARB) &amp;glMultiTexCoord1i;
+	functions-&gt;multiTexCoord1iv = (CL_GLFunctions::ptr_glMultiTexCoord1ivARB) &amp;glMultiTexCoord1iv;
+	functions-&gt;multiTexCoord1s = (CL_GLFunctions::ptr_glMultiTexCoord1sARB) &amp;glMultiTexCoord1s;
+	functions-&gt;multiTexCoord1sv = (CL_GLFunctions::ptr_glMultiTexCoord1svARB) &amp;glMultiTexCoord1sv;
+	functions-&gt;multiTexCoord2d = (CL_GLFunctions::ptr_glMultiTexCoord2dARB) &amp;glMultiTexCoord2d;
+	functions-&gt;multiTexCoord2dv = (CL_GLFunctions::ptr_glMultiTexCoord2dvARB) &amp;glMultiTexCoord2dv;
+	functions-&gt;multiTexCoord2f = (CL_GLFunctions::ptr_glMultiTexCoord2fARB) &amp;glMultiTexCoord2f;
+	functions-&gt;multiTexCoord2fv = (CL_GLFunctions::ptr_glMultiTexCoord2fvARB) &amp;glMultiTexCoord2fv;
+	functions-&gt;multiTexCoord2i = (CL_GLFunctions::ptr_glMultiTexCoord2iARB) &amp;glMultiTexCoord2i;
+	functions-&gt;multiTexCoord2iv = (CL_GLFunctions::ptr_glMultiTexCoord2ivARB) &amp;glMultiTexCoord2iv;
+	functions-&gt;multiTexCoord2s = (CL_GLFunctions::ptr_glMultiTexCoord2sARB) &amp;glMultiTexCoord2s;
+	functions-&gt;multiTexCoord2sv = (CL_GLFunctions::ptr_glMultiTexCoord2svARB) &amp;glMultiTexCoord2sv;
+	functions-&gt;multiTexCoord3d = (CL_GLFunctions::ptr_glMultiTexCoord3dARB) &amp;glMultiTexCoord3d;
+	functions-&gt;multiTexCoord3dv = (CL_GLFunctions::ptr_glMultiTexCoord3dvARB) &amp;glMultiTexCoord3dv;
+	functions-&gt;multiTexCoord3f = (CL_GLFunctions::ptr_glMultiTexCoord3fARB) &amp;glMultiTexCoord3f;
+	functions-&gt;multiTexCoord3fv = (CL_GLFunctions::ptr_glMultiTexCoord3fvARB) &amp;glMultiTexCoord3fv;
+	functions-&gt;multiTexCoord3i = (CL_GLFunctions::ptr_glMultiTexCoord3iARB) &amp;glMultiTexCoord3i;
+	functions-&gt;multiTexCoord3iv = (CL_GLFunctions::ptr_glMultiTexCoord3ivARB) &amp;glMultiTexCoord3iv;
+	functions-&gt;multiTexCoord3s = (CL_GLFunctions::ptr_glMultiTexCoord3sARB) &amp;glMultiTexCoord3s;
+	functions-&gt;multiTexCoord3sv = (CL_GLFunctions::ptr_glMultiTexCoord3svARB) &amp;glMultiTexCoord3sv;
+	functions-&gt;multiTexCoord4d = (CL_GLFunctions::ptr_glMultiTexCoord4dARB) &amp;glMultiTexCoord4d;
+	functions-&gt;multiTexCoord4dv = (CL_GLFunctions::ptr_glMultiTexCoord4dvARB) &amp;glMultiTexCoord4dv;
+	functions-&gt;multiTexCoord4f = (CL_GLFunctions::ptr_glMultiTexCoord4fARB) &amp;glMultiTexCoord4f;
+	functions-&gt;multiTexCoord4fv = (CL_GLFunctions::ptr_glMultiTexCoord4fvARB) &amp;glMultiTexCoord4fv;
+	functions-&gt;multiTexCoord4i = (CL_GLFunctions::ptr_glMultiTexCoord4iARB) &amp;glMultiTexCoord4i;
+	functions-&gt;multiTexCoord4iv = (CL_GLFunctions::ptr_glMultiTexCoord4ivARB) &amp;glMultiTexCoord4iv;
+	functions-&gt;multiTexCoord4s = (CL_GLFunctions::ptr_glMultiTexCoord4sARB) &amp;glMultiTexCoord4s;
+	functions-&gt;multiTexCoord4sv = (CL_GLFunctions::ptr_glMultiTexCoord4svARB) &amp;glMultiTexCoord4sv;
+#else
+	functions-&gt;activeTexture = (CL_GLFunctions::ptr_glActiveTextureARB) CL_OpenGL::get_proc_address(&quot;glActiveTextureARB&quot;);
+	functions-&gt;clientActiveTexture = (CL_GLFunctions::ptr_glClientActiveTextureARB) CL_OpenGL::get_proc_address(&quot;glClientActiveTextureARB&quot;);
+	functions-&gt;multiTexCoord1d = (CL_GLFunctions::ptr_glMultiTexCoord1dARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord1dARB&quot;);
+	functions-&gt;multiTexCoord1dv = (CL_GLFunctions::ptr_glMultiTexCoord1dvARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord1dvARB&quot;);
+	functions-&gt;multiTexCoord1f = (CL_GLFunctions::ptr_glMultiTexCoord1fARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord1fARB&quot;);
+	functions-&gt;multiTexCoord1fv = (CL_GLFunctions::ptr_glMultiTexCoord1fvARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord1fvARB&quot;);
+	functions-&gt;multiTexCoord1i = (CL_GLFunctions::ptr_glMultiTexCoord1iARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord1iARB&quot;);
+	functions-&gt;multiTexCoord1iv = (CL_GLFunctions::ptr_glMultiTexCoord1ivARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord1ivARB&quot;);
+	functions-&gt;multiTexCoord1s = (CL_GLFunctions::ptr_glMultiTexCoord1sARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord1sARB&quot;);
+	functions-&gt;multiTexCoord1sv = (CL_GLFunctions::ptr_glMultiTexCoord1svARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord1svARB&quot;);
+	functions-&gt;multiTexCoord2d = (CL_GLFunctions::ptr_glMultiTexCoord2dARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord2dARB&quot;);
+	functions-&gt;multiTexCoord2dv = (CL_GLFunctions::ptr_glMultiTexCoord2dvARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord2dvARB&quot;);
+	functions-&gt;multiTexCoord2f = (CL_GLFunctions::ptr_glMultiTexCoord2fARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord2fARB&quot;);
+	functions-&gt;multiTexCoord2fv = (CL_GLFunctions::ptr_glMultiTexCoord2fvARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord2fvARB&quot;);
+	functions-&gt;multiTexCoord2i = (CL_GLFunctions::ptr_glMultiTexCoord2iARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord2iARB&quot;);
+	functions-&gt;multiTexCoord2iv = (CL_GLFunctions::ptr_glMultiTexCoord2ivARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord2ivARB&quot;);
+	functions-&gt;multiTexCoord2s = (CL_GLFunctions::ptr_glMultiTexCoord2sARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord2sARB&quot;);
+	functions-&gt;multiTexCoord2sv = (CL_GLFunctions::ptr_glMultiTexCoord2svARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord2svARB&quot;);
+	functions-&gt;multiTexCoord3d = (CL_GLFunctions::ptr_glMultiTexCoord3dARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord3dARB&quot;);
+	functions-&gt;multiTexCoord3dv = (CL_GLFunctions::ptr_glMultiTexCoord3dvARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord3dvARB&quot;);
+	functions-&gt;multiTexCoord3f = (CL_GLFunctions::ptr_glMultiTexCoord3fARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord3fARB&quot;);
+	functions-&gt;multiTexCoord3fv = (CL_GLFunctions::ptr_glMultiTexCoord3fvARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord3fvARB&quot;);
+	functions-&gt;multiTexCoord3i = (CL_GLFunctions::ptr_glMultiTexCoord3iARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord3iARB&quot;);
+	functions-&gt;multiTexCoord3iv = (CL_GLFunctions::ptr_glMultiTexCoord3ivARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord3ivARB&quot;);
+	functions-&gt;multiTexCoord3s = (CL_GLFunctions::ptr_glMultiTexCoord3sARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord3sARB&quot;);
+	functions-&gt;multiTexCoord3sv = (CL_GLFunctions::ptr_glMultiTexCoord3svARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord3svARB&quot;);
+	functions-&gt;multiTexCoord4d = (CL_GLFunctions::ptr_glMultiTexCoord4dARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord4dARB&quot;);
+	functions-&gt;multiTexCoord4dv = (CL_GLFunctions::ptr_glMultiTexCoord4dvARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord4dvARB&quot;);
+	functions-&gt;multiTexCoord4f = (CL_GLFunctions::ptr_glMultiTexCoord4fARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord4fARB&quot;);
+	functions-&gt;multiTexCoord4fv = (CL_GLFunctions::ptr_glMultiTexCoord4fvARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord4fvARB&quot;);
+	functions-&gt;multiTexCoord4i = (CL_GLFunctions::ptr_glMultiTexCoord4iARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord4iARB&quot;);
+	functions-&gt;multiTexCoord4iv = (CL_GLFunctions::ptr_glMultiTexCoord4ivARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord4ivARB&quot;);
+	functions-&gt;multiTexCoord4s = (CL_GLFunctions::ptr_glMultiTexCoord4sARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord4sARB&quot;);
+	functions-&gt;multiTexCoord4sv = (CL_GLFunctions::ptr_glMultiTexCoord4svARB) CL_OpenGL::get_proc_address(&quot;glMultiTexCoord4svARB&quot;);
+#endif
+
+	// Binds for OpenGL 1.3:
+
+#ifdef __APPLE__
+	functions-&gt;compressedTexImage1D = (CL_GLFunctions::ptr_glCompressedTexImage1DARB) &amp;glCompressedTexImage1D;
+	functions-&gt;compressedTexImage2D = (CL_GLFunctions::ptr_glCompressedTexImage2DARB) &amp;glCompressedTexImage2D;
+	functions-&gt;compressedTexImage3D = (CL_GLFunctions::ptr_glCompressedTexImage3DARB) &amp;glCompressedTexImage3D;
+	functions-&gt;compressedTexSubImage1D = (CL_GLFunctions::ptr_glCompressedTexSubImage1DARB) &amp;glCompressedTexSubImage1D;
+	functions-&gt;compressedTexSubImage2D = (CL_GLFunctions::ptr_glCompressedTexSubImage2DARB) &amp;glCompressedTexSubImage2D;
+	functions-&gt;compressedTexSubImage3D = (CL_GLFunctions::ptr_glCompressedTexSubImage3DARB) &amp;glCompressedTexSubImage3D;
+	functions-&gt;getCompressedTexImage = (CL_GLFunctions::ptr_glGetCompressedTexImageARB) &glGetCompressedTexImage;
+	functions-&gt;sampleCoverage = (CL_GLFunctions::ptr_glSampleCoverageARB) &glSampleCoverage;
+	functions-&gt;glLoadTransposeMatrixd = (CL_GLFunctions::ptr_glLoadTransposeMatrixdARB) &glLoadTransposeMatrixd;
+	functions-&gt;glLoadTransposeMatrixf = (CL_GLFunctions::ptr_glLoadTransposeMatrixfARB) &glLoadTransposeMatrixf;
+	functions-&gt;glMultTransposeMatrixd = (CL_GLFunctions::ptr_glMultTransposeMatrixdARB) &glMultTransposeMatrixd;
+	functions-&gt;glMultTransposeMatrixf = (CL_GLFunctions::ptr_glMultTransposeMatrixfARB) &glMultTransposeMatrixf;
+#else
+	functions-&gt;compressedTexImage1D = (CL_GLFunctions::ptr_glCompressedTexImage1DARB) CL_OpenGL::get_proc_address(&quot;glCompressedTexImage1DARB&quot;);
+	functions-&gt;compressedTexImage2D = (CL_GLFunctions::ptr_glCompressedTexImage2DARB) CL_OpenGL::get_proc_address(&quot;glCompressedTexImage2DARB&quot;);
+	functions-&gt;compressedTexImage3D = (CL_GLFunctions::ptr_glCompressedTexImage3DARB) CL_OpenGL::get_proc_address(&quot;glCompressedTexImage3DARB&quot;);
+	functions-&gt;compressedTexSubImage1D = (CL_GLFunctions::ptr_glCompressedTexSubImage1DARB) CL_OpenGL::get_proc_address(&quot;glCompressedTexSubImage1DARB&quot;);
+	functions-&gt;compressedTexSubImage2D = (CL_GLFunctions::ptr_glCompressedTexSubImage2DARB) CL_OpenGL::get_proc_address(&quot;glCompressedTexSubImage2DARB&quot;);
+	functions-&gt;compressedTexSubImage3D = (CL_GLFunctions::ptr_glCompressedTexSubImage3DARB) CL_OpenGL::get_proc_address(&quot;glCompressedTexSubImage3DARB&quot;);
+	functions-&gt;getCompressedTexImage = (CL_GLFunctions::ptr_glGetCompressedTexImageARB) CL_OpenGL::get_proc_address(&quot;glGetCompressedTexImageARB&quot;);
+	functions-&gt;sampleCoverage = (CL_GLFunctions::ptr_glSampleCoverageARB) CL_OpenGL::get_proc_address(&quot;glSampleCoverageARB&quot;);
+	functions-&gt;glLoadTransposeMatrixd = (CL_GLFunctions::ptr_glLoadTransposeMatrixdARB) CL_OpenGL::get_proc_address(&quot;glLoadTransposeMatrixdARB&quot;);
+	functions-&gt;glLoadTransposeMatrixf = (CL_GLFunctions::ptr_glLoadTransposeMatrixfARB) CL_OpenGL::get_proc_address(&quot;glLoadTransposeMatrixfARB&quot;);
+	functions-&gt;glMultTransposeMatrixd = (CL_GLFunctions::ptr_glMultTransposeMatrixdARB) CL_OpenGL::get_proc_address(&quot;glMultTransposeMatrixdARB&quot;);
+	functions-&gt;glMultTransposeMatrixf = (CL_GLFunctions::ptr_glMultTransposeMatrixfARB) CL_OpenGL::get_proc_address(&quot;glMultTransposeMatrixfARB&quot;);
+#endif
+
+	// Binds for OpenGL 1.4:
+
+#ifdef __APPLE__
+	functions-&gt;fogCoordd = (CL_GLFunctions::ptr_glFogCoorddEXT) &glFogCoordd;
+	functions-&gt;fogCoorddv = (CL_GLFunctions::ptr_glFogCoorddvEXT) &glFogCoorddv;
+	functions-&gt;fogCoordf = (CL_GLFunctions::ptr_glFogCoordfEXT) &glFogCoordf;
+	functions-&gt;fogCoordfv = (CL_GLFunctions::ptr_glFogCoordfvEXT) &glFogCoordfv;
+	functions-&gt;fogCoordPointer = (CL_GLFunctions::ptr_glFogCoordPointerEXT) &glFogCoordPointer;
+	functions-&gt;multiDrawArrays = (CL_GLFunctions::ptr_glMultiDrawArraysEXT) &glMultiDrawArrays;
+	functions-&gt;multiDrawElementsEXT = (CL_GLFunctions::ptr_glMultiDrawElementsEXT) &glMultiDrawElements;
+	functions-&gt;pointParameterf = (CL_GLFunctions::ptr_glPointParameterfARB) &glPointParameterf;
+	functions-&gt;pointParameterfv = (CL_GLFunctions::ptr_glPointParameterfvARB) &glPointParameterfv;
+	functions-&gt;secondaryColor3b = (CL_GLFunctions::ptr_glSecondaryColor3bEXT) &amp;glSecondaryColor3b;
+	functions-&gt;secondaryColor3bv = (CL_GLFunctions::ptr_glSecondaryColor3bvEXT) &amp;glSecondaryColor3bv;
+	functions-&gt;secondaryColor3d = (CL_GLFunctions::ptr_glSecondaryColor3dEXT) &amp;glSecondaryColor3d;
+	functions-&gt;secondaryColor3dv = (CL_GLFunctions::ptr_glSecondaryColor3dvEXT) &amp;glSecondaryColor3dv;
+	functions-&gt;secondaryColor3f = (CL_GLFunctions::ptr_glSecondaryColor3fEXT) &amp;glSecondaryColor3f;
+	functions-&gt;secondaryColor3fv = (CL_GLFunctions::ptr_glSecondaryColor3fvEXT) &amp;glSecondaryColor3fv;
+	functions-&gt;secondaryColor3i = (CL_GLFunctions::ptr_glSecondaryColor3iEXT) &amp;glSecondaryColor3i;
+	functions-&gt;secondaryColor3iv = (CL_GLFunctions::ptr_glSecondaryColor3ivEXT) &amp;glSecondaryColor3iv;
+	functions-&gt;secondaryColor3s = (CL_GLFunctions::ptr_glSecondaryColor3sEXT) &amp;glSecondaryColor3s;
+	functions-&gt;secondaryColor3sv = (CL_GLFunctions::ptr_glSecondaryColor3svEXT) &amp;glSecondaryColor3sv;
+	functions-&gt;secondaryColor3ub = (CL_GLFunctions::ptr_glSecondaryColor3ubEXT) &amp;glSecondaryColor3ub;
+	functions-&gt;secondaryColor3ubv = (CL_GLFunctions::ptr_glSecondaryColor3ubvEXT) &amp;glSecondaryColor3ubv;
+	functions-&gt;secondaryColor3ui = (CL_GLFunctions::ptr_glSecondaryColor3uiEXT) &amp;glSecondaryColor3ui;
+	functions-&gt;secondaryColor3uiv = (CL_GLFunctions::ptr_glSecondaryColor3uivEXT) &amp;glSecondaryColor3uiv;
+	functions-&gt;secondaryColor3us = (CL_GLFunctions::ptr_glSecondaryColor3usEXT) &amp;glSecondaryColor3us;
+	functions-&gt;secondaryColor3usv = (CL_GLFunctions::ptr_glSecondaryColor3usvEXT) &amp;glSecondaryColor3usv;
+	functions-&gt;secondaryColorPointer = (CL_GLFunctions::ptr_glSecondaryColorPointerEXT) &glSecondaryColorPointer;
+	functions-&gt;blendFuncSeparate = (CL_GLFunctions::ptr_glBlendFuncSeparateEXT) &glBlendFuncSeparate;
+	
+	// need to manually link these, since some llama linux opengl driver says its 1.4 while its not! &gt;:(
+/*	
+	functions-&gt;windowPos2d = (CL_GLFunctions::ptr_glWindowPos2dARB) CL_OpenGL::get_proc_address(&quot;glWindowPos2dARB&quot;);
+	functions-&gt;windowPos2dv = (CL_GLFunctions::ptr_glWindowPos2dvARB) CL_OpenGL::get_proc_address(&quot;glWindowPos2dvARB&quot;);
+	functions-&gt;windowPos2f = (CL_GLFunctions::ptr_glWindowPos2fARB) CL_OpenGL::get_proc_address(&quot;glWindowPos2fARB&quot;);
+	functions-&gt;windowPos2fv = (CL_GLFunctions::ptr_glWindowPos2fvARB) CL_OpenGL::get_proc_address(&quot;glWindowPos2fvARB&quot;);
+	functions-&gt;windowPos2i = (CL_GLFunctions::ptr_glWindowPos2iARB) CL_OpenGL::get_proc_address(&quot;glWindowPos2iARB&quot;);
+	functions-&gt;windowPos2iv = (CL_GLFunctions::ptr_glWindowPos2ivARB) CL_OpenGL::get_proc_address(&quot;glWindowPos2ivARB&quot;);
+	functions-&gt;windowPos2s = (CL_GLFunctions::ptr_glWindowPos2sARB) CL_OpenGL::get_proc_address(&quot;glWindowPos2sARB&quot;);
+	functions-&gt;windowPos2sv = (CL_GLFunctions::ptr_glWindowPos2svARB) CL_OpenGL::get_proc_address(&quot;glWindowPos2svARB&quot;);
+	functions-&gt;windowPos3d = (CL_GLFunctions::ptr_glWindowPos3dARB) CL_OpenGL::get_proc_address(&quot;glWindowPos3dARB&quot;);
+	functions-&gt;windowPos3dv = (CL_GLFunctions::ptr_glWindowPos3dvARB) CL_OpenGL::get_proc_address(&quot;glWindowPos3dvARB&quot;);
+	functions-&gt;windowPos3f = (CL_GLFunctions::ptr_glWindowPos3fARB) CL_OpenGL::get_proc_address(&quot;glWindowPos3fARB&quot;);
+	functions-&gt;windowPos3fv = (CL_GLFunctions::ptr_glWindowPos3fvARB) CL_OpenGL::get_proc_address(&quot;glWindowPos3fvARB&quot;);
+	functions-&gt;windowPos3i = (CL_GLFunctions::ptr_glWindowPos3iARB) CL_OpenGL::get_proc_address(&quot;glWindowPos3iARB&quot;);
+	functions-&gt;windowPos3iv = (CL_GLFunctions::ptr_glWindowPos3ivARB) CL_OpenGL::get_proc_address(&quot;glWindowPos3ivARB&quot;);
+	functions-&gt;windowPos3s = (CL_GLFunctions::ptr_glWindowPos3sARB) CL_OpenGL::get_proc_address(&quot;glWindowPos3sARB&quot;);
+	functions-&gt;windowPos3sv = (CL_GLFunctions::ptr_glWindowPos3svARB) CL_OpenGL::get_proc_address(&quot;glWindowPos3svARB&quot;);
+*/
+	functions-&gt;windowPos2d = &amp;glWindowPos2d;
+	functions-&gt;windowPos2dv = &amp;glWindowPos2dv;
+	functions-&gt;windowPos2f = &amp;glWindowPos2f;
+	functions-&gt;windowPos2fv = &amp;glWindowPos2fv;
+	functions-&gt;windowPos2i = &amp;glWindowPos2i;
+	functions-&gt;windowPos2iv = &amp;glWindowPos2iv;
+	functions-&gt;windowPos2s = &amp;glWindowPos2s;
+	functions-&gt;windowPos2sv = &amp;glWindowPos2sv;
+	functions-&gt;windowPos3d = &amp;glWindowPos3d;
+	functions-&gt;windowPos3dv = &amp;glWindowPos3dv;
+	functions-&gt;windowPos3f = &amp;glWindowPos3f;
+	functions-&gt;windowPos3fv = &amp;glWindowPos3fv;
+	functions-&gt;windowPos3i = &amp;glWindowPos3i;
+	functions-&gt;windowPos3iv = &amp;glWindowPos3iv;
+	functions-&gt;windowPos3s = &amp;glWindowPos3s;
+	functions-&gt;windowPos3sv = &amp;glWindowPos3sv;
+#else
+	functions-&gt;fogCoordd = (CL_GLFunctions::ptr_glFogCoorddEXT) CL_OpenGL::get_proc_address(&quot;glFogCoorddEXT&quot;);
+	functions-&gt;fogCoorddv = (CL_GLFunctions::ptr_glFogCoorddvEXT) CL_OpenGL::get_proc_address(&quot;glFogCoorddvEXT&quot;);
+	functions-&gt;fogCoordf = (CL_GLFunctions::ptr_glFogCoordfEXT) CL_OpenGL::get_proc_address(&quot;glFogCoordfEXT&quot;);
+	functions-&gt;fogCoordfv = (CL_GLFunctions::ptr_glFogCoordfvEXT) CL_OpenGL::get_proc_address(&quot;glFogCoordfvEXT&quot;);
+	functions-&gt;fogCoordPointer = (CL_GLFunctions::ptr_glFogCoordPointerEXT) CL_OpenGL::get_proc_address(&quot;glFogCoordPointerEXT&quot;);
+	functions-&gt;multiDrawArrays = (CL_GLFunctions::ptr_glMultiDrawArraysEXT) CL_OpenGL::get_proc_address(&quot;glMultiDrawArraysEXT&quot;);
+	functions-&gt;multiDrawElementsEXT = (CL_GLFunctions::ptr_glMultiDrawElementsEXT) CL_OpenGL::get_proc_address(&quot;glMultiDrawElementsEXT&quot;);
+	functions-&gt;pointParameterf = (CL_GLFunctions::ptr_glPointParameterfARB) CL_OpenGL::get_proc_address(&quot;glPointParameterfARB&quot;);
+	functions-&gt;pointParameterfv = (CL_GLFunctions::ptr_glPointParameterfvARB) CL_OpenGL::get_proc_address(&quot;glPointParameterfvARB&quot;);
+	functions-&gt;secondaryColor3b = (CL_GLFunctions::ptr_glSecondaryColor3bEXT) CL_OpenGL::get_proc_address(&quot;glSecondaryColor3bEXT&quot;);
+	functions-&gt;secondaryColor3bv = (CL_GLFunctions::ptr_glSecondaryColor3bvEXT) CL_OpenGL::get_proc_address(&quot;glSecondaryColor3bvEXT&quot;);
+	functions-&gt;secondaryColor3d = (CL_GLFunctions::ptr_glSecondaryColor3dEXT) CL_OpenGL::get_proc_address(&quot;glSecondaryColor3dEXT&quot;);
+	functions-&gt;secondaryColor3dv = (CL_GLFunctions::ptr_glSecondaryColor3dvEXT) CL_OpenGL::get_proc_address(&quot;glSecondaryColor3dvEXT&quot;);
+	functions-&gt;secondaryColor3f = (CL_GLFunctions::ptr_glSecondaryColor3fEXT) CL_OpenGL::get_proc_address(&quot;glSecondaryColor3fEXT&quot;);
+	functions-&gt;secondaryColor3fv = (CL_GLFunctions::ptr_glSecondaryColor3fvEXT) CL_OpenGL::get_proc_address(&quot;glSecondaryColor3fvEXT&quot;);
+	functions-&gt;secondaryColor3i = (CL_GLFunctions::ptr_glSecondaryColor3iEXT) CL_OpenGL::get_proc_address(&quot;glSecondaryColor3iEXT&quot;);
+	functions-&gt;secondaryColor3iv = (CL_GLFunctions::ptr_glSecondaryColor3ivEXT) CL_OpenGL::get_proc_address(&quot;glSecondaryColor3ivEXT&quot;);
+	functions-&gt;secondaryColor3s = (CL_GLFunctions::ptr_glSecondaryColor3sEXT) CL_OpenGL::get_proc_address(&quot;glSecondaryColor3sEXT&quot;);
+	functions-&gt;secondaryColor3sv = (CL_GLFunctions::ptr_glSecondaryColor3svEXT) CL_OpenGL::get_proc_address(&quot;glSecondaryColor3svEXT&quot;);
+	functions-&gt;secondaryColor3ub = (CL_GLFunctions::ptr_glSecondaryColor3ubEXT) CL_OpenGL::get_proc_address(&quot;glSecondaryColor3ubEXT&quot;);
+	functions-&gt;secondaryColor3ubv = (CL_GLFunctions::ptr_glSecondaryColor3ubvEXT) CL_OpenGL::get_proc_address(&quot;glSecondaryColor3ubvEXT&quot;);
+	functions-&gt;secondaryColor3ui = (CL_GLFunctions::ptr_glSecondaryColor3uiEXT) CL_OpenGL::get_proc_address(&quot;glSecondaryColor3uiEXT&quot;);
+	functions-&gt;secondaryColor3uiv = (CL_GLFunctions::ptr_glSecondaryColor3uivEXT) CL_OpenGL::get_proc_address(&quot;glSecondaryColor3uivEXT&quot;);
+	functions-&gt;secondaryColor3us = (CL_GLFunctions::ptr_glSecondaryColor3usEXT) CL_OpenGL::get_proc_address(&quot;glSecondaryColor3usEXT&quot;);
+	functions-&gt;secondaryColor3usv = (CL_GLFunctions::ptr_glSecondaryColor3usvEXT) CL_OpenGL::get_proc_address(&quot;glSecondaryColor3usvEXT&quot;);
+	functions-&gt;secondaryColorPointer = (CL_GLFunctions::ptr_glSecondaryColorPointerEXT) CL_OpenGL::get_proc_address(&quot;glSecondaryColorPointerEXT&quot;);
+	functions-&gt;blendFuncSeparate = (CL_GLFunctions::ptr_glBlendFuncSeparateEXT) CL_OpenGL::get_proc_address(&quot;glBlendFuncSeparateEXT&quot;);
+	functions-&gt;windowPos2d = (CL_GLFunctions::ptr_glWindowPos2dARB) CL_OpenGL::get_proc_address(&quot;glWindowPos2dARB&quot;);
+	functions-&gt;windowPos2dv = (CL_GLFunctions::ptr_glWindowPos2dvARB) CL_OpenGL::get_proc_address(&quot;glWindowPos2dvARB&quot;);
+	functions-&gt;windowPos2f = (CL_GLFunctions::ptr_glWindowPos2fARB) CL_OpenGL::get_proc_address(&quot;glWindowPos2fARB&quot;);
+	functions-&gt;windowPos2fv = (CL_GLFunctions::ptr_glWindowPos2fvARB) CL_OpenGL::get_proc_address(&quot;glWindowPos2fvARB&quot;);
+	functions-&gt;windowPos2i = (CL_GLFunctions::ptr_glWindowPos2iARB) CL_OpenGL::get_proc_address(&quot;glWindowPos2iARB&quot;);
+	functions-&gt;windowPos2iv = (CL_GLFunctions::ptr_glWindowPos2ivARB) CL_OpenGL::get_proc_address(&quot;glWindowPos2ivARB&quot;);
+	functions-&gt;windowPos2s = (CL_GLFunctions::ptr_glWindowPos2sARB) CL_OpenGL::get_proc_address(&quot;glWindowPos2sARB&quot;);
+	functions-&gt;windowPos2sv = (CL_GLFunctions::ptr_glWindowPos2svARB) CL_OpenGL::get_proc_address(&quot;glWindowPos2svARB&quot;);
+	functions-&gt;windowPos3d = (CL_GLFunctions::ptr_glWindowPos3dARB) CL_OpenGL::get_proc_address(&quot;glWindowPos3dARB&quot;);
+	functions-&gt;windowPos3dv = (CL_GLFunctions::ptr_glWindowPos3dvARB) CL_OpenGL::get_proc_address(&quot;glWindowPos3dvARB&quot;);
+	functions-&gt;windowPos3f = (CL_GLFunctions::ptr_glWindowPos3fARB) CL_OpenGL::get_proc_address(&quot;glWindowPos3fARB&quot;);
+	functions-&gt;windowPos3fv = (CL_GLFunctions::ptr_glWindowPos3fvARB) CL_OpenGL::get_proc_address(&quot;glWindowPos3fvARB&quot;);
+	functions-&gt;windowPos3i = (CL_GLFunctions::ptr_glWindowPos3iARB) CL_OpenGL::get_proc_address(&quot;glWindowPos3iARB&quot;);
+	functions-&gt;windowPos3iv = (CL_GLFunctions::ptr_glWindowPos3ivARB) CL_OpenGL::get_proc_address(&quot;glWindowPos3ivARB&quot;);
+	functions-&gt;windowPos3s = (CL_GLFunctions::ptr_glWindowPos3sARB) CL_OpenGL::get_proc_address(&quot;glWindowPos3sARB&quot;);
+	functions-&gt;windowPos3sv = (CL_GLFunctions::ptr_glWindowPos3svARB) CL_OpenGL::get_proc_address(&quot;glWindowPos3svARB&quot;);
+#endif
+
+	// Binds for OpenGL 1.5:
+
+#ifdef __NOBODY_YET_HEHE__
+	functions-&gt;bindBuffer = (CL_GLFunctions::ptr_glBindBufferARB) &glBindBuffer;
+	functions-&gt;deleteBuffers = (CL_GLFunctions::ptr_glDeleteBuffersARB) &glDeleteBuffers;
+	functions-&gt;genBuffers = (CL_GLFunctions::ptr_glGenBuffersARB) &glGenBuffers;
+	functions-&gt;isBuffer = (CL_GLFunctions::ptr_glIsBufferARB) &glIsBuffer;
+	functions-&gt;bufferData = (CL_GLFunctions::ptr_glBufferDataARB) &glBufferData;
+	functions-&gt;bufferSubData = (CL_GLFunctions::ptr_glBufferSubDataARB) &glBufferSubData;
+	functions-&gt;getBufferSubData = (CL_GLFunctions::ptr_glGetBufferSubDataARB) &glGetBufferSubData;
+	functions-&gt;mapBuffer = (CL_GLFunctions::ptr_glMapBufferARB) &glMapBuffer;
+	functions-&gt;unmapBuffer = (CL_GLFunctions::ptr_glUnmapBufferARB) &glUnmapBuffer;
+	functions-&gt;getBufferParameteriv = (CL_GLFunctions::ptr_glGetBufferParameterivARB) &glGetBufferParameteriv;
+	functions-&gt;getBufferPointerv = (CL_GLFunctions::ptr_glGetBufferPointervARB) &glGetBufferPointerv;
+	functions-&gt;genQueries = (CL_GLFunctions::ptr_glGenQueriesARB) &glGenQueries;
+	functions-&gt;deleteQueries = (CL_GLFunctions::ptr_glDeleteQueriesARB) &glDeleteQueries;
+	functions-&gt;isQuery = (CL_GLFunctions::ptr_glIsQueryARB) &glIsQuery;
+	functions-&gt;beginQuery = (CL_GLFunctions::ptr_glBeginQueryARB) &glBeginQuery;
+	functions-&gt;endQuery = (CL_GLFunctions::ptr_glEndQueryARB) &glEndQuery;
+	functions-&gt;getQueryiv = (CL_GLFunctions::ptr_glGetQueryivARB) &glGetQueryiv;
+	functions-&gt;getQueryObjectiv = (CL_GLFunctions::ptr_glGetQueryObjectivARB) &glGetQueryObjectiv;
+	functions-&gt;getQueryObjectuiv = (CL_GLFunctions::ptr_glGetQueryObjectuivARB) &glGetQueryObjectuiv;
+#else
+	functions-&gt;bindBuffer = (CL_GLFunctions::ptr_glBindBufferARB) CL_OpenGL::get_proc_address(&quot;glBindBufferARB&quot;);
+	functions-&gt;deleteBuffers = (CL_GLFunctions::ptr_glDeleteBuffersARB) CL_OpenGL::get_proc_address(&quot;glDeleteBuffersARB&quot;);
+	functions-&gt;genBuffers = (CL_GLFunctions::ptr_glGenBuffersARB) CL_OpenGL::get_proc_address(&quot;glGenBuffersARB&quot;);
+	functions-&gt;isBuffer = (CL_GLFunctions::ptr_glIsBufferARB) CL_OpenGL::get_proc_address(&quot;glIsBufferARB&quot;);
+	functions-&gt;bufferData = (CL_GLFunctions::ptr_glBufferDataARB) CL_OpenGL::get_proc_address(&quot;glBufferDataARB&quot;);
+	functions-&gt;bufferSubData = (CL_GLFunctions::ptr_glBufferSubDataARB) CL_OpenGL::get_proc_address(&quot;glBufferSubDataARB&quot;);
+	functions-&gt;getBufferSubData = (CL_GLFunctions::ptr_glGetBufferSubDataARB) CL_OpenGL::get_proc_address(&quot;glGetBufferSubDataARB&quot;);
+	functions-&gt;mapBuffer = (CL_GLFunctions::ptr_glMapBufferARB) CL_OpenGL::get_proc_address(&quot;glMapBufferARB&quot;);
+	functions-&gt;unmapBuffer = (CL_GLFunctions::ptr_glUnmapBufferARB) CL_OpenGL::get_proc_address(&quot;glUnmapBufferARB&quot;);
+	functions-&gt;getBufferParameteriv = (CL_GLFunctions::ptr_glGetBufferParameterivARB) CL_OpenGL::get_proc_address(&quot;glGetBufferParameterivARB&quot;);
+	functions-&gt;getBufferPointerv = (CL_GLFunctions::ptr_glGetBufferPointervARB) CL_OpenGL::get_proc_address(&quot;glGetBufferPointervARB&quot;);
+	functions-&gt;genQueries = (CL_GLFunctions::ptr_glGenQueriesARB) CL_OpenGL::get_proc_address(&quot;glGenQueriesARB&quot;);
+	functions-&gt;deleteQueries = (CL_GLFunctions::ptr_glDeleteQueriesARB) CL_OpenGL::get_proc_address(&quot;glDeleteQueriesARB&quot;);
+	functions-&gt;isQuery = (CL_GLFunctions::ptr_glIsQueryARB) CL_OpenGL::get_proc_address(&quot;glIsQueryARB&quot;);
+	functions-&gt;beginQuery = (CL_GLFunctions::ptr_glBeginQueryARB) CL_OpenGL::get_proc_address(&quot;glBeginQueryARB&quot;);
+	functions-&gt;endQuery = (CL_GLFunctions::ptr_glEndQueryARB) CL_OpenGL::get_proc_address(&quot;glEndQueryARB&quot;);
+	functions-&gt;getQueryiv = (CL_GLFunctions::ptr_glGetQueryivARB) CL_OpenGL::get_proc_address(&quot;glGetQueryivARB&quot;);
+	functions-&gt;getQueryObjectiv = (CL_GLFunctions::ptr_glGetQueryObjectivARB) CL_OpenGL::get_proc_address(&quot;glGetQueryObjectivARB&quot;);
+	functions-&gt;getQueryObjectuiv = (CL_GLFunctions::ptr_glGetQueryObjectuivARB) CL_OpenGL::get_proc_address(&quot;glGetQueryObjectuivARB&quot;);
+#endif
+
+	// Binds for OpenGL 2.0:
+
+#ifdef __NOBODY_YET_HEHE__
+	functions-&gt;deleteShader = (CL_GLFunctions::ptr_glDeleteObjectARB) &glDeleteShader;
+	functions-&gt;deleteProgram = (CL_GLFunctions::ptr_glDeleteObjectARB) &glDeleteProgram;
+	functions-&gt;getHandle = (CL_GLFunctions::ptr_glGetHandleARB) &glGetHandle;
+	functions-&gt;detachShader = (CL_GLFunctions::ptr_glDetachObjectARB) &glDetachShader;
+	functions-&gt;createShader = (CL_GLFunctions::ptr_glCreateShaderObjectARB) &glCreateShader;
+	functions-&gt;shaderSource = (CL_GLFunctions::ptr_glShaderSourceARB) &glShaderSource;
+	functions-&gt;compileShader = (CL_GLFunctions::ptr_glCompileShaderARB) &glCompileShader;
+	functions-&gt;createProgram = (CL_GLFunctions::ptr_glCreateProgramObjectARB) &glCreateProgram;
+	functions-&gt;attachShader = (CL_GLFunctions::ptr_glAttachObjectARB) &glAttachShader;
+	functions-&gt;linkProgram = (CL_GLFunctions::ptr_glLinkProgramARB) &glLinkProgram;
+	functions-&gt;useProgram = (CL_GLFunctions::ptr_glUseProgramObjectARB) &glUseProgram;
+	functions-&gt;validateProgram = (CL_GLFunctions::ptr_glValidateProgramARB) &glValidateProgram;
+	functions-&gt;uniform1f = (CL_GLFunctions::ptr_glUniform1fARB) &amp;glUniform1f;
+	functions-&gt;uniform2f = (CL_GLFunctions::ptr_glUniform2fARB) &amp;glUniform2f;
+	functions-&gt;uniform3f = (CL_GLFunctions::ptr_glUniform3fARB) &amp;glUniform3f;
+	functions-&gt;uniform4f = (CL_GLFunctions::ptr_glUniform4fARB) &amp;glUniform4f;
+	functions-&gt;uniform1i = (CL_GLFunctions::ptr_glUniform1iARB) &amp;glUniform1i;
+	functions-&gt;uniform2i = (CL_GLFunctions::ptr_glUniform2iARB) &amp;glUniform2i;
+	functions-&gt;uniform3i = (CL_GLFunctions::ptr_glUniform3iARB) &amp;glUniform3i;
+	functions-&gt;uniform4i = (CL_GLFunctions::ptr_glUniform4iARB) &amp;glUniform4i;
+	functions-&gt;uniform1fv = (CL_GLFunctions::ptr_glUniform1fvARB) &amp;glUniform1fv;
+	functions-&gt;uniform2fv = (CL_GLFunctions::ptr_glUniform2fvARB) &amp;glUniform2fv;
+	functions-&gt;uniform3fv = (CL_GLFunctions::ptr_glUniform3fvARB) &amp;glUniform3fv;
+	functions-&gt;uniform4fv = (CL_GLFunctions::ptr_glUniform4fvARB) &amp;glUniform4fv;
+	functions-&gt;uniform1iv = (CL_GLFunctions::ptr_glUniform1ivARB) &amp;glUniform1iv;
+	functions-&gt;uniform2iv = (CL_GLFunctions::ptr_glUniform2ivARB) &amp;glUniform2iv;
+	functions-&gt;uniform3iv = (CL_GLFunctions::ptr_glUniform3ivARB) &amp;glUniform3iv;
+	functions-&gt;uniform4iv = (CL_GLFunctions::ptr_glUniform4ivARB) &amp;glUniform4iv;
+	functions-&gt;uniformMatrix2fv = (CL_GLFunctions::ptr_glUniformMatrix2fvARB) &amp;glUniformMatrix2fv;
+	functions-&gt;uniformMatrix3fv = (CL_GLFunctions::ptr_glUniformMatrix3fvARB) &amp;glUniformMatrix3fv;
+	functions-&gt;uniformMatrix4fv = (CL_GLFunctions::ptr_glUniformMatrix4fvARB) &amp;glUniformMatrix4fv;
+	functions-&gt;getProgramfv = (CL_GLFunctions::ptr_glGetObjectParameterfvARB) &glProgramfv;
+	functions-&gt;getProgramiv = (CL_GLFunctions::ptr_glGetObjectParameterivARB) &glProgramiv;
+	functions-&gt;getShaderfv = (CL_GLFunctions::ptr_glGetObjectParameterfvARB) &glShaderfv;
+	functions-&gt;getShaderiv = (CL_GLFunctions::ptr_glGetObjectParameterivARB) &glShaderiv;
+	functions-&gt;getShaderInfoLog = (CL_GLFunctions::ptr_glGetInfoLogARB) &glGetShaderInfoLog;
+	functions-&gt;getProgramInfoLog = (CL_GLFunctions::ptr_glGetInfoLogARB) &glGetProgramInfoLog;
+	functions-&gt;getAttachedShaders = (CL_GLFunctions::ptr_glGetAttachedObjectsARB) &glGetAttachedShaders;
+	functions-&gt;getUniformLocation = (CL_GLFunctions::ptr_glGetUniformLocationARB) &glGetUniformLocation;
+	functions-&gt;getActiveUniform = (CL_GLFunctions::ptr_glGetActiveUniformARB) &glGetActiveUniform;
+	functions-&gt;getUniformfv = (CL_GLFunctions::ptr_glGetUniformfvARB) &glGetUniformfv;
+	functions-&gt;getUniformiv = (CL_GLFunctions::ptr_glGetUniformivARB) &glGetUniformiv;
+	functions-&gt;getShaderSource = (CL_GLFunctions::ptr_glGetShaderSourceARB) &glGetShaderSource;
+	functions-&gt;vertexAttrib1f = (CL_GLFunctions::ptr_glVertexAttrib1fARB) &amp;glVertexAttrib1f;
+	functions-&gt;vertexAttrib1s = (CL_GLFunctions::ptr_glVertexAttrib1sARB) &amp;glVertexAttrib1s;
+	functions-&gt;vertexAttrib1d = (CL_GLFunctions::ptr_glVertexAttrib1dARB) &amp;glVertexAttrib1d;
+	functions-&gt;vertexAttrib2f = (CL_GLFunctions::ptr_glVertexAttrib2fARB) &amp;glVertexAttrib2f;
+	functions-&gt;vertexAttrib2s = (CL_GLFunctions::ptr_glVertexAttrib2sARB) &amp;glVertexAttrib2s;
+	functions-&gt;vertexAttrib2d = (CL_GLFunctions::ptr_glVertexAttrib2dARB) &amp;glVertexAttrib2d;
+	functions-&gt;vertexAttrib3f = (CL_GLFunctions::ptr_glVertexAttrib3fARB) &amp;glVertexAttrib3f;
+	functions-&gt;vertexAttrib3s = (CL_GLFunctions::ptr_glVertexAttrib3sARB) &amp;glVertexAttrib3s;
+	functions-&gt;vertexAttrib3d = (CL_GLFunctions::ptr_glVertexAttrib3dARB) &amp;glVertexAttrib3d;
+	functions-&gt;vertexAttrib4f = (CL_GLFunctions::ptr_glVertexAttrib4fARB) &amp;glVertexAttrib4f;
+	functions-&gt;vertexAttrib4s = (CL_GLFunctions::ptr_glVertexAttrib4sARB) &amp;glVertexAttrib4s;
+	functions-&gt;vertexAttrib4d = (CL_GLFunctions::ptr_glVertexAttrib4dARB) &amp;glVertexAttrib4d;
+	functions-&gt;vertexAttrib4Nub = (CL_GLFunctions::ptr_glVertexAttrib4NubARB) &amp;glVertexAttrib4Nub;
+	functions-&gt;vertexAttrib1fv = (CL_GLFunctions::ptr_glVertexAttrib1fvARB) &amp;glVertexAttrib1fv;
+	functions-&gt;vertexAttrib1sv = (CL_GLFunctions::ptr_glVertexAttrib1svARB) &amp;glVertexAttrib1sv;
+	functions-&gt;vertexAttrib1dv = (CL_GLFunctions::ptr_glVertexAttrib1dvARB) &amp;glVertexAttrib1dv;
+	functions-&gt;vertexAttrib2fv = (CL_GLFunctions::ptr_glVertexAttrib2fvARB) &amp;glVertexAttrib2fv;
+	functions-&gt;vertexAttrib2sv = (CL_GLFunctions::ptr_glVertexAttrib2svARB) &amp;glVertexAttrib2sv;
+	functions-&gt;vertexAttrib2dv = (CL_GLFunctions::ptr_glVertexAttrib2dvARB) &amp;glVertexAttrib2dv;
+	functions-&gt;vertexAttrib3fv = (CL_GLFunctions::ptr_glVertexAttrib3fvARB) &amp;glVertexAttrib3fv;
+	functions-&gt;vertexAttrib3sv = (CL_GLFunctions::ptr_glVertexAttrib3svARB) &amp;glVertexAttrib3sv;
+	functions-&gt;activeStencilFaceEXT =(CL_GLFunctions::ptr_glActiveStencilFaceEXT) &glActiveStencilFace;
+	functions-&gt;vertexAttrib3dv = (CL_GLFunctions::ptr_glVertexAttrib3dvARB) &amp;glVertexAttrib3dv;
+	functions-&gt;vertexAttrib4fv = (CL_GLFunctions::ptr_glVertexAttrib4fvARB) &amp;glVertexAttrib4fv;
+	functions-&gt;vertexAttrib4sv = (CL_GLFunctions::ptr_glVertexAttrib4svARB) &amp;glVertexAttrib4sv;
+	functions-&gt;vertexAttrib4dv = (CL_GLFunctions::ptr_glVertexAttrib4dvARB) &amp;glVertexAttrib4dv;
+	functions-&gt;vertexAttrib4iv = (CL_GLFunctions::ptr_glVertexAttrib4ivARB) &amp;glVertexAttrib4iv;
+	functions-&gt;vertexAttrib4bv = (CL_GLFunctions::ptr_glVertexAttrib4bvARB) &amp;glVertexAttrib4bv;
+	functions-&gt;vertexAttrib4ubv = (CL_GLFunctions::ptr_glVertexAttrib4ubvARB) &amp;glVertexAttrib4ubv;
+	functions-&gt;vertexAttrib4usv = (CL_GLFunctions::ptr_glVertexAttrib4usvARB) &amp;glVertexAttrib4usv;
+	functions-&gt;vertexAttrib4uiv = (CL_GLFunctions::ptr_glVertexAttrib4uivARB) &amp;glVertexAttrib4uiv;
+	functions-&gt;vertexAttrib4Nbv = (CL_GLFunctions::ptr_glVertexAttrib4NbvARB) &amp;glVertexAttrib4Nbv;
+	functions-&gt;vertexAttrib4Nsv = (CL_GLFunctions::ptr_glVertexAttrib4NsvARB) &amp;glVertexAttrib4Nsv;
+	functions-&gt;vertexAttrib4Niv = (CL_GLFunctions::ptr_glVertexAttrib4NivARB) &amp;glVertexAttrib4Niv;
+	functions-&gt;vertexAttrib4Nubv = (CL_GLFunctions::ptr_glVertexAttrib4NubvARB) &amp;glVertexAttrib4Nubv;
+	functions-&gt;vertexAttrib4Nusv = (CL_GLFunctions::ptr_glVertexAttrib4NusvARB) &amp;glVertexAttrib4Nusv;
+	functions-&gt;vertexAttrib4Nuiv = (CL_GLFunctions::ptr_glVertexAttrib4NuivARB) &amp;glVertexAttrib4Nuiv;
+	functions-&gt;vertexAttribPointer = (CL_GLFunctions::ptr_glVertexAttribPointerARB) &glVertexAttribPointer;
+	functions-&gt;enableVertexAttribArray = (CL_GLFunctions::ptr_glEnableVertexAttribArrayARB) &glEnableVertexAttribArray;
+	functions-&gt;disableVertexAttribArray = (CL_GLFunctions::ptr_glDisableVertexAttribArrayARB) &glDisableVertexAttribArray;
+	functions-&gt;bindAttribLocation = (CL_GLFunctions::ptr_glBindAttribLocationARB) &glBindAttribLocation;
+	functions-&gt;getActiveAttrib = (CL_GLFunctions::ptr_glGetActiveAttribARB) &glGetActiveAttrib;
+	functions-&gt;getAttribLocation = (CL_GLFunctions::ptr_glGetAttribLocationARB) &glGetAttribLocation;
+	functions-&gt;getVertexAttribdv = (CL_GLFunctions::ptr_glGetVertexAttribdvARB) &glGetVertexAttribdv;
+	functions-&gt;getVertexAttribfv = (CL_GLFunctions::ptr_glGetVertexAttribfvARB) &glGetVertexAttribfv;
+	functions-&gt;getVertexAttribiv = (CL_GLFunctions::ptr_glGetVertexAttribivARB) &glGetVertexAttribiv;
+	functions-&gt;getVertexAttribPointerv = (CL_GLFunctions::ptr_glGetVertexAttribPointervARB) &glGetVertexAttribPointerv;
+	functions-&gt;drawBuffers = (CL_GLFunctions::ptr_glDrawBuffersARB) &glDrawBuffers;
+	functions-&gt;stencilFuncSeparate = (CL_GLFunctions::ptr_glStencilFuncSeparateATI) &glStencilFuncSeparate;
+	functions-&gt;stencilOpSeparate = (CL_GLFunctions::ptr_glStencilOpSeparateATI) &glStencilOpSeparate;
+#elif __APPLE__
+	functions-&gt;deleteShader = (CL_GLFunctions::ptr_glDeleteObjectARB) CL_OpenGL::get_proc_address(&quot;glDeleteShader&quot;);
+	functions-&gt;deleteProgram = (CL_GLFunctions::ptr_glDeleteObjectARB) CL_OpenGL::get_proc_address(&quot;glDeleteProgram&quot;);
+	functions-&gt;getHandle = (CL_GLFunctions::ptr_glGetHandleARB) CL_OpenGL::get_proc_address(&quot;glGetHandle&quot;);
+	functions-&gt;detachShader = (CL_GLFunctions::ptr_glDetachObjectARB) CL_OpenGL::get_proc_address(&quot;glDetachShader&quot;);
+	functions-&gt;createShader = (CL_GLFunctions::ptr_glCreateShaderObjectARB) CL_OpenGL::get_proc_address(&quot;glCreateShader&quot;);
+	functions-&gt;shaderSource = (CL_GLFunctions::ptr_glShaderSourceARB) CL_OpenGL::get_proc_address(&quot;glShaderSource&quot;);
+	functions-&gt;compileShader = (CL_GLFunctions::ptr_glCompileShaderARB) CL_OpenGL::get_proc_address(&quot;glCompileShader&quot;);
+	functions-&gt;createProgram = (CL_GLFunctions::ptr_glCreateProgramObjectARB) CL_OpenGL::get_proc_address(&quot;glCreateProgram&quot;);
+	functions-&gt;attachShader = (CL_GLFunctions::ptr_glAttachObjectARB) CL_OpenGL::get_proc_address(&quot;glAttachShader&quot;);
+	functions-&gt;linkProgram = (CL_GLFunctions::ptr_glLinkProgramARB) CL_OpenGL::get_proc_address(&quot;glLinkProgram&quot;);
+	functions-&gt;useProgram = (CL_GLFunctions::ptr_glUseProgramObjectARB) CL_OpenGL::get_proc_address(&quot;glUseProgram&quot;);
+	functions-&gt;validateProgram = (CL_GLFunctions::ptr_glValidateProgramARB) CL_OpenGL::get_proc_address(&quot;glValidateProgram&quot;);
+	functions-&gt;uniform1f = (CL_GLFunctions::ptr_glUniform1fARB) CL_OpenGL::get_proc_address(&quot;glUniform1f&quot;);
+	functions-&gt;uniform2f = (CL_GLFunctions::ptr_glUniform2fARB) CL_OpenGL::get_proc_address(&quot;glUniform2f&quot;);
+	functions-&gt;uniform3f = (CL_GLFunctions::ptr_glUniform3fARB) CL_OpenGL::get_proc_address(&quot;glUniform3f&quot;);
+	functions-&gt;uniform4f = (CL_GLFunctions::ptr_glUniform4fARB) CL_OpenGL::get_proc_address(&quot;glUniform4f&quot;);
+	functions-&gt;uniform1i = (CL_GLFunctions::ptr_glUniform1iARB) CL_OpenGL::get_proc_address(&quot;glUniform1i&quot;);
+	functions-&gt;uniform2i = (CL_GLFunctions::ptr_glUniform2iARB) CL_OpenGL::get_proc_address(&quot;glUniform2i&quot;);
+	functions-&gt;uniform3i = (CL_GLFunctions::ptr_glUniform3iARB) CL_OpenGL::get_proc_address(&quot;glUniform3i&quot;);
+	functions-&gt;uniform4i = (CL_GLFunctions::ptr_glUniform4iARB) CL_OpenGL::get_proc_address(&quot;glUniform4i&quot;);
+	functions-&gt;uniform1fv = (CL_GLFunctions::ptr_glUniform1fvARB) CL_OpenGL::get_proc_address(&quot;glUniform1fv&quot;);
+	functions-&gt;uniform2fv = (CL_GLFunctions::ptr_glUniform2fvARB) CL_OpenGL::get_proc_address(&quot;glUniform2fv&quot;);
+	functions-&gt;uniform3fv = (CL_GLFunctions::ptr_glUniform3fvARB) CL_OpenGL::get_proc_address(&quot;glUniform3fv&quot;);
+	functions-&gt;uniform4fv = (CL_GLFunctions::ptr_glUniform4fvARB) CL_OpenGL::get_proc_address(&quot;glUniform4fv&quot;);
+	functions-&gt;uniform1iv = (CL_GLFunctions::ptr_glUniform1ivARB) CL_OpenGL::get_proc_address(&quot;glUniform1iv&quot;);
+	functions-&gt;uniform2iv = (CL_GLFunctions::ptr_glUniform2ivARB) CL_OpenGL::get_proc_address(&quot;glUniform2iv&quot;);
+	functions-&gt;uniform3iv = (CL_GLFunctions::ptr_glUniform3ivARB) CL_OpenGL::get_proc_address(&quot;glUniform3iv&quot;);
+	functions-&gt;uniform4iv = (CL_GLFunctions::ptr_glUniform4ivARB) CL_OpenGL::get_proc_address(&quot;glUniform4iv&quot;);
+	functions-&gt;uniformMatrix2fv = (CL_GLFunctions::ptr_glUniformMatrix2fvARB) CL_OpenGL::get_proc_address(&quot;glUniformMatrix2fv&quot;);
+	functions-&gt;uniformMatrix3fv = (CL_GLFunctions::ptr_glUniformMatrix3fvARB) CL_OpenGL::get_proc_address(&quot;glUniformMatrix3fv&quot;);
+	functions-&gt;uniformMatrix4fv = (CL_GLFunctions::ptr_glUniformMatrix4fvARB) CL_OpenGL::get_proc_address(&quot;glUniformMatrix4fv&quot;);
+	functions-&gt;getProgramfv = (CL_GLFunctions::ptr_glGetObjectParameterfvARB) CL_OpenGL::get_proc_address(&quot;glGetProgramfv&quot;);
+	functions-&gt;getProgramiv = (CL_GLFunctions::ptr_glGetObjectParameterivARB) CL_OpenGL::get_proc_address(&quot;glGetProgramiv&quot;);
+	functions-&gt;getShaderfv = (CL_GLFunctions::ptr_glGetObjectParameterfvARB) CL_OpenGL::get_proc_address(&quot;glGetShaderfv&quot;);
+	functions-&gt;getShaderiv = (CL_GLFunctions::ptr_glGetObjectParameterivARB) CL_OpenGL::get_proc_address(&quot;glGetShaderiv&quot;);
+	functions-&gt;getShaderInfoLog = (CL_GLFunctions::ptr_glGetInfoLogARB) CL_OpenGL::get_proc_address(&quot;glGetShaderInfoLog&quot;);
+	functions-&gt;getProgramInfoLog = (CL_GLFunctions::ptr_glGetInfoLogARB) CL_OpenGL::get_proc_address(&quot;glGetProgramInfoLog&quot;);
+	functions-&gt;getAttachedShaders = (CL_GLFunctions::ptr_glGetAttachedObjectsARB) CL_OpenGL::get_proc_address(&quot;glGetAttachedShaders&quot;);
+	functions-&gt;getUniformLocation = (CL_GLFunctions::ptr_glGetUniformLocationARB) CL_OpenGL::get_proc_address(&quot;glGetUniformLocation&quot;);
+	functions-&gt;getActiveUniform = (CL_GLFunctions::ptr_glGetActiveUniformARB) CL_OpenGL::get_proc_address(&quot;glGetActiveUniform&quot;);
+	functions-&gt;getUniformfv = (CL_GLFunctions::ptr_glGetUniformfvARB) CL_OpenGL::get_proc_address(&quot;glGetUniformfv&quot;);
+	functions-&gt;getUniformiv = (CL_GLFunctions::ptr_glGetUniformivARB) CL_OpenGL::get_proc_address(&quot;glGetUniformiv&quot;);
+	functions-&gt;getShaderSource = (CL_GLFunctions::ptr_glGetShaderSourceARB) CL_OpenGL::get_proc_address(&quot;glGetShaderSource&quot;);
+	functions-&gt;vertexAttrib1f = (CL_GLFunctions::ptr_glVertexAttrib1fARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib1f&quot;);
+	functions-&gt;vertexAttrib1s = (CL_GLFunctions::ptr_glVertexAttrib1sARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib1s&quot;);
+	functions-&gt;vertexAttrib1d = (CL_GLFunctions::ptr_glVertexAttrib1dARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib1d&quot;);
+	functions-&gt;vertexAttrib2f = (CL_GLFunctions::ptr_glVertexAttrib2fARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib2f&quot;);
+	functions-&gt;vertexAttrib2s = (CL_GLFunctions::ptr_glVertexAttrib2sARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib2s&quot;);
+	functions-&gt;vertexAttrib2d = (CL_GLFunctions::ptr_glVertexAttrib2dARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib2d&quot;);
+	functions-&gt;vertexAttrib3f = (CL_GLFunctions::ptr_glVertexAttrib3fARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib3f&quot;);
+	functions-&gt;vertexAttrib3s = (CL_GLFunctions::ptr_glVertexAttrib3sARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib3s&quot;);
+	functions-&gt;vertexAttrib3d = (CL_GLFunctions::ptr_glVertexAttrib3dARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib3d&quot;);
+	functions-&gt;vertexAttrib4f = (CL_GLFunctions::ptr_glVertexAttrib4fARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4f&quot;);
+	functions-&gt;vertexAttrib4s = (CL_GLFunctions::ptr_glVertexAttrib4sARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4s&quot;);
+	functions-&gt;vertexAttrib4d = (CL_GLFunctions::ptr_glVertexAttrib4dARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4d&quot;);
+	functions-&gt;vertexAttrib4Nub = (CL_GLFunctions::ptr_glVertexAttrib4NubARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4Nub&quot;);
+	functions-&gt;vertexAttrib1fv = (CL_GLFunctions::ptr_glVertexAttrib1fvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib1fv&quot;);
+	functions-&gt;vertexAttrib1sv = (CL_GLFunctions::ptr_glVertexAttrib1svARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib1sv&quot;);
+	functions-&gt;vertexAttrib1dv = (CL_GLFunctions::ptr_glVertexAttrib1dvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib1dv&quot;);
+	functions-&gt;vertexAttrib2fv = (CL_GLFunctions::ptr_glVertexAttrib2fvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib2fv&quot;);
+	functions-&gt;vertexAttrib2sv = (CL_GLFunctions::ptr_glVertexAttrib2svARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib2sv&quot;);
+	functions-&gt;vertexAttrib2dv = (CL_GLFunctions::ptr_glVertexAttrib2dvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib2dv&quot;);
+	functions-&gt;vertexAttrib3fv = (CL_GLFunctions::ptr_glVertexAttrib3fvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib3fv&quot;);
+	functions-&gt;vertexAttrib3sv = (CL_GLFunctions::ptr_glVertexAttrib3svARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib3sv&quot;);
+	functions-&gt;vertexAttrib3dv = (CL_GLFunctions::ptr_glVertexAttrib3dvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib3dv&quot;);
+	functions-&gt;vertexAttrib4fv = (CL_GLFunctions::ptr_glVertexAttrib4fvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4fv&quot;);
+	functions-&gt;vertexAttrib4sv = (CL_GLFunctions::ptr_glVertexAttrib4svARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4sv&quot;);
+	functions-&gt;vertexAttrib4dv = (CL_GLFunctions::ptr_glVertexAttrib4dvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4dv&quot;);
+	functions-&gt;vertexAttrib4iv = (CL_GLFunctions::ptr_glVertexAttrib4ivARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4iv&quot;);
+	functions-&gt;vertexAttrib4bv = (CL_GLFunctions::ptr_glVertexAttrib4bvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4bv&quot;);
+	functions-&gt;vertexAttrib4ubv = (CL_GLFunctions::ptr_glVertexAttrib4ubvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4ubv&quot;);
+	functions-&gt;vertexAttrib4usv = (CL_GLFunctions::ptr_glVertexAttrib4usvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4usv&quot;);
+	functions-&gt;vertexAttrib4uiv = (CL_GLFunctions::ptr_glVertexAttrib4uivARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4uiv&quot;);
+	functions-&gt;vertexAttrib4Nbv = (CL_GLFunctions::ptr_glVertexAttrib4NbvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4Nbv&quot;);
+	functions-&gt;vertexAttrib4Nsv = (CL_GLFunctions::ptr_glVertexAttrib4NsvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4Nsv&quot;);
+	functions-&gt;vertexAttrib4Niv = (CL_GLFunctions::ptr_glVertexAttrib4NivARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4Niv&quot;);
+	functions-&gt;vertexAttrib4Nubv = (CL_GLFunctions::ptr_glVertexAttrib4NubvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4Nubv&quot;);
+	functions-&gt;vertexAttrib4Nusv = (CL_GLFunctions::ptr_glVertexAttrib4NusvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4Nusv&quot;);
+	functions-&gt;vertexAttrib4Nuiv = (CL_GLFunctions::ptr_glVertexAttrib4NuivARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4Nuiv&quot;);
+	functions-&gt;vertexAttribPointer = (CL_GLFunctions::ptr_glVertexAttribPointerARB) CL_OpenGL::get_proc_address(&quot;glVertexAttribPointer&quot;);
+	functions-&gt;enableVertexAttribArray = (CL_GLFunctions::ptr_glEnableVertexAttribArrayARB) CL_OpenGL::get_proc_address(&quot;glEnableVertexAttribArray&quot;);
+	functions-&gt;disableVertexAttribArray = (CL_GLFunctions::ptr_glDisableVertexAttribArrayARB) CL_OpenGL::get_proc_address(&quot;glDisableVertexAttribArray&quot;);
+	functions-&gt;bindAttribLocation = (CL_GLFunctions::ptr_glBindAttribLocationARB) CL_OpenGL::get_proc_address(&quot;glBindAttribLocation&quot;);
+	functions-&gt;getActiveAttrib = (CL_GLFunctions::ptr_glGetActiveAttribARB) CL_OpenGL::get_proc_address(&quot;glGetActiveAttrib&quot;);
+	functions-&gt;getAttribLocation = (CL_GLFunctions::ptr_glGetAttribLocationARB) CL_OpenGL::get_proc_address(&quot;glGetAttribLocation&quot;);
+	functions-&gt;getVertexAttribdv = (CL_GLFunctions::ptr_glGetVertexAttribdvARB) CL_OpenGL::get_proc_address(&quot;glGetVertexAttribdv&quot;);
+	functions-&gt;getVertexAttribfv = (CL_GLFunctions::ptr_glGetVertexAttribfvARB) CL_OpenGL::get_proc_address(&quot;glGetVertexAttribfv&quot;);
+	functions-&gt;getVertexAttribiv = (CL_GLFunctions::ptr_glGetVertexAttribivARB) CL_OpenGL::get_proc_address(&quot;glGetVertexAttribiv&quot;);
+	functions-&gt;getVertexAttribPointerv = (CL_GLFunctions::ptr_glGetVertexAttribPointervARB) CL_OpenGL::get_proc_address(&quot;glGetVertexAttribPointerv&quot;);
+	functions-&gt;drawBuffers = (CL_GLFunctions::ptr_glDrawBuffersARB) CL_OpenGL::get_proc_address(&quot;glDrawBuffers&quot;);
+	functions-&gt;stencilFuncSeparate = (CL_GLFunctions::ptr_glStencilFuncSeparateATI) CL_OpenGL::get_proc_address(&quot;glStencilFuncSeparate&quot;);
+	functions-&gt;stencilOpSeparate = (CL_GLFunctions::ptr_glStencilOpSeparateATI) CL_OpenGL::get_proc_address(&quot;glStencilOpSeparate&quot;);
+#else
+	functions-&gt;deleteShader = (CL_GLFunctions::ptr_glDeleteObjectARB) CL_OpenGL::get_proc_address(&quot;glDeleteObjectARB&quot;);
+	functions-&gt;deleteProgram = functions-&gt;deleteShader;
+	functions-&gt;getHandle = (CL_GLFunctions::ptr_glGetHandleARB) CL_OpenGL::get_proc_address(&quot;glGetHandleARB&quot;);
+	functions-&gt;detachShader = (CL_GLFunctions::ptr_glDetachObjectARB) CL_OpenGL::get_proc_address(&quot;glDetachObjectARB&quot;);
+	functions-&gt;createShader = (CL_GLFunctions::ptr_glCreateShaderObjectARB) CL_OpenGL::get_proc_address(&quot;glCreateShaderObjectARB&quot;);
+	functions-&gt;shaderSource = (CL_GLFunctions::ptr_glShaderSourceARB) CL_OpenGL::get_proc_address(&quot;glShaderSourceARB&quot;);
+	functions-&gt;compileShader = (CL_GLFunctions::ptr_glCompileShaderARB) CL_OpenGL::get_proc_address(&quot;glCompileShaderARB&quot;);
+	functions-&gt;createProgram = (CL_GLFunctions::ptr_glCreateProgramObjectARB) CL_OpenGL::get_proc_address(&quot;glCreateProgramObjectARB&quot;);
+	functions-&gt;attachShader = (CL_GLFunctions::ptr_glAttachObjectARB) CL_OpenGL::get_proc_address(&quot;glAttachObjectARB&quot;);
+	functions-&gt;linkProgram = (CL_GLFunctions::ptr_glLinkProgramARB) CL_OpenGL::get_proc_address(&quot;glLinkProgramARB&quot;);
+	functions-&gt;useProgram = (CL_GLFunctions::ptr_glUseProgramObjectARB) CL_OpenGL::get_proc_address(&quot;glUseProgramObjectARB&quot;);
+	functions-&gt;validateProgram = (CL_GLFunctions::ptr_glValidateProgramARB) CL_OpenGL::get_proc_address(&quot;glValidateProgramARB&quot;);
+	functions-&gt;uniform1f = (CL_GLFunctions::ptr_glUniform1fARB) CL_OpenGL::get_proc_address(&quot;glUniform1fARB&quot;);
+	functions-&gt;uniform2f = (CL_GLFunctions::ptr_glUniform2fARB) CL_OpenGL::get_proc_address(&quot;glUniform2fARB&quot;);
+	functions-&gt;uniform3f = (CL_GLFunctions::ptr_glUniform3fARB) CL_OpenGL::get_proc_address(&quot;glUniform3fARB&quot;);
+	functions-&gt;uniform4f = (CL_GLFunctions::ptr_glUniform4fARB) CL_OpenGL::get_proc_address(&quot;glUniform4fARB&quot;);
+	functions-&gt;uniform1i = (CL_GLFunctions::ptr_glUniform1iARB) CL_OpenGL::get_proc_address(&quot;glUniform1iARB&quot;);
+	functions-&gt;uniform2i = (CL_GLFunctions::ptr_glUniform2iARB) CL_OpenGL::get_proc_address(&quot;glUniform2iARB&quot;);
+	functions-&gt;uniform3i = (CL_GLFunctions::ptr_glUniform3iARB) CL_OpenGL::get_proc_address(&quot;glUniform3iARB&quot;);
+	functions-&gt;uniform4i = (CL_GLFunctions::ptr_glUniform4iARB) CL_OpenGL::get_proc_address(&quot;glUniform4iARB&quot;);
+	functions-&gt;uniform1fv = (CL_GLFunctions::ptr_glUniform1fvARB) CL_OpenGL::get_proc_address(&quot;glUniform1fvARB&quot;);
+	functions-&gt;uniform2fv = (CL_GLFunctions::ptr_glUniform2fvARB) CL_OpenGL::get_proc_address(&quot;glUniform2fvARB&quot;);
+	functions-&gt;uniform3fv = (CL_GLFunctions::ptr_glUniform3fvARB) CL_OpenGL::get_proc_address(&quot;glUniform3fvARB&quot;);
+	functions-&gt;uniform4fv = (CL_GLFunctions::ptr_glUniform4fvARB) CL_OpenGL::get_proc_address(&quot;glUniform4fvARB&quot;);
+	functions-&gt;uniform1iv = (CL_GLFunctions::ptr_glUniform1ivARB) CL_OpenGL::get_proc_address(&quot;glUniform1ivARB&quot;);
+	functions-&gt;uniform2iv = (CL_GLFunctions::ptr_glUniform2ivARB) CL_OpenGL::get_proc_address(&quot;glUniform2ivARB&quot;);
+	functions-&gt;uniform3iv = (CL_GLFunctions::ptr_glUniform3ivARB) CL_OpenGL::get_proc_address(&quot;glUniform3ivARB&quot;);
+	functions-&gt;uniform4iv = (CL_GLFunctions::ptr_glUniform4ivARB) CL_OpenGL::get_proc_address(&quot;glUniform4ivARB&quot;);
+	functions-&gt;uniformMatrix2fv = (CL_GLFunctions::ptr_glUniformMatrix2fvARB) CL_OpenGL::get_proc_address(&quot;glUniformMatrix2fvARB&quot;);
+	functions-&gt;uniformMatrix3fv = (CL_GLFunctions::ptr_glUniformMatrix3fvARB) CL_OpenGL::get_proc_address(&quot;glUniformMatrix3fvARB&quot;);
+	functions-&gt;uniformMatrix4fv = (CL_GLFunctions::ptr_glUniformMatrix4fvARB) CL_OpenGL::get_proc_address(&quot;glUniformMatrix4fvARB&quot;);
+	functions-&gt;getProgramfv = (CL_GLFunctions::ptr_glGetObjectParameterfvARB) CL_OpenGL::get_proc_address(&quot;glGetObjectParameterfvARB&quot;);
+	functions-&gt;getProgramiv = (CL_GLFunctions::ptr_glGetObjectParameterivARB) CL_OpenGL::get_proc_address(&quot;glGetObjectParameterivARB&quot;);
+	functions-&gt;getShaderfv = functions-&gt;getProgramfv;
+	functions-&gt;getShaderiv = functions-&gt;getProgramiv;
+	functions-&gt;getShaderInfoLog = (CL_GLFunctions::ptr_glGetInfoLogARB) CL_OpenGL::get_proc_address(&quot;glGetInfoLogARB&quot;);
+	functions-&gt;getProgramInfoLog = functions-&gt;getShaderInfoLog;
+	functions-&gt;getAttachedShaders = (CL_GLFunctions::ptr_glGetAttachedObjectsARB) CL_OpenGL::get_proc_address(&quot;glGetAttachedObjectsARB&quot;);
+	functions-&gt;getUniformLocation = (CL_GLFunctions::ptr_glGetUniformLocationARB) CL_OpenGL::get_proc_address(&quot;glGetUniformLocationARB&quot;);
+	functions-&gt;getActiveUniform = (CL_GLFunctions::ptr_glGetActiveUniformARB) CL_OpenGL::get_proc_address(&quot;glGetActiveUniformARB&quot;);
+	functions-&gt;getUniformfv = (CL_GLFunctions::ptr_glGetUniformfvARB) CL_OpenGL::get_proc_address(&quot;glGetUniformfvARB&quot;);
+	functions-&gt;getUniformiv = (CL_GLFunctions::ptr_glGetUniformivARB) CL_OpenGL::get_proc_address(&quot;glGetUniformivARB&quot;);
+	functions-&gt;getShaderSource = (CL_GLFunctions::ptr_glGetShaderSourceARB) CL_OpenGL::get_proc_address(&quot;glGetShaderSourceARB&quot;);
+	functions-&gt;vertexAttrib1f = (CL_GLFunctions::ptr_glVertexAttrib1fARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib1fARB&quot;);
+	functions-&gt;vertexAttrib1s = (CL_GLFunctions::ptr_glVertexAttrib1sARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib1sARB&quot;);
+	functions-&gt;vertexAttrib1d = (CL_GLFunctions::ptr_glVertexAttrib1dARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib1dARB&quot;);
+	functions-&gt;vertexAttrib2f = (CL_GLFunctions::ptr_glVertexAttrib2fARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib2fARB&quot;);
+	functions-&gt;vertexAttrib2s = (CL_GLFunctions::ptr_glVertexAttrib2sARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib2sARB&quot;);
+	functions-&gt;vertexAttrib2d = (CL_GLFunctions::ptr_glVertexAttrib2dARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib2dARB&quot;);
+	functions-&gt;vertexAttrib3f = (CL_GLFunctions::ptr_glVertexAttrib3fARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib3fARB&quot;);
+	functions-&gt;vertexAttrib3s = (CL_GLFunctions::ptr_glVertexAttrib3sARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib3sARB&quot;);
+	functions-&gt;vertexAttrib3d = (CL_GLFunctions::ptr_glVertexAttrib3dARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib3dARB&quot;);
+	functions-&gt;vertexAttrib4f = (CL_GLFunctions::ptr_glVertexAttrib4fARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4fARB&quot;);
+	functions-&gt;vertexAttrib4s = (CL_GLFunctions::ptr_glVertexAttrib4sARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4sARB&quot;);
+	functions-&gt;vertexAttrib4d = (CL_GLFunctions::ptr_glVertexAttrib4dARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4dARB&quot;);
+	functions-&gt;vertexAttrib4Nub = (CL_GLFunctions::ptr_glVertexAttrib4NubARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4NubARB&quot;);
+	functions-&gt;vertexAttrib1fv = (CL_GLFunctions::ptr_glVertexAttrib1fvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib1fvARB&quot;);
+	functions-&gt;vertexAttrib1sv = (CL_GLFunctions::ptr_glVertexAttrib1svARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib1svARB&quot;);
+	functions-&gt;vertexAttrib1dv = (CL_GLFunctions::ptr_glVertexAttrib1dvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib1dvARB&quot;);
+	functions-&gt;vertexAttrib2fv = (CL_GLFunctions::ptr_glVertexAttrib2fvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib2fvARB&quot;);
+	functions-&gt;vertexAttrib2sv = (CL_GLFunctions::ptr_glVertexAttrib2svARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib2svARB&quot;);
+	functions-&gt;vertexAttrib2dv = (CL_GLFunctions::ptr_glVertexAttrib2dvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib2dvARB&quot;);
+	functions-&gt;vertexAttrib3fv = (CL_GLFunctions::ptr_glVertexAttrib3fvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib3fvARB&quot;);
+	functions-&gt;vertexAttrib3sv = (CL_GLFunctions::ptr_glVertexAttrib3svARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib3svARB&quot;);
+	functions-&gt;vertexAttrib3dv = (CL_GLFunctions::ptr_glVertexAttrib3dvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib3dvARB&quot;);
+	functions-&gt;vertexAttrib4fv = (CL_GLFunctions::ptr_glVertexAttrib4fvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4fvARB&quot;);
+	functions-&gt;vertexAttrib4sv = (CL_GLFunctions::ptr_glVertexAttrib4svARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4svARB&quot;);
+	functions-&gt;vertexAttrib4dv = (CL_GLFunctions::ptr_glVertexAttrib4dvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4dvARB&quot;);
+	functions-&gt;vertexAttrib4iv = (CL_GLFunctions::ptr_glVertexAttrib4ivARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4ivARB&quot;);
+	functions-&gt;vertexAttrib4bv = (CL_GLFunctions::ptr_glVertexAttrib4bvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4bvARB&quot;);
+	functions-&gt;vertexAttrib4ubv = (CL_GLFunctions::ptr_glVertexAttrib4ubvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4ubvARB&quot;);
+	functions-&gt;vertexAttrib4usv = (CL_GLFunctions::ptr_glVertexAttrib4usvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4usvARB&quot;);
+	functions-&gt;vertexAttrib4uiv = (CL_GLFunctions::ptr_glVertexAttrib4uivARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4uivARB&quot;);
+	functions-&gt;vertexAttrib4Nbv = (CL_GLFunctions::ptr_glVertexAttrib4NbvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4NbvARB&quot;);
+	functions-&gt;vertexAttrib4Nsv = (CL_GLFunctions::ptr_glVertexAttrib4NsvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4NsvARB&quot;);
+	functions-&gt;vertexAttrib4Niv = (CL_GLFunctions::ptr_glVertexAttrib4NivARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4NivARB&quot;);
+	functions-&gt;vertexAttrib4Nubv = (CL_GLFunctions::ptr_glVertexAttrib4NubvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4NubvARB&quot;);
+	functions-&gt;vertexAttrib4Nusv = (CL_GLFunctions::ptr_glVertexAttrib4NusvARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4NusvARB&quot;);
+	functions-&gt;vertexAttrib4Nuiv = (CL_GLFunctions::ptr_glVertexAttrib4NuivARB) CL_OpenGL::get_proc_address(&quot;glVertexAttrib4NuivARB&quot;);
+	functions-&gt;vertexAttribPointer = (CL_GLFunctions::ptr_glVertexAttribPointerARB) CL_OpenGL::get_proc_address(&quot;glVertexAttribPointerARB&quot;);
+	functions-&gt;enableVertexAttribArray = (CL_GLFunctions::ptr_glEnableVertexAttribArrayARB) CL_OpenGL::get_proc_address(&quot;glEnableVertexAttribArrayARB&quot;);
+	functions-&gt;disableVertexAttribArray = (CL_GLFunctions::ptr_glDisableVertexAttribArrayARB) CL_OpenGL::get_proc_address(&quot;glDisableVertexAttribArrayARB&quot;);
+	functions-&gt;bindAttribLocation = (CL_GLFunctions::ptr_glBindAttribLocationARB) CL_OpenGL::get_proc_address(&quot;glBindAttribLocationARB&quot;);
+	functions-&gt;getActiveAttrib = (CL_GLFunctions::ptr_glGetActiveAttribARB) CL_OpenGL::get_proc_address(&quot;glGetActiveAttribARB&quot;);
+	functions-&gt;getAttribLocation = (CL_GLFunctions::ptr_glGetAttribLocationARB) CL_OpenGL::get_proc_address(&quot;glGetAttribLocationARB&quot;);
+	functions-&gt;getVertexAttribdv = (CL_GLFunctions::ptr_glGetVertexAttribdvARB) CL_OpenGL::get_proc_address(&quot;glGetVertexAttribdvARB&quot;);
+	functions-&gt;getVertexAttribfv = (CL_GLFunctions::ptr_glGetVertexAttribfvARB) CL_OpenGL::get_proc_address(&quot;glGetVertexAttribfvARB&quot;);
+	functions-&gt;getVertexAttribiv = (CL_GLFunctions::ptr_glGetVertexAttribivARB) CL_OpenGL::get_proc_address(&quot;glGetVertexAttribivARB&quot;);
+	functions-&gt;getVertexAttribPointerv = (CL_GLFunctions::ptr_glGetVertexAttribPointervARB) CL_OpenGL::get_proc_address(&quot;glGetVertexAttribPointervARB&quot;);
+	functions-&gt;drawBuffers = (CL_GLFunctions::ptr_glDrawBuffersARB) CL_OpenGL::get_proc_address(&quot;glDrawBuffersARB&quot;);
+	functions-&gt;stencilFuncSeparate = (CL_GLFunctions::ptr_glStencilFuncSeparateATI) CL_OpenGL::get_proc_address(&quot;glStencilFuncSeparateATI&quot;);
+	functions-&gt;stencilOpSeparate = (CL_GLFunctions::ptr_glStencilOpSeparateATI) CL_OpenGL::get_proc_address(&quot;glStencilOpSeparateATI&quot;);
+	functions-&gt;activeStencilFaceEXT = (CL_GLFunctions::ptr_glActiveStencilFaceEXT) CL_OpenGL::get_proc_address(&quot;glActiveStencilFaceEXT&quot;);
+#endif
+
+	return functions;
+}

Added: trunk/clanlib/GL/opengl_state_generic.h
===================================================================
--- trunk/clanlib/GL/opengl_state_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/opengl_state_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,250 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_opengl_state_generic
+#define header_opengl_state_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;list&gt;
+#include &lt;map&gt;
+#ifndef WIN32
+#ifdef __APPLE__
+#include &lt;AGL/agl.h&gt;
+#else
+#include &lt;GL/glx.h&gt;
+#endif
+#endif
+#include &quot;API/GL/opengl.h&quot;
+
+#include &quot;API/signals.h&quot;
+
+class CL_OpenGLStateData;
+class CL_GraphicContext;
+class CL_GraphicContext_OpenGL;
+class CL_GLFunctions;
+
+class CL_OpenGLState_Generic
+{
+//! Construction:
+public:
+	CL_OpenGLState_Generic(CL_GraphicContext *gc);
+
+	CL_OpenGLState_Generic(CL_GraphicContext_OpenGL *gc_opengl);
+
+	virtual ~CL_OpenGLState_Generic();
+
+//! Attributes:
+public:
+	CL_GraphicContext_OpenGL *gc_opengl;
+
+	std::list&lt; std::pair&lt;CL_OpenGLStateData *, bool&gt; &gt; data_objects;
+
+	//: Returns true if opengl state is currently active.
+	bool is_active() const;
+
+//! Operations:
+public:
+	void set_active();
+
+	//: Begin window 2D rendering mode.
+	//param upside_down: If set to true, (0,0) will be in the lower left corner.
+	//- &lt;p&gt; This effectively loads a Orto 2D projection matrix and makes sure
+	//- the device are using sane texture parameter values.&lt;/p&gt;
+	void setup_2d(bool upside_down);
+
+//! Implementation:
+private:
+	void init();
+
+	//: Updates scissor if opengl state is currently active.
+	void on_update_scissor();
+
+	void on_update_modelview();
+
+	void on_update_viewport();
+
+	void flush();
+
+	void save();
+
+	void load();
+
+#ifdef WIN32
+	// Selects specified context into opengl state machine.
+	static void set_context(HDC drawable, HGLRC context);
+#else
+#ifdef __APPLE__
+	// Selects specified context into opengl state machine.
+	static void set_context(AGLContext context);
+#else
+	// Selects specified context into opengl state machine.
+	static void set_context(Display *disp, GLXDrawable drawable, GLXContext context);
+#endif
+#endif
+
+	static void clear_context (void);
+
+#ifdef WIN32
+	//: Active opengl drawable.
+	static HDC cur_drawable;
+
+	//: Active opengl context.
+	static HGLRC cur_context;
+
+	//: Context to function pointers:
+	static std::map&lt;std::pair&lt;HDC, HGLRC&gt;, CL_GLFunctions *&gt; function_map;
+#else
+#ifdef __APPLE__
+	//: Active opengl context.
+	static AGLContext cur_context;
+
+	//: Context to function pointers:
+	static std::map&lt;AGLContext, CL_GLFunctions *&gt; function_map;
+#else
+	//: Active opengl drawable.
+	static GLXDrawable cur_drawable;
+
+	//: Active opengl context.
+	static GLXContext cur_context;
+
+	//: Context to function pointers:
+	static std::map&lt;std::pair&lt;GLXDrawable, GLXContext&gt;, CL_GLFunctions *&gt; function_map;
+#endif
+#endif
+	static CL_OpenGLState_Generic *active_state;
+
+	static CL_GLFunctions *setup_binds();
+
+	bool in_2d;
+
+	CLboolean state_texture_2d;
+
+	CLint state_bind_texture_2d;
+
+	CLboolean state_blend;
+
+	CLboolean state_fog;
+
+	CLboolean state_depth_test;
+
+	CLboolean state_scissor_test;
+
+	CLint state_viewport[4];
+
+	CLint state_scissor_box[4];
+
+	CLdouble state_clear_color[4];
+
+	CLint state_blendfunc_sfactor;
+
+	CLint state_blendfunc_dfactor;
+
+	CLint state_blendfunc_sfactor_alpha;
+
+	CLint state_blendfunc_dfactor_alpha;
+
+	CLdouble state_color[4];
+
+	CLint state_vertex_pointer_size;
+
+	CLint state_vertex_pointer_type;
+
+	CLsizei state_vertex_pointer_stride;
+
+	CLvoid *state_vertex_pointer;
+
+	CLint state_color_pointer_size;
+
+	CLint state_color_pointer_type;
+
+	CLsizei state_color_pointer_stride;
+
+	CLvoid *state_color_pointer;
+
+	CLint state_texcoord_pointer_size;
+
+	CLint state_texcoord_pointer_type;
+
+	CLsizei state_texcoord_pointer_stride;
+
+	CLvoid *state_texcoord_pointer;
+
+	CLboolean state_vertex_array;
+
+	CLboolean state_color_array;
+
+	CLboolean state_texture_coord_array;
+
+	CLdouble state_matrix_texture[16];
+
+	CLdouble state_matrix_projection[16];
+
+	CLdouble state_matrix_modelview[16];
+
+	CLint state_matrix_mode;
+
+	CLfloat state_texture_env_mode;
+
+	CLboolean state_stencil_test;
+
+	CLint state_stencil_func;
+	
+	CLint state_stencil_value_mask;
+	
+	CLint state_stencil_ref;
+
+	CLint state_stencil_fail;
+
+	CLint state_stencil_pass_depth_pass;
+
+	CLint state_stencil_pass_depth_fail;
+
+	CLint state_alpha_test_func;
+
+	CLdouble state_alpha_test_ref;
+
+	CLboolean state_alpha_test;
+	
+	CLboolean state_color_write_mask[4];
+
+	CLint state_polygon_mode[2];
+
+	bool is_upside_down;
+
+	bool need_update_viewport;
+
+	CL_SlotContainer slots;
+
+	friend class CL_SetupGL;
+};
+
+#endif

Added: trunk/clanlib/GL/opengl_surface.cpp
===================================================================
--- trunk/clanlib/GL/opengl_surface.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/opengl_surface.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,83 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/GL/opengl_surface.h&quot;
+#include &quot;API/GL/opengl_wrap.h&quot;
+#include &quot;surface_target_opengl.h&quot;
+
+#define gl_target ((CL_Surface_Target_OpenGL *) impl-&gt;target)
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLSurface construction:
+
+CL_OpenGLSurface::CL_OpenGLSurface() : CL_Surface()
+{
+}
+	
+CL_OpenGLSurface::CL_OpenGLSurface(const CL_Surface &amp;copy) : CL_Surface(copy)
+{
+}
+	
+CL_OpenGLSurface::CL_OpenGLSurface(
+	CL_PixelBuffer provider,
+	int flag) :
+	CL_Surface(provider, flag)
+{
+}
+
+CL_OpenGLSurface::CL_OpenGLSurface(
+	const std::string &amp;resource_id,
+	CL_ResourceManager *manager) : CL_Surface(resource_id, manager)
+{
+}
+
+CL_OpenGLSurface::CL_OpenGLSurface(
+	const std::string &amp;filename,
+	int flag) : CL_Surface(filename, flag)
+{
+}
+
+CL_OpenGLSurface::~CL_OpenGLSurface()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLSurface attributes:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLSurface operations:
+
+void CL_OpenGLSurface::bind()
+{
+	clBindTexture(CL_TEXTURE_2D, gl_target-&gt;handle);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLSurface implementation:

Added: trunk/clanlib/GL/opengl_target.cpp
===================================================================
--- trunk/clanlib/GL/opengl_target.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/opengl_target.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,183 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;opengl_target.h&quot;
+#ifdef WIN32
+// #include &quot;Display/Win32/font_win32.h&quot;
+#include &quot;WGL/display_window_opengl.h&quot;
+#include &quot;API/Display/Providers/dc_buffer.h&quot;
+#include &quot;API/Display/sprite_description.h&quot;
+#include &quot;API/Display/pixel_format.h&quot;
+#else
+#ifdef __APPLE__
+#include &quot;AGL/display_window_opengl.h&quot;
+#else
+// #include &quot;GLX/font_x11.h&quot;
+#include &quot;GLX/display_window_opengl.h&quot;
+#endif
+#endif
+#include &quot;surface_target_opengl.h&quot;
+#include &quot;canvas_opengl.h&quot;
+#include &quot;Display/font_target_sprite.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLTarget construction:
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLTarget attributes:
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLTarget operations:
+
+CL_DisplayWindow_Generic *CL_OpenGLTarget::create_window()
+{
+	return new CL_DisplayWindow_OpenGL;
+}
+
+CL_Surface_Target *CL_OpenGLTarget::create_surface(
+	CL_PixelBuffer provider,
+	int flag)
+{
+	return new CL_Surface_Target_OpenGL(provider, flag);
+}
+
+CL_Canvas_Generic *CL_OpenGLTarget::create_canvas()
+{
+	return new CL_Canvas_OpenGL;
+}
+
+CL_Font_Target* CL_OpenGLTarget::create_system_font_target(
+	CL_Font_Generic *attributes,
+	const std::string &amp;font_name,
+	const std::string &amp;letters,
+	int font_height,
+	int font_width,
+	bool bold,
+	bool italic,
+	bool underline,
+	bool strikeout)
+{
+#ifdef WIN32
+	// Create the font we need:
+	HFONT font = CreateFont(
+		font_height,
+		font_width,
+		0,
+		0,
+		bold ? FW_BOLD : FW_NORMAL,
+		italic ? TRUE : FALSE,
+		underline ? TRUE : FALSE,
+		strikeout ? TRUE : FALSE,
+		DEFAULT_CHARSET,
+		OUT_DEFAULT_PRECIS,
+		CLIP_DEFAULT_PRECIS,
+		DEFAULT_QUALITY,
+		FF_DONTCARE,
+		font_name.c_str());
+
+	const int num_chars = letters.length();
+	int i;
+	int total_width = 0;
+	int pos = 0;
+	HDC screen_dc;
+	HFONT old_font;
+	INT widths[256];
+
+	// Get the glyph widths:
+	screen_dc = GetDC(0);
+	old_font = (HFONT) SelectObject(screen_dc, font);
+	GetCharWidth32(screen_dc, 0, 255, widths);
+	SelectObject(screen_dc, old_font);
+
+	// Figure out how big our device context has to be:
+	for (i=0; i&lt;num_chars; i++)
+	{
+		total_width += widths[static_cast&lt;unsigned char&gt;(letters[i])];
+	}
+
+	// Create device context, set it up for glyph drawing:
+	CL_DeviceContextBuffer dc_buffer(screen_dc, total_width, font_height, true);
+	RECT rc = { 0, 0, total_width, font_height };
+	SetBkColor(dc_buffer.get_dc(), RGB(0,0,0));
+	FillRect(dc_buffer.get_dc(), &amp;rc, (HBRUSH) GetStockObject(BLACK_BRUSH));
+	SetTextColor(dc_buffer.get_dc(), RGB(255,255,255));
+	SetBkMode(dc_buffer.get_dc(), OPAQUE);
+	old_font = (HFONT) SelectObject(dc_buffer.get_dc(), font);
+
+	// Draw each glyph:
+	for (i=0; i&lt;num_chars; i++)
+	{
+		const unsigned char cur = static_cast&lt;unsigned char&gt;(letters[i]);
+		TextOut(dc_buffer.get_dc(), pos, 0, (char *)(&amp;cur), 1);
+		pos += widths[cur];
+	}
+	SelectObject(dc_buffer.get_dc(), old_font);
+	DeleteObject(font);
+
+	// Add each glyph as a frame:
+	CL_SpriteDescription desc;
+	pos = 0;
+	for (i=0; i&lt;num_chars; i++)
+	{
+		const int character = static_cast&lt;unsigned char&gt;(letters[i]);
+		desc.add_gridclipped_frames(dc_buffer, pos, 0, widths[character], font_height, 1, 1);
+		pos += widths[character];
+	}
+
+	// Set up the actual font data:
+	return new CL_Font_Target_Sprite(
+		attributes,
+		CL_Sprite(desc),
+		letters);
+#else
+	return 0;
+/*		new CL_Font_X11(
+		attributes,
+		font_name,
+		letters,
+		height,
+		width,
+		bold,
+		italic,
+		underline,
+		strikeout);
+*/
+#endif
+}
+
+bool CL_OpenGLTarget::enable_packer()
+{
+	return true;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLTarget implementation:

Added: trunk/clanlib/GL/opengl_target.h
===================================================================
--- trunk/clanlib/GL/opengl_target.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/opengl_target.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,74 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_opengl_target
+#define header_opengl_target
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;Display/display_target.h&quot;
+
+class CL_OpenGLTarget : public CL_DisplayTarget
+{
+//! Construction:
+public:
+
+//! Attributes:
+public:
+
+//! Operations:
+public:
+	virtual CL_DisplayWindow_Generic *create_window();
+
+	virtual CL_Surface_Target *create_surface(
+		CL_PixelBuffer provider,
+		int flag);
+
+	virtual CL_Canvas_Generic *create_canvas();
+
+	virtual CL_Font_Target* create_system_font_target(
+		CL_Font_Generic *attributes,
+		const std::string &amp;font_name,
+		const std::string &amp;letters,
+		int height,
+		int width,
+		bool bold,
+		bool italic,
+		bool underline,
+		bool strikeout);
+
+	virtual bool enable_packer();
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/GL/opengl_window.cpp
===================================================================
--- trunk/clanlib/GL/opengl_window.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/opengl_window.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,114 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/GL/opengl_window.h&quot;
+#include &quot;API/Display/display_window_description.h&quot;
+
+#ifdef WIN32
+#include &quot;WGL/display_window_opengl.h&quot;
+#else
+#ifdef __APPLE__
+#include &quot;AGL/display_window_opengl.h&quot;
+#else
+#include &quot;GLX/display_window_opengl.h&quot;
+#endif
+#endif
+
+#define gl_impl ((CL_DisplayWindow_OpenGL *) impl)
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLWindow construction:
+
+CL_OpenGLWindow::CL_OpenGLWindow() : CL_DisplayWindow()
+{
+}
+
+CL_OpenGLWindow::CL_OpenGLWindow(const CL_OpenGLWindow &amp;copy) : CL_DisplayWindow(copy)
+{
+}
+
+CL_OpenGLWindow::CL_OpenGLWindow(
+	const std::string &amp;title,
+	int width,
+	int height,
+	bool start_fullscreen,
+	bool allow_resize,
+	int flipping_buffers)
+: CL_DisplayWindow(new CL_DisplayWindow_OpenGL)
+{
+	CL_DisplayWindowDescription desc;
+	desc.set_title(title);
+	desc.set_size(CL_Size(width, height));
+	desc.set_fullscreen(start_fullscreen);
+	desc.set_allow_resize(allow_resize);
+	desc.set_flipping_buffers(flipping_buffers);
+
+	gl_impl-&gt;create_window(desc);
+
+	// Automatically map first created display window as 'CL_Display current'.
+	if (CL_DisplayWindow_Generic::current == 0) CL_DisplayWindow_Generic::current = this;
+
+	gl_impl-&gt;sig_resize(get_width(), get_height());
+}
+
+CL_OpenGLWindow::~CL_OpenGLWindow()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLWindow attributes:
+
+#ifdef WIN32
+
+HGLRC CL_OpenGLWindow::get_context()
+{
+	return gl_impl-&gt;get_context();
+}
+
+HDC CL_OpenGLWindow::get_dc()
+{
+	return gl_impl-&gt;get_dc();
+}
+
+HWND CL_OpenGLWindow::get_wnd()
+{
+	return gl_impl-&gt;get_hwnd();
+}
+#else
+#ifndef __APPLE__
+Display *CL_OpenGLWindow::get_wnd()
+{
+	return gl_impl-&gt;get_hwnd();
+}
+#endif
+#endif
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLWindow operations:

Added: trunk/clanlib/GL/opengl_window_description.cpp
===================================================================
--- trunk/clanlib/GL/opengl_window_description.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/opengl_window_description.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,214 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/GL/opengl_window.h&quot;
+#include &quot;API/GL/opengl_window_description.h&quot;
+#include &quot;opengl_window_description_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLWindowDescription construction:
+
+CL_OpenGLWindowDescription::CL_OpenGLWindowDescription()
+: CL_DisplayWindowDescription(new CL_OpenGLWindowDescription_Generic)
+{
+}
+
+CL_OpenGLWindowDescription::~CL_OpenGLWindowDescription()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLWindowDescription attributes:
+
+int CL_OpenGLWindowDescription::get_buffer_size() const
+{
+	return dynamic_cast&lt;const CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;buffer_size;
+}
+
+int CL_OpenGLWindowDescription::get_level() const
+{
+	return dynamic_cast&lt;const CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;level;
+}
+
+bool CL_OpenGLWindowDescription::get_rgba() const
+{
+	return dynamic_cast&lt;const CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;rgba;
+}
+
+bool CL_OpenGLWindowDescription::get_doublebuffer() const
+{
+	return dynamic_cast&lt;const CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;doublebuffer;
+}
+
+bool CL_OpenGLWindowDescription::get_stereo() const
+{
+	return dynamic_cast&lt;const CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;stereo;
+}
+
+int CL_OpenGLWindowDescription::get_aux_buffers() const
+{
+	return dynamic_cast&lt;const CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;aux_buffers;
+}
+
+int CL_OpenGLWindowDescription::get_red_size() const
+{
+	return dynamic_cast&lt;const CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;red_size;
+}
+
+int CL_OpenGLWindowDescription::get_green_size() const
+{
+	return dynamic_cast&lt;const CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;green_size;
+}
+
+int CL_OpenGLWindowDescription::get_blue_size() const
+{
+	return dynamic_cast&lt;const CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;blue_size;
+}
+
+int CL_OpenGLWindowDescription::get_alpha_size() const
+{
+	return dynamic_cast&lt;const CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;alpha_size;
+}
+
+int CL_OpenGLWindowDescription::get_depth_size() const
+{
+	return dynamic_cast&lt;const CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;depth_size;
+}
+
+int CL_OpenGLWindowDescription::get_stencil_size() const
+{
+	return dynamic_cast&lt;const CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;stencil_size;
+}
+
+int CL_OpenGLWindowDescription::get_accum_red_size() const
+{
+	return dynamic_cast&lt;const CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;accum_red_size;
+}
+
+int CL_OpenGLWindowDescription::get_accum_green_size() const
+{
+	return dynamic_cast&lt;const CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;accum_green_size;
+}
+
+int CL_OpenGLWindowDescription::get_accum_blue_size() const
+{
+	return dynamic_cast&lt;const CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;accum_blue_size;
+}
+
+int CL_OpenGLWindowDescription::get_accum_alpha_size() const
+{
+	return dynamic_cast&lt;const CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;accum_alpha_size;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLWindowDescription operations:
+
+void CL_OpenGLWindowDescription::set_rgba(bool value)
+{
+	dynamic_cast&lt;CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;rgba = value;
+}
+
+void CL_OpenGLWindowDescription::set_doublebuffer(bool value)
+{
+	dynamic_cast&lt;CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;doublebuffer = value;
+}
+
+void CL_OpenGLWindowDescription::set_stereo(bool value)
+{
+	dynamic_cast&lt;CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;stereo = value;
+}
+
+void CL_OpenGLWindowDescription::set_buffer_size(int value)
+{
+	dynamic_cast&lt;CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;buffer_size = value;
+}
+
+void CL_OpenGLWindowDescription::set_level(int value)
+{
+	dynamic_cast&lt;CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;level = value;
+}
+
+void CL_OpenGLWindowDescription::set_aux_buffers(int value)
+{
+	dynamic_cast&lt;CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;aux_buffers = value;
+}
+
+void CL_OpenGLWindowDescription::set_red_size(int value)
+{
+	dynamic_cast&lt;CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;red_size = value;
+}
+
+void CL_OpenGLWindowDescription::set_green_size(int value)
+{
+	dynamic_cast&lt;CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;green_size = value;
+}
+
+void CL_OpenGLWindowDescription::set_blue_size(int value)
+{
+	dynamic_cast&lt;CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;blue_size = value;
+}
+
+void CL_OpenGLWindowDescription::set_alpha_size(int value)
+{
+	dynamic_cast&lt;CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;alpha_size = value;
+}
+
+void CL_OpenGLWindowDescription::set_depth_size(int value)
+{
+	dynamic_cast&lt;CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;depth_size = value;
+}
+
+void CL_OpenGLWindowDescription::set_stencil_size(int value)
+{
+	dynamic_cast&lt;CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;stencil_size = value;
+}
+
+void CL_OpenGLWindowDescription::set_accum_red_size(int value)
+{
+	dynamic_cast&lt;CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;accum_red_size = value;
+}
+
+void CL_OpenGLWindowDescription::set_accum_green_size(int value)
+{
+	dynamic_cast&lt;CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;accum_green_size = value;
+}
+
+void CL_OpenGLWindowDescription::set_accum_blue_size(int value)
+{
+	dynamic_cast&lt;CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;accum_blue_size = value;
+}
+
+void CL_OpenGLWindowDescription::set_accum_alpha_size(int value)
+{
+	dynamic_cast&lt;CL_OpenGLWindowDescription_Generic*&gt;(impl.get())-&gt;accum_alpha_size = value;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_OpenGLWindowDescription implementation:

Added: trunk/clanlib/GL/opengl_window_description_generic.h
===================================================================
--- trunk/clanlib/GL/opengl_window_description_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/opengl_window_description_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,84 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_opengl_window_description_generic
+#define header_opengl_window_description_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;Display/display_window_description_generic.h&quot;
+
+class CL_OpenGLWindowDescription_Generic : public CL_DisplayWindowDescription_Generic
+{
+//! Construction:
+public:
+	CL_OpenGLWindowDescription_Generic()
+	{
+		rgba = true;
+		doublebuffer = true;
+		stereo = false;
+		buffer_size = 16;
+		level = 0;
+		aux_buffers = 0;
+		red_size = 4;
+		green_size = 4;
+		blue_size = 4;
+		alpha_size = 4;
+		depth_size = 16;
+		stencil_size = 8;
+		accum_red_size = 0;
+		accum_green_size = 0;
+		accum_blue_size = 0;
+		accum_alpha_size = 0;
+	}
+
+//! Attributes:
+public:
+
+	bool rgba;
+	bool doublebuffer;
+	bool stereo;
+	int buffer_size;
+	int level;
+	int aux_buffers;
+	int red_size;
+	int green_size;
+	int blue_size;
+	int alpha_size;
+	int depth_size;
+	int stencil_size;
+	int accum_red_size;
+	int accum_green_size;
+	int accum_blue_size;
+	int accum_alpha_size;
+};
+
+#endif

Added: trunk/clanlib/GL/pixel_buffer_opengl_texture.cpp
===================================================================
--- trunk/clanlib/GL/pixel_buffer_opengl_texture.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/pixel_buffer_opengl_texture.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,126 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;pixel_buffer_opengl_texture.h&quot;
+#include &quot;Display/graphic_context_generic.h&quot;
+#include &quot;API/GL/opengl_state.h&quot;
+#include &quot;API/GL/opengl_wrap.h&quot;
+#include &quot;gl_state_checker.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_PixelBuffer_OpenGL_Texture construction:
+
+CL_PixelBuffer_OpenGL_Texture::CL_PixelBuffer_OpenGL_Texture(
+	int offset_x,
+	int offset_y,
+	int width,
+	int height,
+	CLuint handle,
+	CL_GraphicContext *gc)
+: offset_x(offset_x), offset_y(offset_y), handle(handle), gc(gc), data(0)
+{
+	CL_PixelBuffer_Generic::width = width;
+	CL_PixelBuffer_Generic::height = height;
+
+	format.set_depth(32);
+	format.set_red_mask  (0x000000ff);
+	format.set_green_mask(0x0000ff00);
+	format.set_blue_mask (0x00ff0000);
+	format.set_alpha_mask(0xff000000);
+	format.enable_colorkey(false);
+
+	// todo: Use CL_TEXTURE_INTERNAL_FORMAT to use the native format of texture instead.
+
+	CL_OpenGLState state(gc);
+	state.set_active();
+	clEnable(CL_TEXTURE_2D);
+	clBindTexture(CL_TEXTURE_2D, handle);
+	
+	CLint internal_format = 0;
+
+	clGetTexLevelParameteriv(CL_TEXTURE_2D, 0, CL_TEXTURE_WIDTH, &amp;texture_width);
+	clGetTexLevelParameteriv(CL_TEXTURE_2D, 0, CL_TEXTURE_HEIGHT, &amp;texture_height);
+	clGetTexLevelParameteriv(CL_TEXTURE_2D, 0, CL_TEXTURE_INTERNAL_FORMAT, &amp;internal_format);
+	
+	CLint align;
+	clGetIntegerv(CL_PACK_ALIGNMENT, &amp;align);
+	pitch = (texture_width*4+align-1)/align;
+	pitch *= align;
+}
+
+CL_PixelBuffer_OpenGL_Texture::~CL_PixelBuffer_OpenGL_Texture()
+{
+	delete[] data;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_PixelBuffer_OpenGL_Texture operations:
+
+void *CL_PixelBuffer_OpenGL_Texture::get_data()
+{
+	return data+offset_x*4+offset_y*pitch;
+}
+
+void CL_PixelBuffer_OpenGL_Texture::perform_lock()
+{
+	data = new char[pitch*texture_height];
+
+	CL_OpenGLState state(gc);
+	state.set_active();
+	state.setup_2d();
+	clEnable(CL_TEXTURE_2D);
+	clBindTexture(CL_TEXTURE_2D, handle);
+	clGetTexImage(CL_TEXTURE_2D, 0, CL_RGBA, CL_UNSIGNED_BYTE, data);
+}
+
+void CL_PixelBuffer_OpenGL_Texture::perform_unlock()
+{
+	CL_OpenGLState state(gc);
+	state.set_active();
+	state.setup_2d();
+	clEnable(CL_TEXTURE_2D);
+	clBindTexture(CL_TEXTURE_2D, handle);
+	clTexSubImage2D(
+		CL_TEXTURE_2D,          // target
+		0,                      // level
+		CL_RGBA,                // internalformat
+		texture_width,          // width
+		texture_height,         // height
+		0,                      // border
+		CL_RGBA,                // format
+		CL_UNSIGNED_BYTE,       // type
+		data);                  // texels
+
+	delete[] data;
+	data = 0;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_PixelBuffer_OpenGL_Texture Implementation:

Added: trunk/clanlib/GL/pixel_buffer_opengl_texture.h
===================================================================
--- trunk/clanlib/GL/pixel_buffer_opengl_texture.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/pixel_buffer_opengl_texture.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,80 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_pixelbuffer_opengl_texture
+#define header_pixelbuffer_opengl_texture
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Display/graphic_context.h&quot;
+#include &quot;Display/pixel_buffer_generic.h&quot;
+#ifdef WIN32
+#include &lt;windows.h&gt;
+#endif
+#include &quot;API/GL/opengl.h&quot;
+
+//: Pixel data access of a texture.
+class CL_PixelBuffer_OpenGL_Texture : public CL_PixelBuffer_Generic
+{
+//! Construction:
+public:
+	CL_PixelBuffer_OpenGL_Texture(
+		int offset_x,
+		int offset_y,
+		int width,
+		int height,
+		CLuint handle,
+		CL_GraphicContext *gc);
+
+	~CL_PixelBuffer_OpenGL_Texture();
+
+//! Operations:
+public:
+	virtual void *get_data();
+
+	virtual void perform_lock();
+
+	virtual void perform_unlock();
+
+//! Implementation:
+private:
+	int offset_x, offset_y;
+
+	CLuint handle;
+
+	CL_GraphicContext *gc;
+
+	CLint texture_width, texture_height;
+
+	char *data;
+};
+
+#endif

Added: trunk/clanlib/GL/program_attribute.cpp
===================================================================
--- trunk/clanlib/GL/program_attribute.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/program_attribute.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,97 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/GL/program_attribute.h&quot;
+#include &quot;API/GL/opengl_wrap.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ProgramAttribute_Generic:
+
+class CL_ProgramAttribute_Generic
+{
+//! Construction:
+public:
+	CL_ProgramAttribute_Generic()
+	{
+	}
+	
+	~CL_ProgramAttribute_Generic()
+	{
+	}
+
+//! Attributes:
+public:
+	std::string name;
+
+	int type;
+
+	int size;
+};
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ProgramAttribute Construction:
+
+CL_ProgramAttribute::CL_ProgramAttribute()
+{
+}
+
+CL_ProgramAttribute::CL_ProgramAttribute(const std::string &amp;name, int size, int type)
+: impl(new CL_ProgramAttribute_Generic)
+{
+	impl-&gt;name = name;
+	impl-&gt;size = size;
+	impl-&gt;type = type;
+}
+
+CL_ProgramAttribute::~CL_ProgramAttribute()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ProgramAttribute Attributes:
+
+const std::string &amp;CL_ProgramAttribute::get_name() const
+{
+	return impl-&gt;name;
+}
+
+int CL_ProgramAttribute::get_size() const
+{
+	return impl-&gt;size;
+}
+
+int CL_ProgramAttribute::get_type() const
+{
+	return impl-&gt;type;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ProgramAttribute Implementation:

Added: trunk/clanlib/GL/program_object.cpp
===================================================================
--- trunk/clanlib/GL/program_object.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/program_object.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,406 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    Harry Storbacka
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/GL/program_object.h&quot;
+#include &quot;API/GL/program_attribute.h&quot;
+#include &quot;API/GL/program_uniform.h&quot;
+#include &quot;API/GL/shader_object.h&quot;
+#include &quot;API/GL/opengl_wrap.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/Core/Resources/resource.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;API/Core/IOData/inputsource.h&quot;
+#include &quot;API/Core/IOData/inputsource_provider.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ProgramObject_Generic:
+
+class CL_ProgramObject_Generic
+{
+//! Construction:
+public:
+	CL_ProgramObject_Generic();
+	
+	~CL_ProgramObject_Generic();
+
+//! Attributes:
+public:
+	CLuint handle;
+	bool in_use;
+
+	std::vector&lt;CL_ShaderObject&gt; shaders;
+	
+//! Operations:
+public:
+};
+
+CL_ProgramObject_Generic::CL_ProgramObject_Generic() : handle(0), in_use(false)
+{
+	handle = clCreateProgram();
+}
+
+CL_ProgramObject_Generic::~CL_ProgramObject_Generic()
+{
+	clDeleteProgram(handle);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ProgramObject Construction:
+
+CL_ProgramObject::CL_ProgramObject() : impl(new CL_ProgramObject_Generic)
+{
+}
+
+CL_ProgramObject::CL_ProgramObject(const std::string &amp;resource_id, CL_ResourceManager *resources)
+: impl(new CL_ProgramObject_Generic)
+{
+	CL_Resource resource = resources-&gt;get_resource(resource_id);
+	CL_DomNode node = resource.get_element().get_first_child();
+	while (!node.is_null())
+	{
+		if (node.is_element())
+		{
+			CL_DomElement element = node.to_element();
+			if (element.get_tag_name() == &quot;shader&quot;)
+			{
+				CL_ShaderObject shader(element.get_attribute(&quot;name&quot;), resources);
+				attach(shader);
+			}
+			else if (element.get_tag_name() == &quot;bind-attribute&quot;)
+			{
+				bind_attribute_location(
+					CL_String::to_int(element.get_attribute(&quot;index&quot;)),
+					element.get_attribute(&quot;name&quot;));
+			}
+		}
+		node = node.get_next_sibling();
+	}
+	
+	if (!resource.get_element().get_attribute(&quot;shader&quot;).empty())
+	{
+		CL_ShaderObject shader(resource.get_element().get_attribute(&quot;shader&quot;), resources);
+		attach(shader);
+	}
+	
+	if (resource.get_element().get_attribute(&quot;link&quot;, &quot;true&quot;) == &quot;true&quot;)
+	{
+		link();
+		if (get_link_status() == false)
+			throw CL_Error(resource_id + &quot; failed to link: &quot; + get_info_log());
+	}
+}
+
+CL_ProgramObject::~CL_ProgramObject()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ProgramObject Attributes:
+
+unsigned int CL_ProgramObject::get_handle() const
+{
+	return (unsigned int) impl-&gt;handle;
+}
+
+bool CL_ProgramObject::get_link_status() const
+{
+	CLint status = 0;
+	clGetProgramiv(impl-&gt;handle, CL_LINK_STATUS, &amp;status);
+	return (status != CL_FALSE);
+}
+	
+bool CL_ProgramObject::get_validate_status() const
+{
+	CLint status = 0;
+	clGetProgramiv(impl-&gt;handle, CL_VALIDATE_STATUS, &amp;status);
+	return (status != CL_FALSE);
+}
+	
+std::vector&lt;CL_ShaderObject&gt; CL_ProgramObject::get_shaders() const
+{
+	return impl-&gt;shaders;
+}
+	
+std::string CL_ProgramObject::get_info_log() const
+{
+	std::string result;
+	CLsizei buffer_size = 16*1024;
+	while (buffer_size &lt; 2*1024*1024)
+	{
+		CLchar *info_log = new CLchar[buffer_size];
+		CLsizei length = 0;
+		clGetProgramInfoLog(impl-&gt;handle, buffer_size, &amp;length, info_log);
+		if (length &lt; buffer_size-1)
+			result = std::string(info_log, length);
+		delete[] info_log;
+		if (length &lt; buffer_size-1)
+			break;
+		buffer_size *= 2;
+	}
+	return result;
+}
+	
+int CL_ProgramObject::get_uniform_count() const
+{
+	CLint count = 0;
+	clGetProgramiv(impl-&gt;handle, CL_ACTIVE_UNIFORMS, &amp;count);
+	return count;
+}
+	
+std::vector&lt;CL_ProgramUniform&gt; CL_ProgramObject::get_uniforms() const
+{
+	std::vector&lt;CL_ProgramUniform&gt; uniforms;
+	int count = get_uniform_count();
+	CLint name_size = 0;
+	clGetProgramiv(impl-&gt;handle, CL_ACTIVE_UNIFORM_MAX_LENGTH, &amp;name_size);
+	CLchar *name = new CLchar[name_size+1];
+	name[name_size] = 0;
+	for (int i=0; i&lt;count; i++)
+	{
+		CLsizei length = 0;
+		CLint size = 0;
+		CLenum type = 0;
+		name[0] = 0;
+		clGetActiveUniform(impl-&gt;handle, i, name_size, &amp;length, &amp;size, &amp;type, name);
+
+		std::string uniform_name(name, length);
+		CL_ProgramUniform uniform(uniform_name, size, type);
+		uniforms.push_back(uniform);
+	}
+	return uniforms;
+}
+	
+int CL_ProgramObject::get_uniform_location(const std::string &amp;name) const
+{
+	int loc = clGetUniformLocation(impl-&gt;handle, name.c_str());
+
+	if (loc == -1)
+	{
+		throw CL_Error(CL_String::format(&quot;Uniform variable '%1' not present in program object (maybe not active?).&quot;, name));
+	}
+
+	return loc;
+}
+
+bool CL_ProgramObject::has_uniform(const std::string &amp;name, int type) const
+{
+	std::vector&lt;CL_ProgramUniform&gt; uniforms = get_uniforms();
+	std::vector&lt;CL_ProgramUniform&gt;::iterator it;
+
+	for(it = uniforms.begin(); it != uniforms.end(); ++it)
+	{
+		if( (*it).name == name &amp;&amp; (*it).type == type )
+		{
+			return true;
+		}
+	}
+
+	return false;
+}
+
+int CL_ProgramObject::get_attribute_count() const
+{
+	CLint count = 0;
+	clGetProgramiv(impl-&gt;handle, CL_ACTIVE_ATTRIBUTES, &amp;count);
+	return count;
+}
+	
+std::vector&lt;CL_ProgramAttribute&gt; CL_ProgramObject::get_attributes() const
+{
+	std::vector&lt;CL_ProgramAttribute&gt; attributes;
+	int count = get_attribute_count();
+	CLint name_size = 0;
+	clGetProgramiv(impl-&gt;handle, CL_ACTIVE_ATTRIBUTE_MAX_LENGTH, &amp;name_size);
+	CLchar *name = new CLchar[name_size+1];
+	name[name_size] = 0;
+	for (int i=0; i&lt;count; i++)
+	{
+		CLsizei length = 0;
+		CLint size = 0;
+		CLenum type = 0;
+		name[0] = 0;
+		clGetActiveAttrib(impl-&gt;handle, i, name_size, &amp;length, &amp;size, &amp;type, name);
+
+		std::string attrib_name(name, length);
+		CL_ProgramAttribute attribute(attrib_name, size, type);
+		attributes.push_back(attribute);
+	}
+	return attributes;
+}
+	
+int CL_ProgramObject::get_attribute_location(const std::string &amp;name) const
+{
+	return clGetAttribLocation(impl-&gt;handle, name.c_str());
+}
+	
+/////////////////////////////////////////////////////////////////////////////	
+// CL_ProgramObject Operations:
+
+void CL_ProgramObject::attach(const CL_ShaderObject &amp;obj)
+{
+	impl-&gt;shaders.push_back(obj);
+	clAttachShader(impl-&gt;handle, (CLuint) obj.get_handle());
+}
+
+void CL_ProgramObject::detach(const CL_ShaderObject &amp;obj)
+{
+	for (std::vector&lt;CL_ShaderObject&gt;::size_type i = 0; i &lt; impl-&gt;shaders.size(); i++)
+	{
+		if (impl-&gt;shaders[i] == obj)
+		{
+			impl-&gt;shaders.erase(impl-&gt;shaders.begin()+i);
+			break;
+		}
+	}
+	clDetachShader(impl-&gt;handle, (CLuint) obj.get_handle());
+}
+
+void CL_ProgramObject::bind_attribute_location(int index, const std::string &amp;name)
+{
+	clBindAttribLocation(impl-&gt;handle, index, name.c_str());
+}
+
+void CL_ProgramObject::link()
+{
+	clLinkProgram(impl-&gt;handle);
+}
+	
+void CL_ProgramObject::validate()
+{
+	clValidateProgram(impl-&gt;handle);
+}
+
+void CL_ProgramObject::use()
+{
+	if( impl-&gt;in_use == false )
+	{
+		impl-&gt;in_use = true;
+		clUseProgram(impl-&gt;handle);
+	}
+}
+
+void CL_ProgramObject::disable()
+{
+	if( impl-&gt;in_use )
+	{
+		impl-&gt;in_use = false;
+		clUseProgram(0);
+	}
+	else
+	{
+		throw CL_Error(&quot;CL_ProgramObject::disable(): trying to disable shader program not currently in use.&quot;);
+	}
+}
+
+
+void CL_ProgramObject::set_uniform(const std::string &amp;name, int p1)
+{
+	int loc = get_uniform_location(name);
+	clUniform1i(loc, p1);	
+}
+
+void CL_ProgramObject::set_uniform(const std::string &amp;name, int p1, int p2)
+{
+	int loc = get_uniform_location(name);
+	clUniform2i(loc, p1, p2);	
+}
+
+void CL_ProgramObject::set_uniform(const std::string &amp;name, int p1, int p2, int p3)
+{
+	int loc = get_uniform_location(name);
+	clUniform3i(loc, p1, p2, p3);	
+}
+
+void CL_ProgramObject::set_uniform(const std::string &amp;name, int p1, int p2, int p3, int p4)
+{
+	int loc = get_uniform_location(name);
+	clUniform4i(loc, p1, p2, p3, p4);	
+}
+
+void CL_ProgramObject::set_uniform(const std::string &amp;name, int size, int count, int *data)
+{
+	int loc = get_uniform_location(name);
+	if( size == 1 ) clUniform1iv(loc, count, (const CLint*)data);
+	else if( size == 2 ) clUniform2iv(loc, count, (const CLint*)data);
+	else if( size == 3 ) clUniform3iv(loc, count, (const CLint*)data);
+	else if( size == 4 ) clUniform4iv(loc, count, (const CLint*)data);
+	else throw CL_Error(CL_String::format(&quot;CL_ProgramObject::set_uniform: unsupported size given to uniform '%1'.&quot;, name.c_str()));
+}
+
+
+void CL_ProgramObject::set_uniform(const std::string &amp;name, float p1)
+{
+	int loc = get_uniform_location(name);
+	clUniform1f(loc, p1);	
+}
+
+void CL_ProgramObject::set_uniform(const std::string &amp;name, float p1, float p2)
+{
+	int loc = get_uniform_location(name);
+	clUniform2f(loc, p1, p2);	
+}
+
+void CL_ProgramObject::set_uniform(const std::string &amp;name, float p1, float p2, float p3)
+{
+	int loc = get_uniform_location(name);
+	clUniform3f(loc, p1, p2, p3);	
+}
+
+void CL_ProgramObject::set_uniform(const std::string &amp;name, float p1, float p2, float p3, float p4)
+{
+	int loc = get_uniform_location(name);
+	clUniform4f(loc, p1, p2, p3, p4);	
+}
+
+void CL_ProgramObject::set_uniform(const std::string &amp;name, int size, int count, float *data)
+{
+	int loc = get_uniform_location(name);
+	if( size == 1 ) clUniform1fv(loc, count, data);	
+	else if( size == 2 ) clUniform2fv(loc, count, data);	
+	else if( size == 3 ) clUniform3fv(loc, count, data);	
+	else if( size == 4 ) clUniform4fv(loc, count, data);	
+	else throw CL_Error(CL_String::format(&quot;CL_ProgramObject::set_uniform: unsupported size given to uniform '%1'.&quot;, name.c_str()));
+}
+
+
+void CL_ProgramObject::set_uniform_matrix(const std::string &amp;name, int size, int count, bool transpose, float *data)
+{
+	int loc = get_uniform_location(name);
+	if( size == 2 ) clUniformMatrix2fv(loc, count, transpose, data);	
+	else if( size == 3 ) clUniformMatrix3fv(loc, count, transpose, data);	
+	else if( size == 4 ) clUniformMatrix4fv(loc, count, transpose, data);
+	else throw CL_Error(CL_String::format(&quot;CL_ProgramObject::set_uniform_matrix: unsupported size given to uniform '%1'.&quot;, name.c_str()));
+
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ProgramObject Implementation:

Added: trunk/clanlib/GL/program_uniform.cpp
===================================================================
--- trunk/clanlib/GL/program_uniform.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/program_uniform.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,38 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    Harry Storbacka
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/GL/program_uniform.h&quot;
+
+CL_ProgramUniform::CL_ProgramUniform(const std::string &amp;name, int size, int type)
+: name(name), size(size), type(type)
+{
+	return;
+}
+

Added: trunk/clanlib/GL/setupgl.cpp
===================================================================
--- trunk/clanlib/GL/setupgl.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/setupgl.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,72 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;API/GL/setupgl.h&quot;
+#include &quot;opengl_target.h&quot;
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;opengl_state_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_SetupGL construction:
+
+static CL_OpenGLTarget *target = 0;
+
+static int ref_count = 0;
+
+CL_SetupGL::CL_SetupGL(bool register_resources_only)
+{
+	CL_SetupGL::init(register_resources_only);
+}
+
+CL_SetupGL::~CL_SetupGL()
+{
+	CL_SetupGL::deinit();
+}
+
+void CL_SetupGL::init(bool register_resources_only)
+{
+	ref_count++;
+	if (ref_count != 1) return;
+
+	if (register_resources_only) return;
+
+	target = new CL_OpenGLTarget;
+}
+	
+void CL_SetupGL::deinit()
+{
+	ref_count--;
+	if (ref_count != 0) return;
+
+	if(target)
+		delete target;
+	target = 0;
+
+	CL_OpenGLState_Generic::clear_context ();
+}

Added: trunk/clanlib/GL/shader_object.cpp
===================================================================
--- trunk/clanlib/GL/shader_object.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/shader_object.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,228 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/GL/shader_object.h&quot;
+#include &quot;API/GL/opengl_wrap.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/Resources/resource.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;API/Core/IOData/inputsource.h&quot;
+#include &quot;API/Core/IOData/inputsource_provider.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ShaderObject_Generic:
+
+class CL_ShaderObject_Generic
+{
+//! Construction:
+public:
+	CL_ShaderObject_Generic(CL_ShaderType type);
+	
+	~CL_ShaderObject_Generic();
+
+//! Attributes:
+public:
+	CLuint handle;
+	
+	CL_ShaderType type;
+
+//! Operations:
+private:
+	static CLenum shadertype_to_opengl(CL_ShaderType type);
+};
+
+CL_ShaderObject_Generic::CL_ShaderObject_Generic(CL_ShaderType type) : handle(0), type(type)
+{
+	handle = clCreateShader(shadertype_to_opengl(type));
+}
+
+CL_ShaderObject_Generic::~CL_ShaderObject_Generic()
+{
+	clDeleteShader(handle);
+}
+
+CLenum CL_ShaderObject_Generic::shadertype_to_opengl(CL_ShaderType type)
+{
+	switch (type)
+	{
+	case cl_shadertype_vertex:
+		return CL_VERTEX_SHADER;
+	case cl_shadertype_fragment:
+		return CL_FRAGMENT_SHADER;
+	default:
+		throw CL_Error(&quot;Unknown shader type!&quot;);
+	}
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ShaderObject Construction:
+
+CL_ShaderObject::CL_ShaderObject(CL_ShaderType type) : impl(new CL_ShaderObject_Generic(type))
+{
+}
+
+CL_ShaderObject::CL_ShaderObject(CL_ShaderType type, const std::string &amp;source) : impl(new CL_ShaderObject_Generic(type))
+{
+	const CLchar *sources[1];
+	CLint source_lengths[1];
+	source_lengths[0] = source.length();
+	sources[0] = source.c_str();
+	clShaderSource(impl-&gt;handle, 1, sources, source_lengths);
+	clCompileShader(impl-&gt;handle);
+}
+
+CL_ShaderObject::CL_ShaderObject(CL_ShaderType type, const std::vector&lt;std::string&gt; &amp;sources) : impl(new CL_ShaderObject_Generic(type))
+{
+	CLchar ** array_sources = 0;
+	CLint *array_source_lengths = 0;
+	try
+	{
+		array_sources = new CLchar*[sources.size()];
+		array_source_lengths = new CLint[sources.size()];
+	
+		for (std::vector&lt;std::string&gt;::size_type i = 0; i &lt; sources.size(); i++)
+		{
+			array_source_lengths[i] = sources[i].length();
+			array_sources[i] = (CLchar*) sources[i].c_str();
+		}
+		clShaderSource(impl-&gt;handle, sources.size(), (const CLchar**) array_sources, array_source_lengths);
+	}
+	catch (...)
+	{
+		delete[] array_source_lengths;
+		delete[] array_sources;
+		throw;
+	}
+	clCompileShader(impl-&gt;handle);
+}
+
+CL_ShaderObject::CL_ShaderObject(const std::string &amp;resource_id, CL_ResourceManager *resources)
+{
+	CL_Resource resource = resources-&gt;get_resource(resource_id);
+	std::string filename = resource.get_element().get_attribute(&quot;file&quot;);
+	std::string type = resource.get_element().get_tag_name();
+	
+	CL_ShaderType shader_type;
+	if (type == &quot;fragment-shader&quot;)
+		shader_type = cl_shadertype_fragment;
+	else if (type == &quot;vertex-shader&quot;)
+		shader_type = cl_shadertype_vertex;
+	else
+		throw CL_Error(&quot;Unknown shader type: &quot; + type);
+
+	CL_InputSource *file = resources-&gt;get_resource_provider()-&gt;open_source(filename);
+	CLint size = (CLint) file-&gt;size();
+	std::string source(size, 0);
+	file-&gt;read(&amp;source[0], size);
+	delete file;
+	file = 0;
+
+	const CLchar *str = (const CLchar *) source.c_str();
+	impl = CL_SharedPtr&lt;CL_ShaderObject_Generic&gt;(new CL_ShaderObject_Generic(shader_type));
+	clShaderSource(impl-&gt;handle, 1, &amp;str, &amp;size);
+	clCompileShader(impl-&gt;handle);
+
+	if (get_compile_status() == false)
+		throw CL_Error(resource_id + &quot; compile failed: &quot; + get_info_log());
+}
+
+CL_ShaderObject::~CL_ShaderObject()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ShaderObject Attributes:
+
+unsigned int CL_ShaderObject::get_handle() const
+{
+	return (unsigned int) impl-&gt;handle;
+}
+
+bool CL_ShaderObject::get_compile_status() const
+{
+	CLint status = 0;
+	clGetShaderiv(impl-&gt;handle, CL_COMPILE_STATUS, &amp;status);
+	return (status != CL_FALSE);
+}
+
+CL_ShaderType CL_ShaderObject::get_shader_type() const
+{
+	return impl-&gt;type;
+}
+
+std::string CL_ShaderObject::get_info_log() const
+{
+	std::string result;
+	CLsizei buffer_size = 16*1024;
+	while (buffer_size &lt; 2*1024*1024)
+	{
+		CLchar *info_log = new CLchar[buffer_size];
+		CLsizei length = 0;
+		clGetShaderInfoLog(impl-&gt;handle, buffer_size, &amp;length, info_log);
+		if (length &lt; buffer_size-1)
+			result = std::string(info_log, length);
+		delete[] info_log;
+		if (length &lt; buffer_size-1)
+			break;
+		buffer_size *= 2;
+	}
+	return result;
+}
+
+std::string CL_ShaderObject::get_shader_source() const
+{
+	std::string result;
+	CLsizei buffer_size = 16*1024;
+	while (buffer_size &lt; 2*1024*1024)
+	{
+		CLchar *shader_source = new CLchar[buffer_size];
+		CLsizei length = 0;
+		clGetShaderSource(impl-&gt;handle, buffer_size, &amp;length, shader_source);
+		if (length &lt; buffer_size-1)
+			result = std::string(shader_source, length);
+		delete[] shader_source;
+		if (length &lt; buffer_size-1)
+			break;
+		buffer_size *= 2;
+	}
+	return result;
+}
+
+/////////////////////////////////////////////////////////////////////////////	
+// CL_ShaderObject Operations:
+
+bool CL_ShaderObject::operator ==(const CL_ShaderObject &amp;other) const
+{
+	return impl == other.impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ShaderObject Implementation:
+

Added: trunk/clanlib/GL/surface_target_opengl.cpp
===================================================================
--- trunk/clanlib/GL/surface_target_opengl.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/surface_target_opengl.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,382 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;surface_target_opengl.h&quot;
+#include &quot;gl_state_checker.h&quot;
+#include &quot;graphic_context_opengl.h&quot;
+#include &quot;API/Display/pixel_buffer.h&quot;
+#include &quot;API/Display/graphic_context.h&quot;
+#include &quot;API/Display/pixel_format.h&quot;
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Display/display_window.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/IOData/cl_endian.h&quot;
+#include &quot;API/GL/opengl.h&quot;
+#include &quot;API/GL/opengl_state.h&quot;
+#include &quot;API/GL/opengl_wrap.h&quot;
+#include &quot;canvas_opengl.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Surface_Target_OpenGL construction:
+
+CL_Surface_Target_OpenGL::CL_Surface_Target_OpenGL(
+	CL_PixelBuffer provider,
+	int flag)
+{
+	selected_canvas = 0;
+
+	if(flag &amp; CL_Surface::flag_keep_pixelbuffer)
+	{
+		original_pixelbuffer = provider;
+	}
+
+	CL_OpenGLState state(CL_Display::get_current_window()-&gt;get_gc());
+	state.set_active();
+	state.setup_2d();
+	clEnable(CL_TEXTURE_2D);
+
+	surface_size.width  = provider.get_width();
+	surface_size.height = provider.get_height();
+	
+	texture_size.width = 1;
+	texture_size.height = 1;
+	while (texture_size.width &lt; surface_size.width) texture_size.width *= 2;
+	while (texture_size.height &lt; surface_size.height) texture_size.height *= 2;
+
+	// check out if the original texture needs or doesn't need an alpha channel
+	bool needs_alpha = provider.get_format().get_alpha_mask() || provider.get_format().has_colorkey();
+
+	CLint internal_format = needs_alpha ? CL_RGBA : CL_RGB;
+	CLenum format = needs_alpha ? CL_RGBA : CL_RGB;
+
+	// Upload to OpenGL:
+	clGenTextures(1, &amp;handle);
+	clBindTexture(CL_TEXTURE_2D, handle);
+
+	// create
+	clTexImage2D(
+		CL_TEXTURE_2D,            // target
+		0,                        // level
+		internal_format,          // internalformat
+		texture_size.width,       // width
+		texture_size.height,      // height
+		0,                        // border
+		format,                   // format (it really doesn't matter since nothing is uploaded)
+		CL_UNSIGNED_BYTE,         // type (it really doesn't matter since nothing is uploaded)
+		0);                       // texels (0 to avoid uploading)
+
+	set_pixeldata(CL_Point(0, 0), CL_Rect(0, 0, provider.get_width(), provider.get_height()), provider);
+
+	clTexParameteri(CL_TEXTURE_2D, CL_TEXTURE_MIN_FILTER, CL_LINEAR);
+	clTexParameteri(CL_TEXTURE_2D, CL_TEXTURE_MAG_FILTER, CL_LINEAR);
+	clTexParameteri(CL_TEXTURE_2D, CL_TEXTURE_WRAP_S, CL_CLAMP_TO_EDGE);
+	clTexParameteri(CL_TEXTURE_2D, CL_TEXTURE_WRAP_T, CL_CLAMP_TO_EDGE);
+}
+
+CL_Surface_Target_OpenGL::CL_Surface_Target_OpenGL(
+	const CL_PixelFormat &amp;pf,
+	const CL_Size &amp;size)
+{
+	selected_canvas = 0;
+
+	CL_OpenGLState state(CL_Display::get_current_window()-&gt;get_gc());
+	state.set_active();
+	state.setup_2d();
+	clEnable(CL_TEXTURE_2D);
+
+	surface_size.width = size.width;
+	surface_size.height = size.height;
+	
+	texture_size.width = 1;
+	texture_size.height = 1;
+	while (texture_size.width &lt; surface_size.width) texture_size.width *= 2;
+	while (texture_size.height &lt; surface_size.height) texture_size.height *= 2;
+
+	// check out if the original texture needs or doesn't need an alpha channel
+	bool needs_alpha = pf.get_alpha_mask() || pf.has_colorkey();
+
+	CLint internal_format = needs_alpha ? CL_RGBA : CL_RGB;
+	CLenum format = needs_alpha ? CL_RGBA : CL_RGB;
+
+	// Upload to OpenGL:
+	clGenTextures(1, &amp;handle);
+	clBindTexture(CL_TEXTURE_2D, handle);
+
+	// create
+	clTexImage2D(
+		CL_TEXTURE_2D,            // target
+		0,                        // level
+		internal_format,          // internalformat
+		texture_size.width,       // width
+		texture_size.height,      // height
+		0,                        // border
+		format,                   // format (it really doesn't matter since nothing is uploaded)
+		CL_UNSIGNED_BYTE,         // type (it really doesn't matter since nothing is uploaded)
+		0);                       // texels (0 to avoid uploading)
+
+	clTexParameteri(CL_TEXTURE_2D, CL_TEXTURE_MIN_FILTER, CL_LINEAR);
+	clTexParameteri(CL_TEXTURE_2D, CL_TEXTURE_MAG_FILTER, CL_LINEAR);
+	clTexParameteri(CL_TEXTURE_2D, CL_TEXTURE_WRAP_S, CL_CLAMP_TO_EDGE);
+	clTexParameteri(CL_TEXTURE_2D, CL_TEXTURE_WRAP_T, CL_CLAMP_TO_EDGE);
+}
+
+CL_Surface_Target_OpenGL::~CL_Surface_Target_OpenGL()
+{
+	// Make sure context exists
+	if (CL_OpenGL::functions == 0) 
+		return;
+	CL_OpenGLState state(CL_Display::get_current_window()-&gt;get_gc());
+	state.set_active();
+
+	clDeleteTextures(1, &amp;handle);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Surface_Target_OpenGL attributes:
+
+int CL_Surface_Target_OpenGL::get_width() const
+{
+	return surface_size.width;
+}
+	
+int CL_Surface_Target_OpenGL::get_height() const
+{
+	return surface_size.height;
+}
+
+CL_PixelBuffer CL_Surface_Target_OpenGL::get_pixeldata()
+{
+	if (original_pixelbuffer &amp;&amp; !selected_canvas)
+		return original_pixelbuffer;
+
+	if (selected_canvas) selected_canvas-&gt;sync_texture();
+
+	CL_OpenGLState state(CL_Display::get_current_window()-&gt;get_gc());
+	state.set_active();
+	state.setup_2d();
+	clEnable(CL_TEXTURE_2D);
+	clBindTexture(CL_TEXTURE_2D, handle);
+
+	CL_PixelFormat abgr_format;
+	abgr_format.set_depth(32);
+	abgr_format.enable_colorkey(false);
+	abgr_format.set_alpha_mask(0xFF000000);
+	abgr_format.set_blue_mask (0x00FF0000);
+	abgr_format.set_green_mask(0x0000FF00);
+	abgr_format.set_red_mask  (0x000000FF);
+
+	CL_PixelBuffer buffer(
+		texture_size.width, texture_size.height,
+		texture_size.width * 4,
+		abgr_format);
+
+	buffer.lock();
+	clGetTexImage(CL_TEXTURE_2D, 0, CL_RGBA, CL_UNSIGNED_BYTE, buffer.get_data());
+	buffer.unlock();
+
+	return buffer;
+}
+	
+CL_GraphicContext *CL_Surface_Target_OpenGL::get_gc()
+{
+	return 0;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Surface_Target_OpenGL operations:
+
+void CL_Surface_Target_OpenGL::set_pixeldata(
+	const CL_Point &amp;pos,
+	const CL_Rect &amp;src_rect,
+	CL_PixelBuffer &amp;pixeldata)
+{
+	// check the coordinates
+	{
+		CL_Point p1(pos.x + src_rect.left, pos.y + src_rect.top);
+		CL_Point p2(p1.x + src_rect.get_width() - 1, p1.y + src_rect.get_height() - 1);
+		CL_Rect r(CL_Point(0, 0), texture_size);
+		if (!r.is_inside(p1) || !r.is_inside(p2))
+			throw CL_Error(&quot;The destination rectangle cannot be outside the texture rectangle&quot;);
+	}
+
+	if (selected_canvas) selected_canvas-&gt;sync_texture();
+
+	CL_OpenGLState state(CL_Display::get_current_window()-&gt;get_gc());
+	state.set_active();
+	state.setup_2d();
+	clEnable(CL_TEXTURE_2D);
+
+	// check out if the original texture needs or doesn't need an alpha channel
+	bool needs_alpha = pixeldata.get_format().get_alpha_mask() || pixeldata.get_format().has_colorkey();
+
+	CLenum format;
+	CLenum type;
+	bool conv_needed = !CL_OpenGL::to_opengl_pixelformat(pixeldata.get_format(), format, type);
+
+	// also check for the pitch (OpenGL can only skip pixels, not bytes)
+	if (!conv_needed)
+	{
+		const int bytesPerPixel = (pixeldata.get_format().get_depth() + 7) / 8;
+		if (pixeldata.get_pitch() % bytesPerPixel != 0)
+			conv_needed = true;
+	}
+
+	// no conversion needed
+	if (!conv_needed)
+	{
+		pixeldata.lock();
+
+		// Upload to OpenGL:
+		clBindTexture(CL_TEXTURE_2D, handle);
+
+		// change alignment
+		clPixelStorei(CL_UNPACK_ALIGNMENT, 1);
+		const int bytesPerPixel = (pixeldata.get_format().get_depth() + 7) / 8;
+		clPixelStorei(CL_UNPACK_ROW_LENGTH, pixeldata.get_pitch() / bytesPerPixel);
+
+		char *data = (char *)pixeldata.get_data() + (src_rect.top * pixeldata.get_pitch()) + (src_rect.left * bytesPerPixel);
+
+		// upload
+		clTexSubImage2D(
+			CL_TEXTURE_2D,            // target
+			0,                        // level
+			0, 0,                     // xoffset, yoffset
+			src_rect.get_width(),     // width
+			src_rect.get_height(),    // height
+			format,					  // format
+			type,					  // type
+			data);                    // texels
+
+		pixeldata.unlock();
+	}
+	// conversion needed
+	else
+	{
+		bool big_endian = CL_Endian::is_system_big();
+
+		CL_PixelBuffer buffer;
+		if (!big_endian)
+			buffer = CL_PixelBuffer(
+				src_rect.get_width(), src_rect.get_height(),
+				src_rect.get_width() * (needs_alpha ? 4 : 3),
+				needs_alpha ? CL_PixelFormat::abgr8888 : CL_PixelFormat::bgr888); // OpenGL RGB/RGBA is always big endian
+		else
+			buffer = CL_PixelBuffer(
+				src_rect.get_width(), src_rect.get_height(),
+				src_rect.get_width() * (needs_alpha ? 4 : 3),
+				needs_alpha ? CL_PixelFormat::rgba8888 : CL_PixelFormat::rgb888);
+	
+		pixeldata.convert(buffer);
+
+		format = needs_alpha ? CL_RGBA : CL_RGB;
+
+		buffer.lock();	
+
+		// Upload to OpenGL:
+		clBindTexture(CL_TEXTURE_2D, handle);
+
+		// change alignment
+		clPixelStorei(CL_UNPACK_ALIGNMENT, 1);
+		const int bytesPerPixel = (buffer.get_format().get_depth() + 7) / 8;
+		clPixelStorei(CL_UNPACK_ROW_LENGTH, buffer.get_pitch() / bytesPerPixel);
+
+		// upload
+		clTexSubImage2D(
+			CL_TEXTURE_2D,            // target
+			0,                        // level
+			0, 0,                     // xoffset, yoffset
+			src_rect.get_width(),     // width
+			src_rect.get_height(),    // height
+			format,                   // format
+			CL_UNSIGNED_BYTE,         // type
+			buffer.get_data());      // texels
+
+		buffer.unlock();
+	}
+
+#ifdef __APPLE__
+        // seems there's either a bug or some kind of strange quirk on OSX
+        // where the textures can become corrupted at times - this flush call
+        // fixes it.  it seems very wrong.  -- SMH sep 24 2005
+        clFlush();
+#endif
+
+#ifdef __APPLE__
+        // seems there's either a bug or some kind of strange quirk on OSX
+        // where the textures can become corrupted at times - this flush call
+        // fixes it.  it seems very wrong.  -- SMH sep 27 2005
+        clFlush();
+#endif
+
+	// Is this really needed according to OpenGL standard? (already set in constructor)
+	// Think its a Linux OpenGL driver bug.. -- MBN 25. jan 2004
+	clTexParameteri(CL_TEXTURE_2D, CL_TEXTURE_MIN_FILTER, CL_LINEAR);
+	clTexParameteri(CL_TEXTURE_2D, CL_TEXTURE_MAG_FILTER, CL_LINEAR);
+	clTexParameteri(CL_TEXTURE_2D, CL_TEXTURE_WRAP_S, CL_CLAMP_TO_EDGE);
+	clTexParameteri(CL_TEXTURE_2D, CL_TEXTURE_WRAP_T, CL_CLAMP_TO_EDGE);
+
+	if (selected_canvas) selected_canvas-&gt;sync_pbuffer();
+}
+
+void CL_Surface_Target_OpenGL::draw(
+	CL_Surface_Generic *attributes,
+	const CL_Surface_DrawParams1&amp; params1,
+	CL_GraphicContext *gc)
+{
+	if (selected_canvas) selected_canvas-&gt;sync_texture();
+
+	state.blendfunc[0] = params1.blend_src;
+	state.blendfunc[1] = params1.blend_dest;
+	state.blendfunc[2] = params1.blendfunc_src_alpha;
+	state.blendfunc[3] = params1.blendfunc_dest_alpha;
+	state.color[0] = float(params1.red[0]);
+	state.color[1] = float(params1.green[0]);
+	state.color[2] = float(params1.blue[0]);
+	state.color[3] = float(params1.alpha[0]);
+	state.texture_handle = handle;
+	state.fillmode = fillmode_solid;
+	state.sub_pixel_accuracy = params1.sub_pixel_accuracy;
+
+	CL_GLStateChecker::from_gc(gc)-&gt;add_quad(
+		state,
+		params1.destX,
+		params1.destY,
+		params1.srcX,
+		params1.srcY);
+}
+
+int CL_Surface_Target_OpenGL::get_handle()
+{
+	return (int) handle;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Surface_Target_OpenGL implementation:

Added: trunk/clanlib/GL/surface_target_opengl.h
===================================================================
--- trunk/clanlib/GL/surface_target_opengl.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/surface_target_opengl.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,106 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_surface_target_opengl
+#define header_surface_target_opengl
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;Display/surface_generic.h&quot;
+#include &quot;Display/surface_target.h&quot;
+#include &quot;API/Display/surface.h&quot;
+#include &quot;API/Core/Math/size.h&quot;
+#include &quot;GL/gl_state_checker.h&quot;
+
+class CL_Canvas_OpenGL;
+
+class CL_Surface_Target_OpenGL : public CL_Surface_Target
+{
+//! Construction:
+public:
+	CL_Surface_Target_OpenGL(
+		CL_PixelBuffer provider,
+		int flag);
+
+	CL_Surface_Target_OpenGL(
+		const CL_PixelFormat &amp;pf,
+		const CL_Size &amp;size);
+
+	virtual ~CL_Surface_Target_OpenGL();
+
+//! Attributes:
+public:
+	//: Returns the width.
+	virtual int get_width() const;
+	
+	//: Returns the height.
+	virtual int get_height() const;
+
+	//: Returns a pixelbuffer object for accessing surface data.
+	virtual CL_PixelBuffer get_pixeldata();
+	
+	//: Returns a graphic context object for rendering to this surface.
+	virtual CL_GraphicContext *get_gc();
+
+	//: OpenGL texture handle.
+	CLuint handle;
+
+	CL_Size surface_size;
+
+	CL_Size texture_size;
+
+	CL_Canvas_OpenGL *selected_canvas;
+
+	CL_PixelBuffer original_pixelbuffer;
+
+//! Operations:
+public:
+	//: Uploads pixel data to surface.
+	//!param pos: Position on surface where pixel data should be put.
+	//!param pixeldata: CL_PixelBuffer containing the image to be uploaded.
+	//!param src_rect: Part of pixelbuffer that should be uploaded.
+	virtual void set_pixeldata(const CL_Point &amp;pos, const CL_Rect &amp;src_rect, CL_PixelBuffer &amp;pixeldata);
+
+	//: Draw surface on screen.
+	virtual void draw(
+		CL_Surface_Generic *attributes,
+		const CL_Surface_DrawParams1&amp; params1,
+		CL_GraphicContext *gc);
+		
+	//  Get the surface handle
+	int get_handle();
+
+//! Implementation:
+private:
+	CL_GLState state;
+};
+
+#endif

Added: trunk/clanlib/GL/texture.cpp
===================================================================
--- trunk/clanlib/GL/texture.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/texture.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,1235 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/GL/texture.h&quot;
+#include &quot;API/GL/opengl_wrap.h&quot;
+#include &quot;API/GL/opengl_state.h&quot;
+#include &quot;API/Display/pixel_buffer.h&quot;
+#include &quot;API/Display/color.h&quot;
+#include &quot;API/Core/Math/rect.h&quot;
+#include &quot;API/Core/Math/point.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Texture_Generic:
+
+class CL_Texture_Generic
+{
+//! Construction:
+public:
+	CL_Texture_Generic(int target) : handle(0), target(target)
+	{
+		clGenTextures(1, &amp;handle);
+	}
+	
+	~CL_Texture_Generic()
+	{
+		clDeleteTextures(1, &amp;handle);
+	}
+
+//! Attributes:
+public:
+	CLuint handle;
+
+	int target;
+
+//! Operations:
+public:
+	void make_current() const
+	{
+		clBindTexture(target, handle);
+	}
+};
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Texture Construction:
+
+CL_Texture::CL_Texture()
+{
+}
+
+CL_Texture::CL_Texture(int target_gl) 
+: impl(new CL_Texture_Generic(target_gl))
+{
+}
+
+CL_Texture::CL_Texture(
+	int target_gl,
+	CL_PixelBuffer &amp;image,
+	bool autogenerate_mipmaps,
+	int border,
+	int format)
+: impl(new CL_Texture_Generic(target_gl))
+{
+	if (autogenerate_mipmaps)
+		set_generate_mipmap(true);
+
+	set_image(image, 0, border, format);
+}
+
+CL_Texture::CL_Texture(
+	int target_gl,
+	int width,
+	int height,
+	int depth,
+	int border,
+	int format,
+	int level)
+: impl(new CL_Texture_Generic(target_gl))
+{
+	set_size(
+		format,
+		width,
+		height,
+		depth,
+		border,
+		level);
+}
+
+CL_Texture::~CL_Texture()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Texture Attributes:
+
+int CL_Texture::get_handle()
+{
+	return (int) impl-&gt;handle;
+}
+
+int CL_Texture::get_target_gl()
+{
+	return impl-&gt;target;
+}
+
+int CL_Texture::get_format_gl()
+{
+	impl-&gt;make_current();
+	return 0;
+}
+
+int CL_Texture::get_width(int level)
+{
+	impl-&gt;make_current();
+	return 0 / (level+1);
+}
+
+int CL_Texture::get_height(int level)
+{
+	impl-&gt;make_current();
+	return 0 / (level+1);
+}
+
+int CL_Texture::get_depth()
+{
+	impl-&gt;make_current();
+	return 0;
+}
+
+int CL_Texture::get_border()
+{
+	impl-&gt;make_current();
+	return 0;
+}
+
+CL_PixelBuffer CL_Texture::get_pixeldata(int level)
+{
+	return get_pixeldata(CL_Rect(0, 0, get_width(level), get_height(level)), level);
+}
+
+CL_PixelBuffer CL_Texture::get_pixeldata(CL_PixelFormat &amp;format, int level)
+{
+	return get_pixeldata(format, CL_Rect(0, 0, get_width(level), get_height(level)), level);
+}
+
+CL_PixelBuffer CL_Texture::get_pixeldata(const CL_Rect &amp;rect, int level)
+{
+	return CL_PixelBuffer();
+}
+
+CL_PixelBuffer CL_Texture::get_pixeldata(CL_PixelFormat &amp;format, const CL_Rect &amp;rect, int level)
+{
+	return CL_PixelBuffer();
+}
+
+float CL_Texture::get_min_lod() const
+{
+	impl-&gt;make_current();
+	CLfloat min_lod = 0.0f;
+	clGetTexParameterfv(impl-&gt;target, CL_TEXTURE_MIN_LOD, &amp;min_lod);
+	return min_lod;
+}
+
+float CL_Texture::get_max_lod() const
+{
+	impl-&gt;make_current();
+	CLfloat max_lod = 0.0f;
+	clGetTexParameterfv(impl-&gt;target, CL_TEXTURE_MAX_LOD, &amp;max_lod);
+	return max_lod;
+}
+
+float CL_Texture::get_lod_bias() const
+{
+	impl-&gt;make_current();
+	CLfloat lod_bias = 0.0f;
+	clGetTexParameterfv(impl-&gt;target, CL_TEXTURE_LOD_BIAS, &amp;lod_bias);
+	return lod_bias;
+}
+
+int CL_Texture::get_base_level() const
+{
+	impl-&gt;make_current();
+	CLint base_level = 0;
+	clGetTexParameteriv(impl-&gt;target, CL_TEXTURE_BASE_LEVEL, &amp;base_level);
+	return base_level;
+}
+
+int CL_Texture::get_max_level() const
+{
+	impl-&gt;make_current();
+	CLint max_level = 0;
+	clGetTexParameteriv(impl-&gt;target, CL_TEXTURE_MAX_LEVEL, &amp;max_level);
+	return max_level;
+}
+
+bool CL_Texture::get_generate_mipmap() const
+{
+	impl-&gt;make_current();
+	CLint generate_mipmap = CL_FALSE;
+	clGetTexParameteriv(impl-&gt;target, CL_GENERATE_MIPMAP, &amp;generate_mipmap);
+	return (generate_mipmap != CL_FALSE);
+}
+
+CL_TextureWrapMode CL_Texture::get_wrap_mode_s() const
+{
+	return gl_to_wrap_mode(get_wrap_mode_s_gl());
+}
+
+int CL_Texture::get_wrap_mode_s_gl() const
+{
+	impl-&gt;make_current();
+	CLint wrap_mode = CL_CLAMP;
+	clGetTexParameteriv(impl-&gt;target, CL_TEXTURE_WRAP_S, &amp;wrap_mode);
+	return wrap_mode;
+}
+
+CL_TextureWrapMode CL_Texture::get_wrap_mode_t() const
+{
+	return gl_to_wrap_mode(get_wrap_mode_t_gl());
+}
+
+int CL_Texture::get_wrap_mode_t_gl() const
+{
+	impl-&gt;make_current();
+	CLint wrap_mode = CL_CLAMP;
+	clGetTexParameteriv(impl-&gt;target, CL_TEXTURE_WRAP_T, &amp;wrap_mode);
+	return wrap_mode;
+}
+
+CL_TextureWrapMode CL_Texture::get_wrap_mode_r() const
+{
+	return gl_to_wrap_mode(get_wrap_mode_r_gl());
+}
+
+int CL_Texture::get_wrap_mode_r_gl() const
+{
+	impl-&gt;make_current();
+	CLint wrap_mode = CL_CLAMP;
+	clGetTexParameteriv(impl-&gt;target, CL_TEXTURE_WRAP_R, &amp;wrap_mode);
+	return wrap_mode;
+}
+
+CL_TextureFilter CL_Texture::get_min_filter() const
+{
+	return gl_to_filter(get_min_filter_gl());
+}
+
+int CL_Texture::get_min_filter_gl() const
+{
+	impl-&gt;make_current();
+	CLint filter = CL_LINEAR;
+	clGetTexParameteriv(impl-&gt;target, CL_TEXTURE_MIN_FILTER, &amp;filter);
+	return filter;
+}
+
+CL_TextureFilter CL_Texture::get_mag_filter() const
+{
+	return gl_to_filter(get_mag_filter_gl());
+}
+
+int CL_Texture::get_mag_filter_gl() const
+{
+	impl-&gt;make_current();
+	CLint filter = CL_LINEAR;
+	clGetTexParameteriv(impl-&gt;target, CL_TEXTURE_MAG_FILTER, &amp;filter);
+	return filter;
+}
+
+CL_Color CL_Texture::get_border_color() const
+{
+	impl-&gt;make_current();
+	return CL_Color::black;
+}
+
+float CL_Texture::get_priority() const
+{
+	impl-&gt;make_current();
+	CLfloat priority = 0.0f;
+	clGetTexParameterfv(impl-&gt;target, CL_TEXTURE_PRIORITY, &amp;priority);
+	return priority;
+}
+
+bool CL_Texture::is_resident() const
+{
+	impl-&gt;make_current();
+	CLint resident = CL_FALSE;
+	clGetTexParameteriv(impl-&gt;target, CL_TEXTURE_RESIDENT, &amp;resident);
+	return (resident != CL_FALSE);
+}
+
+CL_TextureDepthMode CL_Texture::get_depth_mode() const
+{
+	return gl_to_depth_mode(get_depth_mode_gl());
+}
+
+int CL_Texture::get_depth_mode_gl() const
+{
+	impl-&gt;make_current();
+	CLint depth_mode = CL_LUMINANCE;
+	clGetTexParameteriv(impl-&gt;target, CL_DEPTH_TEXTURE_MODE, &amp;depth_mode);
+	return depth_mode;
+}
+
+CL_TextureCompareMode CL_Texture::get_compare_mode() const
+{
+	return gl_to_compare_mode(get_compare_mode_gl());
+}
+
+int CL_Texture::get_compare_mode_gl() const
+{
+	impl-&gt;make_current();
+	CLint compare_mode = CL_NONE;
+	clGetTexParameteriv(impl-&gt;target, CL_TEXTURE_COMPARE_MODE, &amp;compare_mode);
+	return compare_mode;
+}
+
+CL_TextureCompareFunction CL_Texture::get_compare_function() const
+{
+	return gl_to_compare_function(get_compare_function_gl());
+}
+
+int CL_Texture::get_compare_function_gl() const
+{
+	impl-&gt;make_current();
+	CLint compare_function = CL_LEQUAL;
+	clGetTexParameteriv(impl-&gt;target, CL_TEXTURE_COMPARE_FUNC, &amp;compare_function);
+	return compare_function;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Texture Operations:
+
+void CL_Texture::bind()
+{
+	clBindTexture(impl-&gt;target, impl-&gt;handle);
+}
+
+void CL_Texture::set_size(
+	int format,
+	int width,
+	int height,
+	int depth,
+	int border,
+	int level)
+{
+	switch (impl-&gt;target)
+	{
+	case CL_TEXTURE_3D:
+		set_image3d_gl(
+			impl-&gt;target,
+			level,
+			format,
+			width,
+			height,
+			depth,
+			border,
+			CL_RGBA,
+			CL_BYTE,
+			0);
+		break;
+
+	case CL_TEXTURE_2D:
+		set_image2d_gl(
+			impl-&gt;target,
+			level,
+			format,
+			width,
+			height,
+			border,
+			CL_RGBA,
+			CL_BYTE,
+			0);
+		break;
+
+	case CL_TEXTURE_1D:
+		set_image2d_gl(
+			impl-&gt;target,
+			level,
+			format,
+			width,
+			border,
+			CL_RGBA,
+			CL_BYTE,
+			0);
+		break;
+
+	default:
+		throw CL_Error(&quot;CL_Texture::set_image does not support this texture format&quot;);
+	}
+}
+
+void CL_Texture::set_image(
+	CL_PixelBuffer &amp;image,
+	int level,
+	int border,
+	int format)
+{
+	CLenum native_format = 0, native_type = 0;
+	bool is_native_format = CL_OpenGL::to_opengl_pixelformat(image.get_format(), native_format, native_type);
+	if (is_native_format)
+	{
+		switch (impl-&gt;target)
+		{
+/*		case CL_TEXTURE_3D:
+			image.lock();
+			set_image3d_gl(
+				impl-&gt;target,
+				level,
+				(format == 0) ? native_format : format,
+				image.get_width(),
+				image.get_height(),
+				image.get_depth(),
+				border,
+				native_format,
+				native_type,
+				image.get_data());
+			image.unlock();
+			break;
+*/
+		case CL_TEXTURE_2D:
+			image.lock();
+			set_image2d_gl(
+				impl-&gt;target,
+				level,
+				(format == 0) ? native_format : format,
+				image.get_width(),
+				image.get_height(),
+				border,
+				native_format,
+				native_type,
+				image.get_data());
+			image.unlock();
+			break;
+
+		case CL_TEXTURE_1D:
+			image.lock();
+			set_image1d_gl(
+				impl-&gt;target,
+				level,
+				(format == 0) ? native_format : format,
+				image.get_width(),
+				border,
+				native_format,
+				native_type,
+				image.get_data());
+			image.unlock();
+			break;
+
+		default:
+			throw CL_Error(&quot;CL_Texture::set_image does not support this texture format&quot;);
+		}
+	}
+	else
+	{
+		// For now, upload all non-opengl compatible formats in rgba8888 format:
+		
+		CL_PixelBuffer gl_image = image.to_format(CL_PixelFormat::rgba8888);
+		set_image(gl_image, format, level, border);
+	}
+}
+
+void CL_Texture::set_cube_map(
+	CL_PixelBuffer &amp;cube_map_positive_x,
+	CL_PixelBuffer &amp;cube_map_negative_x,
+	CL_PixelBuffer &amp;cube_map_positive_y,
+	CL_PixelBuffer &amp;cube_map_negative_y,
+	CL_PixelBuffer &amp;cube_map_positive_z,
+	CL_PixelBuffer &amp;cube_map_negative_z,
+	int level,
+	int border,
+	int format)
+{
+	if (impl-&gt;target != CL_TEXTURE_CUBE_MAP)
+		throw CL_Error(&quot;CL_Texture::set_cube_map does not support this texture format&quot;);
+
+	CL_PixelBuffer cube_maps[6];
+	cube_maps[0] = cube_map_positive_x;
+	cube_maps[1] = cube_map_negative_x;
+	cube_maps[2] = cube_map_positive_y;
+	cube_maps[3] = cube_map_negative_y;
+	cube_maps[4] = cube_map_positive_z;
+	cube_maps[5] = cube_map_negative_z;
+	CLenum native_format[6];
+	CLenum native_type[6];
+	int index_maps;
+
+	// Make sure our images are in opengl compatible formats:
+	for (index_maps = 0; index_maps &lt; 6; index_maps++)
+	{
+		bool is_native_format = CL_OpenGL::to_opengl_pixelformat(
+			cube_maps[index_maps].get_format(),
+			native_format[index_maps],
+			native_type[index_maps]);
+		if (!is_native_format)
+		{
+			cube_maps[index_maps] = cube_maps[index_maps].to_format(CL_PixelFormat::rgba8888);
+			is_native_format = CL_OpenGL::to_opengl_pixelformat(
+				cube_maps[index_maps].get_format(),
+				native_format[index_maps],
+				native_type[index_maps]);
+		}
+	}
+	
+	// Upload cube maps:
+	int targets[6] =
+	{
+		CL_TEXTURE_CUBE_MAP_POSITIVE_X,
+		CL_TEXTURE_CUBE_MAP_NEGATIVE_X,
+		CL_TEXTURE_CUBE_MAP_POSITIVE_Y,
+		CL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
+		CL_TEXTURE_CUBE_MAP_POSITIVE_Z,
+		CL_TEXTURE_CUBE_MAP_NEGATIVE_Z
+	};
+	
+	for (index_maps = 0; index_maps &lt; 6; index_maps++)
+	{
+		cube_maps[index_maps].lock();
+		set_image2d_gl(
+			targets[index_maps],
+			level,
+			(format == 0) ? native_format[index_maps] : format,
+			cube_maps[index_maps].get_width(),
+			cube_maps[index_maps].get_height(),
+			border,
+			native_format[index_maps],
+			native_type[index_maps],
+			cube_maps[index_maps].get_data());
+		cube_maps[index_maps].unlock();
+	}
+}
+
+void CL_Texture::set_image3d_gl(
+	int gl_target,
+	int gl_level,
+	int gl_internal_format,
+	int gl_width,
+	int gl_height,
+	int gl_depth,
+	int gl_border,
+	int gl_format,
+	int gl_type,
+	void *gl_data)
+{
+	impl-&gt;make_current();
+	clTexImage3D(
+		gl_target,
+		gl_level,
+		gl_internal_format,
+		gl_width,
+		gl_height,
+		gl_depth,
+		gl_border,
+		gl_format,
+		gl_type,
+		gl_data);
+}
+
+void CL_Texture::set_image2d_gl(
+	int gl_target,
+	int gl_level,
+	int gl_internal_format,
+	int gl_width,
+	int gl_height,
+	int gl_border,
+	int gl_format,
+	int gl_type,
+	void *gl_data)
+{
+	impl-&gt;make_current();
+	clTexImage2D(
+		gl_target,
+		gl_level,
+		gl_internal_format,
+		gl_width,
+		gl_height,
+		gl_border,
+		gl_format,
+		gl_type,
+		gl_data);
+}
+		
+void CL_Texture::set_image1d_gl(
+	int gl_target,
+	int gl_level,
+	int gl_internal_format,
+	int gl_width,
+	int gl_border,
+	int gl_format,
+	int gl_type,
+	void *gl_data)
+{
+	impl-&gt;make_current();
+	clTexImage1D(
+		gl_target,
+		gl_level,
+		gl_internal_format,
+		gl_width,
+		gl_border,
+		gl_format,
+		gl_type,
+		gl_data);
+}
+
+void CL_Texture::set_subimage(
+	int x,
+	int y,
+	CL_PixelBuffer &amp;image,
+	int level)
+{
+}
+
+void CL_Texture::set_subimage(
+	const CL_Point &amp;point,
+	CL_PixelBuffer &amp;image,
+	int level)
+{
+}
+
+void CL_Texture::set_subimage3d_gl(
+	int gl_target,
+	int gl_level,
+	int gl_xoffset,
+	int gl_yoffset,
+	int gl_zoffset,
+	int gl_width,
+	int gl_height,
+	int gl_depth,
+	int gl_format,
+	int gl_type,
+	void *gl_data)
+{
+	impl-&gt;make_current();
+	clTexSubImage3D(
+		gl_target,
+		gl_level,
+		gl_xoffset,
+		gl_yoffset,
+		gl_zoffset,
+		gl_width,
+		gl_height,
+		gl_depth,
+		gl_format,
+		gl_type,
+		gl_data);
+}
+
+void CL_Texture::set_subimage2d_gl(
+	int gl_target,
+	int gl_level,
+	int gl_xoffset,
+	int gl_yoffset,
+	int gl_width,
+	int gl_height,
+	int gl_format,
+	int gl_type,
+	void *gl_data)
+{
+	impl-&gt;make_current();
+	clTexSubImage2D(
+		gl_target,
+		gl_level,
+		gl_xoffset,
+		gl_yoffset,
+		gl_width,
+		gl_height,
+		gl_format,
+		gl_type,
+		gl_data);
+}
+
+void CL_Texture::set_subimage1d_gl(
+	int gl_target,
+	int gl_level,
+	int gl_xoffset,
+	int gl_width,
+	int gl_format,
+	int gl_type,
+	void *gl_data)
+{
+	impl-&gt;make_current();
+	clTexSubImage1D(
+		gl_target,
+		gl_level,
+		gl_xoffset,
+		gl_width,
+		gl_format,
+		gl_type,
+		gl_data);
+}
+
+void CL_Texture::copy_image(
+	int level,
+	int border,
+	int format,
+	CL_GraphicContext *gc)
+{
+}
+
+void CL_Texture::copy_image(
+	int x,
+	int y,
+	int width,
+	int height,
+	int level,
+	int border,
+	int format,
+	CL_GraphicContext *gc)
+{
+}
+
+void CL_Texture::copy_image(
+	const CL_Rect &amp;pos,
+	int level,
+	int border,
+	int format,
+	CL_GraphicContext *gc)
+{
+}
+
+void CL_Texture::copy_image2d_gl(
+	int gl_target,
+	int gl_level,
+	int gl_internal_format,
+	int gl_x,
+	int gl_y,
+	int gl_width,
+	int gl_height,
+	int gl_border,
+	CL_GraphicContext *gc)
+{
+	CL_OpenGLState state(gc);
+	state.set_active();
+	clEnable(impl-&gt;target);
+	clBindTexture(impl-&gt;target, impl-&gt;handle);
+	clCopyTexImage2D(
+		gl_target,
+		gl_level,
+		gl_internal_format,
+		gl_x,
+		gl_y,
+		gl_width,
+		gl_height,
+		gl_border);
+}
+
+void CL_Texture::copy_image1d_gl(
+	int gl_target,
+	int gl_level,
+	int gl_internal_format,
+	int gl_x,
+	int gl_y,
+	int gl_width,
+	int gl_border,
+	CL_GraphicContext *gc)
+{
+	CL_OpenGLState state(gc);
+	state.set_active();
+	clEnable(impl-&gt;target);
+	clBindTexture(impl-&gt;target, impl-&gt;handle);
+	clCopyTexImage1D(
+		gl_target,
+		gl_level,
+		gl_internal_format,
+		gl_x,
+		gl_y,
+		gl_width,
+		gl_border);
+}
+
+void CL_Texture::copy_subimage(
+	int offset_x,
+	int offset_y,
+	int level,
+	CL_GraphicContext *gc)
+{
+}
+
+void CL_Texture::copy_subimage(
+	int offset_x,
+	int offset_y,
+	int x,
+	int y,
+	int width,
+	int height,
+	int level,
+	CL_GraphicContext *gc)
+{
+}
+
+void CL_Texture::copy_subimage(
+	const CL_Point &amp;offset,
+	const CL_Rect &amp;pos,
+	int level,
+	CL_GraphicContext *gc)
+{
+}
+
+void CL_Texture::copy_subimage3d_gl(
+	int gl_target,
+	int gl_level,
+	int gl_xoffset,
+	int gl_yoffset,
+	int gl_zoffset,
+	int gl_x,
+	int gl_y,
+	int gl_width,
+	int gl_height,
+	CL_GraphicContext *gc)
+{
+	CL_OpenGLState state(gc);
+	state.set_active();
+	clEnable(impl-&gt;target);
+	clBindTexture(impl-&gt;target, impl-&gt;handle);
+	clCopyTexSubImage3D(
+		gl_target,
+		gl_level,
+		gl_xoffset,
+		gl_yoffset,
+		gl_zoffset,
+		gl_x,
+		gl_y,
+		gl_width,
+		gl_height);
+}
+
+void CL_Texture::copy_subimage2d_gl(
+	int gl_target,
+	int gl_level,
+	int gl_xoffset,
+	int gl_yoffset,
+	int gl_x,
+	int gl_y,
+	int gl_width,
+	int gl_height,
+	CL_GraphicContext *gc)
+{
+	CL_OpenGLState state(gc);
+	state.set_active();
+	clEnable(impl-&gt;target);
+	clBindTexture(impl-&gt;target, impl-&gt;handle);
+	clCopyTexSubImage2D(
+		gl_target,
+		gl_level,
+		gl_xoffset,
+		gl_yoffset,
+		gl_x,
+		gl_y,
+		gl_width,
+		gl_height);
+}
+
+void CL_Texture::copy_subimage1d_gl(
+	int gl_target,
+	int gl_level,
+	int gl_xoffset,
+	int gl_internal_format,
+	int gl_x,
+	int gl_y,
+	int gl_width,
+	CL_GraphicContext *gc)
+{
+	CL_OpenGLState state(gc);
+	state.set_active();
+	clEnable(impl-&gt;target);
+	clBindTexture(impl-&gt;target, impl-&gt;handle);
+	clCopyTexSubImage1D(
+		gl_target,
+		gl_level,
+		gl_xoffset,
+		gl_x,
+		gl_y,
+		gl_width);
+}
+
+void CL_Texture::set_min_lod(float min_lod)
+{
+	impl-&gt;make_current();
+	clTexParameterf(impl-&gt;target, CL_TEXTURE_MIN_LOD, min_lod);
+}
+
+void CL_Texture::set_max_lod(float max_lod)
+{
+	impl-&gt;make_current();
+	clTexParameterf(impl-&gt;target, CL_TEXTURE_MAX_LOD, max_lod);
+}
+
+void CL_Texture::set_lod_bias(float lod_bias)
+{
+	impl-&gt;make_current();
+	clTexParameterf(impl-&gt;target, CL_TEXTURE_LOD_BIAS, lod_bias);
+}
+
+void CL_Texture::set_base_level(int base_level)
+{
+	impl-&gt;make_current();
+	clTexParameteri(impl-&gt;target, CL_TEXTURE_BASE_LEVEL, base_level);
+}
+
+void CL_Texture::set_max_level(int max_level)
+{
+	impl-&gt;make_current();
+	clTexParameteri(impl-&gt;target, CL_TEXTURE_MAX_LEVEL, max_level);
+}
+
+void CL_Texture::set_generate_mipmap(bool generate_mipmap)
+{
+	impl-&gt;make_current();
+	clTexParameteri(impl-&gt;target, CL_GENERATE_MIPMAP, generate_mipmap ? CL_TRUE : CL_FALSE);
+}
+
+void CL_Texture::set_wrap_mode(
+	CL_TextureWrapMode wrap_s,
+	CL_TextureWrapMode wrap_t,
+	CL_TextureWrapMode wrap_r)
+{
+	set_wrap_mode_gl(
+		wrap_mode_to_gl(wrap_s),
+		wrap_mode_to_gl(wrap_t),
+		wrap_mode_to_gl(wrap_r));
+}
+
+void CL_Texture::set_wrap_mode(
+	CL_TextureWrapMode wrap_s,
+	CL_TextureWrapMode wrap_t)
+{
+	set_wrap_mode_gl(
+		wrap_mode_to_gl(wrap_s),
+		wrap_mode_to_gl(wrap_t));
+}
+
+void CL_Texture::set_wrap_mode(CL_TextureWrapMode wrap_s)
+{
+	set_wrap_mode_gl(wrap_mode_to_gl(wrap_s));
+}
+
+void CL_Texture::set_wrap_mode_gl(
+	int gl_wrap_s,
+	int gl_wrap_t,
+	int gl_wrap_r)
+{
+	impl-&gt;make_current();
+	clTexParameteri(impl-&gt;target, CL_TEXTURE_WRAP_S, gl_wrap_s);
+	clTexParameteri(impl-&gt;target, CL_TEXTURE_WRAP_T, gl_wrap_t);
+	clTexParameteri(impl-&gt;target, CL_TEXTURE_WRAP_R, gl_wrap_r);
+}
+
+void CL_Texture::set_wrap_mode_gl(
+	int gl_wrap_s,
+	int gl_wrap_t)
+{
+	impl-&gt;make_current();
+	clTexParameteri(impl-&gt;target, CL_TEXTURE_WRAP_S, gl_wrap_s);
+	clTexParameteri(impl-&gt;target, CL_TEXTURE_WRAP_T, gl_wrap_t);
+}
+
+void CL_Texture::set_wrap_mode_gl(int gl_wrap_s)
+{
+	impl-&gt;make_current();
+	clTexParameteri(impl-&gt;target, CL_TEXTURE_WRAP_S, gl_wrap_s);
+}
+
+void CL_Texture::set_min_filter(CL_TextureFilter filter)
+{
+	set_min_filter_gl(filter_to_gl(filter));
+}
+
+void CL_Texture::set_min_filter_gl(int gl_filter)
+{
+	impl-&gt;make_current();
+	clTexParameteri(impl-&gt;target, CL_TEXTURE_MIN_FILTER, gl_filter);
+}
+
+void CL_Texture::set_mag_filter(CL_TextureFilter filter)
+{
+	set_mag_filter_gl(filter_to_gl(filter));
+}
+
+void CL_Texture::set_mag_filter_gl(int gl_filter)
+{
+	impl-&gt;make_current();
+	clTexParameteri(impl-&gt;target, CL_TEXTURE_MAG_FILTER, gl_filter);
+}
+
+void CL_Texture::set_border_color(float red, float green, float blue, float alpha)
+{
+	impl-&gt;make_current();
+	CLfloat color[4] = { red, green, blue, alpha };
+	clTexParameterfv(impl-&gt;target, CL_TEXTURE_BORDER_COLOR, color);
+}
+
+void CL_Texture::set_border_color(const CL_Color &amp;color)
+{
+	set_border_color(
+		color.get_red()/255.0f,
+		color.get_green()/255.0f,
+		color.get_blue()/255.0f,
+		color.get_alpha()/255.0f);
+}
+
+void CL_Texture::set_priority(float priority)
+{
+	impl-&gt;make_current();
+	clTexParameterf(impl-&gt;target, CL_TEXTURE_PRIORITY, priority);
+}
+
+void CL_Texture::set_depth_mode(CL_TextureDepthMode depth_mode)
+{
+	set_depth_mode_gl(depth_mode_to_gl(depth_mode));
+}
+
+void CL_Texture::set_depth_mode_gl(int gl_depth_mode)
+{
+	impl-&gt;make_current();
+	clTexParameteri(impl-&gt;target, CL_DEPTH_TEXTURE_MODE, gl_depth_mode);
+}
+
+void CL_Texture::set_texture_compare(CL_TextureCompareMode mode, CL_TextureCompareFunction func)
+{
+	set_texture_compare_gl(
+		compare_mode_to_gl(mode),
+		compare_function_to_gl(func));
+}
+
+void CL_Texture::set_texture_compare_gl(int gl_mode, int gl_func)
+{
+	impl-&gt;make_current();
+	clTexParameteri(impl-&gt;target, CL_TEXTURE_COMPARE_MODE, gl_mode);
+	clTexParameteri(impl-&gt;target, CL_TEXTURE_COMPARE_FUNC, gl_func);
+}
+
+int CL_Texture::wrap_mode_to_gl(CL_TextureWrapMode wrap)
+{
+	switch (wrap)
+	{
+	case cl_wrap_clamp:
+		return CL_CLAMP;
+	case cl_wrap_clamp_to_edge:
+		return CL_CLAMP_TO_EDGE;
+	case cl_wrap_clamp_to_border:
+		return CL_CLAMP_TO_BORDER;
+	case cl_wrap_repeat:
+		return CL_REPEAT;
+	case cl_wrap_mirrored_repeat:
+		return CL_MIRRORED_REPEAT;
+	}
+	return -1;
+}
+
+CL_TextureWrapMode CL_Texture::gl_to_wrap_mode(int gl_wrap)
+{
+	switch (gl_wrap)
+	{
+	case CL_CLAMP:
+		return cl_wrap_clamp;
+	case CL_CLAMP_TO_EDGE:
+		return cl_wrap_clamp_to_edge;
+	case CL_CLAMP_TO_BORDER:
+		return cl_wrap_clamp_to_border;
+	case CL_REPEAT:
+		return cl_wrap_repeat;
+	case CL_MIRRORED_REPEAT:
+		return cl_wrap_mirrored_repeat;
+	}
+	return cl_wrap_clamp;
+}
+
+int CL_Texture::filter_to_gl(CL_TextureFilter filter)
+{
+	switch (filter)
+	{
+	case cl_filter_nearest:
+		return CL_NEAREST;
+	case cl_filter_linear:
+		return CL_LINEAR;
+	case cl_filter_nearest_mipmap_nearest:
+		return CL_NEAREST_MIPMAP_NEAREST;
+	case cl_filter_nearest_mipmap_linear:
+		return CL_NEAREST_MIPMAP_LINEAR;
+	case cl_filter_linear_mipmap_nearest:
+		return CL_LINEAR_MIPMAP_NEAREST;
+	case cl_filter_linear_mipmap_linear:
+		return CL_LINEAR_MIPMAP_LINEAR;
+	}
+	return -1;
+}
+
+CL_TextureFilter CL_Texture::gl_to_filter(int gl_filter)
+{
+	switch (gl_filter)
+	{
+	case CL_NEAREST:
+		return cl_filter_nearest;
+	case CL_LINEAR:
+		return cl_filter_linear;
+	case CL_NEAREST_MIPMAP_NEAREST:
+		return cl_filter_nearest_mipmap_nearest;
+	case CL_NEAREST_MIPMAP_LINEAR:
+		return cl_filter_nearest_mipmap_linear;
+	case CL_LINEAR_MIPMAP_NEAREST:
+		return cl_filter_linear_mipmap_nearest;
+	case CL_LINEAR_MIPMAP_LINEAR:
+		return cl_filter_linear_mipmap_linear;
+	}
+	return cl_filter_nearest;
+}
+
+int CL_Texture::depth_mode_to_gl(CL_TextureDepthMode depth_mode)
+{
+	switch (depth_mode)
+	{
+	case cl_depthmode_luminance:
+		return CL_LUMINANCE;
+	case cl_depthmode_intensity:
+		return CL_INTENSITY;
+	case cl_depthmode_alpha:
+		return CL_ALPHA;
+	}
+	return -1;
+}
+
+CL_TextureDepthMode CL_Texture::gl_to_depth_mode(int gl_depth_mode)
+{
+	switch (gl_depth_mode)
+	{
+	case CL_LUMINANCE:
+		return cl_depthmode_luminance;
+	case CL_INTENSITY:
+		return cl_depthmode_intensity;
+	case CL_ALPHA:
+		return cl_depthmode_alpha;
+	}
+	return cl_depthmode_luminance;
+}
+
+int CL_Texture::compare_mode_to_gl(CL_TextureCompareMode mode)
+{
+	switch (mode)
+	{
+	case cl_comparemode_none:
+		return CL_NONE;
+	case cl_comparemode_compare_r_to_texture:
+		return CL_COMPARE_R_TO_TEXTURE;
+	}
+	return -1;
+}
+
+CL_TextureCompareMode CL_Texture::gl_to_compare_mode(int gl_mode)
+{
+	switch (gl_mode)
+	{
+	case CL_NONE:
+		return cl_comparemode_none;
+	case CL_COMPARE_R_TO_TEXTURE:
+		return cl_comparemode_compare_r_to_texture;
+	}
+        return cl_comparemode_none;
+}
+
+int CL_Texture::compare_function_to_gl(CL_TextureCompareFunction func)
+{
+	switch (func)
+	{
+	case cl_comparefunc_lequal:
+		return CL_LEQUAL;
+	case cl_comparefunc_gequal:
+		return CL_GEQUAL;
+	case cl_comparefunc_less:
+		return CL_LESS;
+	case cl_comparefunc_greater:
+		return CL_GREATER;
+	case cl_comparefunc_equal:
+		return CL_EQUAL;
+	case cl_comparefunc_notequal:
+		return CL_NOTEQUAL;
+	case cl_comparefunc_always:
+		return CL_ALWAYS;
+	case cl_comparefunc_never:
+		return CL_NEVER;
+	}
+	return -1;
+}
+
+CL_TextureCompareFunction CL_Texture::gl_to_compare_function(int gl_func)
+{
+	switch (gl_func)
+	{
+	case CL_LEQUAL:
+		return cl_comparefunc_lequal;
+	case CL_GEQUAL:
+		return cl_comparefunc_gequal;
+	case CL_LESS:
+		return cl_comparefunc_less;
+	case CL_GREATER:
+		return cl_comparefunc_greater;
+	case CL_EQUAL:
+		return cl_comparefunc_equal;
+	case CL_NOTEQUAL:
+		return cl_comparefunc_notequal;
+	case CL_ALWAYS:
+		return cl_comparefunc_always;
+	case CL_NEVER:
+		return cl_comparefunc_never;
+	}
+	return cl_comparefunc_lequal;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Texture Implementation:

Added: trunk/clanlib/GL/viewpoint.cpp
===================================================================
--- trunk/clanlib/GL/viewpoint.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GL/viewpoint.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,260 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;Display/display_precomp.h&quot;
+#include &quot;API/GL/viewpoint.h&quot;
+#include &quot;API/GL/opengl_wrap.h&quot;
+#ifdef __APPLE__
+#include &lt;OpenGL/glu.h&gt;
+#else
+#include &lt;GL/glu.h&gt;
+#endif
+#include &lt;math.h&gt;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Viewpoint construction:
+
+CL_Viewpoint::CL_Viewpoint() : pos(0,0,0), dir(0,0,1), up(0,1,0)
+{
+}
+
+CL_Viewpoint::CL_Viewpoint(
+	const CL_Vector &amp;_pos,
+	const CL_Vector &amp;_dir,
+	const CL_Vector &amp;_up) : pos(_pos), dir(_dir), up(_up)
+{
+	dir.normalize();
+	up.normalize();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Viewpoint attributes:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Viewpoint operations:
+
+void CL_Viewpoint::translate(float mov_x, float mov_y, float mov_z)
+{
+	pos.x += mov_x;
+	pos.y += mov_y;
+	pos.z += mov_z;
+}
+
+void CL_Viewpoint::set(float pos_x, float pos_y, float pos_z)
+{
+	pos.x = pos_x;
+	pos.y = pos_y;
+	pos.z = pos_z;
+}
+
+void CL_Viewpoint::translate_local(float mov_x, float mov_y, float mov_z)
+{
+	CL_Vector res = dir.cross(up);
+	res.normalize();
+
+	float delta_x = res.x*mov_x + up.x*mov_y + dir.x*mov_z;
+	float delta_y = res.y*mov_x + up.y*mov_y + dir.y*mov_z;
+	float delta_z = res.z*mov_x + up.z*mov_y + dir.z*mov_z;
+
+	pos = pos+CL_Vector(delta_x, delta_y, delta_z, 0.0f);
+}
+
+void CL_Viewpoint::rotate_local(double angle, double x, double y, double z)
+{
+/*
+	DESCRIPTION
+	glRotate produces a rotation of angle degrees around the
+	vector (x,y,z). The current matrix (see glMatrixMode) is
+	multiplied by a rotation matrix with the product replacing
+	the current matrix, as if glMultMatrix were called with the
+	following matrix as its argument:
+
+		( xx(1-c)+c    xy(1-c)-zs    xz(1-c)+ys   0  )
+		|                                            |
+		| yx(1-c)+zs   yy(1-c)+c     yz(1-c)-xs	  0  |
+		| xz(1-c)-ys   yz(1-c)+xs    zz(1-c)+c	  0  |
+		|                                            |
+		(     0            0             0        1  )
+
+	Where c = cos(angle), s = sine(angle), and ||( x,y,z )|| = 1
+	(if not, the GL will normalize this vector).
+*/
+	CLdouble length = sqrt(x*x+y*y+z*z);
+	x /= length;
+	y /= length;
+	z /= length;
+
+	CLdouble c = cos(angle*3.14/180);
+	CLdouble s = sin(angle*3.14/180);
+
+	CLdouble matrix[4*4] =
+	{
+		x*x*(1-c)+c, x*y*(1-c)-z*s, x*z*(1-c)+y*s, 0.0f,
+		y*x*(1-c)+z*s, y*y*(1-c)+c, y*z*(1-c)-x*s, 0.0f,
+		x*z*(1-c)-y*s, y*z*(1-c)+x*s, z*z*(1-c)+c, 0.0f,
+		0.0f, 0.0f, 0.0f, 1.0f
+	};
+
+	// Rotate local dir vector:
+	CLdouble matrix_dir[4*1] = { 0.0, 0.0, 1.0, 1.0 };
+	CLdouble matrix_dir_result[4*1] =
+	{
+		matrix[0]*matrix_dir[0] + matrix[4]*matrix_dir[1] + matrix[8]*matrix_dir[2] + matrix[12]*matrix_dir[3],
+		matrix[1]*matrix_dir[1] + matrix[5]*matrix_dir[1] + matrix[9]*matrix_dir[2] + matrix[13]*matrix_dir[3],
+		matrix[2]*matrix_dir[1] + matrix[6]*matrix_dir[1] + matrix[10]*matrix_dir[2] + matrix[14]*matrix_dir[3],
+		matrix[3]*matrix_dir[1] + matrix[7]*matrix_dir[1] + matrix[11]*matrix_dir[2] + matrix[15]*matrix_dir[3]
+	};
+
+	// Rotate local up vector:
+	CLdouble matrix_up[4*1] = { 0.0, 1.0, 0.0, 1.0 };
+	CLdouble matrix_up_result[4*1] =
+	{
+		matrix[0]*matrix_up[0] + matrix[4]*matrix_up[1] + matrix[8]*matrix_up[2] + matrix[12]*matrix_up[3],
+		matrix[1]*matrix_up[1] + matrix[5]*matrix_up[1] + matrix[9]*matrix_up[2] + matrix[13]*matrix_up[3],
+		matrix[2]*matrix_up[1] + matrix[6]*matrix_up[1] + matrix[10]*matrix_up[2] + matrix[14]*matrix_up[3],
+		matrix[3]*matrix_up[1] + matrix[7]*matrix_up[1] + matrix[11]*matrix_up[2] + matrix[15]*matrix_up[3]
+	};
+
+	CL_Vector sideways = dir.cross(up);
+	sideways.normalize();
+
+	// Convert local vectors to world vectors:
+	CL_Vector new_up(
+		(float) (matrix_up_result[0]*sideways.x + matrix_up_result[1]*up.x + matrix_up_result[2]*dir.x),
+		(float) (matrix_up_result[0]*sideways.y + matrix_up_result[1]*up.y + matrix_up_result[2]*dir.y),
+		(float) (matrix_up_result[0]*sideways.z + matrix_up_result[1]*up.z + matrix_up_result[2]*dir.z));
+
+	CL_Vector new_dir(
+		(float) (matrix_dir_result[0]*sideways.x + matrix_dir_result[1]*up.x + matrix_dir_result[2]*dir.x),
+		(float) (matrix_dir_result[0]*sideways.y + matrix_dir_result[1]*up.y + matrix_dir_result[2]*dir.y),
+		(float) (matrix_dir_result[0]*sideways.z + matrix_dir_result[1]*up.z + matrix_dir_result[2]*dir.z));
+
+	new_up.normalize();
+	new_dir.normalize();
+
+	up = new_up;
+	dir = new_dir;
+}
+
+void CL_Viewpoint::enter_local() const
+{
+	// Move local model coordinates into place in the world:
+	clMatrixMode(CL_MODELVIEW);
+	clPushMatrix();
+
+	CL_Vector f = -dir;
+	CL_Vector up2 = -up;
+	f.normalize();
+	up2.normalize();
+	CL_Vector s = f.cross(up2);
+	CL_Vector u = s.cross(f);
+
+	// Inverted gluLookAt coordinate switch matrix:
+	CLfloat matrix[4*4] =
+	{
+		 s.x,  s.y,  s.z,  0.0f,
+		 u.x,  u.y,  u.z,  0.0f,
+		-f.x, -f.y, -f.z,  0.0f,
+		 0.0f, 0.0f, 0.0f, 1.0f
+	};
+
+	clTranslatef(pos.x, pos.y, pos.z);
+	clMultMatrixf(matrix);
+}
+
+void CL_Viewpoint::leave_local() const
+{
+	// Restore model view matrix:
+	clMatrixMode(CL_MODELVIEW);
+	clPopMatrix();
+/*
+	// Render direction arrow for debugging:
+	clDisable(CL_DEPTH_TEST);
+	clDisable(CL_TEXTURE_2D);
+	clBegin(CL_LINE_STRIP);
+	clColor3f(1.0f,1.0f,1.0f);
+	clVertex3f(pos.x+up.x, pos.y+up.y, pos.z+up.z);
+	clVertex3f(pos.x+dir.x, pos.y+dir.y, pos.z+dir.z);
+	clVertex3f(pos.x-up.x, pos.y-up.y, pos.z-up.z);
+	clEnd();
+	clEnable(CL_TEXTURE_2D);
+	clEnable(CL_DEPTH_TEST);
+*/
+}
+
+CL_Vector CL_Viewpoint::make_local_direction(const CL_Vector &amp;v) const
+{
+	CLfloat matrix_v[4] = { v.x, v.y, v.z, v.w };
+
+	CL_Vector f = -dir;
+	CL_Vector up2 = -up;
+	f.normalize();
+	up2.normalize();
+	CL_Vector s = f.cross(up2);
+	CL_Vector u = s.cross(f);
+
+	// gluLookAt coordinate switch matrix:
+	CLfloat matrix[4*4] =
+	{
+		s.x, u.x, -f.x, 0.0f,
+		s.y, u.y, -f.y, 0.0f,
+		s.z, u.z, -f.z, 0.0f,
+		0.0f, 0.0f, 0.0f, 1.0f
+	};
+
+	CLfloat matrix_lv[4] = { 0.0f, 0.0f, 0.0f, 0.0f };
+	for (int r=0; r&lt;4; r++)
+	{
+		for (int c=0; c&lt;4; c++)
+		{
+			matrix_lv[r] += matrix[c*4+r]*matrix_v[c];
+		}
+	}
+
+	return CL_Vector(matrix_lv[0], matrix_lv[1], matrix_lv[2], matrix_lv[3]);
+}
+
+void CL_Viewpoint::setup_modelview() const
+{
+	clMatrixMode(CL_MODELVIEW);
+	clLoadIdentity();			
+	gluLookAt(
+		pos.x,          // position
+		pos.y,
+		pos.z,
+		pos.x+dir.x,    // center
+		pos.y+dir.y,
+		pos.z+dir.z,
+		up.x,           // up
+		up.y,
+		up.z);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Viewpoint implementation

Added: trunk/clanlib/GUI/Makefile.am
===================================================================
--- trunk/clanlib/GUI/Makefile.am	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/Makefile.am	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,96 @@
+lib_LTLIBRARIES = libclanGUI.la
+
+libclanGUI_la_SOURCES = \
+frame_generic.cpp \
+treeview_generic.h \
+component_manager.cpp \
+frame.cpp \
+image_generic.h \
+button_generic.h \
+listbox_generic.h \
+radiogroup.cpp \
+progressbar_generic.cpp \
+component_manager_generic.h \
+radiogroup_generic.h \
+gui_manager.cpp \
+component_generic.h \
+stylemanager.cpp \
+scrollbar_generic.cpp \
+inputbox_generic.cpp \
+inputdialog.cpp \
+inputdialog_generic.cpp \
+label.cpp \
+precomp.h \
+gui_manager_generic.h \
+component_tokenizer.h \
+scrollbar_generic.h \
+listbox.cpp \
+inputbox.cpp \
+image_generic.cpp \
+component_resize_handler.cpp \
+treenode_generic.cpp \
+filedialog_generic.cpp \
+inputbox_generic.h \
+button.cpp \
+component_manager_generic.cpp \
+progressbar.cpp \
+component.cpp \
+component_type.cpp \
+component_type_generic.h \
+layout.cpp \
+layout_generic.cpp \
+layout_generic.h \
+layout_item.cpp \
+layout_item.h \
+gui_manager_generic.cpp \
+treenode_generic.h \
+image.cpp \
+button_generic.cpp \
+default_component_types.h \
+checkbox.cpp \
+component_generic.cpp \
+radiobutton.cpp \
+messagebox_generic.cpp \
+treeitem.cpp \
+label_generic.cpp \
+listbox_generic.cpp \
+setupgui.cpp \
+progressbar_generic.h \
+messagebox.cpp \
+scrollbar.cpp \
+frame_generic.h \
+radiogroup_generic.cpp \
+componentfile_preprocess.h \
+label_generic.h \
+component_move_handler.cpp \
+treenode.cpp \
+window.cpp \
+window_generic.cpp \
+treeview.cpp \
+filedialog_generic.h \
+treeitem_generic.cpp \
+messagebox_generic.h \
+treeitem_generic.h \
+treeview_generic.cpp \
+precomp.cpp \
+filedialog.cpp \
+window_generic.h \
+menu_node_generic.h \
+menu.cpp \
+menu_node.cpp \
+menu_node_generic.cpp \
+menu_generic.h \
+menu_generic.cpp \
+menu_item.cpp \
+menu_item_generic.cpp \
+deck.cpp \
+deck_generic.h \
+deck_generic.cpp
+
+
+
+libclanGUI_la_LDFLAGS = \
+  -release $(LT_RELEASE) \
+  -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE)
+
+# EOF #

Added: trunk/clanlib/GUI/button.cpp
===================================================================
--- trunk/clanlib/GUI/button.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/button.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,180 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/GUI/button.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;button_generic.h&quot;
+#include &quot;component_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_Button::CL_Button(
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(parent, style), impl(0)
+{
+	impl = new CL_Button_Generic(this, std::string(), false);
+	get_style_manager()-&gt;connect_styles(&quot;button&quot;, this);
+	find_preferred_size();
+}
+
+CL_Button::CL_Button(
+	const std::string &amp;text,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(parent, style), impl(0)
+{
+	impl = new CL_Button_Generic(this, text, false);
+	get_style_manager()-&gt;connect_styles(&quot;button&quot;, this);
+	find_preferred_size();
+}
+
+CL_Button::CL_Button(
+	const CL_Rect &amp;pos,
+	const std::string &amp;text,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(pos, parent, style), impl(0)
+{
+	impl = new CL_Button_Generic(this, text, false);
+	get_style_manager()-&gt;connect_styles(&quot;button&quot;, this);
+}
+
+CL_Button::CL_Button(
+	const CL_Point &amp;pos,
+	const std::string &amp;text,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(CL_Rect(pos.x, pos.y, 0, 0), parent, style), impl(0)
+{
+	impl = new CL_Button_Generic(this, text, false);
+	get_style_manager()-&gt;connect_styles(&quot;button&quot;, this);
+	find_preferred_size();
+}
+
+CL_Button::CL_Button(
+	const CL_Rect &amp;pos,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(pos, parent, style), impl(0)
+{
+	impl = new CL_Button_Generic(this, std::string(), false);
+	get_style_manager()-&gt;connect_styles(&quot;button&quot;, this);
+}
+
+CL_Button::CL_Button(
+	const CL_Point &amp;pos,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(CL_Rect(pos.x, pos.y, 0, 0), parent, style), impl(0)
+{
+	impl = new CL_Button_Generic(this, std::string(), false);
+	get_style_manager()-&gt;connect_styles(&quot;button&quot;, this);
+	find_preferred_size();
+}
+
+CL_Button::~CL_Button()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+const std::string &amp;CL_Button::get_text() const
+{
+	return impl-&gt;text;
+}
+
+bool CL_Button::is_toggle_button() const
+{
+	return impl-&gt;toggle_mode;
+}
+
+bool CL_Button::is_down() const
+{
+	return impl-&gt;toggled;
+}
+
+bool CL_Button::is_drawn_down() const
+{
+	return impl-&gt;visually_down;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_Button::set_text(const std::string &amp;text)
+{
+	impl-&gt;text = text;
+}
+
+void CL_Button::set_toggle_mode(bool toggle)
+{
+	impl-&gt;toggle_mode = toggle;
+}
+
+void CL_Button::set_down(bool enable)
+{
+	impl-&gt;toggled = enable;
+	impl-&gt;visually_down = enable;
+}
+
+void CL_Button::toggle()
+{
+	impl-&gt;toggled = !impl-&gt;toggled;
+	impl-&gt;visually_down = impl-&gt;toggled;
+	impl-&gt;sig_toggled(impl-&gt;toggled);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Signals:
+
+CL_Signal_v1&lt;bool&gt; &amp;CL_Button::sig_toggled()
+{
+	return impl-&gt;sig_toggled;
+}
+
+CL_Signal_v0 &amp;CL_Button::sig_clicked()
+{
+	return impl-&gt;sig_clicked;
+}
+
+CL_Signal_v0 &amp;CL_Button::sig_pressed()
+{
+	return impl-&gt;sig_pressed;
+}
+
+CL_Signal_v0 &amp;CL_Button::sig_released()
+{
+	return impl-&gt;sig_released;
+}

Added: trunk/clanlib/GUI/button_generic.cpp
===================================================================
--- trunk/clanlib/GUI/button_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/button_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,158 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;button_generic.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;API/Display/keys.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_Button_Generic::CL_Button_Generic(
+	CL_Button *self,
+	const std::string &amp;text,
+	bool toggle_mode)
+:
+	text(text),
+	toggle_mode(toggle_mode),
+	toggled(false),
+	visually_down(false),
+	pressed_by(NOT_PRESSED),
+	button(self)
+{
+	slots.connect(button-&gt;sig_set_options(), this, &amp;CL_Button_Generic::on_set_options);
+	slots.connect(button-&gt;sig_input_down(), this, &amp;CL_Button_Generic::on_input_down);
+	slots.connect(button-&gt;sig_input_up(), this, &amp;CL_Button_Generic::on_input_up);
+	slots.connect(button-&gt;sig_mouse_move(), this, &amp;CL_Button_Generic::on_mouse_move);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_Button_Generic::on_set_options(const CL_DomElement &amp;options)
+{
+	if (options.has_attribute(&quot;text&quot;)) text = options.get_attribute(&quot;text&quot;);
+	if (options.has_attribute(&quot;toggled&quot;)) toggled = CL_String::to_bool(options.get_attribute(&quot;toggled&quot;));
+	if (options.has_attribute(&quot;togglemode&quot;)) toggle_mode = CL_String::to_bool(options.get_attribute(&quot;togglemode&quot;));
+
+	visually_down = toggled;
+}
+
+void CL_Button_Generic::on_mouse_move(const CL_InputEvent &amp;key)
+{
+	if (pressed_by != PRESSED_BY_MOUSE)
+		return;
+	if(!button-&gt;is_mouse_captured())
+		return;
+
+	if(button-&gt;has_mouse_over())
+		visually_down = !toggled;
+	else
+		visually_down = toggled;
+}
+
+void CL_Button_Generic::on_input_down(const CL_InputEvent &amp;key)
+{
+	if (pressed_by != NOT_PRESSED)
+		return;
+
+	if(button-&gt;is_mouse_captured())
+		return;
+
+	switch(key.id)
+	{
+	case CL_MOUSE_LEFT:
+		pressed_by = PRESSED_BY_MOUSE;
+		break;
+	case CL_KEY_SPACE:
+	case CL_KEY_ENTER:
+		pressed_by = PRESSED_BY_KEYBOARD;
+		break;
+	default:
+		return;
+	}
+
+	sig_pressed();
+	button-&gt;capture_mouse();
+
+	visually_down = !visually_down;
+}
+
+void CL_Button_Generic::on_input_up(const CL_InputEvent &amp;key)
+{
+	if (pressed_by == NOT_PRESSED)
+		return;
+	
+	if (button-&gt;is_mouse_captured() == false)
+		return;
+
+	switch(pressed_by)
+	{
+	case PRESSED_BY_MOUSE:
+		{
+			if (key.id != CL_MOUSE_LEFT)
+				return;
+
+			button-&gt;release_mouse();
+			sig_released();
+			bool mouse_over = button-&gt;has_mouse_over();
+			if (mouse_over)
+			{
+				if (toggle_mode)
+				{
+					toggled = !toggled;
+					sig_toggled(toggled);
+				}
+
+				sig_clicked();
+			}
+		}
+		break;
+	case PRESSED_BY_KEYBOARD:
+		{
+			if (key.id != CL_KEY_SPACE &amp;&amp; key.id != CL_KEY_ENTER)
+				return;
+			button-&gt;release_mouse();
+			if (toggle_mode)
+			{
+				toggled = !toggled;
+				sig_toggled(toggled);
+			}
+			sig_clicked();
+		}
+		break;
+	default:
+		return;
+	}
+
+	pressed_by = NOT_PRESSED;
+
+	visually_down = toggled;
+}

Added: trunk/clanlib/GUI/button_generic.h
===================================================================
--- trunk/clanlib/GUI/button_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/button_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,88 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_button_generic
+#define header_button_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/GUI/button.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+
+class CL_Button_Generic
+{
+private:
+	enum PressType {
+		NOT_PRESSED,
+		PRESSED_BY_KEYBOARD,
+		PRESSED_BY_MOUSE
+	};
+//! Construction:
+public:
+	CL_Button_Generic(
+		CL_Button *self,
+		const std::string &amp;text,
+		bool toggle_mode);
+
+	~CL_Button_Generic() {};
+
+//! Attributes:
+public:
+	std::string text;
+	bool toggle_mode;
+
+	bool toggled;
+	bool visually_down;
+
+	PressType pressed_by;
+
+//! Signals:
+public:
+	CL_Signal_v1&lt;bool&gt; sig_toggled;
+	CL_Signal_v0 sig_clicked;
+	CL_Signal_v0 sig_pressed;
+	CL_Signal_v0 sig_released;
+
+//! Callbacks:
+private:
+	void on_set_options(const CL_DomElement &amp;options);
+	void on_input_down(const CL_InputEvent &amp;key);
+	void on_input_up(const CL_InputEvent &amp;key);
+	void on_mouse_move(const CL_InputEvent &amp;key);
+
+//! Implementation:
+private:
+	CL_Button *button;
+
+	CL_SlotContainer slots;
+};  
+
+#endif

Added: trunk/clanlib/GUI/checkbox.cpp
===================================================================
--- trunk/clanlib/GUI/checkbox.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/checkbox.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,90 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;../API/GUI/checkbox.h&quot;
+#include &quot;../API/GUI/component.h&quot;
+#include &quot;../API/GUI/stylemanager.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_CheckBox::CL_CheckBox(
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Button(parent, style)
+{
+	set_toggle_mode();
+	get_style_manager()-&gt;connect_styles(&quot;checkbox&quot;, this);
+	find_preferred_size();
+}
+
+CL_CheckBox::CL_CheckBox(
+	const std::string &amp;text,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Button(text, parent, style)
+{
+	set_toggle_mode();
+	get_style_manager()-&gt;connect_styles(&quot;checkbox&quot;, this);
+	find_preferred_size();
+}
+
+CL_CheckBox::CL_CheckBox(
+	const CL_Point &amp;pos,
+	const std::string &amp;text,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Button(pos, text, parent, style)
+{
+	set_toggle_mode();
+	get_style_manager()-&gt;connect_styles(&quot;checkbox&quot;, this);
+	find_preferred_size();
+}
+
+CL_CheckBox::~CL_CheckBox()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+bool CL_CheckBox::is_checked() const
+{
+	return is_down();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_CheckBox::set_checked(bool check)
+{
+	set_down(check);
+}

Added: trunk/clanlib/GUI/component.cpp
===================================================================
--- trunk/clanlib/GUI/component.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/component.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,926 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/Core/System/event_trigger.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/Core/System/log.h&quot;
+#include &quot;API/GUI/gui_manager.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;component_generic.h&quot;
+#include &quot;component_manager_generic.h&quot;
+#include &lt;vector&gt;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_Component::CL_Component(
+	CL_Component *parent,
+	CL_StyleManager *style)
+:
+	impl(NULL)
+{
+	impl = new CL_Component_Generic(this, CL_Rect(0,0,0,0), parent, style);
+
+	if (get_style_manager() != NULL)
+		get_style_manager()-&gt;connect_styles(&quot;component&quot;, this);
+
+	if (parent != NULL) parent-&gt;add_child(this, true); //SETH: Changed delete child to true
+}
+
+CL_Component::CL_Component(const CL_Rect &amp;pos, CL_Component *parent, CL_StyleManager *style)
+: impl(NULL)
+{
+	impl = new CL_Component_Generic(this, pos, parent, style);
+
+	if (get_style_manager() != NULL)
+		get_style_manager()-&gt;connect_styles(&quot;component&quot;, this);
+
+	if (parent != NULL) parent-&gt;add_child(this, true); //SETH: Changed delete child to true);
+}
+
+CL_Component::~CL_Component()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+CL_Component *CL_Component::get_client_area() const
+{
+	return impl-&gt;client_area;
+}
+
+CL_Component *CL_Component::get_parent() const
+{
+	return impl-&gt;parent;
+}
+
+CL_Component *CL_Component::get_root_parent()
+{
+	if(impl-&gt;parent)
+		return impl-&gt;parent-&gt;get_root_parent();
+	else
+		return this;
+}
+
+CL_GUIManager *CL_Component::get_gui_manager() const
+{
+	return impl-&gt;get_gui_manager();
+}
+
+CL_StyleManager *CL_Component::get_style_manager() const
+{
+	return impl-&gt;style_manager;
+}
+
+int CL_Component::get_width() const
+{
+	return impl-&gt;position.right - impl-&gt;position.left;
+}
+
+int CL_Component::get_height() const
+{
+	return impl-&gt;position.bottom - impl-&gt;position.top;
+}
+
+int CL_Component::get_screen_x() const
+{
+	if (impl-&gt;parent == NULL)
+	{
+		return impl-&gt;position.left;
+	}
+	else
+	{
+		int x = impl-&gt;parent-&gt;get_screen_x();
+		return x + impl-&gt;position.left;
+	}
+}
+
+int CL_Component::get_screen_y() const
+{
+	if (impl-&gt;parent == NULL)
+	{
+		return impl-&gt;position.top;
+	}
+	else
+	{
+		int y = impl-&gt;parent-&gt;get_screen_y();
+		return y + impl-&gt;position.top;
+	}
+}
+
+int CL_Component::get_client_x() const
+{
+	return impl-&gt;position.left;
+}
+
+int CL_Component::get_client_y() const
+{
+	return impl-&gt;position.top;
+}
+
+CL_Rect CL_Component::get_screen_rect() const
+{
+	if (impl-&gt;parent == NULL)
+	{
+		return impl-&gt;position;
+	}
+	else
+	{
+		CL_Rect r = impl-&gt;parent-&gt;get_screen_rect();
+
+		return CL_Rect(
+			r.left + impl-&gt;position.left, 
+			r.top + impl-&gt;position.top,
+			r.left + impl-&gt;position.right, 
+			r.top + impl-&gt;position.bottom);
+	}
+}
+
+CL_Rect CL_Component::client_to_screen(const CL_Rect &amp; rect)
+{
+	int x = get_screen_x();
+	int y = get_screen_y();
+
+	return CL_Rect(rect.left + x, rect.top + y, rect.right + x, rect.bottom + y);
+}
+
+CL_Point CL_Component::client_to_screen(const CL_Point &amp; point)
+{
+	int x = get_screen_x();
+	int y = get_screen_y();
+
+	return CL_Point(x + point.x, y + point.y);
+}
+
+CL_Rect CL_Component::screen_to_client(const CL_Rect &amp; rect)
+{
+	int x = get_screen_x();
+	int y = get_screen_y();
+
+	return CL_Rect(rect.left - x, rect.top - y, rect.right - x, rect.bottom - y);
+}
+
+CL_Point CL_Component::screen_to_client(const CL_Point &amp; point)
+{
+	int x = get_screen_x();
+	int y = get_screen_y();
+
+	return CL_Point(point.x - x, point.y - y);
+}
+
+const CL_Rect &amp;CL_Component::get_position() const
+{
+	return impl-&gt;position;
+}
+
+//isn't there a better global place to put all these?
+#define cl_min(a,b) ((a &lt; b) ? a : b)
+#define cl_max(a,b) ((a &gt; b) ? a : b)
+
+CL_Rect CL_Component::get_position_with_children()
+{
+	CL_Rect r;
+	CL_Rect rChildren = get_children_rect();
+		
+	r.top = cl_min (impl-&gt;position.top, rChildren.top + impl-&gt;position.top);
+	r.left = cl_min (impl-&gt;position.left, rChildren.left + impl-&gt;position.left);
+
+	r.right = cl_max(impl-&gt;position.right, rChildren.right + impl-&gt;position.left);
+	r.bottom = cl_max(impl-&gt;position.bottom, rChildren.bottom + impl-&gt;position.top);
+
+	return r;
+}
+
+CL_Size CL_Component::get_minimum_size() const
+{
+	return impl-&gt;minimum_size;
+}
+
+CL_Size CL_Component::get_maximum_size() const
+{
+	return impl-&gt;maximum_size;
+}
+
+CL_Size CL_Component::get_preferred_size() const
+{
+	return impl-&gt;preferred_size;
+}
+
+const CL_LayoutPolicy &amp;CL_Component::get_vertical_policy() const
+{
+	return impl-&gt;vertical_policy;
+}
+
+const CL_LayoutPolicy &amp;CL_Component::get_horizontal_policy() const
+{
+	return impl-&gt;horizontal_policy;
+}
+
+const CL_Layout &amp;CL_Component::get_layout() const
+{
+	return impl-&gt;layout;
+}
+
+bool CL_Component::get_event_passing() const
+{
+	return impl-&gt;event_passing;
+}
+
+bool CL_Component::has_child(CL_Component *component) const
+{
+	for (
+		std::list&lt;CL_Component *&gt;::iterator it = impl-&gt;children.begin();
+		it != impl-&gt;children.end();
+		it++)
+	{
+		if ((*it) == component || (*it)-&gt;has_child(component)) return true;
+	}
+
+	return false;
+}
+
+const std::list&lt;CL_Component *&gt; &amp;CL_Component::get_children() const
+{
+	return impl-&gt;children;
+}
+
+CL_Rect CL_Component::get_children_rect() const
+{
+	CL_Rect rect(0, 0, 0, 0);
+	
+	for (
+		std::list&lt;CL_Component *&gt;::iterator it = impl-&gt;children.begin();
+		it != impl-&gt;children.end();
+		it++)
+	{
+		
+		CL_Component *comp = (*it);
+
+	   if (!comp-&gt;is_visible(false)) continue;
+	   if (!comp-&gt;is_focusable()) continue;
+
+		CL_Rect childrect = comp-&gt;get_position_with_children();
+
+		if(childrect.left &lt; rect.left)
+			rect.left = childrect.left;
+		if(childrect.top &lt; rect.top)
+			rect.top = childrect.top;
+		if(childrect.right &gt; rect.right)
+			rect.right = childrect.right;
+		if(childrect.bottom &gt; rect.bottom)
+			rect.bottom = childrect.bottom;
+	}
+
+	return rect;
+}
+
+CL_Component *CL_Component::get_component_at(int pos_x, int pos_y)
+{
+	std::list&lt;CL_Component *&gt;::iterator it;
+	for (it = impl-&gt;children.begin(); it != impl-&gt;children.end(); it++)
+	{
+		CL_Component *cur_component = (*it);
+
+		if(cur_component-&gt;is_visible(false))
+		{
+			const CL_Rect r = cur_component-&gt;get_position_with_children();
+
+			if (pos_x &gt;= r.left &amp;&amp; pos_x &lt; r.right &amp;&amp;
+				pos_y &gt;= r.top &amp;&amp; pos_y &lt; r.bottom)
+			{
+				return cur_component-&gt;get_component_at(pos_x - r.left, pos_y - r.top);
+			}
+		}
+	}
+
+	return this;
+}
+
+CL_Component *CL_Component::get_focus() const
+{
+	return get_gui_manager()-&gt;get_focus();
+}
+
+bool CL_Component::has_focus() const
+{
+	return get_focus() == this;
+}
+
+bool CL_Component::is_focusable() const
+{
+	return impl-&gt;focusable;
+}
+
+bool CL_Component::has_mouse_over() const
+{
+	return impl-&gt;mouse_over;
+}
+
+bool CL_Component::is_visible(bool check_parents) const
+{
+	if(check_parents)
+	{
+		if(impl-&gt;visible == false)
+			return false;
+		if(impl-&gt;parent)
+			return impl-&gt;parent-&gt;is_visible(true);
+		else
+			return impl-&gt;visible;
+	}
+	else
+		return impl-&gt;visible;
+}
+
+bool CL_Component::is_enabled(bool check_parents) const
+{
+	if(check_parents)
+	{
+		if(impl-&gt;enabled == false)
+			return false;
+		if(impl-&gt;parent)
+			return impl-&gt;parent-&gt;is_enabled(true);
+		else
+			return impl-&gt;enabled;
+	}
+	else
+		return impl-&gt;enabled;
+}
+
+bool CL_Component::is_mouse_captured() const
+{
+	CL_GUIManager *gui = get_gui_manager();
+	if (gui != NULL)
+	{
+		return gui-&gt;get_capture() == this;
+	}
+	return false;
+}
+
+bool CL_Component::is_modal() const
+{
+	CL_GUIManager *gui = get_gui_manager();
+	if (gui != NULL)
+	{
+		return gui-&gt;get_modal_component() == this;
+	}
+	return false;
+}
+	
+bool CL_Component::has_modal_parent() const
+{
+	CL_GUIManager *gui = get_gui_manager();
+	if (gui != NULL)
+	{
+		if (impl-&gt;parent)
+			if (impl-&gt;parent == gui-&gt;get_modal_component())
+				return true;
+		else
+			return impl-&gt;parent-&gt;has_modal_parent();
+	}
+	return false;
+}
+
+int CL_Component::get_tab_id() const
+{
+	return impl-&gt;tab_id;
+}
+
+CL_ComponentStyle *CL_Component::get_style() const
+{
+	return impl-&gt;style;
+}
+
+bool CL_Component::is_topmost() const
+{
+	return impl-&gt;topmost_flag;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_Component::set_tab_id(int id)
+{
+	impl-&gt;tab_id = id;
+}
+
+void CL_Component::set_position(const CL_Rect &amp;new_pos)
+{
+	int old_x = impl-&gt;position.left;
+	int old_y = impl-&gt;position.top;
+
+	int old_width = get_width();
+	int old_height = get_height();
+
+	impl-&gt;position = new_pos;
+	impl-&gt;layout.set_position(CL_Rect(CL_Point(0,0), impl-&gt;position.get_size()));
+
+	if(old_x != impl-&gt;position.left || old_y != impl-&gt;position.top)
+		impl-&gt;sig_move(old_x, old_y);
+	if(old_width != get_width() || old_height != get_height())
+		impl-&gt;sig_resize(old_width, old_height);
+
+	update();
+}
+
+void CL_Component::set_position(int new_x, int new_y)
+{
+	int old_x = impl-&gt;position.left;
+	int old_y = impl-&gt;position.top;
+
+	impl-&gt;position.right = get_width() + new_x;
+	impl-&gt;position.bottom = get_height() + new_y;
+	impl-&gt;position.left = new_x;
+	impl-&gt;position.top = new_y;
+	impl-&gt;layout.set_position(CL_Rect(CL_Point(0,0), impl-&gt;position.get_size()));
+
+	if(old_x != impl-&gt;position.left || old_y != impl-&gt;position.top)
+		impl-&gt;sig_move(old_x, old_y);
+
+	update();
+}
+
+void CL_Component::set_size(int new_width, int new_height)
+{
+	int old_width = get_width();
+	int old_height = get_height();
+
+	impl-&gt;position.right = impl-&gt;position.left + new_width;
+	impl-&gt;position.bottom = impl-&gt;position.top + new_height;
+	impl-&gt;layout.set_position(CL_Rect(CL_Point(0,0), impl-&gt;position.get_size()));
+
+	if(old_width != get_width() || old_height != get_height())
+		impl-&gt;sig_resize(old_width, old_height);
+
+	update();
+}
+
+void CL_Component::set_width(int width)
+{
+	int old_width = get_width();
+
+	impl-&gt;position.right = impl-&gt;position.left + width;
+	impl-&gt;layout.set_position(CL_Rect(CL_Point(0,0), impl-&gt;position.get_size()));
+
+	if(old_width != get_width())
+		impl-&gt;sig_resize(old_width, get_height());
+
+	update();
+}
+
+void CL_Component::set_height(int height)
+{
+	int old_height = get_height();
+
+	impl-&gt;position.bottom = impl-&gt;position.top + height;
+	impl-&gt;layout.set_position(CL_Rect(CL_Point(0,0), impl-&gt;position.get_size()));
+
+	if(old_height != get_height())
+		impl-&gt;sig_resize(get_width(), old_height);
+
+	update();
+}
+
+void CL_Component::set_minimum_size(const CL_Size &amp;size)
+{
+	impl-&gt;minimum_size = size;
+
+	update();
+}
+
+void CL_Component::set_maximum_size(const CL_Size &amp;size)
+{
+	impl-&gt;maximum_size = size;
+
+	update();
+}
+
+void CL_Component::set_preferred_size(const CL_Size &amp;size)
+{
+	impl-&gt;preferred_size = size;
+
+	update();
+}
+
+void CL_Component::set_vertical_policy(const CL_LayoutPolicy &amp;policy)
+{
+	impl-&gt;vertical_policy = policy;
+}
+
+void CL_Component::set_horizontal_policy(const CL_LayoutPolicy &amp;policy)
+{
+	impl-&gt;horizontal_policy = policy;
+}
+
+void CL_Component::set_layout(const CL_Layout &amp;layout)
+{
+	impl-&gt;layout = layout;
+}
+
+void CL_Component::set_event_passing(bool enable)
+{
+	impl-&gt;event_passing = enable;
+}
+
+void CL_Component::set_parent(CL_Component *parent)
+{
+	impl-&gt;parent = parent;
+}
+
+void CL_Component::set_gui_manager(CL_GUIManager *gui)
+{
+	impl-&gt;gui = gui;
+}
+
+void CL_Component::show(bool show)
+{
+	impl-&gt;visible = show;
+	update();
+}
+
+void CL_Component::enable(bool enable)
+{
+	impl-&gt;enabled = enable;
+	update();
+}
+
+void CL_Component::set_focusable(bool focusable)
+{
+	impl-&gt;focusable = focusable;
+	update();
+}
+
+void CL_Component::set_focus()
+{
+	get_gui_manager()-&gt;set_focus(this);
+}
+
+void CL_Component::raise()
+{
+	
+	if (impl-&gt;parent == 0) return;
+
+	std::list&lt;CL_Component *&gt; &amp;children = impl-&gt;parent-&gt;impl-&gt;children;
+	children.remove(this);
+	if (impl-&gt;topmost_flag)
+	{
+		children.push_front(this);
+	}
+	else
+	{
+		std::list&lt;CL_Component *&gt;::iterator it;
+		for (it = children.begin(); it != children.end(); ++it)
+		{
+			CL_Component *cur = *it;
+			if (cur-&gt;impl-&gt;topmost_flag == false)
+			{
+				children.insert(it, this);
+				return;
+			}
+		}
+		children.push_back(this);
+	}
+
+	update();
+}
+
+void CL_Component::lower()
+{
+	
+	if (impl-&gt;parent == 0) return;
+
+	std::list&lt;CL_Component *&gt; &amp;children = impl-&gt;parent-&gt;impl-&gt;children;
+	children.remove(this);
+	if (impl-&gt;topmost_flag)
+	{
+		std::list&lt;CL_Component *&gt;::iterator it;
+		for (it = children.begin(); it != children.end(); ++it)
+		{
+			CL_Component *cur = *it;
+			if (cur-&gt;impl-&gt;topmost_flag == false)
+			{
+				children.insert(it, this);
+				return;
+			}
+		}
+		children.push_back(this);
+	}
+	else
+	{
+		children.push_back(this);
+	}
+
+	update();
+}
+
+void CL_Component::capture_mouse()
+{
+	CL_GUIManager *gui = get_gui_manager();
+	if (gui != NULL)
+	{
+		gui-&gt;gui_capture_mouse(this);
+	}
+}
+
+void CL_Component::release_mouse()
+{
+	CL_GUIManager *gui = get_gui_manager();
+	if (gui != NULL)
+	{
+		gui-&gt;gui_release_mouse();
+	}
+}
+
+void CL_Component::update()
+{
+	CL_GUIManager *gui_manager = get_gui_manager();
+	if (gui_manager &amp;&amp; !gui_manager-&gt;is_shutting_down()) gui_manager-&gt;get_update_trigger()-&gt;set_flag();
+}
+
+void CL_Component::paint()
+{
+	impl-&gt;sig_begin_paint();
+	impl-&gt;sig_paint();
+	impl-&gt;sig_paint_children();
+	impl-&gt;sig_end_paint();
+}
+
+void CL_Component::run()
+{
+	update();
+	get_gui_manager()-&gt;run(this);
+}
+
+void CL_Component::quit()
+{
+	get_gui_manager()-&gt;quit();
+}
+
+void CL_Component::close()
+{
+	impl-&gt;sig_close();
+	update();
+}
+
+void CL_Component::add_child(CL_Component *child, bool delete_child)
+{
+	if(has_child(child))
+		return;
+
+	impl-&gt;sig_child_before_add(child);
+
+	child-&gt;set_parent(this);
+
+	impl-&gt;children.push_front(child);
+	if (!child-&gt;is_topmost()) child-&gt;raise();
+
+	if (delete_child)
+		impl-&gt;delete_children.push_front(child);
+
+	impl-&gt;sig_child_add(child);
+
+	update();
+}
+
+void CL_Component::delete_child (CL_Component *child)
+{
+	if (!has_child (child))
+		return;
+
+	impl-&gt;delete_children.push_front(child);
+}
+
+void CL_Component::remove_child(CL_Component *child)
+{
+	impl-&gt;sig_child_before_remove(child);
+
+	child-&gt;impl-&gt;remove_focus();
+	
+	child-&gt;set_parent(NULL);
+
+	impl-&gt;children.remove(child);
+	impl-&gt;delete_children.remove(child);
+
+	impl-&gt;sig_child_remove(child);
+
+	update();
+}
+
+void CL_Component::set_style(CL_ComponentStyle *style, bool delete_style)
+{
+	if (impl-&gt;delete_style &amp;&amp; NULL != impl-&gt;style)
+		delete impl-&gt;style;
+
+	impl-&gt;delete_style = delete_style;
+	impl-&gt;style = style;
+}
+
+void CL_Component::find_preferred_size()
+{
+	impl-&gt;find_preferred_size();
+	update();
+}
+
+CL_Component *CL_Component::find_tab_id(int tab_id)
+{
+	if (impl-&gt;tab_id == tab_id) return this;
+
+	std::list&lt;CL_Component *&gt;::iterator it;
+	for (it = impl-&gt;children.begin(); it != impl-&gt;children.end(); it++)
+	{
+		CL_Component *comp = (*it)-&gt;find_tab_id(tab_id);
+		if (comp) return comp;
+	}
+	return 0;
+}
+
+void CL_Component::set_client_area(CL_Component *component)
+{
+	impl-&gt;client_area = component;
+	update();
+}
+
+void CL_Component::set_topmost_flag(bool topmost)
+{
+	if (impl-&gt;topmost_flag == topmost) return;
+
+	impl-&gt;topmost_flag = topmost;
+	if (topmost) lower();
+	else raise();
+}
+
+void CL_Component::set_clipping(bool enable)
+{
+	impl-&gt;clipping = enable;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Signals:
+
+CL_Signal_v1&lt;const CL_DomElement &amp;&gt; &amp;CL_Component::sig_set_options()
+{
+	return impl-&gt;sig_set_options;
+}
+
+CL_Signal_v0 &amp;CL_Component::sig_paint()
+{
+	return impl-&gt;sig_paint;
+}
+
+CL_Signal_v0 &amp;CL_Component::sig_paint_children()
+{
+	return impl-&gt;sig_paint_children;
+}
+
+CL_Signal_v0 &amp;CL_Component::sig_begin_paint()
+{
+	return impl-&gt;sig_begin_paint;
+}
+
+CL_Signal_v0 &amp;CL_Component::sig_end_paint()
+{
+	return impl-&gt;sig_end_paint;
+}
+
+CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;CL_Component::sig_input_down()
+{
+	return impl-&gt;sig_input_down;
+}
+
+CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;CL_Component::sig_input_up()
+{
+	return impl-&gt;sig_input_up;
+}
+
+CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;CL_Component::sig_key_down()
+{
+	return impl-&gt;sig_key_down;
+}
+
+CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;CL_Component::sig_key_up()
+{
+	return impl-&gt;sig_key_up;
+}
+
+CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;CL_Component::sig_mouse_down()
+{
+	return impl-&gt;sig_mouse_down;
+}
+
+CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;CL_Component::sig_mouse_up()
+{
+	return impl-&gt;sig_mouse_up;
+}
+
+CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;CL_Component::sig_mouse_dblclk()
+{
+	return impl-&gt;sig_mouse_dblclk;
+}
+
+CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; &amp;CL_Component::sig_mouse_move()
+{
+	return impl-&gt;sig_mouse_move;
+}
+
+CL_Signal_v0 &amp;CL_Component::sig_mouse_enter()
+{
+	return impl-&gt;sig_mouse_enter;
+}
+
+CL_Signal_v0 &amp;CL_Component::sig_mouse_leave()
+{
+	return impl-&gt;sig_mouse_leave;
+}
+
+CL_Signal_v0 &amp;CL_Component::sig_got_focus()
+{
+	return impl-&gt;sig_got_focus;
+}
+
+CL_Signal_v0 &amp;CL_Component::sig_lost_focus()
+{
+	return impl-&gt;sig_lost_focus;
+}
+
+CL_Signal_v0 &amp;CL_Component::sig_close()
+{
+	return impl-&gt;sig_close;
+}
+
+CL_Signal_v2&lt;int, int&gt; &amp;CL_Component::sig_resize()
+{
+	return impl-&gt;sig_resize;
+}
+
+CL_Signal_v2&lt;int, int&gt; &amp;CL_Component::sig_move()
+{
+	return impl-&gt;sig_move;
+}
+
+CL_Signal_v2&lt;int &amp;, int &amp;&gt; &amp;CL_Component::sig_transform_coords()
+{
+	return impl-&gt;sig_transform_coords;
+}
+
+CL_Signal_v1&lt;CL_Component *&gt; &amp;CL_Component::sig_child_add()
+{
+	return impl-&gt;sig_child_add;
+}
+
+CL_Signal_v1&lt;CL_Component *&gt; &amp;CL_Component::sig_child_remove()
+{
+	return impl-&gt;sig_child_remove;
+}
+
+CL_Signal_v1&lt;CL_Component *&gt; &amp;CL_Component::sig_child_before_add()
+{
+	return impl-&gt;sig_child_before_add;
+}
+
+CL_Signal_v1&lt;CL_Component *&gt; &amp;CL_Component::sig_child_before_remove()
+{
+	return impl-&gt;sig_child_before_remove;
+}
+
+CL_Signal_v1&lt;CL_Size &amp;&gt; &amp;CL_Component::sig_get_minimum_size()
+{
+	return impl-&gt;sig_get_minimum_size;
+}
+
+CL_Signal_v1&lt;CL_Size &amp;&gt; &amp;CL_Component::sig_get_maximum_size()
+{
+	return impl-&gt;sig_get_maximum_size;
+}
+
+CL_Signal_v1&lt;CL_Size &amp;&gt; &amp;CL_Component::sig_get_preferred_size()
+{
+	return impl-&gt;sig_get_preferred_size;
+}

Added: trunk/clanlib/GUI/component_generic.cpp
===================================================================
--- trunk/clanlib/GUI/component_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/component_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,297 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifdef _MSC_VER
+#pragma warning (disable:4355) // 'this' used in base member initializer list
+#endif
+
+#include &quot;precomp.h&quot;
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Core/System/log.h&quot;
+#include &quot;API/GUI/component_style.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;component_generic.h&quot;
+#include &quot;gui_manager_generic.h&quot;
+
+CL_Component_Generic::CL_Component_Generic(
+	CL_Component *_owner,
+	const CL_Rect &amp;pos,
+	CL_Component *_parent,
+	CL_StyleManager *style)
+:
+	owner(_owner),
+	parent(_parent),
+	client_area(_owner),
+	style_manager(style),
+	position(pos),
+	minimum_size(-1,-1),
+	maximum_size(-1,-1),
+	preferred_size(-1,-1),
+	vertical_policy(layout_expanding),
+	horizontal_policy(layout_expanding),
+	gui(NULL),
+	focusable(true),
+	visible(true),
+	enabled(true),
+	mouse_over(false),
+	event_passing(true),
+	topmost_flag(false),
+	clipping(false),
+	tab_id(-1),
+	style(NULL), delete_style(false)
+{
+	if (style_manager == NULL &amp;&amp; parent)
+		style_manager = parent-&gt;get_style_manager();
+
+	slots.connect(sig_set_options, this, &amp;CL_Component_Generic::on_set_options);
+	slots.connect(sig_begin_paint, this, &amp;CL_Component_Generic::begin_paint);
+	slots.connect(sig_paint_children, this, &amp;CL_Component_Generic::paint_children);
+	slots.connect(sig_end_paint, this, &amp;CL_Component_Generic::end_paint);
+	slots.connect(sig_input_down, this, &amp;CL_Component_Generic::on_input_down);
+	slots.connect(sig_input_up, this, &amp;CL_Component_Generic::on_input_up);
+	slots.connect(sig_key_down, this, &amp;CL_Component_Generic::on_key_down);
+	slots.connect(sig_key_up, this, &amp;CL_Component_Generic::on_key_up);
+	slots.connect(sig_mouse_down, this, &amp;CL_Component_Generic::on_mouse_down);
+	slots.connect(sig_mouse_up, this, &amp;CL_Component_Generic::on_mouse_up);
+	slots.connect(sig_mouse_dblclk, this, &amp;CL_Component_Generic::on_mouse_dblclk);
+	slots.connect(sig_mouse_move, this, &amp;CL_Component_Generic::on_mouse_move);
+	slots.connect(sig_close, this, &amp;CL_Component_Generic::on_close);
+}
+
+CL_Component_Generic::~CL_Component_Generic()
+{
+	// If we got a parent, disconnect ourselves from its lists of children:
+	if (parent)
+	{
+		parent-&gt;impl-&gt;children.remove(owner);
+		parent-&gt;impl-&gt;delete_children.remove(owner);
+		parent-&gt;update();
+	}
+
+	// Clean up component style controlled by us.
+	if(delete_style)
+		delete style;
+
+	// Delete all children marked for deletion.
+	while (!delete_children.empty())
+	{
+		CL_Component *child = delete_children.front();
+		delete_children.pop_front();
+		delete child;
+	}
+
+	remove_focus();
+}
+
+CL_GUIManager *CL_Component_Generic::get_gui_manager() const
+{
+	if (gui != NULL) return gui;
+	if (parent != NULL) return parent-&gt;get_gui_manager();
+	return NULL;
+}
+
+void CL_Component_Generic::remove_focus()
+{
+	// Make sure component doesn't have the focus:
+	CL_GUIManager *gui = owner-&gt;get_gui_manager();
+	if (gui &amp;&amp; gui != owner &amp;&amp; gui-&gt;impl) gui-&gt;impl-&gt;component_deleted(owner);
+}
+
+void CL_Component_Generic::find_preferred_size()
+{
+	CL_Size size(0,0);
+	owner-&gt;sig_get_preferred_size()(size);
+	preferred_size = size;
+	owner-&gt;set_size(size.width, size.height);
+}
+
+void CL_Component_Generic::on_set_options(const CL_DomElement &amp;options)
+{
+	int x = 0, y = 0, width = 0, height = 0;
+
+	if (options.has_attribute(&quot;x&quot;)) x = CL_String::to_int(options.get_attribute(&quot;x&quot;));
+	if (options.has_attribute(&quot;y&quot;)) y = CL_String::to_int(options.get_attribute(&quot;y&quot;));
+	if (options.has_attribute(&quot;width&quot;))  width = CL_String::to_int(options.get_attribute(&quot;width&quot;));
+	if (options.has_attribute(&quot;height&quot;)) height = CL_String::to_int(options.get_attribute(&quot;height&quot;));
+
+	owner-&gt;set_position(CL_Rect(x, y, x + width, y + height));
+
+	if (options.has_attribute(&quot;visible&quot;)) owner-&gt;show(CL_String::to_bool(options.get_attribute(&quot;visible&quot;)));
+	if (options.has_attribute(&quot;enabled&quot;)) owner-&gt;enable(CL_String::to_bool(options.get_attribute(&quot;enabled&quot;)));
+	if (options.has_attribute(&quot;tab_id&quot;)) owner-&gt;set_tab_id(CL_String::to_int(options.get_attribute(&quot;tab_id&quot;)));
+
+	owner-&gt;update();
+}
+
+void CL_Component_Generic::begin_paint()
+{
+	paint_clipping = false;
+	if (clipping)
+	{
+		CL_Rect r = owner-&gt;get_screen_rect();
+		CL_Display::push_cliprect(CL_Rect(r.left, r.top, r.right, r.bottom));
+		paint_clipping = true;
+	}
+}
+
+void CL_Component_Generic::paint_children()
+{
+	// we draw the children back to front because then all non-focus input
+	// will be routed to the topmost window.
+	for (
+		std::list&lt;CL_Component *&gt;::reverse_iterator it = children.rbegin();
+		it != children.rend(); it++
+		)
+	{
+		if((*it)-&gt;is_visible(false)) (*it)-&gt;paint();
+	}
+}
+
+void CL_Component_Generic::end_paint()
+{
+	if (paint_clipping)
+	{
+		CL_Display::pop_cliprect();
+	}
+	paint_clipping = false;
+}
+
+void CL_Component_Generic::on_input_down(const CL_InputEvent &amp;key)
+{
+	if (event_passing == false) return;
+
+	CL_InputEvent translated_key = key;
+	translated_key.mouse_pos.x += position.left;
+	translated_key.mouse_pos.y += position.top;
+	if (parent) parent-&gt;sig_input_down()(translated_key);
+
+	owner-&gt;update();
+}
+
+void CL_Component_Generic::on_input_up(const CL_InputEvent &amp;key)
+{
+	if (event_passing == false) return;
+
+	CL_InputEvent translated_key = key;
+	translated_key.mouse_pos.x += position.left;
+	translated_key.mouse_pos.y += position.top;
+	if (parent) parent-&gt;sig_input_up()(translated_key);
+
+	owner-&gt;update();
+}
+
+void CL_Component_Generic::on_key_down(const CL_InputEvent &amp;key)
+{
+	if (event_passing == false) return;
+
+	CL_InputEvent translated_key = key;
+	translated_key.mouse_pos.x += position.left;
+	translated_key.mouse_pos.y += position.top;
+	if (parent) parent-&gt;sig_key_down()(translated_key);
+
+	owner-&gt;update();
+}
+
+void CL_Component_Generic::on_key_up(const CL_InputEvent &amp;key)
+{
+	if (event_passing == false) return;
+
+	CL_InputEvent translated_key = key;
+	translated_key.mouse_pos.x += position.left;
+	translated_key.mouse_pos.y += position.top;
+	if (parent) parent-&gt;sig_key_up()(translated_key);
+
+	owner-&gt;update();
+}
+
+void CL_Component_Generic::on_mouse_down(const CL_InputEvent &amp;key)
+{
+	if (event_passing == false) return;
+
+	CL_InputEvent translated_key = key;
+	translated_key.mouse_pos.x += position.left;
+	translated_key.mouse_pos.y += position.top;
+	if (parent) parent-&gt;sig_mouse_down()(translated_key);
+
+	owner-&gt;update();
+}
+
+void CL_Component_Generic::on_mouse_up(const CL_InputEvent &amp;key)
+{
+	if (event_passing == false) return;
+
+	CL_InputEvent translated_key = key;
+	translated_key.mouse_pos.x += position.left;
+	translated_key.mouse_pos.y += position.top;
+	if (parent) parent-&gt;sig_mouse_up()(translated_key);
+
+	owner-&gt;update();
+}
+
+void CL_Component_Generic::on_mouse_dblclk(const CL_InputEvent &amp;key)
+{
+	if (event_passing == false) return;
+
+	CL_InputEvent translated_key = key;
+	translated_key.mouse_pos.x += position.left;
+	translated_key.mouse_pos.y += position.top;
+	translated_key.repeat_count = 2;
+	if (parent) parent-&gt;sig_mouse_dblclk()(translated_key);
+
+	owner-&gt;update();
+}
+
+void CL_Component_Generic::on_mouse_move(const CL_InputEvent &amp;key)
+{
+	if (event_passing == false) return;
+
+	CL_InputEvent translated_key = key;
+	translated_key.mouse_pos.x += position.left;
+	translated_key.mouse_pos.y += position.top;
+	if (parent) parent-&gt;sig_mouse_move()(translated_key);
+
+	owner-&gt;update();
+}
+
+void CL_Component_Generic::on_close()
+{
+	owner-&gt;update();
+
+	//	show(false);
+	if(get_gui_manager() != NULL)
+		get_gui_manager()-&gt;quit();
+	else
+		CL_Log::log(&quot;debug&quot;, &quot;CL_Component::close: gui manager pointer is null!&quot;);
+
+	if(parent != NULL)
+		parent-&gt;remove_child(owner);
+	else
+		CL_Log::log(&quot;debug&quot;, &quot;CL_Component::close: parent pointer is null!&quot;);
+	//	set_gui_manager(NULL);
+}

Added: trunk/clanlib/GUI/component_generic.h
===================================================================
--- trunk/clanlib/GUI/component_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/component_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,140 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_component_generic
+#define header_component_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/GUI/component.h&quot;
+#include &quot;API/GUI/layout.h&quot;
+
+class CL_Component_Generic
+{
+public:
+	CL_Component_Generic(
+		CL_Component *self,
+		const CL_Rect &amp;pos,
+		CL_Component *parent,
+		CL_StyleManager *style);
+
+	~CL_Component_Generic();
+
+	void find_preferred_size();
+
+	void remove_focus();
+
+	void begin_paint();
+	void paint_children();
+	void end_paint();
+
+	CL_GUIManager *get_gui_manager() const;
+
+	void on_set_options(const CL_DomElement &amp;options);
+	
+	void on_input_down(const CL_InputEvent &amp;key);
+	void on_input_up(const CL_InputEvent &amp;key);
+	void on_key_down(const CL_InputEvent &amp;key);
+	void on_key_up(const CL_InputEvent &amp;key);
+	void on_mouse_down(const CL_InputEvent &amp;key);
+	void on_mouse_up(const CL_InputEvent &amp;key);
+	void on_mouse_dblclk(const CL_InputEvent &amp;key);
+	void on_mouse_move(const CL_InputEvent &amp;key);
+	void on_close();
+	
+	CL_Component *owner;
+	CL_Component *parent;
+
+	CL_Component *client_area;
+
+	CL_StyleManager *style_manager;
+
+	CL_Rect position;
+
+	CL_Size minimum_size;
+	CL_Size maximum_size;
+	CL_Size preferred_size;
+	CL_LayoutPolicy vertical_policy;
+	CL_LayoutPolicy horizontal_policy;
+	CL_Layout layout;
+
+	CL_GUIManager *gui;
+
+	bool focusable;
+	bool visible;
+	bool enabled;
+	bool mouse_over;
+	bool event_passing;
+	bool topmost_flag;
+	bool clipping;
+	bool paint_clipping;
+	
+	int tab_id;
+	
+	std::list&lt;CL_Component *&gt; children;
+	std::list&lt;CL_Component *&gt; delete_children;
+
+	CL_ComponentStyle *style;
+	bool delete_style;
+
+	CL_Signal_v1&lt;const CL_DomElement &amp;&gt; sig_set_options;
+	CL_Signal_v0 sig_begin_paint;
+	CL_Signal_v0 sig_paint;
+	CL_Signal_v0 sig_end_paint;
+	CL_Signal_v0 sig_paint_children;
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; sig_input_down;
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; sig_input_up;
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; sig_key_down;
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; sig_key_up;
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; sig_mouse_down;
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; sig_mouse_up;
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; sig_mouse_dblclk;
+	CL_Signal_v1&lt;const CL_InputEvent &amp;&gt; sig_mouse_move;
+	CL_Signal_v0 sig_mouse_enter;
+	CL_Signal_v0 sig_mouse_leave;
+	CL_Signal_v0 sig_got_focus;
+	CL_Signal_v0 sig_lost_focus;
+	CL_Signal_v0 sig_close;
+	CL_Signal_v2&lt;int, int&gt; sig_resize;
+	CL_Signal_v2&lt;int, int&gt; sig_move;
+	CL_Signal_v2&lt;int &amp;, int &amp;&gt; sig_transform_coords;
+	CL_Signal_v1&lt;CL_Component *&gt; sig_child_add;
+	CL_Signal_v1&lt;CL_Component *&gt; sig_child_remove;
+	CL_Signal_v1&lt;CL_Component *&gt; sig_child_before_add;
+	CL_Signal_v1&lt;CL_Component *&gt; sig_child_before_remove;
+	CL_Signal_v1&lt;CL_Size &amp;&gt; sig_get_minimum_size;
+	CL_Signal_v1&lt;CL_Size &amp;&gt; sig_get_maximum_size;
+	CL_Signal_v1&lt;CL_Size &amp;&gt; sig_get_preferred_size;
+
+	CL_SlotContainer slots;
+};
+
+#endif

Added: trunk/clanlib/GUI/component_manager.cpp
===================================================================
--- trunk/clanlib/GUI/component_manager.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/component_manager.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,91 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/GUI/component_manager.h&quot;
+#include &quot;component_manager_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ComponentManager construction:
+
+CL_ComponentManager::CL_ComponentManager(
+	const std::string &amp;resource_id,
+	CL_ResourceManager *res_manager,
+	CL_Component *parent,
+	CL_StyleManager *style)
+{
+	impl = new CL_ComponentManager_Generic(resource_id, res_manager, parent, style);
+}
+
+CL_ComponentManager::CL_ComponentManager(
+	const std::string &amp;filename,
+	CL_Component *parent,
+	CL_StyleManager *style, 
+	CL_InputSourceProvider *input_provider,
+	bool delete_provider)
+{
+	impl = new CL_ComponentManager_Generic(filename, parent, style, input_provider, delete_provider);
+}
+
+CL_ComponentManager::CL_ComponentManager(
+	const CL_DomDocument &amp;document,
+	const CL_DomElement &amp;element,
+	CL_Component *parent,
+	CL_StyleManager *style)
+{
+	impl = new CL_ComponentManager_Generic(document, element, parent, style);
+}
+
+CL_ComponentManager::CL_ComponentManager(const CL_ComponentManager &amp;copy)
+: impl(copy.impl)
+{
+}
+
+CL_ComponentManager::~CL_ComponentManager()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ComponentManager attributes:
+
+CL_Component *CL_ComponentManager::get_component(const std::string &amp;name) const
+{
+	return impl-&gt;get_component(name);
+}
+
+CL_StyleManager *CL_ComponentManager::get_style_manager() const
+{
+	return impl-&gt;get_style_manager();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ComponentManager operations:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ComponentManager implementation:

Added: trunk/clanlib/GUI/component_manager_generic.cpp
===================================================================
--- trunk/clanlib/GUI/component_manager_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/component_manager_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,166 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;API/Core/Resources/resourcetype_raw.h&quot;
+#include &quot;API/Core/IOData/inputsource.h&quot;
+#include &quot;API/Core/IOData/inputsource_provider.h&quot;
+#include &quot;API/GUI/component_style.h&quot;
+#include &quot;component_manager_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ComponentManager_Generic construction:
+
+CL_ComponentManager_Generic::CL_ComponentManager_Generic(
+	const std::string &amp;res_id,
+	CL_ResourceManager *resources,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: style_manager(style), parent(parent)
+{
+	if (style_manager == 0) style_manager = parent-&gt;get_style_manager();
+
+	CL_Resource resource = resources-&gt;get_resource(res_id);
+	CL_DomElement element = resource.get_element();
+	if (element.has_attribute(&quot;file&quot;))
+	{
+		document = CL_DomDocument(resources-&gt;get_resource_provider()-&gt;open_source(element.get_attribute(&quot;file&quot;)), true);
+		element = document.get_document_element();
+	}
+	else
+	{
+		document = element.get_owner_document();
+	}
+
+	parse_components(element, parent, true);
+}
+
+CL_ComponentManager_Generic::CL_ComponentManager_Generic(
+	const std::string &amp;filename,
+	CL_Component *parent,
+	CL_StyleManager *style,
+	CL_InputSourceProvider *input_provider,
+	bool delete_provider)
+: style_manager(style), parent(parent)
+{
+	if (style_manager == 0) style_manager = parent-&gt;get_style_manager();
+
+	if (input_provider == 0)
+	{
+		input_provider = CL_InputSourceProvider::create_file_provider(&quot;.&quot;);
+		delete_provider = true;
+	}
+
+	document = CL_DomDocument(input_provider-&gt;open_source(filename), true);
+	if (delete_provider) delete input_provider;
+
+	parse_components(document.get_document_element(), parent, true);
+}
+
+CL_ComponentManager_Generic::CL_ComponentManager_Generic(
+	const CL_DomDocument &amp;document,
+	const CL_DomElement &amp;element,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: style_manager(style), parent(parent), document(document)
+{
+	if (style_manager == 0) style_manager = parent-&gt;get_style_manager();
+	parse_components(element, parent, true);
+}
+
+CL_ComponentManager_Generic::~CL_ComponentManager_Generic()
+{
+	std::vector&lt;CL_Component *&gt;::iterator it;
+	
+	for (it = root_components.begin (); it != root_components.end (); ++it)
+		delete *it;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ComponentManager_Generic attributes:
+
+CL_Component *CL_ComponentManager_Generic::get_component(const std::string &amp;component_id) const
+{
+	std::map&lt;std::string, CL_Component *&gt;::const_iterator it = component_map.find(component_id);
+	if (it != component_map.end())
+	{
+		return (*it).second;
+	}
+
+	throw CL_Error(std::string(&quot;Unable to locate component &quot;) + component_id);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ComponentManager_Generic operations:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ComponentManager_Generic implementation:
+
+void CL_ComponentManager_Generic::parse_components(const CL_DomElement &amp;componentsElement, CL_Component *parent, bool root_level)
+{
+	for (CL_DomNode node = componentsElement.get_first_child(); !node.is_null(); node = node.get_next_sibling())
+	{
+		if (!node.is_element()) continue;
+
+		CL_DomElement element = node.to_element();
+		std::string component_type = element.get_tag_name();
+		std::string component_name = element.get_attribute(&quot;name&quot;);
+
+		CL_Component *component = style_manager-&gt;create_component(component_type, parent-&gt;get_client_area());
+		component-&gt;sig_set_options()(element);
+
+		// Does this belong here? -- mbn
+		if (element.has_attribute(&quot;width&quot;) == false &amp;&amp; element.has_attribute(&quot;height&quot;) == false) component-&gt;find_preferred_size();
+
+				if (!component_name.empty()) 
+		{
+			component_map[component_name] = component;
+		}
+
+		if (root_level)
+		{
+			root_components.push_back(component);
+		}
+		else
+		{
+			/*
+				remove all childs at destruction
+			*/
+			component-&gt;get_parent ()-&gt;delete_child (component);
+		}
+
+		// Parse any child components, if any.
+		if (element.named_item(&quot;components&quot;).is_element())
+		{
+			parse_components(element.named_item(&quot;components&quot;).to_element(), component, false);
+		}
+	}
+}

Added: trunk/clanlib/GUI/component_manager_generic.h
===================================================================
--- trunk/clanlib/GUI/component_manager_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/component_manager_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,99 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_component_manager_generic
+#define header_component_manager_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+#include &lt;stack&gt;
+#include &lt;vector&gt;
+#include &lt;stdio.h&gt;
+
+#include &quot;API/GUI/component_manager.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+#include &quot;API/GUI/component.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;API/Core/XML/dom_document.h&quot;
+
+class CL_InputSource;
+
+class CL_ComponentManager_Generic
+{
+//! Construction:
+public:
+	CL_ComponentManager_Generic(
+		const std::string &amp;resource_id,
+		CL_ResourceManager *resources,
+		CL_Component *parent,
+		CL_StyleManager *style);
+
+	CL_ComponentManager_Generic(
+		const std::string &amp;filename,
+		CL_Component *parent,
+		CL_StyleManager *style,
+		CL_InputSourceProvider *input_provider,
+		bool delete_provider);
+
+	CL_ComponentManager_Generic(
+		const CL_DomDocument &amp;document,
+		const CL_DomElement &amp;element,
+		CL_Component *parent,
+		CL_StyleManager *style);
+		
+	~CL_ComponentManager_Generic();
+
+//! Attributes:
+public:
+	CL_Component *get_component(const std::string &amp;component_id) const;
+
+	CL_StyleManager *get_style_manager() const { return style_manager; }
+
+//! Operations:
+public:
+
+//! Implementation:
+private:
+	void parse_components(const CL_DomElement &amp;componentsElement, CL_Component *parent, bool root_level);
+
+	CL_StyleManager *style_manager;
+	
+	CL_Component *parent;
+
+	CL_DomDocument document;
+
+	std::map&lt;std::string, CL_Component *&gt; component_map;
+
+	std::vector&lt;CL_Component *&gt; root_components;
+};
+
+#endif

Added: trunk/clanlib/GUI/component_move_handler.cpp
===================================================================
--- trunk/clanlib/GUI/component_move_handler.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/component_move_handler.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,127 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/GUI/component_move_handler.h&quot;
+#include &quot;API/GUI/component.h&quot;
+#include &quot;API/Display/keys.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ComponentMoveHandler_Generic class:
+
+class CL_ComponentMoveHandler_Generic
+{
+public:
+	CL_ComponentMoveHandler_Generic(CL_ComponentMoveHandler *move_handler);
+
+	void on_mouse_down(const CL_InputEvent &amp;key);
+	void on_mouse_up(const CL_InputEvent &amp;key);
+	void on_mouse_move(const CL_InputEvent &amp;key);
+
+	CL_Slot slot_mouse_down;
+	CL_Slot slot_mouse_up;
+	CL_Slot slot_mouse_move;
+
+	bool is_active;
+	CL_Point mouse_origin;
+
+	CL_ComponentMoveHandler *move_handler;
+};
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ComponentMoveHandler:
+
+CL_ComponentMoveHandler::CL_ComponentMoveHandler(CL_Component *owner)
+: CL_Component(owner)
+{
+	impl = new CL_ComponentMoveHandler_Generic(this);
+}
+
+CL_ComponentMoveHandler::CL_ComponentMoveHandler(const CL_Rect &amp;move_area, CL_Component *owner)
+: CL_Component(move_area, owner)
+{
+	impl = new CL_ComponentMoveHandler_Generic(this);
+}
+
+CL_ComponentMoveHandler::~CL_ComponentMoveHandler()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ComponentMoveHandler_Generic implementation:
+
+CL_ComponentMoveHandler_Generic::CL_ComponentMoveHandler_Generic(CL_ComponentMoveHandler *move_handler)
+: move_handler(move_handler)
+{
+	is_active = false;
+
+	slot_mouse_down = move_handler-&gt;sig_mouse_down().connect(
+		this, &amp;CL_ComponentMoveHandler_Generic::on_mouse_down);
+
+	slot_mouse_up = move_handler-&gt;sig_mouse_up().connect(
+		this, &amp;CL_ComponentMoveHandler_Generic::on_mouse_up);
+
+	slot_mouse_move = move_handler-&gt;sig_mouse_move().connect(
+		this, &amp;CL_ComponentMoveHandler_Generic::on_mouse_move);
+}
+
+void CL_ComponentMoveHandler_Generic::on_mouse_down(const CL_InputEvent &amp;key)
+{
+	if(key.id == CL_MOUSE_LEFT)
+	{
+		mouse_origin = CL_Point((int)key.mouse_pos.x, (int)key.mouse_pos.y);
+		is_active = true;
+		move_handler-&gt;capture_mouse();
+	}
+}
+
+void CL_ComponentMoveHandler_Generic::on_mouse_up(const CL_InputEvent &amp;key)
+{
+	if(key.id == CL_MOUSE_LEFT)
+	{
+		is_active = false;
+		move_handler-&gt;release_mouse();
+	}
+}
+
+void CL_ComponentMoveHandler_Generic::on_mouse_move(const CL_InputEvent &amp;key)
+{
+	if(is_active == false)
+		return;
+
+	CL_Component *owner = move_handler-&gt;get_parent();
+	
+	const CL_Rect &amp;pos = owner-&gt;get_position();
+
+	int delta_x = key.mouse_pos.x - mouse_origin.x;
+	int delta_y = key.mouse_pos.y - mouse_origin.y;
+
+	owner-&gt;set_position(pos.left + delta_x, pos.top + delta_y);
+}

Added: trunk/clanlib/GUI/component_resize_handler.cpp
===================================================================
--- trunk/clanlib/GUI/component_resize_handler.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/component_resize_handler.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,125 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/GUI/component_resize_handler.h&quot;
+#include &quot;API/GUI/component.h&quot;
+#include &quot;API/Display/keys.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ComponentResizeHandler_Generic class:
+
+class CL_ComponentResizeHandler_Generic
+{
+public:
+	CL_ComponentResizeHandler_Generic(CL_ComponentResizeHandler *resize_handler);
+
+	void on_mouse_down(const CL_InputEvent &amp;key);
+	void on_mouse_up(const CL_InputEvent &amp;key);
+	void on_mouse_move(const CL_InputEvent &amp;key);
+
+	CL_Slot slot_mouse_down;
+	CL_Slot slot_mouse_up;
+	CL_Slot slot_mouse_move;
+
+	bool is_active;
+	CL_Point mouse_origin;
+
+	CL_ComponentResizeHandler *resize_handler;
+};
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ComponentResizeHandler:
+
+CL_ComponentResizeHandler::CL_ComponentResizeHandler(CL_Component *owner)
+: CL_Component(owner)
+{
+	impl = new CL_ComponentResizeHandler_Generic(this);
+}
+
+CL_ComponentResizeHandler::CL_ComponentResizeHandler(const CL_Rect &amp;resize_area, CL_Component *owner)
+: CL_Component(resize_area, owner)
+{
+	impl = new CL_ComponentResizeHandler_Generic(this);
+}
+
+CL_ComponentResizeHandler::~CL_ComponentResizeHandler()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ComponentResizeHandler_Generic implementation:
+
+CL_ComponentResizeHandler_Generic::CL_ComponentResizeHandler_Generic(CL_ComponentResizeHandler *resize_handler)
+: resize_handler(resize_handler)
+{
+	is_active = false;
+
+	slot_mouse_down = resize_handler-&gt;sig_mouse_down().connect(
+		this, &amp;CL_ComponentResizeHandler_Generic::on_mouse_down);
+
+	slot_mouse_up = resize_handler-&gt;sig_mouse_up().connect(
+		this, &amp;CL_ComponentResizeHandler_Generic::on_mouse_up);
+
+	slot_mouse_move = resize_handler-&gt;sig_mouse_move().connect(
+		this, &amp;CL_ComponentResizeHandler_Generic::on_mouse_move);
+}
+
+void CL_ComponentResizeHandler_Generic::on_mouse_down(const CL_InputEvent &amp;key)
+{
+	if(key.id == CL_MOUSE_LEFT)
+	{
+		mouse_origin = CL_Point((int)key.mouse_pos.x, (int)key.mouse_pos.y);
+		is_active = true;
+		resize_handler-&gt;capture_mouse();
+	}
+}
+
+void CL_ComponentResizeHandler_Generic::on_mouse_up(const CL_InputEvent &amp;key)
+{
+	if(key.id == CL_MOUSE_LEFT)
+	{
+		is_active = false;
+		resize_handler-&gt;release_mouse();
+	}
+}
+
+void CL_ComponentResizeHandler_Generic::on_mouse_move(const CL_InputEvent &amp;key)
+{
+	if(is_active == false)
+		return;
+
+	CL_Component *owner = resize_handler-&gt;get_parent();
+	
+	int delta_x = key.mouse_pos.x - mouse_origin.x;
+	int delta_y = key.mouse_pos.y - mouse_origin.y;
+
+	owner-&gt;set_size(owner-&gt;get_width() + delta_x, owner-&gt;get_height() + delta_y);
+}

Added: trunk/clanlib/GUI/component_type.cpp
===================================================================
--- trunk/clanlib/GUI/component_type.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/component_type.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,129 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;component_type_generic.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+/////////////////////////////////////////////////////////////////////////////
+// CL_ComponentType construction:
+
+CL_ComponentType::CL_ComponentType() : impl(new CL_ComponentType_Generic)
+{
+}
+
+CL_ComponentType::~CL_ComponentType()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ComponentType attributes:
+
+std::map&lt;std::string, CL_ComponentType *&gt; CL_ComponentType::component_types;
+
+const std::map&lt;std::string, CL_ComponentType::SOptionType&gt; &amp;CL_ComponentType::get_options() const
+{
+	return impl-&gt;options;
+}
+
+bool CL_ComponentType::has_option(const std::string &amp;option_name) const
+{
+	return impl-&gt;options.find(option_name) != impl-&gt;options.end();
+}
+
+CL_ComponentType::EDatatype CL_ComponentType::get_data_type(const std::string &amp;option_name) const
+{
+	std::map&lt;std::string, SOptionType&gt;::iterator it = impl-&gt;options.find(option_name);
+	if (it == impl-&gt;options.end()) return STRING; // throw error?
+	return it-&gt;second.type;
+}
+
+std::string CL_ComponentType::get_default_value(const std::string &amp;option_name) const
+{
+	std::map&lt;std::string, SOptionType&gt;::iterator it = impl-&gt;options.find(option_name);
+	if (it == impl-&gt;options.end()) return std::string(); // throw error?
+	return it-&gt;second.default_value;
+}
+
+const std::string &amp;CL_ComponentType::get_class_name() const
+{
+	return impl-&gt;class_name;
+}
+
+CL_ComponentType::EDatatype CL_ComponentType::get_data_type(const std::string &amp;type, const std::string &amp;option_name)
+{
+	std::map&lt;std::string, CL_ComponentType *&gt;::const_iterator it(component_types.find(type));
+	if (it == component_types.end()) cl_throw_error(std::string(&quot;Could not find component type &quot;) + type);
+
+	return it-&gt;second-&gt;get_data_type(option_name);
+}
+
+std::string CL_ComponentType::get_default_value(const std::string &amp;type, const std::string &amp;option_name)
+{
+	std::map&lt;std::string, CL_ComponentType *&gt;::const_iterator it(component_types.find(type));
+	if (it == component_types.end()) cl_throw_error(std::string(&quot;Could not find component type &quot;) + type);
+
+	return it-&gt;second-&gt;get_default_value(option_name);
+}
+
+const std::string &amp;CL_ComponentType::get_class_name(const std::string &amp;type)
+{
+	std::map&lt;std::string, CL_ComponentType *&gt;::const_iterator it(component_types.find(type));
+	if (it == component_types.end()) cl_throw_error(std::string(&quot;Could not find component type &quot;) + type);
+
+	return it-&gt;second-&gt;get_class_name();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ComponentType operations:
+
+CL_Component *CL_ComponentType::create_component(
+	const std::string &amp;type,
+	CL_Component *parent,
+	CL_StyleManager *style)
+{
+	std::map&lt;std::string, CL_ComponentType *&gt;::const_iterator it(component_types.find(type));
+	if (it == component_types.end()) cl_throw_error(std::string(&quot;Failed to create component of type &quot;) + type);
+	
+	return (*it).second-&gt;create_component(parent, style);
+}
+
+void CL_ComponentType::set_option(const std::string &amp;name, EDatatype datatype, const std::string &amp;value)
+{
+	impl-&gt;options[name].type = datatype;
+	impl-&gt;options[name].default_value = value;
+}
+
+void CL_ComponentType::set_class_name(const std::string &amp;class_name)
+{
+	impl-&gt;class_name = class_name;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//  CL_ComponentType implementation:

Added: trunk/clanlib/GUI/component_type_generic.h
===================================================================
--- trunk/clanlib/GUI/component_type_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/component_type_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,48 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_component_type_generic
+#define header_component_type_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/GUI/component_type.h&quot;
+
+class CL_ComponentType_Generic
+{
+//! Attributes:
+public:
+	std::map&lt;std::string, CL_ComponentType::SOptionType&gt; options;
+
+	std::string class_name;
+};
+
+#endif

Added: trunk/clanlib/GUI/deck.cpp
===================================================================
--- trunk/clanlib/GUI/deck.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/deck.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,114 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/GUI/deck.h&quot;
+#include &quot;deck_generic.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_Deck::CL_Deck()
+: impl(new CL_Deck_Generic())
+{
+}
+
+CL_Deck::~CL_Deck()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+CL_Component *CL_Deck::get_component(const std::string &amp;name)
+{
+	std::map&lt;std::string, CL_Component *&gt;::iterator iter = impl-&gt;component_map.find(name);
+
+	if (iter == impl-&gt;component_map.end())
+		throw CL_Error(&quot;CL_Deck::get_component failed: &quot; + name + &quot; is not in the component map.&quot;);
+
+	return (*iter).second;
+}
+
+CL_Component *CL_Deck::get_visible()
+{
+	return impl-&gt;active_component;
+}
+
+std::map&lt;std::string, CL_Component *&gt; &amp;CL_Deck::get_map()
+{
+	return impl-&gt;component_map;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_Deck::add(const std::string &amp;name, CL_Component *component)
+{
+	if (impl-&gt;component_map.empty())
+	{
+		component-&gt;show(true);
+		impl-&gt;active_component = component;
+	}
+	else
+		component-&gt;show(false);
+
+	impl-&gt;component_map[name] = component;
+}
+
+void CL_Deck::swap(const std::string &amp;name)
+{
+	std::map&lt;std::string, CL_Component *&gt;::iterator iter = impl-&gt;component_map.find(name);
+
+	if (iter == impl-&gt;component_map.end())
+		throw CL_Error(&quot;CL_Deck::get_component failed: &quot; + name + &quot; is not in the component map.&quot;);
+
+	// hide showing component.
+	if (impl-&gt;active_component)
+		impl-&gt;active_component-&gt;show(false);
+
+	// show selected component.
+	impl-&gt;active_component = (*iter).second;
+	impl-&gt;active_component-&gt;show(true);
+}
+
+void CL_Deck::remove(const std::string &amp;name)
+{
+	std::map&lt;std::string, CL_Component *&gt;::iterator iter = impl-&gt;component_map.find(name);
+
+	if (iter == impl-&gt;component_map.end())
+		throw CL_Error(&quot;CL_Deck::remove failed: &quot; + name + &quot; is not in the component map.&quot;);
+
+	// set active_component to null if removing component is the active component.
+	if (impl-&gt;active_component == (*iter).second)
+		impl-&gt;active_component = 0;
+
+	impl-&gt;component_map.erase(name);
+}

Added: trunk/clanlib/GUI/deck_generic.cpp
===================================================================
--- trunk/clanlib/GUI/deck_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/deck_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,38 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+
+#include &quot;deck_generic.h&quot;
+#include &quot;API/GUI/deck.h&quot;
+
+CL_Deck_Generic::CL_Deck_Generic()
+: active_component(0)
+{
+}

Added: trunk/clanlib/GUI/deck_generic.h
===================================================================
--- trunk/clanlib/GUI/deck_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/deck_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,53 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_deck_generic
+#define header_deck_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/GUI/component.h&quot;
+#include &lt;map&gt;
+
+class CL_Deck_Generic
+{
+//! Construction:
+public:
+	CL_Deck_Generic();
+
+//! Attributes:
+public:
+	std::map&lt;std::string, CL_Component *&gt; component_map;
+	CL_Component *active_component;
+
+};
+
+#endif

Added: trunk/clanlib/GUI/default_component_types.h
===================================================================
--- trunk/clanlib/GUI/default_component_types.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/default_component_types.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,305 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;../API/GUI/component_type.h&quot;
+
+#include &quot;API/GUI/button.h&quot;
+#include &quot;API/GUI/checkbox.h&quot;
+#include &quot;API/GUI/filedialog.h&quot;
+#include &quot;API/GUI/frame.h&quot;
+#include &quot;API/GUI/image.h&quot;
+#include &quot;API/GUI/inputbox.h&quot;
+#include &quot;API/GUI/label.h&quot;
+#include &quot;API/GUI/listbox.h&quot;
+#include &quot;API/GUI/progressbar.h&quot;
+#include &quot;API/GUI/radiobutton.h&quot;
+#include &quot;API/GUI/scrollbar.h&quot;
+#include &quot;API/GUI/window.h&quot;
+#include &quot;API/GUI/treeview.h&quot;
+
+class CL_ComponentType_Component : public CL_ComponentType
+{
+public:
+	CL_ComponentType_Component() : CL_ComponentType()
+	{
+		set_class_name(&quot;CL_Component&quot;);
+		set_option(&quot;x&quot;, NUMBER, &quot;0&quot;);
+		set_option(&quot;y&quot;, NUMBER, &quot;0&quot;);
+		set_option(&quot;width&quot;, NUMBER, &quot;100&quot;);
+		set_option(&quot;height&quot;, NUMBER, &quot;20&quot;);
+		set_option(&quot;visible&quot;, BOOL, &quot;1&quot;);
+		set_option(&quot;enabled&quot;, BOOL, &quot;1&quot;);
+		set_option(&quot;tab_id&quot;, NUMBER, &quot;0&quot;);
+	}
+
+	virtual CL_Component *create_component(
+		CL_Component *parent,
+		CL_StyleManager *style)
+	{
+		return new CL_Component(parent, style);
+	}
+};
+
+class CL_ComponentType_Button : public CL_ComponentType_Component
+{
+public:
+	CL_ComponentType_Button() : CL_ComponentType_Component()
+	{
+		set_class_name(&quot;CL_Button&quot;);
+		set_option(&quot;text&quot;, STRING, &quot;&quot;);
+		set_option(&quot;togglemode&quot;, NUMBER, &quot;0&quot;);
+		set_option(&quot;toggled&quot;, BOOL, &quot;0&quot;);
+	}
+
+	virtual CL_Component *create_component(
+		CL_Component *parent,
+		CL_StyleManager *style)
+	{
+		return new CL_Button(parent, style);
+	}
+};
+
+class CL_ComponentType_CheckBox : public CL_ComponentType_Button
+{
+public:
+	CL_ComponentType_CheckBox() : CL_ComponentType_Button()
+	{
+		set_class_name(&quot;CL_CheckBox&quot;);
+	}
+
+	virtual CL_Component *create_component(
+		CL_Component *parent,
+		CL_StyleManager *style)
+	{
+		return new CL_CheckBox(parent, style);
+	}
+};
+
+class CL_ComponentType_FileDialog : public CL_ComponentType_Component
+{
+public:
+	CL_ComponentType_FileDialog() : CL_ComponentType_Component()
+	{
+		set_class_name(&quot;CL_FileDialog&quot;);
+		set_option(&quot;file&quot;, STRING, &quot;&quot;);
+		set_option(&quot;filter&quot;, STRING, &quot;*.*&quot;);
+		set_option(&quot;show_hidden&quot;, BOOL, &quot;0&quot;);
+	}
+
+	virtual CL_Component *create_component(
+		CL_Component *parent,
+		CL_StyleManager *style)
+	{
+		return new CL_FileDialog(parent, style);
+	}
+};
+
+class CL_ComponentType_Frame : public CL_ComponentType_Component
+{
+public:
+	CL_ComponentType_Frame() : CL_ComponentType_Component()
+	{
+		set_class_name(&quot;CL_Frame&quot;);
+		set_option(&quot;filled&quot;, BOOL, &quot;1&quot;);
+	}
+
+	virtual CL_Component *create_component(
+		CL_Component *parent,
+		CL_StyleManager *style)
+	{
+		return new CL_Frame(parent, style);
+	}
+};
+
+class CL_ComponentType_Image : public CL_ComponentType_Component
+{
+public:
+	CL_ComponentType_Image() : CL_ComponentType_Component()
+	{
+		set_class_name(&quot;CL_Image&quot;);
+		// TODO: add options
+	}
+
+	virtual CL_Component *create_component(
+		CL_Component *parent,
+		CL_StyleManager *style)
+	{
+		return new CL_Image(parent, style);
+	}
+};
+
+class CL_ComponentType_InputBox : public CL_ComponentType_Component
+{
+public:
+	CL_ComponentType_InputBox() : CL_ComponentType_Component()
+	{
+		set_class_name(&quot;CL_InputBox&quot;);
+		set_option(&quot;text&quot;, STRING, &quot;&quot;);
+		set_option(&quot;passwordmode&quot;, NUMBER, &quot;0&quot;);
+		set_option(&quot;read_only&quot;, BOOL, &quot;0&quot;);
+		set_option(&quot;max_length&quot;, NUMBER, &quot;0&quot;);
+	}
+
+	virtual CL_Component *create_component(
+		CL_Component *parent,
+		CL_StyleManager *style)
+	{
+		return new CL_InputBox(parent, style);
+	}
+};
+
+class CL_ComponentType_Label : public CL_ComponentType_Component
+{
+public:
+	CL_ComponentType_Label() : CL_ComponentType_Component()
+	{
+		set_class_name(&quot;CL_Label&quot;);
+		set_option(&quot;text&quot;, STRING, &quot;&quot;);
+	}
+
+	virtual CL_Component *create_component(
+		CL_Component *parent,
+		CL_StyleManager *style)
+	{
+		return new CL_Label(parent, style);
+	}
+};
+
+class CL_ComponentType_ListBox : public CL_ComponentType_Component
+{
+public:
+	CL_ComponentType_ListBox() : CL_ComponentType_Component()
+	{
+		set_class_name(&quot;CL_ListBox&quot;);
+		set_option(&quot;item&quot;, NUMBER, &quot;0&quot;);
+		set_option(&quot;max_visible_items&quot;, NUMBER, &quot;-1&quot;);
+	}
+
+	virtual CL_Component *create_component(
+		CL_Component *parent,
+		CL_StyleManager *style)
+	{
+		return new CL_ListBox(parent, style);
+	}
+};
+
+class CL_ComponentType_ProgressBar : public CL_ComponentType_Component
+{
+public:
+	CL_ComponentType_ProgressBar() : CL_ComponentType_Component()
+	{
+		set_class_name(&quot;CL_ProgressBar&quot;);
+		set_option(&quot;steps&quot;, NUMBER, &quot;100&quot;);
+	}
+
+	virtual CL_Component *create_component(
+		CL_Component *parent,
+		CL_StyleManager *style)
+	{
+		return new CL_ProgressBar(parent, style);
+	}
+};
+
+class CL_ComponentType_RadioButton : public CL_ComponentType_Component
+{
+public:
+	CL_ComponentType_RadioButton() : CL_ComponentType_Component()
+	{
+		set_class_name(&quot;CL_RadioButton&quot;);
+		// TODO: add options
+	}
+
+	virtual CL_Component *create_component(
+		CL_Component *parent,
+		CL_StyleManager *style)
+	{
+		return new CL_RadioButton(parent, style);
+	}
+};
+
+class CL_ComponentType_ScrollBar : public CL_ComponentType_Component
+{
+public:
+	CL_ComponentType_ScrollBar() : CL_ComponentType_Component()
+	{
+		set_class_name(&quot;CL_ScrollBar&quot;);
+		set_option(&quot;min&quot;, NUMBER, &quot;0&quot;);
+		set_option(&quot;max&quot;, NUMBER, &quot;100&quot;);
+		set_option(&quot;value&quot;, NUMBER, &quot;0&quot;);
+		set_option(&quot;orientation&quot;, NUMBER, &quot;0&quot;);
+		set_option(&quot;tracking&quot;, BOOL, &quot;0&quot;);
+	}
+
+	virtual CL_Component *create_component(
+		CL_Component *parent,
+		CL_StyleManager *style)
+	{
+		return new CL_ScrollBar(parent, style);
+	}
+};
+
+class CL_ComponentType_Window : public CL_ComponentType_Component
+{
+public:
+	CL_ComponentType_Window() : CL_ComponentType_Component()
+	{
+		set_class_name(&quot;CL_Window&quot;);
+		set_option(&quot;title&quot;, STRING, &quot;&quot;);
+	}
+
+	virtual CL_Component *create_component(
+		CL_Component *parent,
+		CL_StyleManager *style)
+	{
+		return new CL_Window(parent, style);
+	}
+};
+
+class CL_ComponentType_TreeView : public CL_ComponentType_Component
+{
+public:
+	CL_ComponentType_TreeView() : CL_ComponentType_Component()
+	{
+		set_class_name(&quot;CL_TreeView&quot;);
+		// TODO: add options
+	}
+
+	virtual CL_Component *create_component(
+		CL_Component *parent,
+		CL_StyleManager *style)
+	{
+		return new CL_TreeView(parent, style);
+	}
+};
+
+// TODO:
+
+// Add missing components:
+// - (Menu)
+// - (PopupMenu)

Added: trunk/clanlib/GUI/filedialog.cpp
===================================================================
--- trunk/clanlib/GUI/filedialog.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/filedialog.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,183 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/GUI/filedialog.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;filedialog_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_FileDialog::CL_FileDialog(
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Window(parent, style), impl(NULL)
+{
+	impl = new CL_FileDialog_Generic(this, &quot;&quot;, &quot;&quot;, &quot;*&quot;);
+}
+
+CL_FileDialog::CL_FileDialog(
+	const std::string &amp;title,
+	const std::string &amp;file,
+	const std::string &amp;filter,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Window(parent, style), impl(NULL)
+{
+	impl = new CL_FileDialog_Generic(this, title, file, filter);
+}
+
+CL_FileDialog::~CL_FileDialog()
+{
+	delete impl;
+}
+
+const std::string CL_FileDialog::open(
+	CL_Component *parent)
+{
+	CL_FileDialog filedialog(&quot;Open File&quot;, &quot;&quot;, &quot;*.*&quot;, parent);
+	filedialog.run();
+
+	return filedialog.get_file();
+}
+
+const std::string CL_FileDialog::open(
+	const std::string &amp;file,
+	const std::string &amp;filter,
+	CL_Component *parent)
+{
+	CL_FileDialog filedialog(&quot;Open File&quot;, file, filter, parent);
+	filedialog.run();
+
+	return filedialog.get_file();
+}
+
+const std::string CL_FileDialog::save(
+	CL_Component *parent)
+{
+	CL_FileDialog filedialog(&quot;Save File&quot;, &quot;&quot;, &quot;*.*&quot;, parent);
+	filedialog.run();
+
+	return filedialog.get_file();
+}
+
+const std::string CL_FileDialog::save(
+	const std::string &amp;file,
+	const std::string &amp;filter,
+	CL_Component *parent)
+{
+	CL_FileDialog filedialog(&quot;Save File&quot;, file, filter, parent);
+	filedialog.run();
+
+	return filedialog.get_file();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+const CL_FileDialog::ButtonPressed &amp;CL_FileDialog::get_pressed_button(void) const
+{
+	return impl-&gt;get_pressed_button();
+} 
+
+const std::string &amp;CL_FileDialog::get_file() const
+{
+	return impl-&gt;get_file();
+}
+
+const std::string &amp;CL_FileDialog::get_filter() const
+{
+	return impl-&gt;get_filter();
+}
+
+const std::string &amp;CL_FileDialog::get_dir() const
+{
+	return impl-&gt;get_dir();
+}
+
+const std::string &amp;CL_FileDialog::get_path() const
+{
+	return impl-&gt;get_path();
+}
+
+bool CL_FileDialog::is_hidden_files_visible() const
+{
+	return impl-&gt;is_hidden_files_visible();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+void CL_FileDialog::set_behavior(Behavior behavior)
+{
+	impl-&gt;set_behavior(behavior);
+}
+
+void CL_FileDialog::set_file(const std::string &amp;filename)
+{
+	impl-&gt;set_file(filename);
+}
+
+void CL_FileDialog::set_dir(const std::string &amp;dir)
+{
+	impl-&gt;set_dir(dir);
+}
+
+void CL_FileDialog::set_filter(const std::string &amp;filter)
+{
+	impl-&gt;set_filter(filter);
+}
+
+void CL_FileDialog::show_hidden_files(bool enable)
+{
+	impl-&gt;show_hidden_files(enable);
+}
+
+void CL_FileDialog::refresh()
+{
+	impl-&gt;refresh();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Signals:
+
+CL_Signal_v1&lt;const std::string &amp;&gt; &amp;CL_FileDialog::sig_file_highlighted()
+{
+	return impl-&gt;sig_file_highlighted;
+}
+
+CL_Signal_v1&lt;const std::string &amp;&gt; &amp;CL_FileDialog::sig_file_selected()
+{
+	return impl-&gt;sig_file_selected;
+}
+
+CL_Signal_v1&lt;const std::string &amp;&gt; &amp;CL_FileDialog::sig_dir_entered()
+{
+	return impl-&gt;sig_dir_entered;
+}

Added: trunk/clanlib/GUI/filedialog_generic.cpp
===================================================================
--- trunk/clanlib/GUI/filedialog_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/filedialog_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,399 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;filedialog_generic.h&quot;
+//#include &quot;API/GUI/filedialog.h&quot;
+#include &quot;API/GUI/treenode.h&quot;
+#include &quot;API/GUI/treeitem.h&quot;
+
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;API/Core/IOData/directory_scanner.h&quot;
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/IOData/directory.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_FileDialog_Generic::CL_FileDialog_Generic(
+	CL_FileDialog *self,
+	const std::string &amp;title,
+	const std::string &amp;file,
+	const std::string &amp;filter)
+	: filedialog(self)
+{
+	behavior = CL_FileDialog::quit_always;
+	button = CL_FileDialog::button_none;
+	// TODO: Calculate proper size
+	int width = 400;
+	int height = 315;
+	int x = (CL_Display::get_width() - width) / 2;
+	int y = (CL_Display::get_height() - height) / 2;
+	filedialog-&gt;set_position(CL_Rect(x, y, x + width, y + height));
+	filedialog-&gt;set_title(title);
+
+	CL_Component *client_area = filedialog-&gt;get_client_area();
+
+	width = client_area-&gt;get_width();
+
+	label_dir = new CL_Label(CL_Point(10, 12), &quot;Directory:&quot;, client_area);
+	input_dir = new CL_InputBox(CL_Rect(65, 10, width - 120, 30), client_area);
+	input_dir-&gt;enable(false);
+
+	button_parent = new CL_Button(CL_Rect(width - 115, 9, width - 65, 28), &quot;Parent&quot;, client_area);
+	button_createdir = new CL_Button(CL_Rect(width - 60, 9, width - 10, 28), &quot;New&quot;, client_area);
+
+	treeview_files = new CL_TreeView(CL_Rect(10, 32, width - 10, 197), client_area);
+	treeview_files-&gt;add_column(&quot;Filename&quot;, 200);
+	treeview_files-&gt;add_column(&quot;Size&quot;, 80);
+	treeview_files-&gt;add_column(&quot;Type&quot;, 100);
+	treeview_files-&gt;show_root_decoration(false);
+
+	label_file = new CL_Label(CL_Point(10, 207), &quot;Filename:&quot;, client_area);
+	input_file = new CL_InputBox(CL_Rect(65, 205, width - 10, 225), client_area);
+
+	label_filter = new CL_Label(CL_Point(10, 232), &quot;Filter:&quot;, client_area);
+	input_filter = new CL_InputBox(CL_Rect(65, 230, width - 10, 250), client_area);
+
+	button_ok = new CL_Button(CL_Rect(10, 260, 100, 280), &quot;OK&quot;, client_area);
+	button_cancel = new CL_Button(CL_Rect(width - 110, 260, width - 10, 280), &quot;Cancel&quot;, client_area);
+
+	slots.connect(self-&gt;sig_set_options(), this, &amp;CL_FileDialog_Generic::on_set_options);
+	slots.connect(treeview_files-&gt;sig_selection_changed(), this, &amp;CL_FileDialog_Generic::on_file_activated);
+	slots.connect(button_ok-&gt;sig_clicked(), this, &amp;CL_FileDialog_Generic::on_button_quit, true);
+	slots.connect(button_cancel-&gt;sig_clicked(), this, &amp;CL_FileDialog_Generic::on_button_quit, false);
+	slots.connect(button_parent-&gt;sig_clicked(), this, &amp;CL_FileDialog_Generic::on_button_parent);
+	slots.connect(button_createdir-&gt;sig_clicked(), this, &amp;CL_FileDialog_Generic::on_button_createdir);
+	slots.connect(input_file-&gt;sig_return_pressed(), this, &amp;CL_FileDialog_Generic::on_edit_file);
+	slots.connect(input_filter-&gt;sig_return_pressed(), this, &amp;CL_FileDialog_Generic::on_edit_filter);
+	slots.connect(input_dir-&gt;sig_return_pressed(), this, &amp;CL_FileDialog_Generic::on_edit_dir);
+	
+	set_file(file, false);
+	set_filter(filter, false);
+	show_hidden = false;
+
+	read_dir();
+}
+
+CL_FileDialog_Generic::~CL_FileDialog_Generic()
+{
+	delete label_dir;
+	delete input_dir;
+	delete button_parent;
+	delete button_createdir;
+	delete treeview_files;
+	delete label_file;
+	delete input_file;
+	delete label_filter;
+	delete input_filter;
+	delete button_ok;
+	delete button_cancel;
+}
+
+FileInfo::FileInfo(std::string name, bool directory, bool readable, bool writable, bool hidden, int size) 
+: name(name), directory(directory), readable(readable), writable(writable), hidden(hidden), size(size)
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+const CL_FileDialog::ButtonPressed &amp;CL_FileDialog_Generic::get_pressed_button(void) const
+{
+	return button;
+}
+
+const std::string &amp;CL_FileDialog_Generic::get_file() const
+{
+	return file;
+}
+
+const std::string &amp;CL_FileDialog_Generic::get_filter() const
+{
+	return filter;
+}
+
+const std::string &amp;CL_FileDialog_Generic::get_dir() const
+{
+	return dir;
+}
+
+const std::string &amp;CL_FileDialog_Generic::get_path() const
+{
+	return path;
+}
+
+bool CL_FileDialog_Generic::is_hidden_files_visible() const
+{
+	return show_hidden;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+void CL_FileDialog_Generic::set_behavior(CL_FileDialog::Behavior p_behavior)
+{
+	behavior = p_behavior;
+}
+
+void CL_FileDialog_Generic::set_file(const std::string &amp;new_file, bool perform_refresh)
+{
+	input_file-&gt;set_text(new_file);
+	file = new_file;
+
+	if(perform_refresh)
+		refresh();
+}
+
+void CL_FileDialog_Generic::set_dir(const std::string &amp;new_dir, bool perform_refresh)
+{
+	input_dir-&gt;set_text(new_dir);
+	dir = new_dir;
+	CL_Directory::change_to(dir);
+	path = CL_Directory::get_current();
+
+	if(perform_refresh)
+		refresh();
+}
+
+void CL_FileDialog_Generic::set_filter(const std::string &amp;new_filter, bool perform_refresh)
+{
+	input_filter-&gt;set_text(new_filter);
+	filter = new_filter;
+
+	if(perform_refresh)
+		refresh();
+}
+
+void CL_FileDialog_Generic::show_hidden_files(bool enable)
+{
+	show_hidden = enable;
+}
+
+void CL_FileDialog_Generic::refresh()
+{
+	CL_DirectoryScanner scanner;
+	unsigned int i;
+	bool parent = false;
+
+	treeview_files-&gt;clear();
+	Directories.clear();
+	Files.clear();
+
+	scanner.scan (&quot;.&quot;, &quot;*&quot;);
+	while (scanner.next())
+	{
+		std::string file = scanner.get_name();
+
+		if(file == &quot;.&quot; || file == &quot;..&quot;)
+			parent = true;
+		else 
+		{
+			if (!scanner.is_hidden() || show_hidden == true)
+			{	
+				if (scanner.is_directory())
+				{
+					Directories.push_back(FileInfo(file, scanner.is_directory(), scanner.is_readable(), scanner.is_writable(), scanner.is_hidden(), 0));
+				}
+			}
+		}
+	}
+	
+	scanner.scan (&quot;.&quot;, filter);
+	while (scanner.next())
+	{
+		std::string file = scanner.get_name();
+
+		if(file == &quot;.&quot; || file == &quot;..&quot;)
+			parent = true;
+		else 
+		{
+			if (!scanner.is_hidden() || show_hidden == true)
+			{	
+				if (!scanner.is_directory())
+				{
+					Files.push_back(FileInfo(file, scanner.is_directory(), scanner.is_readable(), scanner.is_writable(), scanner.is_hidden(), scanner.get_size()));
+				}
+			}
+		}
+	}
+
+	std::sort(Directories.begin(), Directories.end(), CL_FileDialog_Generic::sort);
+	std::sort(Files.begin(), Files.end(), CL_FileDialog_Generic::sort);
+
+	for(i = 0; i &lt; Directories.size(); i++)
+		treeview_files-&gt;insert_item(Directories[i].name, &quot;&quot;, &quot;Directory&quot;);
+
+	for(i = 0; i &lt; Files.size(); i++)
+	{
+		std::string AppendName = Files[i].name;
+		int index = AppendName.rfind('.');
+		std::string file_size;
+		
+		file_size = CL_String::format(&quot;%1 bytes&quot;, Files[i].size);
+
+		if(Files[i].size &gt; 1024)
+			file_size = CL_String::format(&quot;%1 KB&quot;, Files[i].size / 1024);
+
+		if(Files[i].size &gt; 1024 * 1024)
+			file_size = CL_String::format(&quot;%1 MB&quot;, Files[i].size / (1024 * 1024));
+
+
+		if(index &gt;= 0)
+		{
+			AppendName = AppendName.substr(index);
+			AppendName = CL_String::format(&quot;%1 file&quot;, AppendName);
+		}
+
+		treeview_files-&gt;insert_item(Files[i].name, file_size, AppendName);
+	}
+
+	button_parent-&gt;enable(parent);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_FileDialog_Generic::on_file_activated(const CL_TreeNode &amp;node)
+{
+	CL_TreeItem *treeitem = (CL_TreeItem *)node.get_component();
+
+	std::string item = treeitem-&gt;get_text(0);
+
+	if(treeitem-&gt;get_text(2) == &quot;Directory&quot;)
+	{
+		CL_Directory::change_to(item);
+		read_dir();
+	}
+	else
+	{
+		set_file(item, false);
+	}
+}
+
+void CL_FileDialog_Generic::on_button_quit(bool ok)
+{
+	if(ok == false)
+	{
+		button = CL_FileDialog::button_cancel;
+		file = &quot;&quot;;
+	}
+	else if(ok)
+	{
+		button = CL_FileDialog::button_ok;
+		
+		if (behavior != CL_FileDialog::quit_file_selected)
+		{
+			//accept manually edited/typed entry as the file	
+			file = input_file-&gt;get_text();
+		}
+	}
+
+	// Quit only if behaviour say that
+	if( (behavior == CL_FileDialog::quit_always) || (button == CL_FileDialog::button_cancel) || ( (behavior == CL_FileDialog::quit_file_selected) &amp;&amp; !file.empty()) )
+		filedialog-&gt;quit();
+}
+
+void CL_FileDialog_Generic::on_button_parent()
+{
+	CL_Directory::change_to(&quot;..&quot;);
+	read_dir();
+}
+
+void CL_FileDialog_Generic::on_button_createdir()
+{
+	CL_InputDialog dlg(&quot;Create new directory&quot;, &quot;Ok&quot;, &quot;Cancel&quot;, &quot;&quot;, filedialog);
+	CL_InputBox *dir_name = dlg.add_input_box(&quot;New directory:&quot;, &quot;&quot;, 200);
+	dlg.set_position(10, 10);
+	dlg.run();
+
+	if(dlg.get_result_button() == 0)
+	{
+		if(dir_name-&gt;get_text() != &quot;&quot;)
+		{
+			CL_Directory::create(dir_name-&gt;get_text());
+			refresh();
+		}
+	}
+}
+
+void CL_FileDialog_Generic::on_edit_dir()
+{
+	set_dir(input_dir-&gt;get_text());
+}
+
+void CL_FileDialog_Generic::on_edit_file()
+{
+	set_file(input_file-&gt;get_text());
+}
+
+void CL_FileDialog_Generic::on_edit_filter()
+{
+	set_filter(input_filter-&gt;get_text());
+}
+
+void CL_FileDialog_Generic::on_set_options(const CL_DomElement &amp;options)
+{
+	if (options.has_attribute(&quot;file&quot;))
+		set_file(options.get_attribute(&quot;file&quot;), false);
+
+	if (options.has_attribute(&quot;filter&quot;))
+		set_filter(options.get_attribute(&quot;filter&quot;), false);
+
+	if (options.has_attribute(&quot;show_hidden&quot;))
+		show_hidden = CL_String::to_bool(options.get_attribute(&quot;show_hidden&quot;));
+
+	read_dir();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Implementation:
+
+void CL_FileDialog_Generic::read_dir()
+{
+	std::string cwd = CL_Directory::get_current();
+	path = cwd;
+
+	int find_last1 = cwd.rfind('/');
+	int find_last2 = cwd.rfind('\\');
+
+	int index = 0;
+	if(find_last1 != -1)
+		index = find_last1 + 1;
+	else if(find_last2 != -1)
+		index = find_last2 + 1;
+
+	cwd = cwd.substr(cwd.length() - (cwd.length() - index));
+
+	set_dir(cwd);
+}
+
+bool CL_FileDialog_Generic::sort(const FileInfo &amp;a, const FileInfo &amp;b)
+{
+   return a.name &lt; b.name;
+}

Added: trunk/clanlib/GUI/filedialog_generic.h
===================================================================
--- trunk/clanlib/GUI/filedialog_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/filedialog_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,160 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_file_dialog_generic
+#define header_file_dialog_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/signals.h&quot;
+#include &quot;API/GUI/window.h&quot;
+#include &quot;API/GUI/label.h&quot;
+#include &quot;API/GUI/inputbox.h&quot;
+#include &quot;API/GUI/button.h&quot;
+#include &quot;API/GUI/treeview.h&quot;
+#include &quot;API/GUI/inputdialog.h&quot;
+#include &quot;API/GUI/filedialog.h&quot;
+
+//class CL_FileDialog;
+class CL_StyleManager;
+class CL_TreeNode;
+
+/////////////////////////////////////////////////////////////////////////////
+// FileInfo
+
+class FileInfo
+{
+public:
+	FileInfo(std::string name, bool directory, bool readable, bool writable, bool hidden, int size);
+	std::string name;
+	bool directory;
+	bool readable;
+	bool writable;
+	bool hidden;
+	int size;
+};
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_FileDialog_Generic
+
+class CL_FileDialog_Generic
+{
+//! Construction:
+public:
+	CL_FileDialog_Generic(
+		CL_FileDialog *self,
+		const std::string &amp;title,
+		const std::string &amp;file,
+		const std::string &amp;filter);
+
+	~CL_FileDialog_Generic();
+
+//! Attributes:
+public:
+	const CL_FileDialog::ButtonPressed &amp;get_pressed_button(void) const; 
+	const std::string &amp;get_file() const;
+	const std::string &amp;get_filter() const;
+	const std::string &amp;get_dir() const;
+	const std::string &amp;get_path() const;
+	bool is_hidden_files_visible() const;
+
+//! Operations:
+public:
+	void set_behavior(CL_FileDialog::Behavior behavior);
+	void set_file(const std::string &amp;filename, bool refresh = true);
+	void set_dir(const std::string &amp;dir, bool refresh = true);
+	void set_filter(const std::string &amp;filter, bool refresh = true);
+	void show_hidden_files(bool enable);
+	void refresh();
+
+//! Callbacks:
+public:
+	void on_file_activated(const CL_TreeNode &amp;node);
+	void on_button_quit(bool ok);
+	void on_button_parent();
+	void on_button_createdir();
+	void on_edit_dir();
+	void on_edit_file();
+	void on_edit_filter();
+	void on_set_options(const CL_DomElement &amp;options);
+
+//! Signals:
+public:
+	CL_Signal_v1&lt;const std::string &amp;&gt; sig_file_highlighted;
+	CL_Signal_v1&lt;const std::string &amp;&gt; sig_file_selected;
+	CL_Signal_v1&lt;const std::string &amp;&gt; sig_dir_entered;
+
+//! Implementation:
+private:
+	void read_dir();
+
+	static bool sort(const FileInfo &amp;a, const FileInfo &amp;b);
+
+	// Behaviou
+	CL_FileDialog::Behavior behavior;
+	// Button pressed
+	CL_FileDialog::ButtonPressed button; 
+
+	CL_FileDialog *filedialog;
+
+	bool show_hidden;
+
+	CL_SlotContainer slots;
+
+	CL_Label *label_dir;
+	CL_InputBox *input_dir;
+	CL_Button *button_parent;
+	CL_Button *button_createdir;
+
+	CL_TreeView *treeview_files;
+
+	CL_Label *label_file;
+	CL_InputBox *input_file;
+
+	CL_Label *label_filter;
+	CL_InputBox *input_filter;
+
+	CL_Button *button_ok;
+	CL_Button *button_cancel;
+
+	std::string file;
+	std::string filter;
+	std::string dir;
+	std::string path;
+
+	std::vector&lt;FileInfo&gt; Directories;
+	std::vector&lt;FileInfo&gt; Files;
+};
+
+#endif

Added: trunk/clanlib/GUI/frame.cpp
===================================================================
--- trunk/clanlib/GUI/frame.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/frame.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,79 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/GUI/frame.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;frame_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_Frame::CL_Frame(
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(parent, style), impl(NULL)
+{
+	impl = new CL_Frame_Generic(this);
+	get_style_manager()-&gt;connect_styles(&quot;frame&quot;, this);
+	find_preferred_size();
+}
+
+CL_Frame::CL_Frame(
+	const CL_Rect &amp;pos,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(pos, parent, style), impl(NULL)
+{
+	impl = new CL_Frame_Generic(this);
+	get_style_manager()-&gt;connect_styles(&quot;frame&quot;, this);
+}
+
+CL_Frame::~CL_Frame()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+bool CL_Frame::is_fill_enabled() const
+{
+	return impl-&gt;fill;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_Frame::enable_fill(bool enabled)
+{
+	impl-&gt;fill = enabled;
+}
+

Added: trunk/clanlib/GUI/frame_generic.cpp
===================================================================
--- trunk/clanlib/GUI/frame_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/frame_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,59 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;frame_generic.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_Frame_Generic::CL_Frame_Generic(CL_Frame *self)
+: fill(false), frame(self)
+{
+	CL_Component *client_area = new CL_Component(frame);
+	frame-&gt;set_client_area(client_area);
+
+	slots.connect(frame-&gt;sig_set_options(), this, &amp;CL_Frame_Generic::on_set_options);
+}
+
+CL_Frame_Generic::~CL_Frame_Generic()
+{
+	delete frame-&gt;get_client_area();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_Frame_Generic::on_set_options(const CL_DomElement &amp;options)
+{
+	if(options.has_attribute(&quot;filled&quot;))
+		fill = CL_String::to_bool(options.get_attribute(&quot;filled&quot;));
+}

Added: trunk/clanlib/GUI/frame_generic.h
===================================================================
--- trunk/clanlib/GUI/frame_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/frame_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,60 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_frame_generic
+#define header_frame_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/GUI/frame.h&quot;
+
+class CL_Frame_Generic
+{
+//! Construction:
+public:
+	CL_Frame_Generic(CL_Frame *self);
+	~CL_Frame_Generic();
+
+//! Attributes:
+public:
+	bool fill;
+
+//! Callbacks:
+private:
+	void on_set_options(const CL_DomElement &amp;options);
+
+//! Implementation:
+private:
+	CL_Frame *frame;
+	CL_SlotContainer slots;
+};  
+
+#endif

Added: trunk/clanlib/GUI/gui_manager.cpp
===================================================================
--- trunk/clanlib/GUI/gui_manager.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/gui_manager.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,135 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/GUI/gui_manager.h&quot;
+#include &quot;API/Display/display.h&quot;
+#include &quot;gui_manager_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_GUIManager Construction:
+
+CL_GUIManager::CL_GUIManager(CL_StyleManager *style)
+:
+	CL_Component(CL_Rect(0, 0, CL_Display::get_width(), CL_Display::get_height()), NULL, style)
+{
+	impl = new CL_GUIManager_Generic(this);
+	set_focusable(false);
+}
+
+CL_GUIManager::~CL_GUIManager()
+{
+	delete impl;
+	impl = NULL; //SETH&gt; Don't remove this, it's used to check &quot;shuttong down&quot; to avoid
+	//a crash in the recursive delete process
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_GUIManager Attributes:
+
+CL_Component *CL_GUIManager::get_focus() const
+{
+	return impl-&gt;get_focus();
+}
+
+CL_Component *CL_GUIManager::get_capture() const
+{
+	return impl-&gt;get_capture();
+}
+
+bool CL_GUIManager::is_input_enabled() const
+{
+	return impl-&gt;is_input_enabled();
+}
+
+CL_EventTrigger *CL_GUIManager::get_update_trigger()
+{
+	return &amp;impl-&gt;update_trigger;
+}
+
+bool CL_GUIManager::is_shutting_down() const
+{
+	return impl == NULL;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_GUIManager Operations:
+
+void CL_GUIManager::set_focus(CL_Component *component)
+{
+	impl-&gt;set_focus(component);
+}
+
+void CL_GUIManager::run(CL_Component *modal_component)
+{
+	impl-&gt;run(modal_component);
+}
+
+void CL_GUIManager::show()
+{
+	impl-&gt;show();
+}
+
+void CL_GUIManager::quit()
+{
+	impl-&gt;quit();
+}
+
+void CL_GUIManager::enable_input()
+{
+	impl-&gt;enable_input();
+}
+
+void CL_GUIManager::disable_input()
+{
+	impl-&gt;disable_input();
+}
+
+void CL_GUIManager::gui_capture_mouse(CL_Component *component)
+{
+	impl-&gt;gui_capture_mouse(component);
+}
+
+void CL_GUIManager::gui_release_mouse()
+{
+	impl-&gt;gui_release_mouse();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_GUIManager Signals:
+
+CL_Signal_v1&lt;CL_Component *&gt; &amp;CL_GUIManager::sig_focus_changed()
+{
+	return impl-&gt;sig_focus_changed;
+}
+
+CL_Component * CL_GUIManager::get_modal_component() const
+{
+	return impl-&gt;get_modal_component();
+}

Added: trunk/clanlib/GUI/gui_manager_generic.cpp
===================================================================
--- trunk/clanlib/GUI/gui_manager_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/gui_manager_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,559 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/Core/System/system.h&quot;
+#include &quot;API/GUI/component.h&quot;
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Display/keys.h&quot;
+#include &quot;API/Display/keyboard.h&quot;
+#include &quot;API/Display/mouse.h&quot;
+#include &quot;gui_manager_generic.h&quot;
+#include &quot;component_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_GUIManager_Generic construction:
+
+CL_GUIManager_Generic::CL_GUIManager_Generic(CL_GUIManager *_owner)
+:
+	owner(_owner),
+	input_enabled(true),
+	current_tab_id(0),
+	comp_focus(_owner),
+	comp_capture_mouse(NULL),
+	comp_mouse_over(NULL),
+	focus_component(NULL)
+{
+	owner-&gt;set_gui_manager(owner);
+
+	slots.connect(CL_Keyboard::sig_key_down(),
+		this, &amp;CL_GUIManager_Generic::on_input_down);
+	slots.connect(CL_Keyboard::sig_key_up(),
+		this, &amp;CL_GUIManager_Generic::on_input_up);
+	slots.connect(CL_Mouse::sig_key_down(),
+		this, &amp;CL_GUIManager_Generic::on_input_down);
+	slots.connect(CL_Mouse::sig_key_up(),
+		this, &amp;CL_GUIManager_Generic::on_input_up);
+	slots.connect(CL_Mouse::sig_move(),
+		this, &amp;CL_GUIManager_Generic::on_mouse_move);
+	slots.connect(CL_Mouse::sig_key_dblclk(),
+		this, &amp;CL_GUIManager_Generic::on_mouse_dblclk);
+	slots.connect(CL_Display::sig_resize(),
+		this, &amp;CL_GUIManager_Generic::on_resize);
+	slots.connect(CL_Display::sig_paint(),
+		this, &amp;CL_GUIManager_Generic::on_paint);
+}
+
+CL_GUIManager_Generic::~CL_GUIManager_Generic()
+{
+	disable_input();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_GUIManager_Generic attributes:
+
+CL_Component *CL_GUIManager_Generic::get_focus()
+{
+	return comp_focus;
+}
+
+CL_Component *CL_GUIManager_Generic::get_capture()
+{
+	return comp_capture_mouse;
+}
+
+bool CL_GUIManager_Generic::is_input_enabled()
+{
+	return input_enabled;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_GUIManager_Generic operations:
+
+void CL_GUIManager_Generic::set_focus(CL_Component *component)
+{
+	if (component == 0) return;
+	if (comp_focus == component) return;
+
+	CL_Component *old_comp_focus = comp_focus;
+
+	comp_focus = component;
+	if(old_comp_focus)
+		old_comp_focus-&gt;sig_lost_focus()();
+	if(comp_focus)
+		comp_focus-&gt;sig_got_focus()();
+	
+	sig_focus_changed(comp_focus);
+	owner-&gt;update();
+}
+
+void CL_GUIManager_Generic::quit()
+{
+	quit_run = true;
+}
+
+void CL_GUIManager_Generic::run(CL_Component *modal_level)
+{
+	modal_stack.push(modal_level);
+
+	try
+	{
+		quit_run = false;
+		while (!quit_run)
+		{
+			if (update_trigger.get_flag())
+			{
+				update_trigger.reset();
+				show();
+				CL_Display::flip();
+			}
+			CL_System::keep_alive(10);
+		}
+		quit_run = false;
+	}
+	catch (...)
+	{
+		modal_stack.pop();
+		throw;
+	}
+
+	modal_stack.pop();
+}
+
+void CL_GUIManager_Generic::show()
+{
+	owner-&gt;paint();
+}
+
+void CL_GUIManager_Generic::enable_input()
+{
+	input_enabled = true;
+}
+
+void CL_GUIManager_Generic::disable_input()
+{
+	input_enabled = false;
+}
+
+void CL_GUIManager_Generic::gui_capture_mouse(CL_Component *component)
+{
+	comp_capture_mouse = component;
+}
+
+void CL_GUIManager_Generic::gui_release_mouse()
+{
+	comp_capture_mouse = NULL;
+}
+
+void CL_GUIManager_Generic::component_deleted(CL_Component *component)
+{
+	// First try to move focus to someone else:
+	if (component-&gt;get_parent()) owner-&gt;set_focus(component-&gt;get_parent());
+
+	// Make sure we dont crash no matter what:
+	if (comp_focus == component) comp_focus = 0;
+	if (comp_capture_mouse == component) comp_capture_mouse = 0;
+	if (comp_mouse_over == component) comp_mouse_over = 0;
+	if (focus_component == component) focus_component = 0;
+}
+
+CL_Component *CL_GUIManager_Generic::find_focus_component(const CL_InputEvent &amp;key)
+{
+	CL_Component *focus_component = comp_focus;
+
+	if (comp_capture_mouse)
+	{
+		focus_component = comp_capture_mouse;
+	}
+	else if (key.device.get_type() == CL_InputDevice::mouse)
+	{
+	focus_component = owner-&gt;get_component_at(
+			(int)(key.mouse_pos.x - owner-&gt;get_position().left),
+			(int)(key.mouse_pos.y - owner-&gt;get_position().top));
+	}
+
+	// If we are in a modal run, make sure input is mapped to modal tree:
+	if (get_modal_component())
+	{
+		if (focus_component == get_modal_component() ||
+			get_modal_component()-&gt;has_child(focus_component))
+		{
+		}
+		else
+		{
+			focus_component = get_modal_component();
+		}
+	}
+
+	return focus_component;
+}
+
+void CL_GUIManager_Generic::on_input_down(const CL_InputEvent &amp;key)
+{
+	if (!input_enabled) return;
+
+	// Transform from screen coordinates to GUI coordinate.
+	int mouse_x = (int) key.mouse_pos.x;
+	int mouse_y = (int) key.mouse_pos.y;
+	owner-&gt;sig_transform_coords()(mouse_x, mouse_y);
+
+	CL_InputEvent transformed_key = key;
+	transformed_key.mouse_pos.x = mouse_x;
+	transformed_key.mouse_pos.y = mouse_y;
+
+	// Figure out what our focus component is (whom to send message):
+	focus_component = find_focus_component(transformed_key);
+	if (!focus_component)
+		return;
+
+	// If its a mouse click, make the clicked component get focus.
+	if (key.device.get_type() == CL_InputDevice::mouse)
+		if (focus_component-&gt;is_focusable())
+			set_focus(focus_component);
+
+	// If its a tab click, pass on keyboard input to next component.
+	if (key.id == CL_KEY_TAB)
+	{
+		if(key.device.get_keycode(CL_KEY_LSHIFT) || key.device.get_keycode(CL_KEY_RSHIFT))
+			focus_component = tab_previous();
+		else
+			focus_component = tab_next();
+	}
+
+	if (!focus_component)
+		return;
+
+	// If component is disabled, do not send event:
+	if (focus_component-&gt;is_enabled() == false || focus_component-&gt;is_visible() == false)
+		return;
+
+	// Make coordinates relative to focus component.
+	transformed_key.mouse_pos.x -= focus_component-&gt;get_screen_rect().left;
+	transformed_key.mouse_pos.y -= focus_component-&gt;get_screen_rect().top;
+
+	// Send input down event:
+	focus_component-&gt;sig_input_down()(transformed_key);
+	if (focus_component == 0) return; // component was deleted.
+
+	// Send key down event:
+	if(key.device.get_type() == CL_InputDevice::keyboard)
+		focus_component-&gt;sig_key_down()(transformed_key);
+
+	// Send mouse down event:
+	if(key.device.get_type() == CL_InputDevice::mouse)
+		focus_component-&gt;sig_mouse_down()(transformed_key);
+}
+
+void CL_GUIManager_Generic::on_mouse_dblclk(const CL_InputEvent &amp;key)
+{
+	if (!input_enabled) return;
+
+	// Transform from screen coordinates to GUI coordinate.
+	int mouse_x = (int) key.mouse_pos.x;
+	int mouse_y = (int) key.mouse_pos.y;
+	owner-&gt;sig_transform_coords()(mouse_x, mouse_y);
+
+	CL_InputEvent transformed_key = key;
+	transformed_key.mouse_pos.x = mouse_x;
+	transformed_key.mouse_pos.y = mouse_y;
+
+	// Figure out what our focus component is (whom to send message):
+	focus_component = find_focus_component(transformed_key);
+	if (!focus_component)
+		return;
+
+	// If its a mouse click, make the clicked component get focus.
+	if (focus_component-&gt;is_focusable())
+		set_focus(focus_component);
+
+	// If component is disabled, do not send event:
+	if (focus_component-&gt;is_enabled() == false || focus_component-&gt;is_visible() == false)
+		return;
+
+	// Make coordinates relative to focus component.
+	transformed_key.mouse_pos.x -= focus_component-&gt;get_screen_rect().left;
+	transformed_key.mouse_pos.y -= focus_component-&gt;get_screen_rect().top;
+
+	// Send input down event:
+	focus_component-&gt;sig_input_down()(transformed_key);
+	if (focus_component == 0) return; // component was deleted.
+
+	transformed_key.repeat_count = 2;
+
+	// Send mouse down event:
+	focus_component-&gt;sig_mouse_dblclk()(transformed_key);
+}
+
+void CL_GUIManager_Generic::on_input_up(const CL_InputEvent &amp;key)
+{
+	if (!input_enabled) return;
+
+	// Do not pass tab support down through the gui:
+	if (key.id == CL_KEY_TAB) return;
+
+	// Transform from screen coordinates to GUI coordinate.
+	int mouse_x = (int) key.mouse_pos.x;
+	int mouse_y = (int) key.mouse_pos.y;
+	owner-&gt;sig_transform_coords()(mouse_x, mouse_y);
+
+	CL_InputEvent transformed_key = key;
+	transformed_key.mouse_pos.x = mouse_x;
+	transformed_key.mouse_pos.y = mouse_y;
+
+	// Figure out what our focus component is (whom to send message):
+	focus_component = find_focus_component(transformed_key);
+	if (!focus_component)
+		return;
+
+	// Make coordinates relative to focus component.
+	transformed_key.mouse_pos.x -= focus_component-&gt;get_screen_rect().left;
+	transformed_key.mouse_pos.y -= focus_component-&gt;get_screen_rect().top;
+
+	// Send input up event:
+	focus_component-&gt;sig_input_up()(transformed_key);
+	if (focus_component == 0) return; // component was deleted.
+
+	// Send key up event:
+	if(key.device.get_type() == CL_InputDevice::keyboard)
+		focus_component-&gt;sig_key_up()(transformed_key);
+
+	// Send mouse up event:
+	if(key.device.get_type() == CL_InputDevice::mouse)
+		focus_component-&gt;sig_mouse_up()(transformed_key);
+}
+
+void CL_GUIManager_Generic::on_mouse_move(const CL_InputEvent &amp;key)
+{
+	if (!input_enabled) return;
+
+	int x = key.mouse_pos.x;
+	int y = key.mouse_pos.y;
+	
+	owner-&gt;sig_transform_coords()(x, y);
+
+	CL_Component *over_component = owner-&gt;get_component_at(
+			x - owner-&gt;get_position().left,
+			y - owner-&gt;get_position().top);
+
+	focus_component = comp_capture_mouse;
+	if (!comp_capture_mouse) focus_component = over_component;
+
+/*	CL_Component *focus_component = over_component;
+	if (comp_capture_mouse)
+		if(!comp_capture_mouse-&gt;has_child(over_component))
+			focus_component = comp_capture_mouse;
+*/	
+
+	if (!focus_component) return;
+
+	// Make coordinates relative to focus component.
+	x -= focus_component-&gt;get_screen_rect().left;
+	y -= focus_component-&gt;get_screen_rect().top;
+
+	// Send mouse enter and mouse leave signals:
+	do_mouse_enter_leave(x, y, over_component);
+
+	if (focus_component == 0) return; // component was deleted.
+
+	CL_InputEvent new_key = key;
+	new_key.mouse_pos.x = x;
+	new_key.mouse_pos.y = y;
+	focus_component-&gt;sig_mouse_move()(new_key);
+}
+
+void CL_GUIManager_Generic::do_mouse_enter_leave(int x, int y, CL_Component *new_focus)
+{
+	CL_Component *old_focus = comp_mouse_over;
+	if (x &lt; 0 || y &lt; 0 || x &gt;= new_focus-&gt;get_width() || y &gt;= new_focus-&gt;get_height()) new_focus = 0;
+
+	// No signals needed if same component kept focus.
+	if (old_focus == new_focus) return;
+
+	if (old_focus)
+	{
+		old_focus-&gt;impl-&gt;mouse_over = false;
+		old_focus-&gt;sig_mouse_leave()();
+		if (focus_component == 0) return; // component was deleted.
+	}
+	if (new_focus)
+	{
+		new_focus-&gt;impl-&gt;mouse_over = true;
+		new_focus-&gt;sig_mouse_enter()();
+		if (focus_component == 0) return; // component was deleted.
+	}
+
+	comp_mouse_over = new_focus;
+}
+
+void CL_GUIManager_Generic::on_resize(int width, int height)
+{
+	owner-&gt;set_size(width, height);
+}
+
+void CL_GUIManager_Generic::on_paint(const CL_Rect &amp;rect)
+{
+	owner-&gt;update();
+}
+
+CL_Component *CL_GUIManager_Generic::tab_next()
+{
+	// First try to find component by tab id:
+	CL_Component *tab_component = owner-&gt;find_tab_id(++current_tab_id);
+	if (tab_component == 0) // reached end, start from beginning
+	{
+		current_tab_id = 0;
+		tab_component = owner-&gt;find_tab_id(current_tab_id);
+	}
+	if (tab_component)
+	{
+		set_focus(tab_component);
+		return comp_focus;
+	}
+
+	if(comp_focus == 0)
+		return 0;
+		
+	// No tab ids - fall back to tree walking:
+	if (comp_focus-&gt;get_children().empty()) // tab to sibling or uncle
+	{
+		CL_Component *cur = comp_focus;
+
+		while (true)
+		{
+			CL_Component *parent = cur-&gt;get_parent();
+			if (parent == 0) break;
+
+			// Search siblings:
+			std::list&lt;CL_Component *&gt;::const_iterator it;
+			for (it = parent-&gt;get_children().begin(); it != parent-&gt;get_children().end(); it++)
+			{
+				if (*it == cur)
+				{
+					it++;
+
+					// no more siblings
+					if (it == parent-&gt;get_children().end()) break;
+
+					// give sibling focus
+					set_focus(*it);
+					return comp_focus;
+				}
+			}
+
+			// Was last sibling, continue search in parent (uncles)
+			cur = parent;
+		}
+
+		// if we are top node (no siblings), and got no children:
+		if (cur == comp_focus) return comp_focus;
+
+		// walked through all components. Restart at first component:
+		set_focus(owner);
+		return comp_focus;
+	}
+	else // tab to children
+	{
+		// give first child focus
+		set_focus(comp_focus-&gt;get_children().front());
+		return comp_focus;
+	}
+}
+
+CL_Component *CL_GUIManager_Generic::tab_previous()
+{
+	// First try to find component by tab id:
+	CL_Component *tab_component = owner-&gt;find_tab_id(--current_tab_id);
+	if (current_tab_id == -1) // reached beginning, start from end
+	{
+		current_tab_id = find_highest_tab_id(owner);
+		tab_component = owner-&gt;find_tab_id(current_tab_id);
+	}
+	if (tab_component)
+	{
+		set_focus(tab_component);
+		return comp_focus;
+	}
+
+	if(comp_focus == 0)
+		return 0;
+
+	// No tab ids - fall back to tree walking:
+	CL_Component *cur = comp_focus;
+	while (true)
+	{
+		CL_Component *parent = cur-&gt;get_parent();
+		if (parent == 0) break;
+
+		// Search siblings:
+		std::list&lt;CL_Component *&gt;::const_iterator it;
+		for (it = parent-&gt;get_children().begin(); it != parent-&gt;get_children().end(); it++)
+		{
+			if (*it == cur)
+			{
+				// no more siblings
+				if (it == parent-&gt;get_children().begin()) break;
+
+				it--;
+
+				// give sibling focus
+				set_focus(*it);
+				return comp_focus;
+			}
+		}
+
+		// Was last sibling, continue search in parent (uncles)
+		cur = parent;
+	}
+
+	// walked through all components. Restart at end component:
+	cur = owner;
+	while (!cur-&gt;get_children().empty()) cur = cur-&gt;get_children().back();
+	set_focus(cur);
+	return comp_focus;
+}
+
+#define cl_max(a,b) ((a &gt; b) ? a : b)
+
+int CL_GUIManager_Generic::find_highest_tab_id(const CL_Component *component)
+{
+	int id = cl_max(0, component-&gt;get_tab_id());
+	const std::list&lt;CL_Component *&gt; &amp;children = component-&gt;get_children();
+	std::list&lt;CL_Component *&gt;::const_iterator it;
+	for (it = children.begin(); it != children.end(); it++)
+	{
+		id = cl_max(id, find_highest_tab_id(*it));
+	}
+	return id;
+}
+
+CL_Component *CL_GUIManager_Generic::get_modal_component() const
+{
+	if (modal_stack.empty()) return 0;
+	return modal_stack.top();
+}

Added: trunk/clanlib/GUI/gui_manager_generic.h
===================================================================
--- trunk/clanlib/GUI/gui_manager_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/gui_manager_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,116 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_guimanager_generic
+#define header_guimanager_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/GUI/gui_manager.h&quot;
+#include &quot;API/signals.h&quot;
+#include &quot;API/Core/System/event_trigger.h&quot;
+#include &lt;stack&gt;
+
+class CL_InputDevice;
+class CL_InputEvent;
+
+class CL_GUIManager_Generic
+{
+//! Construction:
+public:
+	CL_GUIManager_Generic(CL_GUIManager *owner);
+	~CL_GUIManager_Generic();
+
+//! Attributes:
+public:
+	CL_Component *get_focus();
+
+	CL_Component *get_capture();
+
+	bool is_input_enabled();
+
+	CL_EventTrigger update_trigger;
+
+//! Operations:
+public:
+	void run(CL_Component *modal_level);
+	void show();
+	void quit();
+
+	void enable_input();
+	void disable_input();
+	
+	void gui_capture_mouse(CL_Component *component);
+	void gui_release_mouse();
+
+	void set_focus(CL_Component *component);
+
+	void component_deleted(CL_Component *component);
+	CL_Component *get_modal_component() const;
+	
+//! Signals:
+public:
+	CL_Signal_v1 &lt;CL_Component *&gt; sig_focus_changed;
+	
+//! Implementation:
+private:
+	void on_input_up(const CL_InputEvent &amp;key);
+	void on_input_down(const CL_InputEvent &amp;key);
+	void on_mouse_move(const CL_InputEvent &amp;key);
+	void on_mouse_dblclk(const CL_InputEvent &amp;key);
+	void on_resize(int width, int height);
+	void on_paint(const CL_Rect &amp;rect);
+	CL_Component *find_focus_component(const CL_InputEvent &amp;key);
+	void do_mouse_enter_leave(int x, int y, CL_Component *new_focus);
+	CL_Component *tab_next();
+	CL_Component *tab_previous();
+	int find_highest_tab_id(const CL_Component *component);
+
+	CL_SlotContainer slots;
+
+	volatile bool quit_run;
+	CL_GUIManager *owner;
+	bool input_enabled;
+
+	int current_tab_id;
+	CL_Component *comp_focus;
+	CL_Component *comp_capture_mouse;
+	CL_Component *comp_mouse_over;
+
+	//: This is a temporary worker variable for event handlers.
+	//- &lt;p&gt;Only reason this is in the header is because it must be set to null when component_deleted
+	//- is called with the component.&lt;/p&gt;
+	CL_Component *focus_component;
+
+	std::stack&lt;CL_Component *&gt; modal_stack;
+};
+
+#endif

Added: trunk/clanlib/GUI/image.cpp
===================================================================
--- trunk/clanlib/GUI/image.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/image.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,142 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;API/Display/surface.h&quot;
+#include &quot;API/GUI/image.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+#include &quot;API/Display/surface.h&quot;
+#include &quot;image_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_Image::CL_Image(
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(parent, style), impl(NULL)
+{
+	impl = new CL_Image_Generic(this, NULL, false);
+	get_style_manager()-&gt;connect_styles(&quot;image&quot;, this);
+	find_preferred_size();
+}
+
+CL_Image::CL_Image(
+	const CL_Rect &amp;pos,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(pos, parent, style), impl(NULL)
+{
+	impl = new CL_Image_Generic(this, NULL, false);
+	get_style_manager()-&gt;connect_styles(&quot;image&quot;, this);
+}
+
+CL_Image::CL_Image(
+	const CL_Rect &amp;pos,
+	CL_Surface *surface,
+	bool delete_surface,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(pos, parent, style), impl(NULL)
+{
+	impl = new CL_Image_Generic(this, surface, delete_surface);
+	get_style_manager()-&gt;connect_styles(&quot;image&quot;, this);
+}
+
+CL_Image::CL_Image(
+	CL_Surface *surface,
+	bool delete_surface,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(parent, style), impl(NULL)
+{
+	impl = new CL_Image_Generic(this, surface, delete_surface);
+	get_style_manager()-&gt;connect_styles(&quot;image&quot;, this);
+	find_preferred_size();
+}
+
+CL_Image::CL_Image(
+	const CL_Point &amp;pos,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(CL_Rect(pos.x, pos.y, 0, 0), parent, style), impl(NULL)
+{
+	impl = new CL_Image_Generic(this, NULL, false);
+	get_style_manager()-&gt;connect_styles(&quot;image&quot;, this);
+	find_preferred_size();
+}
+
+CL_Image::CL_Image(
+	const CL_Point &amp;pos,
+	CL_Surface *surface,
+	bool delete_surface,	
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(CL_Rect(pos.x, pos.y, 0, 0), parent, style), impl(NULL)
+{
+	impl = new CL_Image_Generic(this, surface, delete_surface);
+	get_style_manager()-&gt;connect_styles(&quot;image&quot;, this);
+	find_preferred_size();
+}
+
+CL_Image::~CL_Image()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+CL_Surface *CL_Image::get_surface() const
+{
+	return impl-&gt;surface;
+}
+
+CL_Image::Mode CL_Image::get_mode() const
+{
+	return impl-&gt;mode;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_Image::set_surface(CL_Surface *surface, bool delete_surface)
+{
+	if(impl-&gt;surface &amp;&amp; impl-&gt;delete_surface)
+		delete impl-&gt;surface;
+		
+	impl-&gt;surface = surface;
+	impl-&gt;delete_surface = delete_surface;
+}
+
+void CL_Image::set_mode(Mode mode)
+{
+	impl-&gt;mode = mode;
+}

Added: trunk/clanlib/GUI/image_generic.cpp
===================================================================
--- trunk/clanlib/GUI/image_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/image_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,56 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;image_generic.h&quot;
+#include &quot;API/Display/surface.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+
+CL_Image_Generic::CL_Image_Generic(CL_Image *self, CL_Surface *surface, bool delete_surface)
+: surface(surface), delete_surface(delete_surface), mode(CL_Image::center), image(self)
+{
+	slot_set_options = image-&gt;sig_set_options().connect(
+		this, &amp;CL_Image_Generic::on_set_options);
+}
+
+CL_Image_Generic::~CL_Image_Generic()
+{
+	if(delete_surface &amp;&amp; surface)
+		delete surface;
+}
+
+void CL_Image_Generic::on_set_options(const CL_DomElement &amp;options)
+{
+	if (options.has_attribute(&quot;surface&quot;))
+	{
+		CL_ResourceManager *resources = image-&gt;get_style_manager()-&gt;get_resources();
+		image-&gt;set_surface(new CL_Surface(options.get_attribute(&quot;surface&quot;), resources), true);
+	}
+}

Added: trunk/clanlib/GUI/image_generic.h
===================================================================
--- trunk/clanlib/GUI/image_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/image_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,62 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_image_generic
+#define header_image_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/GUI/image.h&quot;
+
+class CL_Image_Generic
+{
+//! Construction:
+public:
+	CL_Image_Generic(CL_Image *self, CL_Surface *surface, bool delete_surface);
+	~CL_Image_Generic();
+
+//! Attributes:
+public:
+	CL_Surface *surface;
+	bool delete_surface;
+	
+	CL_Image::Mode mode;
+
+//! Implementation:
+private:
+	CL_Image *image;
+
+	CL_Slot slot_set_options;
+
+	void on_set_options(const CL_DomElement &amp;options);
+};  
+
+#endif

Added: trunk/clanlib/GUI/inputbox.cpp
===================================================================
--- trunk/clanlib/GUI/inputbox.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/inputbox.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,264 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;API/GUI/inputbox.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;inputbox_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_InputBox::CL_InputBox(
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(parent, style), impl(NULL)
+{
+	impl = new CL_InputBox_Generic(this, std::string(), false, false, 0);
+	get_style_manager()-&gt;connect_styles(&quot;inputbox&quot;, this);
+	find_preferred_size();
+}
+
+CL_InputBox::CL_InputBox(
+	const std::string &amp;text,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(parent, style), impl(NULL)
+{
+	impl = new CL_InputBox_Generic(this, text, false, false, 0);
+	get_style_manager()-&gt;connect_styles(&quot;inputbox&quot;, this);
+	find_preferred_size();
+}
+
+CL_InputBox::CL_InputBox(
+	const CL_Rect &amp;pos,
+	const std::string &amp;text,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(pos, parent, style), impl(NULL)
+{
+	impl = new CL_InputBox_Generic(this, text, false, false, 0);
+	get_style_manager()-&gt;connect_styles(&quot;inputbox&quot;, this);
+}
+
+CL_InputBox::CL_InputBox(
+	const CL_Rect &amp;pos,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(pos, parent, style), impl(NULL)
+{
+	impl = new CL_InputBox_Generic(this, &quot;&quot;, false, false, 0);
+	get_style_manager()-&gt;connect_styles(&quot;inputbox&quot;, this);
+}
+
+CL_InputBox::~CL_InputBox()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+int CL_InputBox::get_length() const
+{
+	return impl-&gt;text.size();
+}
+
+const std::string &amp;CL_InputBox::get_text() const
+{
+	return impl-&gt;text;
+}
+
+std::string CL_InputBox::get_marked_text() const
+{
+	return impl-&gt;get_marked_text();
+}
+
+bool CL_InputBox::has_marked_text() const
+{
+	return (get_selection_length() &gt; 0);
+}
+
+int CL_InputBox::get_selection_start() const
+{
+	return impl-&gt;get_selection_start();
+}
+
+int CL_InputBox::get_selection_length() const
+{
+	return impl-&gt;get_selection_length();
+}
+
+int CL_InputBox::get_max_length() const
+{
+	return impl-&gt;max_length;
+}
+
+bool CL_InputBox::in_password_mode() const
+{
+	return impl-&gt;password_mode;
+}
+
+bool CL_InputBox::is_read_only() const
+{
+	return impl-&gt;read_only;
+}
+
+int CL_InputBox::get_cursor_position() const
+{
+	return impl-&gt;cursor_position;
+}
+
+bool CL_InputBox::is_edited() const
+{
+	return impl-&gt;edited;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_InputBox::set_text(const std::string &amp;text)
+{
+	impl-&gt;set_text(text);
+}
+
+void CL_InputBox::set_text(int number)
+{
+	impl-&gt;set_text(CL_String::format(&quot;%1&quot;, number));
+}
+
+void CL_InputBox::set_text(double number)
+{
+	impl-&gt;set_text(CL_String::format(&quot;%1&quot;, number));
+}
+
+void CL_InputBox::set_max_length(int length)
+{
+	impl-&gt;set_max_length(length);
+}
+
+void CL_InputBox::set_password_mode(bool enable)
+{
+	impl-&gt;password_mode = enable;
+}
+
+void CL_InputBox::set_read_only(bool enable)
+{
+	impl-&gt;read_only = enable;
+}
+
+void CL_InputBox::select_all()
+{
+	impl-&gt;select_all();
+}
+
+void CL_InputBox::deselect()
+{
+	impl-&gt;deselect();
+}
+
+void CL_InputBox::set_selection(int start, int length)
+{
+	impl-&gt;set_selection(start, length);
+}
+
+void CL_InputBox::set_cursor_position(int pos)
+{
+	impl-&gt;set_cursor_position(pos);
+}
+
+void CL_InputBox::clear()
+{
+	impl-&gt;set_text(&quot;&quot;);
+}
+
+void CL_InputBox::backspace()
+{
+	impl-&gt;backspace();
+}
+
+void CL_InputBox::del()
+{
+	impl-&gt;del();
+}
+
+void CL_InputBox::cut()
+{
+	impl-&gt;cut();
+}
+
+void CL_InputBox::move_cursor(int delta, bool mark)
+{
+	impl-&gt;move_cursor(delta, mark);
+}
+
+void CL_InputBox::move_cursor_word(int delta, bool mark)
+{
+	impl-&gt;move_cursor_word(delta, mark);
+}
+
+void CL_InputBox::home(bool mark)
+{
+	impl-&gt;home(mark);
+}
+
+void CL_InputBox::end(bool mark)
+{
+	impl-&gt;end(mark);
+}
+
+void CL_InputBox::set_edited(bool on)
+{
+	impl-&gt;edited = on;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Signals:
+
+CL_Signal_v1&lt;const std::string &amp;&gt; &amp;CL_InputBox::sig_changed()
+{
+	return impl-&gt;sig_changed;
+}
+
+CL_Signal_v0 &amp;CL_InputBox::sig_return_pressed()
+{
+	return impl-&gt;sig_return_pressed;
+}
+
+CL_Signal_v0 &amp;CL_InputBox::sig_activity()
+{
+	return impl-&gt;sig_activity;
+}
+
+CL_Signal_v2&lt;char &amp;, bool &amp;&gt; &amp;CL_InputBox::sig_validate_character()
+{
+	return impl-&gt;sig_validate_character;
+}

Added: trunk/clanlib/GUI/inputbox_generic.cpp
===================================================================
--- trunk/clanlib/GUI/inputbox_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/inputbox_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,466 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;inputbox_generic.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;API/Display/keys.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+
+CL_InputBox_Generic::CL_InputBox_Generic(
+	CL_InputBox *self, 
+	const std::string &amp;text,
+	bool password_mode,
+	bool readonly,
+	int maxlength)
+: inputbox(self), password_mode(password_mode), read_only(readonly),
+  max_length(maxlength), text(text)
+{
+	ctrl_down = false;
+	shift_down = false;
+
+	selecting = false;
+	mouse_selecting = false;
+	selection_start = 0;
+	selection_end = 0;
+
+	cursor_position = 0;
+
+	edited = false;
+
+	slot_set_options = inputbox-&gt;sig_set_options().connect(
+		this, &amp;CL_InputBox_Generic::on_set_options);
+	slot_input_down = inputbox-&gt;sig_input_down().connect(
+		this, &amp;CL_InputBox_Generic::on_input_down);
+	slot_input_up = inputbox-&gt;sig_input_up().connect(
+		this, &amp;CL_InputBox_Generic::on_input_up);
+	slot_mouse_move = inputbox-&gt;sig_mouse_move().connect(
+		this, &amp;CL_InputBox_Generic::on_mouse_move);
+}
+
+void CL_InputBox_Generic::on_set_options(const CL_DomElement &amp;options)
+{
+	if (options.has_attribute(&quot;text&quot;))
+		set_text(options.get_attribute(&quot;text&quot;));
+	if (options.has_attribute(&quot;passwordmode&quot;))
+		password_mode = CL_String::to_bool(options.get_attribute(&quot;passwordmode&quot;));
+	if (options.has_attribute(&quot;read_only&quot;))
+		read_only = CL_String::to_bool(options.get_attribute(&quot;read_only&quot;));
+	if (options.has_attribute(&quot;max_length&quot;))
+		set_max_length(CL_String::to_int(options.get_attribute(&quot;max_length&quot;)));
+}
+
+void CL_InputBox_Generic::on_input_down(const CL_InputEvent &amp;key)
+{
+	// Start selecting with mouse?
+	if(key.id == CL_MOUSE_LEFT)
+	{
+		cursor_position = text.size();
+		selecting = false;
+		selection_start = -1;
+		selection_end = -1;
+//		cursor_position = get_mouse_position(key.x, key.y);
+/*		mouse_selecting = true;
+		selecting = true;
+		selection_start = cursor_position;
+		inputbox-&gt;capture_mouse();
+*/		return;
+	}
+
+	// Keyboard?
+	if(key.device.get_type() != CL_InputDevice::keyboard)
+		return;
+
+	switch (key.id)
+	{
+	case CL_KEY_DELETE:
+		if (!read_only)del();
+		break;
+	case CL_KEY_BACKSPACE:
+		if (!read_only)backspace();
+		break;
+	case CL_KEY_END:
+		check_selection();	
+		end(selecting);
+		break;
+	case CL_KEY_HOME:
+		check_selection();	
+		home(selecting);
+		break;
+	case CL_KEY_LEFT:
+		check_selection();	
+//		if (ctrl_down)
+//			word_left();
+//		else
+			move_cursor(-1, selecting);
+		break;
+	case CL_KEY_RIGHT:
+		check_selection();	
+//		if (ctrl_down)
+//			word_right();
+//		else
+			move_cursor(1, selecting);
+		break;
+	case CL_KEY_RETURN:
+		if (!read_only)sig_return_pressed();
+//		inputbox-&gt;clear_focus();
+		break;
+	case CL_KEY_CONTROL:
+		ctrl_down = true;
+		break;
+	case CL_KEY_SHIFT:
+		shift_down = true;
+		break;
+	default:
+		if (!read_only)update_text(key);
+		break;
+	}
+}
+
+void CL_InputBox_Generic::on_input_up(const CL_InputEvent &amp;key)
+{
+	// End mouse-selecting
+	if(key.id == CL_MOUSE_LEFT)
+	{
+/*		cursor_position = get_mouse_position(key.x, key.y);
+		if (mouse_selecting &amp;&amp; cursor_position == selection_start)
+			selecting = false;
+		mouse_selecting = false;
+		inputbox-&gt;release_mouse();
+*/		return;
+	}
+
+	switch (key.id)
+	{
+	case CL_KEY_CONTROL:
+		ctrl_down = false;
+		break;
+	case CL_KEY_SHIFT:
+		shift_down = false;
+		break;
+	}
+}
+
+void CL_InputBox_Generic::on_mouse_move(const CL_InputEvent &amp;key)
+{
+	if (mouse_selecting)
+		set_cursor_position(get_mouse_position(key.mouse_pos.x, key.mouse_pos.y));
+}
+
+void CL_InputBox_Generic::check_selection()
+{
+	if(shift_down)
+	{
+		if(selecting == false)
+		{
+			selecting = true;
+			selection_start = cursor_position;
+		}
+	}
+	else
+	{
+		selecting = false;
+		selection_start = -1;
+		selection_end = -1;
+	}
+}
+
+void CL_InputBox_Generic::set_text(const std::string &amp;new_text)
+{
+	// TODO: Check against max_length
+
+	text = new_text;
+	selecting = false;
+	selection_start = -1;
+	selection_end = -1;
+	cursor_position = text.size();
+}
+
+std::string CL_InputBox_Generic::get_marked_text() const
+{
+	// Added by E.R. Ylvisaker on 11/19/05
+	if (!selecting)
+	{
+		return &quot;&quot;;
+	}
+	else
+	{
+		return text.substr(selection_start, selection_end - selection_start);
+	}
+
+	//throw CL_Error(&quot;CL_InputBox_Generic::get_marked_text() is not implemented&quot;);
+}
+
+void CL_InputBox_Generic::set_max_length(int length)
+{
+	max_length = length;
+	int text_size = text.size();
+
+	if (text_size &gt; max_length &amp;&amp; max_length != 0)
+		text.erase(max_length, text.size());
+}
+
+void CL_InputBox_Generic::select_all()
+{
+	// Added by E.R. Ylvisaker on 11/19/05
+	if (text.size() &gt; 0)
+	{
+		selecting = true;
+		selection_start = 0;
+		selection_end = text.size();
+	}
+	
+	//throw CL_Error(&quot;CL_InputBox_Generic::select_all() is not implemented&quot;);
+}
+
+void CL_InputBox_Generic::deselect()
+{
+	// Added by E.R. Ylvisaker on 11/19/05
+	selecting = false;
+	selection_start = -1;
+	selection_end = -1;
+
+//	throw CL_Error(&quot;CL_InputBox_Generic::deselect() is not implemented&quot;);
+}
+
+void CL_InputBox_Generic::set_selection(int start, int length)
+{
+	// Added by E.R. Ylvisaker on 11/19/05
+	if (start &lt; 0) start = 0;
+	if (start + length &gt; (signed) text.size()) length = text.size() - start;
+
+	if (length &gt; 0)
+	{
+		selecting = true;
+		selection_start = start;
+		selection_end = start + length;
+	}
+	else if (length &lt; 0)
+	{
+		selecting = true;
+		selection_start = start - length;
+		selection_end = start;
+
+		if (selection_start &lt; 0)
+			selection_start = 0;
+
+	}
+	else
+	{
+		selecting = false;
+	}
+
+	//throw CL_Error(&quot;CL_InputBox_Generic::set_selection() is not implemented&quot;);
+}
+
+void CL_InputBox_Generic::set_cursor_position(int pos)
+{
+	cursor_position = pos;
+	if(cursor_position &lt; 0)
+		cursor_position = 0;
+	if(cursor_position &gt; max_length - 1 &amp;&amp; max_length != 0)
+		cursor_position = max_length - 1;
+	if(cursor_position &gt; (signed) text.size())
+		cursor_position = text.size();
+}
+
+void CL_InputBox_Generic::del()
+{
+	if (selecting)
+		cut();
+	else if (cursor_position &lt; (int)text.size())
+	{
+		text.erase(cursor_position, 1);
+		sig_changed(text);
+	}
+
+	sig_activity();
+}
+
+void CL_InputBox_Generic::backspace()
+{
+	if (selecting)
+		cut();
+	else if (cursor_position &gt; 0)
+	{
+		text.erase(cursor_position - 1, 1);
+		cursor_position--;
+		sig_changed(text);
+	}
+
+	sig_activity();
+}
+
+void CL_InputBox_Generic::home(bool mark)
+{
+	if(mark)
+	{
+		selecting = true;
+		selection_start = cursor_position;
+		selection_end = 0;
+	}
+
+	cursor_position = 0;
+
+	sig_activity();
+}
+
+void CL_InputBox_Generic::end(bool mark)
+{
+	if(mark)
+	{
+		selecting = true;
+		selection_start = cursor_position;
+		selection_end = text.size();
+	}
+
+	cursor_position = text.size();
+
+	sig_activity();
+}
+
+void CL_InputBox_Generic::move_cursor(int delta, bool mark)
+{
+	cursor_position += delta;
+
+	// Check bounds
+	if (cursor_position &lt; 0) cursor_position = 0;
+	if (cursor_position &gt; (int)text.size()) cursor_position = (int)text.size();
+
+	if(mark)
+		selection_end = cursor_position;
+
+	sig_activity();
+}
+
+void CL_InputBox_Generic::move_cursor_word(int delta, bool mark)
+{
+	throw CL_Error(&quot;CL_InputBox_Generic::move_cursor_word() is not implemented&quot;);
+/*
+		if (ctrl_down)
+		{
+			while (caret_position &gt; 0 &amp;&amp; text[caret_position] == ' ') caret_position--;
+			while (caret_position &gt; 0 &amp;&amp; text[caret_position] != ' ') caret_position--;
+		}
+		if (ctrl_down)
+		{
+			while (caret_position &lt; (int)text.size() &amp;&amp; text[caret_position] == ' ') caret_position++;
+			while (caret_position &lt; (int)text.size() &amp;&amp; text[caret_position] != ' ') caret_position++;
+		}
+		sig_activity();
+*/
+}
+
+void CL_InputBox_Generic::cut()
+{
+	if(selecting) 
+	{
+		int start = get_selection_start();
+		int end = get_selection_length();
+		text.erase(start, end);
+		cursor_position = start;
+
+		selecting = false;
+		selection_start = selection_end = -1;
+
+		if (cursor_position &gt; (int)text.size())
+			cursor_position = (int)text.size();
+
+		sig_changed(text);
+	}
+}
+
+int CL_InputBox_Generic::get_selection_start()
+{
+	if(selection_start &lt; selection_end)
+		return selection_start;
+	else
+		return selection_end;
+}
+
+int CL_InputBox_Generic::get_selection_length()
+{
+	return abs(selection_start - selection_end);
+}
+
+void CL_InputBox_Generic::update_text(CL_InputEvent key)
+{
+	if (!key.str.empty())
+	{
+		bool changed = false;
+		for(unsigned int i=0; i&lt;key.str.length(); ++i)
+		{
+			if (key.str[i] &gt; 31)
+			{
+				char character = key.str[i];
+				bool accept = true;
+				sig_validate_character(character, accept);
+				if (accept)
+				{
+					if(changed == false)
+					{
+						cut();
+						changed = true;
+					}
+				
+					text.insert(text.begin() + cursor_position, character);
+					cursor_position++;
+				}
+			}
+		}
+		
+		if(changed)
+		{
+			sig_changed(text);
+			sig_activity();
+		}
+	}
+}
+
+int CL_InputBox_Generic::get_mouse_position(int x, int y)
+{
+/*	int delta_x = x - X_TEXTOFFSET;
+	unsigned int i;
+	for (i = 0; i &lt; text.size(); i++)
+	{
+		char buf[2];
+		buf[0] = text[i];
+		buf[1] = 0;
+		int w = fnt_inputbox-&gt;get_text_width(buf);
+		delta_x -= w;
+		if (delta_x &lt;= -w/2)
+		{
+				return i + last_offset;
+		}
+	}
+	return i;
+*/
+	return text.size() - 1;
+}

Added: trunk/clanlib/GUI/inputbox_generic.h
===================================================================
--- trunk/clanlib/GUI/inputbox_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/inputbox_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,110 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_inputbox_generic
+#define header_inputbox_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/GUI/inputbox.h&quot;
+#include &lt;string&gt;
+
+class CL_InputBox_Generic
+{
+public:
+	CL_InputBox_Generic(
+		CL_InputBox *self,
+		const std::string &amp;text,
+		bool password_mode,
+		bool readonly,
+		int maxlength);
+
+	CL_InputBox *inputbox;
+
+	bool password_mode;
+	bool read_only;
+
+	bool edited;
+
+	int cursor_position;
+
+	int max_length;
+
+	std::string text;
+
+	CL_Signal_v1&lt;const std::string &amp;&gt; sig_changed;
+	CL_Signal_v0 sig_return_pressed;
+	CL_Signal_v0 sig_activity;
+	CL_Signal_v2&lt;char &amp;, bool &amp;&gt; sig_validate_character;
+
+	CL_Slot slot_set_options;
+	CL_Slot slot_input_down;
+	CL_Slot slot_input_up;
+	CL_Slot slot_mouse_move;
+
+	void on_set_options(const CL_DomElement &amp;options);
+	void on_input_down(const CL_InputEvent &amp;key);
+	void on_input_up(const CL_InputEvent &amp;key);
+	void on_mouse_move(const CL_InputEvent &amp;key);
+
+	void set_text(const std::string &amp;text);
+	std::string get_marked_text() const;
+	void set_max_length(int length);
+	void select_all();
+	void deselect();
+	void set_selection(int start, int length);
+	void set_cursor_position(int pos);
+	void backspace();
+	void del();
+	void cut();
+	void move_cursor(int delta, bool mark);
+	void move_cursor_word(int delta, bool mark);
+	void home(bool mark);
+	void end(bool mark);
+	int get_selection_start();
+	int get_selection_length();
+
+private:
+	bool selecting;
+	bool mouse_selecting;
+	int selection_start;
+	int selection_end;
+
+	bool ctrl_down;
+	bool shift_down;
+
+	void check_selection();
+
+	void update_text(CL_InputEvent key);
+	int get_mouse_position(int x, int y);
+};
+
+#endif

Added: trunk/clanlib/GUI/inputdialog.cpp
===================================================================
--- trunk/clanlib/GUI/inputdialog.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/inputdialog.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,81 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &lt;string&gt;
+#include &quot;API/GUI/inputdialog.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+#include &quot;API/GUI/gui_manager.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;inputdialog_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_InputDialog::CL_InputDialog(
+	const std::string &amp;title,
+	const std::string &amp;button1,
+	const std::string &amp;button2,
+	const std::string &amp;button3,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Window(parent, style), impl(0)
+{
+	impl = new CL_InputDialog_Generic(this, title, button1, button2, button3);
+}
+
+CL_InputDialog::~CL_InputDialog()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+CL_Button * CL_InputDialog::get_button(int button)
+{
+	return impl-&gt;get_button(button);
+}
+
+int CL_InputDialog::get_result_button()
+{
+	return impl-&gt;result_button;
+}
+
+CL_InputBox * CL_InputDialog::add_input_box(const std::string &amp;label,
+	const std::string &amp;default_value, int inputbox_width)
+{
+	return impl-&gt;add_input_box(label, default_value, inputbox_width);
+}
+
+CL_CheckBox * CL_InputDialog::add_check_box(const std::string &amp;text,
+		bool enabled, int check_box_width)
+{
+	return impl-&gt;add_check_box(text, enabled, check_box_width);
+}

Added: trunk/clanlib/GUI/inputdialog_generic.cpp
===================================================================
--- trunk/clanlib/GUI/inputdialog_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/inputdialog_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,337 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;inputdialog_generic.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;API/Core/Resources/resourcetype_integer.h&quot;
+#include &quot;API/Core/Resources/resourcetype_boolean.h&quot;
+
+CL_InputDialog_Generic::CL_InputDialog_Generic(
+	CL_InputDialog *self,
+	const std::string &amp;title,
+	const std::string &amp;button1,
+	const std::string &amp;button2,
+	const std::string &amp;button3)
+:
+	inputdialog(self),
+	result_button(-1)
+{
+	CL_ResourceManager * resources = inputdialog-&gt;get_style_manager()-&gt;get_resources();
+
+	bool const is_fixed_size_buttons = CL_Boolean(&quot;InputDialog/fixed_size_buttons&quot;,
+		resources, false);
+	int min_button_width = CL_Integer(&quot;InputDialog/min_button_width&quot;,
+		resources, 80);
+	int min_button_height = CL_Integer(&quot;InputDialog/min_button_height&quot;,
+		resources, 20);
+
+	int width = CL_Integer(&quot;InputDialog/min_width&quot;, resources, 150);
+
+	// Calculating height of text
+	int height = 0;
+
+	inputdialog-&gt;set_title(title);
+
+	// We need to know how many space get client_area in 
+	// CL_Window, and then we can calculate offsets from edges
+	CL_Rect const msgbox_rc(
+		CL_Display::get_width()  / 2 - 400 / 2,
+		CL_Display::get_height() / 2 - 400 / 2,
+		CL_Display::get_width()  / 2 + 400 / 2,
+		CL_Display::get_height() / 2 + 400 / 2);
+
+	inputdialog-&gt;set_position(msgbox_rc);
+
+	CL_Rect const client_area_rc =
+		inputdialog-&gt;get_client_area()-&gt;get_position();
+
+	// Now calculate edges offsets
+	int const left_edge_offset   = client_area_rc.left;
+	int const top_edge_offset    = client_area_rc.top;
+	int const right_edge_offset  = msgbox_rc.right - client_area_rc.right - msgbox_rc.left;
+	int const bottom_edge_offset = msgbox_rc.bottom - client_area_rc.bottom - msgbox_rc.top; 	int num_buttons = 0;
+	if (!button1.empty())
+		num_buttons = 1;
+	if (!button2.empty())
+		num_buttons = 2;
+	if (!button3.empty())
+		num_buttons = 3;
+
+	height += space_between_inputbox_and_buttons;
+	int const btn_pos_y = height;
+	height += space_between_buttons_and_bottom;
+
+	switch(num_buttons) {
+	case 1:
+		{
+			if (is_fixed_size_buttons)
+			{
+				button[0] = new CL_Button(
+					CL_Point(width / 2, btn_pos_y),
+					button1,
+					inputdialog-&gt;get_client_area());
+				if (button[0]-&gt;get_width() &gt; min_button_width)
+					min_button_width = button[0]-&gt;get_width();
+				if (button[0]-&gt;get_height() &gt; min_button_height)
+					min_button_height = button[0]-&gt;get_height();
+
+				button[0]-&gt;set_width(min_button_width);
+				button[0]-&gt;set_height(min_button_height);
+			}
+			else
+			{
+				button[0] = new CL_Button(
+					CL_Point(width / 2, btn_pos_y),
+					button1,
+					inputdialog-&gt;get_client_area());
+			}
+
+			if (width &lt; button[0]-&gt;get_width())
+				width = button[0]-&gt;get_width();
+
+			width += space_between_text_and_left_edge + space_between_text_and_right_edge;
+			
+			button[0]-&gt;set_position(
+				width / 2 - button[0]-&gt;get_width() / 2,
+				btn_pos_y);
+
+			slot_button[0] = button[0]-&gt;sig_clicked().connect(
+				this, &amp;CL_InputDialog_Generic::on_button, 0);
+
+			// add buttons height to height
+			height += button[0]-&gt;get_height();
+		}
+		break;
+	case 2:
+		{
+			if (is_fixed_size_buttons)
+			{
+				button[0] = new CL_Button(
+					CL_Point(width / 2, btn_pos_y),
+					button1,
+					inputdialog-&gt;get_client_area());
+				button[1] = new CL_Button(
+					CL_Point(width / 2, btn_pos_y),
+					button2,
+					inputdialog-&gt;get_client_area());
+				
+				// calculate min width and height of buttons,
+				// if some button is bigger than min size
+				for(int i = 0; i &lt; 2; ++i)
+				{
+					if (button[i]-&gt;get_width() &gt; min_button_width)
+						min_button_width = button[i]-&gt;get_width();
+					if (button[i]-&gt;get_height() &gt; min_button_height)
+						min_button_height = button[i]-&gt;get_height();
+				}
+				// set buttons size to max width and height.
+				// and use 'j' for msvc workaround :(
+				for(int j = 0; j &lt; 2; ++j)
+				{
+					button[j]-&gt;set_width(min_button_width);
+					button[j]-&gt;set_height(min_button_height);
+				}
+			}
+			else
+			{
+				button[0] = new CL_Button(
+					CL_Point(width / 2, btn_pos_y),
+					button1,
+					inputdialog-&gt;get_client_area());
+				button[1] = new CL_Button(
+					CL_Point(width / 2, btn_pos_y),
+					button2,
+					inputdialog-&gt;get_client_area());
+			}
+
+			int const total_buttons_size =
+				button[0]-&gt;get_width() +
+				space_between_buttons  +
+				button[1]-&gt;get_width();
+
+			if (width &lt; total_buttons_size)
+				width = total_buttons_size;
+
+			width += space_between_text_and_left_edge + space_between_text_and_right_edge;
+
+			button[0]-&gt;set_position(
+				width / 2 - total_buttons_size / 2,
+				btn_pos_y);
+			button[1]-&gt;set_position(
+				width / 2 - total_buttons_size / 2 +
+				button[0]-&gt;get_width() + space_between_buttons,
+				btn_pos_y);
+
+			slot_button[0] = button[0]-&gt;sig_clicked().connect(
+				this, &amp;CL_InputDialog_Generic::on_button, 0);
+			slot_button[1] = button[1]-&gt;sig_clicked().connect(
+				this, &amp;CL_InputDialog_Generic::on_button, 1);
+
+			// add buttons height to height
+			height += button[0]-&gt;get_height();
+		}
+		break;
+	case 3:
+		{
+			if (is_fixed_size_buttons)
+			{
+				button[0] = new CL_Button(
+					CL_Point(width / 2, btn_pos_y),
+					button1,
+					inputdialog-&gt;get_client_area());
+				button[1] = new CL_Button(
+					CL_Point(width / 2, btn_pos_y),
+					button2,
+					inputdialog-&gt;get_client_area());
+				button[2] = new CL_Button(
+					CL_Point(width / 2, btn_pos_y),
+					button3,
+					inputdialog-&gt;get_client_area());
+				
+				// calculate min width and height of buttons,
+				// if some button is bigger than min size
+				for(int i = 0; i &lt; 3; ++i)
+				{
+					if (button[i]-&gt;get_width() &gt; min_button_width)
+						min_button_width = button[i]-&gt;get_width();
+					if (button[i]-&gt;get_height() &gt; min_button_height)
+						min_button_height = button[i]-&gt;get_height();
+				}
+				// set buttons size to max width and height
+				for(int j = 0; j &lt; 3; ++j)
+				{
+					button[j]-&gt;set_width(min_button_width);
+					button[j]-&gt;set_height(min_button_height);
+				}
+			}
+			else
+			{
+				button[0] = new CL_Button(
+					CL_Point(width / 2, btn_pos_y),
+					button1,
+					inputdialog-&gt;get_client_area());
+				button[1] = new CL_Button(
+					CL_Point(width / 2, btn_pos_y),
+					button2,
+					inputdialog-&gt;get_client_area());
+				button[2] = new CL_Button(
+					CL_Point(width / 2, btn_pos_y),
+					button3,
+					inputdialog-&gt;get_client_area());
+			}
+
+			int const total_buttons_size =
+				button[0]-&gt;get_width() + space_between_buttons +
+				button[1]-&gt;get_width() + space_between_buttons +
+				button[2]-&gt;get_width();
+
+			if (width &lt; total_buttons_size)
+				width = total_buttons_size;
+			
+			width += space_between_text_and_left_edge + space_between_text_and_right_edge;
+
+			button[0]-&gt;set_position(
+				width / 2 - total_buttons_size / 2, btn_pos_y);
+			button[1]-&gt;set_position(
+				width / 2 - total_buttons_size / 2 +
+				button[0]-&gt;get_width() + space_between_buttons,
+				btn_pos_y);
+			button[2]-&gt;set_position(
+				width / 2 - total_buttons_size / 2 +
+					button[0]-&gt;get_width() + space_between_buttons +
+					button[1]-&gt;get_width() + space_between_buttons,
+				btn_pos_y);
+
+			slot_button[0] = button[0]-&gt;sig_clicked().connect(
+				this, &amp;CL_InputDialog_Generic::on_button, 0);
+			slot_button[1] = button[1]-&gt;sig_clicked().connect(
+				this, &amp;CL_InputDialog_Generic::on_button, 1);
+			slot_button[2] = button[2]-&gt;sig_clicked().connect(
+				this, &amp;CL_InputDialog_Generic::on_button, 2);
+
+			// add buttons height to height
+			height += button[0]-&gt;get_height();
+		}
+		break;
+	}
+	button_count = num_buttons;
+
+	// Calc and set real dialog position
+	width += left_edge_offset + right_edge_offset;
+
+	height += top_edge_offset + bottom_edge_offset;
+
+	inputdialog-&gt;set_position(CL_Rect(
+		CL_Display::get_width()  / 2 - width / 2,
+		CL_Display::get_height() / 2 - height / 2,
+		CL_Display::get_width()  / 2 + width / 2,
+		CL_Display::get_height() / 2 + height / 2));
+}
+
+CL_InputDialog_Generic::~CL_InputDialog_Generic()
+{
+	for(int i = 0; i &lt; button_count; ++i)
+		delete button[i];
+	for(size_t j = 0; j &lt; labels.size(); ++j)
+		delete labels[j];
+	for(size_t k = 0; k &lt; components.size(); ++k)
+		delete components[k];
+}
+
+void CL_InputDialog_Generic::on_button(int button)
+{
+	result_button = button;
+	inputdialog-&gt;quit();
+}
+
+CL_Button * CL_InputDialog_Generic::get_button(int button)
+{
+	if (button &gt;= button_count) return NULL; //invalid button
+
+	return this-&gt;button[button];
+}
+
+CL_InputBox * CL_InputDialog_Generic::add_input_box(const std::string &amp;label,
+	const std::string &amp;default_value,
+	int inputbox_width)
+{
+	return (CL_InputBox *) add_component(label, new CL_InputBox(default_value, inputdialog-&gt;get_client_area()), inputbox_width);
+}
+
+CL_CheckBox * CL_InputDialog_Generic::add_check_box(const std::string &amp;text,
+	bool checked,
+	int checkbox_width)
+{
+	CL_CheckBox * checkbox = new CL_CheckBox(text, inputdialog-&gt;get_client_area());
+	checkbox-&gt;set_checked(checked);
+	return (CL_CheckBox *) add_component(&quot;&quot;, checkbox, checkbox_width);
+}

Added: trunk/clanlib/GUI/inputdialog_generic.h
===================================================================
--- trunk/clanlib/GUI/inputdialog_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/inputdialog_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,264 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_inputdialog_generic
+#define header_inputdialog_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/GUI/inputdialog.h&quot;
+#include &quot;API/GUI/button.h&quot;
+#include &quot;API/GUI/label.h&quot;
+#include &quot;API/GUI/inputbox.h&quot;
+#include &quot;API/GUI/checkbox.h&quot;
+#include &quot;API/Display/display.h&quot;
+
+#include &lt;vector&gt;
+
+class CL_Font;
+class CL_InputBox;
+class CL_CheckBox;
+
+class CL_InputDialog_Generic
+{
+public:
+	CL_InputDialog_Generic(
+		CL_InputDialog *self,
+		const std::string &amp;title,
+		const std::string &amp;button1,
+		const std::string &amp;button2,
+		const std::string &amp;button3);
+
+	~CL_InputDialog_Generic();
+
+	CL_InputDialog *inputdialog;
+
+	CL_Button *button[3];
+	int button_count;
+
+	std::vector&lt;CL_Label*&gt; labels;
+	std::vector&lt;CL_Component*&gt; components;
+
+	CL_Slot slot_button[3];
+	
+	CL_Button * get_button(int button);
+	
+	void on_button(int button);
+
+	CL_InputBox * add_input_box(const std::string &amp;label,
+		const std::string &amp;default_value,
+		int component_width);
+
+	CL_CheckBox * add_check_box(const std::string &amp;text,
+		bool checked,
+		int component_width);
+
+	int result_button;
+
+private:
+	enum
+	{
+		space_between_buttons = 10,
+		space_between_title_and_inputbox = 10,
+		space_between_inputboxes = 10,
+		space_between_inputbox_and_buttons = 20,
+		space_between_buttons_and_bottom = 10,
+		space_between_text_and_left_edge = 10,
+		space_between_text_and_right_edge = 10,
+		space_between_label_and_input_box = 10
+	};
+	CL_Component *add_component(const std::string &amp;label, CL_Component * component, int component_width);
+};
+
+inline CL_Component * CL_InputDialog_Generic::add_component(const std::string &amp;label, CL_Component * component, int component_width)
+{
+	int width = inputdialog-&gt;get_client_area()-&gt;get_width() -
+		space_between_text_and_left_edge - space_between_text_and_right_edge;
+	int height = inputdialog-&gt;get_client_area()-&gt;get_height();
+
+	// We need to know how many space get client_area in 
+	// CL_Window, and then we can calculate offsets from edges
+	CL_Rect const msgbox_rc(
+		CL_Display::get_width()  / 2 - 400 / 2,
+		CL_Display::get_height() / 2 - 400 / 2,
+		CL_Display::get_width()  / 2 + 400 / 2,
+		CL_Display::get_height() / 2 + 400 / 2);
+
+	inputdialog-&gt;set_position(msgbox_rc);
+
+	CL_Rect const client_area_rc =
+		inputdialog-&gt;get_client_area()-&gt;get_position();
+
+	// Now calculate edges offsets
+	int const left_edge_offset   = client_area_rc.left;
+	int const top_edge_offset    = client_area_rc.top;
+	int const right_edge_offset  = msgbox_rc.right - client_area_rc.right - msgbox_rc.left;
+	int const bottom_edge_offset = msgbox_rc.bottom - client_area_rc.bottom - msgbox_rc.top;
+
+	// Calculating height of all input boxes, which are allready
+	// in dialog
+
+	if (button_count &gt; 0)
+		// If there some buttons allready, use the button pos to calculate height
+		// of all inputboxes
+		height = button[0]-&gt;get_position().top - space_between_inputbox_and_buttons;
+	else
+		// Otherwise calculate from client_area pos and constants
+		height -= space_between_inputbox_and_buttons + space_between_buttons_and_bottom;
+
+	// If there allready some input boxes, add space between last inputbox
+	if (!components.empty())
+		height += space_between_inputboxes;
+	else
+		height += space_between_title_and_inputbox;
+
+	if (!label.empty())
+		labels.push_back(new CL_Label(
+			CL_Point(space_between_text_and_left_edge, height),
+			label,
+			inputdialog-&gt;get_client_area()));
+
+	int new_input_box_offset = space_between_text_and_left_edge;
+	if (!label.empty())
+		new_input_box_offset += labels.back()-&gt;get_width() +
+			space_between_label_and_input_box;
+
+	// msvc workaround for loop
+	{
+		// Check all other input boxes positions.
+		for(size_t pos = 0; pos &lt; components.size(); ++pos)
+		{
+			if (components[pos]-&gt;get_position().left &gt; new_input_box_offset)
+				new_input_box_offset = components[pos]-&gt;get_position().left;
+		}
+	}
+	
+	// add new input box to InputDialog
+	components.push_back(component);
+
+	components.back()-&gt;set_position(new_input_box_offset, height);
+	components.back()-&gt;set_width(component_width);
+
+	// setting focus on first added input_box
+	if (components.size() == 1)
+		components.back()-&gt;set_focus();
+	
+	if (new_input_box_offset + component_width &gt; width)
+		width = new_input_box_offset + component_width;
+
+	// msvc workaround for loop
+	{
+		// Reposition all input boxes
+		for(size_t pos = 0; pos &lt; components.size(); ++pos)
+		{
+			components[pos]-&gt;set_position(new_input_box_offset,
+				components[pos]-&gt;get_position().top);
+			if (width &lt; components[pos]-&gt;get_position().right)
+				width = components[pos]-&gt;get_position().right;
+		}
+	}
+
+	height += components.back()-&gt;get_height() + space_between_inputbox_and_buttons;
+	int const btn_pos_y = height;
+	height += space_between_buttons_and_bottom;
+
+	width += space_between_text_and_left_edge + space_between_text_and_right_edge;
+
+	switch(button_count) {
+	case 1:
+		{
+			button[0]-&gt;set_position(
+				width / 2 - button[0]-&gt;get_width() / 2,
+				btn_pos_y);
+
+			// add buttons height to height
+			height += button[0]-&gt;get_height();
+		}
+		break;
+	case 2:
+		{
+			int const total_buttons_size =
+				button[0]-&gt;get_width() +
+				space_between_buttons  +
+				button[1]-&gt;get_width();
+
+			button[0]-&gt;set_position(
+				width / 2 - total_buttons_size / 2,
+				btn_pos_y);
+			button[1]-&gt;set_position(
+				width / 2 - total_buttons_size / 2 +
+				button[0]-&gt;get_width() + space_between_buttons,
+				btn_pos_y);
+
+			// add buttons height to height
+			height += button[0]-&gt;get_height();
+		}
+		break;
+	case 3:
+		{
+			int const total_buttons_size =
+				button[0]-&gt;get_width() + space_between_buttons +
+				button[1]-&gt;get_width() + space_between_buttons +
+				button[2]-&gt;get_width();
+
+			button[0]-&gt;set_position(
+				width / 2 - total_buttons_size / 2, btn_pos_y);
+			button[1]-&gt;set_position(
+				width / 2 - total_buttons_size / 2 +
+				button[0]-&gt;get_width() + space_between_buttons,
+				btn_pos_y);
+			button[2]-&gt;set_position(
+				width / 2 - total_buttons_size / 2 +
+					button[0]-&gt;get_width() + space_between_buttons +
+					button[1]-&gt;get_width() + space_between_buttons,
+				btn_pos_y);
+
+			// add buttons height to height
+			height += button[0]-&gt;get_height();
+		}
+		break;
+	}
+
+	// Calc and set real dialog position
+	width += left_edge_offset + right_edge_offset;
+
+	height += top_edge_offset + bottom_edge_offset;
+
+	inputdialog-&gt;set_position(CL_Rect(
+		CL_Display::get_width()  / 2 - width / 2,
+		CL_Display::get_height() / 2 - height / 2,
+		CL_Display::get_width()  / 2 + width / 2,
+		CL_Display::get_height() / 2 + height / 2));
+
+	return components.back();
+}
+
+#endif

Added: trunk/clanlib/GUI/label.cpp
===================================================================
--- trunk/clanlib/GUI/label.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/label.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,152 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/GUI/label.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;label_generic.h&quot;
+#include &quot;component_generic.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_Label::CL_Label(
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(parent, style), impl(NULL)
+{
+	init(&quot;&quot;);
+	find_preferred_size();
+}
+
+CL_Label::CL_Label(
+	const std::string &amp;text,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(parent, style), impl(NULL)
+{
+	init(text);
+	find_preferred_size();
+}
+
+CL_Label::CL_Label(
+	const CL_Point &amp;pos,
+	const std::string &amp;text,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(CL_Rect(pos.x, pos.y, 0, 0), parent, style), impl(NULL)
+{
+	init(text);
+	find_preferred_size();
+}
+
+CL_Label::CL_Label(
+	const CL_Rect &amp;pos,
+	const std::string &amp;text,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(pos, parent, style), impl(NULL)
+{
+	init(text);
+}
+
+void CL_Label::init(const std::string &amp;text)
+{
+	impl = new CL_Label_Generic(this, text);
+	get_style_manager()-&gt;connect_styles(&quot;label&quot;, this);
+	set_focusable(false);
+}
+
+CL_Label::~CL_Label()
+{
+	if (impl-&gt;font == NULL)
+		delete impl-&gt;font;
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+const std::string &amp;CL_Label::get_text() const
+{
+	return impl-&gt;text;
+}
+
+CL_Origin CL_Label::get_alignment() const
+{
+	return impl-&gt;alignment;
+}
+
+CL_Font* CL_Label::get_font()
+{
+	return impl-&gt;font;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_Label::set_text(const std::string &amp;text)
+{
+	impl-&gt;text = text;
+}
+
+void CL_Label::set_text(int number)
+{
+	impl-&gt;text = CL_String::from_int(number);
+}
+
+void CL_Label::set_text(double number)
+{
+	impl-&gt;text = CL_String::from_double(number);
+}
+
+void CL_Label::clear()
+{
+	impl-&gt;text = &quot;&quot;;
+}
+
+void CL_Label::set_alignment(CL_Origin alignment)
+{
+	impl-&gt;alignment = alignment;
+}
+
+void CL_Label::set_font(const CL_Font&amp; f)
+{
+	impl-&gt;font = new CL_Font(f);
+	impl-&gt;sig_font_change();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Signals:
+CL_Signal_v0 &amp;CL_Label::sig_font_change()
+{
+	return impl-&gt;sig_font_change;
+}

Added: trunk/clanlib/GUI/label_generic.cpp
===================================================================
--- trunk/clanlib/GUI/label_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/label_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,51 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;label_generic.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_Label_Generic::CL_Label_Generic(CL_Label *self, const std::string &amp;_text)
+: alignment(origin_top_left), label(self)
+{
+	text = _text;
+	font = NULL;
+	slot_set_options = label-&gt;sig_set_options().connect(
+		this, &amp;CL_Label_Generic::on_set_options);
+}
+
+void CL_Label_Generic::on_set_options(const CL_DomElement &amp;options)
+{
+	if (options.has_attribute(&quot;text&quot;))
+		text = options.get_attribute(&quot;text&quot;);
+}

Added: trunk/clanlib/GUI/label_generic.h
===================================================================
--- trunk/clanlib/GUI/label_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/label_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,66 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_label_generic
+#define header_label_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/GUI/label.h&quot;
+
+class CL_Label_Generic
+{
+//! Construction:
+public:
+	CL_Label_Generic(CL_Label *self, const std::string &amp;text);
+
+//! Attributes:
+public:
+	std::string text;
+
+	CL_Origin alignment;
+	
+	CL_Font *font;
+	
+//! Signals:
+public:
+	CL_Signal_v0 sig_font_change;
+
+//! Implementation:
+private:
+	CL_Label *label;
+
+	CL_Slot slot_set_options;
+
+	void on_set_options(const CL_DomElement &amp;options);
+};  
+
+#endif

Added: trunk/clanlib/GUI/layout.cpp
===================================================================
--- trunk/clanlib/GUI/layout.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/layout.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,117 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/GUI/layout.h&quot;
+#include &quot;layout_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Layout construction:
+
+CL_Layout::CL_Layout()
+{
+}
+
+CL_Layout::CL_Layout(const CL_Layout &amp;copy) : impl(copy.impl)
+{
+}
+
+CL_Layout::CL_Layout(CL_LayoutType type)
+{
+	impl = new CL_Layout_Generic(type);
+}
+
+CL_Layout::~CL_Layout()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Layout operations:
+
+void CL_Layout::set_grid_columns(int columns)
+{
+	if (impl) impl-&gt;grid_columns = columns;
+}
+
+void CL_Layout::set_margin(int margin)
+{
+	if (impl) impl-&gt;margin = margin;
+}
+
+void CL_Layout::set_spacing(int spacing)
+{
+	if (impl) impl-&gt;spacing = spacing;
+}
+
+void CL_Layout::add_component(CL_Component *component)
+{
+	impl-&gt;elements.push_back(new CL_LayoutItem(component));
+}
+
+void CL_Layout::add_component(int index, CL_Component *component)
+{
+	impl-&gt;elements.push_back(new CL_LayoutItem(component));
+}
+
+void CL_Layout::add_component(int col, int row, CL_Component *component, int span)
+{
+	impl-&gt;elements.push_back(new CL_LayoutItem(component));
+}
+
+void CL_Layout::add_layout(const CL_Layout &amp;layout)
+{
+	impl-&gt;elements.push_back(new CL_LayoutItem(layout.impl));
+}
+
+void CL_Layout::add_layout(int index, const CL_Layout &amp;layout)
+{
+	impl-&gt;elements.push_back(new CL_LayoutItem(layout.impl));
+}
+
+void CL_Layout::add_layout(int col, int row, const CL_Layout &amp;layout, int span)
+{
+	impl-&gt;elements.push_back(new CL_LayoutItem(layout.impl));
+}
+
+void CL_Layout::remove_component(CL_Component *component)
+{
+}
+
+void CL_Layout::remove_layout(CL_Layout *layout)
+{
+}
+
+void CL_Layout::set_position(const CL_Rect &amp;pos)
+{
+	if (impl == 0) return;
+	impl-&gt;set_position(pos);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Layout implementation:

Added: trunk/clanlib/GUI/layout_generic.cpp
===================================================================
--- trunk/clanlib/GUI/layout_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/layout_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,282 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;layout_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Layout_Generic construction:
+
+CL_Layout_Generic::CL_Layout_Generic(CL_LayoutType type) : type(type), grid_columns(-1), margin(0), spacing(4)
+{
+}
+
+CL_Layout_Generic::~CL_Layout_Generic()
+{
+	for (std::vector&lt;CL_LayoutItem *&gt;::size_type i = 0; i &lt; elements.size(); i++)
+	{
+		delete elements[i];
+	}
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Layout_Generic attributes:
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Layout_Generic operations:
+
+#define cl_max(a,b) ((a &gt; b) ? a : b)
+
+CL_Size CL_Layout_Generic::get_preferred_size() const
+{
+	CL_Size size(0,0);
+	std::vector&lt;CL_LayoutItem *&gt;::size_type i;
+	for (i=0; i&lt;elements.size(); i++)
+	{
+		CL_Size cur = elements[i]-&gt;get_preferred_size();
+
+		if (type == layout_vertical)
+		{
+			size.width = cl_max(size.width, cur.width);
+			size.height += cur.height;
+			if (i &gt; 0) size.height += spacing;
+		}
+		else if (type == layout_horizontal)
+		{
+			size.width += cur.width;
+			size.height = cl_max(size.height, cur.height);
+			if (i &gt; 0) size.width += spacing;
+		}
+	}
+	size.width += margin*2;
+	size.height += margin*2;
+	return size;
+}
+
+CL_Size CL_Layout_Generic::get_minimum_size() const
+{
+	CL_Size size(0,0);
+	std::vector&lt;CL_LayoutItem *&gt;::size_type i;
+	for (i=0; i&lt;elements.size(); i++)
+	{
+		CL_Size cur = elements[i]-&gt;get_minimum_size();
+
+		if (type == layout_vertical)
+		{
+			size.width = cl_max(size.width, cur.width);
+			size.height += cur.height;
+			if (i &gt; 0) size.height += spacing;
+		}
+		else if (type == layout_horizontal)
+		{
+			size.width += cur.width;
+			size.height = cl_max(size.height, cur.height);
+			if (i &gt; 0) size.width += spacing;
+		}
+	}
+	size.width += margin*2;
+	size.height += margin*2;
+	return size;
+}
+
+CL_Size CL_Layout_Generic::get_maximum_size() const
+{
+	CL_Size size(0,0);
+	std::vector&lt;CL_LayoutItem *&gt;::size_type i;
+	for (i=0; i&lt;elements.size(); i++)
+	{
+		CL_Size cur = elements[i]-&gt;get_maximum_size();
+
+		if (type == layout_vertical)
+		{
+			size.width = cl_max(size.width, cur.width);
+			size.height += cur.height;
+			if (i &gt; 0) size.height += spacing;
+		}
+		else if (type == layout_horizontal)
+		{
+			size.width += cur.width;
+			size.height = cl_max(size.height, cur.height);
+			if (i &gt; 0) size.width += spacing;
+		}
+	}
+	size.width += margin*2;
+	size.height += margin*2;
+	return size;
+}
+
+CL_LayoutPolicy CL_Layout_Generic::get_vertical_policy() const
+{
+	std::vector&lt;CL_LayoutItem *&gt;::size_type i;
+	for (i=0; i&lt;elements.size(); i++)
+	{
+		if (elements[i]-&gt;get_vertical_policy() == layout_expanding) return layout_expanding;
+	}
+	return layout_minimum;
+}
+
+CL_LayoutPolicy CL_Layout_Generic::get_horizontal_policy() const
+{
+	std::vector&lt;CL_LayoutItem *&gt;::size_type i;
+	for (i=0; i&lt;elements.size(); i++)
+	{
+		if (elements[i]-&gt;get_horizontal_policy() == layout_expanding) return layout_expanding;
+	}
+	return layout_minimum;
+}
+
+void CL_Layout_Generic::set_position(const CL_Rect &amp;pos)
+{
+	std::vector&lt;CL_LayoutItem *&gt;::size_type i;
+
+	int minimum_width = 0;
+	int minimum_height = 0;
+	int num_expanding_x = 0;
+	int num_expanding_y = 0;
+
+	for (i=0; i&lt;elements.size(); i++)
+	{
+		if (elements[i]-&gt;get_horizontal_policy() == layout_minimum)
+		{
+			minimum_width += elements[i]-&gt;get_preferred_size().width;
+		}
+		else
+		{
+			num_expanding_x++;
+		}
+
+		if (elements[i]-&gt;get_vertical_policy() == layout_minimum)
+		{
+			minimum_height += elements[i]-&gt;get_preferred_size().height;
+		}
+		else
+		{
+			num_expanding_y++;
+		}
+
+		if (type == layout_horizontal &amp;&amp; i &gt; 0) minimum_width += spacing;
+		if (type == layout_vertical &amp;&amp; i &gt; 0) minimum_height += spacing;
+	}
+
+	int x = pos.left + margin;
+	int y = pos.top + margin;
+	int expandable_width = pos.get_width() - margin*2 - minimum_width;
+	int expandable_height = pos.get_height() - margin*2 - minimum_height;
+
+	// Do vertical and horizontal layout:
+	switch (type)
+	{
+	case layout_vertical:
+		for (i=0; i&lt;elements.size(); i++)
+		{
+			if (elements[i]-&gt;get_vertical_policy() == layout_minimum &amp;&amp; num_expanding_y &gt; 0)
+			{
+				int element_height = elements[i]-&gt;get_preferred_size().height;
+				elements[i]-&gt;set_position(
+					CL_Rect(
+						pos.left+margin,
+						y,
+						pos.right-margin,
+						y+element_height));
+				y += element_height;
+			}
+			else if (num_expanding_y &gt; 0)
+			{
+				int element_height =
+					expandable_height*(i+1)/num_expanding_y - expandable_height*i/num_expanding_y;
+
+				elements[i]-&gt;set_position(
+					CL_Rect(
+						pos.left+margin,
+						y,
+						pos.right-margin,
+						y+element_height));
+				y += element_height;
+			}
+			else
+			{
+				elements[i]-&gt;set_position(
+					CL_Rect(
+						pos.left+margin,
+						pos.top+margin+(pos.get_height()-margin*2)*i/elements.size(),
+						pos.right-margin,
+						pos.top+margin+(pos.get_height()-margin*2)*(i+1)/elements.size()));
+			}
+
+			y += spacing;
+		}
+		break;
+
+	case layout_horizontal:
+		for (i=0; i&lt;elements.size(); i++)
+		{
+			if (elements[i]-&gt;get_horizontal_policy() == layout_minimum &amp;&amp; num_expanding_x &gt; 0)
+			{
+				int element_width = elements[i]-&gt;get_preferred_size().width;
+				elements[i]-&gt;set_position(
+					CL_Rect(
+						x,
+						pos.top+margin,
+						x+element_width,
+						pos.bottom-margin));
+				x += element_width;
+			}
+			else if (num_expanding_x &gt; 0)
+			{
+				int element_width =
+					expandable_width*(i+1)/num_expanding_x - expandable_width*i/num_expanding_x;
+
+				elements[i]-&gt;set_position(
+					CL_Rect(
+						x,
+						pos.top+margin,
+						x+element_width,
+						pos.bottom-margin));
+				x += element_width;
+			}
+			else
+			{
+				elements[i]-&gt;set_position(
+					CL_Rect(
+						pos.left+margin+(pos.get_width()-margin*2)*i/elements.size(),
+						pos.top+margin,
+						pos.left+margin+(pos.get_width()-margin*2)*(i+1)/elements.size(),
+						pos.bottom-margin));
+			}
+
+			x += spacing;
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Layout_Generic implementation:

Added: trunk/clanlib/GUI/layout_generic.h
===================================================================
--- trunk/clanlib/GUI/layout_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/layout_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,82 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_layout_generic
+#define header_layout_generic
+
+#include &quot;API/GUI/layout.h&quot;
+#include &quot;layout_item.h&quot;
+
+class CL_Layout_Generic
+{
+//! Construction:
+public:
+	CL_Layout_Generic(CL_LayoutType type);
+
+	~CL_Layout_Generic();
+
+//! Attributes:
+public:
+	CL_LayoutType type;
+
+	CL_LayoutItem *parent;
+
+	int grid_columns;
+
+	std::vector&lt;CL_LayoutItem *&gt; elements;
+
+	int margin;
+
+	int spacing;
+
+//! Operations:
+public:
+	//: Returns the preferred size of this layout.
+	CL_Size get_preferred_size() const;
+
+	//: Returns the minimum size of this layout.
+	CL_Size get_minimum_size() const;
+
+	//: Returns the maximum size of this layout.
+	CL_Size get_maximum_size() const;
+
+	//: Returns the vertical size policy of this layout.
+	CL_LayoutPolicy get_vertical_policy() const;
+
+	//: Returns the horizontal size policy of this layout.
+	CL_LayoutPolicy get_horizontal_policy() const;
+
+	//: Set layout to use this size and position.
+	void set_position(const CL_Rect &amp;pos);
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/GUI/layout_item.cpp
===================================================================
--- trunk/clanlib/GUI/layout_item.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/layout_item.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,92 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;layout_item.h&quot;
+#include &quot;layout_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_LayoutItem Construction:
+
+CL_LayoutItem::CL_LayoutItem(CL_Component *component) : component(component)
+{
+}
+
+CL_LayoutItem::CL_LayoutItem(CL_SharedPtr&lt;CL_Layout_Generic&gt; layout) : component(0), layout(layout)
+{
+}
+
+CL_LayoutItem::~CL_LayoutItem()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_LayoutItem Attributes:
+
+CL_Size CL_LayoutItem::get_preferred_size() const
+{
+	if (component) return component-&gt;get_preferred_size();
+	return layout-&gt;get_preferred_size();
+}
+
+CL_Size CL_LayoutItem::get_minimum_size() const
+{
+	if (component) return component-&gt;get_minimum_size();
+	return layout-&gt;get_minimum_size();
+}
+
+CL_Size CL_LayoutItem::get_maximum_size() const
+{
+	if (component) return component-&gt;get_maximum_size();
+	return layout-&gt;get_maximum_size();
+}
+
+CL_LayoutPolicy CL_LayoutItem::get_vertical_policy() const
+{
+	if (component) return component-&gt;get_vertical_policy();
+	return layout-&gt;get_vertical_policy();
+}
+
+CL_LayoutPolicy CL_LayoutItem::get_horizontal_policy() const
+{
+	if (component) return component-&gt;get_horizontal_policy();
+	return layout-&gt;get_horizontal_policy();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_LayoutItem Operations:
+
+void CL_LayoutItem::set_position(const CL_Rect &amp;pos)
+{
+	if (component) component-&gt;set_position(pos);
+	else layout-&gt;set_position(pos);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_LayoutItem Implementation:

Added: trunk/clanlib/GUI/layout_item.h
===================================================================
--- trunk/clanlib/GUI/layout_item.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/layout_item.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,91 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_layout_item
+#define header_layout_item
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/GUI/component.h&quot;
+#include &quot;API/Core/System/sharedptr.h&quot;
+
+class CL_Layout_Generic;
+
+//: Layout item in a layout tree.
+class CL_LayoutItem
+{
+//! Construction:
+public:
+	//: Constructs a layout item.
+	CL_LayoutItem(CL_Component *component);
+
+	CL_LayoutItem(CL_SharedPtr&lt;CL_Layout_Generic&gt; layout);
+
+	~CL_LayoutItem();
+
+//! Attributes:
+public:
+	//: Returns the preferred size of this layout item.
+	CL_Size get_preferred_size() const;
+
+	//: Returns the minimum size of this layout item.
+	CL_Size get_minimum_size() const;
+
+	//: Returns the maximum size of this layout item.
+	CL_Size get_maximum_size() const;
+
+	//: Returns the vertical size policy of this layout item.
+	CL_LayoutPolicy get_vertical_policy() const;
+
+	//: Returns the horizontal size policy of this layout item.
+	CL_LayoutPolicy get_horizontal_policy() const;
+
+	//: Component this layout item represents.
+	//- &lt;p&gt;Null if its not a component.&lt;/p&gt;
+	CL_Component *component;
+
+	//: Layout this layout item represents.
+	//- &lt;p&gt;Null if its not a layout.&lt;/p&gt;
+	CL_SharedPtr&lt;CL_Layout_Generic&gt; layout;
+
+//! Operations:
+public:
+	//: Copy assignment operator.
+	CL_LayoutItem &amp;operator =(const CL_LayoutItem &amp;copy);
+
+	//: Set layout item to use this size and position.
+	void set_position(const CL_Rect &amp;pos);
+
+//! Implementation:
+private:
+};
+
+#endif

Added: trunk/clanlib/GUI/listbox.cpp
===================================================================
--- trunk/clanlib/GUI/listbox.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/listbox.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,239 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/GUI/listbox.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;listbox_generic.h&quot;
+#include &quot;component_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_ListBox::CL_ListBox(CL_Component *parent, CL_StyleManager *style)
+: CL_Component(parent, style), impl(0)
+{
+	impl = new CL_ListBox_Generic(this);
+	get_style_manager()-&gt;connect_styles(&quot;listbox&quot;, this);
+	find_preferred_size();
+}
+
+CL_ListBox::CL_ListBox(
+	const CL_Rect &amp;pos,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(pos, parent, style), impl(0)
+{
+	impl = new CL_ListBox_Generic(this);
+	get_style_manager()-&gt;connect_styles(&quot;listbox&quot;, this);
+}
+
+CL_ListBox::~CL_ListBox()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+int CL_ListBox::get_count() const
+{
+	return impl-&gt;items.size();
+}
+
+std::vector&lt;CL_ListItem *&gt; &amp;CL_ListBox::get_items() const
+{
+	return impl-&gt;items;
+}
+
+
+std::vector&lt;std::string&gt; CL_ListBox::get_selected_items() const
+{
+	return impl-&gt;get_selected_items();
+}
+
+const std::string &amp;CL_ListBox::get_current_text() const
+{
+	return impl-&gt;get_current_text();
+}
+
+CL_ListItem *CL_ListBox::get_item(int index) const
+{
+	return impl-&gt;get_item(index);
+}
+
+int CL_ListBox::get_item(const CL_Point &amp;pt)
+{
+	return impl-&gt;get_item(pt);
+}
+
+const std::string &amp;CL_ListBox::get_text(int index) const
+{
+	return impl-&gt;get_text(index);
+}
+
+int CL_ListBox::get_current_item() const
+{
+	return impl-&gt;get_current_item();
+}
+
+bool CL_ListBox::is_selected(int index) const
+{
+	if(index &lt; 0 || index &gt; (int)impl-&gt;items.size())
+		return false;
+		
+	return impl-&gt;items[index]-&gt;selected;
+}
+
+bool CL_ListBox::is_multi_selection() const
+{
+	return impl-&gt;multi_selection;
+}
+
+int CL_ListBox::get_item_height() const
+{
+	return impl-&gt;item_height;
+}
+
+int CL_ListBox::get_top_item() const
+{
+	return impl-&gt;scroll_offset;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+int CL_ListBox::insert_item(CL_ListItem *item, int index, bool delete_item)
+{
+	return impl-&gt;insert_item(item, index, delete_item);
+}
+
+int CL_ListBox::insert_item(const std::string &amp;text, int index)
+{
+	return impl-&gt;insert_item(text, index);
+}
+
+void CL_ListBox::remove_item(int index)
+{
+	impl-&gt;remove_item(index);
+}
+
+void CL_ListBox::change_item(CL_ListItem *item, int index)
+{
+	impl-&gt;change_item(item, index);
+}
+
+void CL_ListBox::change_item(const std::string &amp;text, int index)
+{
+	impl-&gt;change_item(text, index);
+}
+
+void CL_ListBox::set_current_item(int index)
+{
+	impl-&gt;set_current_item(index);
+}
+
+void CL_ListBox::set_selected(int index, bool select)
+{
+	impl-&gt;set_selected(index, select);
+}
+
+void CL_ListBox::clear_selection()
+{
+	impl-&gt;clear_selection();
+}
+
+void CL_ListBox::select_all(bool select)
+{
+	impl-&gt;select_all(select);
+}
+
+void CL_ListBox::invert_selection()
+{
+	impl-&gt;invert_selection();
+}
+
+void CL_ListBox::set_multi_selection(bool enable)
+{
+	impl-&gt;set_multi_selection(enable);
+}
+
+void CL_ListBox::set_item_height(int height)
+{
+	impl-&gt;set_item_height(height);
+}
+
+void CL_ListBox::set_top_item(int index)
+{
+	impl-&gt;set_top_item(index);
+}
+
+void CL_ListBox::sort(bool ascending)
+{
+	impl-&gt;sort(ascending);
+}
+
+void CL_ListBox::clear()
+{
+	impl-&gt;clear();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Signals:
+
+CL_Signal_v1&lt;int&gt; &amp;CL_ListBox::sig_highlighted()
+{
+	return impl-&gt;sig_highlighted;
+}
+
+CL_Signal_v1&lt;int&gt; &amp;CL_ListBox::sig_activated()
+{
+	return impl-&gt;sig_activated;
+}
+
+CL_Signal_v0 &amp;CL_ListBox::sig_selection_changed()
+{
+	return impl-&gt;sig_selection_changed;
+}
+
+CL_Signal_v1&lt;int&gt; &amp;CL_ListBox::sig_item_added()
+{
+	return impl-&gt;sig_item_added;
+}
+
+CL_Signal_v1&lt;int&gt; &amp;CL_ListBox::sig_item_removed()
+{
+	return impl-&gt;sig_item_removed;
+}
+
+CL_Signal_v0 &amp;CL_ListBox::sig_clear()
+{
+	return impl-&gt;sig_clear;
+}

Added: trunk/clanlib/GUI/listbox_generic.cpp
===================================================================
--- trunk/clanlib/GUI/listbox_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/listbox_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,369 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+
+#include &lt;algorithm&gt;
+
+#include &quot;listbox_generic.h&quot;
+#include &quot;API/GUI/listbox.h&quot;
+#include &quot;API/GUI/listitem.h&quot;
+#include &quot;API/GUI/component.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;API/Display/keys.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+
+const static std::string blank;
+
+inline bool list_item_ptr_less(CL_ListItem const * one, CL_ListItem const * two)
+{
+	return *one &lt; *two;
+}
+
+inline bool list_item_ptr_greater(CL_ListItem const * one, CL_ListItem const * two)
+{
+	return *two &lt; *one;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_ListBox_Generic::CL_ListBox_Generic(CL_ListBox *self)
+: listbox(self)
+{
+	scroll_offset = 0;
+	multi_selection = false;
+
+	// Create client area (which is the main listbox)
+	CL_Component *client_area = new CL_Component(listbox);
+	listbox-&gt;set_client_area(client_area);
+
+	slots.connect(client_area-&gt;sig_mouse_dblclk(), this, &amp;CL_ListBox_Generic::on_mouse_down);
+	slots.connect(listbox-&gt;sig_set_options(), this, &amp;CL_ListBox_Generic::on_set_options);
+	slots.connect(client_area-&gt;sig_mouse_down(), this, &amp;CL_ListBox_Generic::on_mouse_down);
+	slots.connect(client_area-&gt;sig_key_up(), this, &amp;CL_ListBox_Generic::on_key_up);
+}
+
+CL_ListBox_Generic::~CL_ListBox_Generic()
+{
+	std::vector&lt;CL_ListItem *&gt;::iterator it;
+	for(it = items.begin(); it != items.end(); ++it)
+		if((*it)-&gt;delete_item)
+			delete (*it);
+
+	delete listbox-&gt;get_client_area();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+std::vector&lt;std::string&gt; CL_ListBox_Generic::get_selected_items() const
+{
+	std::vector&lt;std::string&gt; retval;
+	std::vector&lt;CL_ListItem *&gt;::const_iterator it;
+	
+	for(it = items.begin(); it != items.end(); ++it)
+		if((*it)-&gt;selected)
+			retval.push_back((*it)-&gt;str);
+	
+	return retval;
+}
+
+const std::string &amp;CL_ListBox_Generic::get_current_text() const
+{
+	int pos = 0;
+	std::vector&lt;CL_ListItem *&gt;::const_iterator it;
+	for(it = items.begin(); it != items.end(); ++it, ++pos)
+		if((*it)-&gt;selected)
+			return (*it)-&gt;str;
+
+	return blank;
+}
+
+CL_ListItem *CL_ListBox_Generic::get_item(int index) const
+{
+	int pos = 0;
+	std::vector&lt;CL_ListItem *&gt;::const_iterator it;
+	for(it = items.begin(); it != items.end(); it++, pos++)
+		if(pos == index)
+			return (*it);
+
+	return 0;
+}
+
+int CL_ListBox_Generic::get_item(const CL_Point &amp;pt)
+{
+	//TODO:  Should also check X at some point
+
+	int index = (int)(pt.y / item_height + scroll_offset);
+
+	if(index &lt; 0 || index &gt;= (int)items.size()) return -1;
+
+	return index;
+}
+
+
+const std::string &amp;CL_ListBox_Generic::get_text(int index) const
+{
+	const CL_ListItem *item = get_item(index);
+	if(item)
+		return item-&gt;str;
+	else
+		return blank;
+}
+
+int CL_ListBox_Generic::get_current_item() const
+{
+	int pos = 0;
+	std::vector&lt;CL_ListItem *&gt;::const_iterator it;
+	for(it = items.begin(); it != items.end(); ++it, ++pos)
+		if((*it)-&gt;selected)
+			return pos;
+
+	return -1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+int CL_ListBox_Generic::insert_item(CL_ListItem *item, int index, bool delete_item)
+{
+	item-&gt;delete_item = delete_item;
+
+	if(index &lt; 0)
+		items.push_back(item);
+	else
+		throw CL_Error(&quot;CL_ListBox::insert_item() using index is not implemented&quot;);
+
+	sig_item_added(items.size() - 1);
+	return items.size() - 1;
+}
+
+int CL_ListBox_Generic::insert_item(const std::string &amp;text, int index)
+{
+	if(index &lt; 0)
+	{
+		CL_ListItem *item = new CL_ListItem;
+		item-&gt;str = text;
+		item-&gt;delete_item = true;
+		items.push_back(item);
+	}
+	else
+		throw CL_Error(&quot;CL_ListBox::insert_item() using index is not implemented&quot;);
+
+	sig_item_added(items.size() - 1);
+	return items.size() - 1;
+}
+
+void CL_ListBox_Generic::remove_item(int index)
+{
+	if(index &lt; 0 || index &gt; (int)items.size())
+		return;
+
+	int pos = 0;
+	std::vector&lt;CL_ListItem *&gt;::iterator it;
+	for (it = items.begin(); it != items.end(); ++it, ++pos)
+	{
+		if(pos == index)
+		{
+			if((*it)-&gt;delete_item)
+				delete (*it);
+			items.erase(it);
+			break;
+		}
+	}
+
+	int max_visible_items = listbox-&gt;get_client_area()-&gt;get_height() / item_height;
+	if((int)items.size() - scroll_offset &lt; max_visible_items)
+		scroll_offset = 0;
+
+	sig_item_removed(index);
+}
+
+void CL_ListBox_Generic::change_item(CL_ListItem *item, int index)
+{
+	if(index &lt; 0 || index &gt;= (int)items.size())
+		return;
+
+	delete items[index];
+	items[index] = item;
+}
+
+void CL_ListBox_Generic::change_item(const std::string &amp;text, int index)
+{
+	items[index]-&gt;str = text;
+}
+
+void CL_ListBox_Generic::set_current_item(int index)
+{
+	if(index &lt; 0 || index &gt;= (int)items.size())
+		return;
+
+	std::vector&lt;CL_ListItem *&gt;::iterator it;
+	for(it = items.begin(); it != items.end(); ++it)
+		if((*it)-&gt;selected)
+			(*it)-&gt;selected = false;
+	items[index]-&gt;selected = true;
+	
+	sig_highlighted(index);
+	sig_selection_changed();
+}
+
+void CL_ListBox_Generic::clear_selection()
+{
+	std::vector&lt;CL_ListItem *&gt;::iterator it;
+	for(it = items.begin(); it != items.end(); ++it)
+		(*it)-&gt;selected = false;
+}
+
+void CL_ListBox_Generic::sort(bool ascending)
+{
+	if (ascending)
+		std::sort(items.begin(), items.end(), list_item_ptr_less);
+	else
+		std::sort(items.begin(), items.end(), list_item_ptr_greater);
+}
+
+void CL_ListBox_Generic::clear()
+{
+	std::vector&lt;CL_ListItem *&gt;::iterator it;
+	for(it = items.begin(); it != items.end(); ++it)
+		if((*it)-&gt;delete_item)
+			delete (*it);
+
+	items.clear();
+	sig_clear();
+}
+
+void CL_ListBox_Generic::set_item_height(int new_item_height)
+{
+	item_height = new_item_height;
+}
+
+void CL_ListBox_Generic::set_top_item(int index)
+{
+	int max_visible_items = listbox-&gt;get_client_area()-&gt;get_height() / item_height;
+	int maximum_offset = items.size() - max_visible_items;
+
+	if (index &lt; 0)
+		index = 0;
+	if (maximum_offset &lt; 0)
+		maximum_offset = 0;
+	
+	if (index &gt;= maximum_offset)
+		scroll_offset = maximum_offset;
+	else
+		scroll_offset = index;
+}
+
+void CL_ListBox_Generic::set_selected(int index, bool select)
+{
+	if(index &lt; 0 || index &gt;= (int)items.size())
+		return;
+
+	items[index]-&gt;selected = select;
+}
+
+void CL_ListBox_Generic::select_all(bool select)
+{
+	std::vector&lt;CL_ListItem *&gt;::iterator it;
+	for(it = items.begin(); it != items.end(); ++it)
+		(*it)-&gt;selected = select;
+}
+
+void CL_ListBox_Generic::invert_selection()
+{
+	std::vector&lt;CL_ListItem *&gt;::iterator it;
+	for(it = items.begin(); it != items.end(); ++it)
+		(*it)-&gt;selected = !((*it)-&gt;selected);
+}
+
+void CL_ListBox_Generic::set_multi_selection(bool enable)
+{
+	multi_selection = enable;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_ListBox_Generic::on_set_options(const CL_DomElement &amp;options)
+{
+	CL_DomNode node = options.get_first_child();
+	while (!node.is_null())
+	{
+		if (node.is_element())
+		{
+			CL_DomElement element = node.to_element();
+			if (element.get_tag_name() == &quot;item&quot;)
+			{
+				CL_ListItem *item = new CL_ListItem;
+				item-&gt;str = element.get_attribute(&quot;value&quot;);
+				items.push_back(item);
+			}
+		}
+		node = node.get_next_sibling();
+	}
+}
+
+void CL_ListBox_Generic::on_mouse_down(const CL_InputEvent &amp;key)
+{
+	if(items.size() == 0)
+		return;
+
+	if(key.id == CL_MOUSE_LEFT)
+	{
+		int index = (int)(key.mouse_pos.y / item_height + scroll_offset);
+
+		if(index &lt; 0 || index &gt;= (int)items.size())
+			return;
+
+		if(multi_selection)
+			items[index]-&gt;selected = !items[index]-&gt;selected;
+		else
+		{
+			std::vector&lt;CL_ListItem *&gt;::iterator it;
+			for(it = items.begin(); it != items.end(); ++it)
+				if((*it)-&gt;selected)
+					(*it)-&gt;selected = false;
+			items[index]-&gt;selected = true;
+		}
+
+		sig_highlighted(index);
+		sig_selection_changed();
+		if(key.repeat_count == 2)
+			sig_activated(get_current_item());
+	}
+}
+
+void CL_ListBox_Generic::on_key_up(const CL_InputEvent &amp;key)
+{
+	if (key.id == CL_KEY_SPACE || key.id == CL_KEY_RETURN)
+		sig_activated(get_current_item());
+}

Added: trunk/clanlib/GUI/listbox_generic.h
===================================================================
--- trunk/clanlib/GUI/listbox_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/listbox_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,107 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_listbox_generic
+#define header_listbox_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+
+#include &quot;API/signals.h&quot;
+#include &quot;API/GUI/listitem.h&quot;
+
+class CL_ListBox;
+class CL_Component;
+class CL_DomElement;
+class CL_StyleManager;
+class CL_InputEvent;
+class CL_InputDevice;
+class CL_Rect;
+class CL_ScrollBar;
+class CL_Point;
+
+class CL_ListBox_Generic
+{
+public:
+	CL_ListBox_Generic(CL_ListBox *self);
+
+	~CL_ListBox_Generic();
+
+	std::vector&lt;std::string&gt; get_selected_items() const;
+	const std::string &amp;get_current_text() const;
+	CL_ListItem *get_item(int index) const;
+	int get_item(const CL_Point &amp;pt);
+
+	const std::string &amp;get_text(int index) const;
+	int get_current_item() const;
+
+	int insert_item(CL_ListItem *item, int index, bool delete_item);
+	int insert_item(const std::string &amp;text, int index);
+	void remove_item(int index);
+	void change_item(CL_ListItem *item, int index);
+	void change_item(const std::string &amp;text, int index);
+	void set_current_item(int index);
+	void clear_selection();
+	void set_selected(int index, bool select);
+	void select_all(bool select);
+	void invert_selection();
+	void set_multi_selection(bool enable);
+	void set_item_height(int height);
+	void set_top_item(int index);
+	void sort(bool ascending);
+	void clear();
+
+	CL_Signal_v1&lt;int&gt; sig_highlighted;
+	CL_Signal_v1&lt;int&gt; sig_activated;
+	CL_Signal_v0 sig_selection_changed;
+	CL_Signal_v1&lt;int&gt; sig_item_added;
+	CL_Signal_v1&lt;int&gt; sig_item_removed;
+	CL_Signal_v0 sig_clear;
+		
+	void on_set_options(const CL_DomElement &amp;options);
+	void on_mouse_down(const CL_InputEvent &amp;key);
+	void on_key_up(const CL_InputEvent &amp;key);
+
+	int item_height;
+	int scroll_offset;
+	bool multi_selection;
+
+	CL_ListBox *listbox;
+	CL_ScrollBar *scrollbar;
+
+	std::vector&lt;CL_ListItem *&gt; items;
+
+	CL_SlotContainer slots;
+};
+
+#endif

Added: trunk/clanlib/GUI/menu.cpp
===================================================================
--- trunk/clanlib/GUI/menu.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/menu.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,296 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/gui.h&quot;
+#include &quot;API/core.h&quot; // todo: remove/narrow?
+#include &quot;API/GUI/menu.h&quot;
+#include &quot;API/GUI/menu_node.h&quot;
+#include &quot;menu_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_Menu::CL_Menu(
+	const CL_Point &amp;pos,
+	CL_Component *parent,
+	CL_StyleManager *style,
+	bool vertical)
+:
+	CL_Component( CL_Rect(pos.x, pos.y, 0, 0), parent, style),
+	impl(0)
+{
+	impl = new CL_Menu_Generic(this, vertical, 0);
+	get_style_manager()-&gt;connect_styles(&quot;menu&quot;, this);
+}
+
+CL_Menu::CL_Menu(
+	CL_Component *parent,
+	CL_StyleManager *style,
+	bool vertical)
+:
+	CL_Component( CL_Rect(0, 0, 0, 0), parent, style),
+	impl(0)
+{
+	impl = new CL_Menu_Generic(this, vertical, 0);
+	get_style_manager()-&gt;connect_styles(&quot;menu&quot;, this);
+}
+
+CL_Menu::CL_Menu(
+	const CL_Rect &amp;rect,
+	CL_Component *parent,
+	CL_StyleManager *style,
+	bool vertical)
+:
+	CL_Component( rect, parent, style),
+	impl(0)
+{
+	impl = new CL_Menu_Generic(this, vertical, 0);
+	impl-&gt;auto_resize = false;
+	get_style_manager()-&gt;connect_styles(&quot;menu&quot;, this);
+}
+
+CL_Menu::CL_Menu(
+	CL_MenuNode *parent_node,
+	CL_Component *parent,
+	CL_StyleManager *style)
+:
+	CL_Component( parent, style),
+	impl(0)
+{
+	impl = new CL_Menu_Generic(this, true, parent_node);
+	parent_node-&gt;set_submenu(this);
+	get_style_manager()-&gt;connect_styles(&quot;menu&quot;, this);
+}
+
+CL_Menu::~CL_Menu()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+bool CL_Menu::is_open()
+{
+	return impl-&gt;menu_open;
+}
+
+bool CL_Menu::is_vertical()
+{
+	return impl-&gt;vertical;
+}
+
+bool CL_Menu::is_root_collapsing()
+{
+	return impl-&gt;collapse_root;
+}
+
+bool CL_Menu::is_auto_resize()
+{
+	return impl-&gt;auto_resize;
+}
+
+CL_Menu *CL_Menu::get_root_menu()
+{
+	return impl-&gt;get_root_menu();
+}
+
+CL_MenuNode *CL_Menu::get_parent_node()
+{
+	return impl-&gt;parent_node;
+}
+
+std::list&lt;CL_MenuNode*&gt; &amp;CL_Menu::get_node_list()
+{
+	// todo: CL_Component::get_children() does the same?
+	return impl-&gt;children;
+}
+
+int CL_Menu::get_items_width()
+{
+	return impl-&gt;get_items_width();
+}
+
+int CL_Menu::get_items_height()
+{
+	return impl-&gt;get_items_height();
+}
+
+bool CL_Menu::has_mouse_over()
+{
+	return impl-&gt;has_mouse_over();
+}
+
+bool CL_Menu::has_mouse_in_submenus()
+{
+	return impl-&gt;has_mouse_in_submenus();
+}
+
+bool CL_Menu::is_click_to_open()
+{
+	return impl-&gt;click_to_open;
+}
+
+CL_Menu *CL_Menu::get_menu(const std::string &amp;name)
+{
+	return impl-&gt;get_menu(CL_String::tokenize(name, &quot;/&quot;));
+}
+
+CL_MenuNode *CL_Menu::get_node(const std::string &amp;name)
+{
+	return impl-&gt;get_node(CL_String::tokenize(name, &quot;/&quot;));
+}
+
+CL_Component *CL_Menu::get_item(const std::string &amp;name)
+{
+	return impl-&gt;get_item(CL_String::tokenize(name, &quot;/&quot;));
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_Menu::add_node(CL_MenuNode *node)
+{
+	impl-&gt;add_node(node);
+}
+
+void CL_Menu::remove_node(CL_MenuNode *node)
+{
+	impl-&gt;remove_node(node);
+}
+
+void CL_Menu::open()
+{
+	impl-&gt;open();
+}
+
+void CL_Menu::collapse()
+{
+	impl-&gt;collapse();
+}
+
+void CL_Menu::collapse_submenus()
+{
+	impl-&gt;collapse_submenus();
+}
+
+void CL_Menu::set_vertical(bool vertical)
+{
+	impl-&gt;vertical = vertical; 
+}
+
+void CL_Menu::set_root_collapsing(bool collapse)
+{
+	impl-&gt;collapse_root = collapse;
+}
+
+void CL_Menu::set_auto_resize(bool value)
+{
+	impl-&gt;auto_resize = value;
+}
+
+void CL_Menu::reposition()
+{
+	CL_Rect area = get_position(); 
+
+	impl-&gt;sig_reposition(area.left, area.top);
+}
+
+void CL_Menu::reposition(int x, int y)
+{
+	impl-&gt;sig_reposition(x,y);
+}
+
+void CL_Menu::set_parent_node(CL_MenuNode *parent_node)
+{
+	impl-&gt;parent_node = parent_node;
+}
+
+void CL_Menu::set_click_to_open(bool click_to_open)
+{
+	impl-&gt;click_to_open = click_to_open;
+}
+
+CL_Menu *CL_Menu::create_menu(
+	const std::string &amp;path,
+	const std::string &amp;labels)
+{
+	std::vector&lt;std::string&gt; tokens = CL_String::tokenize(path, &quot;/&quot;);
+
+	if( labels.empty() )
+		return impl-&gt;create_menu(tokens, tokens);
+
+	return impl-&gt;create_menu(tokens, CL_String::tokenize(labels, &quot;/&quot;));
+}
+
+CL_MenuNode *CL_Menu::create_node(
+	const std::string &amp;path,
+	const std::string &amp;labels)
+{
+	std::vector&lt;std::string&gt; tokens = CL_String::tokenize(path, &quot;/&quot;);
+
+	if( labels.empty() )
+		return impl-&gt;create_node(tokens, tokens);
+
+	return impl-&gt;create_node(tokens, CL_String::tokenize(labels, &quot;/&quot;));
+}
+
+CL_MenuNode *CL_Menu::create_item(
+	const std::string &amp;path,
+	const std::string &amp;labels )
+{
+	std::vector&lt;std::string&gt; tokens = CL_String::tokenize(path, &quot;/&quot;);
+
+	if( labels.empty() )
+		return impl-&gt;create_item(tokens, tokens);
+
+	return impl-&gt;create_item(tokens, CL_String::tokenize(labels, &quot;/&quot;));
+}
+
+CL_MenuNode *CL_Menu::create_toggle_item(
+	const std::string &amp;path,
+	const std::string &amp;labels )
+{
+	std::vector&lt;std::string&gt; tokens = CL_String::tokenize(path, &quot;/&quot;);
+
+	if( labels.empty() )
+		return impl-&gt;create_toggle_item(tokens, tokens);
+
+	return impl-&gt;create_toggle_item(tokens, CL_String::tokenize(labels, &quot;/&quot;));
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+// Signals:
+
+CL_Signal_v2&lt;int,int&gt; &amp;CL_Menu::sig_reposition()
+{
+	return impl-&gt;sig_reposition;
+}

Added: trunk/clanlib/GUI/menu_generic.cpp
===================================================================
--- trunk/clanlib/GUI/menu_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/menu_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,429 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/gui.h&quot;
+#include &quot;API/signals.h&quot;
+#include &quot;menu_generic.h&quot;
+#include &quot;API/GUI/menu.h&quot;
+#include &quot;API/GUI/menu_node.h&quot;
+#include &quot;API/Display/mouse.h&quot;
+
+CL_Menu_Generic::CL_Menu_Generic(
+	CL_Menu *self,
+	bool vertical,
+	CL_MenuNode *parent_node)
+:
+	parent_node(parent_node),
+	vertical(vertical),
+	menu_open(true),
+	auto_resize(true),
+	submenu_open(false),
+	click_to_open(false),
+	collapse_root(false),
+	menu(self)
+{
+	if( parent_node == 0 )
+	{
+		slots.connect( CL_Mouse::sig_key_up(), this, &amp;CL_Menu_Generic::on_mouse_up);
+		click_to_open = true;
+	}
+
+	slots.connect( menu-&gt;sig_move(), this, &amp;CL_Menu_Generic::on_menu_moved );
+
+	if( vertical ) collapse();
+}
+
+CL_Menu_Generic::~CL_Menu_Generic()
+{
+	// todo: delete?
+
+	std::list&lt;CL_MenuNode *&gt;::iterator it;
+	for( it = children.begin(); it != children.end(); ++it )
+	{
+		delete (*it);
+	}
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+CL_Menu *CL_Menu_Generic::get_root_menu()
+{
+	CL_Menu *test_parent = menu;
+	
+	while( test_parent != NULL )
+	{
+		if( test_parent-&gt;get_parent_node() == NULL )
+			return test_parent;
+		else
+			test_parent = test_parent-&gt;get_parent_node()-&gt;get_parent_menu();
+	}
+
+	return NULL;
+}
+
+int CL_Menu_Generic::get_items_width()
+{
+	int width = 0;
+
+	std::list&lt;CL_MenuNode*&gt;::iterator it;
+	for( it = children.begin(); it != children.end(); ++it )
+	{
+		const CL_Rect &amp;pos = (*it)-&gt;get_data()-&gt;get_position();
+		int child_width = (*it)-&gt;get_data()-&gt;get_width();
+
+		if( vertical )
+		{
+			if( pos.left + child_width &gt; width )
+				width = pos.left + child_width;
+		}
+		else
+		{
+			width += child_width;
+		}
+
+	}
+	
+	return width;
+}
+
+int CL_Menu_Generic::get_items_height()
+{
+	int height = 0;
+	
+	if( !children.empty() )
+	{
+		std::list&lt;CL_MenuNode*&gt;::iterator it;
+		for( it = children.begin(); it != children.end(); ++it )
+		{
+			const CL_Rect &amp;pos = (*it)-&gt;get_data()-&gt;get_position();
+
+			if( vertical )
+			{
+				height += pos.get_height();
+			}
+			else
+			{
+				if( pos.get_height() &gt; height )
+					height = pos.get_height();
+			}
+		}
+	}
+	
+	return height;
+}
+
+bool CL_Menu_Generic::has_mouse_in_submenus()
+{
+	std::list&lt;CL_MenuNode*&gt;::iterator it;
+	for( it = children.begin(); it != children.end(); ++it )
+	{
+		if( (*it)-&gt;has_mouse_over() )
+			return true;
+	
+		if( (*it)-&gt;has_mouse_in_submenus() )
+			return true;
+	}
+
+	return false;
+}
+
+bool CL_Menu_Generic::has_mouse_over()
+{
+	if( menu-&gt;CL_Component::has_mouse_over() )
+		return true;
+	
+	std::list&lt;CL_MenuNode*&gt;::iterator it;
+	for( it = children.begin(); it != children.end(); ++it )
+	{
+		if( (*it)-&gt;has_mouse_over() )
+			return true;
+	}
+	
+	return false;
+}
+
+CL_Menu *CL_Menu_Generic::get_menu( std::vector&lt;std::string&gt; path )
+{
+	bool final_step = false;
+	std::string wanted = path.front();
+
+	path.erase(path.begin());
+	if( path.empty() )
+		final_step = true;
+	
+	std::list&lt;CL_MenuNode*&gt;::iterator it;
+	for( it = children.begin(); it != children.end(); ++it )
+	{
+		CL_MenuNode *node = (*it);
+		
+		if( node-&gt;has_submenu() )
+		{
+			if( node-&gt;get_name() == wanted )
+			{
+				if( final_step )
+					return node-&gt;get_submenu();
+				else
+					return node-&gt;get_submenu()-&gt;impl-&gt;get_menu(path);
+			}
+		}
+	}
+
+	return 0;
+}
+
+CL_MenuNode *CL_Menu_Generic::get_node( std::vector&lt;std::string&gt; path )
+{
+	bool final_step = false;
+	std::string wanted = path.front();
+	
+	path.erase(path.begin());
+	if( path.empty() )
+		final_step = true;
+
+	std::list&lt;CL_MenuNode*&gt;::iterator it;
+	for( it = children.begin(); it != children.end(); ++it )
+	{
+		CL_MenuNode *node = (*it);
+
+		if( node-&gt;get_name() == wanted )
+		{
+			if( final_step )
+			{
+				return node;
+			}
+			else if( node-&gt;has_submenu() )
+			{
+				return node-&gt;get_submenu()-&gt;impl-&gt;get_node(path);
+			}
+		}
+	}
+
+	return 0;
+}
+
+CL_Component *CL_Menu_Generic::get_item( std::vector&lt;std::string&gt; path )
+{
+	return get_node(path)-&gt;get_data();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_Menu_Generic::add_node(CL_MenuNode *node)
+{
+	node-&gt;set_parent_menu(menu);	
+	children.push_back(node);
+}
+
+void CL_Menu_Generic::remove_node(CL_MenuNode *node)
+{
+	std::list&lt;CL_MenuNode *&gt;::iterator it;
+	for( it = children.begin(); it != children.end(); ++it )
+	{
+		if( (*it) == node )
+			it = children.erase(it);
+	}
+	
+	CL_Menu *root = get_root_menu();
+	CL_Rect pos = root-&gt;get_position();
+	root-&gt;reposition(pos.left, pos.top);
+}
+
+void CL_Menu_Generic::open()
+{
+	menu-&gt;show(true);
+	menu_open = true;
+	if( menu-&gt;get_parent_node() )
+		menu-&gt;get_parent_node()-&gt;get_parent_menu()-&gt;impl-&gt;submenu_open = true;
+}
+
+void CL_Menu_Generic::collapse()
+{
+	collapse_submenus();
+
+	menu-&gt;show(false);
+	menu_open = false;
+}
+
+void CL_Menu_Generic::collapse_submenus()
+{
+	std::list&lt;CL_MenuNode*&gt;::iterator it;
+	for( it = children.begin(); it != children.end(); ++it )
+	{
+		(*it)-&gt;collapse();
+	}
+
+	submenu_open = false;
+}	
+
+CL_Menu *CL_Menu_Generic::create_menu(
+	std::vector&lt;std::string&gt; path,
+	std::vector&lt;std::string&gt; labels )
+{
+	if( path.empty() )
+		return menu-&gt;get_root_menu();
+
+	bool final_step = false;
+	CL_MenuNode *wanted_node = 0;
+
+	std::list&lt;CL_MenuNode*&gt;::iterator it;
+	for( it = children.begin(); it != children.end(); ++it )
+	{
+		if( (*it)-&gt;get_name() == path.front() )
+		{
+			wanted_node = (*it);
+		}
+	}
+
+	std::string wanted_name = path.front();
+	std::string wanted_label = labels.front();
+
+	path.erase(path.begin());
+	labels.erase(labels.begin());
+
+	if( path.empty() )
+		final_step = true;
+
+	if( wanted_node != 0 )
+	{
+		if( wanted_node-&gt;has_submenu() ) // node &amp; submenu exsists
+		{
+			if( final_step )
+				return wanted_node-&gt;get_submenu();
+			else
+				return wanted_node-&gt;get_submenu()-&gt;impl-&gt;create_menu(path, labels);
+		}
+		else 
+		{
+			// submenu doesn't exsist, create one.
+			CL_Menu *submenu = new CL_Menu(wanted_node, menu-&gt;get_root_menu()-&gt;get_parent() );
+			
+			if( final_step ) return submenu;
+			else return submenu-&gt;impl-&gt;create_menu(path, labels);
+		}
+	}
+	else
+	{
+		// create node, item &amp; submenu.
+
+		// node
+		wanted_node = new CL_MenuNode(menu);
+		wanted_node-&gt;set_name(wanted_name);
+
+		// item (submenu label)
+		CL_MenuItem *item = new CL_MenuItem(wanted_label, wanted_node);
+
+		if( wanted_node-&gt;get_parent_menu()-&gt;get_parent_node() == 0 )
+		{
+			item-&gt;set_use_icon(false);
+			item-&gt;find_preferred_size();
+		}
+
+		// submenu
+		CL_Menu *submenu = new CL_Menu(wanted_node, menu-&gt;get_root_menu()-&gt;get_parent());
+		
+		if( final_step ) return submenu;
+		else return submenu-&gt;impl-&gt;create_menu(path,labels);
+	}
+
+	return 0;
+}
+
+
+CL_MenuNode *CL_Menu_Generic::create_node(
+	std::vector&lt;std::string&gt; path,
+	std::vector&lt;std::string&gt; labels )
+{
+	CL_MenuNode *node = menu-&gt;get_root_menu()-&gt;impl-&gt;get_node(path);
+
+	if( node )
+		return node;
+
+	std::string node_name = path.back();
+	path.pop_back();
+	labels.pop_back();
+
+	CL_Menu *parent_menu = create_menu(path, labels);
+
+	node = new CL_MenuNode(parent_menu);
+	node-&gt;set_name(node_name);
+
+	return node;
+}
+
+CL_MenuNode *CL_Menu_Generic::create_item(
+	std::vector&lt;std::string&gt; path,
+	std::vector&lt;std::string&gt; labels)
+{
+	std::string item_name = labels.back();
+	CL_MenuNode *parent_node = create_node(path, labels);
+	// The newly created item is added to the parent_node in the constructor
+	new CL_MenuItem(item_name, parent_node );
+
+	return parent_node;
+}
+
+CL_MenuNode *CL_Menu_Generic::create_toggle_item(
+	std::vector&lt;std::string&gt; path,
+	std::vector&lt;std::string&gt; labels)
+{
+	CL_MenuNode *node = create_item(path,labels);
+	CL_MenuItem *item = static_cast&lt;CL_MenuItem*&gt;(node-&gt;get_data());
+
+	item-&gt;set_toggling(true);
+	node-&gt;set_close_on_click(false);
+
+	return node;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+// on_mouse_up() is connected only to the root menu. It will collapse
+// the menus if a click outside the menus takes place.
+void CL_Menu_Generic::on_mouse_up(const CL_InputEvent&amp;)
+{
+	if( submenu_open &amp;&amp; !menu-&gt;has_mouse_in_submenus() )
+	{
+		collapse_submenus();
+		click_to_open = true;
+	}
+
+	if( parent_node	== 0 &amp;&amp; collapse_root
+		&amp;&amp; !menu-&gt;has_mouse_over() &amp;&amp; !menu-&gt;has_mouse_in_submenus()  )
+		collapse();
+}
+
+void CL_Menu_Generic::on_menu_moved(int old_x, int old_y)
+{
+	menu-&gt;reposition();
+}

Added: trunk/clanlib/GUI/menu_generic.h
===================================================================
--- trunk/clanlib/GUI/menu_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/menu_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,102 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_menu_generic
+#define header_menu_generic
+
+class CL_Menu;
+class CL_MenuNode;
+
+class CL_Menu_Generic
+{
+//! Construction:
+ public:
+	CL_Menu_Generic(
+		CL_Menu *self,
+		bool vertical,
+		CL_MenuNode *parent_node );
+	
+	virtual ~CL_Menu_Generic();
+
+//! Attributes:
+ public:
+	CL_Menu *get_root_menu();
+	
+	std::list&lt;CL_MenuNode*&gt; children;
+	CL_MenuNode *parent_node;
+
+	bool vertical;
+	bool menu_open;
+	bool auto_resize;
+	bool submenu_open;
+	bool click_to_open;
+	bool collapse_root;
+	
+	bool has_mouse_in_submenus();
+	bool has_mouse_over();
+
+	CL_Menu *get_menu( std::vector&lt;std::string&gt; path);
+	CL_MenuNode *get_node( std::vector&lt;std::string&gt; path );
+	CL_Component *get_item( std::vector&lt;std::string&gt; path );
+
+//! Signals:
+	CL_Signal_v2&lt;int,int&gt; sig_reposition;
+
+//! Operations:
+ public:
+	void set_vertical(bool vertical);
+	void add_node(CL_MenuNode *node);
+	void remove_node(CL_MenuNode *node);
+	void set_parent_node( CL_MenuNode *node );
+
+	void open();
+	void collapse();
+	void collapse_submenus();
+	
+	int get_items_height();
+	int get_items_width();
+
+	CL_Menu *create_menu( std::vector&lt;std::string&gt; path, std::vector&lt;std::string&gt; labels );
+	CL_MenuNode *create_node( std::vector&lt;std::string&gt; path, std::vector&lt;std::string&gt; labels );
+	CL_MenuNode *create_item( std::vector&lt;std::string&gt; path, std::vector&lt;std::string&gt; labels );
+	CL_MenuNode *create_toggle_item( std::vector&lt;std::string&gt; path, std::vector&lt;std::string&gt; labels );
+
+//! Callbacks:
+ private:
+	void on_mouse_up(const CL_InputEvent &amp;e);
+	void on_menu_moved(int old_x, int old_y);
+	
+//! Implementation:
+ private:
+	CL_Menu *menu;
+	
+	CL_SlotContainer slots;
+};
+
+#endif

Added: trunk/clanlib/GUI/menu_item.cpp
===================================================================
--- trunk/clanlib/GUI/menu_item.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/menu_item.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,119 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/GUI/menu_item.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;menu_item_generic.h&quot;
+#include &quot;component_generic.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_MenuItem::CL_MenuItem(
+	const std::string &amp;text,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(parent, style), impl(NULL)
+{
+	impl = new CL_MenuItem_Generic(this, text);
+	get_style_manager()-&gt;connect_styles(&quot;menu_item&quot;, this);
+
+	set_focusable(false);
+
+	find_preferred_size();
+}
+
+CL_MenuItem::~CL_MenuItem()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+const std::string &amp;CL_MenuItem::get_text() const
+{
+	return impl-&gt;text;
+}
+
+bool CL_MenuItem::is_toggling() const
+{
+	return impl-&gt;toggling;
+}
+
+bool CL_MenuItem::is_selected() const
+{
+	return impl-&gt;selected;
+}
+
+bool CL_MenuItem::use_icon() const
+{
+	return impl-&gt;use_icon;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_MenuItem::set_toggling(bool toggle)
+{
+	impl-&gt;toggling = toggle;
+}
+
+void CL_MenuItem::set_use_icon(bool use_icon)
+{
+	impl-&gt;use_icon = use_icon;
+}
+
+void CL_MenuItem::set_selected(bool selected)
+{
+	impl-&gt;selected = selected;
+}
+
+void CL_MenuItem::set_text(const std::string &amp;text)
+{
+	impl-&gt;text = text;
+}
+
+void CL_MenuItem::set_text(int number)
+{
+	impl-&gt;text = CL_String::from_int(number);
+}
+
+void CL_MenuItem::set_text(double number)
+{
+	impl-&gt;text = CL_String::from_double(number);
+}
+
+void CL_MenuItem::clear()
+{
+	impl-&gt;text = &quot;&quot;;
+}

Added: trunk/clanlib/GUI/menu_item_generic.cpp
===================================================================
--- trunk/clanlib/GUI/menu_item_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/menu_item_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,62 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;menu_item_generic.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_MenuItem_Generic::CL_MenuItem_Generic(
+	CL_MenuItem *self,
+	const std::string &amp;_text)
+:
+	toggling(false),
+	selected(false),
+	use_icon(true),
+	menu_item(self)
+{
+	text = _text;
+
+	slots.connect( menu_item-&gt;sig_set_options(), this, &amp;CL_MenuItem_Generic::on_set_options);
+	slots.connect( menu_item-&gt;sig_mouse_down(), this, &amp;CL_MenuItem_Generic::on_mouse_down);
+}
+
+void CL_MenuItem_Generic::on_set_options(const CL_DomElement &amp;options)
+{
+	if (options.has_attribute(&quot;text&quot;))
+		text = options.get_attribute(&quot;text&quot;);
+}
+
+void CL_MenuItem_Generic::on_mouse_down(const CL_InputEvent &amp;event)
+{
+	if( toggling &amp;&amp; menu_item-&gt;get_parent()-&gt;is_enabled(false) )
+		selected = !selected;
+}

Added: trunk/clanlib/GUI/menu_item_generic.h
===================================================================
--- trunk/clanlib/GUI/menu_item_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/menu_item_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,66 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_label_generic
+#define header_label_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/GUI/menu_item.h&quot;
+#include &quot;API/Display/surface.h&quot;
+
+class CL_MenuItem_Generic
+{
+//! Construction:
+public:
+	CL_MenuItem_Generic(
+		CL_MenuItem *self,	
+		const std::string &amp;text);
+
+//! Attributes:
+public:
+	bool toggling;
+	bool selected;
+	bool use_icon;
+
+	std::string text;
+
+//! Implementation:
+private:
+	void on_set_options(const CL_DomElement &amp;options);
+	void on_mouse_down(const CL_InputEvent &amp;event);
+
+	CL_MenuItem *menu_item;
+
+	CL_SlotContainer slots;
+};  
+
+#endif

Added: trunk/clanlib/GUI/menu_node.cpp
===================================================================
--- trunk/clanlib/GUI/menu_node.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/menu_node.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,152 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+#include &quot;API/GUI/menu_node.h&quot;
+#include &quot;API/GUI/menu.h&quot;
+#include &quot;menu_node_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_MenuNode::CL_MenuNode(
+	CL_Menu *parent_menu,
+	CL_StyleManager *style)
+:
+	CL_Component( parent_menu, style ),
+	impl(0)
+{
+	impl = new CL_MenuNode_Generic(this, parent_menu);
+	parent_menu-&gt;add_node(this);
+	get_style_manager()-&gt;connect_styles(&quot;menu_node&quot;, this);
+	
+}
+
+CL_MenuNode::~CL_MenuNode()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+bool CL_MenuNode::has_submenu()
+{
+	if( impl-&gt;submenu )
+		return true;
+
+	return false;
+}
+
+bool CL_MenuNode::has_open_submenu()
+{
+	return impl-&gt;has_open_submenu();
+}
+
+bool CL_MenuNode::has_mouse_over()
+{
+	return impl-&gt;has_mouse_over();
+}
+
+bool CL_MenuNode::has_mouse_in_submenus()
+{
+	return impl-&gt;has_mouse_in_submenus();
+}
+
+CL_Component *CL_MenuNode::get_data()
+{
+	return impl-&gt;data;
+}
+
+CL_Menu *CL_MenuNode::get_parent_menu()
+{
+	return impl-&gt;parent_menu;
+}
+
+CL_Menu *CL_MenuNode::get_submenu()
+{
+	return impl-&gt;submenu;
+}
+
+std::string CL_MenuNode::get_name()
+{
+	return impl-&gt;name;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_MenuNode::collapse()
+{
+	impl-&gt;collapse();
+}
+
+void CL_MenuNode::open_submenu()
+{
+	impl-&gt;open_submenu();
+}
+
+void CL_MenuNode::set_submenu(CL_Menu *menu)
+{
+	impl-&gt;set_submenu(menu);
+}
+
+void CL_MenuNode::set_name(std::string name)
+{
+	impl-&gt;name = name;
+}
+
+void CL_MenuNode::set_parent_menu(CL_Menu *menu)
+{
+	impl-&gt;set_parent_menu(menu);
+}
+
+void CL_MenuNode::set_close_on_click(bool close)
+{
+	impl-&gt;close_on_click = close;
+}
+
+void CL_MenuNode::reposition_submenus()
+{
+	impl-&gt;sig_reposition();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Signals:
+
+CL_Signal_v0 &amp;CL_MenuNode::sig_reposition()
+{
+	return impl-&gt;sig_reposition;
+}
+
+CL_Signal_v0 &amp;CL_MenuNode::sig_clicked()
+{
+	return impl-&gt;sig_clicked;
+}

Added: trunk/clanlib/GUI/menu_node_generic.cpp
===================================================================
--- trunk/clanlib/GUI/menu_node_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/menu_node_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,222 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;menu_node_generic.h&quot;
+#include &quot;menu_generic.h&quot;
+#include &quot;API/GUI/menu.h&quot;
+#include &quot;API/GUI/menu_node.h&quot;
+#include &quot;API/signals.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_MenuNode_Generic::CL_MenuNode_Generic(
+	CL_MenuNode *self,
+	CL_Menu *parent_menu)
+:
+	data(0),
+	submenu(0),
+	parent_menu(parent_menu),
+	close_on_click(true),
+	node(self),
+	close_lock(false)
+{
+	slots.connect( node-&gt;sig_mouse_enter(), this, &amp;CL_MenuNode_Generic::on_mouse_enter);
+	slots.connect( node-&gt;sig_mouse_down(), this, &amp;CL_MenuNode_Generic::on_mouse_down);
+	slots.connect( node-&gt;sig_mouse_up(), this, &amp;CL_MenuNode_Generic::on_mouse_up);
+	slots.connect( node-&gt;sig_child_add(), this, &amp;CL_MenuNode_Generic::on_child_add);
+}
+
+CL_MenuNode_Generic::~CL_MenuNode_Generic()
+{
+	delete submenu; //SETH: uncommented this to fix mem leak.. why was it commented out?
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+bool CL_MenuNode_Generic::has_mouse_over()
+{
+	if( node-&gt;CL_Component::has_mouse_over() )
+		return true;
+
+	if( data )
+	{
+		if( data-&gt;has_mouse_over() ) return true;
+		if( child_has_mouse_over(data) ) return true;
+	}
+	
+	return false;
+}
+
+bool CL_MenuNode_Generic::has_mouse_in_submenus()
+{
+	if( !submenu )
+		return false;
+
+	if( submenu-&gt;has_mouse_over() )
+		return true;
+
+	return submenu-&gt;has_mouse_in_submenus();
+}
+
+bool CL_MenuNode_Generic::has_open_submenu()
+{
+	if( submenu )
+		return submenu-&gt;is_visible(false);
+
+	return false;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_MenuNode_Generic::collapse()
+{
+	if( !submenu )
+		return;
+
+	submenu-&gt;collapse();
+}
+
+void CL_MenuNode_Generic::open_submenu()
+{
+	if( !submenu )
+		return;
+
+	submenu-&gt;open();
+}
+
+void CL_MenuNode_Generic::set_submenu(CL_Menu *menu)
+{
+	submenu = menu;
+	submenu-&gt;set_parent_node(node);
+
+//	parent_menu-&gt;get_root_menu()-&gt;reposition();
+}
+
+void CL_MenuNode_Generic::set_parent_menu(CL_Menu *menu)
+{
+	parent_menu = menu;
+
+//	parent_menu-&gt;get_root_menu()-&gt;reposition();
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_MenuNode_Generic::on_child_add(CL_Component *child)
+{
+	this-&gt;data = child;
+	
+	node-&gt;set_width(child-&gt;get_width());
+	node-&gt;set_height(child-&gt;get_height());
+	
+	slots.connect( child-&gt;sig_mouse_enter(), this, &amp;CL_MenuNode_Generic::on_mouse_enter );
+
+	node-&gt;find_preferred_size();
+}
+
+void CL_MenuNode_Generic::on_mouse_down(const CL_InputEvent &amp;e)
+{
+	if( !parent_menu-&gt;is_vertical() ) 
+		parent_menu-&gt;set_click_to_open(false);
+	
+	// click to open a submenu in a horizontal menu.
+	if( !node-&gt;get_parent_menu()-&gt;is_vertical() )
+	{
+		if( node-&gt;is_enabled(false) &amp;&amp; submenu != 0 )
+		{
+			if( !submenu-&gt;is_open() )
+			{
+				open_submenu();
+				close_lock = true;
+			}
+		}
+	}
+}
+
+void CL_MenuNode_Generic::on_mouse_up(const CL_InputEvent &amp;e)
+{
+	if( close_lock )
+	{
+		close_lock = false;
+		return;
+	}
+
+	CL_Menu *root = parent_menu-&gt;get_root_menu();
+
+	// click to close a submenu in a horizontal menu.
+	if( !node-&gt;get_parent_menu()-&gt;is_vertical() )
+	{
+		root-&gt;collapse_submenus();
+		root-&gt;set_click_to_open(true);
+	}
+
+	if( root-&gt;is_root_collapsing() )
+		root-&gt;collapse();
+
+	if( close_on_click &amp;&amp; submenu == 0 &amp;&amp; node-&gt;is_enabled(false) )
+	{
+		CL_Menu *root = parent_menu-&gt;get_root_menu();
+		root-&gt;collapse_submenus();
+		root-&gt;set_click_to_open(true);
+	}
+
+	sig_clicked();	
+}
+
+void CL_MenuNode_Generic::on_mouse_enter()
+{
+	parent_menu-&gt;collapse_submenus();
+
+	if( !node-&gt;is_enabled(false) )
+		return;
+
+	if( parent_menu-&gt;is_vertical() )
+		open_submenu();
+	else if( !parent_menu-&gt;is_click_to_open() ) // horizontal
+		open_submenu();
+}
+
+bool CL_MenuNode_Generic::child_has_mouse_over(const CL_Component *comp) const
+{
+	std::list&lt;CL_Component*&gt;::const_iterator it;
+	const std::list&lt;CL_Component*&gt; &amp;children = comp-&gt;get_children();
+	
+	for( it = children.begin(); it != children.end(); ++it )
+	{
+		if( (*it)-&gt;has_mouse_over() ) return true;
+		if( child_has_mouse_over(*it) ) return true;
+	}
+	
+	return false;	
+}

Added: trunk/clanlib/GUI/menu_node_generic.h
===================================================================
--- trunk/clanlib/GUI/menu_node_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/menu_node_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,89 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_menu_node_generic
+#define header_menu_node_generic
+
+#include &quot;API/gui.h&quot;
+
+
+class CL_MenuNode;
+class CL_Menu;
+class CL_Menu_Generic;
+
+class CL_MenuNode_Generic
+{
+ public:
+	// construction
+	CL_MenuNode_Generic( CL_MenuNode *self, CL_Menu *parent_menu);
+	virtual ~CL_MenuNode_Generic();
+
+	// attributes
+	CL_Component *data;
+	CL_Menu *submenu;
+	CL_Menu *parent_menu;
+	std::string name;
+	bool close_on_click;
+
+	bool mouse_in_submenus();
+	bool has_mouse_over();
+	bool has_mouse_in_submenus();
+	bool has_open_submenu();
+
+	bool child_has_mouse_over(const CL_Component *comp) const;
+
+	// operations
+	void set_submenu(CL_Menu *menu);
+	void set_parent_menu(CL_Menu *menu);
+	void open_submenu();
+	void collapse();
+	void collapse_submenus();
+	void reposition();
+
+	// callbacks
+	void on_mouse_down(const CL_InputEvent &amp;e);
+	void on_mouse_up(const CL_InputEvent &amp;e);
+	void on_mouse_enter();
+	void on_child_add(CL_Component *child);
+
+	// signals:
+	CL_Signal_v0 sig_reposition;
+	CL_Signal_v0 sig_clicked;
+
+ private:
+	// implementation
+	CL_MenuNode *node;
+	bool close_lock;
+
+	CL_SlotContainer slots;
+
+	friend class CL_Menu;
+};
+
+#endif

Added: trunk/clanlib/GUI/messagebox.cpp
===================================================================
--- trunk/clanlib/GUI/messagebox.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/messagebox.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,100 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &lt;string&gt;
+#include &quot;API/GUI/messagebox.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+#include &quot;API/GUI/gui_manager.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;messagebox_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_MessageBox::CL_MessageBox(
+	const std::string &amp;title,
+	const std::string &amp;text,
+	const std::string &amp;button1,
+	const std::string &amp;button2,
+	const std::string &amp;button3,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Window(parent, style), impl(0)
+{
+	impl = new CL_MessageBox_Generic(this, title, text, button1, button2, button3);
+}
+
+CL_MessageBox::~CL_MessageBox()
+{
+	delete impl;
+}
+
+int CL_MessageBox::info(
+	const std::string &amp;text,
+	CL_Component *parent,
+	CL_StyleManager *style)
+{
+	CL_MessageBox message(&quot;Information&quot;, text, &quot;Ok&quot;, &quot;&quot;, &quot;&quot;, parent, style);
+	message.run();
+	return message.get_result_button();
+}
+
+int CL_MessageBox::info(
+	const std::string &amp;title,
+	const std::string &amp;text,
+	CL_Component *parent,
+	CL_StyleManager *style)
+{
+	CL_MessageBox message(title, text, &quot;Ok&quot;, &quot;&quot;, &quot;&quot;, parent, style);
+	message.run();
+	return message.get_result_button();
+}
+
+int CL_MessageBox::info(
+	const std::string &amp;title,
+	const std::string &amp;text,
+	const std::string &amp;button1,
+	const std::string &amp;button2,
+	const std::string &amp;button3,
+	CL_Component *parent,
+	CL_StyleManager *style)
+{
+	CL_MessageBox message(title, text, button1, button2, button3, parent, style);
+	message.run();
+	return message.get_result_button();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+int CL_MessageBox::get_result_button() const
+{
+	return impl-&gt;result_button;
+}

Added: trunk/clanlib/GUI/messagebox_generic.cpp
===================================================================
--- trunk/clanlib/GUI/messagebox_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/messagebox_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,352 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;messagebox_generic.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Display/font.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;API/Core/Resources/resourcetype_integer.h&quot;
+#include &quot;API/Core/Resources/resourcetype_boolean.h&quot;
+
+// private namespace for constants
+namespace {
+	int const space_between_buttons = 10;
+	int const space_between_title_and_text = 10;
+	int const space_between_text_and_buttons = 20;
+	int const space_between_buttons_and_bottom = 10;
+	int const space_between_text_and_left_edge = 10;
+	int const space_between_text_and_right_edge = 10;
+} // end of private namespace for constants
+
+CL_MessageBox_Generic::CL_MessageBox_Generic(
+	CL_MessageBox *self,
+	const std::string &amp;title,
+	const std::string &amp;text,
+	const std::string &amp;button1,
+	const std::string &amp;button2,
+	const std::string &amp;button3)
+:
+	text(text),
+	messagebox(self),
+	result_button(-1)
+{
+	CL_ResourceManager * resources = messagebox-&gt;get_style_manager()-&gt;get_resources();
+	font = new CL_Font(&quot;MessageBox/font&quot;, resources);
+
+	bool is_fixed_size_buttons = CL_Boolean(&quot;MessageBox/fixed_size_buttons&quot;, resources, false);
+	int min_button_width = CL_Integer(&quot;MessageBox/min_button_width&quot;, resources, 80);
+	int min_button_height = CL_Integer(&quot;MessageBox/min_button_height&quot;, resources, 20);
+
+	int width = CL_Integer(&quot;MessageBox/min_width&quot;, resources, 400);
+	int height = 0;
+
+	messagebox-&gt;set_title(title);
+
+	// We need to know how many space get client_area in 
+	// CL_Window, and then we can calculate offsets from edges
+	CL_Rect const msgbox_rc(
+		CL_Display::get_width()  / 2 - 400 / 2,
+		CL_Display::get_height() / 2 - 400 / 2,
+		CL_Display::get_width()  / 2 + 400 / 2,
+		CL_Display::get_height() / 2 + 400 / 2);
+
+	messagebox-&gt;set_position(msgbox_rc);
+
+	CL_Rect const client_area_rc = messagebox-&gt;get_client_area()-&gt;get_position();
+
+	// Now calculate edges offsets
+	int const left_edge_offset   = client_area_rc.left;
+	int const top_edge_offset    = client_area_rc.top;
+	int const right_edge_offset  = msgbox_rc.right - client_area_rc.right - msgbox_rc.left;
+	int const bottom_edge_offset = msgbox_rc.bottom - client_area_rc.bottom - msgbox_rc.top;
+
+	int num_buttons = 0;
+	if (!button1.empty())
+		num_buttons = 1;
+	if (!button2.empty())
+		num_buttons = 2;
+	if (!button3.empty())
+		num_buttons = 3;
+
+	height += space_between_title_and_text + space_between_text_and_buttons;
+	int const btn_pos_y = height;
+	height += space_between_buttons_and_bottom;
+
+	switch(num_buttons)
+	{
+	case 1:
+		{
+			if (is_fixed_size_buttons)
+			{
+				button[0] = new CL_Button(CL_Point(width / 2, btn_pos_y), button1,
+					messagebox-&gt;get_client_area());
+				if (button[0]-&gt;get_width() &gt; min_button_width)
+					min_button_width = button[0]-&gt;get_width();
+				if (button[0]-&gt;get_height() &gt; min_button_height)
+					min_button_height = button[0]-&gt;get_height();
+
+				button[0]-&gt;set_width(min_button_width);
+				button[0]-&gt;set_height(min_button_height);
+			}
+			else
+			{
+				button[0] = new CL_Button(
+					CL_Point(width / 2, btn_pos_y),
+					button1,
+					messagebox-&gt;get_client_area());
+			}
+
+			if (width &lt; button[0]-&gt;get_width())
+				width = button[0]-&gt;get_width();
+
+			width += space_between_text_and_left_edge + space_between_text_and_right_edge;
+			
+			button[0]-&gt;set_position(
+				width / 2 - button[0]-&gt;get_width() / 2,
+				btn_pos_y);
+
+			slot_button[0] = button[0]-&gt;sig_clicked().connect(
+				this, &amp;CL_MessageBox_Generic::on_button, 0);
+
+			// add buttons height to height
+			height += button[0]-&gt;get_height();
+		}
+		break;
+	case 2:
+		{
+			if (is_fixed_size_buttons)
+			{
+				button[0] = new CL_Button(
+					CL_Point(width / 2, btn_pos_y),
+					button1,
+					messagebox-&gt;get_client_area());
+				button[1] = new CL_Button(
+					CL_Point(width / 2, btn_pos_y),
+					button2,
+					messagebox-&gt;get_client_area());
+				
+				// calculate min width and height of buttons,
+				// if some button is bigger than min size
+				for(int i = 0; i &lt; 2; ++i)
+				{
+					if (button[i]-&gt;get_width() &gt; min_button_width)
+						min_button_width = button[i]-&gt;get_width();
+					if (button[i]-&gt;get_height() &gt; min_button_height)
+						min_button_height = button[i]-&gt;get_height();
+				}
+				// set buttons size to max width and height.
+				// and use 'j' for msvc workaround :(
+				for(int j = 0; j &lt; 2; ++j)
+				{
+					button[j]-&gt;set_width(min_button_width);
+					button[j]-&gt;set_height(min_button_height);
+				}
+			}
+			else
+			{
+				button[0] = new CL_Button(
+					CL_Point(width / 2, btn_pos_y),
+					button1,
+					messagebox-&gt;get_client_area());
+				button[1] = new CL_Button(
+					CL_Point(width / 2, btn_pos_y),
+					button2,
+					messagebox-&gt;get_client_area());
+			}
+
+			int const total_buttons_size =
+				button[0]-&gt;get_width() +
+				space_between_buttons  +
+				button[1]-&gt;get_width();
+
+			if (width &lt; total_buttons_size)
+				width = total_buttons_size;
+
+			width += space_between_text_and_left_edge + space_between_text_and_right_edge;
+
+			button[0]-&gt;set_position(
+				width / 2 - total_buttons_size / 2,
+				btn_pos_y);
+			button[1]-&gt;set_position(
+				width / 2 - total_buttons_size / 2 +
+				button[0]-&gt;get_width() + space_between_buttons,
+				btn_pos_y);
+
+			slot_button[0] = button[0]-&gt;sig_clicked().connect(
+				this, &amp;CL_MessageBox_Generic::on_button, 0);
+			slot_button[1] = button[1]-&gt;sig_clicked().connect(
+				this, &amp;CL_MessageBox_Generic::on_button, 1);
+
+			// add buttons height to height
+			height += button[0]-&gt;get_height();
+		}
+		break;
+	case 3:
+		{
+			if (is_fixed_size_buttons)
+			{
+				button[0] = new CL_Button(
+					CL_Point(width / 2, btn_pos_y),
+					button1,
+					messagebox-&gt;get_client_area());
+				button[1] = new CL_Button(
+					CL_Point(width / 2, btn_pos_y),
+					button2,
+					messagebox-&gt;get_client_area());
+				button[2] = new CL_Button(
+					CL_Point(width / 2, btn_pos_y),
+					button3,
+					messagebox-&gt;get_client_area());
+				
+				// calculate min width and height of buttons,
+				// if some button is bigger than min size
+				for(int i = 0; i &lt; 3; ++i)
+				{
+					if (button[i]-&gt;get_width() &gt; min_button_width)
+						min_button_width = button[i]-&gt;get_width();
+					if (button[i]-&gt;get_height() &gt; min_button_height)
+						min_button_height = button[i]-&gt;get_height();
+				}
+				// set buttons size to max width and height
+				for(int j = 0; j &lt; 3; ++j)
+				{
+					button[j]-&gt;set_width(min_button_width);
+					button[j]-&gt;set_height(min_button_height);
+				}
+			}
+			else
+			{
+				button[0] = new CL_Button(
+					CL_Point(width / 2, btn_pos_y),
+					button1,
+					messagebox-&gt;get_client_area());
+				button[1] = new CL_Button(
+					CL_Point(width / 2, btn_pos_y),
+					button2,
+					messagebox-&gt;get_client_area());
+				button[2] = new CL_Button(
+					CL_Point(width / 2, btn_pos_y),
+					button3,
+					messagebox-&gt;get_client_area());
+			}
+
+			int const total_buttons_size =
+				button[0]-&gt;get_width() + space_between_buttons +
+				button[1]-&gt;get_width() + space_between_buttons +
+				button[2]-&gt;get_width();
+
+			if (width &lt; total_buttons_size)
+				width = total_buttons_size;
+			
+			width += space_between_text_and_left_edge + space_between_text_and_right_edge;
+
+			button[0]-&gt;set_position(
+				width / 2 - total_buttons_size / 2, btn_pos_y);
+			button[1]-&gt;set_position(
+				width / 2 - total_buttons_size / 2 +
+				button[0]-&gt;get_width() + space_between_buttons,
+				btn_pos_y);
+			button[2]-&gt;set_position(
+				width / 2 - total_buttons_size / 2 +
+					button[0]-&gt;get_width() + space_between_buttons +
+					button[1]-&gt;get_width() + space_between_buttons,
+				btn_pos_y);
+
+			slot_button[0] = button[0]-&gt;sig_clicked().connect(
+				this, &amp;CL_MessageBox_Generic::on_button, 0);
+			slot_button[1] = button[1]-&gt;sig_clicked().connect(
+				this, &amp;CL_MessageBox_Generic::on_button, 1);
+			slot_button[2] = button[2]-&gt;sig_clicked().connect(
+				this, &amp;CL_MessageBox_Generic::on_button, 2);
+
+			// add buttons height to height
+			height += button[0]-&gt;get_height();
+		}
+		break;
+	}
+
+ 	button_count = num_buttons;
+ 
+	// Calc and set real dialog position
+	width += left_edge_offset + right_edge_offset;
+	height += top_edge_offset + bottom_edge_offset;
+	
+	// Calculating height of text
+	int text_height = font-&gt;get_height(text,
+		CL_Size(width - space_between_text_and_left_edge -
+			space_between_text_and_right_edge,
+			0));
+
+	height += text_height;
+
+	// Repositioning buttons to reflect text height
+	for(int i = 0; i &lt; button_count; ++i)
+	{
+		CL_Rect rc = button[i]-&gt;get_position();
+		button[i]-&gt;set_position(rc.left, rc.top + text_height);
+	}
+
+	messagebox-&gt;set_position(CL_Rect(
+		CL_Display::get_width()  / 2 - width / 2,
+		CL_Display::get_height() / 2 - height / 2,
+		CL_Display::get_width()  / 2 + width / 2,
+		CL_Display::get_height() / 2 + height / 2));
+
+	slot_end_paint = messagebox-&gt;get_client_area()-&gt;sig_end_paint().connect(
+		this, &amp;CL_MessageBox_Generic::on_end_paint);
+}
+
+CL_MessageBox_Generic::~CL_MessageBox_Generic()
+{
+	delete font;
+	for(int i = 0; i &lt; button_count; i++)
+		delete button[i];
+}
+
+void CL_MessageBox_Generic::on_button(int button)
+{
+	result_button = button;
+	messagebox-&gt;quit();
+}
+
+void CL_MessageBox_Generic::on_end_paint()
+{
+	CL_Rect text_rect = messagebox-&gt;get_client_area()-&gt;get_screen_rect();
+
+	text_rect.left   += space_between_text_and_left_edge;
+	text_rect.right  -= space_between_text_and_right_edge;
+	text_rect.top    += space_between_title_and_text;
+	// don't need to modify bottom, because text wasn't changed, so
+	// it shouldn't overwrite buttons
+
+	font-&gt;draw(text_rect, text);
+}
+

Added: trunk/clanlib/GUI/messagebox_generic.h
===================================================================
--- trunk/clanlib/GUI/messagebox_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/messagebox_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,72 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_dialog_generic
+#define header_dialog_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/GUI/messagebox.h&quot;
+#include &quot;API/GUI/button.h&quot;
+#include &quot;API/GUI/label.h&quot;
+
+class CL_Font;
+
+class CL_MessageBox_Generic
+{
+public:
+	CL_MessageBox_Generic(
+		CL_MessageBox *self,
+		const std::string &amp;title,
+		const std::string &amp;text,
+		const std::string &amp;button1,
+		const std::string &amp;button2,
+		const std::string &amp;button3);
+
+	~CL_MessageBox_Generic();
+
+	std::string text;
+
+	CL_MessageBox *messagebox;
+
+	CL_Font * font;
+	CL_Button *button[3];
+	int button_count;
+
+	CL_Slot slot_button[3];
+	CL_Slot slot_end_paint;
+	void on_button(int button);
+	void on_end_paint();
+
+	int result_button;
+};
+
+#endif

Added: trunk/clanlib/GUI/precomp.cpp
===================================================================
--- trunk/clanlib/GUI/precomp.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/precomp.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,30 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;

Added: trunk/clanlib/GUI/precomp.h
===================================================================
--- trunk/clanlib/GUI/precomp.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/precomp.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,56 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_precomp_gui
+#define header_precomp_gui
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#ifdef _MSC_VER
+#pragma warning (disable:4786)
+
+#include &quot;API/core.h&quot;
+#include &quot;API/display.h&quot;
+
+// Framework
+#include &quot;API/GUI/component.h&quot;
+#include &quot;API/GUI/component_manager.h&quot;
+#include &quot;API/GUI/component_type.h&quot;
+#include &quot;API/GUI/component_move_handler.h&quot;
+#include &quot;API/GUI/component_resize_handler.h&quot;
+#include &quot;API/GUI/component_style.h&quot;
+#include &quot;API/GUI/gui_manager.h&quot;
+#include &quot;API/GUI/setupgui.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+
+#endif
+
+#endif

Added: trunk/clanlib/GUI/progressbar.cpp
===================================================================
--- trunk/clanlib/GUI/progressbar.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/progressbar.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,115 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/GUI/progressbar.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;progressbar_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_ProgressBar::CL_ProgressBar(
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(parent, style), impl(NULL)
+{
+	impl = new CL_ProgressBar_Generic(this, 0);
+	get_style_manager()-&gt;connect_styles(&quot;progressbar&quot;, this);
+	find_preferred_size();
+}
+
+CL_ProgressBar::CL_ProgressBar(
+	int steps,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(parent, style), impl(NULL)
+{
+	impl = new CL_ProgressBar_Generic(this, steps);
+	get_style_manager()-&gt;connect_styles(&quot;progressbar&quot;, this);
+	find_preferred_size();
+}
+
+CL_ProgressBar::CL_ProgressBar(
+	const CL_Rect &amp;pos,
+	int steps,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(pos, parent, style), impl(NULL)
+{
+	impl = new CL_ProgressBar_Generic(this, steps);
+	get_style_manager()-&gt;connect_styles(&quot;progressbar&quot;, this);
+}
+
+CL_ProgressBar::~CL_ProgressBar()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+int CL_ProgressBar::get_progress() const
+{
+	return impl-&gt;progress;
+}
+
+int CL_ProgressBar::get_steps() const
+{
+	return impl-&gt;steps;
+}
+
+float CL_ProgressBar::get_percentage() const
+{
+	return impl-&gt;get_percentage();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_ProgressBar::set_steps(int total_steps)
+{
+	impl-&gt;set_steps(total_steps);
+}
+
+void CL_ProgressBar::set_progress(int progress)
+{
+	impl-&gt;set_progress(progress);
+}
+
+void CL_ProgressBar::increase(int steps)
+{
+	impl-&gt;increase(steps);
+}
+
+void CL_ProgressBar::reset()
+{
+	impl-&gt;reset();
+}

Added: trunk/clanlib/GUI/progressbar_generic.cpp
===================================================================
--- trunk/clanlib/GUI/progressbar_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/progressbar_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,99 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;progressbar_generic.h&quot;
+#include &quot;API/GUI/progressbar.h&quot;
+#include &quot;API/GUI/component.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_ProgressBar_Generic::CL_ProgressBar_Generic(
+	CL_ProgressBar *self,
+	int steps)
+:
+	progress(0),
+	progressbar(self)
+{
+	set_steps(steps);
+
+	slot_set_options = progressbar-&gt;sig_set_options().connect(
+		this, &amp;CL_ProgressBar_Generic::on_set_options);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+float CL_ProgressBar_Generic::get_percentage() const
+{
+	return (float)progress / steps;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_ProgressBar_Generic::set_steps(int total_steps)
+{
+	steps = total_steps;
+
+	if(progress &gt; steps)
+		progress = steps;
+}
+
+void CL_ProgressBar_Generic::set_progress(int new_progress)
+{
+	progress = new_progress;
+	if(progress &gt; steps)
+		progress = steps;
+	if(progress &lt; 0)
+		progress = 0;
+}
+
+void CL_ProgressBar_Generic::increase(int steps)
+{
+	set_progress(progress + steps);
+}
+
+void CL_ProgressBar_Generic::reset()
+{
+	progress = 0;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_ProgressBar_Generic::on_set_options(const CL_DomElement &amp;options)
+{
+	if (options.has_attribute(&quot;steps&quot;))
+		set_steps(CL_String::to_int(options.get_attribute(&quot;steps&quot;)));
+}

Added: trunk/clanlib/GUI/progressbar_generic.h
===================================================================
--- trunk/clanlib/GUI/progressbar_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/progressbar_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,78 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_progressbar_generic
+#define header_progressbar_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;API/Core/System/timer.h&gt;
+#include &lt;API/Display/input_event.h&gt;
+#include &lt;API/Core/Math/rect.h&gt;
+#include &lt;API/signals.h&gt;
+
+class CL_ProgressBar;
+class CL_Button;
+class CL_InputDevice;
+class CL_Component;
+class CL_DomElement;
+class CL_StyleManager;
+
+class CL_ProgressBar_Generic
+{
+//! Construction:
+public:
+	CL_ProgressBar_Generic(CL_ProgressBar *self, int steps);
+	~CL_ProgressBar_Generic() {};
+
+//! Attributes:
+public:
+	float get_percentage() const;
+
+	int steps;
+	int progress;
+
+//! Operations:
+public:
+	void set_steps(int total_steps);
+	void set_progress(int progress);
+	void increase(int steps);
+	void reset();
+
+//! Implementation:
+private:
+	CL_ProgressBar *progressbar;
+
+	void on_set_options(const CL_DomElement &amp;options);
+	CL_Slot slot_set_options;
+};
+
+#endif

Added: trunk/clanlib/GUI/radiobutton.cpp
===================================================================
--- trunk/clanlib/GUI/radiobutton.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/radiobutton.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,90 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/GUI/radiobutton.h&quot;
+#include &quot;API/GUI/component.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_RadioButton::CL_RadioButton(
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Button(parent, style)
+{
+	set_toggle_mode();
+	get_style_manager()-&gt;connect_styles(&quot;radiobutton&quot;, this);
+	find_preferred_size();
+}
+
+CL_RadioButton::CL_RadioButton(
+	const std::string &amp;text,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Button(text, parent, style)
+{
+	set_toggle_mode();
+	get_style_manager()-&gt;connect_styles(&quot;radiobutton&quot;, this);
+	find_preferred_size();
+}
+
+CL_RadioButton::CL_RadioButton(
+	const CL_Point &amp;pos,
+	const std::string &amp;text,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Button(pos, text, parent, style)
+{
+	set_toggle_mode();
+	get_style_manager()-&gt;connect_styles(&quot;radiobutton&quot;, this);
+	find_preferred_size();
+}
+
+CL_RadioButton::~CL_RadioButton()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+bool CL_RadioButton::is_checked() const
+{
+	return is_down();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_RadioButton::set_checked(bool check)
+{
+	set_down(check);
+}

Added: trunk/clanlib/GUI/radiogroup.cpp
===================================================================
--- trunk/clanlib/GUI/radiogroup.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/radiogroup.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,89 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;../API/GUI/radiogroup.h&quot;
+#include &quot;radiogroup_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_RadioGroup::CL_RadioGroup()
+{
+	impl = new CL_RadioGroup_Generic();
+}
+
+CL_RadioGroup::~CL_RadioGroup()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+int CL_RadioGroup::get_count() const
+{
+	return impl-&gt;buttons.size();
+}
+	
+CL_RadioButton *CL_RadioGroup::get_toggled() const
+{
+	return impl-&gt;get_toggled();
+}
+
+const std::vector&lt;CL_RadioButton *&gt; &amp;CL_RadioGroup::get_buttons() const
+{
+	return impl-&gt;buttons;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_RadioGroup::add(CL_RadioButton *button, bool delete_component)
+{
+	impl-&gt;add(button, delete_component);
+}
+	
+void CL_RadioGroup::remove(CL_RadioButton *button)
+{
+	impl-&gt;remove(button);
+}
+
+void CL_RadioGroup::set_checked(CL_RadioButton *button)
+{
+	impl-&gt;set_checked(button);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Signals:
+
+CL_Signal_v1&lt;CL_RadioButton *&gt; &amp;CL_RadioGroup::sig_selection_changed()
+{
+	return impl-&gt;sig_selection_changed;
+}

Added: trunk/clanlib/GUI/radiogroup_generic.cpp
===================================================================
--- trunk/clanlib/GUI/radiogroup_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/radiogroup_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,102 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;../API/GUI/radiobutton.h&quot;
+#include &quot;radiogroup_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+CL_RadioButton *CL_RadioGroup_Generic::get_toggled() const
+{
+	std::vector&lt;CL_RadioButton *&gt;::const_iterator it;
+	for(it = buttons.begin(); it != buttons.end(); ++it)
+		if((*it)-&gt;is_checked())
+			return (*it);
+
+	return 0;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_RadioGroup_Generic::add(CL_RadioButton *button, bool delete_component)
+{
+	// TODO: Use delete_component
+	
+	buttons.push_back(button);
+
+	slots.connect(button-&gt;sig_clicked(), this, &amp;CL_RadioGroup_Generic::on_button_clicked, button);
+}
+
+void CL_RadioGroup_Generic::remove(CL_RadioButton *button)
+{
+	// TODO: Remove clicked-slot from slots as well
+	
+	std::vector&lt;CL_RadioButton *&gt;::iterator it;
+	for(it = buttons.begin(); it != buttons.end(); ++it)
+	{
+		if((*it) == button)
+		{
+			buttons.erase(it);
+			return;
+		}	
+	}
+}
+
+void CL_RadioGroup_Generic::set_checked(CL_RadioButton *button)
+{
+	if(button-&gt;is_checked())
+		return;
+		
+	std::vector&lt;CL_RadioButton *&gt;::const_iterator it;
+	for(it = buttons.begin(); it != buttons.end(); ++it)
+		(*it)-&gt;set_checked((*it) == button);
+
+	sig_selection_changed(button);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_RadioGroup_Generic::on_button_clicked(CL_RadioButton *button)
+{
+	std::vector&lt;CL_RadioButton *&gt;::iterator it;
+	for(it = buttons.begin(); it != buttons.end(); ++it)
+	{
+		if((*it) != button)
+			(*it)-&gt;set_checked(false);
+		else
+		{
+			button-&gt;set_checked(true);
+			sig_selection_changed(button);
+		}
+	}
+}

Added: trunk/clanlib/GUI/radiogroup_generic.h
===================================================================
--- trunk/clanlib/GUI/radiogroup_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/radiogroup_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,62 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_radiogroup_generic
+#define header_radiogroup_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;../API/signals.h&quot;
+
+class CL_RadioButton;
+
+class CL_RadioGroup_Generic
+{
+public:
+	CL_RadioGroup_Generic() {};
+
+	void add(CL_RadioButton *button, bool delete_component);
+	void remove(CL_RadioButton *button);
+	void set_checked(CL_RadioButton *button);
+
+	CL_RadioButton *get_toggled() const;
+	
+	CL_Signal_v1&lt;CL_RadioButton *&gt; sig_selection_changed;
+
+	std::vector&lt;CL_RadioButton *&gt; buttons;
+
+private:
+	void on_button_clicked(CL_RadioButton *button);
+
+	CL_SlotContainer slots;
+};
+
+#endif

Added: trunk/clanlib/GUI/scrollbar.cpp
===================================================================
--- trunk/clanlib/GUI/scrollbar.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/scrollbar.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,234 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/GUI/scrollbar.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;scrollbar_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_ScrollBar construction:
+
+CL_ScrollBar::CL_ScrollBar(
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(parent, style), impl(0)
+{
+	impl = new CL_ScrollBar_Generic(this, 0, 100, 0, false, true);
+	get_style_manager()-&gt;connect_styles(&quot;scrollbar&quot;, this);
+	find_preferred_size();
+}
+
+CL_ScrollBar::CL_ScrollBar(
+	int min,
+	int max,
+	bool orientation,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(parent, style), impl(0)
+{
+	impl = new CL_ScrollBar_Generic(this, min, max, 0, orientation, true);
+	get_style_manager()-&gt;connect_styles(&quot;scrollbar&quot;, this);
+	find_preferred_size();
+}
+
+CL_ScrollBar::CL_ScrollBar(
+	bool orientation,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(parent, style), impl(0)
+{
+	impl = new CL_ScrollBar_Generic(this, 0, 100, 0, orientation, true);
+	get_style_manager()-&gt;connect_styles(&quot;scrollbar&quot;, this);
+	find_preferred_size();
+}
+
+CL_ScrollBar::CL_ScrollBar(
+	const CL_Rect &amp;pos,
+	int min,
+	int max,
+	bool orientation,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(pos, parent, style), impl(0)
+{
+	impl = new CL_ScrollBar_Generic(this, min, max, 0, orientation, true);
+	get_style_manager()-&gt;connect_styles(&quot;scrollbar&quot;, this);
+}
+
+CL_ScrollBar::CL_ScrollBar(
+	const CL_Rect &amp;pos,
+	bool orientation,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(pos, parent, style), impl(0)
+{
+	impl = new CL_ScrollBar_Generic(this, 0, 100, 0, orientation, false);
+	get_style_manager()-&gt;connect_styles(&quot;scrollbar&quot;, this);
+}
+
+CL_ScrollBar::~CL_ScrollBar()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+bool CL_ScrollBar::is_vertical() const
+{
+	return impl-&gt;vertical;
+}
+
+bool CL_ScrollBar::is_tracking() const
+{
+	return impl-&gt;tracking;
+}
+
+int CL_ScrollBar::get_min_value() const
+{
+	return impl-&gt;min_value;
+}
+
+int CL_ScrollBar::get_max_value() const
+{
+	return impl-&gt;max_value;
+}
+
+int CL_ScrollBar::get_value() const
+{
+	return impl-&gt;cur_value;
+}
+
+int CL_ScrollBar::get_range() const
+{
+	return impl-&gt;get_range();
+}
+
+bool CL_ScrollBar::is_dragging_slider() const
+{
+	return impl-&gt;dragging;
+}
+
+CL_Rect &amp;CL_ScrollBar::get_slider_rect() const
+{
+	return impl-&gt;rect_slider;
+}
+
+bool CL_ScrollBar::is_fixed_length_slider() const
+{
+	return impl-&gt;fixed_length;
+}
+
+int CL_ScrollBar::get_min_slider_length() const
+{
+	return impl-&gt;min_slider_length;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_ScrollBar::set_vertical(bool enable)
+{
+	impl-&gt;set_vertical(enable);
+}
+
+void CL_ScrollBar::set_tracking(bool enable)
+{
+	impl-&gt;tracking = enable;
+}
+
+void CL_ScrollBar::set_range(int min_value, int max_value)
+{
+	impl-&gt;set_range(min_value, max_value);
+}
+
+void CL_ScrollBar::set_min_value(int value)
+{
+	impl-&gt;set_min_value(value);
+}
+
+void CL_ScrollBar::set_max_value(int value)
+{
+	impl-&gt;set_max_value(value);
+}
+
+void CL_ScrollBar::set_value(int value)
+{
+	impl-&gt;set_value(value);
+}
+
+void CL_ScrollBar::increase(int step)
+{
+	impl-&gt;set_value(impl-&gt;cur_value + step);
+}
+
+void CL_ScrollBar::decrease(int step)
+{
+	impl-&gt;set_value(impl-&gt;cur_value - step);
+}
+
+void CL_ScrollBar::set_fixed_length_mode(bool enable)
+{
+	impl-&gt;fixed_length = enable;
+}
+
+void CL_ScrollBar::set_slider_length(int length)
+{
+	impl-&gt;fixed_slider_length = length;
+}
+
+void CL_ScrollBar::set_min_slider_length(int length)
+{
+	impl-&gt;min_slider_length = length;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Signals:
+
+CL_Signal_v1&lt;int&gt; &amp;CL_ScrollBar::sig_value_changed()
+{
+	return impl-&gt;sig_value_changed;
+}
+
+CL_Signal_v0 &amp;CL_ScrollBar::sig_slider_pressed()
+{
+	return impl-&gt;sig_slider_pressed;
+}
+
+CL_Signal_v1&lt;int&gt; &amp;CL_ScrollBar::sig_slider_moved()
+{
+	return impl-&gt;sig_slider_moved;
+}
+
+CL_Signal_v0 &amp;CL_ScrollBar::sig_slider_released()
+{
+	return impl-&gt;sig_slider_released;
+}

Added: trunk/clanlib/GUI/scrollbar_generic.cpp
===================================================================
--- trunk/clanlib/GUI/scrollbar_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/scrollbar_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,410 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;scrollbar_generic.h&quot;
+#include &quot;API/GUI/scrollbar.h&quot;
+#include &quot;API/GUI/component.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+#include &quot;API/GUI/button.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;API/Display/keys.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+#include &quot;API/Core/System/clanstring.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_ScrollBar_Generic::CL_ScrollBar_Generic(
+	CL_ScrollBar *self,
+	int min,
+	int max,
+	int value,
+	bool orientation,
+	bool tracking)
+:
+	min_value(0),
+	max_value(0),
+	cur_value(0),
+	tracking(tracking),
+	fixed_length(false),
+	dragging(false),
+	scrollbar(self),
+	capture_last_offset(0),
+	timer_scroll(250)
+{
+	vertical = !orientation;
+
+	if(vertical)
+		min_slider_length = scrollbar-&gt;get_height() / 6;
+	else
+		min_slider_length = scrollbar-&gt;get_width() / 6;
+	if(min_slider_length &lt; 20)
+		min_slider_length = 20;
+
+	set_min_value(min);
+	set_max_value(max);
+	set_value(value);
+
+	CL_Rect rect(0, 0, scrollbar-&gt;get_width(), scrollbar-&gt;get_height());
+	CL_Component *client_area = new CL_Component(rect, scrollbar);
+	scrollbar-&gt;set_client_area(client_area);
+	
+	slots.connect(scrollbar-&gt;sig_set_options(), this, &amp;CL_ScrollBar_Generic::on_set_options);
+	slots.connect(client_area-&gt;sig_mouse_move(), this, &amp;CL_ScrollBar_Generic::on_mouse_move);
+	slots.connect(client_area-&gt;sig_mouse_down(), this, &amp;CL_ScrollBar_Generic::on_mouse_down);
+	slots.connect(client_area-&gt;sig_mouse_up(), this, &amp;CL_ScrollBar_Generic::on_mouse_up);
+	slots.connect(client_area-&gt;sig_resize(), this, &amp;CL_ScrollBar_Generic::on_client_resize);
+	slots.connect(timer_scroll.sig_timer(), this, &amp;CL_ScrollBar_Generic::on_timer_scroll);
+}
+
+CL_ScrollBar_Generic::~CL_ScrollBar_Generic()
+{
+	delete scrollbar-&gt;get_client_area();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+int CL_ScrollBar_Generic::get_range() const
+{
+	return max_value - min_value + 1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_ScrollBar_Generic::set_vertical(bool enable)
+{
+	throw CL_Error(&quot;CL_ScrollBar_Generic::set_vertical() is not implemented&quot;);
+}
+
+void CL_ScrollBar_Generic::set_range(int new_min_value, int new_max_value)
+{
+	min_value = new_min_value;
+	max_value = new_max_value;
+
+	if(max_value &lt; min_value)
+		max_value = min_value;
+	
+	if(cur_value &lt; min_value)
+		cur_value = min_value;
+	if(cur_value &gt; max_value)
+		cur_value = max_value;
+
+	calculate_slider();
+}
+
+void CL_ScrollBar_Generic::set_min_value(int value)
+{
+	min_value = value;
+	if(max_value &lt; min_value)
+		max_value = min_value;
+	
+	if(cur_value &lt; min_value)
+		cur_value = min_value;
+
+	calculate_slider();
+}
+
+void CL_ScrollBar_Generic::set_max_value(int value)
+{
+	max_value = value;
+	if(max_value &lt; min_value)
+		max_value = min_value;
+	
+	if(cur_value &gt; max_value)
+		cur_value = max_value;
+
+	calculate_slider();
+}
+
+void CL_ScrollBar_Generic::set_value(int value, bool using_slider)
+{
+	if(value &lt; min_value) value = min_value;
+	if(value &gt; max_value) value = max_value;
+
+	if(cur_value != value)
+	{
+		cur_value = value;
+
+		if(using_slider)
+			sig_slider_moved(cur_value);
+
+		if((using_slider &amp;&amp; tracking) || using_slider == false)
+			sig_value_changed(cur_value);
+	}
+
+	if(using_slider == false)
+		calculate_slider();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_ScrollBar_Generic::on_set_options(const CL_DomElement &amp;options)
+{
+	if (options.has_attribute(&quot;orientation&quot;))
+	{
+		std::string s = CL_String::to_lower(options.get_attribute(&quot;orientation&quot;));
+
+		if(s == &quot;hor&quot; || s == &quot;horz&quot; | s == &quot;horizontal&quot; || s == &quot;1&quot;)
+			vertical = false;
+		else if(s == &quot;ver&quot; || s == &quot;vert&quot; | s == &quot;vertical&quot; || s == &quot;0&quot;)
+			vertical = true;
+		else
+			throw CL_Error(&quot;Invalid scrollbar orientation value&quot;);
+	}
+	else
+		vertical = true;
+	
+	if (options.has_attribute(&quot;min&quot;))
+		set_min_value(CL_String::to_int(options.get_attribute(&quot;min&quot;)));
+	else
+		set_min_value(0);
+
+	if (options.has_attribute(&quot;max&quot;))
+		set_max_value(CL_String::to_int(options.get_attribute(&quot;max&quot;)));
+	else
+		set_max_value(min_value);
+
+	if (options.has_attribute(&quot;value&quot;))
+		set_value(CL_String::to_int(options.get_attribute(&quot;value&quot;)));
+	else
+		set_value(min_value);
+
+	if (options.has_attribute(&quot;tracking&quot;))
+		tracking = CL_String::to_bool(options.get_attribute(&quot;tracking&quot;));
+	else
+		tracking = false;
+		
+	scrollbar-&gt;sig_resize()(0,0);
+}
+
+void CL_ScrollBar_Generic::on_client_resize(int old_width, int old_height)
+{
+	calculate_slider();
+}
+
+void CL_ScrollBar_Generic::on_mouse_down(const CL_InputEvent &amp;key)
+{
+	if(key.id == CL_MOUSE_WHEEL_UP)
+	{
+		set_value(cur_value - 5);
+		return;
+	}
+	if(key.id == CL_MOUSE_WHEEL_DOWN)
+	{
+		set_value(cur_value + 5);
+		return;
+	}
+	if(key.id == CL_MOUSE_LEFT)
+	{
+		if(dragging == false)
+		{
+			if(key.mouse_pos.x &gt; rect_slider.left &amp;&amp; 
+				key.mouse_pos.y &gt; rect_slider.top &amp;&amp; 
+				key.mouse_pos.x &lt; rect_slider.right &amp;&amp; 
+				key.mouse_pos.y &lt; rect_slider.bottom)
+			{
+				dragging = true;
+				scrollbar-&gt;get_client_area()-&gt;capture_mouse();
+				if(vertical) 
+					capture_last_offset = (int) key.mouse_pos.y;
+				else
+					capture_last_offset = (int) key.mouse_pos.x;
+				sig_slider_pressed();
+			}
+			else
+			{
+				int scrollbar_length;
+				int slider_length;
+
+				scroll_delta = 1;
+
+				if(vertical)
+				{
+					scrollbar_length = scrollbar-&gt;get_client_area()-&gt;get_height();
+					slider_length = rect_slider.get_height();
+
+					if(key.mouse_pos.y &lt; rect_slider.top)
+						scroll_delta = -1;
+				}
+				else
+				{
+					scrollbar_length = scrollbar-&gt;get_client_area()-&gt;get_width();
+					slider_length = rect_slider.get_width();
+
+					if(key.mouse_pos.x &lt; rect_slider.left)
+						scroll_delta = -1;
+				}
+
+				float percent = slider_length / (float)(scrollbar_length - slider_length);
+				scroll_delta *= (int)( get_range() * percent);
+
+				on_timer_scroll();
+				timer_scroll.enable();
+				scrollbar-&gt;get_client_area()-&gt;capture_mouse();
+			}
+		}
+	}
+}
+
+void CL_ScrollBar_Generic::on_mouse_up(const CL_InputEvent &amp;key)
+{
+	if(key.id == CL_MOUSE_LEFT)
+	{
+		if(dragging)
+		{
+			scrollbar-&gt;get_client_area()-&gt;release_mouse();
+			dragging = false;
+
+			set_value(cur_value);
+
+			if(tracking == false)
+				sig_value_changed(cur_value);
+			sig_slider_released();
+		}
+		else if(timer_scroll.is_enabled())
+		{
+			timer_scroll.disable();
+			scrollbar-&gt;get_client_area()-&gt;release_mouse();
+		}
+	}
+}
+
+void CL_ScrollBar_Generic::on_mouse_move(const CL_InputEvent &amp;key)
+{
+	if(dragging == false)
+		return;
+
+	if(vertical)
+	{
+//		key.mouse_pos.y -= client_area-&gt;get_position().y1;
+
+		int delta = key.mouse_pos.y - capture_last_offset;
+
+		int scrollbar_length = scrollbar-&gt;get_client_area()-&gt;get_height();
+		int slider_length = rect_slider.get_height();
+
+		rect_slider.top += delta;
+
+		if(rect_slider.top &lt; 0)
+			rect_slider.top = 0;
+		else if(rect_slider.top + slider_length &gt; scrollbar_length)
+			rect_slider.top = scrollbar_length - slider_length;
+		else
+			capture_last_offset = key.mouse_pos.y;
+
+		rect_slider.bottom = rect_slider.top + slider_length;
+
+		float percent = (float)rect_slider.top / (scrollbar_length - slider_length);
+		float value = min_value + (get_range() * percent);
+		set_value((int)value, true);
+	} 
+	else
+	{
+//		key.mouse_pos.x -= client_area-&gt;get_position().x1;
+
+		int delta = key.mouse_pos.x - capture_last_offset;
+
+		int scrollbar_length = scrollbar-&gt;get_client_area()-&gt;get_width();
+		int slider_length = rect_slider.get_width();
+
+		rect_slider.left += delta;
+
+		if(rect_slider.left &lt; 0)
+			rect_slider.left = 0;
+		else if(rect_slider.left + slider_length &gt; scrollbar_length)
+			rect_slider.left = scrollbar_length - slider_length;
+		else capture_last_offset = key.mouse_pos.x;
+
+		rect_slider.right = rect_slider.left + slider_length;
+
+		float percent = (float)rect_slider.left / (scrollbar_length - slider_length);
+		float value = min_value + (get_range() * percent);
+		set_value((int)value, true);
+	}
+}
+
+void CL_ScrollBar_Generic::on_timer_scroll()
+{
+	set_value(cur_value + scroll_delta);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Implementation:
+
+void CL_ScrollBar_Generic::calculate_slider()
+{
+	int slider_offset;
+	int slider_length;
+
+	if(fixed_length)
+	{
+		throw CL_Error(&quot;fixed-length sliders not implemented&quot;);
+	}
+	else {
+		int scrollbar_length;
+		if(vertical)
+			scrollbar_length = scrollbar-&gt;get_client_area()-&gt;get_height();
+		else
+			scrollbar_length = scrollbar-&gt;get_client_area()-&gt;get_width();
+		
+		int range = get_range();
+
+		slider_length = scrollbar_length / range;
+		if(slider_length &lt; min_slider_length)
+			slider_length = min_slider_length;
+
+		float y = 0.0f;
+		if(range &gt; 1)
+		{
+			int available_area = scrollbar_length - slider_length;
+			y = (float)available_area / (range - 1);
+		}
+
+		slider_offset = (int) (y * (cur_value - min_value));
+	}
+
+	if(vertical)
+	{
+		rect_slider.top = slider_offset;
+		rect_slider.bottom = slider_offset + slider_length;
+		rect_slider.left = 0;
+		rect_slider.right = scrollbar-&gt;get_client_area()-&gt;get_width();
+	}
+	else
+	{
+		rect_slider.left = slider_offset;
+		rect_slider.right = slider_offset + slider_length;
+		rect_slider.top = 0;
+		rect_slider.bottom = scrollbar-&gt;get_client_area()-&gt;get_height();
+	}
+}

Added: trunk/clanlib/GUI/scrollbar_generic.h
===================================================================
--- trunk/clanlib/GUI/scrollbar_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/scrollbar_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,124 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_scrollbar_generic
+#define header_scrollbar_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/Core/System/timer.h&quot;
+#include &quot;API/Core/Math/rect.h&quot;
+#include &quot;API/Display/input_event.h&quot;
+#include &quot;API/signals.h&quot;
+
+class CL_ScrollBar;
+class CL_Button;
+class CL_InputDevice;
+class CL_Component;
+class CL_DomElement;
+class CL_StyleManager;
+
+class CL_ScrollBar_Generic
+{
+//! Construction:
+public:
+	CL_ScrollBar_Generic(
+		CL_ScrollBar *self,
+		int min,
+		int max,
+		int value,
+		bool orientation,
+		bool tracking);
+
+	~CL_ScrollBar_Generic();
+
+//! Attributes:
+public:
+	int get_range() const;
+
+	int min_value;
+	int max_value;
+	int cur_value;
+
+	bool tracking;
+	bool vertical;
+	bool fixed_length;
+
+	bool dragging;
+
+	CL_Rect rect_slider;
+	int min_slider_length;
+	int fixed_slider_length;
+			
+//! Operations:
+public:
+	void set_vertical(bool enable);
+	void set_range(int min_value, int max_value);
+	void set_min_value(int value);
+	void set_max_value(int value);
+	void set_value(int value, bool using_slider = false);
+
+//! Signals:
+public:
+	CL_Signal_v1&lt;int&gt; sig_value_changed;
+	CL_Signal_v0 sig_slider_pressed;
+	CL_Signal_v1&lt;int&gt; sig_slider_moved;
+	CL_Signal_v0 sig_slider_released;
+
+//! Slots:
+private:
+	CL_SlotContainer slots;
+
+//! Callbacks:
+private:
+	void on_set_options(const CL_DomElement &amp;options);
+	void on_child_add(CL_Component *child);
+	void on_child_remove(CL_Component *child);
+	void on_mouse_down(const CL_InputEvent &amp;key);
+	void on_mouse_up(const CL_InputEvent &amp;key);
+	void on_mouse_move(const CL_InputEvent &amp;key);
+	void on_client_resize(int old_width, int old_height);
+	void on_timer_scroll();
+
+//! Implementation:
+private:
+	void calculate_slider();
+
+	CL_ScrollBar *scrollbar;
+
+	bool mouse_captured;
+	int capture_last_offset;
+
+	CL_Timer timer_scroll;
+	int scroll_delta;
+};
+
+#endif

Added: trunk/clanlib/GUI/setupgui.cpp
===================================================================
--- trunk/clanlib/GUI/setupgui.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/setupgui.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,89 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/GUI/setupgui.h&quot;
+#include &quot;API/GUI/component_manager.h&quot;
+#include &quot;default_component_types.h&quot;
+
+static int ref_count = 0;
+
+CL_SetupGUI::CL_SetupGUI(bool register_resources_only)
+{
+	CL_SetupGUI::init(register_resources_only);
+}
+
+CL_SetupGUI::~CL_SetupGUI()
+{
+	CL_SetupGUI::deinit();
+}
+
+void CL_SetupGUI::init(bool register_resources_only)
+{
+	ref_count++;
+	if (ref_count != 1) return;
+
+	if (register_resources_only) return;
+
+	CL_ComponentType::component_types[&quot;component&quot;] = new CL_ComponentType_Component;
+	CL_ComponentType::component_types[&quot;button&quot;] = new CL_ComponentType_Button;
+	CL_ComponentType::component_types[&quot;checkbox&quot;] = new CL_ComponentType_CheckBox;
+	CL_ComponentType::component_types[&quot;filedialog&quot;] = new CL_ComponentType_FileDialog;
+	CL_ComponentType::component_types[&quot;frame&quot;] = new CL_ComponentType_Frame;
+	CL_ComponentType::component_types[&quot;image&quot;] = new CL_ComponentType_Image;
+	CL_ComponentType::component_types[&quot;inputbox&quot;] = new CL_ComponentType_InputBox;
+	CL_ComponentType::component_types[&quot;label&quot;] = new CL_ComponentType_Label;
+	CL_ComponentType::component_types[&quot;listbox&quot;] = new CL_ComponentType_ListBox;
+	CL_ComponentType::component_types[&quot;progressbar&quot;] = new CL_ComponentType_ProgressBar;
+	CL_ComponentType::component_types[&quot;radiobutton&quot;] = new CL_ComponentType_RadioButton;
+	CL_ComponentType::component_types[&quot;scrollbar&quot;] = new CL_ComponentType_ScrollBar;
+	CL_ComponentType::component_types[&quot;window&quot;] = new CL_ComponentType_Window;
+	CL_ComponentType::component_types[&quot;treeview&quot;] = new CL_ComponentType_TreeView;
+}
+
+void CL_SetupGUI::deinit()
+{
+	ref_count--;
+	if (ref_count != 0) return;
+
+	delete CL_ComponentType::component_types[&quot;component&quot;];
+	delete CL_ComponentType::component_types[&quot;button&quot;];
+	delete CL_ComponentType::component_types[&quot;checkbox&quot;];
+	delete CL_ComponentType::component_types[&quot;filedialog&quot;];
+	delete CL_ComponentType::component_types[&quot;frame&quot;];
+	delete CL_ComponentType::component_types[&quot;image&quot;];
+	delete CL_ComponentType::component_types[&quot;inputbox&quot;];
+	delete CL_ComponentType::component_types[&quot;label&quot;];
+	delete CL_ComponentType::component_types[&quot;listbox&quot;];
+	delete CL_ComponentType::component_types[&quot;progressbar&quot;];
+	delete CL_ComponentType::component_types[&quot;radiobutton&quot;];
+	delete CL_ComponentType::component_types[&quot;scrollbar&quot;];
+	delete CL_ComponentType::component_types[&quot;window&quot;];
+	delete CL_ComponentType::component_types[&quot;treeview&quot;];
+}

Added: trunk/clanlib/GUI/stylemanager.cpp
===================================================================
--- trunk/clanlib/GUI/stylemanager.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/stylemanager.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,73 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/GUI/component_manager.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_StyleManager_Generic:
+
+class CL_StyleManager_Generic
+{
+public:
+	CL_ResourceManager *resources;
+};
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_StyleManager construction:
+
+CL_StyleManager::CL_StyleManager(CL_ResourceManager *resources)
+: impl(new CL_StyleManager_Generic)
+{
+	impl-&gt;resources = resources;
+}
+
+CL_StyleManager::~CL_StyleManager()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_StyleManager attributes:
+
+CL_ResourceManager *CL_StyleManager::get_resources()
+{
+	return impl-&gt;resources;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_StyleManager overridables:
+
+CL_Component *CL_StyleManager::create_component(
+	const std::string &amp;type,
+	CL_Component *parent)
+{
+	return CL_ComponentType::create_component(type, parent, this);
+}

Added: trunk/clanlib/GUI/treeitem.cpp
===================================================================
--- trunk/clanlib/GUI/treeitem.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/treeitem.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,172 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+
+#include &quot;treeitem_generic.h&quot;
+#include &quot;component_generic.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+#include &quot;API/GUI/treenode.h&quot;
+#include &quot;API/GUI/treeview.h&quot;
+#include &quot;API/GUI/checkbox.h&quot;
+#include &quot;API/Display/surface.h&quot;
+
+const static std::string blank;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_TreeItem::CL_TreeItem(
+	CL_TreeNode *node,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(parent, style), 
+  impl(NULL)
+{
+	impl = new CL_TreeItem_Generic(this, node);
+	get_style_manager()-&gt;connect_styles(&quot;treeitem&quot;, this);
+	find_preferred_size();
+	show(false);
+}
+
+CL_TreeItem::~CL_TreeItem()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+const std::string &amp;CL_TreeItem::get_text(int column) const
+{
+	if((unsigned int)column &gt;= impl-&gt;items.size())
+		return blank;
+
+	return impl-&gt;items[column].text;
+}
+
+CL_Component *CL_TreeItem::get_component(int column) const
+{
+	if((unsigned int)column &gt;= impl-&gt;items.size())
+		return NULL;
+
+	return impl-&gt;items[column].component;
+}
+
+CL_TreeNode *CL_TreeItem::get_node() const
+{
+	return impl-&gt;node;
+}
+
+CL_Surface *CL_TreeItem::get_icon() const
+{
+	return impl-&gt;sur_icon;
+}
+
+int CL_TreeItem::get_text_margin(void) const
+{
+	return impl-&gt;text_margin;
+}
+
+int CL_TreeItem::get_custom_height() const
+{
+	return impl-&gt;custom_height;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_TreeItem::set_text(int column, const std::string &amp;text)
+{
+	if(!text.empty())
+	{
+		if(impl-&gt;items.size() &lt;= (unsigned int)column)
+		{
+			for(unsigned int i = impl-&gt;items.size(); i &lt;= (unsigned int)column; ++i)
+				impl-&gt;items.push_back(CL_TreeItem_Generic::TreeItemStruct());
+		}
+
+		CL_TreeItem_Generic::TreeItemStruct item;
+		item.text = text;
+		impl-&gt;items[column] = item;
+	}
+}
+
+CL_CheckBox *CL_TreeItem::set_checkbox(int column, const std::string &amp;text)
+{
+	CL_CheckBox *checkbox = new CL_CheckBox(this);
+	checkbox-&gt;set_event_passing(false);
+	set_component(column, checkbox);
+	return checkbox;
+}
+
+void CL_TreeItem::set_component(int column, CL_Component *component)
+{
+	if(impl-&gt;items.size() &lt;= (unsigned int)column)
+	{
+		for(unsigned int i = impl-&gt;items.size(); i &lt;= (unsigned int)column; ++i)
+			impl-&gt;items.push_back(CL_TreeItem_Generic::TreeItemStruct());
+	}
+
+	CL_TreeItem_Generic::TreeItemStruct item;
+	item.component = component;
+	impl-&gt;items[column] = item;
+}
+
+void CL_TreeItem::set_icon(CL_Surface *surface, bool delete_surface)
+{
+	if(impl-&gt;sur_icon &amp;&amp; impl-&gt;delete_sur_icon)
+		delete impl-&gt;sur_icon;
+	
+	impl-&gt;sur_icon = surface;
+	impl-&gt;delete_sur_icon = delete_surface;
+
+	find_preferred_size();
+	get_node()-&gt;get_treeview()-&gt;sig_resize()(0,0);
+}
+
+void CL_TreeItem::set_text_margin(int margin)
+{
+	impl-&gt;text_margin = margin;
+}
+
+void CL_TreeItem::set_custom_height(int height)
+{
+	impl-&gt;custom_height = height;
+	find_preferred_size();
+	get_node()-&gt;get_treeview()-&gt;sig_resize()(0,0);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Signals:
+
+CL_Signal_v0 &amp;CL_TreeItem::sig_clicked()
+{
+	return impl-&gt;sig_clicked;
+}

Added: trunk/clanlib/GUI/treeitem_generic.cpp
===================================================================
--- trunk/clanlib/GUI/treeitem_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/treeitem_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,69 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;treeitem_generic.h&quot;
+#include &quot;API/GUI/treeitem.h&quot;
+#include &quot;API/GUI/component.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;API/Display/surface.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_TreeItem_Generic::CL_TreeItem_Generic(
+	CL_TreeItem *self,
+	CL_TreeNode *node)
+: node(node), 
+  sur_icon(0),
+  delete_sur_icon(false),
+  custom_height(0),
+  text_margin(0),
+  item(self)
+{
+	slot_mouse_down = item-&gt;sig_mouse_down().connect(
+		this, &amp;CL_TreeItem_Generic::on_mouse_down);
+
+	items.reserve(8);
+}
+
+CL_TreeItem_Generic::~CL_TreeItem_Generic()
+{
+	if(sur_icon &amp;&amp; delete_sur_icon)
+		delete sur_icon;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_TreeItem_Generic::on_mouse_down(const CL_InputEvent &amp;key)
+{
+//	item-&gt;sig_clicked()();
+}

Added: trunk/clanlib/GUI/treeitem_generic.h
===================================================================
--- trunk/clanlib/GUI/treeitem_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/treeitem_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,81 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_treeitem_generic
+#define header_treeitem_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/GUI/treeitem.h&quot;
+
+class CL_TreeNode;
+
+class CL_TreeItem_Generic
+{
+//! Construction:
+public:
+	CL_TreeItem_Generic(CL_TreeItem *self, CL_TreeNode *node);
+	~CL_TreeItem_Generic();
+
+//! Attributes:
+public:
+	struct TreeItemStruct
+	{
+		TreeItemStruct() { component = NULL; }
+
+		CL_Component *component;
+		std::string text;
+	};
+	std::vector&lt;TreeItemStruct&gt; items;
+
+	CL_TreeNode *node;
+
+	CL_Surface *sur_icon;
+	bool delete_sur_icon;
+	int custom_height;
+	int text_margin;
+
+//! Signals:
+public:
+	CL_Signal_v0 sig_clicked;
+
+//! Callbacks:
+private:
+	void on_mouse_down(const CL_InputEvent &amp;key);
+
+//! Implementation:
+private:
+	CL_TreeItem *item;
+
+	CL_Slot slot_mouse_down;
+};
+
+#endif

Added: trunk/clanlib/GUI/treenode.cpp
===================================================================
--- trunk/clanlib/GUI/treenode.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/treenode.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,329 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+
+#include &quot;API/GUI/treeview.h&quot;
+#include &quot;API/GUI/treeitem.h&quot;
+#include &quot;API/GUI/treenode.h&quot;
+#include &quot;treenode_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_TreeNode::CL_TreeNode(CL_TreeNode *parent, CL_TreeView *root)
+{
+	impl = new CL_TreeNode_Generic(this, parent, root);
+}
+
+CL_TreeNode::~CL_TreeNode()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+void *CL_TreeNode::get_userdata() const
+{
+	return impl-&gt;userdata;
+}
+
+CL_Component *CL_TreeNode::get_component() const
+{
+	return impl-&gt;component;
+}
+
+bool CL_TreeNode::is_selectable() const
+{
+	switch(impl-&gt;selectable)
+	{
+	case 0:
+		return false;
+		break;
+	case 1:
+		return true;
+		break;
+	default:
+		if(impl-&gt;parent)
+            return impl-&gt;parent-&gt;is_selectable();
+	}
+	return true;
+}
+
+bool CL_TreeNode::is_collapsable() const
+{
+	switch(impl-&gt;collapsable)
+	{
+	case 0:
+		return false;
+		break;
+	case 1:
+		return true;
+		break;
+	default:
+		if(impl-&gt;parent)
+            return impl-&gt;parent-&gt;is_collapsable();
+	}
+	return true;
+}
+
+bool CL_TreeNode::is_selected() const
+{
+	return impl-&gt;selected;
+}
+
+bool CL_TreeNode::is_collapsed() const
+{
+	return impl-&gt;collapsed;
+}
+
+bool CL_TreeNode::has_children() const
+{
+	return (impl-&gt;children.empty() == false);
+}
+
+bool CL_TreeNode::is_root() const
+{
+	return impl-&gt;root_node;
+}
+
+CL_TreeNode *CL_TreeNode::get_current_item() const
+{
+	// Do a depth-first search for current selected item.
+	std::list&lt;CL_TreeNode *&gt;::const_iterator it;
+	for (it = impl-&gt;children.begin(); it != impl-&gt;children.end(); ++it)
+	{
+		if((*it)-&gt;impl-&gt;selected)
+			return (*it);
+		else 
+		{
+			CL_TreeNode *node = (*it)-&gt;get_current_item();
+			if(node)
+				return node;
+		}
+	}
+	return NULL;
+}
+
+CL_TreeNode *CL_TreeNode::get_parent() const
+{
+	return impl-&gt;parent;
+}
+
+int CL_TreeNode::get_depth() const
+{
+	if(impl-&gt;parent == 0)
+		return 0;
+	else
+		return impl-&gt;parent-&gt;get_depth() + 1;
+}
+
+CL_TreeView *CL_TreeNode::get_treeview() const
+{
+	return impl-&gt;root;
+}
+
+int CL_TreeNode::get_placement_offset() const
+{
+	return impl-&gt;placement_offset;
+}
+
+int CL_TreeNode::get_items_height() const
+{
+	int height = 0;
+	if(impl-&gt;component &amp;&amp; impl-&gt;component-&gt;is_enabled(false))
+		height = impl-&gt;component-&gt;get_height();
+
+	std::list&lt;CL_TreeNode *&gt;::iterator it;
+	for (it = impl-&gt;children.begin(); it != impl-&gt;children.end(); ++it)
+		height += (*it)-&gt;get_items_height();
+
+	return height;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+CL_TreeItem *CL_TreeNode::insert_item(
+	const std::string &amp;label1, 
+	const std::string &amp;label2, 
+	const std::string &amp;label3, 
+	const std::string &amp;label4, 
+	const std::string &amp;label5, 
+	const std::string &amp;label6, 
+	const std::string &amp;label7, 
+	const std::string &amp;label8) 
+{
+	CL_TreeNode *node = new CL_TreeNode(this, impl-&gt;root);
+	impl-&gt;children.push_back(node);
+
+	if(impl-&gt;root == this)
+		node-&gt;impl-&gt;root_node = true;
+
+	CL_TreeItem *treeitem = new CL_TreeItem(node, impl-&gt;root-&gt;get_client_area());
+	treeitem-&gt;set_text(0, label1);
+	treeitem-&gt;set_text(1, label2);
+	treeitem-&gt;set_text(2, label3);
+	treeitem-&gt;set_text(3, label4);
+	treeitem-&gt;set_text(4, label5);
+	treeitem-&gt;set_text(5, label6);
+	treeitem-&gt;set_text(6, label7);
+	treeitem-&gt;set_text(7, label8);
+	treeitem-&gt;find_preferred_size();
+
+	node-&gt;set_component(treeitem);
+
+	impl-&gt;root-&gt;sig_item_added()(*node);
+
+	return treeitem;
+}
+
+CL_TreeNode *CL_TreeNode::insert_item(
+	CL_Component *component1, 
+	CL_Component *component2, 
+	CL_Component *component3, 
+	CL_Component *component4, 
+	CL_Component *component5, 
+	CL_Component *component6, 
+	CL_Component *component7, 
+	CL_Component *component8)
+{
+	CL_TreeNode *node = new CL_TreeNode(this, impl-&gt;root);
+	impl-&gt;children.push_back(node);
+
+	if(impl-&gt;root == this)
+		node-&gt;impl-&gt;root_node = true;
+
+	impl-&gt;root-&gt;get_client_area()-&gt;add_child(component1);
+
+	node-&gt;set_component(component1);
+
+	impl-&gt;root-&gt;sig_item_added()(*node);
+
+	return node;
+}
+
+bool CL_TreeNode::remove_item(CL_TreeNode *node)
+{
+	std::list&lt;CL_TreeNode *&gt;::iterator it;
+
+	// First check all children
+	for(it = impl-&gt;children.begin(); it != impl-&gt;children.end(); ++it)
+	{
+		if((*it) == node)
+		{
+			impl-&gt;root-&gt;sig_item_removed()(*node);
+			delete (*it);
+			impl-&gt;children.erase(it);
+			return true;
+		}
+	}
+
+	// Then search all children
+	for(it = impl-&gt;children.begin(); it != impl-&gt;children.end(); ++it)
+		if((*it)-&gt;remove_item(node))
+			return true;
+
+	return false;
+}
+
+void CL_TreeNode::set_component(CL_Component *component)
+{
+	impl-&gt;set_component(component);
+}
+
+void CL_TreeNode::set_collapsed(bool collapsed)
+{
+	impl-&gt;set_collapsed(collapsed);
+}
+	
+void CL_TreeNode::set_selected(bool select)
+{
+	impl-&gt;root-&gt;clear_selection();
+	impl-&gt;selected = select;
+	impl-&gt;root-&gt;sig_selection_changed()(*this);
+//	impl-&gt;root-&gt;sig_item_clicked()(*this);
+}
+
+void CL_TreeNode::set_selectable(bool enable)
+{
+	impl-&gt;selectable = enable;
+}
+
+void CL_TreeNode::set_collapsable(bool enable)
+{
+	impl-&gt;collapsable = enable;
+}
+
+void CL_TreeNode::set_selected(CL_TreeNode *node, bool select)
+{
+	node-&gt;set_selected(select);
+}
+
+void CL_TreeNode::clear_selection()
+{
+	impl-&gt;selected = false;
+
+	std::list&lt;CL_TreeNode *&gt;::iterator it;
+	for (it = impl-&gt;children.begin(); it != impl-&gt;children.end(); ++it)
+		(*it)-&gt;clear_selection();
+}
+
+void CL_TreeNode::clear()
+{
+	impl-&gt;clear(true);
+}
+
+void CL_TreeNode::set_userdata(void *data)
+{
+	impl-&gt;userdata = data;
+}
+
+void CL_TreeNode::set_placement_offset(int offset)
+{
+	impl-&gt;placement_offset = offset;
+}
+
+void CL_TreeNode::draw_nodes(CL_Point &amp;point)
+{
+	std::list&lt;CL_TreeNode *&gt;::iterator it;
+
+	// Draw all children
+	for (it = impl-&gt;children.begin(); it != impl-&gt;children.end(); ++it)
+	{
+		int x = point.x;
+
+		impl-&gt;root-&gt;sig_paint_node()(*it, point);
+		if((*it)-&gt;is_collapsed() == false)
+			(*it)-&gt;draw_nodes(point);
+
+		point.x = x;
+	}
+}

Added: trunk/clanlib/GUI/treenode_generic.cpp
===================================================================
--- trunk/clanlib/GUI/treenode_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/treenode_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,145 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;../API/GUI/treenode.h&quot;
+#include &quot;../API/GUI/treeview.h&quot;
+#include &quot;../API/Display/keys.h&quot;
+#include &quot;treenode_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_TreeNode_Generic::CL_TreeNode_Generic(CL_TreeNode *self, CL_TreeNode *parent, CL_TreeView *root)
+{
+	treenode = self;
+	this-&gt;root = root;
+	this-&gt;parent = parent;
+	component = NULL;
+	collapsed = false;
+	selected = false;
+	selectable = 2;
+	collapsable = 2;
+	userdata = NULL;
+	root_node = false;
+}
+
+CL_TreeNode_Generic::~CL_TreeNode_Generic()
+{
+	destroy();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_TreeNode_Generic::set_collapsed(bool new_collapsed)
+{
+	if(collapsed == new_collapsed || children.empty())
+		return;
+	collapsed = new_collapsed;
+
+	if(collapsed)
+	{
+		show_nodes(false);
+		root-&gt;sig_item_collapsed()(*treenode);
+	}
+	else
+	{
+		show_nodes(true);
+		root-&gt;sig_item_expanded()(*treenode);
+	}
+}
+
+void CL_TreeNode_Generic::show_nodes(bool show)
+{
+	std::list&lt;CL_TreeNode *&gt;::iterator it;
+	for (it = children.begin(); it != children.end(); ++it)
+	{
+		(*it)-&gt;impl-&gt;component-&gt;enable(show);
+		(*it)-&gt;impl-&gt;show_nodes(show);
+	}
+}
+
+void CL_TreeNode_Generic::set_component(CL_Component *new_component)
+{
+	if(component)
+	{
+		component-&gt;sig_mouse_up().disconnect(slot_mouse_up);
+		delete component;
+	}
+
+	component = new_component;
+	slot_mouse_up = component-&gt;sig_mouse_up().connect(
+		this, &amp;CL_TreeNode_Generic::on_child_click);
+}
+
+void CL_TreeNode_Generic::destroy()
+{
+	if(component)
+	{
+		component-&gt;sig_mouse_up().disconnect(slot_mouse_up);
+		delete component;
+		component = NULL;
+	}
+
+	//let's schedule these for deletion ASAP, can't do it now because we might be in a
+	//callback create by one of them (CL_FileDialog does this)
+
+	std::list&lt;CL_TreeNode *&gt;::iterator it;
+	for (it = children.begin(); it != children.end(); ++it)
+	{
+		root-&gt;add_node_to_delete_list(*it);
+	}
+
+	children.clear();
+}
+
+void CL_TreeNode_Generic::clear(bool do_signal)
+{
+	destroy();
+
+	if(do_signal)
+		root-&gt;sig_clear()();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_TreeNode_Generic::on_child_click(const CL_InputEvent &amp;key)
+{
+	if(key.id == CL_MOUSE_LEFT)
+	{
+		if(treenode-&gt;is_collapsable())
+			treenode-&gt;set_collapsed(!collapsed);
+		if(treenode-&gt;is_selectable())
+			treenode-&gt;set_selected();
+//		else
+//			root-&gt;sig_item_clicked()(*treenode);
+	}
+}

Added: trunk/clanlib/GUI/treenode_generic.h
===================================================================
--- trunk/clanlib/GUI/treenode_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/treenode_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,86 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_treenode_generic
+#define header_treenode_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &lt;list&gt;
+#include &quot;API/Signals/slot_container.h&quot;
+#include &quot;API/Core/Math/point.h&quot;
+#include &quot;API/Display/input_event.h&quot;
+
+class CL_TreeNode;
+
+//: TreeView node
+class CL_TreeNode_Generic
+{
+public:
+	CL_TreeNode_Generic(CL_TreeNode *self, CL_TreeNode *parent, CL_TreeView *root);
+	~CL_TreeNode_Generic();
+	
+	void set_collapsed(bool new_collapsed);
+	void show_nodes(bool show);
+	void set_component(CL_Component *new_component);
+	void clear(bool do_signal);
+
+	CL_TreeView *root;
+	CL_TreeNode *parent;
+	CL_TreeNode *treenode;
+
+	CL_Component *component;
+
+	std::list&lt;CL_TreeNode *&gt; children;
+
+	CL_SlotContainer slots;
+	CL_Slot slot_mouse_up;
+
+	void *userdata;
+
+	bool collapsed;
+	bool selected;
+	int selectable;	 // 0 - not selectable, 1 - selectable, 2 - use parent setting
+	int collapsable; // 0 - not collapsable, 1 - collapsable, 2 - use parent setting
+	bool root_node;
+
+	int placement_offset;
+
+	void on_child_click(const CL_InputEvent &amp;key);
+
+	CL_Signal_v1&lt;CL_Point &amp;&gt; sig_paint_node;
+
+private:
+
+	void destroy(); //removes all children and kills its component
+};
+
+#endif

Added: trunk/clanlib/GUI/treeview.cpp
===================================================================
--- trunk/clanlib/GUI/treeview.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/treeview.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,187 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+
+#ifdef _MSC_VER
+#pragma warning (disable:4355)
+#endif
+
+#include &quot;API/GUI/stylemanager.h&quot;
+#include &quot;treeview_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_TreeView::CL_TreeView(
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(parent, style), CL_TreeNode(NULL, this), impl(NULL)
+{
+	impl = new CL_TreeView_Generic(this);
+	get_style_manager()-&gt;connect_styles(&quot;treeview&quot;, this);
+	find_preferred_size();
+}
+
+CL_TreeView::CL_TreeView(
+	const CL_Rect &amp;pos,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(pos, parent, style), CL_TreeNode(NULL, this), impl(NULL)
+{
+	impl = new CL_TreeView_Generic(this);
+	get_style_manager()-&gt;connect_styles(&quot;treeview&quot;, this);
+}
+
+CL_TreeView::~CL_TreeView()
+{
+	clear();
+	clear_delete_list();
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+int CL_TreeView::get_column_count() const
+{
+	return impl-&gt;get_column_count();
+}
+
+int CL_TreeView::get_column_width(int index) const
+{
+	return impl-&gt;get_column_width(index);
+}
+
+const std::string &amp;CL_TreeView::get_column_name(int index) const
+{
+	return impl-&gt;get_column_name(index);
+}
+
+bool CL_TreeView::is_root_decoration_visible() const
+{
+	return impl-&gt;show_root_decoration;
+}
+
+bool CL_TreeView::is_header_visible() const
+{
+	return impl-&gt;show_header;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+int CL_TreeView::add_column(const std::string &amp;name, int width)
+{
+	int index = impl-&gt;add_column(name, width);
+	impl-&gt;sig_column_added(index);
+	return index;
+}
+
+void CL_TreeView::show_root_decoration(bool enable)
+{
+	impl-&gt;show_root_decoration = enable;
+}
+
+void CL_TreeView::show_header(bool enable)
+{
+	impl-&gt;show_header = enable;
+	sig_resize()(get_width(), get_height());
+}
+
+void CL_TreeView::add_node_to_delete_list(CL_TreeNode *pNode)
+{
+	//we'll delete it when we can
+	node_delete_list.push_back(pNode);
+}
+
+void CL_TreeView::clear_delete_list()
+{
+	std::list&lt;CL_TreeNode *&gt;::iterator it;
+	for (it = node_delete_list.begin(); it != node_delete_list.end(); ++it)
+	{
+		delete (*it);
+	}
+
+	node_delete_list.clear();
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+// Signals:
+
+CL_Signal_v1&lt;const CL_TreeNode &amp;&gt; &amp;CL_TreeView::sig_selection_changed()
+{
+	return impl-&gt;sig_selection_changed;
+}
+
+CL_Signal_v1&lt;const CL_TreeNode &amp;&gt; &amp;CL_TreeView::sig_item_clicked()
+{
+	return impl-&gt;sig_item_clicked;
+}
+
+CL_Signal_v2&lt;CL_TreeNode *, CL_Point &amp;&gt; &amp;CL_TreeView::sig_paint_node()
+{
+	return impl-&gt;sig_paint_node;
+}
+
+CL_Signal_v1&lt;const CL_TreeNode &amp;&gt; &amp;CL_TreeView::sig_item_added()
+{
+	return impl-&gt;sig_item_added;
+}
+
+CL_Signal_v1&lt;const CL_TreeNode &amp;&gt; &amp;CL_TreeView::sig_item_removed()
+{
+	return impl-&gt;sig_item_removed;
+}
+
+CL_Signal_v1&lt;const CL_TreeNode &amp;&gt; &amp;CL_TreeView::sig_item_expanded()
+{
+	return impl-&gt;sig_item_expanded;
+}
+
+CL_Signal_v1&lt;const CL_TreeNode &amp;&gt; &amp;CL_TreeView::sig_item_collapsed()
+{
+	return impl-&gt;sig_item_collapsed;
+}
+
+CL_Signal_v1&lt;int&gt; &amp;CL_TreeView::sig_column_added()
+{
+	return impl-&gt;sig_column_added;
+}
+
+CL_Signal_v1&lt;int&gt; &amp;CL_TreeView::sig_column_removed()
+{
+	return impl-&gt;sig_column_removed;
+}
+
+CL_Signal_v0 &amp;CL_TreeView::sig_clear()
+{
+	return impl-&gt;sig_clear;
+}

Added: trunk/clanlib/GUI/treeview_generic.cpp
===================================================================
--- trunk/clanlib/GUI/treeview_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/treeview_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,105 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;treeview_generic.h&quot;
+#include &quot;treenode_generic.h&quot;
+#include &quot;API/GUI/gui_manager.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+
+const static std::string blank;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_TreeView_Generic::CL_TreeView_Generic(CL_TreeView *self)
+: show_root_decoration(true),
+  show_header(true),
+  treeview(self)
+{
+	// Create client area (which is the main treeview)
+	CL_Component *client_area = new CL_Component(treeview);
+	treeview-&gt;set_client_area(client_area);
+	
+	slot_paint_children = client_area-&gt;sig_paint_children().connect_virtual(
+		this, &amp;CL_TreeView_Generic::on_paint_children);
+}
+
+CL_TreeView_Generic::~CL_TreeView_Generic()
+{
+	delete treeview-&gt;get_client_area();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+int CL_TreeView_Generic::get_column_count() const
+{
+	return columns.size();
+}
+
+int CL_TreeView_Generic::get_column_width(int index) const
+{
+	if(columns.size() == 0)
+		return treeview-&gt;get_client_area()-&gt;get_width();
+
+	if((unsigned int)index &gt; columns.size())
+		return 0;
+
+	return columns[index].width;
+}
+
+const std::string &amp;CL_TreeView_Generic::get_column_name(int index) const
+{
+	if((unsigned int)index &gt; columns.size())
+		return blank;
+
+	return columns[index].name;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+int CL_TreeView_Generic::add_column(const std::string &amp;name, int width)
+{
+	Column column;
+	column.name = name;
+	column.width = width;
+	columns.push_back(column);
+	return get_column_count() - 1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_TreeView_Generic::on_paint_children(CL_SlotParent_v0 &amp;super)
+{
+//	CL_Point point(0, 0);
+//	treeview-&gt;CL_TreeNode::impl-&gt;draw_nodes(point);
+}

Added: trunk/clanlib/GUI/treeview_generic.h
===================================================================
--- trunk/clanlib/GUI/treeview_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/treeview_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,91 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_treeview_generic
+#define header_treeview_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/GUI/treeview.h&quot;
+
+class CL_TreeView_Generic
+{
+//! Construction:
+public:
+	CL_TreeView_Generic(CL_TreeView *self);
+	~CL_TreeView_Generic();
+
+//! Attributes:
+public:
+	int get_column_count() const;
+	int get_column_width(int index) const;
+	const std::string &amp;get_column_name(int index) const;
+
+	bool show_root_decoration;
+	bool show_header;
+
+//! Operations:
+public:
+	int add_column(const std::string &amp;name, int width);
+		
+//! Signals:
+public:
+	CL_Signal_v2&lt;CL_TreeNode *, CL_Point &amp;&gt; sig_paint_node;
+	CL_Signal_v1&lt;const CL_TreeNode &amp;&gt; sig_selection_changed;
+	CL_Signal_v1&lt;const CL_TreeNode &amp;&gt; sig_item_clicked;
+	CL_Signal_v1&lt;const CL_TreeNode &amp;&gt; sig_item_added;
+	CL_Signal_v1&lt;const CL_TreeNode &amp;&gt; sig_item_removed;
+	CL_Signal_v1&lt;const CL_TreeNode &amp;&gt; sig_item_expanded;
+	CL_Signal_v1&lt;const CL_TreeNode &amp;&gt; sig_item_collapsed;
+	CL_Signal_v1&lt;int&gt; sig_column_added;
+	CL_Signal_v1&lt;int&gt; sig_column_removed;
+	CL_Signal_v0 sig_clear;
+
+//! Callbacks:
+private:
+	void on_paint_children(CL_SlotParent_v0 &amp;super);
+
+//! Implementation:
+private:
+	struct Column
+	{
+		std::string name;
+		int original_width;
+		int width;
+	};
+	std::vector&lt;Column&gt; columns;
+
+	CL_Slot slot_paint_children;
+
+	CL_TreeView *treeview;
+};
+
+#endif

Added: trunk/clanlib/GUI/window.cpp
===================================================================
--- trunk/clanlib/GUI/window.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/window.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,154 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;API/GUI/window.h&quot;
+#include &quot;API/GUI/stylemanager.h&quot;
+#include &quot;API/GUI/gui_manager.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;window_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction
+
+CL_Window::CL_Window(
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(parent, style), impl(0)
+{
+	impl = new CL_Window_Generic(this, std::string(), no_buttons);
+	get_style_manager()-&gt;connect_styles(&quot;window&quot;, this);
+	find_preferred_size();
+}
+
+CL_Window::CL_Window(
+	int button_enum, 
+	CL_Component *parent, 
+	CL_StyleManager *style)
+: CL_Component(parent, style), impl(0)
+{
+	impl = new CL_Window_Generic(this, std::string(), button_enum);
+	get_style_manager()-&gt;connect_styles(&quot;window&quot;, this);
+	find_preferred_size();
+}
+
+CL_Window::CL_Window(
+	const CL_Rect &amp;pos,
+	const std::string &amp;title,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(pos, parent, style), impl(0)
+{
+	impl = new CL_Window_Generic(this, title, no_buttons);
+	get_style_manager()-&gt;connect_styles(&quot;window&quot;, this);
+}
+
+CL_Window::CL_Window(
+	const CL_Rect &amp;pos,
+	const std::string &amp;title,
+	int button_enum, 
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(pos, parent, style), impl(0)
+{
+	impl = new CL_Window_Generic(this, title, button_enum);
+	get_style_manager()-&gt;connect_styles(&quot;window&quot;, this);
+}
+
+CL_Window::CL_Window(
+	const std::string &amp;title,
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(parent, style), impl(0)
+{
+	impl = new CL_Window_Generic(this, title, no_buttons);
+	get_style_manager()-&gt;connect_styles(&quot;window&quot;, this);
+	find_preferred_size();
+}
+
+CL_Window::CL_Window(
+	const std::string &amp;title,
+	int button_enum, 
+	CL_Component *parent,
+	CL_StyleManager *style)
+: CL_Component(parent, style), impl(0)
+{
+	impl = new CL_Window_Generic(this, title, button_enum);
+	get_style_manager()-&gt;connect_styles(&quot;window&quot;, this);
+	find_preferred_size();
+}
+
+CL_Window::~CL_Window()
+{
+	delete impl;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Attributes:
+
+const std::string &amp;CL_Window::get_title() const
+{
+	return impl-&gt;title;
+}
+
+CL_Window::TitlebarButtons CL_Window::get_titlebar_buttons_enum() const
+{
+	return (CL_Window::TitlebarButtons)impl-&gt;titlebar_buttons;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_Window::set_title(const std::string &amp;text)
+{
+	impl-&gt;title = text;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Signals:
+
+CL_Signal_v0 &amp;CL_Window::sig_close_button_clicked()
+{
+	return impl-&gt;sig_close_button_clicked;
+}
+
+CL_Signal_v0 &amp;CL_Window::sig_minimize_button_clicked()
+{
+	return impl-&gt;sig_minimize_button_clicked;
+}
+
+CL_Signal_v0 &amp;CL_Window::sig_maximize_button_clicked()
+{
+	return impl-&gt;sig_maximize_button_clicked;
+}
+
+CL_Signal_v0 &amp;CL_Window::sig_help_button_clicked()
+{
+	return impl-&gt;sig_help_button_clicked;
+}

Added: trunk/clanlib/GUI/window_generic.cpp
===================================================================
--- trunk/clanlib/GUI/window_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/window_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,70 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;precomp.h&quot;
+#include &quot;window_generic.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_Window_Generic::CL_Window_Generic(
+	CL_Window *window,
+	const std::string &amp;title,
+	int titlebar_buttons)
+	: title(title), titlebar_buttons(titlebar_buttons), window(window)
+{
+	CL_Component *client_area = new CL_Component(window);
+	window-&gt;set_client_area(client_area);
+
+	slot_set_options = window-&gt;sig_set_options().connect(this, &amp;CL_Window_Generic::on_set_options);
+	slot_close = sig_close_button_clicked.connect(this, &amp;CL_Window_Generic::on_close);
+}
+
+CL_Window_Generic::~CL_Window_Generic()
+{
+	delete window-&gt;get_client_area();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_Window_Generic::on_set_options(const CL_DomElement &amp;options)
+{
+	if (options.has_attribute(&quot;title&quot;))
+		title = options.get_attribute(&quot;title&quot;);
+}
+
+void CL_Window_Generic::on_close()
+{
+	if (window-&gt;is_modal())
+		window-&gt;quit();
+	else
+		window-&gt;close();
+}

Added: trunk/clanlib/GUI/window_generic.h
===================================================================
--- trunk/clanlib/GUI/window_generic.h	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUI/window_generic.h	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,76 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef header_window_generic
+#define header_window_generic
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+#include &quot;API/GUI/window.h&quot;
+
+class CL_Window_Generic
+{
+//! Construction:
+public:
+	CL_Window_Generic(CL_Window *self, const std::string &amp;title, int titlebar_buttons);
+
+	~CL_Window_Generic();
+
+//! Attributes:
+public:
+	std::string title;
+	int titlebar_buttons;
+
+//! Operations:
+public:
+
+//! Signals:
+public:
+	CL_Signal_v0 sig_close_button_clicked;
+	CL_Signal_v0 sig_minimize_button_clicked;
+	CL_Signal_v0 sig_maximize_button_clicked;
+	CL_Signal_v0 sig_help_button_clicked;
+	
+//! Callbacks:
+public:
+	void on_set_options(const CL_DomElement &amp;options);
+	void on_close();
+
+	CL_Slot slot_set_options;
+	CL_Slot slot_close;
+
+//! Implementation:
+private:
+	CL_Window *window;
+};
+
+#endif
+

Added: trunk/clanlib/GUIStyleSilver/Makefile.am
===================================================================
--- trunk/clanlib/GUIStyleSilver/Makefile.am	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUIStyleSilver/Makefile.am	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,22 @@
+lib_LTLIBRARIES = libclanGUIStyleSilver.la
+
+libclanGUIStyleSilver_la_SOURCES = \
+button_silver.cpp    label_silver.cpp        scrollbar_silver.cpp \
+checkbox_silver.cpp  listbox_silver.cpp      stylemanager_silver.cpp \
+frame_silver.cpp     image_silver.cpp     progressbar_silver.cpp \
+inputbox_silver.cpp  radiobutton_silver.cpp  window_silver.cpp \
+button_silver.h    label_silver.h	   scrollbar_silver.h \
+checkbox_silver.h  listbox_silver.h	   frame_silver.h \
+image_silver.h     progressbar_silver.h  window_silver.h \
+inputbox_silver.h  radiobutton_silver.h \
+menu_silver.cpp      menu_node_silver.cpp	menu_item_silver.cpp \
+treeitem_silver.cpp	treeview_silver.cpp \
+treeitem_silver.h	treeview_silver.h
+
+
+
+libclanGUIStyleSilver_la_LDFLAGS = \
+  -release $(LT_RELEASE) \
+  -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE)
+
+# EOF #

Added: trunk/clanlib/GUIStyleSilver/button_silver.cpp
===================================================================
--- trunk/clanlib/GUIStyleSilver/button_silver.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUIStyleSilver/button_silver.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,369 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    Kenneth Gangst&#248;
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Display/surface.h&quot;
+#include &quot;API/Display/font.h&quot;
+#include &quot;API/GUI/gui_manager.h&quot;
+#include &quot;API/GUIStyleSilver/stylemanager_silver.h&quot;
+#include &quot;API/GUIStyleSilver/button_silver.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;API/Core/Math/rect.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_Button_Silver::CL_Button_Silver(
+	CL_Button *button,
+	CL_StyleManager_Silver *style)
+:
+	CL_ComponentStyle(button),
+	button(button),
+	style(style),
+	font(0),
+	font_disabled(0),
+	delete_font(false),
+	delete_font_disabled(false),
+	sur_up(0), 
+	sur_down(0),
+	sur_highlighted(0),
+	sur_disabled(0), 
+	draw_only_surfaces(true),
+	delete_sur_up(false),
+	delete_sur_down(false),
+	delete_sur_highlighted(false),
+	delete_sur_disabled(false)
+{
+	resources = style-&gt;get_resources();
+
+	if(resources-&gt;exists(&quot;Button/surface_up&quot;))
+		set_surface_up(new CL_Surface(&quot;Button/surface_up&quot;, resources), true);
+	if(resources-&gt;exists(&quot;Button/surface_down&quot;))
+		set_surface_down(new CL_Surface(&quot;Button/surface_down&quot;, resources), true);
+	if(resources-&gt;exists(&quot;Button/surface_highlighted&quot;))
+		set_surface_highlighted(new CL_Surface(&quot;Button/surface_highlighted&quot;, resources), true);
+	if(resources-&gt;exists(&quot;Button/surface_disabled&quot;))
+		set_surface_disabled(new CL_Surface(&quot;Button/surface_disabled&quot;, resources), true);
+	if(resources-&gt;exists(&quot;Button/font&quot;))
+		set_font(new CL_Font(&quot;Button/font&quot;, resources), true);
+	if(resources-&gt;exists(&quot;Button/font_disabled&quot;))
+		set_font_disabled(new CL_Font(&quot;Button/font_disabled&quot;, resources), true);
+
+	slot_set_options = button-&gt;sig_set_options().connect(
+		this, &amp;CL_Button_Silver::on_set_options);
+	slot_paint = button-&gt;sig_paint().connect(
+		this, &amp;CL_Button_Silver::on_paint);
+	slot_get_preferred_size = button-&gt;sig_get_preferred_size().connect(
+		this, &amp;CL_Button_Silver::on_get_preferred_size);
+}
+
+CL_Button_Silver::~CL_Button_Silver()
+{
+	if(delete_font &amp;&amp; font)
+		delete font;
+	if(delete_font_disabled &amp;&amp; font_disabled)
+		delete font_disabled;
+	if(delete_sur_up &amp;&amp; sur_up)
+		delete sur_up;
+	if(delete_sur_down &amp;&amp; sur_down)
+		delete sur_down;
+	if(delete_sur_highlighted &amp;&amp; sur_highlighted)
+		delete sur_highlighted;
+	if(delete_sur_disabled &amp;&amp; sur_disabled)
+		delete sur_disabled;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_Button_Silver::set_font(CL_Font *_font, bool _delete_font)
+{
+	if(delete_font &amp;&amp; font)
+		delete font;
+	font = _font;
+	delete_font = _delete_font;
+}
+
+void CL_Button_Silver::set_font_disabled(CL_Font *_font, bool _delete_font)
+{
+	if(delete_font_disabled &amp;&amp; font_disabled)
+		delete font_disabled;
+	font_disabled = _font;
+	delete_font_disabled = _delete_font;
+}
+
+void CL_Button_Silver::set_surface_up(CL_Surface *surface, bool delete_surface)
+{
+	if(delete_sur_up &amp;&amp; sur_up)
+		delete sur_up;
+	sur_up = surface;
+	delete_sur_up = delete_surface;
+}
+
+void CL_Button_Silver::set_surface_down(CL_Surface *surface, bool delete_surface)
+{
+	if(delete_sur_down &amp;&amp; sur_down)
+		delete sur_down;
+	sur_down = surface;
+	delete_sur_down = delete_surface;
+}
+
+void CL_Button_Silver::set_surface_highlighted(CL_Surface *surface, bool delete_surface)
+{
+	if(delete_sur_highlighted &amp;&amp; sur_highlighted)
+		delete sur_highlighted;
+	sur_highlighted = surface;
+	delete_sur_highlighted = delete_surface;
+}
+
+void CL_Button_Silver::set_surface_disabled(CL_Surface *surface, bool delete_surface)
+{
+	if(delete_sur_disabled &amp;&amp; sur_disabled)
+		delete sur_disabled;
+	sur_disabled = surface;
+	delete_sur_disabled = delete_surface;
+}
+
+void CL_Button_Silver::set_surface_draw_only(bool enable)
+{
+	draw_only_surfaces = enable;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_Button_Silver::on_set_options(const CL_DomElement &amp;options)
+{
+	if (options.has_attribute(&quot;surface_up&quot;))
+		set_surface_up(new CL_Surface(options.get_attribute(&quot;surface_up&quot;), resources), true);
+	if (options.has_attribute(&quot;surface_down&quot;))
+		set_surface_down(new CL_Surface(options.get_attribute(&quot;surface_down&quot;), resources), true);
+	if (options.has_attribute(&quot;surface_disabled&quot;))
+		set_surface_disabled(new CL_Surface(options.get_attribute(&quot;surface_disabled&quot;), resources), true);
+	if (options.has_attribute(&quot;surface_highlighted&quot;))
+		set_surface_highlighted(new CL_Surface(options.get_attribute(&quot;surface_highlighted&quot;), resources), true);
+	if (options.has_attribute(&quot;font&quot;))
+		set_font(new CL_Font(options.get_attribute(&quot;font&quot;), resources), true);
+	if (options.has_attribute(&quot;font_disabled&quot;))
+		set_font_disabled(new CL_Font(options.get_attribute(&quot;font_disabled&quot;), resources), true);
+}
+
+void CL_Button_Silver::on_get_preferred_size(CL_Size &amp;size)
+{
+	if(sur_up)
+	{
+		size.width = sur_up-&gt;get_width();
+		size.height = sur_up-&gt;get_height();
+	}
+	else
+	{
+		if(font)
+		{
+			size.width = font-&gt;get_width(button-&gt;get_text()) + 8;
+			size.height = font-&gt;get_height() + 4;
+		}
+	}
+}
+
+void CL_Button_Silver::on_paint()
+{
+	int text_width = 0;
+	int text_height = 0;
+
+	if(font)
+	{
+		text_width = font-&gt;get_width(button-&gt;get_text().c_str());
+		text_height = font-&gt;get_height();
+	}
+
+	CL_Rectf rect = button-&gt;get_screen_rect();
+
+	int font_xpos = static_cast&lt;int&gt;(rect.left + (rect.right - rect.left - text_width) / 2);
+	int font_ypos = static_cast&lt;int&gt;(rect.top + (rect.bottom - rect.top - text_height) / 2);
+
+	if(button-&gt;is_enabled() == false)
+	{
+		if(draw_only_surfaces == false || sur_disabled == NULL)
+		{
+			CL_Display::draw_rect(rect, CL_Color(203, 209, 216));
+		}
+		if(sur_disabled)
+		{
+			sur_disabled-&gt;draw(rect.left + (rect.get_width() - sur_disabled-&gt;get_width()) / 2, rect.top + (rect.get_height() - sur_disabled-&gt;get_height()) / 2);
+		}
+
+		if(font_disabled)
+		{
+			font_disabled-&gt;draw(font_xpos, font_ypos, button-&gt;get_text());
+		}
+		else if(font)
+		{
+			font-&gt;draw(font_xpos, font_ypos, button-&gt;get_text());
+		}
+	}
+	else 
+	{
+		if(button-&gt;is_drawn_down())
+		{
+			if(draw_only_surfaces == false || sur_down == NULL)
+			{
+				// Main border
+				CL_Display::draw_rect(
+					rect, 
+					CL_Color(128, 142, 159));
+
+				// Dark inner border
+				CL_Display::draw_rect(
+					CL_Rectf(rect.left + 1, rect.top + 1, rect.right - 1, rect.bottom - 1),
+					CL_Color(73, 94, 120));
+
+				// Outer gradient
+				CL_Display::fill_rect(
+					CL_Rectf(rect.left + 2, rect.top + 2, rect.right - 1, rect.bottom - 1),
+					CL_Gradient(CL_Color::white, CL_Color::white, CL_Color(230, 235, 240), CL_Color(230, 235, 240)));
+
+				// Inner fill
+				CL_Display::fill_rect(
+					CL_Rectf(rect.left + 4, rect.top + 4, rect.right - 1, rect.bottom - 1),
+					CL_Color(240, 242, 244));
+			}
+
+			if(sur_down)
+			{
+				sur_down-&gt;draw(rect.left + (rect.get_width() - sur_down-&gt;get_width()) / 2, rect.top + (rect.get_height() - sur_down-&gt;get_height()) / 2);
+			}
+
+			if(font)
+			{
+				font-&gt;draw(font_xpos + 1, font_ypos + 1, button-&gt;get_text());
+			}
+		}
+		else
+		{
+			bool need_highlight = false;
+			if (button-&gt;has_mouse_over())
+			{
+				if (!button-&gt;get_gui_manager() || (!button-&gt;get_gui_manager()-&gt;get_modal_component() ||	button-&gt;has_modal_parent()))
+				{
+					need_highlight = true;
+				}
+			}
+
+			CL_Surface *sur = NULL;
+			if(sur_highlighted &amp;&amp; need_highlight)
+			{
+				sur = sur_highlighted;
+			}
+			else if(sur_up)
+			{
+				sur = sur_up;
+			}
+
+			if(draw_only_surfaces == false || sur == NULL)
+			{
+				// Highlight
+				if(need_highlight)
+				{
+					// Main border
+					CL_Display::draw_rect(
+						rect, 
+						CL_Color(209, 149, 32));
+
+					// Highlight
+					CL_Display::draw_rect(
+						CL_Rectf(rect.left - 1, rect.top - 1, rect.right + 1, rect.bottom + 1),
+						CL_Color(250, 236, 204));
+
+					// Outer gradient
+					CL_Display::fill_rect(
+						CL_Rectf(rect.left + 1, rect.top + 1, rect.right - 1, rect.bottom - 1),
+						CL_Gradient(CL_Color::white, CL_Color::white, CL_Color(230, 235, 240), CL_Color(230, 235, 240)));
+
+					// Inner fill
+					CL_Display::fill_rect(
+						CL_Rectf(rect.left + 3, rect.top + 3, rect.right - 3, rect.bottom - 3),
+						CL_Color(240, 242, 244));
+				}
+				// Focus
+				else if(button-&gt;has_focus())
+				{
+					// Main border
+					CL_Display::draw_rect(
+						rect, 
+						CL_Color(119, 138, 187));
+
+					// Highlight
+					CL_Display::draw_rect(
+						CL_Rectf(rect.left - 1, rect.top - 1, rect.right + 1, rect.bottom + 1),
+						CL_Color(206, 220, 233));
+
+					// Outer gradient
+					CL_Display::fill_rect(
+						CL_Rectf(rect.left + 1, rect.top + 1, rect.right - 1, rect.bottom - 1),
+						CL_Gradient(CL_Color::white, CL_Color::white, CL_Color(230, 235, 240), CL_Color(230, 235, 240)));
+
+					// Inner fill
+					CL_Display::fill_rect(
+						CL_Rectf(rect.left + 3, rect.top + 3, rect.right - 3, rect.bottom - 3),
+						CL_Color(240, 242, 244));
+				}
+				// Normal
+				else
+				{
+					// Main border
+					CL_Display::draw_rect(
+						rect, 
+						CL_Color(128, 142, 159));
+
+					// Outer gradient
+					CL_Display::fill_rect(
+						CL_Rectf(rect.left + 1, rect.top + 1, rect.right - 1, rect.bottom - 1),
+						CL_Gradient(CL_Color::white, CL_Color::white, CL_Color(230, 235, 240), CL_Color(230, 235, 240)));
+
+					// Inner fill
+					CL_Display::fill_rect(
+						CL_Rectf(rect.left + 3, rect.top + 3, rect.right - 3, rect.bottom - 3),
+						CL_Color(240, 242, 244));
+				}
+			}
+
+			if(sur)
+			{
+				sur-&gt;draw(rect.left + (rect.get_width() - sur-&gt;get_width()) / 2, rect.top + (rect.get_height() - sur-&gt;get_height()) / 2);
+			}
+
+			if(font)
+			{
+				font-&gt;draw(font_xpos, font_ypos, button-&gt;get_text());
+			}
+		}
+	}
+}

Added: trunk/clanlib/GUIStyleSilver/checkbox_silver.cpp
===================================================================
--- trunk/clanlib/GUIStyleSilver/checkbox_silver.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUIStyleSilver/checkbox_silver.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,206 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;API/Display/surface.h&quot;
+#include &quot;API/Display/font.h&quot;
+#include &quot;API/GUIStyleSilver/checkbox_silver.h&quot;
+#include &quot;API/GUIStyleSilver/stylemanager_silver.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_CheckBox_Silver::CL_CheckBox_Silver(
+	CL_CheckBox *checkbox,
+	CL_StyleManager_Silver *style)
+: 
+	CL_ComponentStyle(checkbox),
+	checkbox(checkbox),
+	style(style),
+	font(0),
+	font_disabled(0),
+	delete_font(false),
+	delete_font_disabled(false),
+	sur_checked(0),
+	sur_unchecked(0),
+	sur_checked_disabled(0), 
+	sur_unchecked_disabled(0),
+	delete_sur_checked(false),
+	delete_sur_unchecked(false),
+	delete_sur_checked_disabled(false),
+	delete_sur_unchecked_disabled(false)
+{
+	resources = style-&gt;get_resources();
+
+	if(resources-&gt;exists(&quot;CheckBox/surface_checked&quot;))
+		set_surface_checked (new CL_Surface(&quot;CheckBox/surface_checked&quot;, resources), true);
+	if(resources-&gt;exists(&quot;CheckBox/surface_unchecked&quot;))
+		set_surface_unchecked (new CL_Surface(&quot;CheckBox/surface_unchecked&quot;, resources), true);
+	if(resources-&gt;exists(&quot;CheckBox/surface_checked_disabled&quot;))
+		set_surface_checked_disabled (new CL_Surface(&quot;CheckBox/surface_checked_disabled&quot;, resources), true);
+	if(resources-&gt;exists(&quot;CheckBox/surface_unchecked_disabled&quot;))
+		set_surface_unchecked_disabled (new CL_Surface(&quot;CheckBox/surface_unchecked_disabled&quot;, resources), true);
+	if(resources-&gt;exists(&quot;CheckBox/font&quot;))
+		set_font (new CL_Font(&quot;CheckBox/font&quot;, resources), true);
+	if(resources-&gt;exists(&quot;CheckBox/font_disabled&quot;))
+		set_font_disabled (new CL_Font(&quot;CheckBox/font_disabled&quot;, resources), true);
+
+	slot_set_options = checkbox-&gt;sig_set_options().connect(
+		this, &amp;CL_CheckBox_Silver::on_set_options);
+	slot_paint = checkbox-&gt;sig_paint().connect_virtual(
+		this, &amp;CL_CheckBox_Silver::on_paint);
+	slot_get_preferred_size = checkbox-&gt;sig_get_preferred_size().connect(
+		this, &amp;CL_CheckBox_Silver::on_get_preferred_size);
+}
+
+CL_CheckBox_Silver::~CL_CheckBox_Silver()
+{
+	set_font(0);
+	set_font_disabled(0);
+	set_surface_checked(0);
+	set_surface_unchecked(0);
+	set_surface_checked_disabled(0);
+	set_surface_unchecked_disabled(0);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_CheckBox_Silver::set_font(CL_Font *_font, bool _delete_font)
+{
+	if(delete_font &amp;&amp; font)
+		delete font;
+	font = _font;
+	delete_font = _delete_font;
+}
+
+void CL_CheckBox_Silver::set_font_disabled(CL_Font *_font, bool _delete_font)
+{
+	if(delete_font_disabled &amp;&amp; font_disabled)
+		delete font_disabled;
+	font_disabled = _font;
+	delete_font_disabled = _delete_font;
+}
+
+void CL_CheckBox_Silver::set_surface_checked(CL_Surface *_surface, bool _delete_surface)
+{
+	if(delete_sur_checked &amp;&amp; sur_checked)
+		delete sur_checked;
+	sur_checked = _surface;
+	delete_sur_checked = _delete_surface;
+}
+
+void CL_CheckBox_Silver::set_surface_unchecked(CL_Surface *_surface, bool _delete_surface)
+{
+	if(delete_sur_unchecked &amp;&amp; sur_unchecked)
+		delete sur_unchecked;
+	sur_unchecked = _surface;
+	delete_sur_unchecked = _delete_surface;
+}
+
+void CL_CheckBox_Silver::set_surface_checked_disabled(CL_Surface *_surface, bool _delete_surface)
+{
+	if(delete_sur_checked_disabled &amp;&amp; sur_checked_disabled)
+		delete sur_checked_disabled;
+	sur_checked_disabled = _surface;
+	delete_sur_checked_disabled = _delete_surface;
+}
+
+void CL_CheckBox_Silver::set_surface_unchecked_disabled(CL_Surface *_surface, bool _delete_surface)
+{
+	if(delete_sur_unchecked_disabled &amp;&amp; sur_unchecked_disabled)
+		delete sur_unchecked_disabled;
+	sur_unchecked_disabled = _surface;
+	delete_sur_unchecked_disabled = _delete_surface;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_CheckBox_Silver::on_set_options(const CL_DomElement &amp;options)
+{
+	if (options.has_attribute(&quot;surface_checked&quot;))
+		set_surface_checked(new CL_Surface(options.get_attribute(&quot;surface_checked&quot;), resources), true);
+	if (options.has_attribute(&quot;surface_unchecked&quot;))
+		set_surface_unchecked(new CL_Surface(options.get_attribute(&quot;surface_unchecked&quot;), resources), true);
+	if (options.has_attribute(&quot;surface_checked_disabled&quot;))
+		set_surface_checked_disabled(new CL_Surface(options.get_attribute(&quot;surface_checked_disabled&quot;), resources), true);
+	if (options.has_attribute(&quot;surface_unchecked_disabled&quot;))
+		set_surface_unchecked_disabled(new CL_Surface(options.get_attribute(&quot;surface_checked_disabled&quot;), resources), true);
+	if (options.has_attribute(&quot;font&quot;))
+		set_font(new CL_Font(options.get_attribute(&quot;font&quot;), resources), true);
+	if (options.has_attribute(&quot;font_disabled&quot;))
+		set_font_disabled(new CL_Font(options.get_attribute(&quot;font_disabled&quot;), resources), true);
+}
+
+void CL_CheckBox_Silver::on_get_preferred_size(CL_Size &amp;size)
+{
+	CL_Surface *s = sur_checked;
+	size.width = s-&gt;get_width() + font-&gt;get_width(checkbox-&gt;get_text()) + 8;
+	size.height = font-&gt;get_height() + 4;
+	if(size.height &lt; (int)s-&gt;get_height())
+		size.height = s-&gt;get_height();
+}
+
+void CL_CheckBox_Silver::on_paint(CL_SlotParent_v0 &amp;super)
+{
+	CL_Surface *show_surface;
+	CL_Font *show_font;
+	
+	if (checkbox-&gt;is_enabled())
+	{
+		if (checkbox-&gt;is_checked())
+			show_surface = sur_checked;
+		else
+			show_surface = sur_unchecked;
+
+		show_font = font;
+		// Focus
+//		if(checkbox-&gt;has_focus())
+//			style-&gt;fill_rect(0, 0, checkbox-&gt;get_width(), show_surface-&gt;get_height(), GUICOLOR_FOCUS);
+	}
+	else
+	{
+		if (checkbox-&gt;is_checked())
+			show_surface = sur_checked_disabled;
+		else
+			show_surface = sur_unchecked_disabled;
+
+		if(font_disabled)
+			show_font = font_disabled;
+		else
+			show_font = font;
+	}
+
+	show_surface-&gt;draw(checkbox-&gt;get_screen_x(), checkbox-&gt;get_screen_y());
+
+	if (checkbox-&gt;get_text().length() &gt; 0)
+		show_font-&gt;draw(checkbox-&gt;get_screen_x() + 4 + show_surface-&gt;get_width(), checkbox-&gt;get_screen_y(), checkbox-&gt;get_text());
+}

Added: trunk/clanlib/GUIStyleSilver/frame_silver.cpp
===================================================================
--- trunk/clanlib/GUIStyleSilver/frame_silver.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUIStyleSilver/frame_silver.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,138 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Display/surface.h&quot;
+#include &quot;API/GUIStyleSilver/frame_silver.h&quot;
+#include &quot;API/GUIStyleSilver/stylemanager_silver.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;API/Core/System/error.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_Frame_Silver::CL_Frame_Silver(
+	CL_Frame *_frame,
+	CL_StyleManager_Silver *style) 
+:
+	CL_ComponentStyle(_frame),
+	frame(_frame),
+	style(style)
+{
+	resources = style-&gt;get_resources();
+	sur_surface = 0;
+	mode = tile;
+
+	slot_set_options = frame-&gt;sig_set_options().connect(
+		this, &amp;CL_Frame_Silver::on_set_options);
+	slot_paint = frame-&gt;sig_paint().connect(
+		this, &amp;CL_Frame_Silver::on_paint);
+	slot_resize = frame-&gt;sig_resize().connect(
+		this, &amp;CL_Frame_Silver::on_resize);
+
+	on_resize(0,0);
+}
+
+CL_Frame_Silver::~CL_Frame_Silver()
+{
+	if(sur_surface)
+		delete sur_surface;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_Frame_Silver::on_set_options(const CL_DomElement &amp;options)
+{
+	if (options.has_attribute(&quot;surface&quot;))
+	{
+		std::string surface = options.get_attribute(&quot;surface&quot;);
+		sur_surface = new CL_Surface(surface, resources);
+	}
+	
+	if (options.has_attribute(&quot;mode&quot;))
+	{
+		std::string v = options.get_attribute(&quot;mode&quot;);
+		
+		if (v == &quot;center&quot;) mode = center;
+		else if (v == &quot;stretch&quot;) mode = stretch;
+		else if (v == &quot;tile&quot;) mode = tile;
+		else throw CL_Error(&quot;unknown frame mode&quot;);
+	}
+}
+
+void CL_Frame_Silver::on_resize(int old_width, int old_height)
+{
+	CL_Rect client_rect(1, 1, frame-&gt;get_width() - 1, frame-&gt;get_height() - 1);
+	frame-&gt;get_client_area()-&gt;set_position(client_rect);
+}
+
+void CL_Frame_Silver::on_paint()
+{
+	int width = frame-&gt;get_width();
+	int height = frame-&gt;get_height();
+
+	if (sur_surface)
+	{
+		switch (mode)
+		{
+		case center:
+			sur_surface-&gt;draw(
+				frame-&gt;get_screen_x() + width / 2 - sur_surface-&gt;get_width() / 2,
+				frame-&gt;get_screen_x() + height / 2 - sur_surface-&gt;get_height() / 2);
+			break;
+			
+		case stretch:
+			sur_surface-&gt;draw(frame-&gt;get_screen_rect());
+			break;
+
+		case tile:
+			{
+			for (int y = 0; y &lt; height; y += sur_surface-&gt;get_height())
+				for (int x = 0; x &lt; width; x += sur_surface-&gt;get_width())
+					sur_surface-&gt;draw(frame-&gt;get_screen_x()+x, frame-&gt;get_screen_y()+y);
+			}
+		}
+	}
+	else
+	{
+		CL_Display::draw_rect(frame-&gt;get_screen_rect(), CL_Color(204, 212, 222));
+
+		if(frame-&gt;is_fill_enabled())
+		{
+			CL_Rect rect = frame-&gt;get_screen_rect();
+			rect.left++;
+			rect.top++;
+			rect.right--;
+			rect.bottom--;
+			CL_Display::fill_rect(rect, CL_Color::white);
+		}
+	}
+}

Added: trunk/clanlib/GUIStyleSilver/image_silver.cpp
===================================================================
--- trunk/clanlib/GUIStyleSilver/image_silver.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUIStyleSilver/image_silver.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,103 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;API/Display/surface.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;API/GUIStyleSilver/image_silver.h&quot;
+#include &quot;API/GUIStyleSilver/stylemanager_silver.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_Image_Silver::CL_Image_Silver(
+	CL_Image *image,
+	CL_StyleManager_Silver *style) 
+:
+	CL_ComponentStyle(image),
+	image(image)
+{
+	resources = style-&gt;get_resources();
+
+	slot_paint = image-&gt;sig_paint().connect(
+		this, &amp;CL_Image_Silver::on_paint);
+
+	slot_get_preferred_size = image-&gt;sig_get_preferred_size().connect(
+		this, &amp;CL_Image_Silver::on_get_preferred_size);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_Image_Silver::on_get_preferred_size(CL_Size &amp;size)
+{
+	CL_Surface * s = image-&gt;get_surface();
+	if(s)
+	{
+		size.width = s-&gt;get_width();
+		size.height = s-&gt;get_height();
+	}
+}
+
+void CL_Image_Silver::on_paint()
+{
+	CL_Surface *surface = image-&gt;get_surface();
+
+	if(surface == 0)
+		return;
+
+	int width = image-&gt;get_width();
+	int height = image-&gt;get_height();
+
+	CL_Image::Mode mode = image-&gt;get_mode();
+
+	switch (mode)
+	{
+	case CL_Image::normal:
+		surface-&gt;draw(0.0f, 0.0f);
+		break;
+
+	case CL_Image::center:
+		surface-&gt;draw(
+			image-&gt;get_screen_x() + (width - surface-&gt;get_width()) / 2,
+			image-&gt;get_screen_y() + (height - surface-&gt;get_height()) / 2);
+		break;
+		
+	case CL_Image::stretch:
+		surface-&gt;draw(image-&gt;get_screen_rect());
+		break;
+
+	case CL_Image::tile:
+		{
+			for (int y = 0; y &lt; height; y += surface-&gt;get_height())
+				for (int x = 0; x &lt; width; x += surface-&gt;get_width())
+					surface-&gt;draw(image-&gt;get_screen_x(), image-&gt;get_screen_y());
+		}
+		break;
+	}
+}

Added: trunk/clanlib/GUIStyleSilver/inputbox_silver.cpp
===================================================================
--- trunk/clanlib/GUIStyleSilver/inputbox_silver.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUIStyleSilver/inputbox_silver.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,253 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;API/Display/font.h&quot;
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Core/System/system.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;API/GUI/gui_manager.h&quot;
+#include &quot;API/GUIStyleSilver/inputbox_silver.h&quot;
+#include &quot;API/GUIStyleSilver/stylemanager_silver.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_InputBox_Silver::CL_InputBox_Silver(
+	CL_InputBox *inputbox,
+	CL_StyleManager_Silver *style)
+: 
+	CL_ComponentStyle(inputbox),
+	inputbox(inputbox),
+	style(style)
+{
+	resources = style-&gt;get_resources();
+	
+	font = new CL_Font(&quot;InputBox/font&quot;, resources);
+	font_disabled = new CL_Font(&quot;InputBox/font_disabled&quot;, resources);
+
+	show_cursor = false;
+	character_offset = 0;
+	cursor_blink_time = CL_System::get_time();
+
+	set_border_size(3);
+
+	slot_paint = inputbox-&gt;sig_paint().connect(
+		this, &amp;CL_InputBox_Silver::on_paint);
+	slot_activity = inputbox-&gt;sig_activity().connect(
+		this, &amp;CL_InputBox_Silver::on_activity);
+	slot_get_preferred_size = inputbox-&gt;sig_get_preferred_size().connect(
+		this, &amp;CL_InputBox_Silver::on_get_preferred_size);
+}
+
+CL_InputBox_Silver::~CL_InputBox_Silver()
+{
+	delete font;
+	delete font_disabled;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_InputBox_Silver::set_border_size(int size)
+{
+	border_size = size;
+
+	// Override height for font-height
+	CL_Rect position = inputbox-&gt;get_position();
+	position.bottom = position.top + font-&gt;get_height() + border_size * 2;
+	inputbox-&gt;set_position(position);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_InputBox_Silver::on_paint()
+{
+	bool has_focus = inputbox-&gt;is_enabled() &amp;&amp; inputbox-&gt;has_focus();
+
+	CL_Rectf rect = inputbox-&gt;get_screen_rect();
+	int width = inputbox-&gt;get_width();
+
+	// Outline
+	if(has_focus)
+	{
+		// Fill
+		CL_Display::fill_rect(
+			CL_Rectf(rect.left + 1, rect.top + 1, rect.right - 1, rect.bottom - 1),
+			CL_Color(245, 250, 255));
+
+		// Main border
+		CL_Display::draw_rect(
+			rect,
+			CL_Color(90, 118, 149));
+
+		// Highlight
+		CL_Display::draw_rect(
+			CL_Rectf(rect.left - 1, rect.top - 1, rect.right + 1, rect.bottom + 1),
+			CL_Color(206, 220, 233));
+	}
+	else
+	{
+		// Fill
+		CL_Display::fill_rect(
+			CL_Rectf(rect.left + 1, rect.top + 1, rect.right - 1, rect.bottom - 1),
+			CL_Color::white);
+
+		// Main border
+		CL_Display::draw_rect(
+			rect,
+			CL_Color(128, 142, 159));
+	}
+
+	// For easy reference, put inputfield-text into local variable
+	const char *text = inputbox-&gt;get_text().c_str();
+
+	// Calculate offset for vertical centering
+	int vert_center = (inputbox-&gt;get_height () - font-&gt;get_height ()) / 2;
+
+	// Calculate scroll offset
+	int character_offset = 0;
+	int pixel_offset = 0;
+	int text_width = (int) inputbox-&gt;in_password_mode() ? font-&gt;get_width('*')*strlen(text) : font-&gt;get_width(text);
+	if (text_width &gt; width - border_size * 2)
+	{
+		while (
+			text_width &gt;= width - border_size * 2 &amp;&amp;
+			character_offset + 1 &lt; inputbox-&gt;get_cursor_position())
+		{
+			int w = inputbox-&gt;in_password_mode() ? font-&gt;get_width('*') : font-&gt;get_width(text[character_offset]);
+			character_offset++;
+			pixel_offset += w;
+			text_width -= w;
+		}
+	}
+
+	// Display marked text, if any
+	if(has_focus) 
+	{
+		if (inputbox-&gt;has_marked_text())
+		{
+			int start = inputbox-&gt;get_selection_start();
+			int end = start + inputbox-&gt;get_selection_length();
+
+			int mark_x1 = 0, mark_x2 = 0;
+
+			int i;
+			if (inputbox-&gt;in_password_mode())
+			{
+				int w = font-&gt;get_width('*');
+
+				if (start &gt; 0)
+					mark_x1 += start*w;
+
+				if (end &gt; start)
+					mark_x2 += (end-start)*w;
+			}
+			else
+			{
+				for(i = 0; i &lt; start; i++)
+					mark_x1 += font-&gt;get_width(text[i]);
+
+				for(i = start; i &lt; end; i++)
+					mark_x2 += font-&gt;get_width(text[i]);
+			}
+
+			CL_Display::fill_rect(
+				CL_Rect(
+					inputbox-&gt;get_screen_x()+border_size + mark_x1 - 1,
+					inputbox-&gt;get_screen_y() + vert_center,
+					inputbox-&gt;get_screen_x()+border_size + mark_x1 + mark_x2,
+					inputbox-&gt;get_screen_y() + font-&gt;get_height() + vert_center),
+				CL_Color(204, 208, 232));
+		}
+	}
+
+	// Display text
+	if(inputbox-&gt;is_enabled() == false)
+	{
+		if (inputbox-&gt;in_password_mode())
+			font_disabled-&gt;draw(inputbox-&gt;get_screen_x()+border_size, inputbox-&gt;get_screen_y()+vert_center, std::string(strlen(text+character_offset), '*'));
+		else
+			font_disabled-&gt;draw(inputbox-&gt;get_screen_x()+border_size, inputbox-&gt;get_screen_y()+vert_center, &amp;text[character_offset]);
+	}
+	else
+	{
+		if (inputbox-&gt;in_password_mode())
+			font-&gt;draw(inputbox-&gt;get_screen_x()+border_size, inputbox-&gt;get_screen_y()+vert_center, std::string(strlen(text+character_offset), '*'));
+		else
+			font-&gt;draw(inputbox-&gt;get_screen_x()+border_size, inputbox-&gt;get_screen_y()+vert_center, &amp;text[character_offset]);
+	}
+
+	// Show blinking cursor
+	if(has_focus) 
+	{
+		if (show_cursor)
+		{
+			int cursor_x = border_size - pixel_offset;
+
+			if (inputbox-&gt;in_password_mode())
+				cursor_x += inputbox-&gt;get_cursor_position() * font-&gt;get_width('*');
+			else
+				for(int i = 0; i &lt; inputbox-&gt;get_cursor_position(); i++)
+					cursor_x += font-&gt;get_width(text[i]);
+			
+			CL_Display::draw_line(
+				inputbox-&gt;get_screen_x() + cursor_x,
+				inputbox-&gt;get_screen_y() + vert_center,
+				inputbox-&gt;get_screen_x() + cursor_x,
+				inputbox-&gt;get_screen_y() + vert_center + font-&gt;get_height() - 1,
+				CL_Color::black);
+		}
+
+		unsigned int cur_time = CL_System::get_time();
+		if (cur_time &gt;= cursor_blink_time)
+		{
+			cursor_blink_time = cur_time + 400;
+			show_cursor = !show_cursor;
+		}
+	}
+}
+
+void CL_InputBox_Silver::on_activity()
+{
+	cursor_blink_time = CL_System::get_time() + 400;
+	show_cursor = true;
+}
+
+void CL_InputBox_Silver::on_get_preferred_size(CL_Size &amp;size)
+{
+	border_size = 3;
+	
+	// Override height for font-height
+	CL_Rect position = inputbox-&gt;get_position();
+	position.bottom = position.top + font-&gt;get_height() + border_size * 2;
+
+	size.width = position.get_width();
+	size.height = position.get_height();
+}

Added: trunk/clanlib/GUIStyleSilver/label_silver.cpp
===================================================================
--- trunk/clanlib/GUIStyleSilver/label_silver.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUIStyleSilver/label_silver.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,103 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;API/Display/font.h&quot;
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;API/GUI/component_style.h&quot;
+#include &quot;API/GUIStyleSilver/label_silver.h&quot;
+#include &quot;API/GUIStyleSilver/stylemanager_silver.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_Label_Silver::CL_Label_Silver(
+	CL_Label *label,
+	CL_StyleManager_Silver *style)
+:
+	CL_ComponentStyle(label),
+	label(label)
+{
+	resources = style-&gt;get_resources();
+	
+	font = new CL_Font(&quot;Label/font&quot;, resources);
+	
+	slot_paint = label-&gt;sig_paint().connect(
+		this, &amp;CL_Label_Silver::on_paint);
+	slot_get_preferred_size = label-&gt;sig_get_preferred_size().connect(
+		this, &amp;CL_Label_Silver::on_get_preferred_size);
+	slot_font_change = label-&gt;sig_font_change().connect(
+		this, &amp;CL_Label_Silver::on_font_change);
+}
+
+CL_Label_Silver::~CL_Label_Silver()
+{
+	delete font;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_Label_Silver::on_get_preferred_size(CL_Size &amp;size)
+{
+	size.width = font-&gt;get_width(label-&gt;get_text());
+	size.height = font-&gt;get_height(label-&gt;get_text());
+}
+
+void CL_Label_Silver::on_paint()
+{
+	const char *text = label-&gt;get_text().c_str();
+
+	CL_Point pos = calc_origin(label-&gt;get_alignment(), CL_Size(label-&gt;get_width() / 2, label-&gt;get_height()));
+	
+	pos.x += label-&gt;get_screen_x();
+	pos.y += label-&gt;get_screen_y();
+	
+	font-&gt;draw(
+		CL_Rect(
+			pos.x,
+			pos.y,
+			pos.x + label-&gt;get_width(),
+			pos.y + label-&gt;get_height()),
+		text);
+}
+
+void CL_Label_Silver::on_font_change()
+{
+	delete font;
+
+	if (label-&gt;get_font() == NULL)
+	{
+		font = new CL_Font(&quot;Label/font&quot;, resources);
+	}
+	else
+	{
+		font = new CL_Font(*(label-&gt;get_font()));
+	}
+}

Added: trunk/clanlib/GUIStyleSilver/listbox_silver.cpp
===================================================================
--- trunk/clanlib/GUIStyleSilver/listbox_silver.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUIStyleSilver/listbox_silver.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,247 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;API/Display/font.h&quot;
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Display/keys.h&quot;
+#include &quot;API/GUI/scrollbar.h&quot;
+#include &quot;API/GUI/listitem.h&quot;
+#include &quot;API/GUIStyleSilver/listbox_silver.h&quot;
+#include &quot;API/GUIStyleSilver/stylemanager_silver.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_ListBox_Silver::CL_ListBox_Silver(
+	CL_ListBox *listbox,
+	CL_StyleManager_Silver *style)
+:
+	CL_ComponentStyle(listbox),
+	listbox(listbox),
+	style(style)
+{
+	resources = style-&gt;get_resources();
+	font = new CL_Font(&quot;ListBox/font&quot;, resources);
+
+	// Create a vertical scrollbar
+	scrollbar = new CL_ScrollBar(false, listbox);
+	visible_scrollbar = true;
+
+	int font_height = font-&gt;get_height();
+	listbox-&gt;set_item_height(font_height);
+
+	CL_Component *client_area = listbox-&gt;get_client_area();
+
+	slots.connect(listbox-&gt;sig_set_options(), this, &amp;CL_ListBox_Silver::on_set_options);
+	slots.connect(listbox-&gt;sig_paint(), this, &amp;CL_ListBox_Silver::on_paint_background);
+	slots.connect(client_area-&gt;sig_mouse_down(), this, &amp;CL_ListBox_Silver::on_mouse_down);
+	slots.connect(client_area-&gt;sig_paint(), this, &amp;CL_ListBox_Silver::on_paint_listbox);
+	slots.connect(listbox-&gt;sig_resize(), this, &amp;CL_ListBox_Silver::on_resize);
+	slots.connect(listbox-&gt;sig_item_added(), this, &amp;CL_ListBox_Silver::on_item_added);
+	slots.connect(listbox-&gt;sig_item_removed(), this, &amp;CL_ListBox_Silver::on_item_removed);
+	slots.connect(listbox-&gt;sig_clear(), this, &amp;CL_ListBox_Silver::on_clear);
+	slots.connect(scrollbar-&gt;sig_value_changed(), this, &amp;CL_ListBox_Silver::on_scroll_change);
+
+	on_resize(0,0);
+}
+
+CL_ListBox_Silver::~CL_ListBox_Silver()
+{
+	delete font;
+	delete scrollbar;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_ListBox_Silver::on_item_added(int index)
+{
+	update_scrollbar(true);
+}
+
+void CL_ListBox_Silver::on_item_removed(int index)
+{
+	update_scrollbar(true);
+}
+
+void CL_ListBox_Silver::on_clear()
+{
+	update_scrollbar(true);
+}
+
+void CL_ListBox_Silver::on_set_options(const CL_DomElement &amp;options)
+{
+}
+
+void CL_ListBox_Silver::on_scroll_change(int new_offset)
+{
+	listbox-&gt;set_top_item(new_offset);
+}
+
+void CL_ListBox_Silver::on_mouse_down(const CL_InputEvent &amp;key)
+{
+	if(key.id == CL_MOUSE_WHEEL_UP)
+	{
+		listbox-&gt;set_top_item(listbox-&gt;get_top_item() - 5);
+		update_scrollbar(true);
+		return;
+	}
+	if(key.id == CL_MOUSE_WHEEL_DOWN)
+	{
+		listbox-&gt;set_top_item(listbox-&gt;get_top_item() + 5);
+		update_scrollbar(true);
+		return;
+	}
+}
+
+void CL_ListBox_Silver::on_resize(int old_width, int old_height)
+{
+	// Position the listbox item-box
+	CL_Rect rect(4, 4, 4 + listbox-&gt;get_width() - 8 , 4 + listbox-&gt;get_height() - 8);
+	listbox-&gt;get_client_area()-&gt;set_position(rect);
+
+	update_scrollbar(false);
+
+	// Scrollbar was added, shrink clientarea
+	if(visible_scrollbar)
+	{
+		listbox-&gt;get_client_area()-&gt;set_width(listbox-&gt;get_client_area()-&gt;get_width() - 19);
+
+		// Position the scrollbar
+		rect = CL_Rect(listbox-&gt;get_width() - 19, 3, listbox-&gt;get_width() - 3, listbox-&gt;get_height() - 3);
+		scrollbar-&gt;set_position(rect);
+	}
+}
+
+void CL_ListBox_Silver::on_paint_background()
+{
+	// Outline
+	CL_Display::draw_rect(listbox-&gt;get_screen_rect(), CL_Color(128, 142, 159));
+
+	// Background
+	CL_Rect rect = listbox-&gt;get_screen_rect();
+	rect.left++;
+	rect.top++;
+	rect.right--;
+	rect.bottom--;
+	CL_Display::fill_rect(rect, CL_Color::white);
+}
+
+void CL_ListBox_Silver::on_paint_listbox()
+{
+	int width = listbox-&gt;get_client_area()-&gt;get_width();
+
+	int pos = 0;
+
+	int font_height = font-&gt;get_height();
+
+	std::vector&lt;CL_ListItem *&gt; items = listbox-&gt;get_items();
+	std::vector&lt;CL_ListItem *&gt;::iterator it;
+	int offset = listbox-&gt;get_top_item();
+	int end = offset + (listbox-&gt;get_height () - 2) / font_height;
+	for (it = items.begin(); it != items.end(); it++)
+	{
+		if(pos &lt; offset)
+		{
+			++pos;
+			continue;
+		}
+		else if (pos &gt;= end)
+		{
+			break;
+		}
+
+		if((*it)-&gt;selected)
+		{
+			CL_Display::fill_rect(
+				CL_Rect(
+					listbox-&gt;get_screen_x() + 1,
+					listbox-&gt;get_screen_y() + 1 +(pos - offset) * font_height,
+					listbox-&gt;get_screen_x() - 2 + width,
+					listbox-&gt;get_screen_y() + 1 +(pos + 1 - offset) * font_height),
+				CL_Gradient(
+					CL_Color(254, 207, 147),
+					CL_Color::white,
+					CL_Color(254, 207, 147),
+					CL_Color::white));
+		}
+
+		
+
+		CL_Rect rect (CL_Point (listbox-&gt;get_screen_x() + 3,
+			                    listbox-&gt;get_screen_y() + 1 +(pos - offset) * font_height),
+					  CL_Size (listbox-&gt;get_width () - 6,
+							   font_height));
+
+		if (visible_scrollbar)
+		{
+			rect.right -= scrollbar-&gt;get_width ();
+		}
+
+		font-&gt;draw (rect,		
+					(*it)-&gt;str);
+
+		pos++;
+	}
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Implementation:
+
+void CL_ListBox_Silver::update_scrollbar(bool resize)
+{	
+	int max_visible_items = (listbox-&gt;get_client_area()-&gt;get_height() - 4) / listbox-&gt;get_item_height();
+
+	if(listbox-&gt;get_count() &gt; max_visible_items)
+	{
+		if(visible_scrollbar == false)
+		{
+			visible_scrollbar = true;
+			listbox-&gt;add_child(scrollbar, false);
+
+			if(resize)
+				on_resize(0,0);
+		}
+
+		scrollbar-&gt;set_max_value(listbox-&gt;get_count() - max_visible_items);
+		scrollbar-&gt;set_value(listbox-&gt;get_top_item());
+	}
+	else
+	{
+		if(visible_scrollbar)
+		{
+			visible_scrollbar = false;
+			scrollbar-&gt;set_value(0);
+			listbox-&gt;remove_child(scrollbar);
+
+			if(resize)
+				on_resize(0,0);
+		}
+	}
+}

Added: trunk/clanlib/GUIStyleSilver/menu_item_silver.cpp
===================================================================
--- trunk/clanlib/GUIStyleSilver/menu_item_silver.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUIStyleSilver/menu_item_silver.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,155 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;API/Display/font.h&quot;
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Display/surface.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;API/GUI/component_style.h&quot;
+#include &quot;API/GUI/menu_item.h&quot;
+#include &quot;API/GUIStyleSilver/menu_item_silver.h&quot;
+#include &quot;API/GUIStyleSilver/stylemanager_silver.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_MenuItem_Silver::CL_MenuItem_Silver(
+	CL_MenuItem *menu_item,
+	CL_StyleManager_Silver *style)
+:
+	CL_ComponentStyle(menu_item),
+	menu_item(menu_item),
+	sur_icon(0),
+	sur_checked(0),
+	sur_unchecked(0),
+	delete_sur_icon(false)
+{
+	resources = style-&gt;get_resources();
+	
+	font = new CL_Font(&quot;MenuItem/font&quot;, resources);
+	font_disabled = new CL_Font(&quot;MenuItem/font_disabled&quot;, resources);
+
+	slot_paint = menu_item-&gt;sig_paint().connect(
+		this, &amp;CL_MenuItem_Silver::on_paint);
+	slot_get_preferred_size = menu_item-&gt;sig_get_preferred_size().connect(
+		this, &amp;CL_MenuItem_Silver::on_get_preferred_size);
+}
+
+CL_MenuItem_Silver::~CL_MenuItem_Silver()
+{
+	delete font;
+	delete font_disabled;
+	delete sur_checked;
+	delete sur_unchecked;
+
+	if( delete_sur_icon )
+		delete sur_icon;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_MenuItem_Silver::on_get_preferred_size(CL_Size &amp;size)
+{
+	int icon_width = 0;
+	int height = 16;
+
+	if( menu_item-&gt;use_icon() )
+		icon_width = 16;
+	
+	if( font-&gt;get_height(menu_item-&gt;get_text()) &gt; height )
+		height = font-&gt;get_height(menu_item-&gt;get_text())+1;
+
+	size.width = icon_width + 4 + font-&gt;get_width(menu_item-&gt;get_text());
+	size.height = height;
+}
+
+void CL_MenuItem_Silver::on_paint()
+{
+	if( menu_item-&gt;is_toggling() )
+	{
+		if( sur_checked == 0 &amp;&amp; sur_unchecked == 0 )
+		{
+			if (resources-&gt;exists(&quot;MenuItem/checked&quot;))
+				sur_checked = new CL_Surface(&quot;MenuItem/checked&quot;, resources);
+			if (resources-&gt;exists(&quot;MenuItem/unchecked&quot;))
+				sur_unchecked = new CL_Surface(&quot;MenuItem/unchecked&quot;, resources);
+		}
+
+		if( menu_item-&gt;is_selected() )
+		{
+			if( sur_checked )
+				sur_checked-&gt;draw(menu_item-&gt;get_screen_x(),menu_item-&gt;get_screen_y());
+		}
+		else	
+		{
+			if( sur_unchecked )
+				sur_unchecked-&gt;draw(menu_item-&gt;get_screen_x(),menu_item-&gt;get_screen_y());
+		}
+	}
+	else if( sur_icon )
+		sur_icon-&gt;draw(menu_item-&gt;get_screen_x(),menu_item-&gt;get_screen_y());
+
+	const char *text = menu_item-&gt;get_text().c_str();
+
+	// check if menu node is enabled
+	bool is_enabled = menu_item-&gt;get_parent()-&gt;is_enabled();
+
+	// check if parent menu is enabled
+	if( menu_item-&gt;get_parent()-&gt;get_parent()-&gt;is_enabled() == false )
+		is_enabled = false;
+
+	if( menu_item-&gt;use_icon() )
+	{
+		if( is_enabled )
+			font-&gt;draw(menu_item-&gt;get_screen_x()+20, menu_item-&gt;get_screen_y()+2, text);
+		else
+			font_disabled-&gt;draw(menu_item-&gt;get_screen_x()+18, menu_item-&gt;get_screen_y()+2, text);
+	}
+	else
+	{
+		if( is_enabled )
+			font-&gt;draw(menu_item-&gt;get_screen_x()+2, menu_item-&gt;get_screen_y()+2, text);
+		else
+			font_disabled-&gt;draw(menu_item-&gt;get_screen_x()+2, menu_item-&gt;get_screen_y()+2, text);
+	}
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Operations:
+
+void CL_MenuItem_Silver::set_icon(CL_Surface *sur, bool del_surface)
+{
+	if( sur_icon &amp;&amp; delete_sur_icon )
+		delete sur_icon;
+	
+	sur_icon = sur;
+	delete_sur_icon = del_surface;
+}
+

Added: trunk/clanlib/GUIStyleSilver/menu_node_silver.cpp
===================================================================
--- trunk/clanlib/GUIStyleSilver/menu_node_silver.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUIStyleSilver/menu_node_silver.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,113 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;API/Core/Math/rect.h&quot;
+#include &quot;API/Display/surface.h&quot;
+#include &quot;API/Core/XML/dom_element.h&quot;
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/GUIStyleSilver/stylemanager_silver.h&quot;
+#include &quot;API/GUI/menu.h&quot;
+#include &quot;API/GUIStyleSilver/menu_node_silver.h&quot;
+
+CL_MenuNode_Silver::CL_MenuNode_Silver(
+	CL_MenuNode *node,
+	CL_StyleManager_Silver *style)
+:
+	CL_ComponentStyle(node),
+	node(node),
+	style(style),
+	resources(0),
+	arrow(0)
+{
+	resources = style-&gt;get_resources();
+
+	if (resources-&gt;exists(&quot;Menu/submenu_arrow&quot;))
+		arrow = new CL_Surface(&quot;Menu/submenu_arrow&quot;, resources);	
+	
+	slots.connect(node-&gt;sig_set_options(), this, &amp;CL_MenuNode_Silver::on_set_options);
+	slots.connect(node-&gt;sig_paint(), this, &amp;CL_MenuNode_Silver::on_paint);
+	slots.connect(node-&gt;sig_reposition(), this, &amp;CL_MenuNode_Silver::on_reposition); // todo: sync names?
+	slots.connect(node-&gt;sig_get_preferred_size(), this, &amp;CL_MenuNode_Silver::on_get_preferred_size);
+}
+
+CL_MenuNode_Silver::~CL_MenuNode_Silver()
+{
+	delete arrow;
+}
+
+void CL_MenuNode_Silver::on_set_options(const CL_DomElement &amp;options)
+{
+	// ?
+}
+
+void CL_MenuNode_Silver::on_paint()
+{
+	CL_Rect area(
+		node-&gt;get_screen_x()+1,
+		node-&gt;get_screen_y(),
+		node-&gt;get_screen_x()+node-&gt;get_width()-1,
+		node-&gt;get_screen_y()+node-&gt;get_height());
+
+	// mouseover fill
+	if( node-&gt;has_mouse_over() &amp;&amp; node-&gt;is_enabled() &amp;&amp; node-&gt;get_parent_menu()-&gt;is_enabled() )
+		CL_Display::fill_rect( area, 
+			CL_Gradient(
+				CL_Color(255,255,255,128), CL_Color(254, 207, 147, 128),
+				CL_Color(255,255,255,128), CL_Color(254, 207, 147, 128) ));
+
+	if( arrow &amp;&amp; node-&gt;has_submenu() )
+	{		
+		if( node-&gt;get_parent_menu()-&gt;is_vertical() ) // no arrow in horizontal menus
+			arrow-&gt;draw( area.right-8, node-&gt;get_screen_y()+4 );
+	}
+}
+
+void CL_MenuNode_Silver::on_reposition()
+{
+	CL_Rect menu_pos = node-&gt;get_parent_menu()-&gt;get_position();
+	CL_Rect node_pos = node-&gt;get_position();
+	CL_Menu *submenu = node-&gt;get_submenu();
+
+	if( submenu )
+	{
+		if( node-&gt;get_parent_menu()-&gt;is_vertical() )
+			submenu-&gt;reposition( menu_pos.right-2, menu_pos.top + node_pos.top+2 );
+		else
+		{
+			submenu-&gt;reposition( menu_pos.left + node_pos.left, menu_pos.top+menu_pos.get_height() );
+		}
+	}
+}
+
+void CL_MenuNode_Silver::on_get_preferred_size(CL_Size &amp;size)
+{
+	if( size.width &lt; 220 )
+		size.width = 220;
+}

Added: trunk/clanlib/GUIStyleSilver/menu_silver.cpp
===================================================================
--- trunk/clanlib/GUIStyleSilver/menu_silver.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUIStyleSilver/menu_silver.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,206 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;API/display.h&quot;
+#include &quot;API/gui.h&quot;
+#include &quot;API/core.h&quot;  // ?
+
+#include &quot;API/GUIStyleSilver/menu_silver.h&quot;
+#include &quot;API/GUI/menu.h&quot;
+#include &quot;API/GUI/menu_node.h&quot;
+
+CL_Menu_Silver::CL_Menu_Silver(
+	CL_Menu *menu,
+	CL_StyleManager_Silver *style)
+:
+	CL_ComponentStyle(menu),
+	menu(menu),
+	style(style),
+	repositioned(true)
+{
+	slots.connect(menu-&gt;sig_set_options(), this, &amp;CL_Menu_Silver::on_set_options);
+	slots.connect(menu-&gt;sig_paint(), this, &amp;CL_Menu_Silver::on_paint);
+	slots.connect(menu-&gt;sig_reposition(), this, &amp;CL_Menu_Silver::on_reposition);
+
+	if( menu-&gt;get_parent_node() == 0 )
+	{
+		slots.connect(menu-&gt;get_parent()-&gt;sig_resize(), this, &amp;CL_Menu_Silver::on_parent_resize);
+		repositioned = false;
+	}
+}
+
+CL_Menu_Silver::~CL_Menu_Silver()
+{
+}
+
+void CL_Menu_Silver::on_set_options(const CL_DomElement &amp;options)
+{
+	// ?
+}
+
+void CL_Menu_Silver::on_paint()
+{
+	// reposition
+	if( !repositioned )
+	{
+		menu-&gt;reposition();
+		repositioned = true;
+	}
+
+	CL_Rect area = menu-&gt;get_screen_rect();
+	
+	if( !menu-&gt;is_vertical() )
+	{
+		CL_Display::fill_rect(
+			area,
+			CL_Gradient(
+				CL_Color::silver,CL_Color::silver,
+				CL_Color::white, CL_Color::white )
+		);
+
+		CL_Display::fill_rect(
+			CL_Rect( area.left, area.bottom-3, area.right, area.bottom ),
+			CL_Gradient(
+				CL_Color::white, CL_Color::white,
+				CL_Color::silver, CL_Color::silver)
+		);
+
+		CL_Display::draw_rect( area, CL_Color(128,128,128,128) );
+
+	}
+	else
+	{
+		// full cover gradient
+		CL_Display::fill_rect(
+			area,	
+			CL_Gradient(
+				CL_Color::white, CL_Color::white,
+				CL_Color::silver,CL_Color::silver ));
+
+		// left side gradient 
+		CL_Display::fill_rect(
+			CL_Rect(area.left, area.top, area.left+3, area.bottom),	
+			CL_Gradient(
+				CL_Color::silver,CL_Color::silver,
+				CL_Color::white, CL_Color::white ));
+	
+		// icon area gradient
+		CL_Display::fill_rect(
+			CL_Rect(area.left+3, area.top, area.left+3+17, area.bottom),	
+			CL_Gradient(
+				CL_Color::white, CL_Color::lightgray,
+				CL_Color::white, CL_Color::lightgray ));
+
+
+		CL_Display::draw_rect( area, CL_Color(0,0,0,128) );
+	}
+		
+}
+
+void CL_Menu_Silver::on_reposition(int pos_x, int pos_y)
+{
+	menu-&gt;raise(); // make menu be on top of other components.
+
+	int items_width = menu-&gt;get_items_width() + 4;
+	if( items_width &lt; 90 )
+		items_width = 90;
+
+	int items_height = menu-&gt;get_items_height();
+	if( items_height &lt; 20 )
+		items_height = 20;
+
+	CL_Rect menu_rect(
+		pos_x, pos_y,
+		pos_x + items_width + 3,
+		pos_y + items_height );
+	
+	if( menu-&gt;is_auto_resize() )
+	{
+		menu-&gt;set_position( menu_rect );
+	}
+	
+	std::list&lt;CL_MenuNode*&gt; &amp;children = menu-&gt;get_node_list();
+
+	if( !children.empty() )
+	{
+		int X=2, Y=1;
+		
+		// calculate a new position for each menu node, and 
+		// update the positions of all submenus.
+		std::list&lt;CL_MenuNode*&gt;::iterator it;
+		for( it = children.begin(); it != children.end(); ++it )
+		{
+			CL_Component *item = (*it)-&gt;get_data();
+			const CL_Rect &amp;ipos = item-&gt;get_position();
+
+			(*it)-&gt;set_position(
+				CL_Rect(
+					X, Y,
+					menu-&gt;is_vertical() ? X + items_width : X + item-&gt;get_width(),
+					Y + ipos.top + item-&gt;get_height() + 4 ));
+
+			if( menu-&gt;is_vertical() )
+			{
+				// don't resize elements not placed originally at (0,0) or (1,0)
+				if( ipos.top == 0 &amp;&amp; ipos.left == 0 )
+					item-&gt;set_position(1,0);
+			}
+			else
+				item-&gt;set_position(0,0);
+			
+			(*it)-&gt;reposition_submenus();
+			
+			if( menu-&gt;is_vertical() )
+				Y += ipos.top + item-&gt;get_height() + 4;
+			else
+				X += ipos.left + item-&gt;get_width() + 4;
+		}
+	}	
+
+	if( menu-&gt;is_auto_resize() )
+	{
+		CL_Rect child_rect = menu-&gt;get_children_rect();
+
+		if( menu-&gt;is_vertical() )
+			menu-&gt;set_width(child_rect.right);
+		else
+			menu-&gt;set_width(menu-&gt;get_parent()-&gt;get_width());
+
+		menu-&gt;set_height(child_rect.bottom+2);
+	}
+
+}
+
+void CL_Menu_Silver::on_parent_resize(int old_size_x, int old_size_y)
+{
+	if( menu-&gt;is_vertical() || !menu-&gt;is_auto_resize() )
+		return;
+	
+	menu-&gt;set_width( menu-&gt;get_parent()-&gt;get_width() );
+}

Added: trunk/clanlib/GUIStyleSilver/progressbar_silver.cpp
===================================================================
--- trunk/clanlib/GUIStyleSilver/progressbar_silver.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUIStyleSilver/progressbar_silver.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,78 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    Kenneth Gangst&#248;
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Display/surface.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;API/GUIStyleSilver/progressbar_silver.h&quot;
+#include &quot;API/GUIStyleSilver/stylemanager_silver.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_ProgressBar_Silver::CL_ProgressBar_Silver(
+	CL_ProgressBar *progressbar,
+	CL_StyleManager_Silver *style)
+:
+	CL_ComponentStyle(progressbar),
+	style(style),
+	progressbar(progressbar)
+{
+	CL_ResourceManager *resources = style-&gt;get_resources();
+
+	sur_foreground = new CL_Surface(&quot;ProgressBar/surface_foreground&quot;, resources);
+	sur_background = new CL_Surface(&quot;ProgressBar/surface_background&quot;, resources);
+
+	slot_paint = progressbar-&gt;sig_paint().connect(
+		this, &amp;CL_ProgressBar_Silver::on_paint);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_ProgressBar_Silver::on_paint()
+{
+	int width = progressbar-&gt;get_width();
+	float percent = progressbar-&gt;get_percentage();
+
+	int length = (int) ((width - 4) * percent);
+
+	CL_Rect rect = progressbar-&gt;get_screen_rect();
+
+	// Outline
+	CL_Display::draw_rect(rect, CL_Color(128, 142, 159));
+
+	sur_background-&gt;draw(CL_Rect(rect.left + 1, rect.top + 1, rect.right - 1, rect.bottom - 1));
+
+	sur_foreground-&gt;draw(CL_Rect(rect.left + 1, rect.top + 1, rect.left + length - 1, rect.bottom - 1));
+
+	// TODO: Write percentage in text
+//	font-&gt;draw(...);
+}

Added: trunk/clanlib/GUIStyleSilver/radiobutton_silver.cpp
===================================================================
--- trunk/clanlib/GUIStyleSilver/radiobutton_silver.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUIStyleSilver/radiobutton_silver.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,116 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;API/Display/surface.h&quot;
+#include &quot;API/Display/font.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;API/GUIStyleSilver/radiobutton_silver.h&quot;
+#include &quot;API/GUIStyleSilver/stylemanager_silver.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_RadioButton_Silver::CL_RadioButton_Silver(
+	CL_RadioButton *radiobutton,
+	CL_StyleManager_Silver *style)
+:
+	CL_ComponentStyle(radiobutton),
+	radiobutton(radiobutton),
+	style(style)
+{
+	resources = style-&gt;get_resources();
+
+	sur_checked = new CL_Surface(&quot;RadioButton/surface_checked&quot;, resources);
+	sur_unchecked = new CL_Surface(&quot;RadioButton/surface_unchecked&quot;, resources);
+	sur_checked_disabled = new CL_Surface(&quot;RadioButton/surface_checked_disabled&quot;, resources);
+	sur_unchecked_disabled = new CL_Surface(&quot;RadioButton/surface_unchecked_disabled&quot;, resources);
+	font = new CL_Font(&quot;RadioButton/font&quot;, resources);
+
+	slot_paint = radiobutton-&gt;sig_paint().connect_virtual(
+		this, &amp;CL_RadioButton_Silver::on_paint);
+
+	slot_get_preferred_size = radiobutton-&gt;sig_get_preferred_size().connect(
+		this, &amp;CL_RadioButton_Silver::on_get_preferred_size);
+}
+
+CL_RadioButton_Silver::~CL_RadioButton_Silver()
+{
+	delete font;
+	delete sur_checked;
+	delete sur_unchecked;
+	delete sur_checked_disabled;
+	delete sur_unchecked_disabled;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_RadioButton_Silver::on_get_preferred_size(CL_Size &amp;size)
+{
+	CL_Surface *s = sur_checked;
+	size.width = s-&gt;get_width() + font-&gt;get_width(radiobutton-&gt;get_text()) + 8;
+	size.height = font-&gt;get_height() + 4;
+	if(size.height &lt; (int)s-&gt;get_height())
+		size.height = s-&gt;get_height();
+}
+
+void CL_RadioButton_Silver::on_paint(CL_SlotParent_v0 &amp;super)
+{
+	CL_Surface *show_surface;
+
+	if (radiobutton-&gt;is_enabled())
+	{
+		if (radiobutton-&gt;is_checked())
+			show_surface = sur_checked;
+		else
+			show_surface = sur_unchecked;
+	}
+	else
+	{
+		if (radiobutton-&gt;is_checked())
+			show_surface = sur_checked_disabled;
+		else
+			show_surface = sur_checked_disabled;
+	}
+
+	int xpos = radiobutton-&gt;get_screen_x();
+	int ypos = radiobutton-&gt;get_screen_y();
+
+	show_surface-&gt;draw(xpos, ypos);
+
+	if (radiobutton-&gt;get_text().length() &gt; 0)
+	{
+		int text_height = font-&gt;get_height();
+
+		font-&gt;draw(
+			xpos + 4 + show_surface-&gt;get_width(),
+			ypos + (show_surface-&gt;get_height() - text_height) / 2,
+			radiobutton-&gt;get_text());
+	}
+}

Added: trunk/clanlib/GUIStyleSilver/scrollbar_silver.cpp
===================================================================
--- trunk/clanlib/GUIStyleSilver/scrollbar_silver.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUIStyleSilver/scrollbar_silver.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,233 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    Kenneth Gangst&#248;
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Display/surface.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;API/GUIStyleSilver/scrollbar_silver.h&quot;
+#include &quot;API/GUIStyleSilver/button_silver.h&quot;
+#include &quot;API/GUIStyleSilver/stylemanager_silver.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_ScrollBar_Silver::CL_ScrollBar_Silver(
+	CL_ScrollBar *scrollbar,
+	CL_StyleManager_Silver *style)
+:
+	CL_ComponentStyle(scrollbar),
+	timer_scroll(250),
+	scrollbar(scrollbar),
+	style(style)
+{
+	CL_Component *client_area = scrollbar-&gt;get_client_area();
+
+	button_increase = new CL_Button(&quot;&quot;, scrollbar, style);
+	button_decrease = new CL_Button(&quot;&quot;, scrollbar, style);
+
+	slots.connect(client_area-&gt;sig_paint(), this, &amp;CL_ScrollBar_Silver::on_paint);
+	slots.connect(timer_scroll.sig_timer(), this, &amp;CL_ScrollBar_Silver::on_timer_scroll);
+
+	slots.connect(button_increase-&gt;sig_pressed(), this, &amp;CL_ScrollBar_Silver::start_scroll, 1);
+	slots.connect(button_decrease-&gt;sig_pressed(), this, &amp;CL_ScrollBar_Silver::start_scroll, -1);
+	slots.connect(button_increase-&gt;sig_released(), this, &amp;CL_ScrollBar_Silver::stop_scroll);
+	slots.connect(button_decrease-&gt;sig_released(), this, &amp;CL_ScrollBar_Silver::stop_scroll);
+	slots.connect(scrollbar-&gt;sig_resize(), this, &amp;CL_ScrollBar_Silver::on_resize);
+	slots.connect(scrollbar-&gt;sig_set_options(), this, &amp;CL_ScrollBar_Silver::on_set_options);
+
+	on_resize(0, 0);
+}
+
+CL_ScrollBar_Silver::~CL_ScrollBar_Silver()
+{
+	delete button_increase;
+	delete button_decrease;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_ScrollBar_Silver::on_set_options(const CL_DomElement &amp;options)
+{
+}
+
+void CL_ScrollBar_Silver::on_resize(int old_width, int old_height)
+{
+	CL_Rect rect_decrease;
+	CL_Rect rect_increase;
+	CL_Rect rect_client;
+
+	if (scrollbar-&gt;is_vertical())
+	{
+		int button_size = scrollbar-&gt;get_width();
+		rect_decrease = CL_Rect(0, 0, button_size, button_size);
+		rect_increase = CL_Rect(0, scrollbar-&gt;get_height() - button_size, button_size, scrollbar-&gt;get_height());
+		rect_client = CL_Rect(0, button_size, button_size, scrollbar-&gt;get_height() - button_size);
+	}
+	else
+	{
+		int button_size = scrollbar-&gt;get_height();
+		rect_decrease = CL_Rect(0, 0, button_size, button_size);
+		rect_increase = CL_Rect(scrollbar-&gt;get_width() - button_size, 0, scrollbar-&gt;get_width(), button_size);
+		rect_client = CL_Rect(button_size, 0, scrollbar-&gt;get_width() - button_size, button_size);
+	}
+
+	button_decrease-&gt;set_position(rect_decrease);
+	button_increase-&gt;set_position(rect_increase);
+	scrollbar-&gt;get_client_area()-&gt;set_position(rect_client);
+}
+
+void CL_ScrollBar_Silver::on_timer_scroll()
+{
+	scrollbar-&gt;set_value(scrollbar-&gt;get_value() + scroll_delta);
+}
+
+void CL_ScrollBar_Silver::on_paint()
+{
+	CL_Rect rect = scrollbar-&gt;get_screen_rect();
+
+	int offset_x = rect.left;
+	int offset_y = rect.top;
+
+	if (scrollbar-&gt;is_vertical())
+	{
+		offset_y += button_decrease-&gt;get_height();
+	}
+	else
+	{
+		offset_x += button_decrease-&gt;get_width();
+	}
+
+	CL_Rectf slider_rect = scrollbar-&gt;get_slider_rect();
+	slider_rect.left += offset_x;
+	slider_rect.top += offset_y;
+	slider_rect.right += offset_x;
+	slider_rect.bottom += offset_y;
+
+	CL_Display::draw_rect(
+		rect,
+		CL_Color(128, 142, 159));
+
+	CL_Display::fill_rect(
+		CL_Rect(rect.left + 1, rect.top, rect.right - 1, rect.bottom),
+		CL_Color(203, 215, 227));
+
+		// Main border
+	CL_Display::draw_rect(
+		slider_rect, 
+		CL_Color(128, 142, 159));
+
+	// Outer gradient
+	CL_Display::fill_rect(
+		CL_Rectf(slider_rect.left + 1, slider_rect.top + 1, slider_rect.right - 1, slider_rect.bottom - 1),
+		CL_Gradient(CL_Color::white, CL_Color::white, CL_Color(230, 235, 240), CL_Color(230, 235, 240)));
+
+	// Inner gradient
+	CL_Display::fill_rect(
+		CL_Rectf(slider_rect.left + 3, slider_rect.top + 3, slider_rect.right - 3, slider_rect.bottom - 3),
+		CL_Gradient(CL_Color(217, 222, 227), CL_Color(217, 222, 227), CL_Color::white, CL_Color::white));
+
+/*	CL_Display::draw_line(
+		offset_x + slider_rect.left,
+		offset_y + slider_rect.top + 1,
+		offset_x + slider_rect.left,
+		offset_y + slider_rect.bottom - 1,
+		CL_Color(128, 142, 159));
+
+	CL_Display::draw_line(
+		offset_x + slider_rect.right - 1,
+		offset_y + slider_rect.top + 1,
+		offset_x + slider_rect.right - 1,
+		offset_y + slider_rect.bottom - 1,
+		CL_Color(128, 142, 159));
+
+	CL_Display::draw_line(
+		offset_x + slider_rect.left + 1,
+		offset_y + slider_rect.top,
+		offset_x + slider_rect.right - 1,
+		offset_y + slider_rect.top,
+		CL_Color(128, 142, 159));
+
+	CL_Display::draw_line(
+		offset_x + slider_rect.left + 1,
+		offset_y + slider_rect.bottom - 1,
+		offset_x + slider_rect.right - 1,
+		offset_y + slider_rect.bottom - 1,
+		CL_Color(128, 142, 159));
+
+	CL_Display::fill_rect(
+		CL_Rect(
+			offset_x + slider_rect.left + 1,
+			offset_y + slider_rect.top + 1,
+			offset_x + slider_rect.right - 1,
+			offset_y + slider_rect.bottom - 1),
+		CL_Gradient(
+			CL_Color::white,
+			CL_Color(230, 235, 240),
+			CL_Color::white,
+			CL_Color(230, 235, 240)));
+*/
+	CL_Display::draw_line(
+		slider_rect.left + 5,
+		slider_rect.top + slider_rect.get_height() / 2 - 2,
+		slider_rect.right - 5,
+		slider_rect.top + slider_rect.get_height() / 2 - 2, 
+		CL_Color(128, 142, 159));
+
+	CL_Display::draw_line(
+		slider_rect.left + 5,
+		slider_rect.top + slider_rect.get_height() / 2,
+		slider_rect.right - 5,
+		slider_rect.top + slider_rect.get_height() / 2, 
+		CL_Color(128, 142, 159));
+
+	CL_Display::draw_line(
+		slider_rect.left + 5,
+		slider_rect.top + slider_rect.get_height() / 2 + 2,
+		slider_rect.right - 5,
+		slider_rect.top + slider_rect.get_height() / 2 + 2, 
+		CL_Color(128, 142, 159));
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Implementation:
+
+void CL_ScrollBar_Silver::start_scroll(int delta)
+{
+	scroll_delta = delta;
+	timer_scroll.enable();
+	on_timer_scroll();
+}
+
+void CL_ScrollBar_Silver::stop_scroll()
+{
+	timer_scroll.disable();
+}
+

Added: trunk/clanlib/GUIStyleSilver/stylemanager_silver.cpp
===================================================================
--- trunk/clanlib/GUIStyleSilver/stylemanager_silver.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUIStyleSilver/stylemanager_silver.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,99 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Display/surface.h&quot;
+#include &quot;API/Core/Resources/resource_manager.h&quot;
+#include &quot;API/GUI/component_manager.h&quot;
+#include &quot;API/guistylesilver.h&quot;
+
+// Construction:
+
+CL_StyleManager_Silver::CL_StyleManager_Silver(CL_ResourceManager *resources)
+: CL_StyleManager(resources)
+{
+}
+
+CL_StyleManager_Silver::~CL_StyleManager_Silver()
+{
+}
+
+// Overridables:
+void CL_StyleManager_Silver::connect_styles(
+	const std::string &amp;type,
+	CL_Component *component)
+{
+	if (type == &quot;label&quot;)
+		component-&gt;set_style(new CL_Label_Silver((CL_Label *) component, this));
+
+	else if (type == &quot;button&quot;)
+		component-&gt;set_style(new CL_Button_Silver((CL_Button *) component, this));
+
+	else if (type == &quot;frame&quot;)
+		component-&gt;set_style(new CL_Frame_Silver((CL_Frame *) component, this));
+
+	else if (type == &quot;image&quot;)
+		component-&gt;set_style(new CL_Image_Silver((CL_Image *) component, this));
+
+	else if (type == &quot;inputbox&quot;)
+		component-&gt;set_style(new CL_InputBox_Silver((CL_InputBox *) component, this));
+
+	else if (type == &quot;menu&quot;)
+		component-&gt;set_style(new CL_Menu_Silver((CL_Menu *) component, this));
+
+	else if (type == &quot;menu_node&quot;)
+		component-&gt;set_style(new CL_MenuNode_Silver((CL_MenuNode *) component, this));
+
+	else if (type == &quot;menu_item&quot;)
+		component-&gt;set_style(new CL_MenuItem_Silver((CL_MenuItem *) component, this));
+
+	else if (type == &quot;scrollbar&quot;)
+		component-&gt;set_style(new CL_ScrollBar_Silver((CL_ScrollBar *) component, this));
+
+	else if (type == &quot;progressbar&quot;)
+		component-&gt;set_style(new CL_ProgressBar_Silver((CL_ProgressBar *) component, this));
+
+	else if (type == &quot;radiobutton&quot;)
+		component-&gt;set_style(new CL_RadioButton_Silver((CL_RadioButton *) component, this));
+
+	else if (type == &quot;checkbox&quot;)
+		component-&gt;set_style(new CL_CheckBox_Silver((CL_CheckBox *) component, this));
+
+	else if (type == &quot;listbox&quot;)
+		component-&gt;set_style(new CL_ListBox_Silver((CL_ListBox *) component, this));
+
+	else if (type == &quot;treeview&quot;)
+		component-&gt;set_style(new CL_TreeView_Silver((CL_TreeView *) component, this));
+
+	else if (type == &quot;treeitem&quot;)
+		component-&gt;set_style(new CL_TreeItem_Silver((CL_TreeItem *) component, this));
+
+	else if (type == &quot;window&quot;)
+		component-&gt;set_style(new CL_Window_Silver((CL_Window *) component, this));
+}

Added: trunk/clanlib/GUIStyleSilver/treeitem_silver.cpp
===================================================================
--- trunk/clanlib/GUIStyleSilver/treeitem_silver.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUIStyleSilver/treeitem_silver.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,133 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Display/font.h&quot;
+#include &quot;API/Display/surface.h&quot;
+#include &quot;API/GUI/treenode.h&quot;
+#include &quot;API/GUI/treeview.h&quot;
+#include &quot;API/GUIStyleSilver/treeitem_silver.h&quot;
+#include &quot;API/GUIStyleSilver/stylemanager_silver.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_TreeItem_Silver::CL_TreeItem_Silver(
+	CL_TreeItem *treeview_item,
+	CL_StyleManager_Silver *style)
+:
+	CL_ComponentStyle(treeview_item),
+	item(treeview_item),
+	style(style)
+{
+	CL_ResourceManager *resources = style-&gt;get_resources();
+	font = new CL_Font(&quot;TreeViewItem/font&quot;, resources);
+		
+	slot_paint = item-&gt;sig_paint().connect(
+		this, &amp;CL_TreeItem_Silver::on_paint);
+	slot_get_preferred_size = item-&gt;sig_get_preferred_size().connect(
+		this, &amp;CL_TreeItem_Silver::on_get_preferred_size);
+}
+
+CL_TreeItem_Silver::~CL_TreeItem_Silver()
+{
+	delete font;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_TreeItem_Silver::on_get_preferred_size(CL_Size &amp;size)
+{
+	size.width = item-&gt;get_node()-&gt;get_treeview()-&gt;get_client_area()-&gt;get_width();
+	size.height = item-&gt;get_custom_height();
+
+	if(size.height == 0)
+	{
+		if(item-&gt;get_icon())
+			size.height = item-&gt;get_icon()-&gt;get_height() + 2;
+		else
+			size.height = font-&gt;get_height(item-&gt;get_text()) + 2;
+	}
+}
+
+void CL_TreeItem_Silver::on_paint()
+{
+	CL_Rect rect = item-&gt;get_screen_rect();
+	
+	int height = rect.get_height();
+	int font_height = font-&gt;get_height(item-&gt;get_text(0));
+	
+	if(item-&gt;has_mouse_over())
+		CL_Display::fill_rect(rect, CL_Color(232, 236, 241));
+	if(item-&gt;get_node()-&gt;is_selected())
+		CL_Display::fill_rect(rect, CL_Color(184, 195, 209, 150));
+
+	CL_TreeView *treeview = item-&gt;get_node()-&gt;get_treeview();
+	int columns = treeview-&gt;get_column_count();
+	if(columns == 0)
+		columns = 1;
+
+	// Draw columns
+	for(int x = 0, i = 0; i &lt; columns; ++i)
+	{
+		int dx = 0;
+		if(i == 0)
+		{
+			dx += item-&gt;get_text_margin();
+
+			CL_Surface *icon = item-&gt;get_icon();
+			if(icon)
+			{
+				icon-&gt;draw(
+					rect.left + x + 1,
+					rect.top + (height - icon-&gt;get_height()) / 2);
+				dx += icon-&gt;get_width();
+			}
+		}
+
+		CL_Component *comp = item-&gt;get_component(i);
+		if(comp)
+		{
+			comp-&gt;set_position(CL_Rect(x + dx + 4, 0, x + dx + 4 + treeview-&gt;get_column_width(i), height));
+			comp-&gt;paint();
+		}
+		else
+		{
+			font-&gt;draw(
+				rect.left + x + dx + 4,
+				rect.top + (height - font_height) / 2,
+				item-&gt;get_text(i));
+		}
+
+		x += treeview-&gt;get_column_width(i);
+		if(i == 0)
+			x -= item-&gt;get_node()-&gt;get_placement_offset();
+	}
+}

Added: trunk/clanlib/GUIStyleSilver/treeview_silver.cpp
===================================================================
--- trunk/clanlib/GUIStyleSilver/treeview_silver.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUIStyleSilver/treeview_silver.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,371 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    Kenneth Gangst&#248;
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Display/font.h&quot;
+#include &quot;API/Display/keys.h&quot;
+#include &quot;API/GUI/scrollbar.h&quot;
+#include &quot;API/GUIStyleSilver/treeview_silver.h&quot;
+#include &quot;API/GUIStyleSilver/stylemanager_silver.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_TreeView_Silver::CL_TreeView_Silver(
+	CL_TreeView *treeview,
+	CL_StyleManager_Silver *style)
+:
+	CL_ComponentStyle(treeview),
+	treeview(treeview),
+	style(style)
+{
+	CL_ResourceManager *resources = style-&gt;get_resources();
+	font = new CL_Font(&quot;TreeView/font&quot;, resources);
+
+	CL_Component *client_area = treeview-&gt;get_client_area();
+	client_area-&gt;set_clipping(true);
+
+	// Create a vertical scrollbar
+	scrollbar = new CL_ScrollBar(false, treeview);
+	visible_scrollbar = true;
+
+	// Create the header component
+	header_area = new CL_Component(treeview);
+
+	// Connect the dots
+	slots.connect(treeview-&gt;sig_paint(), this, &amp;CL_TreeView_Silver::on_paint);
+	slots.connect(header_area-&gt;sig_paint(), this, &amp;CL_TreeView_Silver::on_paint_header);
+	slots.connect(client_area-&gt;sig_paint(), this, &amp;CL_TreeView_Silver::on_paint_client);
+	slots.connect(treeview-&gt;sig_paint_node(), this, &amp;CL_TreeView_Silver::on_paint_node);
+
+	slots.connect(client_area-&gt;sig_mouse_down(), this, &amp;CL_TreeView_Silver::on_mouse_down);
+
+	slots.connect(treeview-&gt;sig_resize(), this, &amp;CL_TreeView_Silver::on_resize);
+	slots.connect(treeview-&gt;sig_item_added(), this, &amp;CL_TreeView_Silver::on_item_changed);
+	slots.connect(treeview-&gt;sig_item_removed(), this, &amp;CL_TreeView_Silver::on_item_changed);
+	slots.connect(treeview-&gt;sig_item_expanded(), this, &amp;CL_TreeView_Silver::on_item_changed);
+	slots.connect(treeview-&gt;sig_item_collapsed(), this, &amp;CL_TreeView_Silver::on_item_changed);
+	slots.connect(treeview-&gt;sig_column_added(), this, &amp;CL_TreeView_Silver::on_column_added);
+	slots.connect(treeview-&gt;sig_column_removed(), this, &amp;CL_TreeView_Silver::on_column_removed);
+	slots.connect(treeview-&gt;sig_clear(), this, &amp;CL_TreeView_Silver::on_clear);
+
+	// Make sure we're arranged properly
+	on_resize(0,0);
+}
+
+CL_TreeView_Silver::~CL_TreeView_Silver()
+{
+	delete header_area;
+	delete scrollbar;
+	delete font;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_TreeView_Silver::on_item_changed(const CL_TreeNode &amp;node)
+{
+	update_scrollbar(true);
+}
+
+void CL_TreeView_Silver::on_column_added(int index)
+{
+}
+
+void CL_TreeView_Silver::on_column_removed(int index)
+{
+}
+                                                               
+void CL_TreeView_Silver::on_clear()
+{
+	update_scrollbar(true);
+}
+
+void CL_TreeView_Silver::on_mouse_down(const CL_InputEvent &amp;key)
+{
+	if(key.id == CL_MOUSE_WHEEL_UP)
+	{
+		scrollbar-&gt;decrease(16);
+		return;
+	}
+	if(key.id == CL_MOUSE_WHEEL_DOWN)
+	{
+		scrollbar-&gt;increase(16);
+		return;
+	}
+}
+
+void CL_TreeView_Silver::on_resize(int old_width, int old_height)
+{
+	int header_height = 20;
+
+	int width = treeview-&gt;get_width();
+	int height = treeview-&gt;get_height();
+
+	// Position the header area
+	header_area-&gt;set_position(CL_Rect(0, 0, width, header_height));
+
+	// Position the client area
+	CL_Component *client_area = treeview-&gt;get_client_area();
+	if(treeview-&gt;is_header_visible())
+	{
+		client_area-&gt;set_position(CL_Rect(1, header_height, width - 1, height - 1));
+		header_area-&gt;show(true);
+	}
+	else
+	{
+		client_area-&gt;set_position(CL_Rect(1, 1, width - 1, height - 1));
+		header_area-&gt;show(false);
+	}
+
+	update_scrollbar(false);
+
+	// Scrollbar was added, shrink other areas
+	if(visible_scrollbar)
+	{
+		client_area-&gt;set_width(client_area-&gt;get_width() - 19);
+		header_area-&gt;set_width(header_area-&gt;get_width() - 19);
+
+		// Position the scrollbar
+		scrollbar-&gt;set_position(CL_Rect(width - 19, 0, width, height));
+	}
+}
+
+void CL_TreeView_Silver::on_paint()
+{
+	// Outline
+	CL_Rect rect = treeview-&gt;get_screen_rect();
+	CL_Display::draw_rect(rect, CL_Color(128, 142, 159));
+}
+
+void CL_TreeView_Silver::on_paint_header()
+{
+	// Header
+	if(treeview-&gt;is_header_visible())
+	{
+		CL_Rect rect = header_area-&gt;get_screen_rect();
+
+		// Header background
+		CL_Display::fill_rect(
+			CL_Rect(
+				rect.left + 1,
+				rect.top + 1,
+				rect.left + rect.get_width() - 1,
+				rect.top + rect.get_height() - 4),
+			CL_Gradient(
+				CL_Color(245, 246, 247), CL_Color(245, 246, 247), CL_Color(235, 238, 241), CL_Color(235, 238, 241)));
+
+		CL_Display::fill_rect(
+			CL_Rect(
+				rect.left + 1,
+				rect.top + rect.get_height() - 4,
+				rect.left + rect.get_width() - 1,
+				rect.top + rect.get_height()),
+			CL_Gradient(
+				CL_Color(235, 238, 241), CL_Color(235, 238, 241), CL_Color(186, 187, 188), CL_Color(186, 187, 188)));
+
+		// Draw columns
+		int x = 0;
+		int columns = treeview-&gt;get_column_count();
+		for(int i = 0; i &lt; columns; ++i)
+		{
+			font-&gt;draw(
+				rect.left + x + 6,
+				rect.top + 4, treeview-&gt;get_column_name(i));
+				
+			x += treeview-&gt;get_column_width(i);
+			
+			CL_Display::draw_line(
+				rect.left + x,
+				rect.top + 1,
+				rect.left + x,
+				rect.top + rect.get_height(),
+				CL_Color(128, 142, 159));
+			CL_Display::draw_line(
+				rect.left + x + 1,
+				rect.top + 1,
+				rect.left + x + 1,
+				rect.top + rect.get_height(),
+				CL_Color::white);
+		}
+	}
+}
+
+void CL_TreeView_Silver::on_paint_client()
+{
+	// Draw white background
+	CL_Rect rect = treeview-&gt;get_client_area()-&gt;get_screen_rect();
+	CL_Display::fill_rect(rect, CL_Color::white);
+
+	// Draw nodes
+	CL_Point point(0, 0);
+	treeview-&gt;draw_nodes(point);
+}
+
+void CL_TreeView_Silver::on_paint_node(CL_TreeNode *node, CL_Point &amp;point)
+{
+	CL_Component *component = node-&gt;get_component();
+	CL_Component *client_area = treeview-&gt;get_client_area();
+
+	int height = component-&gt;get_height();
+	int mid = (height) / 2;
+
+	// Should we draw decoration ?
+	bool draw_decoration = true;
+	if(node-&gt;is_root())
+		draw_decoration = node-&gt;get_treeview()-&gt;is_root_decoration_visible();
+
+	// Find what y offset we're drawing at
+	point.y -= scrollbar-&gt;get_value();
+
+	// Find what x offset we're drawing at
+	int x_offset = 0;
+	if(draw_decoration)
+		x_offset = 12;
+
+	int screen_x = client_area-&gt;get_screen_x();
+	int screen_y = client_area-&gt;get_screen_y();
+	
+	// Is the node visible?
+	if (point.y + height &gt;= 0 &amp;&amp; point.y &lt;= client_area-&gt;get_height())
+	{
+		if(draw_decoration)
+		{
+			// Draw collapse box
+			if(node-&gt;has_children())
+			{
+				CL_Display::draw_rect(
+					CL_Rect(
+						screen_x + point.x,
+						screen_y + point.y + mid - 5,
+						screen_x + point.x + 9,
+						screen_y + point.y + mid + 4),
+					CL_Color(128, 142, 159));
+
+				CL_Display::fill_rect(
+					CL_Rect(
+						screen_x + point.x + 1,
+						screen_y + point.y + mid - 4,
+						screen_x + point.x + 8,
+						screen_y + point.y + mid + 3),
+					CL_Gradient(
+						CL_Color::white,
+						CL_Color::white,
+						CL_Color(230, 235, 240),
+						CL_Color(230, 235, 240)));
+
+				CL_Display::fill_rect(
+					CL_Rect(
+						screen_x + point.x + 2,
+						screen_y + point.y + mid - 3,
+						screen_x + point.x + 7,
+						screen_y + point.y + mid + 2),
+					CL_Gradient(
+						CL_Color(217, 222, 227),
+						CL_Color(217, 222, 227),
+						CL_Color::white,
+						CL_Color::white));
+
+				// Horizontal line
+				CL_Display::draw_line(
+					screen_x + point.x + 2.0f,
+					screen_y + point.y + mid - 1.0f,
+					screen_x + point.x + 7.0f,
+					screen_y + point.y + mid - 1,
+					CL_Color::black);
+
+				// Vertical line
+				if(node-&gt;is_collapsed())
+					CL_Display::draw_line(
+						screen_x + point.x + 4.0f,
+						screen_y + point.y + mid - 3.0f,
+						screen_x + point.x + 4.0f,
+						screen_y + point.y + mid + 2.0f,
+						CL_Color::black);
+			}
+		}
+
+		// Size and place child component
+		component-&gt;set_position(point.x + x_offset, point.y);
+		node-&gt;set_placement_offset(point.x + x_offset);
+
+		// Draw component
+		component-&gt;show(true);
+		component-&gt;sig_begin_paint();
+		component-&gt;sig_paint()();
+		component-&gt;sig_end_paint();
+	}
+	else
+	{
+		component-&gt;show(false);
+	}
+
+	// Move down for next component
+	point.y += scrollbar-&gt;get_value();
+	point.y += height;
+
+	// If it has any children, adjust the x-position for the children
+	if(node-&gt;is_collapsed() == false)
+		point.x += 3 + x_offset;
+}
+
+void CL_TreeView_Silver::update_scrollbar(bool resize)
+{
+	int max_height = treeview-&gt;get_items_height();
+	int component_height = treeview-&gt;get_client_area()-&gt;get_height();
+
+	if(max_height &gt; component_height)
+	{
+		if(visible_scrollbar == false)
+		{
+			visible_scrollbar = true;
+			treeview-&gt;add_child(scrollbar, false);
+
+			if(resize)
+				on_resize(0, 0);
+		}
+
+		scrollbar-&gt;set_max_value(max_height - component_height + 1);
+		scrollbar-&gt;set_value(0);
+	}
+	else
+	{
+		if(visible_scrollbar)
+		{
+			visible_scrollbar = false;
+			scrollbar-&gt;set_range(0, 0);
+			scrollbar-&gt;set_value(0);
+			treeview-&gt;remove_child(scrollbar);
+
+			if(resize)
+				on_resize(0, 0);
+		}
+	}
+}

Added: trunk/clanlib/GUIStyleSilver/window_silver.cpp
===================================================================
--- trunk/clanlib/GUIStyleSilver/window_silver.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/GUIStyleSilver/window_silver.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,308 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    Kenneth Gangst&#248;
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;API/Display/display.h&quot;
+#include &quot;API/Display/font.h&quot;
+#include &quot;API/Display/surface.h&quot;
+#include &quot;API/GUIStyleSilver/stylemanager_silver.h&quot;
+#include &quot;API/GUIStyleSilver/window_silver.h&quot;
+#include &quot;API/GUIStyleSilver/button_silver.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// Construction:
+
+CL_Window_Silver::CL_Window_Silver(
+	CL_Window *window,
+	CL_StyleManager_Silver *style) 
+:
+	CL_ComponentStyle(window),
+	window(window),
+	button_close(0),
+	button_maximize(0),
+	button_minimize(0),
+	button_help(0),
+	style(style),
+	titlebar_height(22)
+{
+	CL_ResourceManager *resources = style-&gt;get_resources();
+	
+	font = new CL_Font(&quot;Window/font&quot;, resources);
+	font_disabled = new CL_Font(&quot;Window/font_disabled&quot;, resources);
+	
+	// Make the window movable by dragging titlebar
+	move_handler = new CL_ComponentMoveHandler(window);
+
+	// Make the window resizable by dragging corner
+	resize_handler = new CL_ComponentResizeHandler(window);
+
+	CL_Window::TitlebarButtons buttons = window-&gt;get_titlebar_buttons_enum();
+
+	// Create a close button on the titlebar
+	if(buttons &amp; CL_Window::close_button)
+	{
+		button_close = add_titlebar_button(&quot;Window/surface_close&quot;, &quot;Window/surface_close&quot;, &quot;Window/surface_close_disabled&quot;, resources);
+		slots.connect(button_close-&gt;sig_clicked(), this, &amp;CL_Window_Silver::on_close_button_clicked);
+	}
+
+	// Create a maximize button on the titlebar
+	if(buttons &amp; CL_Window::maximize_button)
+	{
+		button_maximize = add_titlebar_button(&quot;Window/surface_maximize&quot;, &quot;Window/surface_maximize&quot;, &quot;Window/surface_maximize_disabled&quot;, resources);
+		slots.connect(button_maximize-&gt;sig_clicked(), this, &amp;CL_Window_Silver::on_maximize_button_clicked);
+	}
+
+	// Create a minimize button on the titlebar
+	if(buttons &amp; CL_Window::minimize_button)
+	{
+		button_minimize = add_titlebar_button(&quot;Window/surface_minimize&quot;, &quot;Window/surface_minimize&quot;, &quot;Window/surface_minimize_disabled&quot;, resources);
+		slots.connect(button_minimize-&gt;sig_clicked(), this, &amp;CL_Window_Silver::on_minimize_button_clicked);
+	}
+
+	// Create a help button on the titlebar
+	if(buttons &amp; CL_Window::help_button)
+	{
+		button_help = add_titlebar_button(&quot;Window/surface_help&quot;, &quot;Window/surface_help&quot;, &quot;Window/surface_help_disabled&quot;, resources);
+		slots.connect(button_help-&gt;sig_clicked(), this, &amp;CL_Window_Silver::on_help_button_clicked);
+	}
+
+	slots.connect(window-&gt;sig_paint(), this, &amp;CL_Window_Silver::on_paint);
+	slots.connect(window-&gt;sig_resize(), this, &amp;CL_Window_Silver::on_resize);
+
+	on_resize(0,0);
+}
+
+CL_Window_Silver::~CL_Window_Silver()
+{
+	delete font;
+	delete font_disabled;
+	delete resize_handler;
+	delete move_handler;
+
+	if(button_close)
+		delete button_close;
+	if(button_maximize)
+		delete button_maximize;
+	if(button_minimize)
+		delete button_minimize;
+	if(button_help)
+		delete button_help;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Callbacks:
+
+void CL_Window_Silver::on_paint()
+{
+	CL_Rectf rect = window-&gt;get_screen_rect();
+
+	// Titlebar
+	CL_Display::fill_rect(
+		CL_Rectf(rect.left + 2, rect.top + 4, rect.right - 2, rect.top + titlebar_height - 3),
+		CL_Color(206, 217, 228));
+
+	CL_Display::draw_line(
+		rect.left + 2,
+		rect.top + 2,
+		rect.right - 2,
+		rect.top + 2,
+		CL_Color(251, 253, 255));
+
+	CL_Display::draw_line(
+		rect.left + 2,
+		rect.top + 3,
+		rect.right - 2,
+		rect.top + 3,
+		CL_Color(236, 238, 240));
+
+	CL_Display::draw_line(
+		rect.left + 2,
+		rect.top + titlebar_height - 3,
+		rect.right - 2,
+		rect.top + titlebar_height - 3,
+		CL_Color(180, 202, 224));
+
+	CL_Display::draw_line(
+		rect.left + 2,
+		rect.top + titlebar_height - 2,
+		rect.right - 2,
+		rect.top + titlebar_height - 2,
+		CL_Color(144, 180, 218));
+
+	CL_Display::draw_line(
+		rect.left + 2,
+		rect.top + titlebar_height - 1,
+		rect.right - 2,
+		rect.top + titlebar_height - 1,
+		CL_Color(128, 142, 159));
+
+	// Outer window frame
+	CL_Display::draw_rect(
+		rect,
+		CL_Color(128, 142, 159));
+
+	// Inner window frame
+	CL_Display::draw_rect(
+		CL_Rectf(rect.left + 1, rect.top + 1, rect.right - 1, rect.bottom - 1),
+		CL_Color(161, 172, 185));
+
+	// Client area
+	CL_Display::fill_rect(
+		CL_Rectf(rect.left + 2, rect.top + titlebar_height, rect.right - 2, rect.bottom - 2),
+		CL_Gradient(
+			CL_Color(255, 255, 255, 235),
+			CL_Color(255, 255, 255, 235),
+			CL_Color(224, 228, 232, 235),
+			CL_Color(224, 228, 232, 235)));
+		
+	int y = (titlebar_height + 2 - font-&gt;get_height()) / 2;
+
+	if(window-&gt;is_enabled() == false)
+		font_disabled-&gt;draw(static_cast&lt;int&gt;(rect.left + 7),
+								  static_cast&lt;int&gt;(rect.top + y), window-&gt;get_title());
+	else
+	{
+		font-&gt;draw(static_cast&lt;int&gt;(rect.left + 7), 
+					  static_cast&lt;int&gt;(rect.top + y), window-&gt;get_title());
+		font-&gt;draw(static_cast&lt;int&gt;(rect.left + 8),
+					  static_cast&lt;int&gt;(rect.top + y), window-&gt;get_title());
+	}
+
+/*	CL_Rect rect = window-&gt;get_screen_rect();
+
+	int offx = window-&gt;get_screen_x();
+	int offy = window-&gt;get_screen_y();
+
+	int w_width = rect.get_width();
+	int w_height = rect.get_height();
+
+	// Vertical shadows
+	CL_Display::draw_line(offx+w_width + 0, offy + 5, offx+w_width + 0, offy+w_height + 0, CL_Color(0, 0, 0, 64));
+	CL_Display::draw_line(offx+w_width + 1, offy + 5, offx+w_width + 1, offy+w_height + 1, CL_Color(0, 0, 0, 51));
+	CL_Display::draw_line(offx+w_width + 2, offy + 5, offx+w_width + 2, offy+w_height + 2, CL_Color(0, 0, 0, 38));
+	CL_Display::draw_line(offx+w_width + 3, offy + 5, offx+w_width + 3, offy+w_height + 3, CL_Color(0, 0, 0, 25));
+	CL_Display::draw_line(offx+w_width + 4, offy + 5, offx+w_width + 4, offy+w_height + 4, CL_Color(0, 0, 0, 13));
+
+	// Horizontal shadows
+	CL_Display::draw_line(offx + 5, offy+w_height + 0, offx+w_width + 1, offy+w_height + 0, CL_Color(0, 0, 0, 64));
+	CL_Display::draw_line(offx + 5, offy+w_height + 1, offx+w_width + 2, offy+w_height + 1, CL_Color(0, 0, 0, 51));
+	CL_Display::draw_line(offx + 5, offy+w_height + 2, offx+w_width + 3, offy+w_height + 2, CL_Color(0, 0, 0, 38));
+	CL_Display::draw_line(offx + 5, offy+w_height + 3, offx+w_width + 4, offy+w_height + 3, CL_Color(0, 0, 0, 25));
+	CL_Display::draw_line(offx + 5, offy+w_height + 4, offx+w_width + 5, offy+w_height + 4, CL_Color(0, 0, 0, 13));
+*/
+}
+
+void CL_Window_Silver::on_resize(int old_width, int old_height)
+{
+	CL_Rect client_rect(3, 24, window-&gt;get_width() - 3, window-&gt;get_height() - 3);
+	window-&gt;get_client_area()-&gt;set_position(client_rect);
+
+	int xpos = window-&gt;get_width() - 20;
+
+	if(button_close)
+	{
+		CL_Rect close_rect(xpos, 3, xpos + 17, 20);
+		button_close-&gt;set_position(close_rect);
+		xpos -= 18;
+	}
+
+	if(button_maximize)
+	{
+		CL_Rect close_rect(xpos, 3, xpos + 17, 20);
+		button_maximize-&gt;set_position(close_rect);
+		xpos -= 18;
+	}
+
+	if(button_minimize)
+	{
+		CL_Rect close_rect(xpos, 3, xpos + 17, 20);
+		button_minimize-&gt;set_position(close_rect);
+		xpos -= 18;
+	}
+
+	if(button_help)
+	{
+		CL_Rect close_rect(xpos, 3, xpos + 17, 20);
+		button_help-&gt;set_position(close_rect);
+	}
+
+	CL_Rect move_rect(0, 0, window-&gt;get_width(), titlebar_height);
+	move_handler-&gt;set_position(move_rect);
+	
+	CL_Rect resize_rect(window-&gt;get_width() - 3, window-&gt;get_height() - 3, window-&gt;get_width(), window-&gt;get_height());
+	resize_handler-&gt;set_position(resize_rect);
+}
+
+void CL_Window_Silver::on_close_button_clicked()
+{
+	window-&gt;sig_close_button_clicked()();
+}
+
+void CL_Window_Silver::on_minimize_button_clicked()
+{
+	window-&gt;sig_minimize_button_clicked()();
+}
+
+void CL_Window_Silver::on_maximize_button_clicked()
+{
+	window-&gt;sig_maximize_button_clicked()();
+}
+
+void CL_Window_Silver::on_help_button_clicked()
+{
+	window-&gt;sig_help_button_clicked()();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Implementation:
+
+CL_Button *CL_Window_Silver::add_titlebar_button(
+	const std::string &amp;resource_normal, 
+	const std::string &amp;resource_down, 
+	const std::string &amp;resource_disabled, 
+	CL_ResourceManager *resources)
+{
+	CL_Button *button = new CL_Button(window, style);
+
+	CL_Button_Silver *button_style = (CL_Button_Silver *)button-&gt;get_style();
+
+	CL_Surface *surface_button = new CL_Surface(resource_normal, resources);
+	CL_Surface *surface_button_down = new CL_Surface(resource_down, resources);
+	CL_Surface *surface_button_disabled = new CL_Surface(resource_disabled, resources);
+
+	surface_button_down-&gt;set_alignment(origin_top_left, 1, -1);
+
+	button_style-&gt;set_surface_up(surface_button, true);
+	button_style-&gt;set_surface_down(surface_button_down, true);
+	button_style-&gt;set_surface_disabled(surface_button_disabled, true);
+	
+	button_style-&gt;set_surface_draw_only(false);
+
+	return button;
+}

Added: trunk/clanlib/Makefile.am
===================================================================
--- trunk/clanlib/Makefile.am	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Makefile.am	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,17 @@
+SUBDIRS = API @ClanLib_Modules@
+
+DIST_SUBDIRS = \
+  API            \
+  Application    \
+  Core           \
+  Display        \
+  GL             \
+  GUI            \
+  GUIStyleSilver \
+  MikMod         \
+  Network        \
+  Sound          \
+  SDL            \
+  Vorbis
+
+# EOF #

Added: trunk/clanlib/README
===================================================================
--- trunk/clanlib/README	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/README	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,3 @@
+This is a cutdown copy of ClanLib-0.8 from 05.07.2006,
+everything not used by flexlay got removed, see doc/
+for copyright info and stuff.

Added: trunk/clanlib/SConstruct
===================================================================
--- trunk/clanlib/SConstruct	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/SConstruct	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,382 @@
+# -*- python -*-
+
+env = Environment(CPPPATH=['API', '.'])
+    
+#    CXXFLAGS  = env['CXXFLAGS'] + clanLib_env['CCFLAGS'],
+#    LINKFLAGS = clanLib_env['LINKFLAGS'],
+#    LIBPATH=['$USER_LIBPATH'] + clanLib_env['LIBPATH'],
+#    LIBS = clanLib_env['LIBS']
+
+clanApp = env.StaticLibrary(
+    target = 'libclanApp.a',
+    source = [
+    'Application/Unix/clanapp.cpp'
+    ])
+
+clanCore = env.StaticLibrary(
+    target = 'libclanCore.a',
+    source = [
+    'Core/core_iostream.cpp',
+    'Core/IOData/Generic/datafile_inputprovider.cpp',
+    'Core/IOData/Generic/directory.cpp',
+    'Core/IOData/Generic/directory_scanner.cpp',
+    'Core/IOData/Generic/endianess.cpp',
+    'Core/IOData/Generic/inputsource.cpp',
+    'Core/IOData/Generic/inputsource_file.cpp',
+    'Core/IOData/Generic/inputsource_memory_generic.cpp',
+    'Core/IOData/Generic/inputsource_provider_file.cpp',
+    'Core/IOData/Generic/inputsource_zipped.cpp',
+    'Core/IOData/Generic/outputsource.cpp',
+    'Core/IOData/Generic/outputsource_file.cpp',
+    'Core/IOData/Generic/outputsource_memory_generic.cpp',
+    'Core/IOData/Generic/outputsource_zipped.cpp',
+    'Core/IOData/inputsource_memory.cpp',
+    'Core/IOData/inputsource_zip_fileentry.cpp',
+    'Core/IOData/outputsource_memory.cpp',
+    'Core/IOData/zip_64_end_of_central_directory_locator.cpp',
+    'Core/IOData/zip_64_end_of_central_directory_record.cpp',
+    'Core/IOData/zip_archive.cpp',
+    'Core/IOData/zip_digital_signature.cpp',
+    'Core/IOData/zip_end_of_central_directory_record.cpp',
+    'Core/IOData/zip_file_entry.cpp',
+    'Core/IOData/zip_file_header.cpp',
+    'Core/IOData/zip_local_file_descriptor.cpp',
+    'Core/IOData/zip_local_file_header.cpp',
+    'Core/Math/matrix4x4.cpp',
+    'Core/Math/cl_vector.cpp',
+    'Core/Math/line_math.cpp',
+    'Core/Math/triangle_math.cpp',
+    'Core/Math/pointset_math.cpp',
+    'Core/Math/origin.cpp',
+    'Core/Math/rect.cpp',
+    'Core/Math/quad.cpp',
+    'Core/Math/vector2.cpp',
+    'Core/Math/number_pool.cpp',
+    'Core/Math/delauney_triangulator.cpp',
+    'Core/Math/delauney_triangulator_generic.cpp',
+    'Core/Math/outline_triangulator.cpp',
+    'Core/Math/outline_triangulator_generic.cpp',
+    'Core/Resources/resource.cpp',
+    'Core/Resources/resource_generic.cpp',
+    'Core/Resources/resource_manager.cpp',
+    'Core/Resources/resource_manager_generic.cpp',
+    'Core/Resources/resourcedata.cpp',
+    'Core/Resources/resourcetype_boolean.cpp',
+    'Core/Resources/resourcetype_integer.cpp',
+    'Core/Resources/resourcetype_float.cpp',
+    'Core/Resources/resourcetype_raw.cpp',
+    'Core/Resources/resourcetype_string.cpp',
+    'Core/System/Generic/cl_assert.cpp',
+    'Core/System/Generic/clanstring.cpp',
+    'Core/System/Generic/command_line.cpp',
+    'Core/System/Generic/command_line_generic.cpp',
+    'Core/System/Generic/console_window.cpp',
+    'Core/System/Generic/console_window_generic.cpp',
+    'Core/System/Generic/detect_3dnow.cpp',
+    'Core/System/Generic/detect_mmx.cpp',
+    'Core/System/Generic/error.cpp',
+    'Core/System/Generic/event_listener.cpp',
+    'Core/System/Generic/event_listener_generic.cpp',
+    'Core/System/Generic/event_trigger.cpp',
+    'Core/System/Generic/event_trigger_generic.cpp',
+    'Core/System/Generic/keep_alive_generic.cpp',
+    'Core/System/Generic/setupcore.cpp',
+    'Core/System/Generic/timer_generic.cpp',
+    'Core/System/Generic/log.cpp',
+    'Core/System/Generic/call_stack.cpp',
+    'Core/System/Generic/crash_reporter.cpp',
+    'Core/XML/dom_attr.cpp',
+    'Core/XML/dom_cdata_section.cpp',
+    'Core/XML/dom_character_data.cpp',
+    'Core/XML/dom_comment.cpp',
+    'Core/XML/dom_document.cpp',
+    'Core/XML/dom_document_fragment.cpp',
+    'Core/XML/dom_document_generic.cpp',
+    'Core/XML/dom_document_type.cpp',
+    'Core/XML/dom_element.cpp',
+    'Core/XML/dom_entity.cpp',
+    'Core/XML/dom_entity_reference.cpp',
+    'Core/XML/dom_exception.cpp',
+    'Core/XML/dom_implementation.cpp',
+    'Core/XML/dom_named_node_map.cpp',
+    'Core/XML/dom_node.cpp',
+    'Core/XML/dom_node_list.cpp',
+    'Core/XML/dom_notation.cpp',
+    'Core/XML/dom_processing_instruction.cpp',
+    'Core/XML/dom_text.cpp',
+    'Core/XML/xml_tokenizer.cpp',
+    'Core/XML/xml_token_load.cpp',
+    'Core/XML/xml_token_save.cpp',
+    'Core/XML/xml_writer.cpp',
+    'Core/precomp.cpp',
+    'Core/System/Unix/event_listener_unix.cpp',
+    'Core/System/Unix/event_trigger_unix.cpp',
+    'Core/System/Unix/init_linux.cpp',
+    'Core/System/Unix/mutex_pthread.cpp',
+    'Core/System/Unix/thread_pthread.cpp',
+    'Core/System/Unix/cl_library.cpp',
+    'Core/System/Unix/crash_reporter_unix.cpp',
+    'Core/IOData/Unix/directory_scanner_unix.cpp'
+    ])
+
+clanDisplay = env.StaticLibrary(
+    target = 'libclanDisplay.a',
+    source = [
+    'Display/display_target.cpp',
+    'Display/display_precomp.h',
+    'Display/surface.cpp',
+    'Display/canvas.cpp',
+    'Display/canvas_generic.h',
+    'Display/color.cpp',
+    'Display/display_iostream.cpp',
+    'Display/display_mode.cpp',
+    'Display/display_window.cpp',
+    'Display/sprite_packer.cpp',
+    'Display/surface_generic.cpp',
+    'Display/setupdisplay.cpp',
+    'Display/input_device_generic.h',
+    'Display/sprite.cpp',
+    'Display/graphic_context.cpp',
+    'Display/graphic_context_generic.cpp',
+    'Display/pixel_buffer_memory.h',
+    'Display/display.cpp',
+    'Display/display_window_description.cpp',
+    'Display/font.cpp',
+    'Display/font_target_sprite.cpp',
+    'Display/keyboard.cpp',
+    'Display/joystick.cpp',
+    'Display/mouse.cpp',
+    'Display/sprite_description.cpp',
+    'Display/input_buffer.cpp',
+    'Display/input_buffer_generic.h',
+    'Display/input_button.cpp',
+    'Display/input_button_generic.cpp',
+    'Display/input_device_generic.cpp',
+    'Display/input_context_generic.cpp',
+    'Display/input_event.cpp',
+    'Display/surface_target.cpp',
+    'Display/display_precomp.cpp',
+    'Display/input_device.cpp',
+    'Display/key_binding.cpp',
+    'Display/resourcedata_collisionoutline.cpp',
+    'Display/resourcedata_font.cpp',
+    'Display/resourcedata_text_styler.cpp',
+    'Display/Providers/jpeg_provider.cpp',
+    'Display/Providers/jpeg_provider_generic.cpp',
+    'Display/Providers/jpeg_provider_generic.h',
+    'Display/Providers/pcx_provider.cpp',
+    'Display/Providers/pcx_provider_generic.cpp',
+    'Display/Providers/pcx_provider_generic.h',
+    'Display/Providers/png_provider.cpp',
+    'Display/Providers/png_provider_generic.h',
+    'Display/Providers/png_provider_generic.cpp',
+    'Display/Providers/provider_factory.cpp',
+    'Display/Providers/provider_type.cpp',
+    'Display/Providers/targa_provider.cpp',
+    'Display/Providers/targa_provider_generic.cpp',
+    'Display/Providers/targa_provider_generic.h',
+    'Display/input_context_generic.h',
+    'Display/sprite_packer_generic.cpp',
+    'Display/sprite_generic.cpp',
+    'Display/pixel_format.cpp',
+    'Display/pixel_buffer.cpp',
+    'Display/pixel_buffer_generic.cpp',
+    'Display/pixel_buffer_generic.h',
+    'Display/pixel_buffer_memory.cpp',
+    'Display/display_window_generic.h',
+    'Display/sprite_generic.h',
+    'Display/font_generic.h',
+    'Display/font_target_sprite.h',
+    'Display/surface_generic.h',
+    'Display/sprite_packer_generic.h',
+    'Display/font_generic.cpp',
+    'Display/sprite_description_generic.h',
+    'Display/resourcedata_surface.cpp',
+    'Display/resourcedata_sprite.cpp',
+    'Display/resourcedata_sprite_description.cpp',
+    'Display/surface_target.h',
+    'Display/input_context.cpp',
+    'Display/display_window_generic.cpp',
+    'Display/glyph_buffer.cpp',
+    'Display/text_styler.cpp',
+    'Display/frameratecounter.cpp',
+    'Display/frameratecounter_generic.h',
+    'Display/Collision/collision_outline.cpp',
+    'Display/Collision/collision_outline_generic.cpp',
+    'Display/Collision/collision_outline_generic.h',
+    'Display/Collision/outline_math.cpp',
+    'Display/Collision/outline_provider_bitmap.cpp',
+    'Display/Collision/outline_provider_bitmap_generic.cpp',
+    'Display/Collision/outline_provider_bitmap_generic.h',
+    'Display/Collision/outline_provider_file.cpp',
+    'Display/Collision/outline_provider_file_generic.cpp',
+    ])
+
+# -L/usr/X11R6/lib/ -lX11 -lXmu -lGL -lGLU -lpng -ljpeg -lXxf86vm @X_LIBS@
+
+clanGL = env.StaticLibrary(
+    target = 'libclanGL.a',
+    source = [
+    'GL/graphic_context_opengl.cpp',
+    'GL/graphic_context_opengl.h',
+    'GL/gl_state_checker.cpp',
+    'GL/pixel_buffer_opengl_texture.cpp',
+    'GL/pixel_buffer_opengl_texture.h',
+    'GL/opengl.cpp',
+    'GL/opengl_target.cpp',
+    'GL/opengl_target.h',
+    'GL/opengl_window.cpp',
+    'GL/opengl_window_description.cpp',
+    'GL/opengl_window_description_generic.h',
+    'GL/setupgl.cpp',
+    'GL/opengl_surface.cpp',
+    'GL/surface_target_opengl.cpp',
+    'GL/surface_target_opengl.h',
+    'GL/canvas_opengl.cpp',
+    'GL/canvas_opengl.h',
+    'GL/opengl_state.cpp',
+    'GL/opengl_state_generic.cpp',
+    'GL/opengl_state_generic.h',
+    'GL/opengl_state_data.cpp',
+    'GL/viewpoint.cpp',
+    'GL/light_source.cpp',
+    'GL/shader_object.cpp',
+    'GL/program_object.cpp',
+    'GL/program_attribute.cpp',
+    'GL/program_uniform.cpp',
+    'GL/texture.cpp',
+    'GL/GLX/display_window_opengl.h',
+    'GL/GLX/display_window_opengl.cpp',
+    'GL/GLX/input_device_linuxjoystick.cpp',
+    'GL/GLX/input_device_linuxjoystick.h',
+    'GL/GLX/input_device_linuxevent.cpp',
+    'GL/GLX/input_device_linuxevent.h',
+    'GL/GLX/input_device_linuxusbmouse.cpp',
+    'GL/GLX/input_device_linuxusbmouse.h',
+    'GL/GLX/display_window_opengl.h',
+    'GL/GLX/input_device_x11mouse.cpp',
+    'GL/GLX/input_device_x11mouse.h',
+    'GL/GLX/input_device_x11keyboard.cpp',
+    'GL/GLX/input_device_x11keyboard.h',
+    'GL/GLX/input_device_xinput.cpp',
+    'GL/GLX/input_device_xinput.h'
+    ])
+
+clanGUI = env.StaticLibrary(
+    target = 'libclanGUI.a',
+    source = [
+    'GUI/frame_generic.cpp',
+    'GUI/treeview_generic.h',
+    'GUI/component_manager.cpp',
+    'GUI/frame.cpp',
+    'GUI/image_generic.h',
+    'GUI/button_generic.h',
+    'GUI/listbox_generic.h',
+    'GUI/radiogroup.cpp',
+    'GUI/progressbar_generic.cpp',
+    'GUI/component_manager_generic.h',
+    'GUI/radiogroup_generic.h',
+    'GUI/gui_manager.cpp',
+    'GUI/component_generic.h',
+    'GUI/stylemanager.cpp',
+    'GUI/scrollbar_generic.cpp',
+    'GUI/inputbox_generic.cpp',
+    'GUI/inputdialog.cpp',
+    'GUI/inputdialog_generic.cpp',
+    'GUI/label.cpp',
+    'GUI/precomp.h',
+    'GUI/gui_manager_generic.h',
+    'GUI/scrollbar_generic.h',
+    'GUI/listbox.cpp',
+    'GUI/inputbox.cpp',
+    'GUI/image_generic.cpp',
+    'GUI/component_resize_handler.cpp',
+    'GUI/treenode_generic.cpp',
+    'GUI/filedialog_generic.cpp',
+    'GUI/inputbox_generic.h',
+    'GUI/button.cpp',
+    'GUI/component_manager_generic.cpp',
+    'GUI/progressbar.cpp',
+    'GUI/component.cpp',
+    'GUI/component_type.cpp',
+    'GUI/component_type_generic.h',
+    'GUI/layout.cpp',
+    'GUI/layout_generic.cpp',
+    'GUI/layout_generic.h',
+    'GUI/layout_item.cpp',
+    'GUI/layout_item.h',
+    'GUI/gui_manager_generic.cpp',
+    'GUI/treenode_generic.h',
+    'GUI/image.cpp',
+    'GUI/button_generic.cpp',
+    'GUI/default_component_types.h',
+    'GUI/checkbox.cpp',
+    'GUI/component_generic.cpp',
+    'GUI/radiobutton.cpp',
+    'GUI/messagebox_generic.cpp',
+    'GUI/treeitem.cpp',
+    'GUI/label_generic.cpp',
+    'GUI/listbox_generic.cpp',
+    'GUI/setupgui.cpp',
+    'GUI/progressbar_generic.h',
+    'GUI/messagebox.cpp',
+    'GUI/scrollbar.cpp',
+    'GUI/frame_generic.h',
+    'GUI/radiogroup_generic.cpp',
+    'GUI/label_generic.h',
+    'GUI/component_move_handler.cpp',
+    'GUI/treenode.cpp',
+    'GUI/window.cpp',
+    'GUI/window_generic.cpp',
+    'GUI/treeview.cpp',
+    'GUI/filedialog_generic.h',
+    'GUI/treeitem_generic.cpp',
+    'GUI/messagebox_generic.h',
+    'GUI/treeitem_generic.h',
+    'GUI/treeview_generic.cpp',
+    'GUI/precomp.cpp',
+    'GUI/filedialog.cpp',
+    'GUI/window_generic.h',
+    'GUI/menu_node_generic.h',
+    'GUI/menu.cpp',
+    'GUI/menu_node.cpp',
+    'GUI/menu_node_generic.cpp',
+    'GUI/menu_generic.h',
+    'GUI/menu_generic.cpp',
+    'GUI/menu_item.cpp',
+    'GUI/menu_item_generic.cpp',
+    'GUI/deck.cpp',
+    'GUI/deck_generic.h',
+    'GUI/deck_generic.cpp'
+    ])
+
+clanGUIStyleSilver = env.StaticLibrary(
+    target = 'libclanGUIStyleSilver.a',
+    source = [
+    'GUIStyleSilver/button_silver.cpp',
+    'GUIStyleSilver/label_silver.cpp',
+    'GUIStyleSilver/scrollbar_silver.cpp',
+    'GUIStyleSilver/checkbox_silver.cpp',
+    'GUIStyleSilver/listbox_silver.cpp',
+    'GUIStyleSilver/stylemanager_silver.cpp',
+    'GUIStyleSilver/frame_silver.cpp',
+    'GUIStyleSilver/image_silver.cpp',
+    'GUIStyleSilver/progressbar_silver.cpp',
+    'GUIStyleSilver/inputbox_silver.cpp',
+    'GUIStyleSilver/radiobutton_silver.cpp',
+    'GUIStyleSilver/window_silver.cpp',
+    'GUIStyleSilver/menu_silver.cpp',
+    'GUIStyleSilver/menu_node_silver.cpp',
+    'GUIStyleSilver/menu_item_silver.cpp',
+    'GUIStyleSilver/treeitem_silver.cpp',
+    'GUIStyleSilver/treeview_silver.cpp',
+    ])
+
+clanSignals = env.StaticLibrary(
+    target = 'libclanSignals.a',
+    source = [
+    'Signals/slot.cpp',
+    'Signals/slot_generic.cpp'
+    ])
+
+# EOF #

Added: trunk/clanlib/Signals/Makefile.am
===================================================================
--- trunk/clanlib/Signals/Makefile.am	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Signals/Makefile.am	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,9 @@
+lib_LTLIBRARIES = libclanSignals.la
+
+libclanSignals_la_SOURCES = slot.cpp slot_generic.cpp
+
+libclanSignals_la_LDFLAGS =  \
+  -release $(LT_RELEASE) \
+  -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE)
+
+# EOF #
\ No newline at end of file

Added: trunk/clanlib/Signals/slot.cpp
===================================================================
--- trunk/clanlib/Signals/slot.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Signals/slot.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,91 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;API/Signals/slot.h&quot;
+#include &quot;API/Signals/slot_generic.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Slot construction:
+
+CL_Slot::CL_Slot() : impl(0)
+{
+}
+
+CL_Slot::CL_Slot(const CL_Slot &amp;copy) : impl(copy.impl)
+{
+	if (impl != 0) impl-&gt;add_slot_ref();
+}
+
+CL_Slot::~CL_Slot()
+{
+	if (impl != 0) impl-&gt;release_slot_ref();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Slot attributes:
+
+int CL_Slot::get_slot_ref() const
+{
+	if (impl) return impl-&gt;get_slot_ref();
+	else return 0;
+}
+
+int CL_Slot::get_signal_ref() const
+{
+	if (impl) return impl-&gt;get_signal_ref();
+	else return 0;
+}
+
+bool CL_Slot::is_persistent() const
+{
+	return impl-&gt;is_persistent();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Slot operations:
+
+void CL_Slot::operator =(const CL_Slot &amp;copy)
+{
+	if (impl) impl-&gt;release_slot_ref();
+	impl = copy.impl;
+	if (impl) impl-&gt;add_slot_ref();
+}
+
+void CL_Slot::set_persistent(bool flag)
+{
+	if (impl) impl-&gt;set_persistent(flag);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Slot implementation:
+
+CL_Slot::CL_Slot(CL_Slot_Generic *impl) : impl(impl)
+{
+	if (impl != 0) impl-&gt;add_slot_ref();
+}

Added: trunk/clanlib/Signals/slot_generic.cpp
===================================================================
--- trunk/clanlib/Signals/slot_generic.cpp	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/Signals/slot_generic.cpp	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,121 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include &quot;API/Signals/slot_generic.h&quot;
+#include &quot;API/Signals/slot.h&quot;
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Slot_Generic construction:
+
+CL_Slot_Generic::CL_Slot_Generic() : persistent(false), slot_ref_count(0), signal_ref_count(0)
+{
+}
+
+CL_Slot_Generic::~CL_Slot_Generic()
+{
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Slot_Generic attributes:
+
+int CL_Slot_Generic::get_slot_ref() const
+{
+	return slot_ref_count;
+}
+
+int CL_Slot_Generic::get_signal_ref() const
+{
+	return signal_ref_count;
+}
+
+bool CL_Slot_Generic::is_persistent() const
+{
+	return persistent;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// CL_Slot_Generic operations:
+
+void CL_Slot_Generic::add_slot_ref()
+{
+	slot_ref_count++;
+}
+
+void CL_Slot_Generic::release_slot_ref()
+{
+	slot_ref_count--;
+	check_delete();
+}
+
+void CL_Slot_Generic::add_signal_ref(CL_Signal *signal)
+{
+	connected_signals.push_back(signal);
+	signal_ref_count++;
+}
+
+void CL_Slot_Generic::release_signal_ref(CL_Signal *signal)
+{
+	connected_signals.remove(signal);
+	signal_ref_count--;
+	check_delete();
+}
+
+void CL_Slot_Generic::set_persistent(bool flag)
+{
+	persistent = flag;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//! Implementation:
+
+void CL_Slot_Generic::check_delete()
+{
+	// Try remove from signals immidiately, if possible:
+	if (slot_ref_count == 0 &amp;&amp; signal_ref_count &gt; 0)
+	{
+		// Prevent recursive looping (and allows us to create a helper CL_Slot object):
+		slot_ref_count++;
+
+		std::list&lt;CL_Signal *&gt; signals = connected_signals;
+		connected_signals.clear(); // clear member list to avoid recursive loop problems
+
+		std::list&lt;CL_Signal *&gt;::iterator it;
+		for (it = signals.begin(); it != signals.end(); ++it)
+		{
+			CL_Signal *cur = (*it);
+			CL_Slot slot(this);
+			cur-&gt;disconnect(slot);
+		}
+
+		slot_ref_count--;
+	}
+
+	// Delete ourselves if nobody reference us anymore
+	if (slot_ref_count == 0 &amp;&amp; signal_ref_count == 0) delete this;
+}

Added: trunk/clanlib/doc/CODING_STYLE
===================================================================
--- trunk/clanlib/doc/CODING_STYLE	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/doc/CODING_STYLE	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,237 @@
+$Id: CODING_STYLE,v 1.7 2004/02/07 23:11:42 mbn Exp $
+
+ClanLib coding style and conventions:
+--------------------------------------
+
+1. All classes have a &quot;CL_&quot; prefix. Eg. CL_Display, CL_SoundBuffer...
+2. All macros have a &quot;cl_&quot; prefix. Eg. cl_assert, cl_info...
+
+3. We do NOT use K&amp;R style C style. We use the special ClanSoft variant of
+the Microsoft style!! Please do NOT use K&amp;R style and not GNU style either.
+Braces should look like this:
+
+int CL_MyClass::my_func(int arg1, int arg2)
+{
+	if (...)
+	{
+		switch (whatever)
+		{
+		case 1:
+			break;
+		
+		case 2:
+			{
+				int i = 5;
+				...
+			}
+			break;
+		}
+	}
+	else
+	{
+	}
+}
+
+Please try to follow this indenting style as closely as you can. If
+you are using Emacs you can set the coding style with:
+
+(c-set-style &quot;linux&quot;) or C-c . linux
+
+4. We always use TABS, and NEVER SPACES to do indenting. This is because we
+want people to be able to pick their own tab size. I run with 4, but others
+like 8 and some like 2.
+
+So please don't use spaces. It will have a very bad effect when someone else
+uses another tab size than you. For instance, imagine the following was
+written by someone using tabs, and then you add a section with spaces:
+(all is written here with spaces so people will notice the difference seen
+with other tab sizes than their own)
+
+	void my_func()
+	{
+	    int a,b,c,d;
+	    a = b + c/d;
+	    
+	    // added section with spaces:
+	    d = a;
+	    c = b/d;
+	    // end of space section
+	    
+	    do_something(a,b,c,d);
+	}
+
+So it looks nice to you - but then we watch it with someone that has tab
+size 8:
+
+	void my_func();
+	{
+	        int a,b,c,d;
+	        a = b + c/d;
+	    
+	    // added section with spaces:
+	    d = a;
+	    c = b/d;
+	    // end of space section
+	
+	        do_something(a,b,c,d);
+	}
+
+Not very nice, is it?
+
+Many unix editors use a &quot;smart&quot; indenting algorithm which will fuck things
+even more up. They exchange spaces with tabs when reaching a given size
+(normally 8 or 4), but that just isn't very smart. The result is that some
+sections are spaces, and others are tabbed - all messed into one pile of
+junk.
+
+So please verify that your editor does indenting correct. This is
+important.
+
+5. Function names and variables are always in small, and underscore is used
+where other people often use a captial letter.
+Eg. MyVariable -&gt; my_variable.
+
+6. Variable access functions have a set/get prefix.
+Eg. int size()         -&gt; int get_size()
+    void size(int s)   -&gt; void set_size(int s)
+
+7. STL and variable names.
+
+Do NOT use the &quot;using namespace std;&quot; command. Not in API header or in source
+files. You may be the world champion in STL, but for us other mortals its NICE
+to be able to read what is STL and whats not.
+
+Also don't use two letter variable names and avoid to do aggressive shortening
+of common words (ie. cnt, num, refcnt, glph, fnt, idx). Its annoying to read
+if you have to stop up and think for every variable you encounter just to try
+figure out what it stands for. :) Yes we don't all speak english natively.
+
+8. The API documentation
+
+ClanLib uses a reference documentation system called pce2. It builds the
+reference by parsing the API header files where it looks for the
+documentation. There are the following types of documentation:
+
+1) Short description.
+
+The marker for short description is //:
+
+The short description is used at top of the class reference pages and
+function pages. Its supposed to be &quot;a one sentence description&quot;. Example:
+
+	//: Sprite image class.
+	class CL_Sprite
+	{ ...
+
+Short descriptions do not support markup and should not include any further
+markup tags (bold, italic, paragraph, etc etc).
+
+2) Long description.
+
+The marker for long description is //-
+
+The long description is also known as the &quot;Detailed description:&quot; part of
+the reference pages. This is where the class/functions purpose and
+functional details are explained.
+
+Long descriptions are supposed to put everything into html markup tags. Use
+the paragraph (&lt;p&gt;Text&lt;/p&gt;) tag for text. Example:
+
+	//: Sprite image class.
+	//- &lt;p&gt;CL_Sprite is the image class of ClanLib. A sprite is a serie
+	//- of images (each called a frame) that somehow have a connection
+	//- to each others. It could be all the images needed to animate a
+	//- man, or it could be all the different tiles of a tile map.&lt;/p&gt;
+	class CL_Sprite
+	{ ...
+
+3) Function groups.
+
+Functions in a class is grouped into different sections. The typical ones
+are Construction, Attributes, Operations and Implementation. These groups
+are marked up like this:
+
+	//! Construction:
+	//! Attributes:
+	//! Operations:
+	//! Implementation:
+
+Any functions following such a group markup will belong to that group. The
+group markups are placed at the beginning of the line:
+
+	//! Construction:
+	public:
+		//: Constructs a sprite object.
+		//- &lt;p&gt;Blah blah, this will make a sprite, surprise!&lt;/p&gt;
+		CL_Sprite();
+
+4) Function parameters.
+
+The marker for a function parameter is //param name: description
+
+Parameters of a function are desired to have a parameter description. An example:
+
+	//! Operations:
+	public:
+		//: Draws the sprite onto back buffer.
+		//- &lt;p&gt;The draw function will draw the current frame of the
+		//- sprite at the specified position, using the alignment
+		//- and other attributes specified for the sprite.&lt;/p&gt;
+		//param x: x position of where to draw the sprite.
+		//param y: y position of where to draw the sprite.
+		//param gc: Graphic context used as target. If null, current
+		//param gc: selected display window will be used.
+		void draw(int x, int y, CL_GraphicContext *gc = 0);
+
+5) See also.
+
+The marker for adding a &quot;See also&quot; reference is //also: text
+
+Example:
+
+	//: Sprite image class.
+	//- &lt;p&gt;CL_Sprite is the image class of ClanLib. A sprite is a serie
+	//- of images (each called a frame) that somehow have a connection
+	//- to each others. It could be all the images needed to animate a
+	//- man, or it could be all the different tiles of a tile map.&lt;/p&gt;
+	//also: &lt;a href=&quot;../../overview/sprite.html&quot;&gt;Sprite overview&lt;/a&gt;
+	//also: CL_SpriteDescription
+	class CL_Sprite
+	{ ...
+
+6) Polymorph functions.
+
+If there exist several functions with the same name, then they share one
+common reference page for all of them. The documentation of them should be
+placed in front of the first function:
+
+	//! Operations:
+	public:
+		//: Draws the sprite onto back buffer.
+		//- &lt;p&gt;The draw function will draw the current frame of the
+		//- sprite at the specified position, using the alignment
+		//- and other attributes specified for the sprite.&lt;/p&gt;
+		//param x: x position of where to draw the sprite.
+		//param y: y position of where to draw the sprite.
+		//param dest: Destination rectangle of where to draw sprite.
+		//param gc: Graphic context used as target. If null, current
+		//param gc: selected display window will be used.
+		void draw(int x, int y, CL_GraphicContext *gc = 0);
+
+		void draw(CL_Rect &amp;dest, CL_GraphicContext *gc = 0);
+
+7) Class groups and header file info.
+
+Each header file should contain below the GPL notice:
+//! clan{group}=&quot;{section}&quot;
+{group} denotes the ClanLib group (eg Core, Display, GUI)
+{section} denotes the group section (eg &quot;Controls&quot; for GUI)
+
+To denote which base header file a class belongs to:
+//! header={fname}.h
+{fname} denotes the base header file name eg &quot;display&quot;
+
+
+
+There is more things than there - but I think this summarizes the most
+important issues. In general, just do like the other source files do.

Added: trunk/clanlib/doc/COPYING
===================================================================
--- trunk/clanlib/doc/COPYING	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/doc/COPYING	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,22 @@
+
+ClanLib SDK
+Copyright (c) 1997-2005 The ClanLib Team
+
+This software is provided 'as-is', without any express or implied
+warranty.  In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must not
+   claim that you wrote the original software. If you use this software
+   in a product, an acknowledgment in the product documentation would be
+   appreciated but is not required.
+2. Altered source versions must be plainly marked as such, and must not be
+   misrepresented as being the original software.
+3. This notice may not be removed or altered from any source distribution.
+
+Note: Some of the libraries ClanLib may link to may have additional
+requirements or restrictions.

Added: trunk/clanlib/doc/CREDITS
===================================================================
--- trunk/clanlib/doc/CREDITS	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/doc/CREDITS	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,41 @@
+This file contains the somewhat complete list of the people, who made
+ClanLib what it is today. If you contribute anything to ClanLib, please feel
+free to add yourself to this file!
+
+ClanLib developers:
+(Ranked after coolness, work and activeness)
+
+  Magnus Norddahl &lt;mbn at clanlib.org&gt;
+  Kenneth Gangstoe &lt;sphair at clanlib.org&gt;
+  Ingo Ruhnke &lt;grumbel at gmx.de&gt;
+  Harry Storbacka &lt;harrysto at nic.fi&gt;
+  David Simon &lt;davids at argia.net&gt;
+  Sergey Antonov &lt;sergant_ at mail.ru&gt;
+  Sylvain Hellegouarch &lt;sh at programmationworld.com&gt;
+  Javier Gonz&#225;lez Garc&#233;s &lt;xaviergonz at hotmail.com&gt;
+  Andre Gross &lt;mvk-andreg at ipa.fhg.de&gt;
+  James Wynn &lt;jameswynn at ou.edu&gt;
+  Olof Ohlsson Sax &lt;Olof.Olsson_Sax.9763 at student.uu.se&gt;
+  Immanuel Scholz &lt;immanuel.scholz at gmx.de&gt;
+
+  Mark Robinson &lt;plasmoid at shaw.ca&gt;
+  Christian Mauduit &lt;ufoot at ufoot.org&gt;
+  Jeroen Janssen &lt;japj at clanlib.org&gt;
+  Mark Page &lt;rombust at postmaster.co.uk&gt;
+  Martin Starch Soerensen &lt;starch at clanlib.org&gt;
+  Daniel Vogel &lt;666 at grafzahl.de&gt;
+  Denis Oliver Kropp &lt;dok at fischlustig.de&gt;
+  Christian Nentwich &lt;C.Nentwich at cs.ucl.ac.uk&gt;
+  Ryan Robinson
+  Juan Pablo Sousa &lt;jpsousa at mixcoac.upmx.mx&gt;
+  Arjan Lamers &lt;arjanl at sci.kun.nl&gt;
+  Don Rivers &lt;drivers at uswest.net&gt;
+  Nick Roberts
+  Joachim Andresen &lt;joachim.andresen at ah.telia.no&gt;
+  Baldur Norddahl &lt;bbn at clansoft.dk&gt;
+  Daniel A. Palm &lt;nightwinddp at yahoo.com&gt;
+  Lenny Palozzi &lt;domain at ica.net&gt;
+  Simon Vaillancourt &lt;simon_v at videotron.ca&gt;
+  Daniel James Patterson &lt;danpat at cs.rmit.edu.au&gt;
+  Karsten Laux &lt;klaux at student.uni-kl.de&gt;
+  Sean Heber &lt;sean at fifthace.com&gt;

Added: trunk/clanlib/doc/INSTALL.borland
===================================================================
--- trunk/clanlib/doc/INSTALL.borland	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/doc/INSTALL.borland	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,131 @@
+BorlandC++ 5 Install instructions. 
+Written by Mark Page.
+Last modified February 28, 2002 by Craig Timpany
+
+THIS FILE IS NOT BEING MAINTAINED. IF YOU DISCOVER SOMETHING IS WRONG,
+PLEASE TRY TO FIGURE IT OUT AND SEND US A PATCH.
+
+Building ClanLib
+===========================================================================
+If you have the Borland C++Builder then simply compile and run
+configure.bpr.
+
+If some Borland packages seem to be missing:
+If you have the standard version of the Borland IDE you may need to disable
+the use of runtime packages in order to get it working.
+Go to Project-&gt;Options and select the Packages tab. Then disable the lowerst 
+option ('Compile with runtime packages', should be the name, I tried to 
+translate)
+
+If you have the commmand line tools then 'make -f configure.mak'.
+
+Run Configure, this creates the necessary directories and files. Then
+simply open the appropriate Borland/*.bpr file and start building. To build
+specific projects either use C++Builder or use make. It is suggested that
+you build App, Core and Display at the very minimum. The config program
+will ask if you have TASM, Borland's assembler. The Free-tools do *not*
+have it.
+
+In the Borland directory are makefiles and C++Builder project files.
+Either will build the project.  The files with an extra 'd' on the end
+builds the debug versions.  If you just want to build ClanLib quickly then
+I suggest you use the makefiles. They are faster (you don't need to have BCB
+loaded) and won't crash your computer.  The makefiles assume you have
+Hermes and zlib includes in your $(BCB)\include dir so it looks like this:
+($(BCB) being where you install borland c++)
+
+$(BCB)\include\zlib.h
+$(BCB)\include\zconf.h
+$(BCB)\include\Hermes\Hermes.h
+$(BCB)\include\Hermes\H_Blit.h
+$(BCB)\include\Hermes\H_Clear.h
+$(BCB)\include\Hermes\H_Config.h
+$(BCB)\include\Hermes\H_Conv.h
+$(BCB)\include\Hermes\H_Format.h
+$(BCB)\include\Hermes\H_Pal.h
+$(BCB)\include\Hermes\H_Types.h
+
+To run a makefile from DOS, type 'make -f whatever.mak'. There is no master
+makefile, you'll need to do this individually for each ClanLib module you need.
+
+You need zlib.lib and hermes.lib to create complete applications, however you
+don't need them to compile ClanLib.  You can build them from source but they
+MUST be multi-threaded (use -tWM) or else you'll get weird crashes.
+
+Check out clanlib.org for pre-built binaries of these libraries.
+
+
+Compiling Apps with ClanLib
+===========================================================================
+
+1. You must compile your program the -tWM flag.  This enables
+multi-threading (ClanLib is multi-threaded).
+
+2. You must link with cw32mt.lib and not cw32.lib.  You also need to link
+to zlib.lib, hermes.lib and libapp.lib you may also have to link with
+other libraries(eg Clanlib libdisplay.lib) and almost certainly the 
+directX libs (dinput.lib, ddraw.lib). 
+
+You can't use the user run-time DLLs of DirectX for this, you need the SDK.
+If you only have free command-line borland, you probably have headers, but
+not libraries. Converting the MS DirectX libraries to ones Borland can use 
+is reputed to be difficult, so you might have to find a package of Borland 
+.libs somewhere on the net.
+
+At the time of writing, there were some here:
+<A HREF="http://www.geocities.com/foetsch/borland_dx8_libs.zip">http://www.geocities.com/foetsch/borland_dx8_libs.zip</A>
+
+Don't worry if you can't find the latest version, as far as I know, Clanlib
+only uses very basic DirectX features (circa DirectX 3).
+
+There are external libraries that you may need as well (libPNG, etc...).
+
+3. You must place a directory called ClanLib somewhere in your header search path.  I recommend placing it in $(BCB)\include\.  Then simply copy the files under ClanLib\Sources\API to $(BCB)\include\ClanLib\.  If you do this properly then $(BCB)\include\ClanLib\ should be populated with files such as ttf.h, core.h, display.h and app.h.  There should also the appropriate subdirectories for each.
+
+4. Depending on which external libraries you link with(Hermes-dynamic, Hermes-static...) then you might have to include the .def files for the project into your application.  This is required when using Hermes-dynamic(Hermes.lib/Hermes.dll).
+
+
+If your app doesnt work with the supplied .libs you may need to compile them
+yourself. See above for instructions. Firstly only compile
+libApp.lib, libClan.lib and libDisplay.lib and see whether it works then.
+Don't forget to use your self compiled libraries for your project after that !
+(Project-&gt;Remove from project to remove the downloaded ones and Project-&gt;Add
+to project to add your self compiled ones).
+You can find your self-compiled libraries in &lt;ClanLib Dir&gt;\Release for release 
+libraries and &lt;ClanLib Dir&gt;\Debug for debug versions (the ones with a 'd' at 
+the end).
+
+For those with command-line tools, here's an example makefile:
+
+===========================================================================
+
+OBJS = mysourcefilename.obj anotherfile.obj andsoon.obj
+CPP        = bcc32
+LINKER     = ilink32
+
+CCOPTS = -tWM
+DEBUG = -v -k
+LDEBUG = /v
+CPPFLAGS= -jb $(CCOPTS) $(DEBUG) -DHAVEMIKMOD
+
+LINKFLAGS= /aa /Tpe $(LDEBUG)	c0w32.obj
+LINKLIBS=zlib.lib hermes.lib \
+	ddraw.lib dinput.lib \
+	libapp.lib libdisplay.lib libcore.lib \
+	import32.lib \
+	cw32mt.lib
+
+all: $(OBJS)
+	$(LINKER) $(LINKFLAGS) $(OBJS), acmegame.exe, , $(LINKLIBS)
+
+# cpp -&gt; obj:
+.cpp.obj:
+    $(CPP) $(CPPFLAGS) -c {$? }
+
+Known Issues
+===========================================================================
+
+- The define BORLAND must be set in all your programs or else they won't
+  compile at all.
+
+Report bugs to <A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">plasmoid at shaw.ca</A> and <A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">clanlib-devel at dark.x.dtu.dk.</A>

Added: trunk/clanlib/doc/INSTALL.linux
===================================================================
--- trunk/clanlib/doc/INSTALL.linux	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/doc/INSTALL.linux	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,180 @@
+$Id: INSTALL.linux,v 1.17 2004/03/17 14:22:06 sphair Exp $
+
+Readme file for ClanLib 0.8.x under Linux
+---------------------------------------------------------------------------
+This readme will guide you with compiling, installing ClanLib and creating
+your first ClanLib application.
+
+If you have downloaded the binaries, you can skip section 2 and 3.
+
+1. Getting started
+2. Checking out from CVS
+3. Compilation
+4. Creating a simple Makefile
+5. Creating a simple application
+6. Problems ?
+
+
+1. Getting started
+---------------------------------------------------------------------------
+Make sure you have all the required libraries and programms you need
+before you start compiling ClanLib. Currently, you need at least zlib,
+libjpg and libpng to compile ClanLib and pkgconfig to guide at
+the compilation of examples and games using ClanLib. Check out the
+Links and Download page on our website for more info on these
+libraries.
+
+Remember to read the README if you run into any problems!
+
+This is the linux/unix INSTALL document, have a look at INSTALL.win32
+for the win32 installation &amp; readme information.
+
+
+2. Checking out from CVS
+---------------------------------------------------------------------------
+If you download a nightly snapshot, or this is an official release, skip
+this step.
+
+If checked out from cvs, run autogen.sh to produce the configure script:
+
+  ./autogen.sh
+
+
+3. Compilation
+---------------------------------------------------------------------------
+  ./configure
+  make
+  make install
+
+You can force enabling of implementations, or disable some - eg.:
+
+  ./configure --disable-clanMikMod --enable-clanGL
+
+To get a list of possible options, run &quot;./configure --help&quot;
+
+
+The documentation is generated automatically if the required tools are
+on your system, you can disable it if you don't need them with:
+
+  ./configure --disable-docs
+
+
+At default both shared (.so) and static libraries (.a) are build,
+unless you want to make a static release, you will probally only want
+the shared libraries, you can disable the static ones with:
+
+  ./configure --disable-static
+
+Doing so will reduce the compile size by a half.
+
+
+4. Creating a simple Makefile
+---------------------------------------------------------------------------
+A simple makefile used to compile ClanLib under Linux could look like
+this:
+
+PACKAGES = clanCore-0.8 clanDisplay-0.8 clanApp-0.8 clanGL-0.8
+CPPFLAGS = `pkg-config --cflags $(PACKAGES)`
+LIBS = `pkg-config --libs $(PACKAGES)`
+OBJS = simple.o
+
+all: $(OBJS)
+	g++ -o simple $(OBJS) $(LIBS)
+
+clean:
+	-rm -rf *.o
+	-rm simple
+
+Note that you should minimum link with clanCore, clanDisplay, clanGL and 
+clanApp.
+
+Optional libraries:
+     If you want to use network, add clanNetwork
+     If you want to use sound, add clanSound
+     If you want to use MikMod, add clanMikMod
+     If you want to use Vorbis, add clanVorbis
+     If you want to use GUI, add clanGUI
+     If you want to use SDL, add clanSDL
+
+If you are not using pkg-config to compile your program, you might want to
+refer to INSTALL.mingw in order to link your program with the libraries
+manually. In INSTALL.mingw, you can see that when linking your program
+manually, you need to be careful about the order of the libraries, however
+this is not the case if you use pkg-config, it will handle it for you.
+therefore it is recommended that you use pkg-config in your makefile.
+
+
+5. Creating a simple application
+---------------------------------------------------------------------------
+
+#include &lt;ClanLib/gl.h&gt;
+#include &lt;ClanLib/core.h&gt;
+#include &lt;ClanLib/application.h&gt;
+#include &lt;ClanLib/display.h&gt;
+
+class MyApp : public CL_ClanApplication
+{
+public:
+	virtual int main(int argc, char **argv)
+	{
+		// Create a console window for text-output if not available
+		// Use printf or cout to display some text in your program
+		CL_ConsoleWindow console(&quot;Console&quot;);
+		console.redirect_stdio();
+
+		try
+		{
+			// Initialize ClanLib base components
+			CL_SetupCore setup_core;
+
+			// Initialize the ClanLib display component
+			CL_SetupDisplay setup_display;
+
+			// Initialize the ClanLib GL component
+			CL_SetupGL setup_gl;
+
+			// Create a display window
+			CL_DisplayWindow window(&quot;ClanLib application&quot;, 640, 480);
+
+			// Run until someone presses escape
+			while (!CL_Keyboard::get_keycode(CL_KEY_ESCAPE))
+			{
+				// Clear the display in a dark blue nuance
+				// The four arguments are red, green, blue and alpha (defaults to 255)
+				// All color nuances in ClanLib are measured in the interval 0-&gt;255
+				CL_Display::clear(CL_Color(0, 0, 50));
+
+				// Flip the display (using a double-buffer),
+				// showing on the screen what we have drawed
+				// since last call to flip()
+				CL_Display::flip();
+
+				// This call updates input and performs other &quot;housekeeping&quot;
+				// Call this each frame
+				// Also, gives the CPU a rest for 10 milliseconds to catch up
+				CL_System::keep_alive(10);
+			}
+		}
+		// Catch any errors from ClanLib
+		catch (CL_Error err)
+		{
+			// Display the error message
+			std::cout &lt;&lt; err.message.c_str() &lt;&lt; std::endl;
+		}
+
+		// Display console close message and wait for a key
+		console.display_close_message();
+
+		return 0;
+	}
+} app;
+
+
+6. Problems ?
+---------------------------------------------------------------------------
+Please read the FAQ on <A HREF="http://clanlib.org">http://clanlib.org</A> for common errors and explanations!
+
+
+--
+Enjoy,
+The ClanLib development team

Added: trunk/clanlib/doc/INSTALL.macosx
===================================================================
--- trunk/clanlib/doc/INSTALL.macosx	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/doc/INSTALL.macosx	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,174 @@
+---------------------------------------------------------------------------
+Building ClanLib on Mac OS X
+---------------------------------------------------------------------------
+
+1. Getting Started
+2. Building ClanLib
+3. Running Example Applications
+4. Creating Applications with ClanLib
+5. Universal Binaries
+6. Problems?
+
+1. Getting Started
+---------------------------------------------------------------------------
+The ClanLib Xcode project file was created with Xcode 1.5, so download and
+install that (or something newer) before continuing.
+
+In order to build ClanLib, you need to locate a few dependencies.
+The required frameworks depend upon which ClanLib modules you will build.
+You will most likely require at least libjpeg and libpng as ClanDisplay
+requires those frameworks and several other ClanLib components require
+ClanDisplay. The available external frameworks are:
+
+- libjpeg
+- libpng
+- mikmod
+- Ogg
+- SDL
+- Vorbis
+
+With the likely exception of libjpeg and libpng, the source code and Xcode
+project files for each of these frameworks can be found at their respective
+websites (use Google). To make things easier, all of them have been pre-built
+and collected at these URLs for easy downloading:
+
+- Mac OS X 10.4+ Universal (PowerPC + Intel):
+- <A HREF="http://www.clanlib.org/download-binaries-osx-gcc40-universal.html">http://www.clanlib.org/download-binaries-osx-gcc40-universal.html</A>
+
+- Mac OS X 10.4+ PowerPC Only:
+- <A HREF="http://www.clanlib.org/download-binaries-osx-gcc40.html">http://www.clanlib.org/download-binaries-osx-gcc40.html</A>
+
+- Older Mac OS X PowerPC Only:
+- <A HREF="http://www.clanlib.org/download-binaries-osx-gcc33.html">http://www.clanlib.org/download-binaries-osx-gcc33.html</A>
+
+Once you have all of the external frameworks collected, place them into
+a &quot;Frameworks&quot; folder in your &quot;ClanLib-0.8&quot; folder (the same folder that
+the ClanLib.xcode project file is in) as this is where the ClanLib Xcode
+project expects them to be. You will have to create this folder manually.
+If you want them somewhere else, then you will have to point the way to
+Xcode - in which case you are on your own.  :-)
+
+2. Building ClanLib
+---------------------------------------------------------------------------
+Now that you've installed Xcode and got the other frameworks, go ahead and
+open the ClanLib.xcode project file. (If you are using a newer version of
+Xcode it will prompt to upgrade the project file - do it.) The project file
+contains several targets which build each component of ClanLib as a
+separate framework. These resulting frameworks are private frameworks which
+are meant to be copied/embedded into the bundle for the application you are
+creating. This means your finished application will be self-contained as
+far as ClanLib is concerned and not require installation of any components
+onto end-user machines.
+
+Select the ClanLib target in the Xcode project and hit build. The resulting
+frameworks are placed into a &quot;MacOSX&quot; folder within the same folder as the
+ClanLib.xcode file itself resides. Inside this folder you will find all
+required frameworks that are both part of ClanLib as well as the required
+external frameworks. This should make it easy to see exactly what you will
+need to bundle with your application.
+
+If you don't need all of the modules (for instance, if you have no need for
+ClanSDL and ClanMikMod), then simply edit the &quot;ClanLib Distro&quot; target and
+delete the references to the targets you do not need. Don't forget to look
+in the &quot;Copy Files (MacOSX)&quot; build phase as well!
+
+3. Running Example Applications
+---------------------------------------------------------------------------
+The &quot;Examples&quot; folder has another Xcode project file named Examples.xcode.
+This project has most (but not all) of the ClanLib example applications
+pre-built as targets for easy testing. Simply set the active target to the
+example you wish to try and hit build. The project file expects the ClanLib
+frameworks to be in the &quot;ClanLib-0.8/MacOSX/&quot; folder which is where the
+ClanLib.xcode project you used in step #2 places them.
+
+4. Creating Applications with ClanLib
+---------------------------------------------------------------------------
+Now that you've got ClanLib and the modules you need built, it is time to
+use them! Create an Xcode project however you like. (The Carbon Application
+template is probably what you will want for now.) Then add the frameworks
+you will need to your project - remember they are in the &quot;MacOSX&quot; folder as
+mentioned in step 2 above. You will *always* need the ClanLib.framework as
+well as any others you may have used (most certainly ClanCore.framework).
+
+Don't forget to add the external frameworks that may be required by the
+ClanLib components you are using! (These are libjpeg, libpng, etc. which
+should have been copied into the &quot;MacOSX&quot; folder mentioned earlier and are
+required by ClanDisplay.framework.) When adding external frameworks, Xcode
+should automatically set your target to link with them. You can check to
+make sure by opening the &quot;Link Binary With Libraries&quot; folder under your
+target and verifying that they are represented there.  If not, simply drag
+them into the folder.
+
+The final preparation step is to add a &quot;Copy Files&quot; build phase to your
+target. Set the location to &quot;Frameworks&quot; and then drag the various ClanLib
+and required external frameworks (such as libjpeg and libpng) into the build
+phase's folder.  This will cause Xcode to copy those frameworks directly into
+your application's bundle and result in a self-contained binary which needs
+no installer.  You do not need to copy in CoreServices, Carbon, libstdc++,
+or any other frameworks or libraries that were automatically added by the
+new project template (such as Carbon Application) when you created the new
+project file with Xcode as they are always included with Mac OS X.
+
+After your project file is prepared, add your source files and click build.
+With luck it will all just work.
+
+5. Universal Binaries
+---------------------------------------------------------------------------
+As you know, universial binaries will execute natively on PowerPC and Intel
+based Macs using the same application bundle.  This means that you can
+easily deploy Mac applications to users of both types of machines and be
+sure that each user enjoys the performance they expect from their platform.
+
+Building a universal version of your ClanLib application is easy and should
+only require a few changes to your Xcode project file as well as ClanLib's
+project file.  You must have Xcode 2.2 or newer in order for this to work
+as well as universal versions of the required frameworks copied into your
+&quot;Frameworks&quot; folder (as talked about above).  Additionally, it is important
+that if you have previously built ClanLib *without* using the universal
+frameworks, you must remove the non-universal frameworks from the &quot;MacOSX&quot;
+folder that the ClanLib build process created (as was described above).
+Sometimes Xcode doesn't notice that the new universal frameworks have
+changed from the old and so they don't get replaced which can cause
+problems if your project file refers to that &quot;MacOSX&quot; folder directly (as
+is the case with the Examples Xcode project file provided in the ClanLib
+&quot;Examples&quot; folder).
+
+Since you should already have Xcode 2.2 or higher, you've likely already
+opened and upgraded a copy of the ClanLib.xcode project file.  If not, do
+so.  Be sure to tell Xcode to save the upgraded project file in the same
+folder as the original ClanLib.xcode file (which it should do by default).
+
+Once Xcode is open and the ClanLib project file is loaded, click on the
+&quot;Project&quot; menu followed by the &quot;Edit Project Settings&quot; option.  The project
+settings editor should pop up.  First switch to the &quot;General&quot; tab.  There
+should be an option labled &quot;Cross-Develop Using Target SDK&quot; with a drop
+down menu.  The menu likely reads something like &quot;Current Mac OS.&quot;  Change
+that to &quot;Mac OS X 10.4 (Universal).&quot;
+
+Switch to the &quot;Build&quot; tab and look for the setting named &quot;Architectures&quot;.
+Select it and click &quot;Edit&quot; and check the boxes for both Intel and PowerPC
+and click OK.
+
+Now rebuild ClanLib.  It will take awhile since it'd building for two, now.
+
+Once ClanLib has been built, simply make those same two changes to your own
+project file and make sure it is refering to the now universal ClanLib and
+supporting frameworks and rebuild your application.  Once the build is done
+you will have a complete universal application bundle that will run on both
+PowerPC and Intel based Macs with OS X 10.4 or later.  Of course to be safe
+you should test the end product on both architectures before your final
+deployment.
+
+6. Problems?
+---------------------------------------------------------------------------
+Please read the FAQ on <A HREF="http://www.clanlib.org/">http://www.clanlib.org/</A> for common errors and
+explanations.  There is also a Wiki at <A HREF="http://www.clanlib.org/wiki/.">http://www.clanlib.org/wiki/.</A>
+
+If you cannot find the answer to your problem in the FAQ, feel free to ask
+on the ClanLib user mailing list or join the #clanlib channel on IRC at
+irc.freenode.net.
+
+--
+Enjoy,
+The ClanLib development team
+

Added: trunk/clanlib/doc/INSTALL.mingw
===================================================================
--- trunk/clanlib/doc/INSTALL.mingw	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/doc/INSTALL.mingw	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,210 @@
+$Id: INSTALL.mingw,v 1.8 2004/03/17 14:22:06 sphair Exp $
+
+Readme file for ClanLib 0.8.x using MinGW under Win32
+---------------------------------------------------------------------------
+This readme will guide you with installing, compiling ClanLib and
+creating your first ClanLib application using the MinGW compiler and
+MSYS toolset on Win32 or a gcc ix86-mingw32msvc cross-compiler (i.e.
+you can compile ClanLib in Linux and then run the binaries in Windows!
+(or even run them using a Windows emulator like Wine...)). You should
+also be able to compile ClanLib with Cygwin, the ./configure script
+will detect Cygwin and append the '-mno-cygwin -DWIN32' flags to the
+compiler call.
+
+1. Requirements
+2. Compiling ClanLib
+3. Compiling ClanLib applications
+4. Simple akefile example
+5. Creating a simple application
+
+
+1. Requirements
+---------------------------------------------------------------------------
+To compile and use ClanLib you need some other libraries. As with any
+ClanLib target you need to zlib, libjpeg and libpng. There are
+links from the ClanLib download page (www.clanlib.org/download) to all
+these libraries.
+
+All libraries should be named as Unix libraries (i.e. libjpeg.a instead
+of jpeg.lib) and has to be installed so that the compiler can find both
+the archive files (*.a) and the include files.
+
+You also need the DirectX libraries and headers version 7 or later. Just google
+the net to find them. It should be possible to use the DirectX SDK from MS
+but there are also some MinGW specific packages out there. At the moment
+of writing there is a DirectX 7 MinGW package at:
+
+ * <A HREF="http://caesar.logiqx.com/zips/tools/compilers/mingw/dx70_mgw.zip">http://caesar.logiqx.com/zips/tools/compilers/mingw/dx70_mgw.zip</A>
+
+Other additional libraries for MinGW can be found at (site looks a bit
+outdated, but might still be helpfull):
+
+ * <A HREF="http://mingwrep.sourceforge.net/">http://mingwrep.sourceforge.net/</A>
+
+Instructions on how to build a cross-compile environment can be found
+at:
+
+ * <A HREF="http://www.libsdl.org/Xmingw32/">http://www.libsdl.org/Xmingw32/</A>
+
+If you try to compile the other libraries from source you might
+want to '--enable-static --disable-shared' at ./configure time since
+often the DLL build process is a bit buggy and also doesn't lead to
+having a standalone binary in the end, so static libraries should be
+prefered.
+
+
+2. Compiling ClanLib
+---------------------------------------------------------------------------
+Compiling ClanLib works buy using the standard ./configure script as
+with most other Free Software.
+
+ClanLibs configure script should be able to detect a mingw or cygwin
+environment automatically and setup everything according to that. As
+with other libraries, compiling a static library is recomment if you
+want a binary that doesn't depend on extra .dll's. So to compile you
+would do:
+
+ ./configure --enable-static --disable-shared
+ make
+ make install
+
+If you want to cross compile, you have to use the cross-configure.sh
+scripts as documented on:
+
+  * <A HREF="http://www.libsdl.org/Xmingw32/">http://www.libsdl.org/Xmingw32/</A>
+
+or pass the target options manually.
+
+
+3. Compiling ClanLib applications
+---------------------------------------------------------------------------
+When you compile an application that uses ClanLib you have to use the
+-mthreads option to enable multithreading.
+
+Depending on which ClanLib modules you use you also may have to link with
+some extra libraries:
+
+Module          Extra linker flags
+
+clanCore        -lz
+clanDisplay     -lwinmm -lddraw -ldinput -ldxguid -ljpeg -lpng
+clanGL          -lopengl32 -lglu32
+clanSound       -ldsound -lwinmm
+clanNetwork     -lws2_32
+
+If you want to try the ClanLib examples in the Examples directory
+you'll have to adjust the makefiles to include the above mentioned
+compiler and linker flags. [FIXME: in the future this should be
+handled automatically by pkg-config, but currently thats not the case]
+
+
+4. Simple makefile example
+---------------------------------------------------------------------------
+MY_GAME=my_great_game
+OBJS=badies.o goodies.o lots_of_weapons.o
+
+CXX=g++
+
+CXXFLAGS= -mthreads
+CLANLIBS= -lclanApp -lclanGL -lclanDisplay -lclanCore
+EXTRALIBS= -lz -lwinmm -lddraw -ldinput -ldxguid -ljpeg -lpng \
+           -lopengl32 -lglu32
+
+PROGRAM: OBJS
+	$(CXX) $(CXXFLAGS) -o $(MY_GAME) $(OBJS) $(CLANLIBS) $(EXTRALIBS)
+
+
+Note that you should minimum link with clanCore, clanDisplay, clanGL and 
+clanApp.
+
+Note that it is important to realize that in order to get your code 
+compiled, some of the libraries should be put in a certain order. 
+
+For example:
+If you want to compile code that is involving GUI stuff, you will need
+to link your program with clanGUI library. In addition, You might also 
+need to include clanGUIStyleBoring and clanGUIStyleSilver libraries in
+your makefile. These libraries should go before clanDisplay library, 
+and both the clanGUIStyleBoring and clanGUIStyleSilver libraries should
+be put before clanGUI. 
+
+One possibility of the libraries orders would be:
+   -lclanGUIStyleBoring -lclanGUIStyleSilver -lclanGUI -lclanApp -lclanGL 
+   -lclanDisplay -lclanCore
+
+If you need to link your program with any other libraries and the compiler
+complains something about &quot;undefined reference to &lt;some stuff&gt;&quot;, and
+you are sure that the libraries that you link with, already contain the
+&lt;stuff&gt;, you will probably need to shuffle your libraries order abit.
+
+You may also need to check that the required libraries have already been
+installed. The basic ClanLib libraries are:
+clanApp, clanCore, clanDisplay, clanGL, clanGUI, clanGUIStyleBoring, 
+clanGUIStyleSilver, clanNetwork, clanSignals, and clanSound
+These libraries filenames are usually prefixed by &quot;lib&quot; and followed by 
+&quot;.a&quot;, e.g. libclanApp.a
+
+
+5. Creating a simple application
+---------------------------------------------------------------------------
+
+#include &lt;ClanLib/core.h&gt;
+#include &lt;ClanLib/application.h&gt;
+#include &lt;ClanLib/display.h&gt;
+
+class MyApp : public CL_ClanApplication
+{
+public:
+	virtual int main(int argc, char **argv)
+	{
+		// Create a console window for text-output if not available
+		// Use printf or cout to display some text in your program
+		CL_ConsoleWindow console(&quot;Console&quot;);
+		console.redirect_stdio();
+
+		try
+		{
+			// Initialize ClanLib base components
+			CL_SetupCore setup_core;
+
+			// Initialize the ClanLib display component
+			CL_SetupDisplay setup_display;
+
+			// Initialize the ClanLib GL component
+			CL_SetupGL setup_gl;
+
+			// Create a display window
+			CL_DisplayWindow window(&quot;ClanLib application&quot;, 640, 480);
+
+			// Run until someone presses escape
+			while (!CL_Keyboard::get_keycode(CL_KEY_ESCAPE))
+			{
+				// Clear the display in a dark blue nuance
+				// The four arguments are red, green, blue and alpha (defaults to 255)
+				// All color nuances in ClanLib are measured in the interval 0-&gt;255
+				CL_Display::clear(CL_Color(0, 0, 50));
+
+				// Flip the display (using a double-buffer),
+				// showing on the screen what we have drawed
+				// since last call to flip()
+				CL_Display::flip();
+
+				// This call updates input and performs other &quot;housekeeping&quot;
+				// Call this each frame
+				// Also, gives the CPU a rest for 10 milliseconds to catch up
+				CL_System::keep_alive(10);
+			}
+		}
+		// Catch any errors from ClanLib
+		catch (CL_Error err)
+		{
+			// Display the error message
+			std::cout &lt;&lt; err.message.c_str() &lt;&lt; std::endl;
+		}
+
+		// Display console close message and wait for a key
+		console.display_close_message();
+
+		return 0;
+	}
+} app;

Added: trunk/clanlib/doc/INSTALL.win32
===================================================================
--- trunk/clanlib/doc/INSTALL.win32	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/doc/INSTALL.win32	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,271 @@
+$Id: INSTALL.win32,v 1.11 2004/03/28 00:13:14 sphair Exp $
+
+Readme file for ClanLib 0.8.x under Win32
+---------------------------------------------------------------------------
+This readme will guide you with installing, compiling ClanLib and creating
+your first ClanLib application.
+
+If you have downloaded the binaries, you can skip section 3 and 4.
+
+1. Getting started
+2. Preparing installation
+3. Configuring ClanLib
+4. Compiling ClanLib
+5. Testing ClanLib
+6. Creating applications with ClanLib
+7. Creating a workspace for your application
+8. Problems ?
+
+
+1. Getting started
+---------------------------------------------------------------------------
+You need Microsoft Developer Studio 6.0 or 7.x/200x (.NET) with MFC
+installed to follow this installation guide (see INSTALL.borland for
+Borland specific instructions). The instructions here are mostly based
+on VC 6.0, but you will be able to easily find the same options in VC 7.0.
+
+Go to <A HREF="http://clanlib.org/download.html">http://clanlib.org/download.html</A> and download at least the zlib,
+libjpeg and libpng multithreaded libraries. If you need more
+functionality in ClanLib, you can download those other libraries you need.
+(Check out the handy Windows External Libraries section!)
+
+Install these libraries in a directory - remember which one, because you
+need to enter that information in the next section.
+
+If you are using VC6, You MUST install service pack 5 from 
+<A HREF="http://msdn.microsoft.com/vstudio/downloads/updates/sp/vs6/sp5/">http://msdn.microsoft.com/vstudio/downloads/updates/sp/vs6/sp5/</A>
+
+It is also recommended to install latest Microsoft Platform SDK, which
+will give you a much newer set of include files and libraries, making it
+possible to use things Microsoft invented since 1998.  If you are using
+VS.Net Express, then you will HAVE to do this.
+
+The Microsoft Platform SDK is available at:
+<A HREF="http://www.microsoft.com/msdownload/platformsdk/sdkupdate/">http://www.microsoft.com/msdownload/platformsdk/sdkupdate/</A>
+
+
+2. Preparing installation
+---------------------------------------------------------------------------
+The first step in using ClanLib under Windows is to setup a sane build
+environment. This involves two things:
+
+1. ClanLib must be able to locate the libraries it uses.
+2. ClanLib must know where to install itself.
+
+My personal build environment is setup as follows using &quot;c:\My Documents&quot;
+as base path. (You don't need to follow the same scheme, put your libraries
+where it fits you).
+
+&quot;c:\My Documents\lib&quot; contains all .lib files that didn't come along with
+msvc++ and that are needed by ClanLib.
+
+&quot;c:\My Documents\include&quot; contains all include files needed by the libs.
+
+Here is how it looks like after I've installed Zlib:
+
+c:\My Documents\lib\zlib.lib
+c:\My Documents\include\zlib.h
+c:\My Documents\include\zconf.h
+
+You must configure Visual C++ so it knows where to find the include and 
+library files.  This is done through the Tools -&gt; Options -&gt; Projects 
+-&gt; VC++ Directories.  Fill in the include directory
+(&quot;c:\My Documents\include&quot;) under the Include Files listbox,
+and the library directory (&quot;c:\My Documents\lib&quot;) under the Library Files
+listbox. 
+
+IMPORTANT: Put the new include and library paths on the TOP of the lists
+(to avoid it using dx3 for instance) UNLESS you are using VS.Net 2005.
+In that case, make sure the PlatformSDK include folder is at the top of
+the list.
+
+
+3. Configuring ClanLib
+---------------------------------------------------------------------------
+A freshly downloaded ClanLib source package will include a workspace/solution
+and project for either MSVC6 (configure.dsw), or Visual Studio .NET 2005
+(configure-vs80.sln).  This is a configuration tool that
+will generate the real ClanLib workspace and project files. If you are using
+Visual Studio .NET below 2005, use the configure.dsw file and answer yes
+to the conversion.
+
+You have to compile and run this wizard and answer its questions carefully.
+Incorrect information will give you problems during the compilation.
+After you've compiled the app, just run it from inside of the compiler.
+
+When the configure wizard asks me where to install the header and library
+files, I specify those paths from section 2 (C:\My Documents\include and
+C:\My Documents\lib).
+
+When this is done, open the ClanLib.dsw file if you are using Developer
+Studio 6, or the ClanLib.sln file if you are using .NET version.  Answer
+Yes to convert the file to your MSVC version if prompted.
+
+
+4. Compiling ClanLib
+---------------------------------------------------------------------------
+After loading the ClanLib workspace, the project view will show many different
+projects; clanApp, clanCore, clanDisplay etc...
+
+Start with making clanCore the active project, if its not active already.
+You do this by right-clicking it, and select 'Set as Active Project'.
+Select Debug or Release in the toolbar. If you can't find this option
+anywhere, right click on the toolbar, and make sure Build is selected,
+and deselect the Build Minibar. Press F7 to compile the active project.
+
+You need to compile at least these projects:
+- ClanApp
+- ClanCore
+- ClanDisplay
+- ClanGL
+
+Optionally, you can compile the others if you need them. Batch Build is
+handy here.
+
+You'll get some warnings for the different projects, similar to:
+
+   ddraw.lib(DDRAW.dll) : warning LNK4006: __NULL_IMPORT_DESCRIPTOR already
+   defined in winmm.lib(WINMM.dll); second definition ignored
+
+   GLU32.lib(GLU32.dll) : warning LNK4006: __NULL_IMPORT_DESCRIPTOR already
+   defined in OpenGL32.lib(OPENGL32.dll); second definition ignored
+
+   LINK : warning LNK4098: defaultlib &quot;LIBCMT&quot; conflicts with use of other
+   libs; use /NODEFAULTLIB:library
+
+Ignore these warnings, they are not important.
+
+For each library in ClanLib, we produce two .lib files, eg clanCore.lib and
+clanCored.lib. The first one is for release versions of your game, and the
+second is for debug versions.
+
+The debug version includes debugging information in the library itself (so
+if the lib crashes, you can see where in the source code it crashed).
+
+After a successful compilation of ClanLib, it will automatically run a batch
+file that will install all headers and lib files in the path you specified
+in the wizard. In my case, that is &quot;c:\My Documents\lib&quot; and
+&quot;c:\My Documents\include&quot;. So the following files will be added:
+
+c:\My Documents\lib\clanCore.lib  (release lib)
+c:\My Documents\lib\clanCored.lib (debug lib)
+c:\My Documents\lib\clanGL.lib
+c:\My Documents\lib\clanGLd.lib
+
+c:\My Documents\include\ClanLib\core.h
+c:\My Documents\include\ClanLib\gl.h
+...
+
+
+5. Testing ClanLib
+---------------------------------------------------------------------------
+To have a look at some examples of various parts of ClanLib, open the
+Examples.dsw/.sln file in your ClanLib root directory. This was created after
+you ran the Configure application.
+
+Select any example, and compile it. You'll find examples covering most
+parts of the ClanLib API.
+
+Once you're done and ready for some coding, proceed to next section.
+
+
+6. Creating applications with ClanLib
+---------------------------------------------------------------------------
+Note that MSVC will know what .lib file to link into your application, based
+upon the ClanLib headers you include in your application.
+
+Example:
+	If you include &lt;ClanLib/core.h&gt; then depending on whether you are
+	building release or debug binaries the clanCore.lib or clanCored.lib
+	library will be automatically linked into your executable. 
+
+
+7. Creating a workspace for your application
+---------------------------------------------------------------------------
+ 1.  Select File-&gt;New...
+ 2.  Select Projects-&gt;Win32 Application, and specify where you want it located.
+ 3.  Select &quot;An empty project&quot;, and press OK till you're finished with the wizard.
+ 4.  Select Project-&gt;Settings...
+     Notice there are several configurations in which you can modify settings.
+     Normally, these are 'Win32 Debug' and 'Win32 Release'. You switch between
+     these in the 'Settings for:' droplist. 
+     In section 5 and 6 below, you need to modify both these settings
+     (sections a for release setting, and sections b for debug settings).
+ 5.  Select the 'C/C++' tab, and then Category 'Code Generation'
+ 5a. For Release version, change the 'Use run-time library' to Multithreaded.
+ 5b. For Debug version, change the 'Use run-time library' to Debug Multithreaded.
+ 6.  Select Project-&gt;Add To Project-&gt;New...
+ 7.  Select C++ Source File, and enter a name for the file, for example 'app.cpp'
+ 8.  Enter a skeleton for your code:
+
+#include &lt;ClanLib/core.h&gt;
+#include &lt;ClanLib/application.h&gt;
+#include &lt;ClanLib/display.h&gt;
+#include &lt;ClanLib/gl.h&gt;
+
+class MyApp : public CL_ClanApplication
+{
+public:
+	virtual int main(int argc, char **argv)
+	{
+		// Create a console window for text-output if not available
+		// Use printf or cout to display some text in your program
+		CL_ConsoleWindow console(&quot;Console&quot;);
+		console.redirect_stdio();
+
+		try
+		{
+			// Initialize ClanLib base components
+			CL_SetupCore setup_core;
+
+			// Initialize the ClanLib display component
+			CL_SetupDisplay setup_display;
+
+			// Initialize the ClanLib GL component
+			CL_SetupGL setup_gl;
+
+			// Create a display window
+			CL_DisplayWindow window(&quot;ClanLib application&quot;, 640, 480);
+
+			// Run until someone presses escape
+			while (!CL_Keyboard::get_keycode(CL_KEY_ESCAPE))
+			{
+				// Clear the display in a dark blue nuance
+				// The four arguments are red, green, blue and alpha (defaults to 255)
+				// All color nuances in ClanLib are measured in the interval 0-&gt;255
+				CL_Display::clear(CL_Color(0, 0, 50));
+
+				// Flip the display (using a double-buffer),
+				// showing on the screen what we have drawed
+				// since last call to flip()
+				CL_Display::flip();
+
+				// This call updates input and performs other &quot;housekeeping&quot;
+				// Call this each frame
+				// Also, gives the CPU a rest for 10 milliseconds to catch up
+				CL_System::keep_alive(10);
+			}
+		}
+		// Catch any errors from ClanLib
+		catch (CL_Error err)
+		{
+			// Display the error message
+			std::cout &lt;&lt; err.message.c_str() &lt;&lt; std::endl;
+		}
+
+		// Display console close message and wait for a key
+		console.display_close_message();
+
+		return 0;
+	}
+} app;
+
+
+8. Problems ?
+---------------------------------------------------------------------------
+Please read the FAQ on <A HREF="http://clanlib.org">http://clanlib.org</A> for common errors and explanations!
+
+
+--
+Enjoy,
+The ClanLib development team

Added: trunk/clanlib/doc/README
===================================================================
--- trunk/clanlib/doc/README	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/doc/README	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,85 @@
+Welcome
+-------
+Welcome to ClanLib, a multi-platform game development library.
+
+
+Getting started
+---------------
+PLEASE! Please read the INSTALL files for the platform/compiler you want to use.
+See INSTALL.win32, INSTALL.linux, INSTALL.borland, INSTALL.whatever.
+
+
+Upgrading from earlier ClanLib versions
+---------------------------------------
+If you are upgrading your ClanLib project from earlier ClanLib versions, read the
+file README.upgrade for API changes. The NEWS file will have some details on
+what was upgraded, fixed and added in this specific version.
+
+
+Documentation
+-------------
+If you get any problems, there is a FAQ in the Documentation folder; it might have
+an answer to your questions. Otherwise, read the overviews for specific info on
+the various areas of ClanLib. 
+
+  Examples: Many small examples showing features of ClanLib.
+  Documentation/Overview: Articles about certain features of ClanLib.
+  Documentation/Reference: The complete API reference to all ClanLib classes.
+  Documentation/Tutorial: Some tutorials about game programming with ClanLib.
+  Documentation/FAQ: Frequently asked/answered questions.
+
+YOU ARE NOT SUPPOSED TO READ THE XML FILES, THEY MUST BE CONVERTED TO HTML!
+(OR JUST READ THEM ONLINE ON CLANLIB.ORG)
+
+If you are using Windows, and haven't got the tools required to build the
+documentation, or the distribution of ClanLib you have don't have a Documentation
+folder, you can manually download the documentation packages from
+<A HREF="http://clanlib.org/download.html.">http://clanlib.org/download.html.</A> Also, all documentation is available
+for viewing online at <A HREF="http://clanlib.org/docs.html">http://clanlib.org/docs.html</A>
+ 
+
+Mailing lists
+-------------
+You can subscribe to our mailing lists by visiting the website at
+<A HREF="http://www.clanlib.org/contact.html.">http://www.clanlib.org/contact.html.</A>
+
+
+IRC
+---
+Our official IRC channel is located at irc.freenode.net, channel #clanlib.
+Drop by to meet fellow ClanLibbers and developers! 
+
+
+Making ClanLib even better
+--------------------------
+We are grateful for all the help we can get, and if you wish to contribute with
+anything, don't hesitate to contact us.
+
+If you have fixed something in ClanLib, you can send us a patch. Please have a
+look at the PATCHES file for more detailed information.
+
+If you have discovered a bug, please enter the info into our bugtracker, see 
+<A HREF="http://www.clanlib.org/contact.html">http://www.clanlib.org/contact.html</A> for more information.
+
+A developer's reference is available. This contains all the internal classes for 
+ClanLib which are useful for ClanLib developers.  To enable the reference, go in
+to the Documentation/Reference directory and run 'make dev_ref'. Note that you
+need the same tools as described in the section Documentation to make this.
+
+
+ClanLib Website
+---------------
+Check out ClanLib homepage at:
+
+	<A HREF="http://www.clanlib.org">http://www.clanlib.org</A>
+
+Here you will find:
+- News about ClanLib development
+- Downloads of ClanLib and other required/optional libraries
+- Documentation
+- Links to ClanLib games
+- Much more!
+
+--
+Enjoy,
+The ClanLib development team

Added: trunk/clanlib/doc/README.anjuta
===================================================================
--- trunk/clanlib/doc/README.anjuta	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/doc/README.anjuta	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,9 @@
+Using ClanLib with Anjuta
+
+1. Create a new project, this is done by selecting File-&gt;New Project and following the on screen wizard.  Be sure to select a the Generic/Terminal project type, and also set the programming language to c++.
+
+2. Add an include path for clanlib.  Goto to Settings-&gt;Compiler and Linker Settings and select the Include Paths tab.  In the text box type in the path where ClanLib's include files are located (/usr/local/include/ClanLib-0.8).
+
+3. Import the ClanLib libraries you need.  To do this again goto Settings-&gt;Compiler and Linker Settings and select the Libraries tab.  In the text box type in clanCore and click add.  You should also do this for the other ClanLib libraries such as clanDisplay, clanApp, and clanGL.  Add more as needed.
+
+~shadowarts

Added: trunk/clanlib/doc/README.distros
===================================================================
--- trunk/clanlib/doc/README.distros	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/doc/README.distros	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,11 @@
+Hello distribution maker,
+
+If you happen to make any patches to these sources and think they should be
+incorporated in our next release, don't hestitate to let us know.. we would
+gladly apply any patches that improve ClanLib.
+
+Note that there are several rpm specs in Setup/Unix/ 
+(for the different distributions)
+
+Best regards,
+The ClanLib Team

Added: trunk/clanlib/doc/README.kdevelop
===================================================================
--- trunk/clanlib/doc/README.kdevelop	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/doc/README.kdevelop	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,35 @@
+Making a ClanLib project in KDevelop
+------------------------------------------------------------
+This guide will help you set up a project in KDevelop that
+will use the ClanLib libraries. This is quite simple.
+Make sure you have clanlib installed :)
+
+1. Create a project
+------------------------------------------------------------
+First, Project-&gt;new, then in the Application wizard select
+terminal C++ project. Fill out the rest, and create the
+project.
+
+2. Add the libraries to the project
+------------------------------------------------------------
+Go to Project-&gt;Options
+Then in go to Compiler Options.
+Under additional options put in
+-lclanCore -lclanDisplay -lclanApp -lclanGL
+and then any other additional libraries you need.
+
+Note
+-------------------------------------------------------------
+Cronos (I think that was his name) informed me that KDevelop
+creates large project files (about 1 mb) which is true.  So
+he suggested to run autoproject, then create a custom project
+in KDevelop and so on. I couldn't get this to work very well
+without having to rig everything up and you lose some
+features. So please update this file with the information on
+how to do this if you know how.
+
+Contributed by <A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">lowercase at crappysoft.com</A>
+
+--
+Enjoy,
+The ClanLib development team

Added: trunk/clanlib/doc/README.sdl
===================================================================
--- trunk/clanlib/doc/README.sdl	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/doc/README.sdl	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,52 @@
+In this version of ClanLib we have an experimental version of a classic software
+2d display. We use SDL for this, as we couldn't bother to write such oldskool
+stuff ourselves.
+
+This doesn't mean ClanLib requires SDL, far from it. The normal display is still
+using OpenGL, which it is far more featureful compared to the SDL target,
+and most important, it is hardware accelerated.
+
+But if you have any problems with the OpenGL display, or just want to run your
+game on old hardware, you could try clanSDL.
+
+Note that due to limitations in SDL clanSDL doesn't support everything in the
+ClanLib API:
+
+- You can only create one CL_DisplayWindow.
+- Rotation is not supported.
+- Scaling is not supported.
+- Gradient is not supported.
+- set_color on surfaces and sprites is not supported.
+- Only the default blendfunc set is supported.
+- Because it is software and not hardware accelerated, the amount of
+  alphablending should be taken in consideration.
+
+--
+
+Why should you use clanSDL instead of just SDL ?
+
+Because ClanLib has so much more to offer than a simple display
+API. We have xml resources, high-level network, themable gui, advanced
+sprites, transparent use of gfxformats (jpeg, png, tga, pcx), 
+transparent use of soundinputs (vorbis, mods, wavs, etc) and
+much, much more. And you can now switch from using classic 2D software
+rendering to blazingly fast OpenGL rendering with just a single code line!
+
+Also, lets not forget to mention that our API is C++, putting all
+functionality neatly into manageable and consistent classes.
+
+--
+ 
+How to switch between ClanGL and ClanSDL ?
+
+To use OpenGL in your app, you do the following:
+
+	#include &lt;ClanLib/gl.h&gt;
+	...
+	CL_SetupGL::init();
+
+If you want to use SDL instead, replace it with:
+
+	#include &lt;ClanLib/sdl.h&gt;
+	...
+	CL_SetupSDL::init();

Added: trunk/clanlib/doc/README.upgrade
===================================================================
--- trunk/clanlib/doc/README.upgrade	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/clanlib/doc/README.upgrade	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,903 @@
+This document describes how to port your game from an old ClanLib version to a new one.
+
+Upgrading from 0.7.8 to 0.8.0
+=============================
+
+  1. CL_InputEvent changes
+  ------------------------
+  CL_InputEvent::right/left_alt/shift/ctrl got removed, 
+  use this to check if they are pressed instead: 
+
+    CL_Keyboard::get_keycode(CL_KEY_LSHIFT) // (CL_KEY_LCONTROL, CL_KEY_RCONTROL, etc)
+
+  2. CL_Surface changes
+  ---------------------
+  The CL_Surface_DrawParams got turned into references
+  (they were pointers before):
+
+    void draw(
+      const CL_Surface_DrawParams1&amp; params1,
+      CL_GraphicContext *context = 0);
+    void draw(
+      const CL_Surface_DrawParams2&amp; params2,
+      CL_GraphicContext *context = 0);
+
+  3. CL_PixelBuffer changes
+  -------------------------
+  CL_PixelBuffer is a ref_counted class, thus its no longer needed
+  to manully keep track of the ownership, so all calls which took
+  CL_PixelBuffer* have been changed to use CL_PixelBuffer instead:
+
+    CL_Surface(CL_PixelBuffer*, bool delete_provider);
+
+  was changed to
+
+    CL_Surface(CL_PixelBuffer);
+
+  4. sig_key_dblclk() is gone
+  ---------------------------
+  If you need it, you have to emulate it now yourself via
+  sig_key_down() and CL_System::get_time(). 
+
+  5. CL_InputDevice::keyid_to_string(const std::string &amp;str)
+  ---------------------------------------------------------------------
+  We renamed a function here to more sense what it actually does:
+
+    int CL_InputDevice::keyid_to_string(const std::string &amp;str) const;
+
+  is now called
+
+    int CL_InputDevice::string_to_keyid(const std::string &amp;str) const;
+
+  6. ClanGUI clipping and translation changes
+  ------------------
+  For performance reasons, GUI components do no longer automatically
+  add translation and clipping to the drawing area. If you have a
+  CL_Component and use sig_paint(), you can get the absolute screen
+  coordinates by calling:
+
+    CL_Rectf rect = component-&gt;get_screen_rect();
+
+  If you want to have a clipping section around your component use:
+
+    component-&gt;set_clipping(true);
+
+  7. ClanGUI CL_Window buttons
+  ----------------------------
+  If you want to hook into the close buttons of windows, use
+  CL_Window::sig_close_button_clicked() instead of sig_close().
+  Also have a look at the GUIWindow example to see how you define
+  which buttons go on the titlebar.
+
+
+Upgrading from 0.7.7 to 0.7.8
+=============================
+
+  1. Canvas changes
+  -----------------
+
+    Instead of using surface.get_gc() to get a surface canvas, you now create a CL_Canvas object.
+    Example:
+
+	CL_Surface surface_foo(&quot;foo.png&quot;);
+	CL_Surface surface_bar(&quot;bar.png&quot;);
+	CL_Canvas canvas(surface_foo);
+	surface_bar.draw(5, 5, canvas.get_gc());
+
+    Check the new Canvas example, and the API reference for more information.
+
+  2. Surface changes
+  ------------------
+
+    The Hint parameter to surface construction was removed.
+
+  3. Module initializations
+  -------------------------
+
+    To initialize ClanLib modules, you call CL_SetupCore::init(), CL_SetupDisplay::init(), etc
+    for each module. ::deinit() to de-initialize them.
+
+    This can cause problems, since in some cases objects on the stack are deleted after the
+    deinit of ClanLib modules.
+
+    So, we have added some new initialization classes to help remedy this problem.
+
+    CL_SetupCore::init(); -&gt; CL_SetupCore setup_core;
+    CL_SetupDisplay::init(); -&gt; CL_SetupDisplay setup_display;
+    CL_SetupNetwork::init(); -&gt; CL_SetupNetwork setup_network;
+
+    etc, for all modules. There is no deinit in this new case.
+
+    If you have problems with crashes on shutdown, try to use this alternative initialization.
+
+  4. TargaProvider changes
+  ------------------------
+ 
+    The internal format of images provided by the Targa loader changed. Make sure you don't
+    make any assumptions of the formats returned by the image providers. Check the format
+    using get_format(), and its functions get_red/green/blue/alpha_mask().
+
+
+Upgrading from 0.7.6 to 0.7.7
+=============================
+
+  1. OpenGL state changes 
+  -----------------------
+
+  Instead of begin_3d() / end_3d(), we now have a new method of synchronizing the OpenGL
+  state between ClanLib and your own custom OpenGL code. Please read the new OpenGL
+  Overview on how to use this new class.
+
+  2. CL_Component signal changes
+  ------------------------------
+
+  sig_get_minimum_size / sig_get_maximum_size / sig_get_preferred_size 
+
+  These signals in CL_Component changed from CL_Point to CL_Size, so if you have a custom
+  theme make sure you change the signal function to
+  
+  void ...::on_get_preferred_size(CL_Size &amp;size)
+
+  Note that CL_Size has width and height, compared to CL_Points x and y.
+
+  3. CL_Window construction changes
+  ---------------------------------
+
+  Previously, a CL_Window would always make itself a root component in the GUI hierarchy,
+  no matter what parent component you specificed in its constructor.
+
+  We've changed this behaviour to make it use the parent you give in its constructor.
+  This way a CL_Window behaves the same as all other components, and also makes it possible
+  to create MDI apps.
+
+  To make sure your windows are root components, use get_gui_manager() as the parent.
+  In most cases this is probably what you already do, or the parent IS the root component,
+  so any changes will normally not be required.
+
+
+Upgrading from 0.7.5 to 0.7.6
+=============================
+
+No changes needed.
+
+
+Upgrading from 0.7.4 to 0.7.5
+=============================
+
+1. ClanGUI changes
+------------------
+
+1a. XML used for GUI
+
+  To complete our transition away from proprietary formats, we have now moved the last
+  part over to XML - the GUI definition files.
+
+  GUI definition example of the old format:
+
+    window my_window
+    {
+      x = 10;
+      y = 10;
+      width = 600;
+      height = 400;
+      title = &quot;My Window&quot;;
+	
+      button my_button
+      {
+        text = &quot;My Button&quot;;
+        x = 25;
+        y = 130;
+        width = 100;
+        height = 20;
+      }
+    }
+
+  The same defintion in the new format:
+
+    &lt;components&gt;
+      &lt;window name=&quot;my_window&quot; x=&quot;10&quot; y=&quot;10&quot; width=&quot;600&quot; height=&quot;400&quot; title=&quot;My Window&quot;&gt; 
+        &lt;components&gt;
+          &lt;button name=&quot;my_button&quot; x=&quot;25&quot; y=&quot;130&quot; width=&quot;100&quot; height=&quot;20&quot; text=&quot;My Button&quot; /&gt;
+        &lt;/components&gt;
+      &lt;/window&gt;
+    &lt;/components&gt;
+
+  Since we now use both XML for the resources and gui definition, you can now put them both
+  into the same XML file if you want. Make sure you read the GUI XML Overview for more info
+  about the GUI resource format.
+
+1b. CL_ComponentManager
+
+  We changed the constructors of this class to make less used parameters use default values.
+  Check the reference, it should be plain to see what should be done.
+
+1c. CL_ListBox
+  
+  ListBox now uses pointers internally, so the insert_item(CL_ListItem) function was changed,
+  and minor others. If you have a custom theme, you'll notice that get_items() now return
+  std::vector&lt;CL_ListItem *&gt; instead of std::vector&lt;CL_ListItem&gt;.
+
+
+Upgrading from 0.7.3 to 0.7.4
+=============================
+
+  No API changes.
+
+
+Upgrading from 0.7.2 to 0.7.3
+=============================
+
+1. XML used for resources
+-------------------------
+
+  We threw away our proprietary resource format, and now use XML instead. The changes
+  are mostly cosmetic, but using XML gives us and the user a lot more freedom and
+  flexibility in creating resource-types.
+
+  Resource example of the old format:
+
+    my_surface = my_surface.tga (type=surface);
+    my_integer = 80 (type = integer);
+    my_sample = beep.wav (type = sample);
+
+    section my_fonts
+    {
+      font_glyph = 
+      (
+        type = sprite,
+        image1 = my_font.tga,
+        image1_method = alpha
+      );
+
+      font = 
+      (
+        type = font,
+        glyphs = my_fonts/font_glyph,
+        spacelen = 4,
+        letters = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
+      );
+    }
+
+  The same resources in the new format:
+
+    &lt;resources&gt;
+      &lt;surface name=&quot;my_surface&quot; file=&quot;my_surface.tga&quot; /&gt;
+      &lt;integer name=&quot;my_integer&quot; value=&quot;80&quot; /&gt;
+      &lt;sample name=&quot;my_sample&quot; file=&quot;beep.wav&quot; /&gt;
+
+      &lt;section name=&quot;my_fonts&quot;&gt;
+        &lt;sprite name=&quot;font_glyph&quot;&gt;
+          &lt;image file=&quot;my_font.tga&quot;&gt;&lt;alpha /&gt;&lt;/image&gt;
+        &lt;/sprite&gt;
+
+        &lt;font name=&quot;font&quot;&gt;
+          &lt;bitmap glyphs=&quot;my_fonts/font_glyph&quot; spacelen=&quot;4&quot; letters=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; /&gt;
+        &lt;/font&gt;
+      &lt;/section&gt;
+    &lt;/resources&gt;
+
+  Read the brand new overviews explaining all the resource options!
+
+
+2. Sound must use soundoutput object
+------------------------------------
+
+   If you are using sound in your application, you must create a 
+   CL_SoundOutput object first. CL_SoundOutput is the interface
+   to a sound output device. It is used to control the main mixer
+   volume and other global settings. 
+
+   Example:
+     CL_SetupCore::init();
+     CL_SetupSound::init();
+     CL_SetupVorbis::init();
+
+     CL_SoundOutput sound_output(44100);
+
+
+3. CL_Texture was replaced with CL_OpenGLSurface
+------------------------------------------------
+
+   Example 1 of its usage:
+     CL_OpenGLSurface surface(&quot;texture.jpg&quot;);
+     gc-&gt;begin_3d();
+     surface.bind();
+     renderCoolOpenGLStuff();
+     gc-&gt;end_3d();
+
+   Example 2:
+     CL_Surface surface(&quot;texture.jpg&quot;);
+     CL_OpenGLSurface surface_gl = surface;
+     gc-&gt;begin_3d();
+     surface_gl.bind();
+     renderCoolOpenGLStuff();
+     gc-&gt;end_3d();
+
+
+3. Custom resources
+-------------------
+
+   Custom resources was changed slightly, check the ResourcesCustom for an example 
+   how its done now.
+
+   Note that most users will prolly be happy with the direct-dom approach to 
+   custom resources used in the example Resources.
+
+
+Upgrading from 0.7.0/1 to 0.7.2
+===============================
+
+1. String API changed
+---------------------
+
+  The CL_String class was modified to be a helper-class only. You don't construct 
+  a CL_String anymore as an object, instead you use the standard std::string.
+
+  It might look like this is more work to use now, but it was done so we can use
+  one string construct all over ClanLib, and not mix std::string and CL_String
+  like we did before.
+
+  Using CL_String::format instead of CL_String &lt;&lt; also has its advantages, for 
+  example in localization of your game.
+
+  Examples:
+
+  - CL_String str(&quot;ClanLib&quot;);
+
+    -&gt; must be replaced with -&gt;
+
+    std::string str(&quot;ClanLib&quot;);
+
+  - CL_String str(integer);
+
+    -&gt; must be replaced with -&gt;
+
+    std::string str = CL_String::from_int(integer);
+
+  - CL_String str(10);
+    int i = str.to_int();
+
+    -&gt; must be replaced with -&gt;
+
+    std::string str = CL_String::from_int(10);
+    int i = CL_String::to_int(str);
+
+  - CL_String str; CL_String text(&quot;text&quot;); int number = 10;
+    str &lt;&lt; &quot;Example string with &quot; &lt;&lt; text &lt;&lt; &quot;, &quot; &lt;&lt; number &lt;&lt; &quot;, &quot; &lt;&lt; &quot;yo&quot; &lt;&lt; &quot; and &quot; &lt;&lt; 23 &quot;!&quot;;
+
+    -&gt; must be replaced with -&gt;
+
+    std::string str; std::string text(&quot;text&quot;); int number = 10;
+    str = CL_String::format(&quot;Example string with %1, %2, %3 and %4 !&quot;, text, number, &quot;yo&quot;, 23);
+
+  - CL_String str(&quot;my_string_resource&quot;, resourcemanager);
+
+    -&gt; must be replaced with -&gt;
+
+    std::string str = CL_String::load(&quot;&quot;my_string_resource&quot;, resourcemanager);
+
+
+2. GUI
+------
+
+  The GUI was cleaned up alot in this release. Also, we made themeing alot
+  more flexible.
+
+2a. Default theme was removed
+
+  It was replaced with the Boring and the Silver theme.
+  Replace CL_StyleManager_Default with either CL_StyleManager_Boring
+  or CL_StyleManager_Silver.
+
+  The Boring theme is the old Default theme, but with some features removed
+  (like button-bitmaps). The Silver theme is a completely new theme, which
+  support everything in the old Default theme, and more.
+
+  Resources for the themes was moved from Documentation/Examples/GUIThemeDefault
+  to Resources/GUIStyleSilver and Resources/GUIStyleBoring.
+
+2b. Modal GUI components
+
+  Modal component creation was changed. It is now more logical.
+
+  How it was done earlier:
+	CL_Component comp(..., NULL, style);
+	comp.run(gui);
+
+  How its done now:
+	CL_Component comp(..., gui);
+	comp.run();
+
+  We've removed the need to create separate GUIManagers, so don't do that anymore.
+
+2c. GUI Themeing
+
+  CL_Component::attach_style() was replaced with CL_Component::set_style(), so
+  you need to update your styleManager to reflect this.
+
+2d. CL_Button surface setting
+
+  The surface handling was moved from CL_Button to CL_Button_Silver, so you
+  need to replace:
+
+    CL_Button b(pos, text, surface_up, surface_down, surface_disabled, surface_highlight)
+
+  with
+
+    CL_Button b(pos, text);
+    CL_Button_Silver *b_style = (CL_Button_Silver *) b-&gt;get_style();
+    b_style-&gt;set_surface_up(surface_up);
+    b_style-&gt;set_surface_down(surface_down);
+    b_style-&gt;set_surface_disabled(surface_disabled);
+    b_style-&gt;set_surface_highlighted(surface_highlighted);
+
+  Note that the Boring style no longer support bitmapped buttons.
+
+2e. GUI.scr themes
+
+  In CL_CheckBox and CL_RadioButton, the resource name was changed from sur_ to surface_.
+  For example, in CL_CheckBox:
+
+	Old syntax:
+	sur_checked = checkbox/checked.tga (type=surface);
+	sur_unchecked = checkbox/unchecked.tga (type=surface);
+	sur_checked_disabled = checkbox/checked_disabled.tga (type=surface);
+	sur_unchecked_disabled = checkbox/unchecked_disabled.tga (type=surface);
+	
+	New syntax:
+	surface_checked = checkbox/checked.tga (type=surface);
+	surface_unchecked = checkbox/unchecked.tga (type=surface);
+	surface_checked_disabled = checkbox/checked_disabled.tga (type=surface);
+	surface_unchecked_disabled = checkbox/unchecked_disabled.tga (type=surface);
+
+  This is for both Boring and Silver theme.
+
+2f. CL_ListBox::max_visible_items
+
+  Set/get max visible items was removed. You have to calculate the size of the listbox
+  yourself. This might be reimplemented in the future, though.
+
+2g. CL_Window::set_client_size
+
+  This function was removed. It might be reimplemented in the future, though.
+
+	
+3. begin_2d()/end_2d -&gt; begin_3d()/end_3d()
+-------------------------------------------
+
+  Remove any begin_2d() calls, they were replaced with the invert called
+  begin_3d() - which you call if you need to do something OpenGL specific.
+
+
+
+Upgrading from 0.6.0 to 0.7.0
+=============================
+
+1. Network API has been rewritten
+---------------------------------
+
+ClanLib 0.7.0 now includes the former-known ClanNet2 - replacing the previous
+network API. Some API changes, but the overall structure should be relative 
+easy to understand if you have worked with the previous network API.
+
+2. New Display API
+------------------
+
+ClanDisplay2 is now included in 0.7.0 - replacing the previous ClanDisplay from
+0.6.x. Many API changes, but looking in the reference you shouldn't have too
+much trouble adapting to the new API. More powerful, more streamlined, more flexible.
+
+3. Default GUI theme was separated from clanGUI
+-----------------------------------------------
+
+You now need to link with clanGUIStyle in addition to clanGUI to use the default theme. 
+
+Also, you need to include this:
+#include &lt;ClanLib/guistyle.h&gt;
+
+If you only use a custom theme, you don't need to link with these new libs, nor
+include the guistyle.h file.
+
+4. Minor GUI API adjustments
+----------------------------
+
+	CL_Signal_v2&lt;CL_InputDevice *, const CL_Key &amp;&gt; &amp;CL_Component::sig_input_down()
+	CL_Signal_v2&lt;CL_InputDevice *, const CL_Key &amp;&gt; &amp;CL_Component::sig_input_up()
+
+were changed to:
+
+	CL_Signal_v1&lt;const CL_Key &amp;&gt; &amp;CL_Component::sig_input_down()
+	CL_Signal_v1&lt;const CL_Key &amp;&gt; &amp;CL_Component::sig_input_up()
+
+	Use key.device to get hold of the inputdevice instead.
+
+5. New CL_String class
+----------------------
+The string class was replaced with a new, more powerful one. Should be pretty easy
+to upgrade though.
+
+5. CL_Rect changes
+------------------
+The x1, y1, x2, y2 variables in CL_Rect was replaced with left, top, right, bottom.
+
+
+Upgrading from 0.5.4 to 0.6.0
+=============================
+
+1. Signals have been made consistent all over ClanLib
+-----------------------------------------------------
+In a few cases you need to add a parenthesis to a signal.
+
+Example:
+
+     CL_Timer timer;
+
+     // ClanLib 0.5.x:
+     sig_timer.connect(...)
+
+     // ClanLib 0.6.0:
+     sig_timer().connect(...)
+
+
+The affected signals are as follows:
+
+     CL_Timer::sig_timer
+     CL_Input::sig_button_press
+     CL_Input::sig_button_release
+     CL_Input::sig_mouse_move
+     CL_Mouse::sig_move
+     CL_Mouse::sig_button_press
+     CL_Mouse::sig_button_release
+
+2. Input signals were changed in clanGUI
+----------------------------------------
+
+     CL_Component::sig_key_up(CL_Component *comp, CL_InputDevice *device, const CL_Key &amp;key)
+     CL_Component::sig_key_down(CL_Component *comp, CL_InputDevice *device, const CL_Key &amp;key)
+     CL_Component::sig_mouse_move(CL_Component *comp, int x, int y);
+
+were changed to: 
+
+     CL_Component::sig_key_up(const CL_Key &amp;key)
+     CL_Component::sig_key_down(const CL_Key &amp;key)
+     CL_Component::sig_mouse_move(int x, int y);
+ 
+Also, the following signals were added:
+
+     CL_Component::sig_input_up(CL_InputDevice *device, const CL_Key &amp;key)
+     CL_Component::sig_input_down(CL_InputDevice *device, const CL_Key &amp;key)
+
+sig_key_up/down used to include both mouse and keyboard events, but now sig_key_up/down is
+ONLY keyboard, and the newly added sig_input_up/down is ANY inputdevice (mouse, keyboard,
+joystick, etc). So, if you want the old behaviour, hook into the sig_input instead of sig_key signals.
+
+Remember, you can always use CL_InputDevice::get_type() to check which inputdevice the
+sig_input_up/down got its event from (returns CL_InputDevice::type_mouse, type_joystick,
+type_keyboard).
+
+
+Upgrading from 0.5.2 to 0.5.3
+=============================
+
+1. Default videomode has been set to windowed, and not fullscreen as previously.
+
+   To override default, you specify fullscreen-mode like this:
+	CL_Display::set_videomode(640, 480, 16, true);
+   or, window-mode:
+	CL_Display::set_videomode(640, 480, 16, false);
+
+
+Upgrading from 0.5.1 to 0.5.2
+=============================
+
+1. Resource pathhandling is changed
+-----------------------------------
+Now all resources are loaded with path from the location of the resource file, and 
+not the location of the executable as before.
+
+So, for example, if you have this structure:
+	data/
+	data/images/
+	data/images/surface.tga
+	data/images.scr
+
+Previously, the images.scr would look like this:
+	surface = data/images/surface.tga (type = surface);
+
+Now, it must be changed into:
+	surface = images/surface.tga (type = surface);
+without the first data/, as the resourcefile itself is in the data directory.
+
+
+2. Signal connection API changed
+--------------------------------
+
+Earlier you had to use CL_CreateSlot when connecting to a signal:
+
+	CL_Slot slot = sig_something.connect(CL_CreateSlot(this, &amp;MyApp::on_signal));
+
+It has been modified to this shorter method instead:
+
+	CL_Slot slot = sig_something.connect(this, &amp;MyApp::on_signal);
+
+Just remove CL_CreateSlot from your code, and you're set.
+
+
+Also, we added a handy CL_SlotContainer. If you find it awkward storing all those
+CL_Slot objects, you can do use this instead:
+
+CL_SlotContainer slots; // Put this where you earlier stored your CL_Slot objects. Don't make it local!
+
+...
+
+slots.connect(sig_something, this, &amp;MyApp::on_signal);
+slots.connect(sig_something2, this, &amp;MyApp::on_signal2);
+slots.connect(sig_something_else, this, &amp;MyApp::on_signal_else);
+
+
+3. GUI Themeing
+---------------
+
+If you have created your own StyleManager, you need to remove the 
+	CL_ComponentOptions &amp;options 
+from the
+	void CL_StyleManager::connect_styles(..) function.
+
+For example:
+
+void CL_StyleManager_OpenGL::connect_styles(
+	const std::string &amp;type,
+	CL_Component *owner)
+
+Also, remove the ComponentOptions from all the components. Check
+the GUIGL example for more specific details.
+
+
+-------------------------------------------------------------------------------
+
+
+Upgrading from 0.5.0 to 0.5.1
+=============================
+
+1. CL_Input::sig_mouse_move
+---------------------------
+This signal was moved into the CL_Mouse class, and is now called
+
+	CL_Mouse::sig_move(int x, int y);
+
+
+
+2. ClanGUI
+----------
+Sorry, but this module is so rapidly changing these days, so
+its no use updating this document regarding that.
+
+
+-------------------------------------------------------------------------------
+
+
+Upgrading from 0.4.x to 0.5.0
+=============================
+
+1. Multithreaded on Windows
+2. Separated modules (Sound, Display, Network &amp; Application)
+3. Init/Deinit modules
+4. Debug console
+5. Datafile invocation
+6. Event Chains
+7. Input/OutputSource
+8. Resources
+9. Network
+
+
+1. Multithreaded on Windows
+---------------------------
+ClanLib now uses multithreaded libraries on Windows, and you need to upgrade your
+libraries (zlib, libpng etc) - see <A HREF="http://clanlib.org/download/foreign-win32.html">http://clanlib.org/download/foreign-win32.html</A>
+and download the needed libraries there.
+
+Also, you need to change your own application to use multithreaded libraries:
+
+1.  Select Project-&gt;Settings...
+2.  Select the 'C/C++' tab, and then Category 'Code Generation'
+3a. For Release version, change the 'Use run-time library' to Multithreaded.
+3b. For Debug version, change the 'Use run-time library' to Debug Multithreaded.
+
+
+2. Separated modules (Sound, Display, Network &amp; Application)
+------------------------------------------------------------
+Sound, Display, Network, Application was separated from clanCore, and you need to do
+some changes to the initialization and library including in your game.
+
+  ClanApplication
+  ---------------
+  ClanCore was separated from the CL_ClanApplication initializing, and therefore you need
+  to link with both clanCore and clanApp if you want to use the &quot;standard&quot; way of
+  initializing ClanLib (the easy way).
+
+  Windows:
+	Add clanApp.lib (release) or clanAppd.lib (debug) to your project settings.
+
+  Linux:
+	Add -lclanApp to your Makefile.
+
+  You also need to add this: #include &lt;ClanLib/application.h&gt;
+
+  If you want to initialize ClanLib yourself (for example if you want to use ClanNetwork
+  without anything else from ClanLib), you do not link with ClanApplication,
+  and do a manual initialization.
+
+  ClanDisplay
+  -----------
+  ClanDisplay was separated from ClanCore, and therefore you need to link with both clanCore
+  and clanDisplay.
+
+  Windows:
+	Add clanDisplay.lib (release) or clanDisplayd.lib (debug) to your project settings.
+
+  Linux:
+	Add -lclanDisplay to your Makefile.
+
+  Codewise, you need to replace
+	CL_SetupCore::init_display();
+	CL_SetupCore::deinit_display();
+  with
+	CL_SetupDisplay::init();
+	CL_SetupDisplay::deinit();
+
+  You also need to add this: #include &lt;ClanLib/display.h&gt;
+
+  ClanSound
+  ---------
+  ClanSound was separated from ClanCore, and therefore you need to link with both clanCore
+  and clanSound IF you want to use sound in your game.
+
+  Windows:
+	Add clanSound.lib (release) or clanSoundd.lib (debug) to your project settings.
+
+  Linux:
+	Add -lclanSound to your Makefile.
+
+  Codewise, you need to replace 
+
+	CL_SetupCore::init_sound();
+	CL_SetupCore::deinit_sound();
+  with
+	CL_SetupSound::init();
+	CL_SetupSound::deinit();
+
+  You also need to add this: #include &lt;ClanLib/sound.h&gt;
+
+  ClanNetwork
+  -----------
+  ClanNetwork was separated from ClanCore, and therefore you need to link with both clanCore
+  and clanNetwork IF you want to use network in your game.
+
+  Windows:
+	Add clanNetwork.lib (release) or clanNetworkd.lib (debug) to your project settings.
+
+  Linux:
+	Add -lclanNetwork to your Makefile.
+
+  Codewise, you need to replace 
+
+	CL_SetupCore::init_network();
+	CL_SetupCore::deinit_network();
+  with
+	CL_SetupNetwork::init();
+	CL_SetupNetwork::deinit();
+
+  You also need to add this: #include &lt;ClanLib/network.h&gt;
+
+
+3. Init/Deinit modules
+----------------------
+The CL_ClanApplication no longer uses the init_modules() and deinit_modules()
+functions. Move the initialization into your main() instead, and remove these
+functions. Or, add functions calling init_modules() and deinit_modules() from
+your main().
+
+
+4. Debug console
+----------------
+The debug window under Windows is no longer enabled by default. If you want a
+console window (for std::cout and printf), add this code:
+(at the beginning of CL_Application::main for example)
+
+	CL_ConsoleWindow console(&quot;My console&quot;);
+	console.redirect_stdio();
+
+
+5. Datafile invocation
+----------------------
+Datafile support is no longer enabled by default. To support the feature with
+&quot;app -datafile ...&quot; add something like the following code to your main():
+(You can of course improve this to use filenames from the command line as well)
+
+	... CL_SetupCore::init();
+	... CL_SetupGL::init();
+
+	if (argv[1] == &quot;-datafile&quot;) {
+		CL_DatafileCompiler::write(&quot;my_file.scr&quot;, &quot;my_file.dat&quot;);
+		return;
+	}
+
+	... CL_SetupCore::init_display();
+	... CL_Display::set_videomode(640, 480, 16 false);	
+
+
+Lines starting with ... are just to show where you could put the code.
+
+
+6. Event Chains
+---------------
+Event chains has been removed, and replaced with a signal-system.
+So, if any of your classes inherit the following classes, read on to find out
+how to upgrade your app to the signal system:
+	CL_Event_ButtonRelease
+	CL_Event_ButtonPress
+	CL_Event_WindowResize
+	CL_Event_MouseMove
+	CL_Event_MouseEnter
+	CL_Event_MouseExit
+
+1. Remove these inherited classes from your classes.
+
+2. Replace the lines:
+      CL_Input::chain_button_press.push_back( this );
+      ...
+      CL_Input::chain_button_press.remove( this );
+
+   with 
+
+      CL_Slot slot; // Put this is a non-local location (like your class-header)
+      ...
+      slot = CL_Input::sig_button_press.connect(CL_CreateSlot(this, &amp;MyClass::on_button_press));
+
+This just shows the buttonpress event, the others are similar. Refer to the
+reference for correct API.
+
+
+7. Input/OutputSource
+---------------------
+This change is represented in all CL_InputSource* and CL_OutputSource* classes.
+
+The read_bool() function was renamed to read_bool8().
+The write_bool() function was renamed to write_bool8().
+
+
+8. Resources
+------------
+The resource API has changed a little bit.
+
+First, the construction of the CL_ResourceManager is uses a standard constructor instead
+of the previous ::create() method.
+
+Replace
+	CL_ResourceManager *resource = CL_ResourceManager::create(...);
+with
+	CL_ResourceManager *resource = new CL_ResourceManager(...);
+	or
+	CL_ResourceManager resource(...);
+
+Second, if you use custom resources, go read the new Documentation/Overview about
+resources. It is now much easier to create custom resources, but it uses a different method
+than earlier.
+
+Third, the classes CL_Res_Integer, CL_Res_Boolean and CL_Res_String was replaced with
+CL_Integer, CL_Boolean and CL_String.
+
+Instead of previously doing:
+	int my_integer = CL_Res_Integer::load(&quot;resource_name&quot;, resource_manager);
+you now do:
+	int my_integer = CL_Integer(&quot;resource_name&quot;, resource_manager);
+
+
+9. Network
+----------
+CL_NetGame was renamed to CL_NetSession, as it is now possible to use ClanNetwork
+in other than games; ClanNetwork is no longer dependent on the rest of ClanLib.
+
+Various other stuff was altered in ClanNetwork, but the specifics we cannot recall.
+If you have any additions, please send mail to the mailing-lists.
+

Modified: trunk/lib/SConstruct
===================================================================
--- trunk/lib/SConstruct	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/lib/SConstruct	2006-07-05 04:25:17 UTC (rev 631)
@@ -45,9 +45,15 @@
 #            LIBPATH=['.', '/home/ingo/run/ClanLib-0.8-current//lib/'],
 #            LIBS=['flexlay'])
 
-clanLib_env = Environment()
-clanLib_env.ParseConfig(&quot;pkg-config --cflags --libs clanCore-0.8 clanDisplay-0.8 clanGL-0.8 clanSignals-0.8 clanGUI-0.8 clanGUIStyleSilver-0.8&quot;)
 
+clanLib_env = Environment(CPPPATH=['../clanlib/'],
+                          LIBPATH=['../clanlib/'],
+                          LIBS=['clanCore', 'clanDisplay', 'clanGL', 'clanSignals', 'clanGUI', 'clanGUIStyleSilver'],
+                          )
+# Use this if you want to use your globally installed ClanLib
+#  clanLib_env = Environment()
+#  clanLib_env.ParseConfig(&quot;pkg-config --cflags --libs clanCore-0.8 clanDisplay-0.8 clanGL-0.8 clanSignals-0.8 clanGUI-0.8 clanGUIStyleSilver-0.8&quot;)
+
 libflexlay_env = env.Copy()
 flexlay_lib = libflexlay_env.StaticLibrary(
     target = 'libflexlay.a',

Modified: trunk/supertux/supertux.rb
===================================================================
--- trunk/supertux/supertux.rb	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/supertux/supertux.rb	2006-07-05 04:25:17 UTC (rev 631)
@@ -94,7 +94,7 @@
 
 $config  = Config.new()
 if !$datadir then
-  $datadir = File.expand_path(&quot;~/projects/supertux/data/&quot;)+&quot;/&quot;
+  $datadir = File.expand_path(&quot;~/projects/supertux/trunk/supertux/data/&quot;)+&quot;/&quot;
 end
 
 require &quot;data.rb&quot;

Added: trunk/windstille/main.rb
===================================================================
--- trunk/windstille/main.rb	2006-07-05 03:29:58 UTC (rev 630)
+++ trunk/windstille/main.rb	2006-07-05 04:25:17 UTC (rev 631)
@@ -0,0 +1,25 @@
+##  $Id$
+## 
+##  Flexlay - A Generic 2D Game Editor
+##  Copyright (C) 2004 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+##
+##  This program is free software; you can redistribute it and/or
+##  modify it under the terms of the GNU General Public License
+##  as published by the Free Software Foundation; either version 2
+##  of the License, or (at your option) any later version.
+##
+##  This program is distributed in the hope that it will be useful,
+##  but WITHOUT ANY WARRANTY; without even the implied warranty of
+##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+##  GNU General Public License for more details.
+## 
+##  You should have received a copy of the GNU General Public License
+##  along with this program; if not, write to the Free Software
+##  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+require &quot;windstille.rb&quot;
+
+$editor = WindstilleEditor.new(ARGV)
+$editor.run()
+
+# EOF #


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000127.html">[Flexlay-commit] r630 - trunk/supertux
</A></li>
	<LI>Next message: <A HREF="000128.html">[Flexlay-commit] r632 - trunk/ruby
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#131">[ date ]</a>
              <a href="thread.html#131">[ thread ]</a>
              <a href="subject.html#131">[ subject ]</a>
              <a href="author.html#131">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/flexlay-commit">More information about the Flexlay-commit
mailing list</a><br>
</body></html>
