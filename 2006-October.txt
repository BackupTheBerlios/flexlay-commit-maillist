From grumbel at mail.berlios.de  Tue Oct 17 13:24:49 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Tue, 17 Oct 2006 13:24:49 +0200
Subject: [Flexlay-commit] r645 - in trunk: lib supertux
Message-ID: <200610171124.k9HBOnhI020077@sheep.berlios.de>

Author: grumbel
Date: 2006-10-17 13:24:49 +0200 (Tue, 17 Oct 2006)
New Revision: 645

Modified:
   trunk/lib/generated_brush.hxx
   trunk/supertux/gui.rb
   trunk/supertux/supertux.rb
Log:
- small stuff

Modified: trunk/lib/generated_brush.hxx
===================================================================
--- trunk/lib/generated_brush.hxx	2006-07-24 07:36:13 UTC (rev 644)
+++ trunk/lib/generated_brush.hxx	2006-10-17 11:24:49 UTC (rev 645)
@@ -45,8 +45,8 @@
   void  set_radius(float radius);
   float get_radius();
 
-  void set_spikes(int spikes);
-  int  get_spikes();
+  void  set_spikes(int spikes);
+  int   get_spikes();
 
   void  set_hardness(float hardness);
   float get_hardness();

Modified: trunk/supertux/gui.rb
===================================================================
--- trunk/supertux/gui.rb	2006-07-24 07:36:13 UTC (rev 644)
+++ trunk/supertux/gui.rb	2006-10-17 11:24:49 UTC (rev 645)
@@ -43,6 +43,7 @@
 
     @workspace.set_tool(106, $workspace_move_tool.to_tool())
     @workspace.set_tool(107, $zoom2_tool.to_tool())
+    @workspace.set_tool(65507, $zoom2_tool.to_tool())
 
     @minimap = Minimap.new(@editor_map, minimap_rect, @gui.get_component())
 

Modified: trunk/supertux/supertux.rb
===================================================================
--- trunk/supertux/supertux.rb	2006-07-24 07:36:13 UTC (rev 644)
+++ trunk/supertux/supertux.rb	2006-10-17 11:24:49 UTC (rev 645)
@@ -51,9 +51,11 @@
 require "sexpr.rb"
 
 flexlay = Flexlay.new()
-width = 1024
+width  = 1024
 height = 768
-flexlay.init("SuperTux Editor", width, height)
+fullscreen = false
+resizeable = true
+flexlay.init("SuperTux Editor", width, height, fullscreen, resizeable)
 
 # Tools
 $tilemap_paint_tool  = TileMapPaintTool.new()



From grumbel at mail.berlios.de  Wed Oct 18 22:56:11 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Wed, 18 Oct 2006 22:56:11 +0200
Subject: [Flexlay-commit] r646 - in trunk: . flexlay
Message-ID: <200610182056.k9IKuBmd025759@sheep.berlios.de>

Author: grumbel
Date: 2006-10-18 22:56:11 +0200 (Wed, 18 Oct 2006)
New Revision: 646

Added:
   trunk/flexlay/
   trunk/flexlay/AUTHORS
   trunk/flexlay/COPYING
   trunk/flexlay/ChangeLog
   trunk/flexlay/INSTALL
   trunk/flexlay/NEWS
   trunk/flexlay/README
   trunk/flexlay/SConstruct
   trunk/flexlay/TODO
   trunk/flexlay/clanlib/
   trunk/flexlay/contrib/
   trunk/flexlay/data/
   trunk/flexlay/guile/
   trunk/flexlay/lib/
   trunk/flexlay/netpanzer/
   trunk/flexlay/paint/
   trunk/flexlay/pingus/
   trunk/flexlay/python/
   trunk/flexlay/ruby/
   trunk/flexlay/supertux-portable/
   trunk/flexlay/supertux/
   trunk/flexlay/test/
   trunk/flexlay/windstille/
Removed:
   trunk/AUTHORS
   trunk/COPYING
   trunk/ChangeLog
   trunk/INSTALL
   trunk/NEWS
   trunk/README
   trunk/SConstruct
   trunk/TODO
   trunk/clanlib/
   trunk/contrib/
   trunk/data/
   trunk/guile/
   trunk/lib/
   trunk/netpanzer/
   trunk/paint/
   trunk/pingus/
   trunk/python/
   trunk/ruby/
   trunk/supertux-portable/
   trunk/supertux/
   trunk/test/
   trunk/windstille/
Log:
- move flexlay from trunk into subdirectory

Deleted: trunk/AUTHORS
===================================================================
--- trunk/AUTHORS	2006-10-17 11:24:49 UTC (rev 645)
+++ trunk/AUTHORS	2006-10-18 20:56:11 UTC (rev 646)
@@ -1,5 +0,0 @@
-Programming
-===========
-  Ingo Ruhnke <grumbel at gmx.de>
-
-# EOF #

Deleted: trunk/COPYING
===================================================================
--- trunk/COPYING	2006-10-17 11:24:49 UTC (rev 645)
+++ trunk/COPYING	2006-10-18 20:56:11 UTC (rev 646)
@@ -1,340 +0,0 @@
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.
-     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Library General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-	    How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) year  name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Library General
-Public License instead of this License.

Deleted: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2006-10-17 11:24:49 UTC (rev 645)
+++ trunk/ChangeLog	2006-10-18 20:56:11 UTC (rev 646)
@@ -1,744 +0,0 @@
-------------------------------------------------------------------------
-r147 | grumbel | 2004-01-10 03:19:28 +0100 (Sat, 10 Jan 2004) | 1 line
-
-
-------------------------------------------------------------------------
-r146 | grumbel | 2003-12-11 14:13:29 +0100 (Thu, 11 Dec 2003) | 2 lines
-
-- fixed frame counter
-
-------------------------------------------------------------------------
-r145 | grumbel | 2003-12-11 14:03:34 +0100 (Thu, 11 Dec 2003) | 1 line
-
-- added input/ to configure
-------------------------------------------------------------------------
-r144 | grumbel | 2003-12-11 13:59:21 +0100 (Thu, 11 Dec 2003) | 1 line
-
-- added input recording and video recording
-------------------------------------------------------------------------
-r143 | grumbel | 2003-12-05 21:57:30 +0100 (Fri, 05 Dec 2003) | 1 line
-
-- added clanlib gui stuff
-------------------------------------------------------------------------
-r142 | grumbel | 2003-12-02 22:21:13 +0100 (Tue, 02 Dec 2003) | 1 line
-
-- some cleanup of obsolote files
-------------------------------------------------------------------------
-r141 | grumbel | 2003-12-02 22:04:30 +0100 (Tue, 02 Dec 2003) | 1 line
-
-- added ignorance
-------------------------------------------------------------------------
-r138 | grumbel | 2003-12-02 17:50:41 +0100 (Tue, 02 Dec 2003) | 2 lines
-
-- disabled readline support
-
-------------------------------------------------------------------------
-r137 | grumbel | 2003-11-13 13:59:42 +0100 (Thu, 13 Nov 2003) | 2 lines
-
-- some minor bug fixes
-
-------------------------------------------------------------------------
-r136 | grumbel | 2003-11-11 15:19:04 +0100 (Tue, 11 Nov 2003) | 2 lines
-
-*** empty log message ***
-
-------------------------------------------------------------------------
-r135 | grumbel | 2003-11-07 23:41:18 +0100 (Fri, 07 Nov 2003) | 2 lines
-
-- fixed a bunch of issues that my last commit broke
-
-------------------------------------------------------------------------
-r134 | grumbel | 2003-11-07 14:00:39 +0100 (Fri, 07 Nov 2003) | 2 lines
-
-- restructed the startup a bit
-
-------------------------------------------------------------------------
-r133 | grumbel | 2003-11-06 15:44:48 +0100 (Thu, 06 Nov 2003) | 2 lines
-
-what do you do in CVS?
-
-------------------------------------------------------------------------
-r132 | grumbel | 2003-11-06 11:32:22 +0100 (Thu, 06 Nov 2003) | 2 lines
-
-- finalized the extra screen
-
-------------------------------------------------------------------------
-r131 | grumbel | 2003-11-06 10:53:43 +0100 (Thu, 06 Nov 2003) | 2 lines
-
-- more extra pics + timing for the bonus screen
-
-------------------------------------------------------------------------
-r130 | grumbel | 2003-11-06 10:47:16 +0100 (Thu, 06 Nov 2003) | 2 lines
-
-- more images
-
-------------------------------------------------------------------------
-r129 | grumbel | 2003-11-06 10:24:17 +0100 (Thu, 06 Nov 2003) | 2 lines
-
-- added better music support
-
-------------------------------------------------------------------------
-r128 | grumbel | 2003-11-06 00:00:27 +0100 (Thu, 06 Nov 2003) | 2 lines
-
-missing music
-
-------------------------------------------------------------------------
-r127 | grumbel | 2003-11-05 23:51:27 +0100 (Wed, 05 Nov 2003) | 2 lines
-
-- added some missing files
-
-------------------------------------------------------------------------
-r126 | grumbel | 2003-11-05 23:44:49 +0100 (Wed, 05 Nov 2003) | 2 lines
-
-- added extra's screen
-
-------------------------------------------------------------------------
-r125 | grumbel | 2003-11-05 14:36:17 +0100 (Wed, 05 Nov 2003) | 2 lines
-
-- fixed kill and respawn behaviour
-
-------------------------------------------------------------------------
-r124 | grumbel | 2003-11-05 13:41:37 +0100 (Wed, 05 Nov 2003) | 2 lines
-
-- added half working dead animation
-
-------------------------------------------------------------------------
-r123 | grumbel | 2003-11-05 12:09:36 +0100 (Wed, 05 Nov 2003) | 2 lines
-
-- added light and exit marker
-
-------------------------------------------------------------------------
-r122 | grumbel | 2003-11-04 23:48:51 +0100 (Tue, 04 Nov 2003) | 2 lines
-
-- fixed fadeout a bit
-
-------------------------------------------------------------------------
-r121 | grumbel | 2003-10-29 16:34:43 +0100 (Wed, 29 Oct 2003) | 2 lines
-
-- added joystick support
-
-------------------------------------------------------------------------
-r120 | grumbel | 2003-10-12 17:22:31 +0200 (Sun, 12 Oct 2003) | 2 lines
-
-missing file
-
-------------------------------------------------------------------------
-r119 | grumbel | 2003-10-12 13:58:09 +0200 (Sun, 12 Oct 2003) | 3 lines
-
-- added gui style
-- added some more or less usefull stuff to the gamegui
-
-------------------------------------------------------------------------
-r118 | grumbel | 2003-10-11 14:15:59 +0200 (Sat, 11 Oct 2003) | 2 lines
-
-- moved some stuff from WindstilleGame into ViewComponent
-
-------------------------------------------------------------------------
-r117 | grumbel | 2003-10-11 10:11:59 +0200 (Sat, 11 Oct 2003) | 3 lines
-
-- removed some now reduntant editor code
-- cleaned up gui a bit
-
-------------------------------------------------------------------------
-r116 | grumbel | 2003-10-10 23:06:22 +0200 (Fri, 10 Oct 2003) | 5 lines
-
-- some little compile fixes
-- fixed naming conflict between X11 and Windstille classes
-- seperated editor gui code into its own class
-- added gui to the game itself (just for debugging)
-
-------------------------------------------------------------------------
-r115 | grumbel | 2003-10-01 01:01:06 +0200 (Wed, 01 Oct 2003) | 2 lines
-
-- added some missing tiles
-
-------------------------------------------------------------------------
-r114 | grumbel | 2003-09-30 18:47:39 +0200 (Tue, 30 Sep 2003) | 2 lines
-
-- fixed broken igel
-
-------------------------------------------------------------------------
-r113 | grumbel | 2003-09-30 18:42:26 +0200 (Tue, 30 Sep 2003) | 3 lines
-
-- added startup dialog
-- added dynamic resize of dialog box
-
-------------------------------------------------------------------------
-r112 | grumbel | 2003-09-30 00:20:57 +0200 (Tue, 30 Sep 2003) | 2 lines
-
-- added clanSound/Vorbis check
-
-------------------------------------------------------------------------
-r111 | grumbel | 2003-09-29 23:51:40 +0200 (Mon, 29 Sep 2003) | 2 lines
-
-- added music
-
-------------------------------------------------------------------------
-r110 | grumbel | 2003-09-29 23:26:46 +0200 (Mon, 29 Sep 2003) | 2 lines
-
-- added some fadeout stuff
-
-------------------------------------------------------------------------
-r109 | grumbel | 2003-09-29 21:56:42 +0200 (Mon, 29 Sep 2003) | 2 lines
-
-- made menu useable
-
-------------------------------------------------------------------------
-r108 | grumbel | 2003-09-29 21:29:17 +0200 (Mon, 29 Sep 2003) | 2 lines
-
-- added (non-working) menu
-
-------------------------------------------------------------------------
-r107 | grumbel | 2003-09-28 18:58:04 +0200 (Sun, 28 Sep 2003) | 2 lines
-
-- added functions to adjust game speed
-
-------------------------------------------------------------------------
-r106 | grumbel | 2003-09-28 13:00:25 +0200 (Sun, 28 Sep 2003) | 2 lines
-
-- added bomb/igel collision
-
-------------------------------------------------------------------------
-r105 | grumbel | 2003-09-28 12:55:34 +0200 (Sun, 28 Sep 2003) | 2 lines
-
-- added bomb/igel collision
-
-------------------------------------------------------------------------
-r104 | grumbel | 2003-09-27 22:57:39 +0200 (Sat, 27 Sep 2003) | 2 lines
-
-- fixed igel a bit, added diamond counting
-
-------------------------------------------------------------------------
-r103 | grumbel | 2003-09-27 10:29:12 +0200 (Sat, 27 Sep 2003) | 3 lines
-
-- added another tree tile
-- added function to return the passed time
-
-------------------------------------------------------------------------
-r102 | grumbel | 2003-09-26 16:29:36 +0200 (Fri, 26 Sep 2003) | 2 lines
-
-- added per level scripts
-
-------------------------------------------------------------------------
-r101 | grumbel | 2003-09-24 20:19:13 +0200 (Wed, 24 Sep 2003) | 2 lines
-
-- some more diamond support
-
-------------------------------------------------------------------------
-r100 | grumbel | 2003-09-24 13:52:00 +0200 (Wed, 24 Sep 2003) | 2 lines
-
-- more levels
-
-------------------------------------------------------------------------
-r99 | grumbel | 2003-09-24 13:49:19 +0200 (Wed, 24 Sep 2003) | 2 lines
-
-- completed level9 a bit more
-
-------------------------------------------------------------------------
-r98 | grumbel | 2003-09-24 01:08:00 +0200 (Wed, 24 Sep 2003) | 2 lines
-
-- new level
-
-------------------------------------------------------------------------
-r97 | grumbel | 2003-09-24 00:10:40 +0200 (Wed, 24 Sep 2003) | 2 lines
-
-- some more tool seperation
-
-------------------------------------------------------------------------
-r96 | grumbel | 2003-09-23 21:41:23 +0200 (Tue, 23 Sep 2003) | 2 lines
-
-- small level
-
-------------------------------------------------------------------------
-r95 | grumbel | 2003-09-23 21:33:43 +0200 (Tue, 23 Sep 2003) | 2 lines
-
-- added limitation to view pos
-
-------------------------------------------------------------------------
-r94 | grumbel | 2003-09-23 21:10:05 +0200 (Tue, 23 Sep 2003) | 2 lines
-
-- seperated tilemap tool  into seperate class
-
-------------------------------------------------------------------------
-r93 | grumbel | 2003-09-23 12:48:03 +0200 (Tue, 23 Sep 2003) | 3 lines
-
-- improved some tiles
-- let editor keep track of the name of the current level
-
-------------------------------------------------------------------------
-r92 | grumbel | 2003-09-22 20:37:05 +0200 (Mon, 22 Sep 2003) | 2 lines
-
-- added tile editor
-
-------------------------------------------------------------------------
-r91 | grumbel | 2003-09-22 11:13:16 +0200 (Mon, 22 Sep 2003) | 2 lines
-
-- more tiles
-
-------------------------------------------------------------------------
-r90 | grumbel | 2003-09-22 00:10:29 +0200 (Mon, 22 Sep 2003) | 2 lines
-
-- some tile stuff
-
-------------------------------------------------------------------------
-r89 | grumbel | 2003-09-21 23:57:40 +0200 (Sun, 21 Sep 2003) | 2 lines
-
-- added some new tiles with new naming convention
-
-------------------------------------------------------------------------
-r88 | grumbel | 2003-09-21 20:24:37 +0200 (Sun, 21 Sep 2003) | 2 lines
-
-- added readline check
-
-------------------------------------------------------------------------
-r87 | grumbel | 2003-09-21 20:05:21 +0200 (Sun, 21 Sep 2003) | 2 lines
-
-- optimized tiledrawing a bit (speed from 90% CPU usage to something hardly noticable ;)
-
-------------------------------------------------------------------------
-r86 | grumbel | 2003-09-21 19:34:54 +0200 (Sun, 21 Sep 2003) | 2 lines
-
-- some dialog triggery
-
-------------------------------------------------------------------------
-r85 | grumbel | 2003-09-21 17:22:59 +0200 (Sun, 21 Sep 2003) | 2 lines
-
-- hooked up dialog stuff a bit into the scripting
-
-------------------------------------------------------------------------
-r84 | grumbel | 2003-09-21 10:49:47 +0200 (Sun, 21 Sep 2003) | 2 lines
-
-some more image goodiness
-
-------------------------------------------------------------------------
-r83 | grumbel | 2003-09-20 23:55:57 +0200 (Sat, 20 Sep 2003) | 2 lines
-
-- seperated some junk out of windstille_game
-
-------------------------------------------------------------------------
-r82 | grumbel | 2003-09-20 23:53:38 +0200 (Sat, 20 Sep 2003) | 3 lines
-
-- fixed jump behaviour
-- cleaned up controller and made it event driven (more or less)
-
-------------------------------------------------------------------------
-r81 | grumbel | 2003-09-17 20:48:45 +0200 (Wed, 17 Sep 2003) | 2 lines
-
-- added some simple trigger code
-
-------------------------------------------------------------------------
-r80 | grumbel | 2003-09-15 19:00:38 +0200 (Mon, 15 Sep 2003) | 2 lines
-
-- fixed stuff to suit clanlib-0.7 cvs
-
-------------------------------------------------------------------------
-r79 | grumbel | 2003-09-13 20:37:57 +0200 (Sat, 13 Sep 2003) | 2 lines
-
-*** empty log message ***
-
-------------------------------------------------------------------------
-r78 | grumbel | 2003-09-13 20:01:17 +0200 (Sat, 13 Sep 2003) | 2 lines
-
-*** empty log message ***
-
-------------------------------------------------------------------------
-r77 | grumbel | 2003-09-13 19:54:40 +0200 (Sat, 13 Sep 2003) | 2 lines
-
-- some more gfx
-
-------------------------------------------------------------------------
-r76 | grumbel | 2003-09-13 12:19:08 +0200 (Sat, 13 Sep 2003) | 2 lines
-
-- fixed update behaviour a bit
-
-------------------------------------------------------------------------
-r75 | grumbel | 2003-09-13 12:11:33 +0200 (Sat, 13 Sep 2003) | 2 lines
-
-- added a first enemy and energie
-
-------------------------------------------------------------------------
-r74 | grumbel | 2003-09-13 00:41:06 +0200 (Sat, 13 Sep 2003) | 2 lines
-
-- added some stupid code to collect diamonds
-
-------------------------------------------------------------------------
-r73 | grumbel | 2003-09-13 00:14:03 +0200 (Sat, 13 Sep 2003) | 2 lines
-
-- added energiebar
-
-------------------------------------------------------------------------
-r72 | grumbel | 2003-09-12 23:43:21 +0200 (Fri, 12 Sep 2003) | 2 lines
-
-- changed splash function
-
-------------------------------------------------------------------------
-r71 | grumbel | 2003-09-12 22:57:29 +0200 (Fri, 12 Sep 2003) | 2 lines
-
-- some cleanup
-
-------------------------------------------------------------------------
-r70 | grumbel | 2003-09-12 22:17:06 +0200 (Fri, 12 Sep 2003) | 4 lines
-
-- added watersplash
-- added water to levelfile
-- seperated scripting a bit
-
-------------------------------------------------------------------------
-r69 | grumbel | 2003-09-12 18:31:21 +0200 (Fri, 12 Sep 2003) | 2 lines
-
-- added diamonds and water
-
-------------------------------------------------------------------------
-r68 | grumbel | 2003-09-12 11:25:48 +0200 (Fri, 12 Sep 2003) | 2 lines
-
-- fixed out-of-bounce crash
-
-------------------------------------------------------------------------
-r67 | grumbel | 2003-09-12 10:27:41 +0200 (Fri, 12 Sep 2003) | 2 lines
-
-- another experimental level
-
-------------------------------------------------------------------------
-r66 | grumbel | 2003-09-11 22:11:01 +0200 (Thu, 11 Sep 2003) | 2 lines
-
-- added some simple file dialogs
-
-------------------------------------------------------------------------
-r65 | grumbel | 2003-09-11 20:58:19 +0200 (Thu, 11 Sep 2003) | 2 lines
-
-- added some load save stuff
-
-------------------------------------------------------------------------
-r64 | grumbel | 2003-09-10 20:56:03 +0200 (Wed, 10 Sep 2003) | 2 lines
-
-- added support for multilayer tilemaps
-
-------------------------------------------------------------------------
-r63 | grumbel | 2003-09-10 15:58:30 +0200 (Wed, 10 Sep 2003) | 4 lines
-
-- added tile selector to the editor
-- fixed few bugs in editor code
-- editor now already half useable
-
-------------------------------------------------------------------------
-r62 | grumbel | 2003-09-10 15:53:11 +0200 (Wed, 10 Sep 2003) | 4 lines
-
-- added tile selector to the editor
-- fixed few bugs in editor code
-- editor now already half useable
-
-------------------------------------------------------------------------
-r61 | grumbel | 2003-09-10 12:58:29 +0200 (Wed, 10 Sep 2003) | 2 lines
-
-- fixed the editor a bit, scrolling around and viewing levels is now possible
-
-------------------------------------------------------------------------
-r60 | grumbel | 2003-09-10 10:25:29 +0200 (Wed, 10 Sep 2003) | 3 lines
-
-- started editor rewrite
-- added scripting support for gui (still pretty much experimental)
-
-------------------------------------------------------------------------
-r59 | grumbel | 2003-09-08 21:59:57 +0200 (Mon, 08 Sep 2003) | 4 lines
-
-- made the game independed of the start path
-- moved args_parse into ClanLib
-- added CL_CommandLine argument parsing
-
-------------------------------------------------------------------------
-r58 | grumbel | 2003-09-07 23:01:45 +0200 (Sun, 07 Sep 2003) | 2 lines
-
-- changed API to be more DirectoryScanner like
-
-------------------------------------------------------------------------
-r57 | grumbel | 2003-09-06 22:38:18 +0200 (Sat, 06 Sep 2003) | 3 lines
-
-- ClanLib nameing style and indention
-- _Generic seperation
-
-------------------------------------------------------------------------
-r56 | grumbel | 2003-09-06 19:29:07 +0200 (Sat, 06 Sep 2003) | 2 lines
-
-- added special handling for usage and extra docu
-
-------------------------------------------------------------------------
-r55 | grumbel | 2003-09-06 17:13:18 +0200 (Sat, 06 Sep 2003) | 2 lines
-
-- fixed bug that caused a single '-' not to be threaded as rest argument
-
-------------------------------------------------------------------------
-r54 | grumbel | 2003-09-06 17:05:10 +0200 (Sat, 06 Sep 2003) | 2 lines
-
-changed class layout a bit so that one doesn't have to derive from ArgsParse
-
-------------------------------------------------------------------------
-r53 | grumbel | 2003-09-06 13:48:01 +0200 (Sat, 06 Sep 2003) | 2 lines
-
-added docu
-
-------------------------------------------------------------------------
-r52 | grumbel | 2003-09-06 13:14:16 +0200 (Sat, 06 Sep 2003) | 3 lines
-
-- added support for --foobar=foo style options
-- option argument is now printed in help
-
-------------------------------------------------------------------------
-r51 | grumbel | 2003-09-05 22:41:52 +0200 (Fri, 05 Sep 2003) | 2 lines
-
-- added argument parser
-
-------------------------------------------------------------------------
-r50 | grumbel | 2003-09-05 00:51:04 +0200 (Fri, 05 Sep 2003) | 3 lines
-
-- fixed bug in scaling collision check
-- added seperate x/y axis for scaling collision check
-
-------------------------------------------------------------------------
-r49 | grumbel | 2003-09-03 00:25:23 +0200 (Wed, 03 Sep 2003) | 2 lines
-
-- fixed bug in scaling test, but still buggy
-
-------------------------------------------------------------------------
-r48 | grumbel | 2003-09-03 00:05:02 +0200 (Wed, 03 Sep 2003) | 3 lines
-
-- added collisionsprite
-- added some support for scaling (broken)
-
-------------------------------------------------------------------------
-r47 | grumbel | 2003-09-02 15:52:04 +0200 (Tue, 02 Sep 2003) | 2 lines
-
-- added benchmark
-
-------------------------------------------------------------------------
-r46 | grumbel | 2003-09-02 15:51:43 +0200 (Tue, 02 Sep 2003) | 2 lines
-
-replaced a few 32 with int_width
-
-------------------------------------------------------------------------
-r45 | grumbel | 2003-09-02 13:16:35 +0200 (Tue, 02 Sep 2003) | 2 lines
-
-- a bug fix and some docu
-
-------------------------------------------------------------------------
-r44 | grumbel | 2003-09-02 13:01:44 +0200 (Tue, 02 Sep 2003) | 2 lines
-
-- seems to work now and I might even know why... time for some more testing
-
-------------------------------------------------------------------------
-r43 | grumbel | 2003-09-02 12:33:01 +0200 (Tue, 02 Sep 2003) | 2 lines
-
-- seems to work, not sure why
-
-------------------------------------------------------------------------
-r42 | grumbel | 2003-09-02 01:43:16 +0200 (Tue, 02 Sep 2003) | 2 lines
-
-- at least 32xHEIGHT is working, rest not, but doesn't look completly wrong
-
-------------------------------------------------------------------------
-r41 | grumbel | 2003-09-01 22:56:57 +0200 (Mon, 01 Sep 2003) | 2 lines
-
-- at least 32xHEIGHT is working...
-
-------------------------------------------------------------------------
-r40 | grumbel | 2003-09-01 17:36:02 +0200 (Mon, 01 Sep 2003) | 2 lines
-
-- some code for pixel perfect collisions
-
-------------------------------------------------------------------------
-r39 | grumbel | 2003-08-28 19:15:31 +0200 (Thu, 28 Aug 2003) | 2 lines
-
-start script for windows
-
-------------------------------------------------------------------------
-r38 | grumbel | 2003-08-23 10:32:28 +0200 (Sat, 23 Aug 2003) | 2 lines
-
-- new music
-
-------------------------------------------------------------------------
-r37 | grumbel | 2003-08-19 15:49:37 +0200 (Tue, 19 Aug 2003) | 2 lines
-
-- removed obsolete files
-
-------------------------------------------------------------------------
-r36 | grumbel | 2003-08-19 15:40:48 +0200 (Tue, 19 Aug 2003) | 2 lines
-
-- added missing assert.h's
-
-------------------------------------------------------------------------
-r35 | grumbel | 2003-08-19 12:33:20 +0200 (Tue, 19 Aug 2003) | 2 lines
-
-- more tiles
-
-------------------------------------------------------------------------
-r34 | grumbel | 2003-08-18 21:53:05 +0200 (Mon, 18 Aug 2003) | 2 lines
-
-- more tiles
-
-------------------------------------------------------------------------
-r33 | grumbel | 2003-08-18 17:14:43 +0200 (Mon, 18 Aug 2003) | 2 lines
-
-- increased level size a bit, more tiles
-
-------------------------------------------------------------------------
-r32 | grumbel | 2003-08-18 10:52:06 +0200 (Mon, 18 Aug 2003) | 2 lines
-
-- added windstille binary start script
-
-------------------------------------------------------------------------
-r31 | grumbel | 2003-08-18 10:50:22 +0200 (Mon, 18 Aug 2003) | 3 lines
-
-- added a few more gfx
-- added a second tile layer (background-tilemap)
-
-------------------------------------------------------------------------
-r30 | grumbel | 2003-08-13 15:49:32 +0200 (Wed, 13 Aug 2003) | 2 lines
-
-- fixed build rules, made release
-
-------------------------------------------------------------------------
-r29 | grumbel | 2003-08-13 01:41:48 +0200 (Wed, 13 Aug 2003) | 2 lines
-
-- added code for static linking
-
-------------------------------------------------------------------------
-r28 | grumbel | 2003-08-12 21:38:08 +0200 (Tue, 12 Aug 2003) | 2 lines
-
-- fixed make dist
-
-------------------------------------------------------------------------
-r27 | grumbel | 2003-08-12 21:30:02 +0200 (Tue, 12 Aug 2003) | 2 lines
-
-- cleanup
-
-------------------------------------------------------------------------
-r26 | grumbel | 2003-08-12 21:24:21 +0200 (Tue, 12 Aug 2003) | 2 lines
-
-- cleanup
-
-------------------------------------------------------------------------
-r25 | grumbel | 2003-08-12 21:09:50 +0200 (Tue, 12 Aug 2003) | 2 lines
-
-- cleanup
-
-------------------------------------------------------------------------
-r24 | grumbel | 2003-08-12 16:37:03 +0200 (Tue, 12 Aug 2003) | 4 lines
-
-- added darkning
-- added logo
-- updated INSTALL and README
-
-------------------------------------------------------------------------
-r23 | grumbel | 2003-08-12 16:34:56 +0200 (Tue, 12 Aug 2003) | 2 lines
-
-- more gfx
-
-------------------------------------------------------------------------
-r22 | grumbel | 2003-08-12 10:58:49 +0200 (Tue, 12 Aug 2003) | 2 lines
-
-- added indicator for current active tile
-
-------------------------------------------------------------------------
-r21 | grumbel | 2003-08-12 10:24:41 +0200 (Tue, 12 Aug 2003) | 3 lines
-
-- fixed copyright header
-- some cleanup
-
-------------------------------------------------------------------------
-r20 | grumbel | 2003-08-11 23:50:35 +0200 (Mon, 11 Aug 2003) | 3 lines
-
-- tweaked the player behaviour a little bit
-- added friendlier sky color
-
-------------------------------------------------------------------------
-r19 | grumbel | 2003-08-11 22:26:07 +0200 (Mon, 11 Aug 2003) | 2 lines
-
-- some cleanup and new gfx
-
-------------------------------------------------------------------------
-r18 | grumbel | 2003-08-11 21:54:22 +0200 (Mon, 11 Aug 2003) | 2 lines
-
-- fixed crash bug
-
-------------------------------------------------------------------------
-r17 | grumbel | 2003-08-11 21:50:12 +0200 (Mon, 11 Aug 2003) | 3 lines
-
-- cleaned level format up a bit
-- integrated tile factory
-
-------------------------------------------------------------------------
-r16 | grumbel | 2003-08-11 13:19:41 +0200 (Mon, 11 Aug 2003) | 2 lines
-
-- cleanup, added handling for sub-tile collision
-
-------------------------------------------------------------------------
-r15 | grumbel | 2003-08-11 13:18:11 +0200 (Mon, 11 Aug 2003) | 2 lines
-
-- added definition file for tiles
-
-------------------------------------------------------------------------
-r14 | grumbel | 2003-08-11 12:04:38 +0200 (Mon, 11 Aug 2003) | 2 lines
-
-- cleanup, added handling for sub-tile collision
-
-------------------------------------------------------------------------
-r13 | grumbel | 2003-08-11 10:03:23 +0200 (Mon, 11 Aug 2003) | 3 lines
-
-- added support for 128x128 tiles
-- added colorfull background gradient
-
-------------------------------------------------------------------------
-r12 | grumbel | 2003-08-11 00:55:50 +0200 (Mon, 11 Aug 2003) | 2 lines
-
-- replaced xml with guile
-
-------------------------------------------------------------------------
-r11 | grumbel | 2003-08-10 21:58:39 +0200 (Sun, 10 Aug 2003) | 2 lines
-
-- renamed files to lowercase
-
-------------------------------------------------------------------------
-r10 | grumbel | 2003-08-10 21:30:03 +0200 (Sun, 10 Aug 2003) | 2 lines
-
-- fixed game to compile and run again
-
-------------------------------------------------------------------------
-r9 | grumbel | 2003-08-06 19:29:19 +0200 (Wed, 06 Aug 2003) | 2 lines
-
-- some CL0.7 fixes
-
-------------------------------------------------------------------------
-r8 | grumbel | 2003-08-06 19:16:19 +0200 (Wed, 06 Aug 2003) | 2 lines
-
-- some cleanup
-
-------------------------------------------------------------------------
-r7 | grumbel | 2002-09-01 15:07:53 +0200 (Sun, 01 Sep 2002) | 2 lines
-
-ported .scr file over to ClanLib-0.7, game runs again now (slow like hell and hero sprite is missing...)
-
-------------------------------------------------------------------------
-r6 | grumbel | 2002-09-01 02:05:33 +0200 (Sun, 01 Sep 2002) | 2 lines
-
-made it compilable with ClanLib-0.7
-
-------------------------------------------------------------------------
-r5 | grumbel | 2002-08-28 22:59:10 +0200 (Wed, 28 Aug 2002) | 2 lines
-
-byebye mp3, welcome ogg
-
-------------------------------------------------------------------------
-r4 | grumbel | 2002-08-25 12:48:07 +0200 (Sun, 25 Aug 2002) | 2 lines
-
-- added title song from Ralph Weinert
-
-------------------------------------------------------------------------
-r3 | grumbel | 2002-03-19 19:05:02 +0100 (Tue, 19 Mar 2002) | 2 lines
-
-Added missing file
-
-------------------------------------------------------------------------
-r1 | grumbel | 2002-03-19 18:56:44 +0100 (Tue, 19 Mar 2002) | 2 lines
-
-Initial revision
-
-------------------------------------------------------------------------

Deleted: trunk/INSTALL
===================================================================
--- trunk/INSTALL	2006-10-17 11:24:49 UTC (rev 645)
+++ trunk/INSTALL	2006-10-18 20:56:11 UTC (rev 646)
@@ -1,59 +0,0 @@
-Installing Flexlay 
-==================
-
-Requirements:
-=============
-
-To compile Flexlay you need a recent ClanLib 0.7, quite often the
-latest not-yet-released development version from the subversion tree,
-available at:
-
-  * http://www.clanlib.org
-
-And you need scons (a make replacement) available at:
-
-  * http://www.scons.org
-
-In addition to that Ruby, available at:
-
-  * http://www.ruby-lang.org
-
-And for the games you need a recent copy of them, most often latest
-development version of them is required.
-
-
-Compilation:
-============
-
-Just type:
-
- $ scons
-
-and it should build everything automatically if the prerequirements
-are meet. 
-
-
-Running:
-========
-
-The directories supertux/, netpanzer/, paint/, pingus/ and windstille/
-contain the editors for the games, just run the executable scripts in
-there. You might need to adjust the path to the game data, which is
-currently hardcoded in the scripts.
-
-
-Installing:
-===========
-
-Currently not supported, run directly from the source directory.
-
-Notes:
-======
-
-Flexlay is still a moving target, so most often you are better of
-using the latest development version instead of a tarball release.
-Latest version is available via subversion at:
-
-svn checkout svn://svn.berlios.de/flexlay/trunk/
-
-# EOF #

Deleted: trunk/NEWS
===================================================================
--- trunk/NEWS	2006-10-17 11:24:49 UTC (rev 645)
+++ trunk/NEWS	2006-10-18 20:56:11 UTC (rev 646)
@@ -1,37 +0,0 @@
-Flexlay 0.1.0
-=============
- - splitted flexlay into a C++ library and a scripting modules, Ruby
-   and (very limited) Python support is now available
- - restructured the scripting bindings
- - C++ object hierachy now completly available in scripting
- - switched build system from autohell to SCons
- - support for resizable rectangular objects
- - better support for sprite objects
- - support for constrained object movement
- - major GUI cleanup
- - a icon-toolbar
- - configurable keyboard shortcut support
- - SuperTux: support for multiple sublevels and most features of
-   lasted development version
- - NetPanzer: support for object based level building, no more need to
-   mess with raw tiles
- - Pingus: basic support for loading levels and saving them, however
-   only limited editing capabilties
- - Paint: a simple paint application with support for animation
-
-Flexlay 0.0.1
-==============
- - first release
- - zoom support
- - multilayer tilemap support
- - tilemap to png converting
- - tile brushes
- - simple copy/paste
- - undo/redo
- - game object support
- - SuperTux support
- - netPanzer support
- - Windstille support
- - Pingus support (load only)
-
-# EOF #

Deleted: trunk/README
===================================================================
--- trunk/README	2006-10-17 11:24:49 UTC (rev 645)
+++ trunk/README	2006-10-18 20:56:11 UTC (rev 646)
@@ -1,34 +0,0 @@
-Flexlay
-=======
-
-Flexlay is a generic 2d editor with special focus on games. It
-currently supports multi layered tile-, object- and bitmaps, full
-undo/redo, support for tile-brushes, easy copy/paste, multiple
-buffers, minimap support, a metadata editor and some other stuff
-usefull for creating levels for 2d games.
-
-Supported games are at the moment:
-
- Windstille - http://www.nongnu.org/windstille/
- netPanzer  - http://netpanzer.berlios.de/
- SuperTux   - http://super-tux.sourceforge.net/
- Pingus     - http://pingus.seul.org/
-
-Other Stuff:
-
- Paint - A basic application with animation and graphic tablet support 
-
-Flexlay can't be run on its own, but instead of you have to start it
-via wrapper scripts (supertux-editor, windstille-editor,
-netpanzer-editor).
-
-For informations on how to compile and run Flexlay see the file
-INSTALL. Flexlay makes use of OpenGL so you will need working hardware
-3d support.
-
-Flexlay is covered under the GNU GPL, which means that you can copy
-and even modify it pretty much as you like, as long as you keep the
-copyright headers in place and distribute the source too if you
-distribute binaries, see the file COPYING for details.
-
-# EOF #

Deleted: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2006-10-17 11:24:49 UTC (rev 645)
+++ trunk/SConstruct	2006-10-18 20:56:11 UTC (rev 646)
@@ -1,29 +0,0 @@
-# -*- python -*-
-
-# FIXME: replace the X11 stuff with a proper X11 configure check and
-# make them somehow part of the clanlib libraries themself
-clanLib_env = Environment(CPPPATH=['../clanlib/'],
-                          LIBPATH=['/usr/X11R6/lib/',
-                                   '../clanlib/'],
-                          LIBS=['clanGUIStyleSilver', 
-                                'clanGUI',      
-                                'clanGL',
-                                'clanDisplay',
-                                'clanSignals', 
-                                'clanCore',
-                                'X11', 'Xmu', 'GL', 'GLU', 'png', 'jpeg', 'Xxf86vm', 'Xi'])
-
-# Use this if you want to use your globally installed ClanLib
-#  clanLib_env = Environment()
-#  clanLib_env.ParseConfig("pkg-config --cflags --libs clanCore-0.8 clanDisplay-0.8 clanGL-0.8 clanSignals-0.8 clanGUI-0.8 clanGUIStyleSilver-0.8")
-
-Export('clanLib_env')
-
-SConscript(['clanlib/SConstruct'])
-SConscript(['lib/SConscript'])
-SConscript(['ruby/SConscript'])
-SConscript(['supertux/SConstruct'])
-SConscript(['netpanzer/SConstruct'])
-
-# EOF #
-

Deleted: trunk/TODO
===================================================================
--- trunk/TODO	2006-10-17 11:24:49 UTC (rev 645)
+++ trunk/TODO	2006-10-18 20:56:11 UTC (rev 646)
@@ -1,4 +0,0 @@
-- SConstruct file needs configuration features (check for clanlib,
-   check for ruby.h, check for swig1.3)
-
-# EOF #

Copied: trunk/flexlay/AUTHORS (from rev 645, trunk/AUTHORS)

Copied: trunk/flexlay/COPYING (from rev 645, trunk/COPYING)

Copied: trunk/flexlay/ChangeLog (from rev 645, trunk/ChangeLog)

Copied: trunk/flexlay/INSTALL (from rev 645, trunk/INSTALL)

Copied: trunk/flexlay/NEWS (from rev 645, trunk/NEWS)

Copied: trunk/flexlay/README (from rev 645, trunk/README)

Copied: trunk/flexlay/SConstruct (from rev 645, trunk/SConstruct)

Copied: trunk/flexlay/TODO (from rev 645, trunk/TODO)

Copied: trunk/flexlay/clanlib (from rev 645, trunk/clanlib)

Copied: trunk/flexlay/contrib (from rev 645, trunk/contrib)

Copied: trunk/flexlay/data (from rev 645, trunk/data)

Copied: trunk/flexlay/guile (from rev 645, trunk/guile)

Copied: trunk/flexlay/lib (from rev 645, trunk/lib)

Copied: trunk/flexlay/netpanzer (from rev 645, trunk/netpanzer)

Copied: trunk/flexlay/paint (from rev 645, trunk/paint)

Copied: trunk/flexlay/pingus (from rev 645, trunk/pingus)

Copied: trunk/flexlay/python (from rev 645, trunk/python)

Copied: trunk/flexlay/ruby (from rev 645, trunk/ruby)

Copied: trunk/flexlay/supertux (from rev 645, trunk/supertux)

Copied: trunk/flexlay/supertux-portable (from rev 645, trunk/supertux-portable)

Copied: trunk/flexlay/test (from rev 645, trunk/test)

Copied: trunk/flexlay/windstille (from rev 645, trunk/windstille)



From grumbel at mail.berlios.de  Thu Oct 19 14:22:21 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Thu, 19 Oct 2006 14:22:21 +0200
Subject: [Flexlay-commit] r648 - trunk/netbrush
Message-ID: <200610191222.k9JCMLP6002519@sheep.berlios.de>

Author: grumbel
Date: 2006-10-19 14:22:20 +0200 (Thu, 19 Oct 2006)
New Revision: 648

Added:
   trunk/netbrush/server_connection.cpp
Modified:
   trunk/netbrush/SConstruct
   trunk/netbrush/brush_widget.cpp
   trunk/netbrush/client.cpp
   trunk/netbrush/client_state.hpp
   trunk/netbrush/globals.cpp
   trunk/netbrush/globals.hpp
   trunk/netbrush/screen_buffer.cpp
   trunk/netbrush/stroke_buffer.cpp
Log:
- fixed offline mode

Modified: trunk/netbrush/SConstruct
===================================================================
--- trunk/netbrush/SConstruct	2006-10-18 21:14:26 UTC (rev 647)
+++ trunk/netbrush/SConstruct	2006-10-19 12:22:20 UTC (rev 648)
@@ -45,7 +45,8 @@
         'widget/slider_widget.cpp',
         'brushmask.cpp',
         'brush_widget.cpp',
-        'generic_brush.cpp'
+        'generic_brush.cpp',
+        'server_connection.cpp'
 ])
 
 # EOF #

Modified: trunk/netbrush/brush_widget.cpp
===================================================================
--- trunk/netbrush/brush_widget.cpp	2006-10-18 21:14:26 UTC (rev 647)
+++ trunk/netbrush/brush_widget.cpp	2006-10-19 12:22:20 UTC (rev 648)
@@ -191,7 +191,7 @@
     }
 
   SDL_Cursor* cursor = SDL_CreateCursor(data, mask, pitch*8, h, 
-                                        pitch*4, h/2);
+                                        w/2, h/2);
   SDL_SetCursor(cursor);
 }
 

Modified: trunk/netbrush/client.cpp
===================================================================
--- trunk/netbrush/client.cpp	2006-10-18 21:14:26 UTC (rev 647)
+++ trunk/netbrush/client.cpp	2006-10-19 12:22:20 UTC (rev 648)
@@ -22,6 +22,7 @@
 #include "alpha_picker.hpp"
 #include "brush_widget.hpp"
 #include "widget/callback.hpp"
+#include "server_connection.hpp"
 #include "widget/slider_widget.hpp"
 
 SDL_Rect* make_rect(int x, int y, int w, int h)
@@ -34,246 +35,6 @@
   return &rect;
 }
 
-void connect(const char* hostname, Uint16 port)
-{
-  IPaddress ip;
-
-  if(SDLNet_ResolveHost(&ip, hostname, port) == -1) 
-    {
-      printf("SDLNet_ResolveHost: %s\n", SDLNet_GetError());
-      exit(1);
-    }
-
-  tcpsock = SDLNet_TCP_Open(&ip);
-  if(!tcpsock)
-    {
-      printf("SDLNet_TCP_Open: %s %s:%d\n", SDLNet_GetError(), hostname, port);
-      exit(2);
-    }
-  else
-    {
-      std::string line = "client_version 1\n";
-      SDLNet_TCP_Send(tcpsock, const_cast<char*>(line.c_str()), line.length());
-
-      socketset = SDLNet_AllocSocketSet(1);
-      SDLNet_TCP_AddSocket(socketset, tcpsock);
-    }
-}
-
-
-std::vector<std::string>
-tokenize(const std::string& str, char split_char)
-{
-  std::string::size_type start = 0;
-  std::string::size_type end   = 0;
-
-  std::vector<std::string> tokens;
-
-  while (start < str.size())
-    {
-      if ((end = str.find(split_char, start)) == std::string::npos)
-        {
-          tokens.push_back(str.substr(start));
-          break;
-        }
-
-      const std::string& ret = str.substr(start, end - start);
-
-      if (!ret.empty())
-        tokens.push_back(ret);
-
-      start = end + 1;
-    }
-
-  return tokens;
-}
-
-void process_command(const std::string& cmd)
-{
-  if (cmd.empty()) return;
-
-  const std::vector<std::string>& tokens = tokenize(cmd, ' ');
-  if (0)
-    for(int i = 0; i < int(tokens.size()); ++i)
-      std::cout << "Token: '" << tokens[i] << "'" << std::endl;
-
-  if (!tokens.empty())
-    {
-      if (tokens[0] == "#")
-        {
-          // comment, ignore
-        }
-      else if (tokens[0] == "clear")
-        {
-          draw_ctx->clear();
-        }
-      else if (tokens[0] == "client")
-        {
-          if (tokens.size() > 2)
-            {
-              int client_id = atoi(tokens[1].c_str());
-              // convert to stroke
-              std::map<int, ClientState*>::iterator i = client_states.find(client_id);
-              ClientState* client_state = 0;
-              if (i != client_states.end())
-                {
-                  client_state = i->second;
-                }
-              else
-                {
-                  std::cout << "# allocating new ClientState" << std::endl;
-                  client_state = new ClientState(client_id);
-                  client_states[client_id] = client_state;
-                }
-              
-              if (tokens.size() == 3 && tokens[2] == "stroke_begin")
-                {
-                  client_state->stroke_begin();
-                }
-              else if (tokens.size() == 3 && tokens[2] == "stroke_end")
-                {
-                  client_state->stroke_end();
-                }
-              else if (tokens.size() == 4 && tokens[2] == "set_brush")
-                {
-                  client_state->set_brush(tokens[3]);
-                }
-              else if (tokens.size() == 9 && tokens[2] == "set_generic_brush")
-                {
-                  client_state->set_generic_brush((BrushShape)atoi(tokens[3].c_str()),  // shape FIXME: could use name instead
-                                                  atof(tokens[4].c_str()),  // radius
-                                                  atoi(tokens[5].c_str()),  // spike
-                                                  atof(tokens[6].c_str()),  // hardness
-                                                  atof(tokens[7].c_str()),  // aspectratio
-                                                  atof(tokens[8].c_str())); // angle
-                }
-              else if (tokens.size() == 4 && tokens[2] == "set_opacity")
-                {
-                  client_state->set_opacity(atoi(tokens[3].c_str()));
-                }
-              else if (tokens.size() == 6 && tokens[2] == "set_color")
-                {
-                  client_state->set_color(Color(atoi(tokens[3].c_str()), 
-                                                atoi(tokens[4].c_str()), 
-                                                atoi(tokens[5].c_str())));
-                }
-              else if (tokens.size() == 6 && tokens[2] == "dab")
-                {
-                  client_state->dab(atoi(tokens[3].c_str()), 
-                                    atoi(tokens[4].c_str()),
-                                    atoi(tokens[5].c_str()));
-                }
-              else
-                {
-                  std::cout << "# invalid command: " << cmd << std::endl;
-                }
-            }
-          else
-            {
-              std::cout << "# invalid command: " << cmd << std::endl;
-            }
-        }
-      else if (tokens[0] == "version")
-        {
-          if (tokens.size() == 2)
-            {
-              if (atoi(tokens[1].c_str()) != 0)
-                {
-                  std::cout << "# version mismatch: " << cmd << std::endl;
-                  std::cout << "# upgrade your netbrush client" << std::endl;
-                  exit(1);
-                }
-            }
-          else
-            {
-              std::cout << "# invalid command: " << cmd << std::endl;
-            }
-        }
-      else if (tokens[0] == "your_id")
-        {
-          if (tokens.size() == 2)
-            {
-              std::cout << "# my Id: " << atoi(tokens[1].c_str()) << std::endl;
-            }
-          else
-            {
-              std::cout << "# invalid command: " << cmd << std::endl;
-            }
-        }
-      else
-        {
-          std::cout << "# invalid command: " << cmd << std::endl;
-        }
-    }
-}
-
-void update_network()
-{
-  if (tcpsock)
-    {
-      int num = 0;
-      if ((num = SDLNet_CheckSockets(socketset, 0)) == -1)
-        {
-          printf("SDLNet_CheckSockets: %s\n", SDLNet_GetError());
-          //most of the time this is a system error, where perror might help you.
-          perror("SDLNet_CheckSockets");
-        }
-  
-      if (num > 0)
-        {
-          if (SDLNet_SocketReady(tcpsock))
-            {
-              const int MAXLEN = 1024;
-              int result;
-              char msg[MAXLEN];
-
-              result = SDLNet_TCP_Recv(tcpsock, msg, MAXLEN);
-              if(result <= 0) 
-                {
-                  // TCP Connection is broken. (because of error or closure)
-                  SDLNet_TCP_Close(tcpsock);
-                  exit(1);
-                }
-              else 
-                {
-                  for(int i = 0; i < result; ++i)
-                    {
-                      if (msg[i] == '\n')
-                        {
-                          process_command(server_buffer);
-                          //std::cout << server_buffer << std::endl;
-                          server_buffer.clear();
-                        }
-                      else
-                        {
-                          server_buffer += msg[i];
-                        }
-                    }
-                }
-            }
-        }
-    }
-}
-
-
-void
-draw_stroke(SDL_Surface* surface, const Stroke& stroke, DrawingParameter* param)
-{
-  SDL_Surface* brush = param->get_brush_surface();
-  
-  Stroke::Dabs dabs = stroke.get_interpolated_dabs(param->spacing, param->spacing);
-  for(Stroke::Dabs::iterator i = dabs.begin(); i != dabs.end(); ++i)
-    {
-      SDL_Rect rect;
-      rect.x = int(i->pos.x)-(brush->w/2);
-      rect.y = int(i->pos.y)-(brush->h/2);
-      rect.w = brush->w;
-      rect.h = brush->h;
-                  
-      SDL_BlitSurface(brush, 0, surface, &rect);
-    }
-}
-
 void process_events()
 {
   SDL_Event event;
@@ -325,8 +86,7 @@
             }
           else if (event.key.keysym.sym == SDLK_c)
             {
-              std::string line = "clear\n";
-              SDLNet_TCP_Send(tcpsock, const_cast<char*>(line.c_str()), line.length());
+              server->send("clear\n");
             }
           else if (event.key.keysym.sym == SDLK_INSERT)
             {
@@ -384,7 +144,7 @@
   {
     float radius = v * 100.0f + 0.1f;
     client_draw_param->generic_brush.radius = radius;
-    std::cout << "Radius: " << radius << std::endl;
+    //std::cout << "Radius: " << radius << std::endl;
     brush_widget->set_brush(client_draw_param->generic_brush);
   }
 };
@@ -395,7 +155,7 @@
   void operator()(float v) 
   {
     int spikes = int(v*18) + 2;
-    std::cout << "Spike: " << spikes << std::endl;
+    //std::cout << "Spike: " << spikes << std::endl;
     client_draw_param->generic_brush.spikes = spikes;    
     brush_widget->set_brush(client_draw_param->generic_brush);
   }
@@ -407,8 +167,8 @@
   void operator()(float v) 
   {
     float hardness = v;
-    client_draw_param->generic_brush.hardness = v;
-    std::cout << "Hardness: " << hardness << std::endl;
+    client_draw_param->generic_brush.hardness = hardness;
+    //std::cout << "Hardness: " << hardness << std::endl;
     brush_widget->set_brush(client_draw_param->generic_brush);
   }
 };
@@ -420,7 +180,7 @@
   {
     float aspect_ratio = v*19.0f + 1.0f;
     client_draw_param->generic_brush.aspect_ratio = aspect_ratio;
-    std::cout << "Aspect_Ratio: " << aspect_ratio << std::endl;
+    //std::cout << "Aspect_Ratio: " << aspect_ratio << std::endl;
     brush_widget->set_brush(client_draw_param->generic_brush);
   }
 };
@@ -432,7 +192,7 @@
   {
     float angle = v * 360.0f;
     client_draw_param->generic_brush.angle = angle;
-    std::cout << "Angle: " << angle << std::endl;
+    //std::cout << "Angle: " << angle << std::endl;
     brush_widget->set_brush(client_draw_param->generic_brush);
   }
 };
@@ -469,10 +229,11 @@
   client_draw_param = new DrawingParameter();
   stroke_buffer->set_param(client_draw_param);
   
+  server = new ServerConnection();
   if (argc == 3)
     {
       std::cout << "# connecting to: " << argv[1] << ":" << atoi(argv[2]) << std::endl;
-      connect(argv[1], atoi(argv[2]));
+      server->connect(argv[1], atoi(argv[2]));
     }
   else
     {
@@ -538,7 +299,7 @@
   while(true)
     {
       process_events();
-      update_network();
+      server->update();
       widget_manager->update();
       SDL_Delay(10);
     }

Modified: trunk/netbrush/client_state.hpp
===================================================================
--- trunk/netbrush/client_state.hpp	2006-10-18 21:14:26 UTC (rev 647)
+++ trunk/netbrush/client_state.hpp	2006-10-19 12:22:20 UTC (rev 648)
@@ -27,7 +27,9 @@
 #define HEADER_CLIENT_STATE_HPP
 
 #include <string>
+#include "brushmask.hpp"
 
+class Color;
 class Stroke;
 class DrawingParameter;
 

Modified: trunk/netbrush/globals.cpp
===================================================================
--- trunk/netbrush/globals.cpp	2006-10-18 21:14:26 UTC (rev 647)
+++ trunk/netbrush/globals.cpp	2006-10-19 12:22:20 UTC (rev 648)
@@ -25,10 +25,6 @@
 
 #include "globals.hpp"
 
-TCPsocket tcpsock = 0;
-SDLNet_SocketSet socketset;
-
-std::string server_buffer;
 DrawingContext*   draw_ctx          = 0;
 DrawingParameter* client_draw_param = 0;
 ScreenBuffer*     screen_buffer     = 0;
@@ -39,8 +35,9 @@
 
 SaturationValuePicker* saturation_value_picker =0;
 HuePicker*   hue_picker =0;
-AlphaPicker* alpha_picker = 0;
-BrushWidget* brush_widget = 0;
-Stroke* current_stroke = 0;
+AlphaPicker*      alpha_picker = 0;
+BrushWidget*      brush_widget = 0;
+Stroke*           current_stroke = 0;
+ServerConnection* server = 0;
 
 /* EOF */

Modified: trunk/netbrush/globals.hpp
===================================================================
--- trunk/netbrush/globals.hpp	2006-10-18 21:14:26 UTC (rev 647)
+++ trunk/netbrush/globals.hpp	2006-10-19 12:22:20 UTC (rev 648)
@@ -43,12 +43,11 @@
 class HuePicker;
 class AlphaPicker;
 class BrushWidget;
+class ServerConnection;
 
-extern TCPsocket tcpsock;
 extern SDLNet_SocketSet socketset;
 
 extern BrushWidget* brush_widget;
-extern std::string server_buffer;
 extern DrawingContext*   draw_ctx;
 extern DrawingParameter* client_draw_param;
 extern std::map<int, ClientState*> client_states;
@@ -59,7 +58,7 @@
 extern SaturationValuePicker* saturation_value_picker;
 extern HuePicker*   hue_picker;
 extern AlphaPicker* alpha_picker;
-
+extern ServerConnection* server;
 extern Stroke* current_stroke;
 
 #endif

Modified: trunk/netbrush/screen_buffer.cpp
===================================================================
--- trunk/netbrush/screen_buffer.cpp	2006-10-18 21:14:26 UTC (rev 647)
+++ trunk/netbrush/screen_buffer.cpp	2006-10-19 12:22:20 UTC (rev 648)
@@ -31,49 +31,9 @@
 #include "stroke_buffer.hpp"
 #include "widget/widget_manager.hpp"
 #include "globals.hpp"
+#include "server_connection.hpp"
 #include "screen_buffer.hpp"
 
-void send_stroke(const Stroke& stroke, DrawingParameter* param)
-{
-  if (tcpsock)
-    {
-      const Stroke::Dabs& dabs = stroke.get_dabs();
-
-      std::stringstream str;
-      if (param->get_brush().empty())
-        str << "set_generic_brush " 
-            << param->generic_brush.shape << " "
-            << param->generic_brush.radius << " "
-            << param->generic_brush.spikes << " "
-            << param->generic_brush.hardness << " "
-            << param->generic_brush.aspect_ratio << " "
-            << param->generic_brush.angle << " "
-            << std::endl;
-      else
-          str << "set_brush " << param->get_brush() << std::endl;
-      str << "set_opacity " << int(param->opacity) << std::endl;
-      str << "set_color "
-          << int(param->color.r) << " " 
-          << int(param->color.g) << " " 
-          << int(param->color.b) << std::endl;
-      str << "stroke_begin" << std::endl;
-      for(Stroke::Dabs::const_iterator i = dabs.begin(); i != dabs.end(); ++i)
-        {
-          str << "dab " << i->time << " " << i->pos.x << " " << i->pos.y  << std::endl;
-        }
-      str << "stroke_end" << std::endl;
-      
-      std::string line = str.str();
-
-      int result = SDLNet_TCP_Send(tcpsock, const_cast<char*>(line.c_str()), line.length());
-      if(result < int(line.length()))
-        {
-          printf( "SDLNet_TCP_Send: %s\n", SDLNet_GetError() );
-          // It may be good to disconnect sock because it is likely invalid now.
-        }     
-    }
-}
-
 ScreenBuffer::ScreenBuffer(const Rect& rect)
   : Widget(rect),
     scroll_offset_x(0),
@@ -255,15 +215,8 @@
             {
               widget_manager->ungrab(this);
 
-              if (!tcpsock)
-                { // FIXME: Might not work, not really maintained
-                  draw_ctx->draw_stroke(*current_stroke, client_draw_param);
-                }
-              else
-                {
-                  stroke_buffer->clear();
-                  send_stroke(*current_stroke, client_draw_param);
-                }
+              stroke_buffer->clear();
+              server->send_stroke(*current_stroke, client_draw_param);
 
               current_stroke = 0;
             }

Added: trunk/netbrush/server_connection.cpp
===================================================================
--- trunk/netbrush/server_connection.cpp	2006-10-18 21:14:26 UTC (rev 647)
+++ trunk/netbrush/server_connection.cpp	2006-10-19 12:22:20 UTC (rev 648)
@@ -0,0 +1,328 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#include <iostream>
+#include <sstream>
+#include "globals.hpp"
+#include "client_state.hpp"
+#include "color.hpp"
+#include "drawing_context.hpp"
+#include "drawing_parameter.hpp"
+#include "server_connection.hpp"
+
+static std::vector<std::string>
+tokenize(const std::string& str, char split_char)
+{
+  std::string::size_type start = 0;
+  std::string::size_type end   = 0;
+
+  std::vector<std::string> tokens;
+
+  while (start < str.size())
+    {
+      if ((end = str.find(split_char, start)) == std::string::npos)
+        {
+          tokens.push_back(str.substr(start));
+          break;
+        }
+
+      const std::string& ret = str.substr(start, end - start);
+
+      if (!ret.empty())
+        tokens.push_back(ret);
+
+      start = end + 1;
+    }
+
+  return tokens;
+}
+
+ServerConnection::ServerConnection()
+  : tcpsock(0),
+    socketset(0)
+{
+}
+
+ServerConnection::~ServerConnection()
+{
+}
+
+void
+ServerConnection::send(const std::string& str)
+{
+  if (tcpsock)
+    {
+      int result = SDLNet_TCP_Send(tcpsock, const_cast<char*>(str.c_str()), str.length());
+      if(result < int(str.length()))
+        {
+          printf( "SDLNet_TCP_Send: %s\n", SDLNet_GetError() );
+          // It may be good to disconnect sock because it is likely invalid now.
+        }     
+    }
+  else
+    { // Not connected, so directly procses the command without a
+      // round trip through the server
+      std::string tmp;
+      for(std::string::size_type i = 0; i < str.length(); ++i)
+        {
+          if (str[i] == '\n')
+            {
+              process_command("client 0 " + tmp);
+              tmp.clear();
+            }
+          else
+            tmp += str[i];
+        }
+    }  
+}
+
+void
+ServerConnection::connect(const char* hostname, Uint16 port)
+{
+  IPaddress ip;
+
+  if(SDLNet_ResolveHost(&ip, hostname, port) == -1) 
+    {
+      printf("SDLNet_ResolveHost: %s\n", SDLNet_GetError());
+      exit(1);
+    }
+
+  tcpsock = SDLNet_TCP_Open(&ip);
+  if(!tcpsock)
+    {
+      printf("SDLNet_TCP_Open: %s %s:%d\n", SDLNet_GetError(), hostname, port);
+      exit(2);
+    }
+  else
+    {
+      std::string line = "client_version 1\n";
+      SDLNet_TCP_Send(tcpsock, const_cast<char*>(line.c_str()), line.length());
+
+      socketset = SDLNet_AllocSocketSet(1);
+      SDLNet_TCP_AddSocket(socketset, tcpsock);
+    }
+}
+
+void
+ServerConnection::update()
+{
+  if (!tcpsock) return;
+
+  int num = 0;
+  if ((num = SDLNet_CheckSockets(socketset, 0)) == -1)
+    {
+      printf("SDLNet_CheckSockets: %s\n", SDLNet_GetError());
+      //most of the time this is a system error, where perror might help you.
+      perror("SDLNet_CheckSockets");
+    }
+  
+  if (num > 0)
+    {
+      if (SDLNet_SocketReady(tcpsock))
+        {
+          const int MAXLEN = 1024;
+          int result;
+          char msg[MAXLEN];
+
+          result = SDLNet_TCP_Recv(tcpsock, msg, MAXLEN);
+          if(result <= 0) 
+            {
+              // TCP Connection is broken. (because of error or closure)
+              SDLNet_TCP_Close(tcpsock);
+              exit(1);
+            }
+          else 
+            {
+              for(int i = 0; i < result; ++i)
+                {
+                  if (msg[i] == '\n')
+                    {
+                      process_command(buffer);
+                      //std::cout << server_buffer << std::endl;
+                      buffer.clear();
+                    }
+                  else
+                    {
+                      buffer += msg[i];
+                    }
+                }
+            }
+        }
+    }
+}
+
+void
+ServerConnection::process_command(const std::string& cmd)
+{
+  if (cmd.empty()) return;
+
+  const std::vector<std::string>& tokens = tokenize(cmd, ' ');
+  if (0)
+    for(int i = 0; i < int(tokens.size()); ++i)
+      std::cout << "Token: '" << tokens[i] << "'" << std::endl;
+
+  if (!tokens.empty())
+    {
+      if (tokens[0] == "#")
+        {
+          // comment, ignore
+        }
+      else if (tokens[0] == "clear")
+        {
+          draw_ctx->clear();
+        }
+      else if (tokens[0] == "client")
+        {
+          if (tokens.size() > 2)
+            {
+              int client_id = atoi(tokens[1].c_str());
+              // convert to stroke
+              std::map<int, ClientState*>::iterator i = client_states.find(client_id);
+              ClientState* client_state = 0;
+              if (i != client_states.end())
+                {
+                  client_state = i->second;
+                }
+              else
+                {
+                  std::cout << "# allocating new ClientState" << std::endl;
+                  client_state = new ClientState(client_id);
+                  client_states[client_id] = client_state;
+                }
+              
+              if (tokens.size() == 3 && tokens[2] == "stroke_begin")
+                {
+                  client_state->stroke_begin();
+                }
+              else if (tokens.size() == 3 && tokens[2] == "stroke_end")
+                {
+                  client_state->stroke_end();
+                }
+              else if (tokens.size() == 4 && tokens[2] == "set_brush")
+                {
+                  client_state->set_brush(tokens[3]);
+                }
+              else if (tokens.size() == 9 && tokens[2] == "set_generic_brush")
+                {
+                  client_state->set_generic_brush((BrushShape)atoi(tokens[3].c_str()),  // shape FIXME: could use name instead
+                                                  atof(tokens[4].c_str()),  // radius
+                                                  atoi(tokens[5].c_str()),  // spike
+                                                  atof(tokens[6].c_str()),  // hardness
+                                                  atof(tokens[7].c_str()),  // aspectratio
+                                                  atof(tokens[8].c_str())); // angle
+                }
+              else if (tokens.size() == 4 && tokens[2] == "set_opacity")
+                {
+                  client_state->set_opacity(atoi(tokens[3].c_str()));
+                }
+              else if (tokens.size() == 6 && tokens[2] == "set_color")
+                {
+                  client_state->set_color(Color(atoi(tokens[3].c_str()), 
+                                                atoi(tokens[4].c_str()), 
+                                                atoi(tokens[5].c_str())));
+                }
+              else if (tokens.size() == 6 && tokens[2] == "dab")
+                {
+                  client_state->dab(atoi(tokens[3].c_str()), 
+                                    atoi(tokens[4].c_str()),
+                                    atoi(tokens[5].c_str()));
+                }
+              else
+                {
+                  std::cout << "# invalid command: " << cmd << std::endl;
+                }
+            }
+          else
+            {
+              std::cout << "# invalid command: " << cmd << std::endl;
+            }
+        }
+      else if (tokens[0] == "version")
+        {
+          if (tokens.size() == 2)
+            {
+              if (atoi(tokens[1].c_str()) != 0)
+                {
+                  std::cout << "# version mismatch: " << cmd << std::endl;
+                  std::cout << "# upgrade your netbrush client" << std::endl;
+                  exit(1);
+                }
+            }
+          else
+            {
+              std::cout << "# invalid command: " << cmd << std::endl;
+            }
+        }
+      else if (tokens[0] == "your_id")
+        {
+          if (tokens.size() == 2)
+            {
+              std::cout << "# my Id: " << atoi(tokens[1].c_str()) << std::endl;
+            }
+          else
+            {
+              std::cout << "# invalid command: " << cmd << std::endl;
+            }
+        }
+      else
+        {
+          std::cout << "# invalid command: " << cmd << std::endl;
+        }
+    }
+}
+
+void
+ServerConnection::send_stroke(const Stroke& stroke, DrawingParameter* param)
+{
+  const Stroke::Dabs& dabs = stroke.get_dabs();
+
+  std::stringstream str;
+  if (param->get_brush().empty())
+    str << "set_generic_brush " 
+        << param->generic_brush.shape << " "
+        << param->generic_brush.radius << " "
+        << param->generic_brush.spikes << " "
+        << param->generic_brush.hardness << " "
+        << param->generic_brush.aspect_ratio << " "
+        << param->generic_brush.angle << " "
+        << std::endl;
+  else
+    str << "set_brush " << param->get_brush() << std::endl;
+  str << "set_opacity " << int(param->opacity) << std::endl;
+  str << "set_color "
+      << int(param->color.r) << " " 
+      << int(param->color.g) << " " 
+      << int(param->color.b) << std::endl;
+  str << "stroke_begin" << std::endl;
+  for(Stroke::Dabs::const_iterator i = dabs.begin(); i != dabs.end(); ++i)
+    {
+      str << "dab " << i->time << " " << i->pos.x << " " << i->pos.y  << std::endl;
+    }
+  str << "stroke_end" << std::endl;
+      
+  send(str.str());
+}
+
+/* EOF */

Modified: trunk/netbrush/stroke_buffer.cpp
===================================================================
--- trunk/netbrush/stroke_buffer.cpp	2006-10-18 21:14:26 UTC (rev 647)
+++ trunk/netbrush/stroke_buffer.cpp	2006-10-19 12:22:20 UTC (rev 648)
@@ -89,7 +89,8 @@
 {
   GrayscaleBuffer* brush = param->get_brush_buffer();
 
-  Stroke::Dabs dabs = stroke.get_interpolated_dabs(param->spacing, param->spacing);
+  //Stroke::Dabs dabs = stroke.get_interpolated_dabs(param->spacing, param->spacing);
+  Stroke::Dabs dabs = stroke.get_dabs();
   for(Stroke::Dabs::iterator i = dabs.begin(); i != dabs.end(); ++i)
     {
       buffer->blit(brush,



From grumbel at mail.berlios.de  Thu Oct 19 14:24:04 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Thu, 19 Oct 2006 14:24:04 +0200
Subject: [Flexlay-commit] r649 - trunk/netbrush
Message-ID: <200610191224.k9JCO4En002625@sheep.berlios.de>

Author: grumbel
Date: 2006-10-19 14:24:04 +0200 (Thu, 19 Oct 2006)
New Revision: 649

Added:
   trunk/netbrush/server_connection.hpp
Log:
- fixed offline mode

Added: trunk/netbrush/server_connection.hpp
===================================================================
--- trunk/netbrush/server_connection.hpp	2006-10-19 12:22:20 UTC (rev 648)
+++ trunk/netbrush/server_connection.hpp	2006-10-19 12:24:04 UTC (rev 649)
@@ -0,0 +1,62 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#ifndef HEADER_SERVER_CONNECTION_HPP
+#define HEADER_SERVER_CONNECTION_HPP
+
+#include <string>
+#include "SDL_net.h"
+
+class Stroke;
+class DrawingParameter;
+
+/** */
+class ServerConnection
+{
+private:
+  TCPsocket tcpsock;
+  SDLNet_SocketSet socketset;
+  std::string buffer;
+
+public:
+  ServerConnection();
+  ~ServerConnection();
+
+  void connect(const char* hostname, Uint16 port);
+
+  /** Send a string to the server, you must add the trailing newline
+      yourself to \a str */
+  void send(const std::string& str);
+  void send_stroke(const Stroke& stroke, DrawingParameter* param);
+  void update();
+  void process_command(const std::string& cmd);
+private:
+  ServerConnection (const ServerConnection&);
+  ServerConnection& operator= (const ServerConnection&);
+};
+
+#endif
+
+/* EOF */



From grumbel at mail.berlios.de  Thu Oct 19 14:37:25 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Thu, 19 Oct 2006 14:37:25 +0200
Subject: [Flexlay-commit] r650 - trunk/netbrush
Message-ID: <200610191237.k9JCbP8g004148@sheep.berlios.de>

Author: grumbel
Date: 2006-10-19 14:37:24 +0200 (Thu, 19 Oct 2006)
New Revision: 650

Modified:
   trunk/netbrush/client.cpp
Log:
- added window title

Modified: trunk/netbrush/client.cpp
===================================================================
--- trunk/netbrush/client.cpp	2006-10-19 12:24:04 UTC (rev 649)
+++ trunk/netbrush/client.cpp	2006-10-19 12:37:24 UTC (rev 650)
@@ -214,7 +214,8 @@
   screen = SDL_SetVideoMode(1024, 768, 32, SDL_HWSURFACE); 
   if (screen == 0)
     printf("SDL_SetVideoMode: %s\n", SDL_GetError());
-  
+  SDL_WM_SetCaption("netBrush", "netBrush");
+
   screen_buffer = new ScreenBuffer(Rect(68, 0, screen->w - 128, screen->h));
   draw_ctx      = new DrawingContext(1024, 1024);
   stroke_buffer = new StrokeBuffer(1024, 1024);
@@ -234,12 +235,15 @@
     {
       std::cout << "# connecting to: " << argv[1] << ":" << atoi(argv[2]) << std::endl;
       server->connect(argv[1], atoi(argv[2]));
+      std::ostringstream title_line;
+      title_line << "netBrush - online: " << argv[1] << ":" << atoi(argv[2]);
+      SDL_WM_SetCaption(title_line.str().c_str(), "netBrush");
     }
   else
     {
       std::cout << "# use '" << argv[0] << " HOSTNAME PORT' to connect a networking session" << std::endl;
+      SDL_WM_SetCaption("netBrush - offline mode", "netBrush");
     }
-
   
   widget_manager = new WidgetManager();
   {



From grumbel at mail.berlios.de  Thu Oct 19 15:10:35 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Thu, 19 Oct 2006 15:10:35 +0200
Subject: [Flexlay-commit] r651 - in trunk/netbrush: . widget
Message-ID: <200610191310.k9JDAZGP008766@sheep.berlios.de>

Author: grumbel
Date: 2006-10-19 15:10:34 +0200 (Thu, 19 Oct 2006)
New Revision: 651

Modified:
   trunk/netbrush/client.cpp
   trunk/netbrush/drawing_context.hpp
   trunk/netbrush/screen_buffer.cpp
   trunk/netbrush/widget/widget.cpp
Log:
- fixed scrolling a bit

Modified: trunk/netbrush/client.cpp
===================================================================
--- trunk/netbrush/client.cpp	2006-10-19 12:37:24 UTC (rev 650)
+++ trunk/netbrush/client.cpp	2006-10-19 13:10:34 UTC (rev 651)
@@ -216,9 +216,9 @@
     printf("SDL_SetVideoMode: %s\n", SDL_GetError());
   SDL_WM_SetCaption("netBrush", "netBrush");
 
-  screen_buffer = new ScreenBuffer(Rect(68, 0, screen->w - 128, screen->h));
-  draw_ctx      = new DrawingContext(1024, 1024);
-  stroke_buffer = new StrokeBuffer(1024, 1024);
+  screen_buffer = new ScreenBuffer(Rect(68 + 16, 0 + 16, screen->w - 128 - 16, screen->h - 16));
+  draw_ctx      = new DrawingContext(2048, 2048);
+  stroke_buffer = new StrokeBuffer(2048, 2048);
 
   std::cout << "# clear screen" << std::endl;
 

Modified: trunk/netbrush/drawing_context.hpp
===================================================================
--- trunk/netbrush/drawing_context.hpp	2006-10-19 12:37:24 UTC (rev 650)
+++ trunk/netbrush/drawing_context.hpp	2006-10-19 13:10:34 UTC (rev 651)
@@ -49,6 +49,9 @@
   void clear();
 
   void draw(SDL_Surface* target, const Rect& region, int x_of, int y_of);
+
+  int get_width()  const { return drawable->w; }
+  int get_height() const { return drawable->h; }
 };
 
 #endif

Modified: trunk/netbrush/screen_buffer.cpp
===================================================================
--- trunk/netbrush/screen_buffer.cpp	2006-10-19 12:37:24 UTC (rev 650)
+++ trunk/netbrush/screen_buffer.cpp	2006-10-19 13:10:34 UTC (rev 651)
@@ -44,33 +44,6 @@
     click_pos_y(0),
     scrolling(false)
 {
-#if 0 
-  // Create drawable
-  Uint32 rmask, gmask, bmask, amask;
-
-  /* SDL interprets each pixel as a 32-bit number, so our masks must depend
-     on the endianness (byte order) of the machine */
-#if SDL_BYTEORDER == SDL_BIG_ENDIAN
-  rmask = 0xff000000;
-  gmask = 0x00ff0000;
-  bmask = 0x0000ff00;
-  amask = 0; //0x000000ff;
-#else
-  rmask = 0x000000ff;
-  gmask = 0x0000ff00;
-  bmask = 0x00ff0000;
-  amask = 0; //0xff000000;
-#endif
-
-  buffer = SDL_CreateRGBSurface(SDL_SWSURFACE, w, h, 24,
-                                rmask, gmask, bmask, amask);
-
-  if(buffer == NULL) 
-    {
-      fprintf(stderr, "CreateRGBSurface failed: %s\n", SDL_GetError());
-      exit(1);
-    }
-#endif 
 }
 
 ScreenBuffer::~ScreenBuffer()
@@ -108,8 +81,19 @@
               << dirty_region.bottom 
               << std::endl;
 
-  draw_ctx->draw(target, dirty_region, trans_x, trans_y);
+  if (0)
+    { // FIXME: Slow, ugly and only for testing
+      SDL_Rect r;
+      r.x = get_rect().left;
+      r.y = get_rect().top;
+      r.w = get_rect().get_width();
+      r.h = get_rect().get_height();
+      std::cout << "fill rect: " << r.x << " " << r.y << " " << r.w << " " << r.h << std::endl;
+      SDL_FillRect(target, &r, SDL_MapRGB(target->format, 0, 0, 0));
+      SDL_UpdateRect(target, r.x, r.y, r.w, r.h);
+    }
 
+  draw_ctx->draw(target, dirty_region, trans_x, trans_y);
   stroke_buffer->draw(target, dirty_region, trans_x, trans_y);
   
   SDL_UpdateRect(target, 
@@ -142,11 +126,11 @@
     y = 0;
   
   // FIXME: This must be drawable size, not screen size
-  if (x + w > screen->w)
-    w = screen->w - x;
+  if (x + w > draw_ctx->get_width())
+    w = draw_ctx->get_width() - x;
 
-  if (y + h > screen->h)
-    h = screen->h - y;
+  if (y + h > draw_ctx->get_height())
+    h = draw_ctx->get_height() - y;
 
   //std::cout << "Dirty: " << x << " " << y << " " << w << " " << h << std::endl;
 
@@ -199,8 +183,16 @@
     {
       scroll_offset_x = old_scroll_offset_x + (motion.x - click_pos_x);
       scroll_offset_y = old_scroll_offset_y + (motion.y - click_pos_y);
-      mark_dirty(get_rect());
-      //std::cout << "Scrolling: " << scroll_offset_x << " " << scroll_offset_y << std::endl;
+
+      // FIXME: JUCK?!
+      Rect r(0, 0, get_rect().get_width(), get_rect().get_height());
+      r.left   -= scroll_offset_x;
+      r.right  -= scroll_offset_x;
+      r.top    -= scroll_offset_y;
+      r.bottom -= scroll_offset_y;
+      mark_dirty(r);
+
+      std::cout << "Scrolling: " << scroll_offset_x << " " << scroll_offset_y << std::endl;
     } 
 }
 

Modified: trunk/netbrush/widget/widget.cpp
===================================================================
--- trunk/netbrush/widget/widget.cpp	2006-10-19 12:37:24 UTC (rev 650)
+++ trunk/netbrush/widget/widget.cpp	2006-10-19 13:10:34 UTC (rev 651)
@@ -26,7 +26,7 @@
 #include "widget.hpp"
 
 Widget::Widget(const Rect& rect_)
-  : rect(rect_.left+1, rect_.top+1, rect_.right-1, rect_.bottom-1),  // FIXME: Cheap way to add border
+  : rect(rect_),
     dirty(false) 
 {
 }



From grumbel at mail.berlios.de  Thu Oct 19 15:58:26 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Thu, 19 Oct 2006 15:58:26 +0200
Subject: [Flexlay-commit] r652 - in trunk/netbrush: . widget
Message-ID: <200610191358.k9JDwQMm014201@sheep.berlios.de>

Author: grumbel
Date: 2006-10-19 15:58:26 +0200 (Thu, 19 Oct 2006)
New Revision: 652

Added:
   trunk/netbrush/widget/scrollbar.cpp
   trunk/netbrush/widget/scrollbar.hpp
Removed:
   trunk/netbrush/widget/callback.hpp
Modified:
   trunk/netbrush/SConstruct
   trunk/netbrush/client.cpp
   trunk/netbrush/globals.cpp
   trunk/netbrush/globals.hpp
   trunk/netbrush/screen_buffer.cpp
   trunk/netbrush/widget/slider_widget.cpp
   trunk/netbrush/widget/slider_widget.hpp
Log:
- added some scrollbars


Modified: trunk/netbrush/SConstruct
===================================================================
--- trunk/netbrush/SConstruct	2006-10-19 13:10:34 UTC (rev 651)
+++ trunk/netbrush/SConstruct	2006-10-19 13:58:26 UTC (rev 652)
@@ -19,34 +19,35 @@
 client_env['CPPPATH'] += ['.']
 client_env['LIBS'] += ['SDL_image', 'SDL_net']
 client_env.Program('client', [
+        'alpha_picker.cpp',
+        'brush_widget.cpp',
+        'brushmask.cpp',
         'client.cpp', 
         'client_state.cpp',
         'debug.cpp',
         'drawing_context.cpp',
+        'drawing_parameter.cpp',
+        'generic_brush.cpp',
         'globals.cpp',
         'grayscale_buffer.cpp', 
-        'screen_buffer.cpp',
-        'stroke.cpp',
-        'stroke_buffer.cpp',
-        'video.cpp',
-        'drawing_parameter.cpp',
-        'widget/widget_manager.cpp',
-        'widget/widget.cpp',
-        'widget/button.cpp',
-#        'widget/events.cpp',
+        'hue_picker.cpp',
         'math/matrix.cpp',
         'math/origin.cpp',
         'math/quaternion.cpp',
         'math/rect.cpp',
         'math/vector.cpp',
         'saturation_value_picker.cpp',
-        'hue_picker.cpp',
-        'alpha_picker.cpp',
+        'screen_buffer.cpp',
+        'server_connection.cpp',
+        'stroke.cpp',
+        'stroke_buffer.cpp',
+        'video.cpp',
+        'widget/button.cpp',
+        'widget/scrollbar.cpp',
         'widget/slider_widget.cpp',
-        'brushmask.cpp',
-        'brush_widget.cpp',
-        'generic_brush.cpp',
-        'server_connection.cpp'
+        'widget/widget.cpp',
+        'widget/widget_manager.cpp',
+#        'widget/events.cpp',
 ])
 
 # EOF #

Modified: trunk/netbrush/client.cpp
===================================================================
--- trunk/netbrush/client.cpp	2006-10-19 13:10:34 UTC (rev 651)
+++ trunk/netbrush/client.cpp	2006-10-19 13:58:26 UTC (rev 652)
@@ -16,12 +16,12 @@
 #include "screen_buffer.hpp"
 #include "stroke_buffer.hpp"
 #include "widget/widget_manager.hpp"
+#include "widget/scrollbar.hpp"
 #include "widget/button.hpp"
 #include "saturation_value_picker.hpp"
 #include "hue_picker.hpp"
 #include "alpha_picker.hpp"
 #include "brush_widget.hpp"
-#include "widget/callback.hpp"
 #include "server_connection.hpp"
 #include "widget/slider_widget.hpp"
 
@@ -137,7 +137,7 @@
     }  
 }
 
-class RadiusCallback : public Callback
+class RadiusCallback : public SliderCallback
 {
 public:
   void operator()(float v) 
@@ -149,7 +149,7 @@
   }
 };
 
-class SpikeCallback : public Callback
+class SpikeCallback : public SliderCallback
 {
 public:
   void operator()(float v) 
@@ -161,7 +161,7 @@
   }
 };
 
-class HardnessCallback : public Callback
+class HardnessCallback : public SliderCallback
 {
 public:
   void operator()(float v) 
@@ -173,7 +173,7 @@
   }
 };
 
-class AspectRatioCallback : public Callback
+class AspectRatioCallback : public SliderCallback
 {
 public:
   void operator()(float v) 
@@ -185,7 +185,7 @@
   }
 };
 
-class AngleCallback : public Callback
+class AngleCallback : public SliderCallback
 {
 public:
   void operator()(float v) 
@@ -216,7 +216,8 @@
     printf("SDL_SetVideoMode: %s\n", SDL_GetError());
   SDL_WM_SetCaption("netBrush", "netBrush");
 
-  screen_buffer = new ScreenBuffer(Rect(68 + 16, 0 + 16, screen->w - 128 - 16, screen->h - 16));
+  // 18 is scrollbar
+  screen_buffer = new ScreenBuffer(Rect(68 + 16, 0 + 16, screen->w - 128 - 16 - 18, screen->h - 16 - 18)); 
   draw_ctx      = new DrawingContext(2048, 2048);
   stroke_buffer = new StrokeBuffer(2048, 2048);
 
@@ -267,6 +268,16 @@
 
   widget_manager->add(screen_buffer);
 
+  widget_manager->add(vertical_scrollbar = 
+                      new Scrollbar(0, 2048, screen_buffer->get_rect().get_height(), Scrollbar::VERTICAL,
+                                    Rect(screen->w - 128 - 16 - 16, 0 + 16,
+                                         screen->w - 128 - 16, screen->h - 16 - 18)));
+
+  widget_manager->add(horizontal_scrollbar = 
+                      new Scrollbar(0, 2048, screen_buffer->get_rect().get_width(), Scrollbar::HORIZONTAL,
+                                    Rect(68 + 16, screen->h - 16 - 16,
+                                         screen->w - 128 - 16 - 18, screen->h - 16)));
+
   alpha_picker = new AlphaPicker(Rect(Point(screen->w-128, 128+24), Size(128, 24)));
   saturation_value_picker = new SaturationValuePicker(Rect(Point(screen->w-128, 0), Size(128, 128)));
   hue_picker   = new HuePicker(Rect(Point(screen->w-128, 128), Size(128, 24)));

Modified: trunk/netbrush/globals.cpp
===================================================================
--- trunk/netbrush/globals.cpp	2006-10-19 13:10:34 UTC (rev 651)
+++ trunk/netbrush/globals.cpp	2006-10-19 13:58:26 UTC (rev 652)
@@ -40,4 +40,7 @@
 Stroke*           current_stroke = 0;
 ServerConnection* server = 0;
 
+Scrollbar* horizontal_scrollbar = 0;
+Scrollbar* vertical_scrollbar   = 0;
+
 /* EOF */

Modified: trunk/netbrush/globals.hpp
===================================================================
--- trunk/netbrush/globals.hpp	2006-10-19 13:10:34 UTC (rev 651)
+++ trunk/netbrush/globals.hpp	2006-10-19 13:58:26 UTC (rev 652)
@@ -44,9 +44,12 @@
 class AlphaPicker;
 class BrushWidget;
 class ServerConnection;
+class Scrollbar;
 
 extern SDLNet_SocketSet socketset;
 
+extern Scrollbar* horizontal_scrollbar;
+extern Scrollbar* vertical_scrollbar;
 extern BrushWidget* brush_widget;
 extern DrawingContext*   draw_ctx;
 extern DrawingParameter* client_draw_param;

Modified: trunk/netbrush/screen_buffer.cpp
===================================================================
--- trunk/netbrush/screen_buffer.cpp	2006-10-19 13:10:34 UTC (rev 651)
+++ trunk/netbrush/screen_buffer.cpp	2006-10-19 13:58:26 UTC (rev 652)
@@ -32,6 +32,7 @@
 #include "widget/widget_manager.hpp"
 #include "globals.hpp"
 #include "server_connection.hpp"
+#include "widget/scrollbar.hpp"
 #include "screen_buffer.hpp"
 
 ScreenBuffer::ScreenBuffer(const Rect& rect)
@@ -73,7 +74,7 @@
       dirty_region.bottom = std::min(get_rect().bottom, dirty_region.bottom);
     }
 
-  if (0)
+  if (1)
     std::cout << "Updating screen: "
               << dirty_region.left  << " "
               << dirty_region.top   << " "
@@ -93,14 +94,21 @@
       SDL_UpdateRect(target, r.x, r.y, r.w, r.h);
     }
 
-  draw_ctx->draw(target, dirty_region, trans_x, trans_y);
-  stroke_buffer->draw(target, dirty_region, trans_x, trans_y);
+  horizontal_scrollbar->set_pos(-scroll_offset_x);
+  vertical_scrollbar->set_pos(-scroll_offset_y);
+
+  // check for invalid dirty_regions (ie. canvas is completly outside of the view)
+  if (dirty_region.left < dirty_region.right &&
+      dirty_region.top  <  dirty_region.bottom)
+    {       draw_ctx->draw(target, dirty_region, trans_x, trans_y);
+      stroke_buffer->draw(target, dirty_region, trans_x, trans_y);
   
-  SDL_UpdateRect(target, 
-                 dirty_region.left,        dirty_region.top, 
-                 dirty_region.get_width(), dirty_region.get_height());
+      SDL_UpdateRect(target, 
+                     dirty_region.left,        dirty_region.top, 
+                     dirty_region.get_width(), dirty_region.get_height());
+    }
 
-  if (0) 
+  if (1) 
     std::cout << "Updating done" << std::endl;
 }
 

Deleted: trunk/netbrush/widget/callback.hpp
===================================================================
--- trunk/netbrush/widget/callback.hpp	2006-10-19 13:10:34 UTC (rev 651)
+++ trunk/netbrush/widget/callback.hpp	2006-10-19 13:58:26 UTC (rev 652)
@@ -1,44 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#ifndef HEADER_CALLBACK_HPP
-#define HEADER_CALLBACK_HPP
-
-/** */
-class Callback
-{
-public:
-  Callback() {}
-  virtual ~Callback() {}
-  virtual void operator()(float) =0;
-
-private:
-  Callback (const Callback&);
-  Callback& operator= (const Callback&);
-};
-
-#endif
-
-/* EOF */

Added: trunk/netbrush/widget/scrollbar.cpp
===================================================================
--- trunk/netbrush/widget/scrollbar.cpp	2006-10-19 13:10:34 UTC (rev 651)
+++ trunk/netbrush/widget/scrollbar.cpp	2006-10-19 13:58:26 UTC (rev 652)
@@ -0,0 +1,86 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#include "scrollbar.hpp"
+
+Scrollbar::Scrollbar(int min_, int max_, int page_step_, Orientation orientation_, const Rect& rect)
+  : Widget(rect),
+    min(min_),
+    max(max_),
+    page_step(page_step_),
+    orientation(orientation_),
+    pos(min_ + (max_ - min_)/2)
+{
+  
+}
+  
+void
+Scrollbar::on_mouse_motion(const MouseMotionEvent& motion)
+{ 
+}
+
+void
+Scrollbar::on_mouse_button(const MouseButtonEvent& button)
+{
+}
+
+void
+Scrollbar::draw(SDL_Surface* target)
+{
+  SDL_Rect r;
+  r.x = get_rect().left;
+  r.y = get_rect().top;
+  r.w = get_rect().get_width();
+  r.h = get_rect().get_height();
+  SDL_FillRect(target, &r, SDL_MapRGB(target->format, 200, 200, 200));
+
+  if (orientation == HORIZONTAL)
+    {
+      r.x = get_rect().left + 2 + ((pos-min) * (get_rect().get_width()-4) / (max - min));
+      r.y = get_rect().top + 2;
+      r.w = page_step * (get_rect().get_width()-4) / (max - min);
+      r.h = get_rect().get_height()-4;
+
+      SDL_FillRect(target, &r, SDL_MapRGB(target->format, 0, 0, 0));
+    }
+  else // VERSION
+    {
+      r.x = get_rect().left + 2;
+      r.y = get_rect().top  + 2 + ((pos-min) * (get_rect().get_height()-4) / (max - min));
+      r.w = get_rect().get_width()-4;
+      r.h = page_step * (get_rect().get_height()-4) / (max - min);
+
+      SDL_FillRect(target, &r, SDL_MapRGB(target->format, 0, 0, 0));
+    }
+}
+
+void
+Scrollbar::set_pos(int p)
+{
+  pos = p;
+  set_dirty(true);
+}
+
+/* EOF */

Added: trunk/netbrush/widget/scrollbar.hpp
===================================================================
--- trunk/netbrush/widget/scrollbar.hpp	2006-10-19 13:10:34 UTC (rev 651)
+++ trunk/netbrush/widget/scrollbar.hpp	2006-10-19 13:58:26 UTC (rev 652)
@@ -0,0 +1,63 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#ifndef HEADER_SCROLLBAR_HPP
+#define HEADER_SCROLLBAR_HPP
+
+#include "widget.hpp"
+
+/** */
+class Scrollbar : public Widget
+{
+public:
+  enum Orientation { HORIZONTAL, VERTICAL };
+
+private: 
+  int min;
+  int max;
+  int page_step;
+  Orientation orientation;
+  int pos; 
+
+public:
+  Scrollbar(int min, int max, int page_step, Orientation orientation, const Rect& rect);
+  
+  void on_mouse_motion(const MouseMotionEvent& motion);
+  void on_mouse_button(const MouseButtonEvent& button);;
+
+  void on_enter() {}
+  void on_leave() {}
+
+  void draw(SDL_Surface* target);
+  
+  void set_pos(int p);
+private:
+  Scrollbar (const Scrollbar&);
+  Scrollbar& operator= (const Scrollbar&);
+};
+
+#endif
+
+/* EOF */

Modified: trunk/netbrush/widget/slider_widget.cpp
===================================================================
--- trunk/netbrush/widget/slider_widget.cpp	2006-10-19 13:10:34 UTC (rev 651)
+++ trunk/netbrush/widget/slider_widget.cpp	2006-10-19 13:58:26 UTC (rev 652)
@@ -28,7 +28,7 @@
 #include "widget_manager.hpp"
 #include "slider_widget.hpp"
 
-SliderWidget::SliderWidget(const Rect& rect_, Callback* callback_)
+SliderWidget::SliderWidget(const Rect& rect_, SliderCallback* callback_)
   : Widget(rect_), callback(callback_), pos(0.5f), dragging(false)
 {
 }

Modified: trunk/netbrush/widget/slider_widget.hpp
===================================================================
--- trunk/netbrush/widget/slider_widget.hpp	2006-10-19 13:10:34 UTC (rev 651)
+++ trunk/netbrush/widget/slider_widget.hpp	2006-10-19 13:58:26 UTC (rev 652)
@@ -26,19 +26,31 @@
 #ifndef HEADER_SLIDER_WIDGET_HPP
 #define HEADER_SLIDER_WIDGET_HPP
 
-#include "callback.hpp"
 #include "widget.hpp"
 
 /** */
+class SliderCallback
+{
+public:
+  SliderCallback() {}
+  virtual ~SliderCallback() {}
+  virtual void operator()(float) =0;
+
+private:
+  SliderCallback (const SliderCallback&);
+  SliderCallback& operator= (const SliderCallback&);
+};
+
+/** */
 class SliderWidget : public Widget
 {
 private:
-  Callback* callback;
+  SliderCallback* callback;
   float pos;
   bool  dragging;
   
 public:
-  SliderWidget(const Rect& rect_, Callback* callback);
+  SliderWidget(const Rect& rect_, SliderCallback* callback);
   ~SliderWidget();
 
   void on_mouse_motion(const MouseMotionEvent& motion);



From grumbel at mail.berlios.de  Thu Oct 19 18:08:37 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Thu, 19 Oct 2006 18:08:37 +0200
Subject: [Flexlay-commit] r653 - trunk/netbrush
Message-ID: <200610191608.k9JG8bom032383@sheep.berlios.de>

Author: grumbel
Date: 2006-10-19 18:08:37 +0200 (Thu, 19 Oct 2006)
New Revision: 653

Modified:
   trunk/netbrush/drawing_context.cpp
   trunk/netbrush/screen_buffer.cpp
   trunk/netbrush/screen_buffer.hpp
   trunk/netbrush/stroke_buffer.cpp
   trunk/netbrush/video.cpp
   trunk/netbrush/video.hpp
Log:
- work around for crash (maybe)

Modified: trunk/netbrush/drawing_context.cpp
===================================================================
--- trunk/netbrush/drawing_context.cpp	2006-10-19 13:58:26 UTC (rev 652)
+++ trunk/netbrush/drawing_context.cpp	2006-10-19 16:08:37 UTC (rev 653)
@@ -76,6 +76,8 @@
   rect.right  += param->thickness()/2;
   rect.bottom += param->thickness()/2;
 
+  clip_to(rect, Rect(0, 0, get_width(), get_height()));
+
   stroke_buffer->clear(rect);
   stroke_buffer->set_param(param);
   stroke_buffer->draw_stroke(stroke, param);
@@ -113,7 +115,7 @@
 
   SDL_FillRect(drawable, &rect, SDL_MapRGB(drawable->format, 255, 255, 255));
 
-  screen_buffer->mark_dirty(&rect);
+  screen_buffer->mark_dirty(Rect(Point(0,0), Size(rect.w, rect.h)));
 }
 
 void

Modified: trunk/netbrush/screen_buffer.cpp
===================================================================
--- trunk/netbrush/screen_buffer.cpp	2006-10-19 13:58:26 UTC (rev 652)
+++ trunk/netbrush/screen_buffer.cpp	2006-10-19 16:08:37 UTC (rev 653)
@@ -74,7 +74,7 @@
       dirty_region.bottom = std::min(get_rect().bottom, dirty_region.bottom);
     }
 
-  if (1)
+  if (0)
     std::cout << "Updating screen: "
               << dirty_region.left  << " "
               << dirty_region.top   << " "
@@ -108,17 +108,11 @@
                      dirty_region.get_width(), dirty_region.get_height());
     }
 
-  if (1) 
+  if (0) 
     std::cout << "Updating done" << std::endl;
 }
 
 void
-ScreenBuffer::mark_dirty(SDL_Rect* region)
-{
-  mark_dirty(region->x, region->y, region->w, region->h);
-}
-
-void
 ScreenBuffer::mark_dirty(const Rect& region)
 {
   mark_dirty(region.left, region.top, region.get_width(), region.get_height());
@@ -184,7 +178,7 @@
       rect.right  += client_draw_param->thickness()/2;
       rect.bottom += client_draw_param->thickness()/2;
                   
-      screen_buffer->mark_dirty(rect);
+      mark_dirty(rect);
     }
 
   if (scrolling)
@@ -192,7 +186,6 @@
       scroll_offset_x = old_scroll_offset_x + (motion.x - click_pos_x);
       scroll_offset_y = old_scroll_offset_y + (motion.y - click_pos_y);
 
-      // FIXME: JUCK?!
       Rect r(0, 0, get_rect().get_width(), get_rect().get_height());
       r.left   -= scroll_offset_x;
       r.right  -= scroll_offset_x;
@@ -200,7 +193,7 @@
       r.bottom -= scroll_offset_y;
       mark_dirty(r);
 
-      std::cout << "Scrolling: " << scroll_offset_x << " " << scroll_offset_y << std::endl;
+      //std::cout << "Scrolling: " << scroll_offset_x << " " << scroll_offset_y << std::endl;
     } 
 }
 

Modified: trunk/netbrush/screen_buffer.hpp
===================================================================
--- trunk/netbrush/screen_buffer.hpp	2006-10-19 13:58:26 UTC (rev 652)
+++ trunk/netbrush/screen_buffer.hpp	2006-10-19 16:08:37 UTC (rev 653)
@@ -53,7 +53,6 @@
 
   // Mark an region as dirty in canvas space, not screen space
   void mark_dirty(int x, int y, int w, int h);
-  void mark_dirty(SDL_Rect* region);
   void mark_dirty(const Rect& region);
   
   void draw(SDL_Surface* target);

Modified: trunk/netbrush/stroke_buffer.cpp
===================================================================
--- trunk/netbrush/stroke_buffer.cpp	2006-10-19 13:58:26 UTC (rev 652)
+++ trunk/netbrush/stroke_buffer.cpp	2006-10-19 16:08:37 UTC (rev 653)
@@ -109,6 +109,10 @@
   Uint8* dst = static_cast<Uint8*>(target->pixels);
   Uint8* src = buffer->get_data();
   
+  assert(rect.left >= 0);
+  std::cout << "StrokeBuffer::draw: " << rect.left << " " << rect.top << " "
+            << rect.right << " " << rect.bottom << " - " << x_of << " " << y_of << std::endl;
+
   if (target == screen) // FIXME: Ugly workaround
     {
       for(int y = rect.top; y < rect.bottom; ++y)

Modified: trunk/netbrush/video.cpp
===================================================================
--- trunk/netbrush/video.cpp	2006-10-19 13:58:26 UTC (rev 652)
+++ trunk/netbrush/video.cpp	2006-10-19 16:08:37 UTC (rev 653)
@@ -24,6 +24,7 @@
 */
 
 #include <algorithm>
+#include "math/rect.hpp"
 #include "video.hpp"
 
 SDL_Surface* screen = 0;
@@ -43,6 +44,14 @@
   rect->h = y2 - y1;
 }
 
+void clip_to(Rect& rect, const Rect& clip_rect)
+{
+  rect.left   = std::max(rect.left,   clip_rect.left);
+  rect.right  = std::min(rect.right,  clip_rect.right);
+  rect.top    = std::max(rect.top,    clip_rect.top);
+  rect.bottom = std::min(rect.bottom, clip_rect.bottom);
+}
+
 SDL_Surface* create_surface(int w, int h)
 {
   Uint32 rmask, gmask, bmask, amask;

Modified: trunk/netbrush/video.hpp
===================================================================
--- trunk/netbrush/video.hpp	2006-10-19 13:58:26 UTC (rev 652)
+++ trunk/netbrush/video.hpp	2006-10-19 16:08:37 UTC (rev 653)
@@ -30,7 +30,10 @@
 
 extern SDL_Surface* screen;
 
+class Rect;
+
 void clip_to(SDL_Rect* rect, SDL_Rect* clip_rect);
+void clip_to(Rect& rect, const Rect& clip_rect);
 SDL_Surface* create_surface(int w, int h);
 
 #endif



From grumbel at mail.berlios.de  Thu Oct 19 19:48:53 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Thu, 19 Oct 2006 19:48:53 +0200
Subject: [Flexlay-commit] r654 - trunk/netbrush/data/icons
Message-ID: <200610191748.k9JHmrqO017023@sheep.berlios.de>

Author: grumbel
Date: 2006-10-19 19:48:52 +0200 (Thu, 19 Oct 2006)
New Revision: 654

Added:
   trunk/netbrush/data/icons/stock-navigation-16.png
   trunk/netbrush/data/icons/stock-tool-airbrush-22.png
   trunk/netbrush/data/icons/stock-tool-clone-22.png
   trunk/netbrush/data/icons/stock-tool-paintbrush-22.png
   trunk/netbrush/data/icons/stock-tool-pencil-22.png
   trunk/netbrush/data/icons/stock-tool-smudge-22.png
   trunk/netbrush/data/icons/stock-tool-zoom-22.png
Log:
- added some icons from gimp

Added: trunk/netbrush/data/icons/stock-navigation-16.png
===================================================================
(Binary files differ)


Property changes on: trunk/netbrush/data/icons/stock-navigation-16.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/netbrush/data/icons/stock-tool-airbrush-22.png
===================================================================
(Binary files differ)


Property changes on: trunk/netbrush/data/icons/stock-tool-airbrush-22.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/netbrush/data/icons/stock-tool-clone-22.png
===================================================================
(Binary files differ)


Property changes on: trunk/netbrush/data/icons/stock-tool-clone-22.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/netbrush/data/icons/stock-tool-paintbrush-22.png
===================================================================
(Binary files differ)


Property changes on: trunk/netbrush/data/icons/stock-tool-paintbrush-22.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/netbrush/data/icons/stock-tool-pencil-22.png
===================================================================
(Binary files differ)


Property changes on: trunk/netbrush/data/icons/stock-tool-pencil-22.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/netbrush/data/icons/stock-tool-smudge-22.png
===================================================================
(Binary files differ)


Property changes on: trunk/netbrush/data/icons/stock-tool-smudge-22.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/netbrush/data/icons/stock-tool-zoom-22.png
===================================================================
(Binary files differ)


Property changes on: trunk/netbrush/data/icons/stock-tool-zoom-22.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From grumbel at mail.berlios.de  Thu Oct 19 20:22:36 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Thu, 19 Oct 2006 20:22:36 +0200
Subject: [Flexlay-commit] r655 - in trunk/netbrush: . widget
Message-ID: <200610191822.k9JIMaCV020569@sheep.berlios.de>

Author: grumbel
Date: 2006-10-19 20:22:36 +0200 (Thu, 19 Oct 2006)
New Revision: 655

Modified:
   trunk/netbrush/client.cpp
   trunk/netbrush/client_state.cpp
   trunk/netbrush/client_state.hpp
   trunk/netbrush/drawing_context.cpp
   trunk/netbrush/drawing_parameter.cpp
   trunk/netbrush/drawing_parameter.hpp
   trunk/netbrush/server.cpp
   trunk/netbrush/server_connection.cpp
   trunk/netbrush/stroke_buffer.cpp
   trunk/netbrush/widget/button.cpp
   trunk/netbrush/widget/button.hpp
Log:
- bit GUI cleanup
- added way to change tools

Modified: trunk/netbrush/client.cpp
===================================================================
--- trunk/netbrush/client.cpp	2006-10-19 17:48:52 UTC (rev 654)
+++ trunk/netbrush/client.cpp	2006-10-19 18:22:36 UTC (rev 655)
@@ -197,6 +197,33 @@
   }
 };
 
+class ToolButtonCallback : public ButtonCallback
+{
+private:
+  DrawingParameter::Tool tool;
+public:
+  ToolButtonCallback(DrawingParameter::Tool tool_)
+    : tool(tool_)
+  {
+  }
+
+  void on_press  (Button* button) 
+  {
+    std::cout << "Press: " << button << std::endl;
+  }
+
+  void on_release(Button* button) 
+  {
+    std::cout << "Release: " << button << std::endl;
+  }
+  
+  void on_click  (Button* button) 
+  {
+    std::cout << "Setting tool: " << tool << std::endl;
+    client_draw_param->tool = tool;
+  }
+};
+
 int main(int argc, char** argv)
 {
   if(SDL_Init(SDL_INIT_VIDEO)== -1) {
@@ -217,7 +244,7 @@
   SDL_WM_SetCaption("netBrush", "netBrush");
 
   // 18 is scrollbar
-  screen_buffer = new ScreenBuffer(Rect(68 + 16, 0 + 16, screen->w - 128 - 16 - 18, screen->h - 16 - 18)); 
+  screen_buffer = new ScreenBuffer(Rect(38, 2, screen->w - 128 - 16 - 18, screen->h - 16 - 4)); 
   draw_ctx      = new DrawingContext(2048, 2048);
   stroke_buffer = new StrokeBuffer(2048, 2048);
 
@@ -247,13 +274,16 @@
     }
   
   widget_manager = new WidgetManager();
-  {
-    for(int y = 0; y < 10; ++y)
-      for(int x = 0; x < 2; ++x)
-        {
-          widget_manager->add(new Button(Rect(Point(x*34, y*34), Size(34, 34))));
-        }
-  }
+  widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-airbrush-22.png"), 
+                                 Rect(Point(2, 2+0*34), Size(34, 34)),
+                                 new ToolButtonCallback(DrawingParameter::TOOL_AIRBRUSH)));
+  widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-paintbrush-22.png"), 
+                                 Rect(Point(2, 2+1*34), Size(34, 34)),
+                                 new ToolButtonCallback(DrawingParameter::TOOL_PAINTBRUSH)));
+  if (0)
+    widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-zoom-22.png"), 
+                                   Rect(Point(2, 2+2*34), Size(34, 34)),
+                                   new ToolButtonCallback(DrawingParameter::TOOL_PAINTBRUSH)));
 
   {
     SDL_Rect color_rect;
@@ -270,13 +300,13 @@
 
   widget_manager->add(vertical_scrollbar = 
                       new Scrollbar(0, 2048, screen_buffer->get_rect().get_height(), Scrollbar::VERTICAL,
-                                    Rect(screen->w - 128 - 16 - 16, 0 + 16,
-                                         screen->w - 128 - 16, screen->h - 16 - 18)));
+                                    Rect(screen->w - 128 - 16 - 16, 2,
+                                         screen->w - 128 - 16, screen->h - 16 - 4)));
 
   widget_manager->add(horizontal_scrollbar = 
                       new Scrollbar(0, 2048, screen_buffer->get_rect().get_width(), Scrollbar::HORIZONTAL,
-                                    Rect(68 + 16, screen->h - 16 - 16,
-                                         screen->w - 128 - 16 - 18, screen->h - 16)));
+                                    Rect(38, screen->h - 16 - 2,
+                                         screen->w - 128 - 16 - 18, screen->h - 2)));
 
   alpha_picker = new AlphaPicker(Rect(Point(screen->w-128, 128+24), Size(128, 24)));
   saturation_value_picker = new SaturationValuePicker(Rect(Point(screen->w-128, 0), Size(128, 128)));

Modified: trunk/netbrush/client_state.cpp
===================================================================
--- trunk/netbrush/client_state.cpp	2006-10-19 17:48:52 UTC (rev 654)
+++ trunk/netbrush/client_state.cpp	2006-10-19 18:22:36 UTC (rev 655)
@@ -43,6 +43,12 @@
 }
 
 void
+ClientState::set_tool(DrawingParameter::Tool tool)
+{
+  draw_param->tool = tool;
+}
+
+void
 ClientState::set_color(const Color& color)
 {
   draw_param->color = color;

Modified: trunk/netbrush/client_state.hpp
===================================================================
--- trunk/netbrush/client_state.hpp	2006-10-19 17:48:52 UTC (rev 654)
+++ trunk/netbrush/client_state.hpp	2006-10-19 18:22:36 UTC (rev 655)
@@ -28,6 +28,7 @@
 
 #include <string>
 #include "brushmask.hpp"
+#include "drawing_parameter.hpp"
 
 class Color;
 class Stroke;
@@ -44,6 +45,7 @@
   ClientState(int id_);
   ~ClientState();
 
+  void set_tool(DrawingParameter::Tool tool);
   void set_opacity(Uint8 o);
   void set_color(const Color& color);
   void set_generic_brush(BrushShape shape,

Modified: trunk/netbrush/drawing_context.cpp
===================================================================
--- trunk/netbrush/drawing_context.cpp	2006-10-19 17:48:52 UTC (rev 654)
+++ trunk/netbrush/drawing_context.cpp	2006-10-19 18:22:36 UTC (rev 655)
@@ -83,23 +83,6 @@
   stroke_buffer->draw_stroke(stroke, param);
   stroke_buffer->draw(drawable, rect, 0, 0);
 
-  if (0)
-    {
-      SDL_Surface* brush = param->get_brush_surface();
-  
-      Stroke::Dabs dabs = stroke.get_interpolated_dabs(param->spacing, param->spacing);
-      for(Stroke::Dabs::iterator i = dabs.begin(); i != dabs.end(); ++i)
-        {
-          SDL_Rect rect;
-          rect.x = int(i->pos.x)-(brush->w/2);
-          rect.y = int(i->pos.y)-(brush->h/2);
-          rect.w = brush->w;
-          rect.h = brush->h;
-                  
-          SDL_BlitSurface(brush, 0, drawable, &rect);
-        }
-    }
-
   screen_buffer->mark_dirty(rect);
 }
 

Modified: trunk/netbrush/drawing_parameter.cpp
===================================================================
--- trunk/netbrush/drawing_parameter.cpp	2006-10-19 17:48:52 UTC (rev 654)
+++ trunk/netbrush/drawing_parameter.cpp	2006-10-19 18:22:36 UTC (rev 655)
@@ -27,7 +27,9 @@
 #include "drawing_parameter.hpp"
 
 DrawingParameter::DrawingParameter()
-  : brush_surface(0), brush_buffer(0), 
+  : tool(TOOL_AIRBRUSH),
+    brush_surface(0), 
+    brush_buffer(0), 
     color(0, 0, 0), 
     opacity(128),
     spacing(1.0f)

Modified: trunk/netbrush/drawing_parameter.hpp
===================================================================
--- trunk/netbrush/drawing_parameter.hpp	2006-10-19 17:48:52 UTC (rev 654)
+++ trunk/netbrush/drawing_parameter.hpp	2006-10-19 18:22:36 UTC (rev 655)
@@ -37,6 +37,8 @@
 class DrawingParameter
 {
 public:
+  enum Tool { TOOL_AIRBRUSH, TOOL_PAINTBRUSH };
+  Tool             tool;
   std::string      brush_file;
   GenericBrush     generic_brush;
   SDL_Surface*     brush_surface;

Modified: trunk/netbrush/server.cpp
===================================================================
--- trunk/netbrush/server.cpp	2006-10-19 17:48:52 UTC (rev 654)
+++ trunk/netbrush/server.cpp	2006-10-19 18:22:36 UTC (rev 655)
@@ -211,8 +211,9 @@
               tokens[0] == "stroke_begin" ||
               tokens[0] == "stroke_end"   ||
               tokens[0] == "set_brush"    ||
-              tokens[0] == "set_generic_brush"    ||
+              tokens[0] == "set_generic_brush" ||
               tokens[0] == "set_color"    ||
+              tokens[0] == "set_tool"     ||
               tokens[0] == "set_opacity" 
               ))
       {

Modified: trunk/netbrush/server_connection.cpp
===================================================================
--- trunk/netbrush/server_connection.cpp	2006-10-19 17:48:52 UTC (rev 654)
+++ trunk/netbrush/server_connection.cpp	2006-10-19 18:22:36 UTC (rev 655)
@@ -237,6 +237,10 @@
                 {
                   client_state->set_opacity(atoi(tokens[3].c_str()));
                 }
+              else if (tokens.size() == 4 && tokens[2] == "set_tool")
+                {
+                  client_state->set_tool(static_cast<DrawingParameter::Tool>(atoi(tokens[3].c_str())));
+                }
               else if (tokens.size() == 6 && tokens[2] == "set_color")
                 {
                   client_state->set_color(Color(atoi(tokens[3].c_str()), 
@@ -310,6 +314,7 @@
         << std::endl;
   else
     str << "set_brush " << param->get_brush() << std::endl;
+  str << "set_tool " << param->tool << std::endl; 
   str << "set_opacity " << int(param->opacity) << std::endl;
   str << "set_color "
       << int(param->color.r) << " " 

Modified: trunk/netbrush/stroke_buffer.cpp
===================================================================
--- trunk/netbrush/stroke_buffer.cpp	2006-10-19 17:48:52 UTC (rev 654)
+++ trunk/netbrush/stroke_buffer.cpp	2006-10-19 18:22:36 UTC (rev 655)
@@ -89,68 +89,82 @@
 {
   GrayscaleBuffer* brush = param->get_brush_buffer();
 
-  //Stroke::Dabs dabs = stroke.get_interpolated_dabs(param->spacing, param->spacing);
-  Stroke::Dabs dabs = stroke.get_dabs();
-  for(Stroke::Dabs::iterator i = dabs.begin(); i != dabs.end(); ++i)
+  if (param->tool == DrawingParameter::TOOL_AIRBRUSH)
     {
-      buffer->blit(brush,
-                   static_cast<int>(i->pos.x - brush->get_width()/2), 
-                   static_cast<int>(i->pos.y - brush->get_height()/2), 
-                   GrayscaleBuffer::ALPHA);
+      Stroke::Dabs dabs = stroke.get_dabs();
+      for(Stroke::Dabs::iterator i = dabs.begin(); i != dabs.end(); ++i)
+        {
+          buffer->blit(brush,
+                       static_cast<int>(i->pos.x - brush->get_width()/2), 
+                       static_cast<int>(i->pos.y - brush->get_height()/2), 
+                       GrayscaleBuffer::ALPHA);
+        }
     }
+  else if (param->tool == DrawingParameter::TOOL_PAINTBRUSH)
+    {
+      Stroke::Dabs dabs = stroke.get_interpolated_dabs(param->spacing, param->spacing);
+      for(Stroke::Dabs::iterator i = dabs.begin(); i != dabs.end(); ++i)
+        {
+          buffer->blit(brush,
+                       static_cast<int>(i->pos.x - brush->get_width()/2), 
+                       static_cast<int>(i->pos.y - brush->get_height()/2), 
+                       GrayscaleBuffer::ALPHA);
+        }      
+    }
 }
 
-void
-StrokeBuffer::draw(SDL_Surface* target, const Rect& rect, int x_of, int y_of)
-{ 
-  // rect is in screenspace, x_of, y_of tell how to go from canvas to screenspace
-  SDL_LockSurface(target);
+  void
+    StrokeBuffer::draw(SDL_Surface* target, const Rect& rect, int x_of, int y_of)
+  { 
+    // rect is in screenspace, x_of, y_of tell how to go from canvas to screenspace
+    SDL_LockSurface(target);
 
-  Uint8* dst = static_cast<Uint8*>(target->pixels);
-  Uint8* src = buffer->get_data();
+    Uint8* dst = static_cast<Uint8*>(target->pixels);
+    Uint8* src = buffer->get_data();
   
-  assert(rect.left >= 0);
-  std::cout << "StrokeBuffer::draw: " << rect.left << " " << rect.top << " "
-            << rect.right << " " << rect.bottom << " - " << x_of << " " << y_of << std::endl;
+    assert(rect.left >= 0);
+    if (0)
+      std::cout << "StrokeBuffer::draw: " << target << " " << rect.left << " " << rect.top << " "
+                << rect.right << " " << rect.bottom << " - " << x_of << " " << y_of << std::endl;
 
-  if (target == screen) // FIXME: Ugly workaround
-    {
-      for(int y = rect.top; y < rect.bottom; ++y)
-        for(int x = rect.left; x < rect.right; ++x)
-          {
-            Uint8* d = dst + (y * target->pitch + target->format->BytesPerPixel * x);
-            Uint8  s = src[(y - y_of) * buffer->get_width() + (x - x_of)];
+    if (target == screen) // FIXME: Ugly workaround
+      {
+        for(int y = rect.top; y < rect.bottom; ++y)
+          for(int x = rect.left; x < rect.right; ++x)
+            {
+              Uint8* d = dst + (y * target->pitch + target->format->BytesPerPixel * x);
+              Uint8  s = src[(y - y_of) * buffer->get_width() + (x - x_of)];
 
-            s = (s * param->opacity)/255;
+              s = (s * param->opacity)/255;
 
-            d[0] = ((255 - s) * d[0] + (s * param->color.b))/255;
-            d[1] = ((255 - s) * d[1] + (s * param->color.g))/255;
-            d[2] = ((255 - s) * d[2] + (s * param->color.r))/255;
-          }
-    }
-  else
-    {
-      for(int y = rect.top; y < rect.bottom; ++y)
-        for(int x = rect.left; x < rect.right; ++x)
-          {
-            Uint8* d = dst + (y * target->pitch + target->format->BytesPerPixel * x);
-            Uint8  s = src[(y - y_of) * buffer->get_width() + (x - x_of)];
+              d[0] = ((255 - s) * d[0] + (s * param->color.b))/255;
+              d[1] = ((255 - s) * d[1] + (s * param->color.g))/255;
+              d[2] = ((255 - s) * d[2] + (s * param->color.r))/255;
+            }
+      }
+    else
+      {
+        for(int y = rect.top; y < rect.bottom; ++y)
+          for(int x = rect.left; x < rect.right; ++x)
+            {
+              Uint8* d = dst + (y * target->pitch + target->format->BytesPerPixel * x);
+              Uint8  s = src[(y - y_of) * buffer->get_width() + (x - x_of)];
 
-            s = (s * param->opacity)/255;
+              s = (s * param->opacity)/255;
 
-            d[0] = ((255 - s) * d[0] + (s * param->color.r))/255;
-            d[1] = ((255 - s) * d[1] + (s * param->color.g))/255;
-            d[2] = ((255 - s) * d[2] + (s * param->color.b))/255;
-          }
-    }
+              d[0] = ((255 - s) * d[0] + (s * param->color.r))/255;
+              d[1] = ((255 - s) * d[1] + (s * param->color.g))/255;
+              d[2] = ((255 - s) * d[2] + (s * param->color.b))/255;
+            }
+      }
 
-  SDL_UnlockSurface(target);
-}
+    SDL_UnlockSurface(target);
+  }
 
-void
-StrokeBuffer::set_param(DrawingParameter* param_)
-{
-  param = param_;
-}
+  void
+    StrokeBuffer::set_param(DrawingParameter* param_)
+  {
+    param = param_;
+  }
 
-/* EOF */
+  /* EOF */

Modified: trunk/netbrush/widget/button.cpp
===================================================================
--- trunk/netbrush/widget/button.cpp	2006-10-19 17:48:52 UTC (rev 654)
+++ trunk/netbrush/widget/button.cpp	2006-10-19 18:22:36 UTC (rev 655)
@@ -29,10 +29,12 @@
 #include "../globals.hpp"
 #include "button.hpp"
 
-Button::Button(const Rect& rect_)
+Button::Button(SDL_Surface* icon_, const Rect& rect_, ButtonCallback* callback_)
   : Widget(rect_),
+    callback(callback_),
     state(UP),
-    hover(false)
+    hover(false),
+    icon(icon_)
 {
   up_surface    = IMG_Load("data/icons/up.png");
   down_surface  = IMG_Load("data/icons/down.png");
@@ -73,12 +75,17 @@
       state = DOWN;
       set_dirty(true);
       widget_manager->grab(this);
+      callback->on_press(this);
+      
     }
   else if (button.button == 1 && button.state == SDL_RELEASED)
     {
       state = UP;
       widget_manager->ungrab(this);
       set_dirty(true);
+      callback->on_release(this);
+      // FIXME: Need to check if inside button rectangle
+      callback->on_click(this);
     }
 }
 
@@ -109,6 +116,11 @@
       break;
     }
 
+  r.x = get_rect().left + 6;
+  r.y = get_rect().top  + 6;
+
+  SDL_BlitSurface(icon, NULL, target, &r);
+
   //SDL_FillRect(target, get_rect(), color);
 }
 

Modified: trunk/netbrush/widget/button.hpp
===================================================================
--- trunk/netbrush/widget/button.hpp	2006-10-19 17:48:52 UTC (rev 654)
+++ trunk/netbrush/widget/button.hpp	2006-10-19 18:22:36 UTC (rev 655)
@@ -28,10 +28,24 @@
 
 #include "widget.hpp"
 
+class Button;
+
+class ButtonCallback
+{
+public:
+  ButtonCallback() {}
+  virtual ~ButtonCallback() {}
+  virtual void on_press  (Button* button) =0;
+  virtual void on_release(Button* button) =0;
+  virtual void on_click  (Button* button) =0;
+};
+
 /** */
 class Button : public Widget
 {
 private:
+  ButtonCallback* callback;
+  
   enum State { UP, DOWN };
   State state;
   bool  hover;
@@ -40,8 +54,10 @@
   SDL_Surface* down_surface;
   SDL_Surface* hover_surface;
 
+  SDL_Surface* icon;
+
 public:
-  Button(const Rect& rect);
+  Button(SDL_Surface* icon, const Rect& rect, ButtonCallback* callback_);
   ~Button();
 
   void on_mouse_motion(const MouseMotionEvent& motion);



From grumbel at mail.berlios.de  Thu Oct 19 20:48:01 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Thu, 19 Oct 2006 20:48:01 +0200
Subject: [Flexlay-commit] r656 - trunk/netbrush
Message-ID: <200610191848.k9JIm1cd023308@sheep.berlios.de>

Author: grumbel
Date: 2006-10-19 20:48:01 +0200 (Thu, 19 Oct 2006)
New Revision: 656

Modified:
   trunk/netbrush/brush_widget.cpp
Log:
- don't create mousepointers that are virtually invisible

Modified: trunk/netbrush/brush_widget.cpp
===================================================================
--- trunk/netbrush/brush_widget.cpp	2006-10-19 18:22:36 UTC (rev 655)
+++ trunk/netbrush/brush_widget.cpp	2006-10-19 18:48:01 UTC (rev 656)
@@ -117,6 +117,9 @@
 void
 BrushWidget::update_mouse_cursor()
 {
+  if (client_draw_param->generic_brush.radius < 5.0f)
+    return ;
+
   GrayscaleBuffer* brush = client_draw_param->brush_buffer;
   
   int w     = brush->get_width();



From grumbel at mail.berlios.de  Thu Oct 19 22:14:40 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Thu, 19 Oct 2006 22:14:40 +0200
Subject: [Flexlay-commit] r657 - trunk/netbrush
Message-ID: <200610192014.k9JKEeq3004887@sheep.berlios.de>

Author: grumbel
Date: 2006-10-19 22:14:40 +0200 (Thu, 19 Oct 2006)
New Revision: 657

Modified:
   trunk/netbrush/screen_buffer.cpp
Log:
- some scrolling speedup

Modified: trunk/netbrush/screen_buffer.cpp
===================================================================
--- trunk/netbrush/screen_buffer.cpp	2006-10-19 18:48:01 UTC (rev 656)
+++ trunk/netbrush/screen_buffer.cpp	2006-10-19 20:14:40 UTC (rev 657)
@@ -100,8 +100,10 @@
   // check for invalid dirty_regions (ie. canvas is completly outside of the view)
   if (dirty_region.left < dirty_region.right &&
       dirty_region.top  <  dirty_region.bottom)
-    {       draw_ctx->draw(target, dirty_region, trans_x, trans_y);
-      stroke_buffer->draw(target, dirty_region, trans_x, trans_y);
+    {
+      draw_ctx->draw(target, dirty_region, trans_x, trans_y);
+      if (!scrolling)
+        stroke_buffer->draw(target, dirty_region, trans_x, trans_y);
   
       SDL_UpdateRect(target, 
                      dirty_region.left,        dirty_region.top, 



From grumbel at mail.berlios.de  Thu Oct 19 23:01:29 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Thu, 19 Oct 2006 23:01:29 +0200
Subject: [Flexlay-commit] r658 - trunk/netbrush
Message-ID: <200610192101.k9JL1ToB012059@sheep.berlios.de>

Author: grumbel
Date: 2006-10-19 23:01:28 +0200 (Thu, 19 Oct 2006)
New Revision: 658

Added:
   trunk/netbrush/navigation.cpp
   trunk/netbrush/navigation.hpp
Modified:
   trunk/netbrush/SConstruct
   trunk/netbrush/client.cpp
   trunk/netbrush/drawing_context.hpp
   trunk/netbrush/globals.cpp
   trunk/netbrush/globals.hpp
   trunk/netbrush/screen_buffer.cpp
Log:
- added navigation widget with thumbnail support

Modified: trunk/netbrush/SConstruct
===================================================================
--- trunk/netbrush/SConstruct	2006-10-19 20:14:40 UTC (rev 657)
+++ trunk/netbrush/SConstruct	2006-10-19 21:01:28 UTC (rev 658)
@@ -47,6 +47,7 @@
         'widget/slider_widget.cpp',
         'widget/widget.cpp',
         'widget/widget_manager.cpp',
+        'navigation.cpp'
 #        'widget/events.cpp',
 ])
 

Modified: trunk/netbrush/client.cpp
===================================================================
--- trunk/netbrush/client.cpp	2006-10-19 20:14:40 UTC (rev 657)
+++ trunk/netbrush/client.cpp	2006-10-19 21:01:28 UTC (rev 658)
@@ -22,6 +22,7 @@
 #include "hue_picker.hpp"
 #include "alpha_picker.hpp"
 #include "brush_widget.hpp"
+#include "navigation.hpp"
 #include "server_connection.hpp"
 #include "widget/slider_widget.hpp"
 
@@ -120,6 +121,10 @@
             {
               client_draw_param->opacity = std::min(255, client_draw_param->opacity + 16);
             }
+          else if (event.key.keysym.sym == SDLK_u)
+            {
+              navigation->update();
+            }
           break;
 
         case SDL_MOUSEBUTTONDOWN:
@@ -274,6 +279,7 @@
     }
   
   widget_manager = new WidgetManager();
+  widget_manager->add(navigation = new Navigation(Rect(screen->w - 128, screen->h - 128, screen->w, screen->h)));
   widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-airbrush-22.png"), 
                                  Rect(Point(2, 2+0*34), Size(34, 34)),
                                  new ToolButtonCallback(DrawingParameter::TOOL_AIRBRUSH)));

Modified: trunk/netbrush/drawing_context.hpp
===================================================================
--- trunk/netbrush/drawing_context.hpp	2006-10-19 20:14:40 UTC (rev 657)
+++ trunk/netbrush/drawing_context.hpp	2006-10-19 21:01:28 UTC (rev 658)
@@ -52,6 +52,8 @@
 
   int get_width()  const { return drawable->w; }
   int get_height() const { return drawable->h; }
+
+  SDL_Surface* get_surface() { return drawable; }
 };
 
 #endif

Modified: trunk/netbrush/globals.cpp
===================================================================
--- trunk/netbrush/globals.cpp	2006-10-19 20:14:40 UTC (rev 657)
+++ trunk/netbrush/globals.cpp	2006-10-19 21:01:28 UTC (rev 658)
@@ -43,4 +43,6 @@
 Scrollbar* horizontal_scrollbar = 0;
 Scrollbar* vertical_scrollbar   = 0;
 
+Navigation* navigation = 0;
+
 /* EOF */

Modified: trunk/netbrush/globals.hpp
===================================================================
--- trunk/netbrush/globals.hpp	2006-10-19 20:14:40 UTC (rev 657)
+++ trunk/netbrush/globals.hpp	2006-10-19 21:01:28 UTC (rev 658)
@@ -45,6 +45,7 @@
 class BrushWidget;
 class ServerConnection;
 class Scrollbar;
+class Navigation;
 
 extern SDLNet_SocketSet socketset;
 
@@ -64,6 +65,8 @@
 extern ServerConnection* server;
 extern Stroke* current_stroke;
 
+extern Navigation* navigation;
+
 #endif
 
 /* EOF */

Added: trunk/netbrush/navigation.cpp
===================================================================
--- trunk/netbrush/navigation.cpp	2006-10-19 20:14:40 UTC (rev 657)
+++ trunk/netbrush/navigation.cpp	2006-10-19 21:01:28 UTC (rev 658)
@@ -0,0 +1,86 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#include <iostream>
+#include "video.hpp"
+#include "globals.hpp"
+#include "drawing_context.hpp"
+#include "navigation.hpp"
+
+Navigation::Navigation(const Rect& rect_)
+  : Widget(rect_)
+{
+  surface = create_surface(rect_.get_width(), rect_.get_height());  
+}
+
+void
+Navigation::on_mouse_motion(const MouseMotionEvent& motion)
+{
+  set_dirty(true);
+}
+
+void
+Navigation::on_mouse_button(const MouseButtonEvent& button)
+{
+  
+}
+
+void
+Navigation::draw(SDL_Surface* target)
+{
+  SDL_Rect pos;
+  pos.x = get_rect().left;
+  pos.y = get_rect().top;
+
+  SDL_BlitSurface(surface, 0, target, &pos);  
+}
+
+void
+Navigation::update()
+{
+  std::cout << "Navigation::update" << std::endl;
+  SDL_Surface* drawable = draw_ctx->get_surface();
+  SDL_LockSurface(drawable);
+  SDL_LockSurface(surface);
+
+  Uint8* target = static_cast<Uint8*>(surface->pixels);
+  Uint8* source = static_cast<Uint8*>(drawable->pixels);
+
+  int sx = drawable->w / surface->w;
+  int sy = drawable->h / surface->h;
+  
+  for(int y = 0; y < surface->h; ++y)
+    for(int x = 0; x < surface->pitch; ++x)
+      {
+        target[y * surface->pitch + x] = source[(y*sy) * drawable->pitch + (x*sx)];
+      }
+
+  SDL_UnlockSurface(surface);
+  SDL_UnlockSurface(drawable);
+
+  set_dirty(true);
+}
+
+/* EOF */

Added: trunk/netbrush/navigation.hpp
===================================================================
--- trunk/netbrush/navigation.hpp	2006-10-19 20:14:40 UTC (rev 657)
+++ trunk/netbrush/navigation.hpp	2006-10-19 21:01:28 UTC (rev 658)
@@ -0,0 +1,55 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#ifndef HEADER_NAVIGATION_HPP
+#define HEADER_NAVIGATION_HPP
+
+#include "widget/widget.hpp"
+
+/** */
+class Navigation : public Widget
+{
+private:
+  SDL_Surface* surface;
+
+public:
+  Navigation(const Rect& rect);
+  
+  void on_mouse_motion(const MouseMotionEvent& motion);
+  void on_mouse_button(const MouseButtonEvent& button);
+
+  void on_enter() {};
+  void on_leave() {}
+
+  void draw(SDL_Surface* target);
+  void update();
+private:
+  Navigation (const Navigation&);
+  Navigation& operator= (const Navigation&);
+};
+
+#endif
+
+/* EOF */

Modified: trunk/netbrush/screen_buffer.cpp
===================================================================
--- trunk/netbrush/screen_buffer.cpp	2006-10-19 20:14:40 UTC (rev 657)
+++ trunk/netbrush/screen_buffer.cpp	2006-10-19 21:01:28 UTC (rev 658)
@@ -104,6 +104,39 @@
       draw_ctx->draw(target, dirty_region, trans_x, trans_y);
       if (!scrolling)
         stroke_buffer->draw(target, dirty_region, trans_x, trans_y);
+
+      { // draw layer boundary
+        Uint32 color = SDL_MapRGB(target->format, 0, 0, 0);
+        SDL_Rect r;
+
+        r.x = trans_x;
+        r.y = trans_y;
+        r.w = draw_ctx->get_width();
+        r.h = 1;
+
+        SDL_FillRect(target, &r, color);
+
+        r.x = trans_x;
+        r.y = draw_ctx->get_height()-1 + trans_y;
+        r.w = draw_ctx->get_width();
+        r.h = 1;
+
+        SDL_FillRect(target, &r, color);
+
+        r.x = draw_ctx->get_width()-1 + trans_x;
+        r.y = trans_y;
+        r.w = 1;
+        r.h = draw_ctx->get_height();
+
+        SDL_FillRect(target, &r, color);
+
+        r.x = trans_x;
+        r.y = trans_y;
+        r.w = 1;
+        r.h = draw_ctx->get_height();
+
+        SDL_FillRect(target, &r, color);
+      }
   
       SDL_UpdateRect(target, 
                      dirty_region.left,        dirty_region.top, 



From grumbel at mail.berlios.de  Thu Oct 19 23:14:18 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Thu, 19 Oct 2006 23:14:18 +0200
Subject: [Flexlay-commit] r659 - trunk/netbrush
Message-ID: <200610192114.k9JLEIvu013594@sheep.berlios.de>

Author: grumbel
Date: 2006-10-19 23:14:18 +0200 (Thu, 19 Oct 2006)
New Revision: 659

Modified:
   trunk/netbrush/client.cpp
   trunk/netbrush/navigation.cpp
   trunk/netbrush/navigation.hpp
   trunk/netbrush/screen_buffer.cpp
   trunk/netbrush/screen_buffer.hpp
Log:
- added mouse support to navigation

Modified: trunk/netbrush/client.cpp
===================================================================
--- trunk/netbrush/client.cpp	2006-10-19 21:01:28 UTC (rev 658)
+++ trunk/netbrush/client.cpp	2006-10-19 21:14:18 UTC (rev 659)
@@ -279,7 +279,8 @@
     }
   
   widget_manager = new WidgetManager();
-  widget_manager->add(navigation = new Navigation(Rect(screen->w - 128, screen->h - 128, screen->w, screen->h)));
+  widget_manager->add(navigation = new Navigation(Rect(Point(screen->w - 128 - 2, screen->h - 128 - 2),
+                                                       Size(128, 128))));
   widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-airbrush-22.png"), 
                                  Rect(Point(2, 2+0*34), Size(34, 34)),
                                  new ToolButtonCallback(DrawingParameter::TOOL_AIRBRUSH)));

Modified: trunk/netbrush/navigation.cpp
===================================================================
--- trunk/netbrush/navigation.cpp	2006-10-19 21:01:28 UTC (rev 658)
+++ trunk/netbrush/navigation.cpp	2006-10-19 21:14:18 UTC (rev 659)
@@ -27,10 +27,11 @@
 #include "video.hpp"
 #include "globals.hpp"
 #include "drawing_context.hpp"
+#include "screen_buffer.hpp"
 #include "navigation.hpp"
 
 Navigation::Navigation(const Rect& rect_)
-  : Widget(rect_)
+  : Widget(rect_), dragging(false)
 {
   surface = create_surface(rect_.get_width(), rect_.get_height());  
 }
@@ -38,13 +39,31 @@
 void
 Navigation::on_mouse_motion(const MouseMotionEvent& motion)
 {
-  set_dirty(true);
+  if (dragging)
+    {
+      screen_buffer->move_to(draw_ctx->get_width()  * motion.x / get_rect().get_width(),
+                             draw_ctx->get_height() * motion.y / get_rect().get_height());
+    }
 }
 
 void
 Navigation::on_mouse_button(const MouseButtonEvent& button)
 {
-  
+  if (button.button == 1)
+    {
+      if (button.state == SDL_RELEASED)
+        {
+          screen_buffer->move_to(draw_ctx->get_width()  * button.x / get_rect().get_width(),
+                                 draw_ctx->get_height() * button.y / get_rect().get_height());
+          dragging = false;
+        }
+      else if (button.state == SDL_PRESSED)
+        {
+          screen_buffer->move_to(draw_ctx->get_width()  * button.x / get_rect().get_width(),
+                                 draw_ctx->get_height() * button.y / get_rect().get_height());
+          dragging = true;
+        }
+    }
 }
 
 void

Modified: trunk/netbrush/navigation.hpp
===================================================================
--- trunk/netbrush/navigation.hpp	2006-10-19 21:01:28 UTC (rev 658)
+++ trunk/netbrush/navigation.hpp	2006-10-19 21:14:18 UTC (rev 659)
@@ -33,7 +33,7 @@
 {
 private:
   SDL_Surface* surface;
-
+  bool dragging;
 public:
   Navigation(const Rect& rect);
   

Modified: trunk/netbrush/screen_buffer.cpp
===================================================================
--- trunk/netbrush/screen_buffer.cpp	2006-10-19 21:01:28 UTC (rev 658)
+++ trunk/netbrush/screen_buffer.cpp	2006-10-19 21:14:18 UTC (rev 659)
@@ -281,4 +281,21 @@
     }
 }
 
+void
+ScreenBuffer::move_to(int x, int y)
+{
+  scroll_offset_x = get_rect().get_width()/2  - x;
+  scroll_offset_y = get_rect().get_height()/2 - y;
+  std::cout << "MoveTo: " << x << " " << y << std::endl;
+
+  Rect r(0, 0, get_rect().get_width(), get_rect().get_height());
+  r.left   -= scroll_offset_x;
+  r.right  -= scroll_offset_x;
+  r.top    -= scroll_offset_y;
+  r.bottom -= scroll_offset_y;
+  mark_dirty(r);
+
+  set_dirty(true);
+}
+
 /* EOF */

Modified: trunk/netbrush/screen_buffer.hpp
===================================================================
--- trunk/netbrush/screen_buffer.hpp	2006-10-19 21:01:28 UTC (rev 658)
+++ trunk/netbrush/screen_buffer.hpp	2006-10-19 21:14:18 UTC (rev 659)
@@ -63,8 +63,10 @@
   void on_enter() {}
   void on_leave() {}
 
-   bool do_update() { return false; }
+  bool do_update() { return false; }
 
+  void move_to(int x, int y);
+
 private:
   ScreenBuffer (const ScreenBuffer&);
   ScreenBuffer& operator= (const ScreenBuffer&);



From grumbel at mail.berlios.de  Fri Oct 20 01:02:34 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Fri, 20 Oct 2006 01:02:34 +0200
Subject: [Flexlay-commit] r661 - trunk/netbrush
Message-ID: <200610192302.k9JN2YZC016373@sheep.berlios.de>

Author: grumbel
Date: 2006-10-20 01:02:30 +0200 (Fri, 20 Oct 2006)
New Revision: 661

Modified:
   trunk/netbrush/NEWS
   trunk/netbrush/SConstruct
   trunk/netbrush/drawing_parameter.cpp
   trunk/netbrush/drawing_parameter.hpp
   trunk/netbrush/grayscale_buffer.cpp
   trunk/netbrush/screen_buffer.cpp
   trunk/netbrush/stroke_buffer.cpp
Log:
- fixed crash bug
- made spacing brush size depended 
- switched default tool to paintbrush

Modified: trunk/netbrush/NEWS
===================================================================
--- trunk/netbrush/NEWS	2006-10-19 22:19:55 UTC (rev 660)
+++ trunk/netbrush/NEWS	2006-10-19 23:02:30 UTC (rev 661)
@@ -11,4 +11,7 @@
 - scrolling (buggy)
 - load/save on the server side
 
+netbrush 0.0.0 (Oct 12 2006)
+============================
+
 # EOF #

Modified: trunk/netbrush/SConstruct
===================================================================
--- trunk/netbrush/SConstruct	2006-10-19 22:19:55 UTC (rev 660)
+++ trunk/netbrush/SConstruct	2006-10-19 23:02:30 UTC (rev 661)
@@ -6,7 +6,7 @@
 
 server_env = Environment()
 server_env.ParseConfig('sdl-config --cflags --libs')
-server_env['CXXFLAGS'] += ['-O2', '-Wall', '-g']
+server_env['CXXFLAGS'] += ['-O0', '-Wall', '-g']
 server_env['LIBS'] += ['SDL_net']
 server_env.Program('server', [
         'server.cpp'
@@ -15,7 +15,7 @@
 
 client_env = Environment()
 client_env.ParseConfig('sdl-config --cflags --libs')
-client_env['CXXFLAGS'] += ['-O2', '-Wall', '-g']
+client_env['CXXFLAGS'] += ['-O0', '-Wall', '-g']
 client_env['CPPPATH'] += ['.']
 client_env['LIBS'] += ['SDL_image', 'SDL_net']
 client_env.Program('client', [

Modified: trunk/netbrush/drawing_parameter.cpp
===================================================================
--- trunk/netbrush/drawing_parameter.cpp	2006-10-19 22:19:55 UTC (rev 660)
+++ trunk/netbrush/drawing_parameter.cpp	2006-10-19 23:02:30 UTC (rev 661)
@@ -27,7 +27,7 @@
 #include "drawing_parameter.hpp"
 
 DrawingParameter::DrawingParameter()
-  : tool(TOOL_AIRBRUSH),
+  : tool(TOOL_PAINTBRUSH),
     brush_surface(0), 
     brush_buffer(0), 
     color(0, 0, 0), 
@@ -82,4 +82,10 @@
   return brush_buffer->get_width();
 }
 
+float
+DrawingParameter::get_spacing()
+{
+  return brush_buffer->get_width() * spacing / 12.0f;
+}
+
 /* EOF */

Modified: trunk/netbrush/drawing_parameter.hpp
===================================================================
--- trunk/netbrush/drawing_parameter.hpp	2006-10-19 22:19:55 UTC (rev 660)
+++ trunk/netbrush/drawing_parameter.hpp	2006-10-19 23:02:30 UTC (rev 661)
@@ -50,6 +50,7 @@
 public:
   DrawingParameter();
 
+  float get_spacing();
   void set_brush(const std::string& filename);
   std::string get_brush() const;
   SDL_Surface* get_brush_surface() const;

Modified: trunk/netbrush/grayscale_buffer.cpp
===================================================================
--- trunk/netbrush/grayscale_buffer.cpp	2006-10-19 22:19:55 UTC (rev 660)
+++ trunk/netbrush/grayscale_buffer.cpp	2006-10-19 23:02:30 UTC (rev 661)
@@ -29,6 +29,7 @@
 #include <iostream>
 #include <algorithm>
 #include "math/rect.hpp"
+#include "video.hpp"
 #include "grayscale_buffer.hpp"
 
 GrayscaleBuffer::GrayscaleBuffer(SDL_Surface* surface)
@@ -78,13 +79,17 @@
 }
   
 void
-GrayscaleBuffer::fill_rect(const Rect& rect, Uint8 c)
+GrayscaleBuffer::fill_rect(const Rect& rect_, Uint8 c)
 {
-  // FIXME: No clipping done
-  for(int y = rect.top; y < rect.bottom; ++y)
-    {
-      memset(buffer + y * width + rect.left, c, rect.get_width());
-    }
+  Rect rect = rect_;
+  clip_to(rect, Rect(0, 0, width, height));
+
+  // FIXME: Ugly way to clip
+  if (rect.left < rect.right && rect.top < rect.bottom)
+    for(int y = rect.top; y < rect.bottom; ++y)
+      {
+        memset(buffer + y * width + rect.left, c, rect.get_width());
+      }
 }
 
 void

Modified: trunk/netbrush/screen_buffer.cpp
===================================================================
--- trunk/netbrush/screen_buffer.cpp	2006-10-19 22:19:55 UTC (rev 660)
+++ trunk/netbrush/screen_buffer.cpp	2006-10-19 23:02:30 UTC (rev 661)
@@ -314,7 +314,7 @@
 {
   scroll_offset_x = get_rect().get_width()/2  - x;
   scroll_offset_y = get_rect().get_height()/2 - y;
-  std::cout << "MoveTo: " << x << " " << y << std::endl;
+  //std::cout << "MoveTo: " << x << " " << y << std::endl;
 
   Rect r(0, 0, get_rect().get_width(), get_rect().get_height());
   r.left   -= scroll_offset_x;

Modified: trunk/netbrush/stroke_buffer.cpp
===================================================================
--- trunk/netbrush/stroke_buffer.cpp	2006-10-19 22:19:55 UTC (rev 660)
+++ trunk/netbrush/stroke_buffer.cpp	2006-10-19 23:02:30 UTC (rev 661)
@@ -102,7 +102,7 @@
     }
   else if (param->tool == DrawingParameter::TOOL_PAINTBRUSH)
     {
-      Stroke::Dabs dabs = stroke.get_interpolated_dabs(param->spacing, param->spacing);
+      Stroke::Dabs dabs = stroke.get_interpolated_dabs(param->get_spacing(), param->get_spacing());
       for(Stroke::Dabs::iterator i = dabs.begin(); i != dabs.end(); ++i)
         {
           buffer->blit(brush,



From grumbel at mail.berlios.de  Fri Oct 20 10:29:31 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Fri, 20 Oct 2006 10:29:31 +0200
Subject: [Flexlay-commit] r662 - trunk/netbrush
Message-ID: <200610200829.k9K8TVeA009449@sheep.berlios.de>

Author: grumbel
Date: 2006-10-20 10:29:30 +0200 (Fri, 20 Oct 2006)
New Revision: 662

Added:
   trunk/netbrush/graphic_context_state.cpp
   trunk/netbrush/graphic_context_state.hpp
Modified:
   trunk/netbrush/SConstruct
   trunk/netbrush/drawing_context.cpp
Log:
- some code for zooming

Modified: trunk/netbrush/SConstruct
===================================================================
--- trunk/netbrush/SConstruct	2006-10-19 23:02:30 UTC (rev 661)
+++ trunk/netbrush/SConstruct	2006-10-20 08:29:30 UTC (rev 662)
@@ -47,7 +47,8 @@
         'widget/slider_widget.cpp',
         'widget/widget.cpp',
         'widget/widget_manager.cpp',
-        'navigation.cpp'
+        'navigation.cpp',
+        'graphic_context_state.cpp',
 #        'widget/events.cpp',
 ])
 

Modified: trunk/netbrush/drawing_context.cpp
===================================================================
--- trunk/netbrush/drawing_context.cpp	2006-10-19 23:02:30 UTC (rev 661)
+++ trunk/netbrush/drawing_context.cpp	2006-10-20 08:29:30 UTC (rev 662)
@@ -106,30 +106,57 @@
 }
 
 void
-DrawingContext::draw(SDL_Surface* target, const Rect& rect, int x_of, int y_of)
+DrawingContext::draw(SDL_Surface* target_surf, const Rect& rect, int x_of, int y_of)
 {
   // rect is in screenspace, x_of, y_of tell how to go from canvas to screenspace
 
-  SDL_Rect target_pos;
-  target_pos.x = rect.left;
-  target_pos.y = rect.top;
-  target_pos.w = rect.get_width();
-  target_pos.h = rect.get_height();
+  if (1) // no zoom
+    {
+      SDL_Rect target_pos;
+      target_pos.x = rect.left;
+      target_pos.y = rect.top;
+      target_pos.w = rect.get_width();
+      target_pos.h = rect.get_height();
 
-  SDL_Rect source_pos;
-  source_pos.x = rect.left - x_of;
-  source_pos.y = rect.top  - y_of;
-  source_pos.w = rect.get_width();
-  source_pos.h = rect.get_height();
+      SDL_Rect source_pos;
+      source_pos.x = rect.left - x_of;
+      source_pos.y = rect.top  - y_of;
+      source_pos.w = rect.get_width();
+      source_pos.h = rect.get_height();
 
-  SDL_Rect r;
-  r.x = 0;
-  r.y = 0;
-  r.w = drawable->w;
-  r.h = drawable->h;
+      SDL_Rect r;
+      r.x = 0;
+      r.y = 0;
+      r.w = drawable->w;
+      r.h = drawable->h;
 
-  clip_to(&source_pos, &r);
-  SDL_BlitSurface(drawable, &source_pos, target, &target_pos);
+      clip_to(&source_pos, &r);
+      SDL_BlitSurface(drawable, &source_pos, target_surf, &target_pos);
+    }
+  else
+    {
+      SDL_LockSurface(target_surf);
+      SDL_LockSurface(drawable);
+
+      Uint8* target = static_cast<Uint8*>(target_surf->pixels);
+      Uint8* source = static_cast<Uint8*>(drawable->pixels);
+
+      // FIXME: do clipping or do clipping at a higher level in the code
+      float zoom = 2.0f;
+      for(int y = rect.top; y < rect.bottom; ++y)
+        for(int x = rect.left; x < rect.right; ++x)
+          {
+            int sx = int(x * zoom);
+            int sy = int(y * zoom);
+
+            target[y * target_surf->pitch + target_surf->format->BytesPerPixel * x + 2] = source[sy * drawable->pitch + drawable->format->BytesPerPixel * sx + 0];
+            target[y * target_surf->pitch + target_surf->format->BytesPerPixel * x + 1] = source[sy * drawable->pitch + drawable->format->BytesPerPixel * sx + 1];
+            target[y * target_surf->pitch + target_surf->format->BytesPerPixel * x + 0] = source[sy * drawable->pitch + drawable->format->BytesPerPixel * sx + 2];
+          }
+
+      SDL_UnlockSurface(drawable);
+      SDL_UnlockSurface(target_surf);
+    }
 }
 
 /* EOF */

Added: trunk/netbrush/graphic_context_state.cpp
===================================================================
--- trunk/netbrush/graphic_context_state.cpp	2006-10-19 23:02:30 UTC (rev 661)
+++ trunk/netbrush/graphic_context_state.cpp	2006-10-20 08:29:30 UTC (rev 662)
@@ -0,0 +1,201 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#include <math.h>
+#include "graphic_context_state.hpp"
+
+class GraphicContextStateImpl
+{
+public:
+  int width;
+  int height;
+  
+  Vector offset;
+  float zoom;
+  float rotation;
+};
+
+GraphicContextState::GraphicContextState()
+  : impl(new GraphicContextStateImpl())
+{
+  impl->width  = 1;
+  impl->height = 1; 
+  impl->offset = Vector(0,0);
+  impl->zoom   = 1.0f;
+  impl->rotation = 0;
+}
+
+GraphicContextState::GraphicContextState(int w, int h)
+  : impl(new GraphicContextStateImpl())
+{  
+  impl->width  = w;
+  impl->height = h;
+  impl->offset = Vector(0,0); 
+  impl->zoom   = 1.0f;
+  impl->rotation = 0;
+}
+
+void
+GraphicContextState::set_size(int w, int h)
+{
+  impl->width  = w;
+  impl->height = h;
+}
+
+#if 0
+void
+GraphicContextState::push(CL_GraphicContext* gc)
+{
+  if (gc == 0)
+    gc = CL_Display::get_current_window()->get_gc();
+  
+  gc->push_modelview();
+
+  gc->add_translate(impl->width/2, impl->height/2);
+  gc->add_rotate(impl->rotation, 0, 0, 1.0);
+  gc->add_translate(-impl->width/2, -impl->height/2);
+
+  gc->add_scale(get_zoom(), get_zoom());
+  gc->add_translate(impl->offset.x, impl->offset.y);
+}
+
+void
+GraphicContextState::pop(CL_GraphicContext* gc)
+{
+  if (gc == 0)
+    gc = CL_Display::get_current_window()->get_gc();
+  
+  gc->pop_modelview();
+}
+#endif
+
+Rectf
+GraphicContextState::get_clip_rect()
+{
+  return Rectf(Vector(-impl->offset.x,
+                            -impl->offset.y),
+                  Sizef(get_width()  / impl->zoom,
+                           get_height() / impl->zoom));
+}
+
+void
+GraphicContextState::set_pos(const Vector& pos)
+{
+  impl->offset.x = -pos.x + (get_width()/2  / impl->zoom);
+  impl->offset.y = -pos.y + (get_height()/2 / impl->zoom);
+}
+
+Vector
+GraphicContextState::get_pos() const
+{
+  return Vector(-impl->offset.x + (get_width()/2  / impl->zoom),
+                   -impl->offset.y + (get_height()/2  / impl->zoom));
+}
+
+void
+GraphicContextState::set_zoom(Vector pos, float z)
+{
+  float old_zoom = impl->zoom;
+  set_zoom(z);
+  impl->offset.x = pos.x/impl->zoom - pos.x/old_zoom + impl->offset.x;
+  impl->offset.y = pos.y/impl->zoom - pos.y/old_zoom + impl->offset.y;
+}
+
+void
+GraphicContextState::set_zoom(float z)
+{
+  impl->zoom = z;
+}
+
+float
+GraphicContextState::get_zoom()
+{
+  return impl->zoom;
+}
+
+void
+GraphicContextState::zoom_to (const Rectf& rect)
+{
+  float center_x = (rect.left + rect.right) / 2.0f;
+  float center_y = (rect.top + rect.bottom) / 2.0f;
+
+  float width  = rect.right - rect.left;
+  float height = rect.bottom - rect.top;
+  float screen_relation = float(get_height())/float(get_width ());
+  float rect_relation   = height/width; 
+  
+  //std::cout << "Screen: " << screen_relation << " Zoom: " << rect_relation << std::endl;
+  if (rect_relation < screen_relation) // take width, ignore height
+    {
+      impl->zoom = get_width()/width; 
+    }
+  else // take height, ignore width
+    {
+      impl->zoom = get_height()/height;
+    }
+
+  impl->offset.x = (get_width()  / (2*impl->zoom)) - center_x;
+  impl->offset.y = (get_height() / (2*impl->zoom)) - center_y;
+}
+
+Vector
+GraphicContextState::screen2world(const Point& pos_)
+{
+  Vector pos(pos_.x, pos_.y);
+
+  float sa = sin(-impl->rotation/180.0f*M_PI);
+  float ca = cos(-impl->rotation/180.0f*M_PI);
+
+  float dx = pos.x - impl->width/2;
+  float dy = pos.y - impl->height/2;
+
+  pos.x = impl->width/2  + (ca * dx - sa * dy);
+  pos.y = impl->height/2 + (sa * dx + ca * dy);
+
+  Vector p((float(pos.x) / impl->zoom) - impl->offset.x, 
+              (float(pos.y) / impl->zoom) - impl->offset.y);
+
+  return p;
+}
+
+void
+GraphicContextState::set_rotation(float angle)
+{
+  impl->rotation = angle;
+}
+
+float
+GraphicContextState::get_rotation()
+{
+  return impl->rotation;
+}
+
+int
+GraphicContextState::get_width()  const 
+{
+  return impl->width; 
+}
+
+int
+GraphicContextState::get_height() const 
+{ 
+  return impl->height; 
+}
+
+/* EOF */

Added: trunk/netbrush/graphic_context_state.hpp
===================================================================
--- trunk/netbrush/graphic_context_state.hpp	2006-10-19 23:02:30 UTC (rev 661)
+++ trunk/netbrush/graphic_context_state.hpp	2006-10-20 08:29:30 UTC (rev 662)
@@ -0,0 +1,81 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#ifndef HEADER_GRAPHIC_CONTEXT_STATE_HXX
+#define HEADER_GRAPHIC_CONTEXT_STATE_HXX
+
+#include "math/rect.hpp"
+#include "math/point.hpp"
+
+class CL_GraphicContext;
+
+class GraphicContextStateImpl;
+
+/** Helper class for capturing the state of a GraphicContext, with
+    additional convenience functions to make handling GraphicContexts
+    easier */
+class GraphicContextState
+{
+public:
+  GraphicContextState();
+  GraphicContextState(int w, int h);
+
+  void set_size(int w, int h);
+
+  //void push(CL_GraphicContext* gc = 0);
+  //void pop (CL_GraphicContext* gc = 0);
+
+  /** Return a rectangle in world coordinates that represents the area
+      visible on the screen */
+  Rectf get_clip_rect();
+
+  int get_width()  const;
+  int get_height() const;
+
+  /** Set the current rotation angel */
+  void  set_rotation(float angle);
+
+  /** Return the current rotation angel */
+  float get_rotation();
+
+  /** Move the center of the visible area to pos */
+  void   set_pos(const Vector& pos);
+  Vector get_pos() const;
+
+  /** Set zoom to z, while ensuring that the screen position \a pos
+      (normaly the position of the mouse pointer) stays in the same
+      position even after zoomed in/out */
+  void  set_zoom(Vector pos, float z);
+  void  set_zoom(float z);
+  float get_zoom(); 
+
+  void zoom_to (const Rectf& rect);
+
+  Vector screen2world(const Point& pos);
+
+private:
+  GraphicContextStateImpl* impl;
+
+  GraphicContextState (const GraphicContextState&);
+  GraphicContextState& operator= (const GraphicContextState&);
+};
+
+#endif
+
+/* EOF */



From grumbel at mail.berlios.de  Fri Oct 20 10:32:25 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Fri, 20 Oct 2006 10:32:25 +0200
Subject: [Flexlay-commit] r663 - in trunk/netbrush: . src src/widget
Message-ID: <200610200832.k9K8WPtc009911@sheep.berlios.de>

Author: grumbel
Date: 2006-10-20 10:32:24 +0200 (Fri, 20 Oct 2006)
New Revision: 663

Added:
   trunk/netbrush/src/
   trunk/netbrush/src/SConstruct
   trunk/netbrush/src/alpha_picker.cpp
   trunk/netbrush/src/alpha_picker.hpp
   trunk/netbrush/src/brush_widget.cpp
   trunk/netbrush/src/brush_widget.hpp
   trunk/netbrush/src/brushmask.cpp
   trunk/netbrush/src/brushmask.hpp
   trunk/netbrush/src/client.cpp
   trunk/netbrush/src/client_state.cpp
   trunk/netbrush/src/client_state.hpp
   trunk/netbrush/src/color.hpp
   trunk/netbrush/src/debug.cpp
   trunk/netbrush/src/debug.hpp
   trunk/netbrush/src/drawing_context.cpp
   trunk/netbrush/src/drawing_context.hpp
   trunk/netbrush/src/drawing_parameter.cpp
   trunk/netbrush/src/drawing_parameter.hpp
   trunk/netbrush/src/generic_brush.cpp
   trunk/netbrush/src/generic_brush.hpp
   trunk/netbrush/src/globals.cpp
   trunk/netbrush/src/globals.hpp
   trunk/netbrush/src/graphic_context_state.cpp
   trunk/netbrush/src/graphic_context_state.hpp
   trunk/netbrush/src/grayscale_buffer.cpp
   trunk/netbrush/src/grayscale_buffer.hpp
   trunk/netbrush/src/hue_picker.cpp
   trunk/netbrush/src/hue_picker.hpp
   trunk/netbrush/src/math/
   trunk/netbrush/src/navigation.cpp
   trunk/netbrush/src/navigation.hpp
   trunk/netbrush/src/saturation_value_picker.cpp
   trunk/netbrush/src/saturation_value_picker.hpp
   trunk/netbrush/src/screen_buffer.cpp
   trunk/netbrush/src/screen_buffer.hpp
   trunk/netbrush/src/server.cpp
   trunk/netbrush/src/server_connection.cpp
   trunk/netbrush/src/server_connection.hpp
   trunk/netbrush/src/stroke.cpp
   trunk/netbrush/src/stroke.hpp
   trunk/netbrush/src/stroke_buffer.cpp
   trunk/netbrush/src/stroke_buffer.hpp
   trunk/netbrush/src/video.cpp
   trunk/netbrush/src/video.hpp
   trunk/netbrush/src/widget/
   trunk/netbrush/src/widget/button.cpp
   trunk/netbrush/src/widget/button.hpp
   trunk/netbrush/src/widget/scrollbar.cpp
   trunk/netbrush/src/widget/scrollbar.hpp
   trunk/netbrush/src/widget/slider_widget.cpp
   trunk/netbrush/src/widget/slider_widget.hpp
   trunk/netbrush/src/widget/widget.cpp
   trunk/netbrush/src/widget/widget_manager.cpp
Removed:
   trunk/netbrush/SConstruct
   trunk/netbrush/alpha_picker.cpp
   trunk/netbrush/alpha_picker.hpp
   trunk/netbrush/brush_widget.cpp
   trunk/netbrush/brush_widget.hpp
   trunk/netbrush/brushmask.cpp
   trunk/netbrush/brushmask.hpp
   trunk/netbrush/client.cpp
   trunk/netbrush/client_state.cpp
   trunk/netbrush/client_state.hpp
   trunk/netbrush/color.hpp
   trunk/netbrush/debug.cpp
   trunk/netbrush/debug.hpp
   trunk/netbrush/drawing_context.cpp
   trunk/netbrush/drawing_context.hpp
   trunk/netbrush/drawing_parameter.cpp
   trunk/netbrush/drawing_parameter.hpp
   trunk/netbrush/generic_brush.cpp
   trunk/netbrush/generic_brush.hpp
   trunk/netbrush/globals.cpp
   trunk/netbrush/globals.hpp
   trunk/netbrush/graphic_context_state.cpp
   trunk/netbrush/graphic_context_state.hpp
   trunk/netbrush/grayscale_buffer.cpp
   trunk/netbrush/grayscale_buffer.hpp
   trunk/netbrush/hue_picker.cpp
   trunk/netbrush/hue_picker.hpp
   trunk/netbrush/math/
   trunk/netbrush/navigation.cpp
   trunk/netbrush/navigation.hpp
   trunk/netbrush/saturation_value_picker.cpp
   trunk/netbrush/saturation_value_picker.hpp
   trunk/netbrush/screen_buffer.cpp
   trunk/netbrush/screen_buffer.hpp
   trunk/netbrush/server.cpp
   trunk/netbrush/server_connection.cpp
   trunk/netbrush/server_connection.hpp
   trunk/netbrush/src/widget/button.cpp
   trunk/netbrush/src/widget/button.hpp
   trunk/netbrush/src/widget/callback.hpp
   trunk/netbrush/src/widget/slider_widget.cpp
   trunk/netbrush/src/widget/slider_widget.hpp
   trunk/netbrush/src/widget/widget.cpp
   trunk/netbrush/src/widget/widget_manager.cpp
   trunk/netbrush/stroke.cpp
   trunk/netbrush/stroke.hpp
   trunk/netbrush/stroke_buffer.cpp
   trunk/netbrush/stroke_buffer.hpp
   trunk/netbrush/video.cpp
   trunk/netbrush/video.hpp
   trunk/netbrush/widget/
Log:
- some directory reorganisation

Deleted: trunk/netbrush/SConstruct
===================================================================
--- trunk/netbrush/SConstruct	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/SConstruct	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,56 +0,0 @@
-# netbrush_env = Environment()
-# netbrush_env.ParseConfig('sdl-config --cflags --libs')
-# netbrush_env['LIBS'] += ['SDL_net']
-# netbrush_env['CXXFLAGS'] += ['-O2', '-Wall', '-g']
-# netbrush_env.Program('netbrush', ['net.cpp', 'vector.cpp'])
-
-server_env = Environment()
-server_env.ParseConfig('sdl-config --cflags --libs')
-server_env['CXXFLAGS'] += ['-O0', '-Wall', '-g']
-server_env['LIBS'] += ['SDL_net']
-server_env.Program('server', [
-        'server.cpp'
-])
-
-
-client_env = Environment()
-client_env.ParseConfig('sdl-config --cflags --libs')
-client_env['CXXFLAGS'] += ['-O0', '-Wall', '-g']
-client_env['CPPPATH'] += ['.']
-client_env['LIBS'] += ['SDL_image', 'SDL_net']
-client_env.Program('client', [
-        'alpha_picker.cpp',
-        'brush_widget.cpp',
-        'brushmask.cpp',
-        'client.cpp', 
-        'client_state.cpp',
-        'debug.cpp',
-        'drawing_context.cpp',
-        'drawing_parameter.cpp',
-        'generic_brush.cpp',
-        'globals.cpp',
-        'grayscale_buffer.cpp', 
-        'hue_picker.cpp',
-        'math/matrix.cpp',
-        'math/origin.cpp',
-        'math/quaternion.cpp',
-        'math/rect.cpp',
-        'math/vector.cpp',
-        'saturation_value_picker.cpp',
-        'screen_buffer.cpp',
-        'server_connection.cpp',
-        'stroke.cpp',
-        'stroke_buffer.cpp',
-        'video.cpp',
-        'widget/button.cpp',
-        'widget/scrollbar.cpp',
-        'widget/slider_widget.cpp',
-        'widget/widget.cpp',
-        'widget/widget_manager.cpp',
-        'navigation.cpp',
-        'graphic_context_state.cpp',
-#        'widget/events.cpp',
-])
-
-# EOF #
-

Deleted: trunk/netbrush/alpha_picker.cpp
===================================================================
--- trunk/netbrush/alpha_picker.cpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/alpha_picker.cpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,138 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#include <vector>
-#include "video.hpp"
-#include "color.hpp"
-#include "globals.hpp"
-#include "drawing_parameter.hpp"
-#include "widget/widget_manager.hpp"
-#include "alpha_picker.hpp"
-
-AlphaPicker::AlphaPicker(const Rect& rect_)
-  : Widget(rect_), dragging(0)
-{
-  std::vector<Color> colors;
-
-  colors.push_back(Color(255,   0,   0));
-  colors.push_back(Color(255,   0, 255));
-  colors.push_back(Color(  0,   0, 255));
-  colors.push_back(Color(  0, 255, 255));
-  colors.push_back(Color(  0, 255,   0));
-  colors.push_back(Color(255, 255,   0));
-  colors.push_back(Color(255,   0,   0));
-
-  surface = create_surface(rect_.get_width(), rect_.get_height());
-  set_color(Color(255,255,0));
-}
-
-void
-AlphaPicker::on_mouse_motion(const MouseMotionEvent& motion)
-{
-  set_dirty(true);
-  if (dragging)
-    {
-      click_pos.x = motion.x;
-      click_pos.y = motion.y;
-      client_draw_param->opacity = 255 * click_pos.x/get_rect().get_width();
-    }
-}
-
-void
-AlphaPicker::on_mouse_button(const MouseButtonEvent& button)
-{
-  if (button.button == 1)
-    {
-      if (button.state == SDL_RELEASED)
-        {
-          dragging = false;
-          widget_manager->ungrab(this);
-        }
-      else if (button.state == SDL_PRESSED)
-        {
-          dragging = true;
-
-          click_pos.x = button.x;
-          click_pos.y = button.y;
-
-          client_draw_param->opacity = 255 * click_pos.x/get_rect().get_width();
-
-          set_dirty(true);
-          widget_manager->grab(this);
-        }
-    }
-}
-
-void
-AlphaPicker::draw(SDL_Surface* target)
-{
-  SDL_Rect pos;
-  pos.x = get_rect().left;
-  pos.y = get_rect().top;
-
-  SDL_BlitSurface(surface, 0, target, &pos);
-
-
-  SDL_Rect vline;
-  vline.x = click_pos.x + get_rect().left - 1;
-  vline.y = 0 + get_rect().top;
-  vline.w = 3;
-  vline.h = get_rect().get_height();
-
-  SDL_FillRect(target, &vline, SDL_MapRGB(target->format, 0, 0, 0));
-
-  vline.x += 1;
-  vline.w = 1;
-
-  SDL_FillRect(target, &vline, SDL_MapRGB(target->format, 255, 255, 255));
-}
-
-void
-AlphaPicker::set_color(const Color& color)
-{
-  client_draw_param->color = color;
-
-  SDL_LockSurface(surface);
-  Uint8* data = static_cast<Uint8*>(surface->pixels);
-
-  for(int y = 0; y < surface->h; ++y)
-    for(int x = 0; x < surface->w; ++x)
-      {
-        Uint8 c = 255 * x / surface->w;
-
-        Uint8 check = 0;
-        if (((x / 8) % 2) ^ (y / 8) % 2)
-          check = 128;
-
-        data[3*(y * surface->w + x)+0] = (color.r*c + (255 - c)*check)/255;
-        data[3*(y * surface->w + x)+1] = (color.g*c + (255 - c)*check)/255;
-        data[3*(y * surface->w + x)+2] = (color.b*c + (255 - c)*check)/255;
-      }
-  SDL_UnlockSurface(surface);  
-  
-  set_dirty(true);  
-}
-
-/* EOF */

Deleted: trunk/netbrush/alpha_picker.hpp
===================================================================
--- trunk/netbrush/alpha_picker.hpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/alpha_picker.hpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,58 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#ifndef HEADER_ALPHA_PICKER_HPP
-#define HEADER_ALPHA_PICKER_HPP
-
-#include "widget/widget.hpp"
-
-/** */
-class AlphaPicker : public Widget
-{
-private:
-  SDL_Surface* surface;
-  bool  dragging;
-  Point click_pos;
-
-public:
-  AlphaPicker(const Rect& rect);
-
-  void on_mouse_motion(const MouseMotionEvent& motion);
-  void on_mouse_button(const MouseButtonEvent& button);
-
-  void on_enter() {}
-  void on_leave() {}
-
-  void draw(SDL_Surface* target);
-
-  void set_color(const Color& color);
-private:
-  AlphaPicker (const AlphaPicker&);
-  AlphaPicker& operator= (const AlphaPicker&);
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/netbrush/brush_widget.cpp
===================================================================
--- trunk/netbrush/brush_widget.cpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/brush_widget.cpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,201 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#include <algorithm>
-#include "video.hpp"
-#include "globals.hpp"
-#include "drawing_parameter.hpp"
-#include "brushmask.hpp"
-#include "brush_widget.hpp"
-
-BrushWidget::BrushWidget(const Rect& rect_)
-  : Widget(rect_)
-{
-  surface = create_surface(rect_.get_width(), rect_.get_height());
-  
-}
-
-BrushWidget::~BrushWidget()
-{
-  SDL_FreeSurface(surface);
-}
-
-void
-BrushWidget::on_mouse_motion(const MouseMotionEvent& motion)
-{
-  set_dirty(true);
-}
-
-void
-BrushWidget::on_mouse_button(const MouseButtonEvent& button)
-{
-}
-
-void
-BrushWidget::draw(SDL_Surface* target)
-{
-  SDL_Rect pos;
-  pos.x = get_rect().left;
-  pos.y = get_rect().top;
-
-  SDL_BlitSurface(surface, 0, target, &pos);
-}
-
-void 
-BrushWidget::set_brush(const GenericBrush& brush)
-{
-  GrayscaleBuffer* brushmask = generate_brushmask(brush.shape,
-                                                  brush.radius,
-                                                  brush.spikes,     // spikes
-                                                  brush.hardness,  // hardness
-                                                  brush.aspect_ratio,  // aspect
-                                                  brush.angle);
-  
-  SDL_FillRect(surface, NULL, SDL_MapRGB(surface->format, 255, 255, 255));
-  SDL_LockSurface(surface);
-  Uint8* data = static_cast<Uint8*>(surface->pixels);
-
-  int x_of = std::max(0, (surface->w - brushmask->get_width())/2);
-  int y_of = std::max(0, (surface->h - brushmask->get_height())/2);
-  
-  for(int y = 0; y < std::min(brushmask->get_height(), surface->h); ++y)
-    for(int x = 0; x < std::min(brushmask->get_width(), surface->w); ++x)
-      {
-        if (0)
-          { // Checkboard fun
-            Uint8 check = 64;
-            if (((x / 8) % 2) ^ (y / 8) % 2)
-              check = 128+64;
-
-            Uint8 c = brushmask->at(x,y);
-
-            data[3*((y+y_of) * surface->w + (x+x_of))+0] = ((255-c) * check + c*client_draw_param->color.r)/255;
-            data[3*((y+y_of) * surface->w + (x+x_of))+1] = ((255-c) * check + c*client_draw_param->color.g)/255;
-            data[3*((y+y_of) * surface->w + (x+x_of))+2] = ((255-c) * check + c*client_draw_param->color.b)/255;
-          }
-        else
-          {
-            Uint8 c = 255 - brushmask->at(x,y);
-            data[3*((y+y_of) * surface->w + (x+x_of))+0] = c;
-            data[3*((y+y_of) * surface->w + (x+x_of))+1] = c;
-            data[3*((y+y_of) * surface->w + (x+x_of))+2] = c;
-          }
-      }
-      
-  SDL_UnlockSurface(surface); 
-  set_dirty(true);
-
-  // FIXME: where is delete?!
-  client_draw_param->brush_file = "";
-  client_draw_param->brush_buffer = brushmask;
-
-  update_mouse_cursor();
-}
-
-void
-BrushWidget::update_mouse_cursor()
-{
-  if (client_draw_param->generic_brush.radius < 5.0f)
-    return ;
-
-  GrayscaleBuffer* brush = client_draw_param->brush_buffer;
-  
-  int w     = brush->get_width();
-  int pitch = brush->get_width()/8 + 1;
-  int h     = brush->get_height();
-  int len   = pitch * h;
-  Uint8 data[len];
-  Uint8 mask[len];
-
-  memset(data, 0, len);
-  memset(mask, 0, len);
-
-  for(int y = 1; y < brush->get_height()-1; ++y)
-    for(int x = 1; x < brush->get_width()-1; ++x)
-      {
-        int threshold = 64;
-
-        Uint8 check = 0;
-        if (((x / 1) % 2) ^ (y / 1) % 2)
-          check = 1;
-
-
-        if ((brush->at(x-1, y) < threshold && 
-             brush->at(x+1, y) > threshold)
-            ||
-            (brush->at(x-1, y) > threshold && 
-             brush->at(x+1, y) < threshold)
-            ||
-            (brush->at(x, y-1) < threshold && 
-             brush->at(x, y+1) > threshold)
-            ||
-            (brush->at(x, y-1) > threshold && 
-             brush->at(x, y+1) < threshold)
-            )
-          { // black
-            data[y * pitch + x/8] |= (check << (7 - (x%8)));
-            mask[y * pitch + x/8] |= (0x01 << (7 - (x%8)));
-          }
-      }
-  
-  if (w > 7 && h > 7)
-    {
-      int y = h / 2;
-      int x = 0;
-      for(x = w/2 - 3; x <= w/2 + 3; ++x)
-        {
-          data[y * pitch + x/8] |= (0x01 << (7 - (x%8)));
-          mask[y * pitch + x/8] |= (0x01 << (7 - (x%8)));
-        }
-
-      x = w / 2;
-      for(int y = h/2 - 3; y <= h/2 + 3; ++y)
-        {
-          data[y * pitch + x/8] |= (0x01 << (7 - (x%8)));
-          mask[y * pitch + x/8] |= (0x01 << (7 - (x%8)));
-        }
-
-
-      y = h / 2;
-      for(x = w/2 - 1; x <= w/2 + 1; ++x)
-        {
-          data[y * pitch + x/8] ^= (0x01 << (7 - (x%8)));
-          mask[y * pitch + x/8] |= (0x01 << (7 - (x%8)));
-        }
-      
-      x = w / 2;
-      for(int y = h/2 - 1; y <= h/2 + 1; ++y)
-        {
-          data[y * pitch + x/8] ^= (0x01 << (7 - (x%8)));
-          mask[y * pitch + x/8] |= (0x01 << (7 - (x%8)));
-        }
-    }
-
-  SDL_Cursor* cursor = SDL_CreateCursor(data, mask, pitch*8, h, 
-                                        w/2, h/2);
-  SDL_SetCursor(cursor);
-}
-
-/* EOF */

Deleted: trunk/netbrush/brush_widget.hpp
===================================================================
--- trunk/netbrush/brush_widget.hpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/brush_widget.hpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,60 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#ifndef HEADER_BRUSH_WIDGET_HPP
-#define HEADER_BRUSH_WIDGET_HPP
-
-#include "generic_brush.hpp"
-#include "widget/widget.hpp"
-
-/** */
-class BrushWidget : public Widget
-{
-private:
-  SDL_Surface* surface;
-
-public:
-  BrushWidget(const Rect& rect);
-  ~BrushWidget();
-
-  void on_mouse_motion(const MouseMotionEvent& motion);
-  void on_mouse_button(const MouseButtonEvent& button);
-
-  void on_enter() {}
-  void on_leave() {}
-
-  void draw(SDL_Surface* target);
-  void set_brush(const GenericBrush& brush);
-
-  void update_mouse_cursor();
-
-private:
-  BrushWidget (const BrushWidget&);
-  BrushWidget& operator= (const BrushWidget&);
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/netbrush/brushmask.cpp
===================================================================
--- trunk/netbrush/brushmask.cpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/brushmask.cpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,293 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2004 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-/* Most of the code below is taken from Gimp2.2:
-   gimp_brush_generated module Copyright 1998 Jay Cox <jaycox at earthlink.net> 
- */
-
-#include <iostream>
-#include <math.h>
-#include <string.h>
-#include "brushmask.hpp"
-
-#define OVERSAMPLING 5
-
-typedef int gint;
-typedef unsigned char guchar;
-
-#define gimp_deg_to_rad(angle) ((angle) * (2.0 * M_PI) / 360.0)
-#define gimp_rad_to_deg(angle) ((angle) * 360.0 / (2.0 * M_PI))
-
-static double
-gauss (double f)
-{
-  /* this aint' a real gauss function */
-  if (f < -0.5)
-    {
-      f = -1.0 - f;
-      return (2.0 * f*f);
-    }
-
-  if (f < 0.5)
-    return (1.0 - 2.0 * f*f);
-
-  f = 1.0 - f;
-  return (2.0 * f*f);
-}
-
-struct GimpVector2
-{
-  double x, y;
-};
-
-struct GimpBrushGenerated
-{
-  GrayscaleBuffer *mask;     /*  the actual mask                */
-
-  GimpVector2   x_axis;     /*  for calculating brush spacing  */
-  GimpVector2   y_axis;     /*  for calculating brush spacing  */
-
-  BrushShape shape;
-  float                  radius;
-  gint                    spikes;       /* 2 - 20     */
-  float                  hardness;     /* 0.0 - 1.0  */
-  float                  aspect_ratio; /* y/x        */
-  float                  angle;        /* in degrees */
-};
-
-
-static void
-gimp_brush_generated_dirty (GimpBrushGenerated *brush)
-{
-  gint                x, y;
-  guchar             *centerp;
-  double             d;
-  double             exponent;
-  guchar              a;
-  gint                length;
-  gint                width  = 0;
-  gint                height = 0;
-  guchar             *lookup;
-  double             sum;
-  double             c, s, cs, ss;
-  double             short_radius;
-  double             buffer[OVERSAMPLING];
-
-  s = sin (gimp_deg_to_rad (brush->angle));
-  c = cos (gimp_deg_to_rad (brush->angle));
-
-  short_radius = brush->radius / brush->aspect_ratio;
-
-  brush->x_axis.x =        c * brush->radius;
-  brush->x_axis.y = -1.0 * s * brush->radius;
-  brush->y_axis.x =        s * short_radius;
-  brush->y_axis.y =        c * short_radius;
-
-  switch (brush->shape)
-    {
-    case BRUSH_SHAPE_CIRCLE:
-      width  = static_cast<int>(ceil (sqrt (brush->x_axis.x * brush->x_axis.x +
-                                            brush->y_axis.x * brush->y_axis.x)));
-      height = static_cast<int>(ceil (sqrt (brush->x_axis.y * brush->x_axis.y +
-                                            brush->y_axis.y * brush->y_axis.y)));
-      break;
-
-    case BRUSH_SHAPE_SQUARE:
-      width  = static_cast<int>(ceil (fabs (brush->x_axis.x) + fabs (brush->y_axis.x)));
-      height = static_cast<int>(ceil (fabs (brush->x_axis.y) + fabs (brush->y_axis.y)));
-      break;
-
-    case BRUSH_SHAPE_DIAMOND:
-      width  = static_cast<int>(ceil (std::max(fabs (brush->x_axis.x), fabs (brush->y_axis.x))));
-      height = static_cast<int>(ceil (std::max(fabs (brush->x_axis.y), fabs (brush->y_axis.y))));
-      break;
-
-    default:
-      return;
-    }
-
-  if (brush->spikes > 2)
-    {
-      /* could be optimized by respecting the angle */
-      width = height = static_cast<int>(ceil (sqrt (brush->radius * brush->radius +
-                                                    short_radius * short_radius)));
-      brush->y_axis.x =        s * brush->radius;
-      brush->y_axis.y =        c * brush->radius;
-    }
-
-  brush->mask = new GrayscaleBuffer(width  * 2 + 1,
-                                    height * 2 + 1,
-                                    0);
-
-  centerp = brush->mask->get_data() + height * brush->mask->get_width() + width;
-
-  /* set up lookup table */
-  length = static_cast<int>(OVERSAMPLING * ceil (1 + sqrt (2 *
-                                                           ceil (brush->radius + 1.0) *
-                                                           ceil (brush->radius + 1.0))));
-
-  if ((1.0 - brush->hardness) < 0.0000004)
-    exponent = 1000000.0;
-  else
-    exponent = 0.4 / (1.0 - brush->hardness);
-
-  lookup = new guchar[length];
-  sum = 0.0;
-
-  for (x = 0; x < OVERSAMPLING; x++)
-    {
-      d = fabs ((x + 0.5) / OVERSAMPLING - 0.5);
-
-      if (d > brush->radius)
-        buffer[x] = 0.0;
-      else
-        buffer[x] = gauss (pow (d / brush->radius, exponent));
-
-      sum += buffer[x];
-    }
-
-  for (x = 0; d < brush->radius || sum > 0.00001; d += 1.0 / OVERSAMPLING)
-    {
-      sum -= buffer[x % OVERSAMPLING];
-
-      if (d > brush->radius)
-        buffer[x % OVERSAMPLING] = 0.0;
-      else
-        buffer[x % OVERSAMPLING] = gauss (pow (d / brush->radius, exponent));
-
-      sum += buffer[x % OVERSAMPLING];
-      lookup[x++] = static_cast<int>(rint(sum * (255.0 / OVERSAMPLING)));
-    }
-
-  while (x < length)
-    {
-      lookup[x++] = 0;
-    }
-
-  cs = cos (- 2 * M_PI / brush->spikes);
-  ss = sin (- 2 * M_PI / brush->spikes);
-
-  /* for an even number of spikes compute one half and mirror it */
-  for (y = (brush->spikes % 2 ? -height : 0); y <= height; y++)
-    {
-      for (x = -width; x <= width; x++)
-        {
-          double tx, ty, angle;
-
-          tx = c*x - s*y;
-          ty = fabs (s*x + c*y);
-
-          if (brush->spikes > 2)
-            {
-              angle = atan2 (ty, tx);
-
-              while (angle > M_PI / brush->spikes)
-                {
-                  double sx = tx, sy = ty;
-
-                  tx = cs * sx - ss * sy;
-                  ty = ss * sx + cs * sy;
-
-                  angle -= 2 * M_PI / brush->spikes;
-                }
-            }
-
-          ty *= brush->aspect_ratio;
-          switch (brush->shape)
-            {
-            case BRUSH_SHAPE_CIRCLE:
-              d = sqrt (tx*tx + ty*ty);
-              break;
-            case BRUSH_SHAPE_SQUARE:
-              d = std::max (fabs (tx), fabs (ty));
-              break;
-            case BRUSH_SHAPE_DIAMOND:
-              d = fabs (tx) + fabs (ty);
-              break;
-            }
-
-          if (d < brush->radius + 1)
-            a = lookup[(gint) rint (d * OVERSAMPLING)];
-          else
-            a = 0;
-
-          centerp[ y * brush->mask->get_width() + x] = a;
-
-          if (brush->spikes % 2 == 0)
-            centerp[-1 * y * brush->mask->get_width() - x] = a;
-        }
-    }
-
-  delete lookup;
-}
-
-GrayscaleBuffer* generate_brushmask(BrushShape shape,
-                                    float  radius,
-                                    int    spikes,        /* 2 - 20     */
-                                    float  hardness,      /* 0.0 - 1.0  */
-                                    float  aspect_ratio,  /* y/x        */
-                                    float  angle)         /* in degrees */
-{
-  GimpBrushGenerated brush;
-  
-  brush.mask         = 0;
-  brush.shape        = shape;
-  brush.radius       = radius;
-  brush.spikes       = spikes;
-  brush.hardness     = hardness;
-  brush.aspect_ratio = aspect_ratio;
-  brush.angle        = angle;
-
-  gimp_brush_generated_dirty(&brush);
-
-  return brush.mask;
-}
-
-#ifdef TEST
-int main()
-{
-  GimpBrushGenerated brush;
-  
-  brush.mask         = 0;
-  brush.shape        = BRUSH_SHAPE_DIAMOND;
-  brush.radius       = 512;
-  brush.spikes       = 19;
-  brush.hardness     = 0.9;
-  brush.aspect_ratio = 1;
-  brush.angle        = 0;
-
-  gimp_brush_generated_dirty(&brush);
-
-  std::cout << "P2\n";
-  std::cout << "# Gimp Brush Generator\n";
-  std::cout << brush.mask->width << " " << brush.mask->height << "\n";
-  std::cout << "255\n";
-
-  for (int i = 0; i < brush.mask->width * brush.mask->height; ++i)
-    std::cout << int(brush.mask->data[i]) << " ";
-
-  //temp_buf_free(brush.mask);
-  
-  std::cout << std::endl;
-
-  return 0;
-}
-#endif
-
-/* EOF */

Deleted: trunk/netbrush/brushmask.hpp
===================================================================
--- trunk/netbrush/brushmask.hpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/brushmask.hpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,45 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#ifndef HEADER_BRUSHMASK_HPP
-#define HEADER_BRUSHMASK_HPP
-
-#include "grayscale_buffer.hpp"
-
-enum BrushShape {
-  BRUSH_SHAPE_CIRCLE,
-  BRUSH_SHAPE_SQUARE,
-  BRUSH_SHAPE_DIAMOND
-};
-
-GrayscaleBuffer* generate_brushmask(BrushShape shape,
-                                    float  radius,
-                                    int    spikes,        /* 2 - 20     */
-                                    float  hardness,      /* 0.0 - 1.0  */
-                                    float  aspect_ratio,  /* y/x (1.0f - 20.0f)       */
-                                    float  angle);        /* in degrees */
-#endif
-
-/* EOF */

Deleted: trunk/netbrush/client.cpp
===================================================================
--- trunk/netbrush/client.cpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/client.cpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,363 +0,0 @@
-#include <iostream>
-#include <sstream>
-#include <map>
-#include "math/rect.hpp"
-#include "stroke.hpp"
-#include "SDL.h"
-#include "SDL_main.h"
-#include "SDL_image.h"
-#include "SDL_net.h"
-#include "drawing_context.hpp"
-#include "drawing_parameter.hpp"
-#include "debug.hpp"
-#include "video.hpp"
-#include "client_state.hpp"
-#include "globals.hpp"
-#include "screen_buffer.hpp"
-#include "stroke_buffer.hpp"
-#include "widget/widget_manager.hpp"
-#include "widget/scrollbar.hpp"
-#include "widget/button.hpp"
-#include "saturation_value_picker.hpp"
-#include "hue_picker.hpp"
-#include "alpha_picker.hpp"
-#include "brush_widget.hpp"
-#include "navigation.hpp"
-#include "server_connection.hpp"
-#include "widget/slider_widget.hpp"
-
-SDL_Rect* make_rect(int x, int y, int w, int h)
-{
-  static SDL_Rect rect;
-  rect.x = x;
-  rect.y = y;
-  rect.w = w;
-  rect.h = h;
-  return &rect;
-}
-
-void process_events()
-{
-  SDL_Event event;
-  
-  while(SDL_PollEvent(&event))
-    {
-      switch(event.type)
-        {
-        case SDL_QUIT:
-          puts("# quit");
-          exit(0);
-          break;
-
-        case SDL_KEYDOWN:
-          if (event.key.keysym.sym == SDLK_1)
-            {
-              client_draw_param->set_brush("brush_2x2.png");
-            }
-          else if (event.key.keysym.sym == SDLK_2)
-            {
-              client_draw_param->set_brush("brush_white_2x2.png");
-            }
-          else if (event.key.keysym.sym == SDLK_3)
-            {
-              client_draw_param->set_brush("brush_3x3.png");
-            }
-          else if (event.key.keysym.sym == SDLK_4)
-            {
-              client_draw_param->set_brush("brush_white_3x3.png");
-            }
-          else if (event.key.keysym.sym == SDLK_5)
-            {
-              client_draw_param->set_brush("brush_14x14.png");
-            }
-          else if (event.key.keysym.sym == SDLK_6)
-            {
-              client_draw_param->set_brush("brush_white_14x14.png");
-            }
-          else if (event.key.keysym.sym == SDLK_k)
-            {
-              std::cout << "Forced screen clear and update" << std::endl;
-              SDL_FillRect(screen, NULL, SDL_MapRGB(screen->format, 255, 0, 255));
-              SDL_UpdateRect(screen, 0, 0, 0, 0);
-            }
-          else if (event.key.keysym.sym == SDLK_j)
-            {
-              std::cout << "Forced screen update" << std::endl;
-              SDL_UpdateRect(screen, 0, 0, 0, 0);
-            }
-          else if (event.key.keysym.sym == SDLK_c)
-            {
-              server->send("clear\n");
-            }
-          else if (event.key.keysym.sym == SDLK_INSERT)
-            {
-              client_draw_param->color.r = std::min(255, client_draw_param->color.r + 32);
-            }
-          else if (event.key.keysym.sym == SDLK_DELETE)
-            {
-              client_draw_param->color.r = std::max(0, client_draw_param->color.r - 32);
-            }
-          else if (event.key.keysym.sym == SDLK_HOME)
-            {
-              client_draw_param->color.g = std::min(255, client_draw_param->color.g + 32);
-            }
-          else if (event.key.keysym.sym == SDLK_END)
-            {
-              client_draw_param->color.g = std::max(0, client_draw_param->color.g - 32);
-            }
-          else if (event.key.keysym.sym == SDLK_PAGEUP)
-            {
-              client_draw_param->color.b = std::min(255, client_draw_param->color.b + 32);
-            }
-          else if (event.key.keysym.sym == SDLK_PAGEDOWN)
-            {
-              client_draw_param->color.b = std::max(0, client_draw_param->color.b - 32);
-            }
-          else if (event.key.keysym.sym == SDLK_UP)
-            {
-              client_draw_param->opacity = std::max(0, client_draw_param->opacity - 16);
-            }
-          else if (event.key.keysym.sym == SDLK_DOWN)
-            {
-              client_draw_param->opacity = std::min(255, client_draw_param->opacity + 16);
-            }
-          else if (event.key.keysym.sym == SDLK_u)
-            {
-              navigation->update();
-            }
-          break;
-
-        case SDL_MOUSEBUTTONDOWN:
-          widget_manager->on_mouse_button(event.button);
-          break;
-
-        case SDL_MOUSEBUTTONUP:
-          widget_manager->on_mouse_button(event.button);
-          break;
-
-        case SDL_MOUSEMOTION:
-          widget_manager->on_mouse_motion(event.motion);
-          break;
-        }
-    }  
-}
-
-class RadiusCallback : public SliderCallback
-{
-public:
-  void operator()(float v) 
-  {
-    float radius = v * 100.0f + 0.1f;
-    client_draw_param->generic_brush.radius = radius;
-    //std::cout << "Radius: " << radius << std::endl;
-    brush_widget->set_brush(client_draw_param->generic_brush);
-  }
-};
-
-class SpikeCallback : public SliderCallback
-{
-public:
-  void operator()(float v) 
-  {
-    int spikes = int(v*18) + 2;
-    //std::cout << "Spike: " << spikes << std::endl;
-    client_draw_param->generic_brush.spikes = spikes;    
-    brush_widget->set_brush(client_draw_param->generic_brush);
-  }
-};
-
-class HardnessCallback : public SliderCallback
-{
-public:
-  void operator()(float v) 
-  {
-    float hardness = v;
-    client_draw_param->generic_brush.hardness = hardness;
-    //std::cout << "Hardness: " << hardness << std::endl;
-    brush_widget->set_brush(client_draw_param->generic_brush);
-  }
-};
-
-class AspectRatioCallback : public SliderCallback
-{
-public:
-  void operator()(float v) 
-  {
-    float aspect_ratio = v*19.0f + 1.0f;
-    client_draw_param->generic_brush.aspect_ratio = aspect_ratio;
-    //std::cout << "Aspect_Ratio: " << aspect_ratio << std::endl;
-    brush_widget->set_brush(client_draw_param->generic_brush);
-  }
-};
-
-class AngleCallback : public SliderCallback
-{
-public:
-  void operator()(float v) 
-  {
-    float angle = v * 360.0f;
-    client_draw_param->generic_brush.angle = angle;
-    //std::cout << "Angle: " << angle << std::endl;
-    brush_widget->set_brush(client_draw_param->generic_brush);
-  }
-};
-
-class ToolButtonCallback : public ButtonCallback
-{
-private:
-  DrawingParameter::Tool tool;
-public:
-  ToolButtonCallback(DrawingParameter::Tool tool_)
-    : tool(tool_)
-  {
-  }
-
-  void on_press  (Button* button) 
-  {
-    std::cout << "Press: " << button << std::endl;
-  }
-
-  void on_release(Button* button) 
-  {
-    std::cout << "Release: " << button << std::endl;
-  }
-  
-  void on_click  (Button* button) 
-  {
-    std::cout << "Setting tool: " << tool << std::endl;
-    client_draw_param->tool = tool;
-  }
-};
-
-int main(int argc, char** argv)
-{
-  if(SDL_Init(SDL_INIT_VIDEO)== -1) {
-    printf("SDL_Init: %s\n", SDL_GetError());
-    exit(1);
-  }
-  atexit(SDL_Quit);
-
-  if(SDLNet_Init()==-1) {
-    printf("SDLNet_Init: %s\n", SDLNet_GetError());
-    exit(2);
-  }
-  atexit(SDLNet_Quit);
-
-  screen = SDL_SetVideoMode(1024, 768, 32, SDL_HWSURFACE); 
-  if (screen == 0)
-    printf("SDL_SetVideoMode: %s\n", SDL_GetError());
-  SDL_WM_SetCaption("netBrush", "netBrush");
-
-  // 18 is scrollbar
-  screen_buffer = new ScreenBuffer(Rect(38, 2, screen->w - 128 - 16 - 18, screen->h - 16 - 4)); 
-  draw_ctx      = new DrawingContext(2048, 2048);
-  stroke_buffer = new StrokeBuffer(2048, 2048);
-
-  std::cout << "# clear screen" << std::endl;
-
-  // clear screen
-  draw_ctx->clear();
-
-  std::cout << "# clear screen done" << std::endl;
-
-  client_draw_param = new DrawingParameter();
-  stroke_buffer->set_param(client_draw_param);
-  
-  server = new ServerConnection();
-  if (argc == 3)
-    {
-      std::cout << "# connecting to: " << argv[1] << ":" << atoi(argv[2]) << std::endl;
-      server->connect(argv[1], atoi(argv[2]));
-      std::ostringstream title_line;
-      title_line << "netBrush - online: " << argv[1] << ":" << atoi(argv[2]);
-      SDL_WM_SetCaption(title_line.str().c_str(), "netBrush");
-    }
-  else
-    {
-      std::cout << "# use '" << argv[0] << " HOSTNAME PORT' to connect a networking session" << std::endl;
-      SDL_WM_SetCaption("netBrush - offline mode", "netBrush");
-    }
-  
-  widget_manager = new WidgetManager();
-  widget_manager->add(navigation = new Navigation(Rect(Point(screen->w - 128 - 2, screen->h - 128 - 2),
-                                                       Size(128, 128))));
-  widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-airbrush-22.png"), 
-                                 Rect(Point(2, 2+0*34), Size(34, 34)),
-                                 new ToolButtonCallback(DrawingParameter::TOOL_AIRBRUSH)));
-  widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-paintbrush-22.png"), 
-                                 Rect(Point(2, 2+1*34), Size(34, 34)),
-                                 new ToolButtonCallback(DrawingParameter::TOOL_PAINTBRUSH)));
-  if (0)
-    widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-zoom-22.png"), 
-                                   Rect(Point(2, 2+2*34), Size(34, 34)),
-                                   new ToolButtonCallback(DrawingParameter::TOOL_PAINTBRUSH)));
-
-  {
-    SDL_Rect color_rect;
-    color_rect.x = 768;
-    color_rect.y = 100;
-
-    color_rect.w = 128;
-    color_rect.h = 128;
-
-    //widget_manager->add(new ColorSelector(&color_rect));
-  }
-
-  widget_manager->add(screen_buffer);
-
-  widget_manager->add(vertical_scrollbar = 
-                      new Scrollbar(0, 2048, screen_buffer->get_rect().get_height(), Scrollbar::VERTICAL,
-                                    Rect(screen->w - 128 - 16 - 16, 2,
-                                         screen->w - 128 - 16, screen->h - 16 - 4)));
-
-  widget_manager->add(horizontal_scrollbar = 
-                      new Scrollbar(0, 2048, screen_buffer->get_rect().get_width(), Scrollbar::HORIZONTAL,
-                                    Rect(38, screen->h - 16 - 2,
-                                         screen->w - 128 - 16 - 18, screen->h - 2)));
-
-  alpha_picker = new AlphaPicker(Rect(Point(screen->w-128, 128+24), Size(128, 24)));
-  saturation_value_picker = new SaturationValuePicker(Rect(Point(screen->w-128, 0), Size(128, 128)));
-  hue_picker   = new HuePicker(Rect(Point(screen->w-128, 128), Size(128, 24)));
-
-  brush_widget = new BrushWidget(Rect(Point(screen->w-128, 128+24+24), Size(128, 128)));
-  brush_widget->set_brush(client_draw_param->generic_brush);
-
-  SliderWidget* radius_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(0)), Size(128, 24)),
-                                                 new RadiusCallback());
-  widget_manager->add(radius_slider);
-
-  SliderWidget* spike_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(1)), Size(128, 24)),
-                                                 new SpikeCallback());
-  widget_manager->add(spike_slider);
-
-  SliderWidget* hardness_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(2)), Size(128, 24)),
-                                                 new HardnessCallback());
-  widget_manager->add(hardness_slider);
-
-  SliderWidget* aspect_ratio_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(3)), Size(128, 24)),
-                                                 new AspectRatioCallback());
-  widget_manager->add(aspect_ratio_slider);
-
-  SliderWidget* angle_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(4)), Size(128, 24)),
-                                                 new AngleCallback());
-  widget_manager->add(angle_slider);
-
-  widget_manager->add(saturation_value_picker);
-  widget_manager->add(hue_picker);
-  widget_manager->add(alpha_picker);
-  widget_manager->add(brush_widget);
-
-  // Main Loop
-  while(true)
-    {
-      process_events();
-      server->update();
-      widget_manager->update();
-      SDL_Delay(10);
-    }
-  
-  return 0;
-}
-
-/* EOF */
-

Deleted: trunk/netbrush/client_state.cpp
===================================================================
--- trunk/netbrush/client_state.cpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/client_state.cpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,122 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#include <iostream>
-#include "drawing_parameter.hpp"
-#include "drawing_context.hpp"
-#include "stroke.hpp"
-#include "globals.hpp"
-#include "client_state.hpp"
-
-ClientState::ClientState(int id_)
-  :id(id_), current_stroke(0), draw_param(0)
-{    
-  draw_param = new DrawingParameter();
-}
-
-ClientState::~ClientState()
-{
-  delete draw_param;
-  delete current_stroke; 
-}
-
-void
-ClientState::set_tool(DrawingParameter::Tool tool)
-{
-  draw_param->tool = tool;
-}
-
-void
-ClientState::set_color(const Color& color)
-{
-  draw_param->color = color;
-}
-
-void
-ClientState::set_opacity(Uint8 o)
-{
-  draw_param->opacity = o;
-}
-
-void
-ClientState::set_brush(const std::string& filename) 
-{
-  draw_param->set_brush(filename);
-}
-
-void
-ClientState::set_generic_brush(BrushShape shape,
-                               float  radius,
-                               int    spikes,        /* 2 - 20     */
-                               float  hardness,      /* 0.0 - 1.0  */
-                               float  aspect_ratio,  /* y/x (1.0f - 20.0f)       */
-                               float  angle)
-{
-  draw_param->generic_brush.shape        = shape;
-  draw_param->generic_brush.radius       = radius;
-  draw_param->generic_brush.spikes       = spikes;
-  draw_param->generic_brush.hardness     = hardness;
-  draw_param->generic_brush.aspect_ratio = aspect_ratio;
-  draw_param->generic_brush.angle        = angle;
-  
-  draw_param->brush_file = "";
-  delete draw_param->brush_buffer;
-  draw_param->brush_buffer = draw_param->generic_brush.generate();
-}
-
-void
-ClientState::stroke_begin() {
-  //std::cout << "CL" << id << " stroke_begin" << std::endl;
-  current_stroke = new Stroke();
-}
-
-void
-ClientState::stroke_end() {
-  //std::cout << "CL" << id << " stroke_end" << std::endl;
-  if (current_stroke)
-    {
-      //std::cout << "# drawing stroke" << std::endl;
-      draw_ctx->draw_stroke(*current_stroke, draw_param);
-
-      delete current_stroke;
-      current_stroke = 0;
-    }
-  else
-    {
-      std::cout << "# got stroke_end before stroke_begin" << std::endl;
-    }
-}
-
-void
-ClientState::dab(unsigned int time, int x, int y) 
-{
-  //std::cout << "CL" << id << " dab " << time << " " << x << " " << y << std::endl;
-  if (current_stroke)
-    {
-      current_stroke->add_dab(Dab(x, y));
-    }
-}
-
-/* EOF */

Deleted: trunk/netbrush/client_state.hpp
===================================================================
--- trunk/netbrush/client_state.hpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/client_state.hpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,66 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#ifndef HEADER_CLIENT_STATE_HPP
-#define HEADER_CLIENT_STATE_HPP
-
-#include <string>
-#include "brushmask.hpp"
-#include "drawing_parameter.hpp"
-
-class Color;
-class Stroke;
-class DrawingParameter;
-
-class ClientState
-{
-private:
-  int id;
-  Stroke* current_stroke;
-  DrawingParameter* draw_param;
-
-public:
-  ClientState(int id_);
-  ~ClientState();
-
-  void set_tool(DrawingParameter::Tool tool);
-  void set_opacity(Uint8 o);
-  void set_color(const Color& color);
-  void set_generic_brush(BrushShape shape,
-                         float  radius,
-                         int    spikes,        /* 2 - 20     */
-                         float  hardness,      /* 0.0 - 1.0  */
-                         float  aspect_ratio,  /* y/x (1.0f - 20.0f)       */
-                         float  angle);
-  void set_brush(const std::string& filename);
-  void stroke_begin();
-  void stroke_end();
-
-  void dab(unsigned int time, int x, int y);
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/netbrush/color.hpp
===================================================================
--- trunk/netbrush/color.hpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/color.hpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,48 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#ifndef HEADER_COLOR_HPP
-#define HEADER_COLOR_HPP
-
-#include "SDL.h"
-
-struct Color
-{
-  Color()
-    : r(0), g(0), b(0)
-  {}
-
-  Color(Uint8 r_, Uint8 g_, Uint8 b_)
-    : r(r_), g(g_), b(b_)
-  {}
-
-  Uint8 r;
-  Uint8 g;
-  Uint8 b;
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/netbrush/debug.cpp
===================================================================
--- trunk/netbrush/debug.cpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/debug.cpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,39 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#include <iostream>
-#include "debug.hpp"
-
-void client_error(const std::string& msg)
-{
-  std::cout << "# ERROR: " << msg << std::endl;
-}
-
-void client_notice(const std::string& msg)
-{
-  std::cout << "# notice: " << msg << std::endl;
-}
-
-/* EOF */

Deleted: trunk/netbrush/debug.hpp
===================================================================
--- trunk/netbrush/debug.hpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/debug.hpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,36 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#ifndef HEADER_DEBUG_HPP
-#define HEADER_DEBUG_HPP
-
-#include <string>
-
-void client_error(const std::string& msg);
-void client_notice(const std::string& msg);
-
-#endif
-
-/* EOF */

Deleted: trunk/netbrush/drawing_context.cpp
===================================================================
--- trunk/netbrush/drawing_context.cpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/drawing_context.cpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,162 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#include <iostream>
-#include "globals.hpp"
-#include "screen_buffer.hpp"
-#include "drawing_parameter.hpp"
-#include "video.hpp"
-#include "grayscale_buffer.hpp"
-#include "stroke_buffer.hpp"
-#include "navigation.hpp"
-#include "drawing_context.hpp"
-
-DrawingContext::DrawingContext(int w, int h) 
-{
-  Uint32 rmask, gmask, bmask, amask;
-
-  /* SDL interprets each pixel as a 32-bit number, so our masks must depend
-     on the endianness (byte order) of the machine */
-#if SDL_BYTEORDER == SDL_BIG_ENDIAN
-  rmask = 0xff000000;
-  gmask = 0x00ff0000;
-  bmask = 0x0000ff00;
-  amask = 0; //0x000000ff;
-#else
-  rmask = 0x000000ff;
-  gmask = 0x0000ff00;
-  bmask = 0x00ff0000;
-  amask = 0; //0xff000000;
-#endif
-
-  drawable = SDL_CreateRGBSurface(SDL_SWSURFACE, w, h, 24,
-                                  rmask, gmask, bmask, amask);
-  if(drawable == NULL) {
-    fprintf(stderr, "CreateRGBSurface failed: %s\n", SDL_GetError());
-    exit(1);
-  }
-
-  stroke_buffer = new StrokeBuffer(w, h);
-}
-
-DrawingContext::~DrawingContext() 
-{
-  SDL_FreeSurface(drawable);
-}
-
-void
-DrawingContext::draw_stroke(const Stroke& stroke, DrawingParameter* param)
-{
-  Rect rect = stroke.get_bounding_rect();
-
-  rect.left -= param->thickness()/2;
-  rect.top  -= param->thickness()/2;
-  
-  rect.right  += param->thickness()/2;
-  rect.bottom += param->thickness()/2;
-
-  clip_to(rect, Rect(0, 0, get_width(), get_height()));
-
-  stroke_buffer->clear(rect);
-  stroke_buffer->set_param(param);
-  stroke_buffer->draw_stroke(stroke, param);
-  stroke_buffer->draw(drawable, rect, 0, 0);
-
-  screen_buffer->mark_dirty(rect);
-
-  // FIXME: Limit this to what changed on the buffer instead of whole screen
-  navigation->update();
-}
-
-void
-DrawingContext::clear()
-{
-  SDL_Rect rect;
-  
-  rect.x = 0;
-  rect.y = 0;
-  rect.w = drawable->w;
-  rect.h = drawable->h;
-
-  SDL_FillRect(drawable, &rect, SDL_MapRGB(drawable->format, 255, 255, 255));
-
-  screen_buffer->mark_dirty(Rect(Point(0,0), Size(rect.w, rect.h)));
-}
-
-void
-DrawingContext::draw(SDL_Surface* target_surf, const Rect& rect, int x_of, int y_of)
-{
-  // rect is in screenspace, x_of, y_of tell how to go from canvas to screenspace
-
-  if (1) // no zoom
-    {
-      SDL_Rect target_pos;
-      target_pos.x = rect.left;
-      target_pos.y = rect.top;
-      target_pos.w = rect.get_width();
-      target_pos.h = rect.get_height();
-
-      SDL_Rect source_pos;
-      source_pos.x = rect.left - x_of;
-      source_pos.y = rect.top  - y_of;
-      source_pos.w = rect.get_width();
-      source_pos.h = rect.get_height();
-
-      SDL_Rect r;
-      r.x = 0;
-      r.y = 0;
-      r.w = drawable->w;
-      r.h = drawable->h;
-
-      clip_to(&source_pos, &r);
-      SDL_BlitSurface(drawable, &source_pos, target_surf, &target_pos);
-    }
-  else
-    {
-      SDL_LockSurface(target_surf);
-      SDL_LockSurface(drawable);
-
-      Uint8* target = static_cast<Uint8*>(target_surf->pixels);
-      Uint8* source = static_cast<Uint8*>(drawable->pixels);
-
-      // FIXME: do clipping or do clipping at a higher level in the code
-      float zoom = 2.0f;
-      for(int y = rect.top; y < rect.bottom; ++y)
-        for(int x = rect.left; x < rect.right; ++x)
-          {
-            int sx = int(x * zoom);
-            int sy = int(y * zoom);
-
-            target[y * target_surf->pitch + target_surf->format->BytesPerPixel * x + 2] = source[sy * drawable->pitch + drawable->format->BytesPerPixel * sx + 0];
-            target[y * target_surf->pitch + target_surf->format->BytesPerPixel * x + 1] = source[sy * drawable->pitch + drawable->format->BytesPerPixel * sx + 1];
-            target[y * target_surf->pitch + target_surf->format->BytesPerPixel * x + 0] = source[sy * drawable->pitch + drawable->format->BytesPerPixel * sx + 2];
-          }
-
-      SDL_UnlockSurface(drawable);
-      SDL_UnlockSurface(target_surf);
-    }
-}
-
-/* EOF */

Deleted: trunk/netbrush/drawing_context.hpp
===================================================================
--- trunk/netbrush/drawing_context.hpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/drawing_context.hpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,61 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#ifndef HEADER_DRAWING_CONTEXT_HPP
-#define HEADER_DRAWING_CONTEXT_HPP
-
-#include "SDL.h"
-#include "math/rect.hpp"
-#include "stroke.hpp"
-
-class GrayscaleBuffer;
-class DrawingParameter;
-class StrokeBuffer;
-
-class DrawingContext
-{
-private:
-  SDL_Surface*     drawable;
-  StrokeBuffer*    stroke_buffer;
- 
-public:
-  DrawingContext(int w, int h);
-  ~DrawingContext();
-
-  void draw_stroke(const Stroke& stroke, DrawingParameter* param); 
-
-  void clear();
-
-  void draw(SDL_Surface* target, const Rect& region, int x_of, int y_of);
-
-  int get_width()  const { return drawable->w; }
-  int get_height() const { return drawable->h; }
-
-  SDL_Surface* get_surface() { return drawable; }
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/netbrush/drawing_parameter.cpp
===================================================================
--- trunk/netbrush/drawing_parameter.cpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/drawing_parameter.cpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,91 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#include "grayscale_buffer.hpp"
-#include "drawing_parameter.hpp"
-
-DrawingParameter::DrawingParameter()
-  : tool(TOOL_PAINTBRUSH),
-    brush_surface(0), 
-    brush_buffer(0), 
-    color(0, 0, 0), 
-    opacity(128),
-    spacing(1.0f)
-{
-  set_brush("brush_3x3.png");
-}
-
-void
-DrawingParameter::set_brush(const std::string& filename)
-{
-  SDL_Surface* new_brush = IMG_Load(filename.c_str());
-  if (new_brush)
-    {
-      if (brush_surface)
-        SDL_FreeSurface(brush_surface);
-
-      brush_surface = new_brush;
-      brush_file    = filename;  
-
-      delete brush_buffer;
-      brush_buffer = new GrayscaleBuffer(brush_surface);
-    }
-  else
-    {
-      client_error("Couldn't load file " + filename);
-    }
-}
-
-std::string
-DrawingParameter::get_brush() const 
-{
-  return brush_file;
-}
-
-SDL_Surface*
-DrawingParameter::get_brush_surface() const 
-{ 
-  return brush_surface;
-}
-
-GrayscaleBuffer*
-DrawingParameter::get_brush_buffer() const
-{
-  return brush_buffer;
-}
-
-int
-DrawingParameter::thickness() const
-{
-  return brush_buffer->get_width();
-}
-
-float
-DrawingParameter::get_spacing()
-{
-  return brush_buffer->get_width() * spacing / 12.0f;
-}
-
-/* EOF */

Deleted: trunk/netbrush/drawing_parameter.hpp
===================================================================
--- trunk/netbrush/drawing_parameter.hpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/drawing_parameter.hpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,63 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#ifndef HEADER_DRAWING_PARAMETER_HPP
-#define HEADER_DRAWING_PARAMETER_HPP
-
-#include "SDL.h"
-#include "SDL_image.h"
-#include "debug.hpp"
-#include "color.hpp"
-#include "generic_brush.hpp"
-
-class GrayscaleBuffer;
-
-class DrawingParameter
-{
-public:
-  enum Tool { TOOL_AIRBRUSH, TOOL_PAINTBRUSH };
-  Tool             tool;
-  std::string      brush_file;
-  GenericBrush     generic_brush;
-  SDL_Surface*     brush_surface;
-  GrayscaleBuffer* brush_buffer;
-  Color            color;
-  Uint8            opacity;
-  float            spacing;
-  
-public:
-  DrawingParameter();
-
-  float get_spacing();
-  void set_brush(const std::string& filename);
-  std::string get_brush() const;
-  SDL_Surface* get_brush_surface() const;
-  GrayscaleBuffer* get_brush_buffer() const;
-  int thickness() const;
-};
-
-#endif 
-
-/* EOF */

Deleted: trunk/netbrush/generic_brush.cpp
===================================================================
--- trunk/netbrush/generic_brush.cpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/generic_brush.cpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,34 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#include "generic_brush.hpp"
-
-GrayscaleBuffer*
-GenericBrush::generate()
-{
-  return generate_brushmask(shape, radius, spikes, hardness, aspect_ratio, angle);
-}
-
-/* EOF */

Deleted: trunk/netbrush/generic_brush.hpp
===================================================================
--- trunk/netbrush/generic_brush.hpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/generic_brush.hpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,55 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#ifndef HEADER_GENERIC_BRUSH_HPP
-#define HEADER_GENERIC_BRUSH_HPP
-
-#include "brushmask.hpp"
-
-class GenericBrush
-{
-public:
-  BrushShape shape;
-  float      radius;
-  int        spikes;        /* 2 - 20     */
-  float      hardness;      /* 0.0 - 1.0  */
-  float      aspect_ratio;  /* y/x (1.0f - 20.0f) */
-  float      angle;         /* in degrees */
-  
-  GenericBrush()
-    : shape(BRUSH_SHAPE_CIRCLE),
-      radius(10),
-      spikes(2),
-      hardness(0.5),
-      aspect_ratio(1.0f),
-      angle(0.0f)
-  {}
-
-  GrayscaleBuffer* generate();
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/netbrush/globals.cpp
===================================================================
--- trunk/netbrush/globals.cpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/globals.cpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,48 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#include "globals.hpp"
-
-DrawingContext*   draw_ctx          = 0;
-DrawingParameter* client_draw_param = 0;
-ScreenBuffer*     screen_buffer     = 0;
-StrokeBuffer*     stroke_buffer     = 0;
-WidgetManager*    widget_manager    = 0;
-
-std::map<int, ClientState*> client_states;
-
-SaturationValuePicker* saturation_value_picker =0;
-HuePicker*   hue_picker =0;
-AlphaPicker*      alpha_picker = 0;
-BrushWidget*      brush_widget = 0;
-Stroke*           current_stroke = 0;
-ServerConnection* server = 0;
-
-Scrollbar* horizontal_scrollbar = 0;
-Scrollbar* vertical_scrollbar   = 0;
-
-Navigation* navigation = 0;
-
-/* EOF */

Deleted: trunk/netbrush/globals.hpp
===================================================================
--- trunk/netbrush/globals.hpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/globals.hpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,72 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#ifndef HEADER_GLOBALS_HPP
-#define HEADER_GLOBALS_HPP
-
-#include "SDL_net.h"
-
-#include <map>
-#include <vector>
-#include <string>
-
-class StrokeBuffer;
-class ScreenBuffer;
-class Stroke;
-class ClientState;
-class DrawingContext;
-class DrawingParameter;
-class WidgetManager;
-class SaturationValuePicker;
-class HuePicker;
-class AlphaPicker;
-class BrushWidget;
-class ServerConnection;
-class Scrollbar;
-class Navigation;
-
-extern SDLNet_SocketSet socketset;
-
-extern Scrollbar* horizontal_scrollbar;
-extern Scrollbar* vertical_scrollbar;
-extern BrushWidget* brush_widget;
-extern DrawingContext*   draw_ctx;
-extern DrawingParameter* client_draw_param;
-extern std::map<int, ClientState*> client_states;
-extern ScreenBuffer*     screen_buffer;
-extern StrokeBuffer*     stroke_buffer;
-extern WidgetManager* widget_manager;
-
-extern SaturationValuePicker* saturation_value_picker;
-extern HuePicker*   hue_picker;
-extern AlphaPicker* alpha_picker;
-extern ServerConnection* server;
-extern Stroke* current_stroke;
-
-extern Navigation* navigation;
-
-#endif
-
-/* EOF */

Deleted: trunk/netbrush/graphic_context_state.cpp
===================================================================
--- trunk/netbrush/graphic_context_state.cpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/graphic_context_state.cpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,201 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#include <math.h>
-#include "graphic_context_state.hpp"
-
-class GraphicContextStateImpl
-{
-public:
-  int width;
-  int height;
-  
-  Vector offset;
-  float zoom;
-  float rotation;
-};
-
-GraphicContextState::GraphicContextState()
-  : impl(new GraphicContextStateImpl())
-{
-  impl->width  = 1;
-  impl->height = 1; 
-  impl->offset = Vector(0,0);
-  impl->zoom   = 1.0f;
-  impl->rotation = 0;
-}
-
-GraphicContextState::GraphicContextState(int w, int h)
-  : impl(new GraphicContextStateImpl())
-{  
-  impl->width  = w;
-  impl->height = h;
-  impl->offset = Vector(0,0); 
-  impl->zoom   = 1.0f;
-  impl->rotation = 0;
-}
-
-void
-GraphicContextState::set_size(int w, int h)
-{
-  impl->width  = w;
-  impl->height = h;
-}
-
-#if 0
-void
-GraphicContextState::push(CL_GraphicContext* gc)
-{
-  if (gc == 0)
-    gc = CL_Display::get_current_window()->get_gc();
-  
-  gc->push_modelview();
-
-  gc->add_translate(impl->width/2, impl->height/2);
-  gc->add_rotate(impl->rotation, 0, 0, 1.0);
-  gc->add_translate(-impl->width/2, -impl->height/2);
-
-  gc->add_scale(get_zoom(), get_zoom());
-  gc->add_translate(impl->offset.x, impl->offset.y);
-}
-
-void
-GraphicContextState::pop(CL_GraphicContext* gc)
-{
-  if (gc == 0)
-    gc = CL_Display::get_current_window()->get_gc();
-  
-  gc->pop_modelview();
-}
-#endif
-
-Rectf
-GraphicContextState::get_clip_rect()
-{
-  return Rectf(Vector(-impl->offset.x,
-                            -impl->offset.y),
-                  Sizef(get_width()  / impl->zoom,
-                           get_height() / impl->zoom));
-}
-
-void
-GraphicContextState::set_pos(const Vector& pos)
-{
-  impl->offset.x = -pos.x + (get_width()/2  / impl->zoom);
-  impl->offset.y = -pos.y + (get_height()/2 / impl->zoom);
-}
-
-Vector
-GraphicContextState::get_pos() const
-{
-  return Vector(-impl->offset.x + (get_width()/2  / impl->zoom),
-                   -impl->offset.y + (get_height()/2  / impl->zoom));
-}
-
-void
-GraphicContextState::set_zoom(Vector pos, float z)
-{
-  float old_zoom = impl->zoom;
-  set_zoom(z);
-  impl->offset.x = pos.x/impl->zoom - pos.x/old_zoom + impl->offset.x;
-  impl->offset.y = pos.y/impl->zoom - pos.y/old_zoom + impl->offset.y;
-}
-
-void
-GraphicContextState::set_zoom(float z)
-{
-  impl->zoom = z;
-}
-
-float
-GraphicContextState::get_zoom()
-{
-  return impl->zoom;
-}
-
-void
-GraphicContextState::zoom_to (const Rectf& rect)
-{
-  float center_x = (rect.left + rect.right) / 2.0f;
-  float center_y = (rect.top + rect.bottom) / 2.0f;
-
-  float width  = rect.right - rect.left;
-  float height = rect.bottom - rect.top;
-  float screen_relation = float(get_height())/float(get_width ());
-  float rect_relation   = height/width; 
-  
-  //std::cout << "Screen: " << screen_relation << " Zoom: " << rect_relation << std::endl;
-  if (rect_relation < screen_relation) // take width, ignore height
-    {
-      impl->zoom = get_width()/width; 
-    }
-  else // take height, ignore width
-    {
-      impl->zoom = get_height()/height;
-    }
-
-  impl->offset.x = (get_width()  / (2*impl->zoom)) - center_x;
-  impl->offset.y = (get_height() / (2*impl->zoom)) - center_y;
-}
-
-Vector
-GraphicContextState::screen2world(const Point& pos_)
-{
-  Vector pos(pos_.x, pos_.y);
-
-  float sa = sin(-impl->rotation/180.0f*M_PI);
-  float ca = cos(-impl->rotation/180.0f*M_PI);
-
-  float dx = pos.x - impl->width/2;
-  float dy = pos.y - impl->height/2;
-
-  pos.x = impl->width/2  + (ca * dx - sa * dy);
-  pos.y = impl->height/2 + (sa * dx + ca * dy);
-
-  Vector p((float(pos.x) / impl->zoom) - impl->offset.x, 
-              (float(pos.y) / impl->zoom) - impl->offset.y);
-
-  return p;
-}
-
-void
-GraphicContextState::set_rotation(float angle)
-{
-  impl->rotation = angle;
-}
-
-float
-GraphicContextState::get_rotation()
-{
-  return impl->rotation;
-}
-
-int
-GraphicContextState::get_width()  const 
-{
-  return impl->width; 
-}
-
-int
-GraphicContextState::get_height() const 
-{ 
-  return impl->height; 
-}
-
-/* EOF */

Deleted: trunk/netbrush/graphic_context_state.hpp
===================================================================
--- trunk/netbrush/graphic_context_state.hpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/graphic_context_state.hpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,81 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#ifndef HEADER_GRAPHIC_CONTEXT_STATE_HXX
-#define HEADER_GRAPHIC_CONTEXT_STATE_HXX
-
-#include "math/rect.hpp"
-#include "math/point.hpp"
-
-class CL_GraphicContext;
-
-class GraphicContextStateImpl;
-
-/** Helper class for capturing the state of a GraphicContext, with
-    additional convenience functions to make handling GraphicContexts
-    easier */
-class GraphicContextState
-{
-public:
-  GraphicContextState();
-  GraphicContextState(int w, int h);
-
-  void set_size(int w, int h);
-
-  //void push(CL_GraphicContext* gc = 0);
-  //void pop (CL_GraphicContext* gc = 0);
-
-  /** Return a rectangle in world coordinates that represents the area
-      visible on the screen */
-  Rectf get_clip_rect();
-
-  int get_width()  const;
-  int get_height() const;
-
-  /** Set the current rotation angel */
-  void  set_rotation(float angle);
-
-  /** Return the current rotation angel */
-  float get_rotation();
-
-  /** Move the center of the visible area to pos */
-  void   set_pos(const Vector& pos);
-  Vector get_pos() const;
-
-  /** Set zoom to z, while ensuring that the screen position \a pos
-      (normaly the position of the mouse pointer) stays in the same
-      position even after zoomed in/out */
-  void  set_zoom(Vector pos, float z);
-  void  set_zoom(float z);
-  float get_zoom(); 
-
-  void zoom_to (const Rectf& rect);
-
-  Vector screen2world(const Point& pos);
-
-private:
-  GraphicContextStateImpl* impl;
-
-  GraphicContextState (const GraphicContextState&);
-  GraphicContextState& operator= (const GraphicContextState&);
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/netbrush/grayscale_buffer.cpp
===================================================================
--- trunk/netbrush/grayscale_buffer.cpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/grayscale_buffer.cpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,202 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#include <assert.h>
-#include <string.h>
-#include <iomanip>
-#include <iostream>
-#include <algorithm>
-#include "math/rect.hpp"
-#include "video.hpp"
-#include "grayscale_buffer.hpp"
-
-GrayscaleBuffer::GrayscaleBuffer(SDL_Surface* surface)
-  : width(surface->w), height(surface->h)
-{
-  buffer = new unsigned char[width*height];
-
-  SDL_LockSurface(surface);
-  int bpp = surface->format->BytesPerPixel;
-
-  Uint8* data = static_cast<Uint8*>(surface->pixels);
-  Uint8 r, g, b, a;
-  for(int i = 0; i < width*height; ++i)
-    {
-      //if (i % width == 0)
-      //std::cout << std::endl;
-
-      SDL_GetRGBA(*reinterpret_cast<Uint32*>(data + (i*bpp)), surface->format, &r, &g, &b, &a);
-
-      if (0)
-        std::cout << "(" << std::setw(3) << int(r) << " "
-                << std::setw(3) << int(g) << " "
-                << std::setw(3) << int(b) << " "
-                << std::setw(3) << int(a) << ")  ";
-
-      buffer[i] = (((255 - (r + g + b))/3 * a)/255);
-    }
-  //std::cout << std::endl;
-  SDL_UnlockSurface(surface);
-}
-
-GrayscaleBuffer::GrayscaleBuffer(int w, int h, Uint8 c)
-  : width(w), height(h)
-{
-  buffer = new unsigned char[w*h];
-  memset(buffer, c, w*h);
-}
-
-GrayscaleBuffer::~GrayscaleBuffer()
-{
-}
-
-void
-GrayscaleBuffer::clear(Uint8 c)
-{
-  memset(buffer, c, width*height);
-}
-  
-void
-GrayscaleBuffer::fill_rect(const Rect& rect_, Uint8 c)
-{
-  Rect rect = rect_;
-  clip_to(rect, Rect(0, 0, width, height));
-
-  // FIXME: Ugly way to clip
-  if (rect.left < rect.right && rect.top < rect.bottom)
-    for(int y = rect.top; y < rect.bottom; ++y)
-      {
-        memset(buffer + y * width + rect.left, c, rect.get_width());
-      }
-}
-
-void
-GrayscaleBuffer::blit(GrayscaleBuffer* source, SDL_Rect* srcrect, int of_x, int of_y)
-{
-  assert(!"Implement me");
-}
-
-void
-GrayscaleBuffer::blit(GrayscaleBuffer* source, int of_x, int of_y, BlendMode mode)
-{
-  int start_x = std::max(of_x, 0);
-  int start_y = std::max(of_y, 0);
-
-  int end_x = std::min(of_x + source->width,  width);
-  int end_y = std::min(of_y + source->height, height);
-
-  // insert blitter here
-
-  switch(mode)
-    { 
-    case OPAQUE:
-      for(int y = start_y; y < end_y ; ++y)
-        for(int x = start_x; x < end_x ; ++x)
-          {
-            Uint8& f = buffer[y * width + x];
-            Uint8& p = source->buffer[(y - of_y) * source->width + (x - of_x)];
-          
-            f = p;
-          }
-      break;
-  
-    case ADDITION:
-      for(int y = start_y; y < end_y ; ++y)
-        for(int x = start_x; x < end_x ; ++x)
-          {
-            Uint8& f = buffer[y * width + x];
-            Uint8& p = source->buffer[(y - of_y) * source->width + (x - of_x)];
-          
-            f = std::max(std::min(f + p, 255), 0);
-          }      
-      break;
-
-    case SUBTRACT:
-      for(int y = start_y; y < end_y ; ++y)
-        for(int x = start_x; x < end_x ; ++x)
-          {
-            Uint8& f = buffer[y * width + x];
-            Uint8& p = source->buffer[(y - of_y) * source->width + (x - of_x)];
-          
-            f = std::max(f - p, 0);
-          }      
-      break;
-
-    case ALPHA:
-      for(int y = start_y; y < end_y ; ++y)
-        for(int x = start_x; x < end_x ; ++x)
-          {
-            Uint8& f = buffer[y * width + x];
-            Uint8& p = source->buffer[(y - of_y) * source->width + (x - of_x)];
-            
-            // Works, but not exactly alpha
-            f = std::max(std::min(f + p/4, 255), 0);
-            
-            //f = (((255 - p) * f) + (p * p))/255; 
-            
-            // Speed worm: f = ((p)*p + p*f)/255;
-          }      
-      break;
-      
-    default:
-      assert(!"Unknown blend mode");
-    }
-}
-
-#ifdef __TEST__
-#include <stdio.h>
-
-void print(GrayscaleBuffer& buffer)
-{
-  for(int y = 0; y < buffer.get_height(); ++y)
-    {
-      for(int x = 0; x < buffer.get_width(); ++x)
-      {
-        printf("%3d ", int(buffer.at(x,y)));
-      }
-      putchar('\n');
-    }
-  putchar('\n');
-}
-
-int main()
-{
-  GrayscaleBuffer target(20,20, 0);
-  GrayscaleBuffer source(5,5, 99);
-
-  print(target);
-  print(source);
-  
-  target.blit(&source, -3, -3, GrayscaleBuffer::ADDITION);
-  target.blit(&source, 5, 4, GrayscaleBuffer::ADDITION);
-  target.blit(&source, 7, 5, GrayscaleBuffer::SUBTRACT);
-
-  print(target);
- 
-}
-
-#endif
-
-/* EOF */

Deleted: trunk/netbrush/grayscale_buffer.hpp
===================================================================
--- trunk/netbrush/grayscale_buffer.hpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/grayscale_buffer.hpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,68 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#ifndef HEADER_GRAYSCALE_BUFFER_HPP
-#define HEADER_GRAYSCALE_BUFFER_HPP
-
-#include <assert.h>
-#include "SDL.h"
-
-class Rect;
-
-class GrayscaleBuffer
-{
-private:
-  int    width;
-  int    height;
-  Uint8* buffer;
-
-public:
-  enum BlendMode { OPAQUE, ALPHA, ADDITION, SUBTRACT };
-
-  GrayscaleBuffer(SDL_Surface* surface);
-  GrayscaleBuffer(int w, int h, Uint8 c);
-  ~GrayscaleBuffer();
-  
-  void blit(GrayscaleBuffer* source, SDL_Rect* srcrect, int of_x, int of_y);
-  void blit(GrayscaleBuffer* source, int of_x, int of_y, BlendMode mode);
-
-  inline Uint8& at(int x, int y) 
-  { 
-    assert(x >= 0 && x < width && y >= 0 && y < height);
-    return buffer[y * width + x];
-  }
-
-  void clear(Uint8 c);
-  void fill_rect(const Rect& rect, Uint8 c);
-
-  Uint8* get_data() { return buffer; }
-
-  int get_width()  const { return width; }
-  int get_height() const { return height; }
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/netbrush/hue_picker.cpp
===================================================================
--- trunk/netbrush/hue_picker.cpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/hue_picker.cpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,130 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#include <vector>
-#include "video.hpp"
-#include "color.hpp"
-#include "globals.hpp"
-#include "widget/widget_manager.hpp"
-#include "saturation_value_picker.hpp"
-#include "globals.hpp"
-
-#include "hue_picker.hpp"
-
-HuePicker::HuePicker(const Rect& rect_)
-  : Widget(rect_), dragging(0)
-{
-  surface = create_surface(rect_.get_width(), rect_.get_height());
-  
-  SDL_LockSurface(surface);
-  Uint8* data = static_cast<Uint8*>(surface->pixels);
-
-  for(int y = 0; y < surface->h; ++y)
-    for(int x = 0; x < surface->w; ++x)
-      {
-        int hue = 255 * x / surface->w;
-        const Color& color = get_color(hue);
-        data[3*(y * surface->w + x)+0] = color.r;
-        data[3*(y * surface->w + x)+1] = color.g;
-        data[3*(y * surface->w + x)+2] = color.b;
-      }
-  SDL_UnlockSurface(surface);  
-}
-
-Color
-HuePicker::get_color(Uint8 hue)
-{
-  static Color colors[] = { Color(255,   0,   0),
-                            Color(255,   0, 255),
-                            Color(  0,   0, 255),
-                            Color(  0, 255, 255),
-                            Color(  0, 255,   0),
-                            Color(255, 255,   0),
-                            Color(255,   0,   0) };
-  
-  int seg_len = (255/6);
-  int seg  = (hue / seg_len);
-  int prog = (hue % seg_len);
-
-  return Color((((seg_len - prog) * colors[seg].r) + (prog * colors[seg+1].r))/seg_len,
-               (((seg_len - prog) * colors[seg].g) + (prog * colors[seg+1].g))/seg_len,
-               (((seg_len - prog) * colors[seg].b) + (prog * colors[seg+1].b))/seg_len);
-}
-
-void
-HuePicker::on_mouse_motion(const MouseMotionEvent& motion)
-{
-  if (dragging)
-    {
-      click_pos.x = motion.x;
-      click_pos.y = motion.y;
-      saturation_value_picker->set_color(get_color(255 * click_pos.x / get_rect().get_width()));
-      set_dirty(true);
-    }
-}
-
-void
-HuePicker::on_mouse_button(const MouseButtonEvent& button)
-{
-  if (button.button == 1)
-    {
-      if (button.state == SDL_RELEASED)
-        {
-          dragging = false;
-          widget_manager->ungrab(this);
-        }
-      else if (button.state == SDL_PRESSED)
-        {
-          dragging = true;
-
-          click_pos.x = button.x;
-          click_pos.y = button.y;
-
-          saturation_value_picker->set_color(get_color(255 * click_pos.x / get_rect().get_width()));
-
-          set_dirty(true);
-          widget_manager->grab(this);
-        }
-    }
-}
-
-void
-HuePicker::draw(SDL_Surface* target)
-{
-  SDL_Rect pos;
-  pos.x = get_rect().left;
-  pos.y = get_rect().top;
-
-  SDL_Rect vline;
-  vline.x = click_pos.x + get_rect().left;
-  vline.y = 0 + get_rect().top;
-  vline.w = 1;
-  vline.h = get_rect().get_height();
-
-  SDL_BlitSurface(surface, 0, target, &pos);
-  SDL_FillRect(target, &vline, SDL_MapRGB(target->format, 0, 0, 0));
-}
-
-/* EOF */

Deleted: trunk/netbrush/hue_picker.hpp
===================================================================
--- trunk/netbrush/hue_picker.hpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/hue_picker.hpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,61 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#ifndef HEADER_HUE_PICKER_HPP
-#define HEADER_HUE_PICKER_HPP
-
-#include "widget/widget.hpp"
-
-/** */
-class HuePicker : public Widget
-{
-private:
-  SDL_Surface* surface;
-  bool  dragging;
-  Point click_pos;
-
-public:
-  HuePicker(const Rect& rect);
-
-  Color get_color(Uint8 hue);
-
-  void on_mouse_motion(const MouseMotionEvent& motion);
-  void on_mouse_button(const MouseButtonEvent& button);
-
-  void set_hue(Uint8 hue);
-
-  void on_enter() {}
-  void on_leave() {}
-
-  void draw(SDL_Surface* target);
- 
-private:
-  HuePicker (const HuePicker&);
-  HuePicker& operator= (const HuePicker&);
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/netbrush/navigation.cpp
===================================================================
--- trunk/netbrush/navigation.cpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/navigation.cpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,105 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#include <iostream>
-#include "video.hpp"
-#include "globals.hpp"
-#include "drawing_context.hpp"
-#include "screen_buffer.hpp"
-#include "navigation.hpp"
-
-Navigation::Navigation(const Rect& rect_)
-  : Widget(rect_), dragging(false)
-{
-  surface = create_surface(rect_.get_width(), rect_.get_height());  
-}
-
-void
-Navigation::on_mouse_motion(const MouseMotionEvent& motion)
-{
-  if (dragging)
-    {
-      screen_buffer->move_to(draw_ctx->get_width()  * motion.x / get_rect().get_width(),
-                             draw_ctx->get_height() * motion.y / get_rect().get_height());
-    }
-}
-
-void
-Navigation::on_mouse_button(const MouseButtonEvent& button)
-{
-  if (button.button == 1)
-    {
-      if (button.state == SDL_RELEASED)
-        {
-          screen_buffer->move_to(draw_ctx->get_width()  * button.x / get_rect().get_width(),
-                                 draw_ctx->get_height() * button.y / get_rect().get_height());
-          dragging = false;
-        }
-      else if (button.state == SDL_PRESSED)
-        {
-          screen_buffer->move_to(draw_ctx->get_width()  * button.x / get_rect().get_width(),
-                                 draw_ctx->get_height() * button.y / get_rect().get_height());
-          dragging = true;
-        }
-    }
-}
-
-void
-Navigation::draw(SDL_Surface* target)
-{
-  SDL_Rect pos;
-  pos.x = get_rect().left;
-  pos.y = get_rect().top;
-
-  SDL_BlitSurface(surface, 0, target, &pos);  
-}
-
-void
-Navigation::update()
-{
-  //std::cout << "Navigation::update" << std::endl;
-  SDL_Surface* drawable = draw_ctx->get_surface();
-  SDL_LockSurface(drawable);
-  SDL_LockSurface(surface);
-
-  Uint8* target = static_cast<Uint8*>(surface->pixels);
-  Uint8* source = static_cast<Uint8*>(drawable->pixels);
-
-  int sx = drawable->w / surface->w;
-  int sy = drawable->h / surface->h;
-  
-  for(int y = 0; y < surface->h; ++y)
-    for(int x = 0; x < surface->pitch; ++x)
-      {
-        target[y * surface->pitch + x] = source[(y*sy) * drawable->pitch + (x*sx)];
-      }
-
-  SDL_UnlockSurface(surface);
-  SDL_UnlockSurface(drawable);
-
-  set_dirty(true);
-}
-
-/* EOF */

Deleted: trunk/netbrush/navigation.hpp
===================================================================
--- trunk/netbrush/navigation.hpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/navigation.hpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,55 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#ifndef HEADER_NAVIGATION_HPP
-#define HEADER_NAVIGATION_HPP
-
-#include "widget/widget.hpp"
-
-/** */
-class Navigation : public Widget
-{
-private:
-  SDL_Surface* surface;
-  bool dragging;
-public:
-  Navigation(const Rect& rect);
-  
-  void on_mouse_motion(const MouseMotionEvent& motion);
-  void on_mouse_button(const MouseButtonEvent& button);
-
-  void on_enter() {};
-  void on_leave() {}
-
-  void draw(SDL_Surface* target);
-  void update();
-private:
-  Navigation (const Navigation&);
-  Navigation& operator= (const Navigation&);
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/netbrush/saturation_value_picker.cpp
===================================================================
--- trunk/netbrush/saturation_value_picker.cpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/saturation_value_picker.cpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,140 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#include <iostream>
-#include "video.hpp"
-#include "globals.hpp"
-#include "widget/widget_manager.hpp"
-#include "color.hpp"
-#include "alpha_picker.hpp"
-#include "saturation_value_picker.hpp"
-
-SaturationValuePicker::SaturationValuePicker(const Rect& rect_)
-  : Widget(rect_), dragging(false), click_pos(64, 64)
-{
-  surface = create_surface(rect_.get_width(), rect_.get_height());
-  set_color(Color(255, 0, 0));
-
-  alpha_picker->set_color(get_color(255 * click_pos.x/get_rect().get_width(),
-                                    255 * click_pos.y/get_rect().get_height()));
-}
-
-void
-SaturationValuePicker::set_color(const Color& color_)
-{
-  color = color_;
-  SDL_LockSurface(surface);
-
-  Uint8* data = static_cast<Uint8*>(surface->pixels);
-  
-  for(int y = 0; y < surface->h; ++y)
-    for(int x = 0; x < surface->w; ++x)
-      {
-        int value      = 255 - (255 * x / surface->w);
-        int saturation = (255 * y / surface->h);
-        
-        data[3*(y * surface->w + x)+0] = (0*value + (255-value) * ((255 * saturation + color.r * (255 - saturation))/255))/255;
-        data[3*(y * surface->w + x)+1] = (0*value + (255-value) * ((255 * saturation + color.g * (255 - saturation))/255))/255;
-        data[3*(y * surface->w + x)+2] = (0*value + (255-value) * ((255 * saturation + color.b * (255 - saturation))/255))/255;
-      }
-  SDL_UnlockSurface(surface);
-  
-  alpha_picker->set_color(get_color(255 - 255 * click_pos.x/get_rect().get_width(),
-                                    255 * click_pos.y/get_rect().get_height()));
-  set_dirty(true);
-}
-
-Color
-SaturationValuePicker::get_color(Uint8 value, Uint8 saturation) const
-{
-  return Color((0*value + (255-value) * ((255 * saturation + color.r * (255 - saturation))/255))/255,
-               (0*value + (255-value) * ((255 * saturation + color.g * (255 - saturation))/255))/255,
-               (0*value + (255-value) * ((255 * saturation + color.b * (255 - saturation))/255))/255);  
-}
-
-void
-SaturationValuePicker::on_mouse_motion(const MouseMotionEvent& motion)
-{
-  set_dirty(true);
-  if (dragging)
-    {
-      click_pos.x = std::min(std::max(0, motion.x), get_rect().get_width());
-      click_pos.y = std::min(std::max(0, motion.y), get_rect().get_height());
-      alpha_picker->set_color(get_color(255 - 255 * click_pos.x/get_rect().get_width(),
-                                        255 * click_pos.y/get_rect().get_height()));
-    }
-}
-
-void
-SaturationValuePicker::on_mouse_button(const MouseButtonEvent& button)
-{
-  if (button.button == 1)
-    {
-      if (button.state == SDL_RELEASED)
-        {
-          dragging = false;
-          widget_manager->ungrab(this);
-        }
-      else if (button.state == SDL_PRESSED)
-        {
-          dragging = true;
-
-          click_pos.x = std::min(std::max(0, button.x), get_rect().get_width());
-          click_pos.y = std::min(std::max(0, button.y), get_rect().get_height());
-      
-          set_dirty(true);
-          widget_manager->grab(this);
-          alpha_picker->set_color(get_color(255 - 255 * click_pos.x/get_rect().get_width(),
-                                            255 * click_pos.y/get_rect().get_height()));
-        }
-    }
-}
-
-void
-SaturationValuePicker::draw(SDL_Surface* target)
-{
-  SDL_Rect pos;
-  pos.x = get_rect().left;
-  pos.y = get_rect().top;
-
-  SDL_Rect hline;
-  hline.x = 0  + get_rect().left;;
-  hline.y = click_pos.y  + get_rect().top;
-  hline.w = get_rect().get_width();
-  hline.h = 1;
-
-  SDL_Rect vline;
-  vline.x = click_pos.x + get_rect().left;
-  vline.y = 0 + get_rect().top;
-  vline.w = 1;
-  vline.h = get_rect().get_height();
-
-  SDL_BlitSurface(surface, 0, target, &pos);
-
-  SDL_FillRect(target, &hline, SDL_MapRGB(target->format, 0, 0, 0));
-  SDL_FillRect(target, &vline, SDL_MapRGB(target->format, 0, 0, 0));
-}
-
-/* EOF */

Deleted: trunk/netbrush/saturation_value_picker.hpp
===================================================================
--- trunk/netbrush/saturation_value_picker.hpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/saturation_value_picker.hpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,60 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#ifndef HEADER_SATURATION_VALUE_PICKER_HPP
-#define HEADER_SATURATION_VALUE_PICKER_HPP
-
-#include "widget/widget.hpp"
-
-/** */
-class SaturationValuePicker : public Widget
-{
-private:
-  Color color;
-  SDL_Surface* surface;
-  bool  dragging;
-  Point click_pos;
-public:
-  SaturationValuePicker(const Rect& rect);
-
-  void on_mouse_motion(const MouseMotionEvent& motion);
-  void on_mouse_button(const MouseButtonEvent& button);
-
-  void on_enter() {};
-  void on_leave() {}
-
-  void draw(SDL_Surface* target);
-  void set_color(const Color& color);
-
-  Color get_color(Uint8 value, Uint8 saturation) const;
-
-private:
-  SaturationValuePicker (const SaturationValuePicker&);
-  SaturationValuePicker& operator= (const SaturationValuePicker&);
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/netbrush/screen_buffer.cpp
===================================================================
--- trunk/netbrush/screen_buffer.cpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/screen_buffer.cpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,329 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#include <iostream>
-#include <sstream>
-#include "video.hpp"
-#include "drawing_context.hpp"
-#include "drawing_parameter.hpp"
-#include "stroke_buffer.hpp"
-#include "widget/widget_manager.hpp"
-#include "globals.hpp"
-#include "server_connection.hpp"
-#include "widget/scrollbar.hpp"
-#include "screen_buffer.hpp"
-
-ScreenBuffer::ScreenBuffer(const Rect& rect)
-  : Widget(rect),
-    scroll_offset_x(0),
-    scroll_offset_y(0),
-    old_scroll_offset_x(0),
-    old_scroll_offset_y(0),
-    click_pos_x(0),
-    click_pos_y(0),
-    scrolling(false),
-    complete_refresh(false)
-{
-}
-
-ScreenBuffer::~ScreenBuffer()
-{
-  //  SDL_FreeSurface(buffer);
-}
-
-void
-ScreenBuffer::draw(SDL_Surface* target)
-{
-  //SDL_SetClipRect(target, &rect);
-
-  int trans_x = get_rect().left + scroll_offset_x;
-  int trans_y = get_rect().top  + scroll_offset_y;
-
-  // Transform dirty_region into screen space
-  dirty_region.left   += trans_x;
-  dirty_region.top    += trans_y;
-  dirty_region.right  += trans_x;
-  dirty_region.bottom += trans_y;
-  
-  if (1)
-    {
-      dirty_region.left   = std::max(get_rect().left,   dirty_region.left);
-      dirty_region.top    = std::max(get_rect().top,    dirty_region.top);
-      dirty_region.right  = std::min(get_rect().right,  dirty_region.right);
-      dirty_region.bottom = std::min(get_rect().bottom, dirty_region.bottom);
-    }
-
-  if (0)
-    std::cout << "Updating screen: "
-              << dirty_region.left  << " "
-              << dirty_region.top   << " "
-              << dirty_region.right << " "
-              << dirty_region.bottom 
-              << std::endl;
-
-  // FIXME: Should go elsewhere
-  horizontal_scrollbar->set_pos(-scroll_offset_x);
-  vertical_scrollbar->set_pos(-scroll_offset_y);
-
-  if (complete_refresh)
-    { 
-      SDL_Rect r;
-      r.x = get_rect().left;
-      r.y = get_rect().top;
-      r.w = get_rect().get_width();
-      r.h = get_rect().get_height();
-      SDL_FillRect(target, &r, SDL_MapRGB(target->format, 0, 0, 0));
-    }
-
-  // check for invalid dirty_regions (ie. canvas is completly outside of the view)
-  if (dirty_region.left < dirty_region.right &&
-      dirty_region.top  <  dirty_region.bottom)
-    {
-      draw_ctx->draw(target, dirty_region, trans_x, trans_y);
-      if (!scrolling)
-        stroke_buffer->draw(target, dirty_region, trans_x, trans_y);
-
-      { // draw layer boundary
-        Uint32 color = SDL_MapRGB(target->format, 0, 0, 0);
-        SDL_Rect r;
-
-        r.x = trans_x;
-        r.y = trans_y;
-        r.w = draw_ctx->get_width();
-        r.h = 1;
-
-        SDL_FillRect(target, &r, color);
-
-        r.x = trans_x;
-        r.y = draw_ctx->get_height()-1 + trans_y;
-        r.w = draw_ctx->get_width();
-        r.h = 1;
-
-        SDL_FillRect(target, &r, color);
-
-        r.x = draw_ctx->get_width()-1 + trans_x;
-        r.y = trans_y;
-        r.w = 1;
-        r.h = draw_ctx->get_height();
-
-        SDL_FillRect(target, &r, color);
-
-        r.x = trans_x;
-        r.y = trans_y;
-        r.w = 1;
-        r.h = draw_ctx->get_height();
-
-        SDL_FillRect(target, &r, color);
-      }
-  
-      if (complete_refresh)
-        { 
-          SDL_Rect r;
-          r.x = get_rect().left;
-          r.y = get_rect().top;
-          r.w = get_rect().get_width();
-          r.h = get_rect().get_height();
-            
-          SDL_UpdateRect(target, r.x, r.y, r.w, r.h);
-        }
-      else
-        {
-          SDL_UpdateRect(target, 
-                         dirty_region.left,        dirty_region.top, 
-                         dirty_region.get_width(), dirty_region.get_height());
-        }
-    }
-  else 
-    {
-      if (complete_refresh)
-        { 
-          SDL_Rect r;
-          r.x = get_rect().left;
-          r.y = get_rect().top;
-          r.w = get_rect().get_width();
-          r.h = get_rect().get_height();
-            
-          SDL_UpdateRect(target, r.x, r.y, r.w, r.h);
-        }
-    }
-
-  if (0) 
-    std::cout << "Updating done" << std::endl;
-
-  complete_refresh = false;
-}
-
-void
-ScreenBuffer::mark_dirty(const Rect& region)
-{
-  mark_dirty(region.left, region.top, region.get_width(), region.get_height());
-}
-
-void
-ScreenBuffer::mark_dirty(int x, int y, int w, int h)
-{
-  if (x < 0)
-    x = 0;
-
-  if (y < 0)
-    y = 0;
-  
-  // FIXME: This must be drawable size, not screen size
-  if (x + w > draw_ctx->get_width())
-    w = draw_ctx->get_width() - x;
-
-  if (y + h > draw_ctx->get_height())
-    h = draw_ctx->get_height() - y;
-
-  //std::cout << "Dirty: " << x << " " << y << " " << w << " " << h << std::endl;
-
-  if (is_dirty())
-    {
-      int x1 = dirty_region.left;
-      int y1 = dirty_region.top;
-      int x2 = dirty_region.right;
-      int y2 = dirty_region.bottom;
-
-      dirty_region.left = std::min(x, x1);
-      dirty_region.top  = std::min(y, y1);
-      
-      dirty_region.right  = std::max(x+w, x2);
-      dirty_region.bottom = std::max(y+h, y2);
-    }
-  else
-    {
-      dirty_region.left   = x;
-      dirty_region.top    = y;
-      dirty_region.right  = x + w;
-      dirty_region.bottom = y + h;
-      set_dirty(true);
-    }
-}
-
-void
-ScreenBuffer::on_mouse_motion(const MouseMotionEvent& motion)
-{
-  //satd::cout << motion.x << " " << motion.y << std::endl;
-  if (current_stroke)
-    {
-      current_stroke->add_dab(Dab(motion.x - scroll_offset_x, motion.y - scroll_offset_y));
-      stroke_buffer->add_dab(Dab(motion.x - scroll_offset_x, motion.y - scroll_offset_y));
-
-      // sync
-      Rect rect = current_stroke->get_bounding_rect(); 
-              
-      // calculate bounding rectangle by taking brush thickness into account
-      rect.left -= client_draw_param->thickness()/2;
-      rect.top  -= client_draw_param->thickness()/2;
-
-      rect.right  += client_draw_param->thickness()/2;
-      rect.bottom += client_draw_param->thickness()/2;
-                  
-      mark_dirty(rect);
-    }
-
-  if (scrolling)
-    {
-      scroll_offset_x = old_scroll_offset_x + (motion.x - click_pos_x);
-      scroll_offset_y = old_scroll_offset_y + (motion.y - click_pos_y);
-
-      Rect r(0, 0, get_rect().get_width(), get_rect().get_height());
-      r.left   -= scroll_offset_x;
-      r.right  -= scroll_offset_x;
-      r.top    -= scroll_offset_y;
-      r.bottom -= scroll_offset_y;
-      mark_dirty(r);
-      complete_refresh = true;
-      //std::cout << "Scrolling: " << scroll_offset_x << " " << scroll_offset_y << std::endl;
-    } 
-}
-
-void
-ScreenBuffer::on_mouse_button(const MouseButtonEvent& button)
-{
-  if (button.state == SDL_RELEASED)
-    {
-      if (button.button == 1)
-        {
-          if (current_stroke)
-            {
-              widget_manager->ungrab(this);
-
-              stroke_buffer->clear();
-              server->send_stroke(*current_stroke, client_draw_param);
-
-              current_stroke = 0;
-            }
-        }
-      else if (button.button == 2)
-        {
-          scroll_offset_x = old_scroll_offset_x + (button.x - click_pos_x);
-          scroll_offset_y = old_scroll_offset_y + (button.y - click_pos_y);
-          scrolling = false;
-        }
-    }  
-  else if (button.state == SDL_PRESSED)
-    {
-      if (button.button == 1)
-        {
-          widget_manager->grab(this);
-          current_stroke = new Stroke();
-
-          current_stroke->add_dab(Dab(button.x - scroll_offset_x, button.y - scroll_offset_y));
-          stroke_buffer->add_dab(Dab(button.x - scroll_offset_x, button.y - scroll_offset_y));
-
-          // FIXME: First dab is lost
-        }
-      else if (button.button == 2)
-        {
-          click_pos_x = button.x;
-          click_pos_y = button.y;
-
-          old_scroll_offset_x = scroll_offset_x;
-          old_scroll_offset_y = scroll_offset_y;
-
-          scrolling = true;
-        }
-    }
-}
-
-void
-ScreenBuffer::move_to(int x, int y)
-{
-  scroll_offset_x = get_rect().get_width()/2  - x;
-  scroll_offset_y = get_rect().get_height()/2 - y;
-  //std::cout << "MoveTo: " << x << " " << y << std::endl;
-
-  Rect r(0, 0, get_rect().get_width(), get_rect().get_height());
-  r.left   -= scroll_offset_x;
-  r.right  -= scroll_offset_x;
-  r.top    -= scroll_offset_y;
-  r.bottom -= scroll_offset_y;
-  mark_dirty(r);
-  complete_refresh = true;
-  set_dirty(true);
-}
-
-/* EOF */

Deleted: trunk/netbrush/screen_buffer.hpp
===================================================================
--- trunk/netbrush/screen_buffer.hpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/screen_buffer.hpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,77 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#ifndef HEADER_SCREEN_BUFFER_HPP
-#define HEADER_SCREEN_BUFFER_HPP
-
-#include "SDL.h"
-#include "widget/widget.hpp"
-
-/** */
-class ScreenBuffer : public Widget
-{
-private:
-  //SDL_Surface* buffer;
-  Rect dirty_region;
-
-  int scroll_offset_x;
-  int scroll_offset_y;
-
-  int old_scroll_offset_x;
-  int old_scroll_offset_y;
-
-  int click_pos_x;
-  int click_pos_y;
-
-  bool scrolling;
-  bool complete_refresh;
-public:
-  ScreenBuffer(const Rect& rect);
-  ~ScreenBuffer();
-
-  // Mark an region as dirty in canvas space, not screen space
-  void mark_dirty(int x, int y, int w, int h);
-  void mark_dirty(const Rect& region);
-  
-  void draw(SDL_Surface* target);
-
-  void on_mouse_motion(const MouseMotionEvent& motion);
-  void on_mouse_button(const MouseButtonEvent& button);
-  
-  void on_enter() {}
-  void on_leave() {}
-
-  bool do_update() { return false; }
-
-  void move_to(int x, int y);
-
-private:
-  ScreenBuffer (const ScreenBuffer&);
-  ScreenBuffer& operator= (const ScreenBuffer&);
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/netbrush/server.cpp
===================================================================
--- trunk/netbrush/server.cpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/server.cpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,369 +0,0 @@
-#include <string>
-#include <iostream>
-#include <fstream>
-#include <sstream>
-#include <vector>
-#include "SDL.h"
-#include "SDL_net.h"
-
-#ifdef WIN32
-#include  <io.h>
-#define access _access
-#define F_OK   0
-#endif
-
-class ClientConnection;
-
-std::vector<ClientConnection*> clients;
-SDLNet_SocketSet socketset;
-
-TCPsocket serversock;
-
-std::vector<std::string> drawing_history;
-
-std::ofstream* outfile = 0;
-
-std::vector<std::string>
-tokenize(const std::string& str, char split_char)
-{
-  std::string::size_type start = 0;
-  std::string::size_type end   = 0;
-
-  std::vector<std::string> tokens;
-
-  while (start < str.size())
-    {
-      if ((end = str.find(split_char, start)) == std::string::npos)
-        {
-          tokens.push_back(str.substr(start));
-          break;
-        }
-
-      const std::string& ret = str.substr(start, end - start);
-
-      if (!ret.empty())
-        tokens.push_back(ret);
-
-      start = end + 1;
-    }
-
-  return tokens;
-}
-
-class ClientConnection
-{
-public:
-  int id;
-  TCPsocket   tcpsock;
-  int         buffer_pos;
-  std::string buffer;
-  bool        invalid;
-  bool        full_client;
-public:
-  ClientConnection(int id_, TCPsocket socket)
-    : id(id_), 
-      tcpsock(socket),
-      invalid(false)
-  {
-    buffer_pos = 0;
-    full_client = false;
-  }
-  
-  bool is_invalid()
-  {
-    return invalid;
-  }
-
-  void update()
-  {
-    if (invalid) return;
-
-    if (SDLNet_SocketReady(tcpsock))
-      {
-        const int MAXLEN = 1024;
-        char msg[MAXLEN];
-
-        int result = SDLNet_TCP_Recv(tcpsock, msg, MAXLEN);
-        if(result <= 0) 
-          {
-            // TCP Connection is broken. (because of error or closure)
-            std::cout << "# Connection break, abort" << std::endl;
-            invalid = true;
-            return;
-          }
-        else 
-          {
-            for(int i = 0; i < result; ++i)
-              {
-                if (msg[i] == '\n')
-                  {
-                    process_line(buffer);
-                    buffer.clear();
-                    buffer_pos = 0;
-                  }
-                else
-                  {
-                    buffer += msg[i];
-                  }
-              }
-          }
-      }
-  }
-
-  void send_string(const std::string& line)
-  {
-    if (full_client)
-      {
-        if (invalid) return;
-
-        int result = SDLNet_TCP_Send(tcpsock, const_cast<char*>(line.c_str()), line.length());
-        if (result < int(line.length()))
-          {
-            // It may be good to disconnect sock because it is likely invalid now.
-            printf( "Error: SDLNet_TCP_Send: '%s'\n", SDLNet_GetError() );
-            invalid = true;
-          }
-      }
-  }
-
-  void process_line(const std::string& line)
-  {
-    if (invalid) return;
-    
-    std::vector<std::string> tokens = tokenize(line, ' ');
-    if (tokens.size() == 2 && tokens[0] == "load")
-      {
-        for(int i = 0; i < int(clients.size()); ++i)
-          {
-            if (clients[i])
-              {
-                clients[i]->send_string("clear\n");
-              }
-          }
-        std::cout << "# load unimplemented" << std::endl;
-      }
-    else if (tokens.size() == 2 && tokens[0] == "import")
-      {
-        std::cout << "# import unimplemented" << std::endl;
-      }
-    else if (tokens.size() == 2 && tokens[0] == "save")
-      {
-        for(int i = 0; i < int(tokens[1].size()); ++i)
-          {
-            if (tokens[1][i] == '/' || tokens[1][i] == '.')
-              {
-                tokens[1][i] = '.';
-              }
-          }
-        
-        std::ostringstream filename;
-        filename << "images/" << tokens[1] << ".nbr";        
-
-        int j = 1;
-        std::string fname = filename.str();
-        while (access(fname.c_str(), F_OK) == 0)
-          {
-            filename.str("");
-            filename << "images/" << tokens[1] << "-" << j << ".nbr";
-            fname = filename.str();
-            j += 1;
-          }
-
-        std::cout << "# writing log to " << filename.str() << std::endl;
-        std::ofstream out(fname.c_str());
-        for(int i = 0; i < int(drawing_history.size()); ++i)
-          out << drawing_history[i];
-        out.close();
-      }
-    else if (tokens.size() == 2 && tokens[0] == "client_version")
-      {
-        if (atoi(tokens[1].c_str()) == 1)
-          {
-            full_client = true;
-            for(int i = 0; i < int(drawing_history.size()); ++i)
-              {
-                clients.back()->send_string(drawing_history[i]);
-              }
-          }
-      }
-    else if (tokens.size() == 1 && tokens[0] == "clear")
-      {
-        std::ostringstream filename;
-        filename << "sessions/session-" << time(NULL) << ".nbr";
-        
-        std::cout << "# writing log to " << filename.str() << std::endl;
-        outfile->close();
-        delete outfile;
-        outfile = new std::ofstream(filename.str().c_str());
-
-        drawing_history.clear();
-
-        for(int i = 0; i < int(clients.size()); ++i)
-          {
-            if (clients[i])
-              {
-                clients[i]->send_string("clear\n");
-              }
-          }
-      }
-    else if (tokens.size() >= 1 && 
-             (tokens[0] == "dab" ||
-              tokens[0] == "stroke_begin" ||
-              tokens[0] == "stroke_end"   ||
-              tokens[0] == "set_brush"    ||
-              tokens[0] == "set_generic_brush" ||
-              tokens[0] == "set_color"    ||
-              tokens[0] == "set_tool"     ||
-              tokens[0] == "set_opacity" 
-              ))
-      {
-        std::ostringstream str;
-        str << "client " << id << " " << line << std::endl;
-        //std::cout << "SERVER: " << str.str();
-        drawing_history.push_back(str.str());
-        (*outfile) << str.str() << std::flush;
-
-        for(int i = 0; i < int(clients.size()); ++i)
-          {
-            if (clients[i])
-              {
-                clients[i]->send_string(str.str());
-                // FIXME: write to file
-              }
-          }
-      }
-    else
-      {
-        std::cout << "# invalid command: " << line << std::endl;
-      }
-  }
-};
-
-void accept_connections()
-{
-  if (SDLNet_SocketReady(serversock))
-    {
-      TCPsocket client = SDLNet_TCP_Accept(serversock);
-      if (client)
-        {
-          clients.push_back(new ClientConnection(clients.size()+1, client));
-
-          std::stringstream out;
-          out << "version 0" << std::endl;
-          out << "your_id " << clients.size() << std::endl;
-          std::string str = out.str();
-          SDLNet_TCP_Send(client, const_cast<char*>(str.c_str()), str.length()+1);
-
-          IPaddress* ip = SDLNet_TCP_GetPeerAddress(client);
-
-          const char* host;
-          if((host = SDLNet_ResolveIP(ip)) != 0)
-            std::cout << "# Got client connection from " << host << " " << ip->port << std::endl;
-          else
-            std::cout << "# Got client connection from " << ip->host << " " << ip->port << std::endl;
-          
-          int numused = SDLNet_TCP_AddSocket(socketset, client);
-          if (numused == -1) {
-            printf("SDLNet_AddSocket: %s\n", SDLNet_GetError());
-            // perhaps you need to restart the set and make it bigger...
-          } 
-          else
-            {
-              std::cout << "# Sockets used: " << numused << std::endl;
-            }
-        }
-    }
-}
-
-void connect(Uint16 port)
-{
-  IPaddress ip;
-  
-  if(SDLNet_ResolveHost(&ip,NULL,port)==-1) {
-    printf("SDLNet_ResolveHost: %s\n", SDLNet_GetError());
-    exit(1);
-  }
-  serversock = SDLNet_TCP_Open(&ip);
-  if(!serversock) {
-    printf("SDLNet_TCP_Open: %s\n", SDLNet_GetError());
-    exit(2);
-  }
-
-  socketset = SDLNet_AllocSocketSet(32);
-  if (!socketset) {
-    printf("SDLNet_AllocSocketSet: %s\n", SDLNet_GetError());
-    exit(1); //most of the time this is a major error, but do what you want.
-  }
-
-  SDLNet_TCP_AddSocket(socketset, serversock);
-
-  while(true)
-    {
-      int num = 0;
-      if ((num = SDLNet_CheckSockets(socketset, 10000)) == -1)
-        {
-          printf("SDLNet_CheckSockets: %s\n", SDLNet_GetError());
-          //most of the time this is a system error, where perror might help you.
-          perror("SDLNet_CheckSockets");
-        }
-      else
-        { 
-          accept_connections();
-       
-          for(int i = 0; i < int(clients.size()); ++i)
-            {
-              if (clients[i])
-                clients[i]->update();
-            }
-
-          for(int i = 0; i < int(clients.size()); ++i)
-            {
-              if (clients[i] && clients[i]->is_invalid())
-                {
-                  std::cout << "# client " << clients[i]->id << " got disconnected" << std::endl;
-                  SDLNet_TCP_DelSocket(socketset, clients[i]->tcpsock); 
-                  SDLNet_TCP_Close(clients[i]->tcpsock);
-                  delete clients[i];
-                  clients[i] = 0;
-                }
-            }
-        }
-    }
-}
-
-int main(int argc, char** argv)
-{
-  if(SDL_Init(0)==-1) {
-    printf("SDL_Init: %s\n", SDL_GetError());
-    exit(1);
-  }
-
-  if(SDLNet_Init()==-1) {
-    printf("SDLNet_Init: %s\n", SDLNet_GetError());
-    exit(2);
-  }
-
-  atexit(SDL_Quit);
-  atexit(SDLNet_Quit);
-
-  std::ostringstream filename;
-  filename << "sessions/session-" << time(NULL) << ".nbr";
-
-  std::cout << "# writing log to " << filename.str() << std::endl;
-  outfile = new std::ofstream(filename.str().c_str());
-
-  if (argc == 2)
-    {
-      std::cout << "# listening on: " << argv[1] << std::endl;
-      connect(atoi(argv[1]));
-    }
-  else
-    {
-      std::cout << "Usage: " << argv[0] << " PORT" << std::endl;
-    }
-
-  outfile->close();
-  delete outfile;
-
-  return 0;
-}

Deleted: trunk/netbrush/server_connection.cpp
===================================================================
--- trunk/netbrush/server_connection.cpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/server_connection.cpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,333 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#include <iostream>
-#include <sstream>
-#include "globals.hpp"
-#include "client_state.hpp"
-#include "color.hpp"
-#include "drawing_context.hpp"
-#include "drawing_parameter.hpp"
-#include "server_connection.hpp"
-
-static std::vector<std::string>
-tokenize(const std::string& str, char split_char)
-{
-  std::string::size_type start = 0;
-  std::string::size_type end   = 0;
-
-  std::vector<std::string> tokens;
-
-  while (start < str.size())
-    {
-      if ((end = str.find(split_char, start)) == std::string::npos)
-        {
-          tokens.push_back(str.substr(start));
-          break;
-        }
-
-      const std::string& ret = str.substr(start, end - start);
-
-      if (!ret.empty())
-        tokens.push_back(ret);
-
-      start = end + 1;
-    }
-
-  return tokens;
-}
-
-ServerConnection::ServerConnection()
-  : tcpsock(0),
-    socketset(0)
-{
-}
-
-ServerConnection::~ServerConnection()
-{
-}
-
-void
-ServerConnection::send(const std::string& str)
-{
-  if (tcpsock)
-    {
-      int result = SDLNet_TCP_Send(tcpsock, const_cast<char*>(str.c_str()), str.length());
-      if(result < int(str.length()))
-        {
-          printf( "SDLNet_TCP_Send: %s\n", SDLNet_GetError() );
-          // It may be good to disconnect sock because it is likely invalid now.
-        }     
-    }
-  else
-    { // Not connected, so directly procses the command without a
-      // round trip through the server
-      std::string tmp;
-      for(std::string::size_type i = 0; i < str.length(); ++i)
-        {
-          if (str[i] == '\n')
-            {
-              process_command("client 0 " + tmp);
-              tmp.clear();
-            }
-          else
-            tmp += str[i];
-        }
-    }  
-}
-
-void
-ServerConnection::connect(const char* hostname, Uint16 port)
-{
-  IPaddress ip;
-
-  if(SDLNet_ResolveHost(&ip, hostname, port) == -1) 
-    {
-      printf("SDLNet_ResolveHost: %s\n", SDLNet_GetError());
-      exit(1);
-    }
-
-  tcpsock = SDLNet_TCP_Open(&ip);
-  if(!tcpsock)
-    {
-      printf("SDLNet_TCP_Open: %s %s:%d\n", SDLNet_GetError(), hostname, port);
-      exit(2);
-    }
-  else
-    {
-      std::string line = "client_version 1\n";
-      SDLNet_TCP_Send(tcpsock, const_cast<char*>(line.c_str()), line.length());
-
-      socketset = SDLNet_AllocSocketSet(1);
-      SDLNet_TCP_AddSocket(socketset, tcpsock);
-    }
-}
-
-void
-ServerConnection::update()
-{
-  if (!tcpsock) return;
-
-  int num = 0;
-  if ((num = SDLNet_CheckSockets(socketset, 0)) == -1)
-    {
-      printf("SDLNet_CheckSockets: %s\n", SDLNet_GetError());
-      //most of the time this is a system error, where perror might help you.
-      perror("SDLNet_CheckSockets");
-    }
-  
-  if (num > 0)
-    {
-      if (SDLNet_SocketReady(tcpsock))
-        {
-          const int MAXLEN = 1024;
-          int result;
-          char msg[MAXLEN];
-
-          result = SDLNet_TCP_Recv(tcpsock, msg, MAXLEN);
-          if(result <= 0) 
-            {
-              // TCP Connection is broken. (because of error or closure)
-              SDLNet_TCP_Close(tcpsock);
-              exit(1);
-            }
-          else 
-            {
-              for(int i = 0; i < result; ++i)
-                {
-                  if (msg[i] == '\n')
-                    {
-                      process_command(buffer);
-                      //std::cout << server_buffer << std::endl;
-                      buffer.clear();
-                    }
-                  else
-                    {
-                      buffer += msg[i];
-                    }
-                }
-            }
-        }
-    }
-}
-
-void
-ServerConnection::process_command(const std::string& cmd)
-{
-  if (cmd.empty()) return;
-
-  const std::vector<std::string>& tokens = tokenize(cmd, ' ');
-  if (0)
-    for(int i = 0; i < int(tokens.size()); ++i)
-      std::cout << "Token: '" << tokens[i] << "'" << std::endl;
-
-  if (!tokens.empty())
-    {
-      if (tokens[0] == "#")
-        {
-          // comment, ignore
-        }
-      else if (tokens[0] == "clear")
-        {
-          draw_ctx->clear();
-        }
-      else if (tokens[0] == "client")
-        {
-          if (tokens.size() > 2)
-            {
-              int client_id = atoi(tokens[1].c_str());
-              // convert to stroke
-              std::map<int, ClientState*>::iterator i = client_states.find(client_id);
-              ClientState* client_state = 0;
-              if (i != client_states.end())
-                {
-                  client_state = i->second;
-                }
-              else
-                {
-                  std::cout << "# allocating new ClientState" << std::endl;
-                  client_state = new ClientState(client_id);
-                  client_states[client_id] = client_state;
-                }
-              
-              if (tokens.size() == 3 && tokens[2] == "stroke_begin")
-                {
-                  client_state->stroke_begin();
-                }
-              else if (tokens.size() == 3 && tokens[2] == "stroke_end")
-                {
-                  client_state->stroke_end();
-                }
-              else if (tokens.size() == 4 && tokens[2] == "set_brush")
-                {
-                  client_state->set_brush(tokens[3]);
-                }
-              else if (tokens.size() == 9 && tokens[2] == "set_generic_brush")
-                {
-                  client_state->set_generic_brush((BrushShape)atoi(tokens[3].c_str()),  // shape FIXME: could use name instead
-                                                  atof(tokens[4].c_str()),  // radius
-                                                  atoi(tokens[5].c_str()),  // spike
-                                                  atof(tokens[6].c_str()),  // hardness
-                                                  atof(tokens[7].c_str()),  // aspectratio
-                                                  atof(tokens[8].c_str())); // angle
-                }
-              else if (tokens.size() == 4 && tokens[2] == "set_opacity")
-                {
-                  client_state->set_opacity(atoi(tokens[3].c_str()));
-                }
-              else if (tokens.size() == 4 && tokens[2] == "set_tool")
-                {
-                  client_state->set_tool(static_cast<DrawingParameter::Tool>(atoi(tokens[3].c_str())));
-                }
-              else if (tokens.size() == 6 && tokens[2] == "set_color")
-                {
-                  client_state->set_color(Color(atoi(tokens[3].c_str()), 
-                                                atoi(tokens[4].c_str()), 
-                                                atoi(tokens[5].c_str())));
-                }
-              else if (tokens.size() == 6 && tokens[2] == "dab")
-                {
-                  client_state->dab(atoi(tokens[3].c_str()), 
-                                    atoi(tokens[4].c_str()),
-                                    atoi(tokens[5].c_str()));
-                }
-              else
-                {
-                  std::cout << "# invalid command: " << cmd << std::endl;
-                }
-            }
-          else
-            {
-              std::cout << "# invalid command: " << cmd << std::endl;
-            }
-        }
-      else if (tokens[0] == "version")
-        {
-          if (tokens.size() == 2)
-            {
-              if (atoi(tokens[1].c_str()) != 0)
-                {
-                  std::cout << "# version mismatch: " << cmd << std::endl;
-                  std::cout << "# upgrade your netbrush client" << std::endl;
-                  exit(1);
-                }
-            }
-          else
-            {
-              std::cout << "# invalid command: " << cmd << std::endl;
-            }
-        }
-      else if (tokens[0] == "your_id")
-        {
-          if (tokens.size() == 2)
-            {
-              std::cout << "# my Id: " << atoi(tokens[1].c_str()) << std::endl;
-            }
-          else
-            {
-              std::cout << "# invalid command: " << cmd << std::endl;
-            }
-        }
-      else
-        {
-          std::cout << "# invalid command: " << cmd << std::endl;
-        }
-    }
-}
-
-void
-ServerConnection::send_stroke(const Stroke& stroke, DrawingParameter* param)
-{
-  const Stroke::Dabs& dabs = stroke.get_dabs();
-
-  std::stringstream str;
-  if (param->get_brush().empty())
-    str << "set_generic_brush " 
-        << param->generic_brush.shape << " "
-        << param->generic_brush.radius << " "
-        << param->generic_brush.spikes << " "
-        << param->generic_brush.hardness << " "
-        << param->generic_brush.aspect_ratio << " "
-        << param->generic_brush.angle << " "
-        << std::endl;
-  else
-    str << "set_brush " << param->get_brush() << std::endl;
-  str << "set_tool " << param->tool << std::endl; 
-  str << "set_opacity " << int(param->opacity) << std::endl;
-  str << "set_color "
-      << int(param->color.r) << " " 
-      << int(param->color.g) << " " 
-      << int(param->color.b) << std::endl;
-  str << "stroke_begin" << std::endl;
-  for(Stroke::Dabs::const_iterator i = dabs.begin(); i != dabs.end(); ++i)
-    {
-      str << "dab " << i->time << " " << i->pos.x << " " << i->pos.y  << std::endl;
-    }
-  str << "stroke_end" << std::endl;
-      
-  send(str.str());
-}
-
-/* EOF */

Deleted: trunk/netbrush/server_connection.hpp
===================================================================
--- trunk/netbrush/server_connection.hpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/server_connection.hpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,62 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#ifndef HEADER_SERVER_CONNECTION_HPP
-#define HEADER_SERVER_CONNECTION_HPP
-
-#include <string>
-#include "SDL_net.h"
-
-class Stroke;
-class DrawingParameter;
-
-/** */
-class ServerConnection
-{
-private:
-  TCPsocket tcpsock;
-  SDLNet_SocketSet socketset;
-  std::string buffer;
-
-public:
-  ServerConnection();
-  ~ServerConnection();
-
-  void connect(const char* hostname, Uint16 port);
-
-  /** Send a string to the server, you must add the trailing newline
-      yourself to \a str */
-  void send(const std::string& str);
-  void send_stroke(const Stroke& stroke, DrawingParameter* param);
-  void update();
-  void process_command(const std::string& cmd);
-private:
-  ServerConnection (const ServerConnection&);
-  ServerConnection& operator= (const ServerConnection&);
-};
-
-#endif
-
-/* EOF */

Copied: trunk/netbrush/src/SConstruct (from rev 662, trunk/netbrush/SConstruct)

Copied: trunk/netbrush/src/alpha_picker.cpp (from rev 647, trunk/netbrush/alpha_picker.cpp)

Copied: trunk/netbrush/src/alpha_picker.hpp (from rev 647, trunk/netbrush/alpha_picker.hpp)

Copied: trunk/netbrush/src/brush_widget.cpp (from rev 656, trunk/netbrush/brush_widget.cpp)

Copied: trunk/netbrush/src/brush_widget.hpp (from rev 647, trunk/netbrush/brush_widget.hpp)

Copied: trunk/netbrush/src/brushmask.cpp (from rev 647, trunk/netbrush/brushmask.cpp)

Copied: trunk/netbrush/src/brushmask.hpp (from rev 647, trunk/netbrush/brushmask.hpp)

Copied: trunk/netbrush/src/client.cpp (from rev 659, trunk/netbrush/client.cpp)

Copied: trunk/netbrush/src/client_state.cpp (from rev 655, trunk/netbrush/client_state.cpp)

Copied: trunk/netbrush/src/client_state.hpp (from rev 655, trunk/netbrush/client_state.hpp)

Copied: trunk/netbrush/src/color.hpp (from rev 647, trunk/netbrush/color.hpp)

Copied: trunk/netbrush/src/debug.cpp (from rev 647, trunk/netbrush/debug.cpp)

Copied: trunk/netbrush/src/debug.hpp (from rev 647, trunk/netbrush/debug.hpp)

Copied: trunk/netbrush/src/drawing_context.cpp (from rev 662, trunk/netbrush/drawing_context.cpp)

Copied: trunk/netbrush/src/drawing_context.hpp (from rev 658, trunk/netbrush/drawing_context.hpp)

Copied: trunk/netbrush/src/drawing_parameter.cpp (from rev 661, trunk/netbrush/drawing_parameter.cpp)

Copied: trunk/netbrush/src/drawing_parameter.hpp (from rev 661, trunk/netbrush/drawing_parameter.hpp)

Copied: trunk/netbrush/src/generic_brush.cpp (from rev 647, trunk/netbrush/generic_brush.cpp)

Copied: trunk/netbrush/src/generic_brush.hpp (from rev 647, trunk/netbrush/generic_brush.hpp)

Copied: trunk/netbrush/src/globals.cpp (from rev 658, trunk/netbrush/globals.cpp)

Copied: trunk/netbrush/src/globals.hpp (from rev 658, trunk/netbrush/globals.hpp)

Copied: trunk/netbrush/src/graphic_context_state.cpp (from rev 662, trunk/netbrush/graphic_context_state.cpp)

Copied: trunk/netbrush/src/graphic_context_state.hpp (from rev 662, trunk/netbrush/graphic_context_state.hpp)

Copied: trunk/netbrush/src/grayscale_buffer.cpp (from rev 661, trunk/netbrush/grayscale_buffer.cpp)

Copied: trunk/netbrush/src/grayscale_buffer.hpp (from rev 647, trunk/netbrush/grayscale_buffer.hpp)

Copied: trunk/netbrush/src/hue_picker.cpp (from rev 647, trunk/netbrush/hue_picker.cpp)

Copied: trunk/netbrush/src/hue_picker.hpp (from rev 647, trunk/netbrush/hue_picker.hpp)

Copied: trunk/netbrush/src/math (from rev 647, trunk/netbrush/math)

Copied: trunk/netbrush/src/navigation.cpp (from rev 660, trunk/netbrush/navigation.cpp)

Copied: trunk/netbrush/src/navigation.hpp (from rev 659, trunk/netbrush/navigation.hpp)

Copied: trunk/netbrush/src/saturation_value_picker.cpp (from rev 647, trunk/netbrush/saturation_value_picker.cpp)

Copied: trunk/netbrush/src/saturation_value_picker.hpp (from rev 647, trunk/netbrush/saturation_value_picker.hpp)

Copied: trunk/netbrush/src/screen_buffer.cpp (from rev 661, trunk/netbrush/screen_buffer.cpp)

Copied: trunk/netbrush/src/screen_buffer.hpp (from rev 660, trunk/netbrush/screen_buffer.hpp)

Copied: trunk/netbrush/src/server.cpp (from rev 655, trunk/netbrush/server.cpp)

Copied: trunk/netbrush/src/server_connection.cpp (from rev 655, trunk/netbrush/server_connection.cpp)

Copied: trunk/netbrush/src/server_connection.hpp (from rev 649, trunk/netbrush/server_connection.hpp)

Copied: trunk/netbrush/src/stroke.cpp (from rev 647, trunk/netbrush/stroke.cpp)

Copied: trunk/netbrush/src/stroke.hpp (from rev 647, trunk/netbrush/stroke.hpp)

Copied: trunk/netbrush/src/stroke_buffer.cpp (from rev 661, trunk/netbrush/stroke_buffer.cpp)

Copied: trunk/netbrush/src/stroke_buffer.hpp (from rev 647, trunk/netbrush/stroke_buffer.hpp)

Copied: trunk/netbrush/src/video.cpp (from rev 653, trunk/netbrush/video.cpp)

Copied: trunk/netbrush/src/video.hpp (from rev 653, trunk/netbrush/video.hpp)

Copied: trunk/netbrush/src/widget (from rev 647, trunk/netbrush/widget)

Deleted: trunk/netbrush/src/widget/button.cpp
===================================================================
--- trunk/netbrush/widget/button.cpp	2006-10-18 21:14:26 UTC (rev 647)
+++ trunk/netbrush/src/widget/button.cpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,115 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#include <iostream>
-#include "SDL_image.h"
-#include "widget_manager.hpp"
-#include "../globals.hpp"
-#include "button.hpp"
-
-Button::Button(const Rect& rect_)
-  : Widget(rect_),
-    state(UP),
-    hover(false)
-{
-  up_surface    = IMG_Load("data/icons/up.png");
-  down_surface  = IMG_Load("data/icons/down.png");
-  hover_surface = IMG_Load("data/icons/hover.png");
-}
-
-Button::~Button()
-{
-  
-}
-
-void
-Button::on_enter()
-{
-  hover = true;
-  set_dirty(true);
-}
-
-void
-Button::on_leave()
-{
-  hover = false;
-  set_dirty(true);
-}
-
-void
-Button::on_mouse_motion(const MouseMotionEvent& motion)
-{
-  // std::cout << "Motion: " << motion.x << " " << motion.y << std::endl;
-  // FIXME: borked
-}
-
-void
-Button::on_mouse_button(const MouseButtonEvent& button)
-{
-  if (button.button == 1 && button.state == SDL_PRESSED)
-    {
-      state = DOWN;
-      set_dirty(true);
-      widget_manager->grab(this);
-    }
-  else if (button.button == 1 && button.state == SDL_RELEASED)
-    {
-      state = UP;
-      widget_manager->ungrab(this);
-      set_dirty(true);
-    }
-}
-
-void
-Button::draw(SDL_Surface* target)
-{
-  //Uint32 color = SDL_MapRGB(target->format, 255, 0, 0);
-
-  SDL_Rect r;
-
-  r.x = get_rect().left;
-  r.y = get_rect().top;
-
-  r.w = get_rect().get_width();
-  r.h = get_rect().get_height();
-
-  switch(state)
-    {
-    case UP:
-      if (hover)
-        SDL_BlitSurface(hover_surface, NULL, target, &r);
-      else
-        SDL_BlitSurface(up_surface, NULL, target, &r);
-      break;
-
-    case DOWN:
-      SDL_BlitSurface(down_surface, NULL, target, &r);
-      break;
-    }
-
-  //SDL_FillRect(target, get_rect(), color);
-}
-
-/* EOF */

Copied: trunk/netbrush/src/widget/button.cpp (from rev 662, trunk/netbrush/widget/button.cpp)

Deleted: trunk/netbrush/src/widget/button.hpp
===================================================================
--- trunk/netbrush/widget/button.hpp	2006-10-18 21:14:26 UTC (rev 647)
+++ trunk/netbrush/src/widget/button.hpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,62 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#ifndef HEADER_BUTTON_HPP
-#define HEADER_BUTTON_HPP
-
-#include "widget.hpp"
-
-/** */
-class Button : public Widget
-{
-private:
-  enum State { UP, DOWN };
-  State state;
-  bool  hover;
-
-  SDL_Surface* up_surface;
-  SDL_Surface* down_surface;
-  SDL_Surface* hover_surface;
-
-public:
-  Button(const Rect& rect);
-  ~Button();
-
-  void on_mouse_motion(const MouseMotionEvent& motion);
-  void on_mouse_button(const MouseButtonEvent& button);
-
-  void on_enter();
-  void on_leave();
-
-  void draw(SDL_Surface* target);
-  
-private:
-  Button (const Button&);
-  Button& operator= (const Button&);
-};
-
-#endif
-
-/* EOF */

Copied: trunk/netbrush/src/widget/button.hpp (from rev 662, trunk/netbrush/widget/button.hpp)

Deleted: trunk/netbrush/src/widget/callback.hpp
===================================================================
--- trunk/netbrush/widget/callback.hpp	2006-10-18 21:14:26 UTC (rev 647)
+++ trunk/netbrush/src/widget/callback.hpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,44 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#ifndef HEADER_CALLBACK_HPP
-#define HEADER_CALLBACK_HPP
-
-/** */
-class Callback
-{
-public:
-  Callback() {}
-  virtual ~Callback() {}
-  virtual void operator()(float) =0;
-
-private:
-  Callback (const Callback&);
-  Callback& operator= (const Callback&);
-};
-
-#endif
-
-/* EOF */

Copied: trunk/netbrush/src/widget/scrollbar.cpp (from rev 662, trunk/netbrush/widget/scrollbar.cpp)

Copied: trunk/netbrush/src/widget/scrollbar.hpp (from rev 662, trunk/netbrush/widget/scrollbar.hpp)

Deleted: trunk/netbrush/src/widget/slider_widget.cpp
===================================================================
--- trunk/netbrush/widget/slider_widget.cpp	2006-10-18 21:14:26 UTC (rev 647)
+++ trunk/netbrush/src/widget/slider_widget.cpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,116 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#include <algorithm>
-#include "globals.hpp"
-#include "widget_manager.hpp"
-#include "slider_widget.hpp"
-
-SliderWidget::SliderWidget(const Rect& rect_, Callback* callback_)
-  : Widget(rect_), callback(callback_), pos(0.5f), dragging(false)
-{
-}
-
-SliderWidget::~SliderWidget()
-{
-  delete callback;
-}
-
-void
-SliderWidget::on_mouse_motion(const MouseMotionEvent& motion)
-{
-  set_dirty(true);
-  if (dragging)
-    {
-      pos = float(motion.x) / get_rect().get_width();
-      pos = std::max(0.0f, std::min(pos, 1.0f));
-      (*callback)(pos);
-    }
-
-}
-
-void
-SliderWidget::on_mouse_button(const MouseButtonEvent& button)
-{
-  if (button.button == 1)
-    {
-      if (button.state == SDL_RELEASED)
-        {
-          dragging = false;
-          widget_manager->ungrab(this);
-        }
-      else if (button.state == SDL_PRESSED)
-        {
-          dragging = true;
-
-          pos = float(button.x) / get_rect().get_width();
-          pos = std::max(0.0f, std::min(pos, 1.0f));
-
-          (*callback)(pos);
-
-          set_dirty(true);
-          widget_manager->grab(this);
-        }
-    }
-}
-
-void
-SliderWidget::on_enter()
-{
-}
-
-void
-SliderWidget::on_leave()
-{
-}
-
-void
-SliderWidget::draw(SDL_Surface* target)
-{
-  SDL_Rect rect;
-  rect.x = get_rect().left;
-  rect.y = get_rect().top;
-  rect.w = get_rect().get_width();
-  rect.h = get_rect().get_height();
-
-  SDL_FillRect(target, &rect, SDL_MapRGB(target->format, 200, 200, 200));
-
-  rect.x += 2;
-  rect.y += 10;
-  rect.w -= 4;
-  rect.h -= 20;
-
-  SDL_FillRect(target, &rect, SDL_MapRGB(target->format, 100, 100, 100));
-
-  SDL_Rect slider;
-  slider.x = int(get_rect().get_width() * pos) + get_rect().left - 4;
-  slider.y = 2 + get_rect().top;
-  slider.w = 8;
-  slider.h = get_rect().get_height() - 4;
-
-  SDL_FillRect(target, &slider, SDL_MapRGB(target->format, 0, 0, 0));
-}
-
-/* EOF */

Copied: trunk/netbrush/src/widget/slider_widget.cpp (from rev 662, trunk/netbrush/widget/slider_widget.cpp)

Deleted: trunk/netbrush/src/widget/slider_widget.hpp
===================================================================
--- trunk/netbrush/widget/slider_widget.hpp	2006-10-18 21:14:26 UTC (rev 647)
+++ trunk/netbrush/src/widget/slider_widget.hpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,59 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#ifndef HEADER_SLIDER_WIDGET_HPP
-#define HEADER_SLIDER_WIDGET_HPP
-
-#include "callback.hpp"
-#include "widget.hpp"
-
-/** */
-class SliderWidget : public Widget
-{
-private:
-  Callback* callback;
-  float pos;
-  bool  dragging;
-  
-public:
-  SliderWidget(const Rect& rect_, Callback* callback);
-  ~SliderWidget();
-
-  void on_mouse_motion(const MouseMotionEvent& motion);
-  void on_mouse_button(const MouseButtonEvent& button);
-
-  void on_enter();
-  void on_leave();
-
-  void draw(SDL_Surface* target);
-
-private:
-  SliderWidget (const SliderWidget&);
-  SliderWidget& operator= (const SliderWidget&);
-};
-
-#endif
-
-/* EOF */

Copied: trunk/netbrush/src/widget/slider_widget.hpp (from rev 662, trunk/netbrush/widget/slider_widget.hpp)

Deleted: trunk/netbrush/src/widget/widget.cpp
===================================================================
--- trunk/netbrush/widget/widget.cpp	2006-10-18 21:14:26 UTC (rev 647)
+++ trunk/netbrush/src/widget/widget.cpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,39 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#include "widget.hpp"
-
-Widget::Widget(const Rect& rect_)
-  : rect(rect_.left+1, rect_.top+1, rect_.right-1, rect_.bottom-1),  // FIXME: Cheap way to add border
-    dirty(false) 
-{
-}
-
-Widget::~Widget()
-{
-}
-
-
-/* EOF */

Copied: trunk/netbrush/src/widget/widget.cpp (from rev 662, trunk/netbrush/widget/widget.cpp)

Deleted: trunk/netbrush/src/widget/widget_manager.cpp
===================================================================
--- trunk/netbrush/widget/widget_manager.cpp	2006-10-18 21:14:26 UTC (rev 647)
+++ trunk/netbrush/src/widget/widget_manager.cpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,177 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#include <assert.h>
-#include <iostream>
-#include "../video.hpp"
-#include "widget.hpp"
-#include "events.hpp"
-#include "widget_manager.hpp"
-
-WidgetManager::WidgetManager()
-  : grabbed_widget(0), focused_widget(0)
-{
-  
-}
-
-WidgetManager::~WidgetManager()
-{
-  for(Widgets::iterator i = widgets.begin(); i != widgets.end(); ++i)
-    {
-      delete *i;
-    }
-}
-
-void
-WidgetManager::add(Widget* widget)
-{
-  widget->set_dirty(true);
-  widgets.push_back(widget);
-}
-
-void
-WidgetManager::on_mouse_motion(const MouseMotionEvent& motion)
-{
-  if (grabbed_widget)
-    {
-      MouseMotionEvent trans_motion(motion);
-
-      trans_motion.x -= grabbed_widget->get_rect().left;
-      trans_motion.y -= grabbed_widget->get_rect().top;
-
-      grabbed_widget->on_mouse_motion(trans_motion);
-    }
-  else
-    {
-      Widget* old_focused_widget = focused_widget;
-      
-      focused_widget = 0;
-
-      for(Widgets::iterator i = widgets.begin(); i != widgets.end(); ++i)
-        {
-          if ((*i)->get_rect().is_inside(Point(motion.x, motion.y)))
-            {
-              MouseMotionEvent trans_motion(motion);
-
-              trans_motion.x -= (*i)->get_rect().left;
-              trans_motion.y -= (*i)->get_rect().top;
-
-              if (!grabbed_widget)
-                focused_widget = (*i);
-              
-              (*i)->on_mouse_motion(trans_motion);
-              break;
-            }
-        }
-
-      if (!grabbed_widget)
-        {
-          if (old_focused_widget != focused_widget)
-            {
-              if (old_focused_widget)
-                old_focused_widget->on_leave();
-         
-              if (focused_widget)
-                focused_widget->on_enter();
-            }
-        }
-      else
-        {
-          focused_widget = grabbed_widget;
-        }
-    }
-}
-
-void
-WidgetManager::on_mouse_button(const MouseButtonEvent& button)
-{
-  if (grabbed_widget)
-    {
-      MouseButtonEvent trans_button(button);
-
-      trans_button.x -= grabbed_widget->get_rect().left;
-      trans_button.y -= grabbed_widget->get_rect().top;
-
-      grabbed_widget->on_mouse_button(trans_button);
-    }
-  else
-    {
-      for(Widgets::iterator i = widgets.begin(); i != widgets.end(); ++i)
-        {
-          if ((*i)->get_rect().is_inside(Point(button.x, button.y)))
-            {
-              MouseButtonEvent trans_button(button);
-              trans_button.x -= (*i)->get_rect().left;
-              trans_button.y -= (*i)->get_rect().top;
-
-              (*i)->on_mouse_button(trans_button);
-              break;
-            }
-        }  
-    }
-}
-
-void
-WidgetManager::update()
-{
-  for(Widgets::reverse_iterator i = widgets.rbegin(); i != widgets.rend(); ++i)
-    {
-      if ((*i)->is_dirty())
-        {
-          (*i)->draw(screen);
-
-          // FIXME: might conflict with Screenbuffers update procedure
-          if ((*i)->do_update())
-            {
-              if (0)
-                std::cout << "\nWidgetManager: update: "
-                          << (*i)->get_rect().left << " " << (*i)->get_rect().top << " "
-                          << (*i)->get_rect().get_width() << " " << (*i)->get_rect().get_height() << std::endl;
-
-              SDL_UpdateRect(screen, 
-                             (*i)->get_rect().left,        (*i)->get_rect().top,
-                             (*i)->get_rect().get_width(), (*i)->get_rect().get_height());
-            }
-
-          (*i)->set_dirty(false);
-        }
-    }  
-}
-
-void
-WidgetManager::grab(Widget* widget)
-{
-  assert(grabbed_widget == 0);
-  grabbed_widget = widget;
-}
-
-void
-WidgetManager::ungrab(Widget* widget)
-{
-  //assert(grabbed_widget == widget);
-  grabbed_widget = 0;
-}
-
-/* EOF */

Copied: trunk/netbrush/src/widget/widget_manager.cpp (from rev 662, trunk/netbrush/widget/widget_manager.cpp)

Deleted: trunk/netbrush/stroke.cpp
===================================================================
--- trunk/netbrush/stroke.cpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/stroke.cpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,126 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#include <math.h>
-#include "stroke.hpp"
-
-Stroke::Stroke()
-{
-  
-}
-
-Stroke::~Stroke()
-{
-  
-}
-
-Stroke::Dabs
-Stroke::get_interpolated_dabs(float x_spacing, float y_spacing) const
-{
-  if (dabs.size() > 0)
-    {
-      Dabs interpolated_dabs;
-
-      interpolated_dabs.push_back(dabs.front());
-
-      // The following code basically takes all the event dabs as recieved
-      // by from the InputDevice and interpolates new dabs inbetween to
-      // give them an equal spacing (ie. every dab is only 'spacing' away
-      // from the next)
-      float overspace = 0.0f;
-      for(unsigned int j = 0; j < dabs.size()-1; ++j)
-        {
-          Vector dist = dabs[j+1].pos - dabs[j].pos;
-          float length = sqrt(dist.x * dist.x + dist.y * dist.y);
-          int n = 1;
-    
-          // Spacing is keep relative to the brush size
-          // FIXME: This is specific to a Sprite based drawer, might not work for others
-          // FIXME: y_spacing isn't taken into account either
-          float local_spacing = x_spacing * dabs[j].pressure;
-
-          while (length + overspace > (local_spacing * n))
-            {
-              float factor = (local_spacing/length) * n - (overspace/length);
-          
-              // FIXME: Interpolate tilting, pressure, etc. along the line
-              interpolated_dabs.push_back(Dab(dabs[j].pos.x + dist.x * factor,
-                                              dabs[j].pos.y + dist.y * factor,
-                                              dabs[j].pressure));
-              n += 1;
-            }
-
-          // calculate the space that wasn't used in the last iteration
-          overspace = (length + overspace) - (local_spacing * (n-1));
-        }
-      return interpolated_dabs;
-    }
-  else
-    {
-      // No dabs available, so nothing to interpolate
-      return dabs;
-    }
-}
-
-const Stroke::Dabs&
-Stroke::get_dabs() const
-{
-  return dabs; 
-}
-
-int
-Stroke::get_dab_count() const
-{
-  return dabs.size();
-}
-
-void
-Stroke::add_dab(const Dab& dab)
-{
-  if(dabs.empty())
-    {
-      bounding_rect = Rect(Point(static_cast<int>(dab.pos.x),
-                                 static_cast<int>(dab.pos.y)),
-                           Size(1, 1));
-    }
-  else
-    {
-      bounding_rect.left    = std::min(bounding_rect.left,   static_cast<int>(dab.pos.x));
-      bounding_rect.top     = std::min(bounding_rect.top,    static_cast<int>(dab.pos.y));
-
-      bounding_rect.right   = std::max(bounding_rect.right,  static_cast<int>(dab.pos.x));
-      bounding_rect.bottom  = std::max(bounding_rect.bottom, static_cast<int>(dab.pos.y));
-    }
-
-  dabs.push_back(dab);
-}
-
-const Rect&
-Stroke::get_bounding_rect() const
-{
-  return bounding_rect; 
-}
-
-/* EOF */

Deleted: trunk/netbrush/stroke.hpp
===================================================================
--- trunk/netbrush/stroke.hpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/stroke.hpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,104 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#ifndef HEADER_STROKE_HPP
-#define HEADER_STROKE_HPP
-
-#include "SDL.h"
-#include <vector>
-#include "math/vector.hpp"
-#include "math/rect.hpp"
-
-/** A dab is basically an event send from the mouse to the drawing
-    canvas, it consists of time, position, tilt, pressure and possible
-    additional information that is needed */
-class Dab
-{
-public:
-  /** Time at which the dot was placed */
-  unsigned int time;
-
-  /** Position at which the dot is placed */
-  Vector pos;
-
-  /** The pressure with which the dot was drawn (can be interpreted as
-      size, opacity or similar things by the StrokeDrawer */
-  float pressure;
-
-  /** Tilting of the pen while painting the dot */
-  Vector tilt;
-
-  Dab()
-    : time(SDL_GetTicks()), pos(0, 0), pressure(1.0f), tilt(0, 0)
-  {}
-
-  Dab(float x, float y) 
-    : time(SDL_GetTicks()), pos(x, y), pressure(1.0f), tilt(0.0f, 0.0f)
-  {}
-
-  Dab(float x_, float y_, float pressure_)
-    : time(SDL_GetTicks()), pos(x_, y_), pressure(pressure_), tilt(0.0f, 0.0f)
-  {}
-};
-
-/** */
-class Stroke
-{
-public:
-  typedef std::vector<Dab> Dabs;
-
-private:
-  Stroke::Dabs dabs;
-  Rect bounding_rect;
-
-public:
-  Stroke();
-  ~Stroke();
-
-  /** Return true if the Stroke doesn't contain any dabs */
-  bool empty() const { return dabs.empty(); }
-
-  void  add_dab(const Dab& dab);
-  
-  /** Returns the real dabs as recieved by the InputDevice */
-  const Dabs&  get_dabs()  const;
-
-  /** Returns interpolated dabs, meaning the holes in get_dabs() are
-      closed with interpolated dabs so that all dabs are equally
-      spread (ie. every dab is 'spacing' away from the next) */
-  Dabs  get_interpolated_dabs(float x_spacing, float y_spacing) const;
-
-  int get_dab_count() const;
-
-  const Rect& get_bounding_rect() const;
-
-private:
-  Stroke (const Stroke&);
-  Stroke& operator= (const Stroke&);
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/netbrush/stroke_buffer.cpp
===================================================================
--- trunk/netbrush/stroke_buffer.cpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/stroke_buffer.cpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,170 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#include <iostream>
-#include "math/rect.hpp"
-#include "grayscale_buffer.hpp"
-#include "stroke.hpp"
-#include "video.hpp"
-#include "drawing_parameter.hpp"
-#include "stroke_buffer.hpp"
-
-StrokeBuffer::StrokeBuffer(int w, int h)
-  : param(0)
-{
-  buffer = new GrayscaleBuffer(w, h, 0);
-  stroke = new Stroke();
-}
-
-StrokeBuffer::~StrokeBuffer()
-{
-  delete stroke;
-  delete buffer;
-}
-
-void
-StrokeBuffer::clear(const Rect& rect)
-{
-  buffer->fill_rect(rect, 0);  
-}
-
-void
-StrokeBuffer::clear()
-{
-  buffer->clear(0);
-
-  // FIXME: This doesn't belong here
-  delete this->stroke;
-  this->stroke = new Stroke();
-}
-
-void
-StrokeBuffer::add_dab(const Dab& dab)
-{
-  //  for(int y = - 5; y < 10; ++y)
-  //for(int x = - 5; x < 10; ++x)
-  //buffer->at(int(dab.pos.x)+x, int(dab.pos.y)+y) = 128;
-
-  GrayscaleBuffer* brush = param->get_brush_buffer();
-
-  stroke->add_dab(dab);
-  if (1)
-    {
-      buffer->blit(brush,
-                   static_cast<int>(dab.pos.x - brush->get_width()/2), 
-                   static_cast<int>(dab.pos.y - brush->get_height()/2), 
-                   GrayscaleBuffer::ALPHA);
-    }
-  else
-    { // FIXME: SLOW!
-      buffer->clear(0);
-      draw_stroke(*stroke, param);
-    }
-}
-
-void
-StrokeBuffer::draw_stroke(const Stroke& stroke, DrawingParameter* param)
-{
-  GrayscaleBuffer* brush = param->get_brush_buffer();
-
-  if (param->tool == DrawingParameter::TOOL_AIRBRUSH)
-    {
-      Stroke::Dabs dabs = stroke.get_dabs();
-      for(Stroke::Dabs::iterator i = dabs.begin(); i != dabs.end(); ++i)
-        {
-          buffer->blit(brush,
-                       static_cast<int>(i->pos.x - brush->get_width()/2), 
-                       static_cast<int>(i->pos.y - brush->get_height()/2), 
-                       GrayscaleBuffer::ALPHA);
-        }
-    }
-  else if (param->tool == DrawingParameter::TOOL_PAINTBRUSH)
-    {
-      Stroke::Dabs dabs = stroke.get_interpolated_dabs(param->get_spacing(), param->get_spacing());
-      for(Stroke::Dabs::iterator i = dabs.begin(); i != dabs.end(); ++i)
-        {
-          buffer->blit(brush,
-                       static_cast<int>(i->pos.x - brush->get_width()/2), 
-                       static_cast<int>(i->pos.y - brush->get_height()/2), 
-                       GrayscaleBuffer::ALPHA);
-        }      
-    }
-}
-
-  void
-    StrokeBuffer::draw(SDL_Surface* target, const Rect& rect, int x_of, int y_of)
-  { 
-    // rect is in screenspace, x_of, y_of tell how to go from canvas to screenspace
-    SDL_LockSurface(target);
-
-    Uint8* dst = static_cast<Uint8*>(target->pixels);
-    Uint8* src = buffer->get_data();
-  
-    assert(rect.left >= 0);
-    if (0)
-      std::cout << "StrokeBuffer::draw: " << target << " " << rect.left << " " << rect.top << " "
-                << rect.right << " " << rect.bottom << " - " << x_of << " " << y_of << std::endl;
-
-    if (target == screen) // FIXME: Ugly workaround
-      {
-        for(int y = rect.top; y < rect.bottom; ++y)
-          for(int x = rect.left; x < rect.right; ++x)
-            {
-              Uint8* d = dst + (y * target->pitch + target->format->BytesPerPixel * x);
-              Uint8  s = src[(y - y_of) * buffer->get_width() + (x - x_of)];
-
-              s = (s * param->opacity)/255;
-
-              d[0] = ((255 - s) * d[0] + (s * param->color.b))/255;
-              d[1] = ((255 - s) * d[1] + (s * param->color.g))/255;
-              d[2] = ((255 - s) * d[2] + (s * param->color.r))/255;
-            }
-      }
-    else
-      {
-        for(int y = rect.top; y < rect.bottom; ++y)
-          for(int x = rect.left; x < rect.right; ++x)
-            {
-              Uint8* d = dst + (y * target->pitch + target->format->BytesPerPixel * x);
-              Uint8  s = src[(y - y_of) * buffer->get_width() + (x - x_of)];
-
-              s = (s * param->opacity)/255;
-
-              d[0] = ((255 - s) * d[0] + (s * param->color.r))/255;
-              d[1] = ((255 - s) * d[1] + (s * param->color.g))/255;
-              d[2] = ((255 - s) * d[2] + (s * param->color.b))/255;
-            }
-      }
-
-    SDL_UnlockSurface(target);
-  }
-
-  void
-    StrokeBuffer::set_param(DrawingParameter* param_)
-  {
-    param = param_;
-  }
-
-  /* EOF */

Deleted: trunk/netbrush/stroke_buffer.hpp
===================================================================
--- trunk/netbrush/stroke_buffer.hpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/stroke_buffer.hpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,62 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#ifndef HEADER_STROKE_BUFFER_HPP
-#define HEADER_STROKE_BUFFER_HPP
-
-class Rect;
-class DrawingParameter;
-class Dab;
-
-/** */
-class StrokeBuffer
-{
-private:
-  GrayscaleBuffer*  buffer;
-  Stroke*           stroke;
-  DrawingParameter* param;
-
-public:
-  StrokeBuffer(int w, int h);
-  ~StrokeBuffer();
-
-  void set_param(DrawingParameter* param);
-
-  void add_dab(const Dab& dab);
-  void clear();
-  void clear(const Rect& rect);
-
-  void draw(SDL_Surface* target, const Rect& rect, int x_of, int y_of);
-
-  void draw_stroke(const Stroke& stroke, DrawingParameter* param);
-
-private:
-  StrokeBuffer (const StrokeBuffer&);
-  StrokeBuffer& operator= (const StrokeBuffer&);
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/netbrush/video.cpp
===================================================================
--- trunk/netbrush/video.cpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/video.cpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,83 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#include <algorithm>
-#include "math/rect.hpp"
-#include "video.hpp"
-
-SDL_Surface* screen = 0;
-
-void clip_to(SDL_Rect* rect, SDL_Rect* clip_rect)
-{
-  int x1 = std::max(clip_rect->x, rect->x);
-  int y1 = std::max(clip_rect->y, rect->y);
-
-  int x2 = std::min(clip_rect->x + clip_rect->w, rect->x + rect->w);
-  int y2 = std::min(clip_rect->y + clip_rect->h, rect->y + rect->h);  
-
-  rect->x = x1;
-  rect->y = y1;
-
-  rect->w = x2 - x1;
-  rect->h = y2 - y1;
-}
-
-void clip_to(Rect& rect, const Rect& clip_rect)
-{
-  rect.left   = std::max(rect.left,   clip_rect.left);
-  rect.right  = std::min(rect.right,  clip_rect.right);
-  rect.top    = std::max(rect.top,    clip_rect.top);
-  rect.bottom = std::min(rect.bottom, clip_rect.bottom);
-}
-
-SDL_Surface* create_surface(int w, int h)
-{
-  Uint32 rmask, gmask, bmask, amask;
-
-  /* SDL interprets each pixel as a 32-bit number, so our masks must depend
-     on the endianness (byte order) of the machine */
-#if SDL_BYTEORDER == SDL_BIG_ENDIAN
-  rmask = 0xff000000;
-  gmask = 0x00ff0000;
-  bmask = 0x0000ff00;
-  amask = 0; //0x000000ff;
-#else
-  rmask = 0x000000ff;
-  gmask = 0x0000ff00;
-  bmask = 0x00ff0000;
-  amask = 0; //0xff000000;
-#endif
-
-  SDL_Surface* drawable = SDL_CreateRGBSurface(SDL_SWSURFACE, w, h, 24,
-                                  rmask, gmask, bmask, amask);
-  if(drawable == NULL) {
-    fprintf(stderr, "CreateRGBSurface failed: %s\n", SDL_GetError());
-    exit(1);
-  }
-
-  return drawable;
-}
-
-/* EOF */

Deleted: trunk/netbrush/video.hpp
===================================================================
--- trunk/netbrush/video.hpp	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/video.hpp	2006-10-20 08:32:24 UTC (rev 663)
@@ -1,41 +0,0 @@
-/*  $Id$
-**   __      __ __             ___        __   __ __   __
-**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
-**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
-**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
-**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
-**         \/          \/      \/    \/                         \/
-**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  as published by the Free Software Foundation; either version 2
-**  of the License, or (at your option) any later version.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-** 
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-**  02111-1307, USA.
-*/
-
-#ifndef HEADER_VIDEO_HPP
-#define HEADER_VIDEO_HPP
-
-#include "SDL.h"
-
-extern SDL_Surface* screen;
-
-class Rect;
-
-void clip_to(SDL_Rect* rect, SDL_Rect* clip_rect);
-void clip_to(Rect& rect, const Rect& clip_rect);
-SDL_Surface* create_surface(int w, int h);
-
-#endif
-
-/* EOF */



From grumbel at mail.berlios.de  Fri Oct 20 11:57:22 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Fri, 20 Oct 2006 11:57:22 +0200
Subject: [Flexlay-commit] r664 - in trunk/netbrush: . src
Message-ID: <200610200957.k9K9vMjR020733@sheep.berlios.de>

Author: grumbel
Date: 2006-10-20 11:57:21 +0200 (Fri, 20 Oct 2006)
New Revision: 664

Added:
   trunk/netbrush/SConstruct
   trunk/netbrush/src/Makefile
Removed:
   trunk/netbrush/Makefile
   trunk/netbrush/brush_14x14.png
   trunk/netbrush/brush_2x2.png
   trunk/netbrush/brush_3x3.png
   trunk/netbrush/brush_white_14x14.png
   trunk/netbrush/brush_white_2x2.png
   trunk/netbrush/brush_white_3x3.png
   trunk/netbrush/src/SConstruct
Modified:
   trunk/netbrush/src/client.cpp
   trunk/netbrush/src/drawing_parameter.cpp
   trunk/netbrush/src/screen_buffer.cpp
Log:
- added checkboard pattern background
- removed obsolete pixel brushes

Deleted: trunk/netbrush/Makefile
===================================================================
--- trunk/netbrush/Makefile	2006-10-20 08:32:24 UTC (rev 663)
+++ trunk/netbrush/Makefile	2006-10-20 09:57:21 UTC (rev 664)
@@ -1,4 +0,0 @@
-all:
-	scons
-
-# EOF #

Copied: trunk/netbrush/SConstruct (from rev 663, trunk/netbrush/src/SConstruct)
===================================================================
--- trunk/netbrush/src/SConstruct	2006-10-20 08:32:24 UTC (rev 663)
+++ trunk/netbrush/SConstruct	2006-10-20 09:57:21 UTC (rev 664)
@@ -0,0 +1,56 @@
+# netbrush_env = Environment()
+# netbrush_env.ParseConfig('sdl-config --cflags --libs')
+# netbrush_env['LIBS'] += ['SDL_net']
+# netbrush_env['CXXFLAGS'] += ['-O2', '-Wall', '-g']
+# netbrush_env.Program('netbrush', ['net.cpp', 'vector.cpp'])
+
+server_env = Environment()
+server_env.ParseConfig('sdl-config --cflags --libs')
+server_env['CXXFLAGS'] += ['-O0', '-Wall', '-g']
+server_env['LIBS'] += ['SDL_net']
+server_env.Program('server', [
+        'src/server.cpp'
+])
+
+
+client_env = Environment()
+client_env.ParseConfig('sdl-config --cflags --libs')
+client_env['CXXFLAGS'] += ['-O0', '-Wall', '-g']
+client_env['CPPPATH'] += ['src/']
+client_env['LIBS'] += ['SDL_image', 'SDL_net']
+client_env.Program('client', [
+        'src/alpha_picker.cpp',
+        'src/brush_widget.cpp',
+        'src/brushmask.cpp',
+        'src/client.cpp', 
+        'src/client_state.cpp',
+        'src/debug.cpp',
+        'src/drawing_context.cpp',
+        'src/drawing_parameter.cpp',
+        'src/generic_brush.cpp',
+        'src/globals.cpp',
+        'src/grayscale_buffer.cpp', 
+        'src/hue_picker.cpp',
+        'src/math/matrix.cpp',
+        'src/math/origin.cpp',
+        'src/math/quaternion.cpp',
+        'src/math/rect.cpp',
+        'src/math/vector.cpp',
+        'src/saturation_value_picker.cpp',
+        'src/screen_buffer.cpp',
+        'src/server_connection.cpp',
+        'src/stroke.cpp',
+        'src/stroke_buffer.cpp',
+        'src/video.cpp',
+        'src/widget/button.cpp',
+        'src/widget/scrollbar.cpp',
+        'src/widget/slider_widget.cpp',
+        'src/widget/widget.cpp',
+        'src/widget/widget_manager.cpp',
+        'src/navigation.cpp',
+        'src/graphic_context_state.cpp',
+#        'src/widget/events.cpp',
+])
+
+# EOF #
+

Deleted: trunk/netbrush/brush_14x14.png
===================================================================
(Binary files differ)

Deleted: trunk/netbrush/brush_2x2.png
===================================================================
(Binary files differ)

Deleted: trunk/netbrush/brush_3x3.png
===================================================================
(Binary files differ)

Deleted: trunk/netbrush/brush_white_14x14.png
===================================================================
(Binary files differ)

Deleted: trunk/netbrush/brush_white_2x2.png
===================================================================
(Binary files differ)

Deleted: trunk/netbrush/brush_white_3x3.png
===================================================================
(Binary files differ)

Copied: trunk/netbrush/src/Makefile (from rev 662, trunk/netbrush/Makefile)
===================================================================
--- trunk/netbrush/Makefile	2006-10-20 08:29:30 UTC (rev 662)
+++ trunk/netbrush/src/Makefile	2006-10-20 09:57:21 UTC (rev 664)
@@ -0,0 +1,4 @@
+all:
+	scons -D
+
+# EOF #

Deleted: trunk/netbrush/src/SConstruct
===================================================================
--- trunk/netbrush/src/SConstruct	2006-10-20 08:32:24 UTC (rev 663)
+++ trunk/netbrush/src/SConstruct	2006-10-20 09:57:21 UTC (rev 664)
@@ -1,56 +0,0 @@
-# netbrush_env = Environment()
-# netbrush_env.ParseConfig('sdl-config --cflags --libs')
-# netbrush_env['LIBS'] += ['SDL_net']
-# netbrush_env['CXXFLAGS'] += ['-O2', '-Wall', '-g']
-# netbrush_env.Program('netbrush', ['net.cpp', 'vector.cpp'])
-
-server_env = Environment()
-server_env.ParseConfig('sdl-config --cflags --libs')
-server_env['CXXFLAGS'] += ['-O0', '-Wall', '-g']
-server_env['LIBS'] += ['SDL_net']
-server_env.Program('server', [
-        'server.cpp'
-])
-
-
-client_env = Environment()
-client_env.ParseConfig('sdl-config --cflags --libs')
-client_env['CXXFLAGS'] += ['-O0', '-Wall', '-g']
-client_env['CPPPATH'] += ['.']
-client_env['LIBS'] += ['SDL_image', 'SDL_net']
-client_env.Program('client', [
-        'alpha_picker.cpp',
-        'brush_widget.cpp',
-        'brushmask.cpp',
-        'client.cpp', 
-        'client_state.cpp',
-        'debug.cpp',
-        'drawing_context.cpp',
-        'drawing_parameter.cpp',
-        'generic_brush.cpp',
-        'globals.cpp',
-        'grayscale_buffer.cpp', 
-        'hue_picker.cpp',
-        'math/matrix.cpp',
-        'math/origin.cpp',
-        'math/quaternion.cpp',
-        'math/rect.cpp',
-        'math/vector.cpp',
-        'saturation_value_picker.cpp',
-        'screen_buffer.cpp',
-        'server_connection.cpp',
-        'stroke.cpp',
-        'stroke_buffer.cpp',
-        'video.cpp',
-        'widget/button.cpp',
-        'widget/scrollbar.cpp',
-        'widget/slider_widget.cpp',
-        'widget/widget.cpp',
-        'widget/widget_manager.cpp',
-        'navigation.cpp',
-        'graphic_context_state.cpp',
-#        'widget/events.cpp',
-])
-
-# EOF #
-

Modified: trunk/netbrush/src/client.cpp
===================================================================
--- trunk/netbrush/src/client.cpp	2006-10-20 08:32:24 UTC (rev 663)
+++ trunk/netbrush/src/client.cpp	2006-10-20 09:57:21 UTC (rev 664)
@@ -50,32 +50,8 @@
           break;
 
         case SDL_KEYDOWN:
-          if (event.key.keysym.sym == SDLK_1)
+          if (event.key.keysym.sym == SDLK_k)
             {
-              client_draw_param->set_brush("brush_2x2.png");
-            }
-          else if (event.key.keysym.sym == SDLK_2)
-            {
-              client_draw_param->set_brush("brush_white_2x2.png");
-            }
-          else if (event.key.keysym.sym == SDLK_3)
-            {
-              client_draw_param->set_brush("brush_3x3.png");
-            }
-          else if (event.key.keysym.sym == SDLK_4)
-            {
-              client_draw_param->set_brush("brush_white_3x3.png");
-            }
-          else if (event.key.keysym.sym == SDLK_5)
-            {
-              client_draw_param->set_brush("brush_14x14.png");
-            }
-          else if (event.key.keysym.sym == SDLK_6)
-            {
-              client_draw_param->set_brush("brush_white_14x14.png");
-            }
-          else if (event.key.keysym.sym == SDLK_k)
-            {
               std::cout << "Forced screen clear and update" << std::endl;
               SDL_FillRect(screen, NULL, SDL_MapRGB(screen->format, 255, 0, 255));
               SDL_UpdateRect(screen, 0, 0, 0, 0);

Modified: trunk/netbrush/src/drawing_parameter.cpp
===================================================================
--- trunk/netbrush/src/drawing_parameter.cpp	2006-10-20 08:32:24 UTC (rev 663)
+++ trunk/netbrush/src/drawing_parameter.cpp	2006-10-20 09:57:21 UTC (rev 664)
@@ -34,7 +34,7 @@
     opacity(128),
     spacing(1.0f)
 {
-  set_brush("brush_3x3.png");
+  brush_buffer = generic_brush.generate();
 }
 
 void

Modified: trunk/netbrush/src/screen_buffer.cpp
===================================================================
--- trunk/netbrush/src/screen_buffer.cpp	2006-10-20 08:32:24 UTC (rev 663)
+++ trunk/netbrush/src/screen_buffer.cpp	2006-10-20 09:57:21 UTC (rev 664)
@@ -89,12 +89,24 @@
 
   if (complete_refresh)
     { 
-      SDL_Rect r;
-      r.x = get_rect().left;
-      r.y = get_rect().top;
-      r.w = get_rect().get_width();
-      r.h = get_rect().get_height();
-      SDL_FillRect(target, &r, SDL_MapRGB(target->format, 0, 0, 0));
+      Uint32 black = SDL_MapRGB(target->format, 200, 200, 200);
+      Uint32 white = SDL_MapRGB(target->format, 100, 100, 100);
+
+      SDL_Rect r;     
+      for(int y = get_rect().top; y < get_rect().bottom; y += 32)
+        for(int x = get_rect().left; x < get_rect().right; x += 32)
+          {
+            r.x = x;
+            r.y = y;
+            
+            r.w = 32;
+            r.h = 32;
+            
+            if (((x / 32) % 2) ^ ((y / 32) % 2))
+              SDL_FillRect(target, &r, black);
+            else
+              SDL_FillRect(target, &r, white);
+          }
     }
 
   // check for invalid dirty_regions (ie. canvas is completly outside of the view)



From grumbel at mail.berlios.de  Fri Oct 20 14:35:26 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Fri, 20 Oct 2006 14:35:26 +0200
Subject: [Flexlay-commit] r665 - in trunk/netbrush: . src
Message-ID: <200610201235.k9KCZQRY004695@sheep.berlios.de>

Author: grumbel
Date: 2006-10-20 14:35:24 +0200 (Fri, 20 Oct 2006)
New Revision: 665

Added:
   trunk/netbrush/src/command_line.cpp
   trunk/netbrush/src/command_line.hpp
   trunk/netbrush/src/command_line_generic.cpp
   trunk/netbrush/src/command_line_generic.hpp
Modified:
   trunk/netbrush/SConstruct
   trunk/netbrush/src/client.cpp
   trunk/netbrush/src/screen_buffer.cpp
   trunk/netbrush/src/server_connection.cpp
Log:
- added command line parsing

Modified: trunk/netbrush/SConstruct
===================================================================
--- trunk/netbrush/SConstruct	2006-10-20 09:57:21 UTC (rev 664)
+++ trunk/netbrush/SConstruct	2006-10-20 12:35:24 UTC (rev 665)
@@ -8,7 +8,7 @@
 server_env.ParseConfig('sdl-config --cflags --libs')
 server_env['CXXFLAGS'] += ['-O0', '-Wall', '-g']
 server_env['LIBS'] += ['SDL_net']
-server_env.Program('server', [
+server_env.Program('netbrush-server', [
         'src/server.cpp'
 ])
 
@@ -18,7 +18,7 @@
 client_env['CXXFLAGS'] += ['-O0', '-Wall', '-g']
 client_env['CPPPATH'] += ['src/']
 client_env['LIBS'] += ['SDL_image', 'SDL_net']
-client_env.Program('client', [
+client_env.Program('netbrush-client', [
         'src/alpha_picker.cpp',
         'src/brush_widget.cpp',
         'src/brushmask.cpp',
@@ -49,6 +49,8 @@
         'src/widget/widget_manager.cpp',
         'src/navigation.cpp',
         'src/graphic_context_state.cpp',
+        'src/command_line.cpp',
+        'src/command_line_generic.cpp'
 #        'src/widget/events.cpp',
 ])
 

Modified: trunk/netbrush/src/client.cpp
===================================================================
--- trunk/netbrush/src/client.cpp	2006-10-20 09:57:21 UTC (rev 664)
+++ trunk/netbrush/src/client.cpp	2006-10-20 12:35:24 UTC (rev 665)
@@ -1,4 +1,5 @@
 #include <iostream>
+#include <stdexcept>
 #include <sstream>
 #include <map>
 #include "math/rect.hpp"
@@ -24,6 +25,7 @@
 #include "brush_widget.hpp"
 #include "navigation.hpp"
 #include "server_connection.hpp"
+#include "command_line.hpp"
 #include "widget/slider_widget.hpp"
 
 SDL_Rect* make_rect(int x, int y, int w, int h)
@@ -45,7 +47,7 @@
       switch(event.type)
         {
         case SDL_QUIT:
-          puts("# quit");
+          puts("Quitting");
           exit(0);
           break;
 
@@ -101,6 +103,10 @@
             {
               navigation->update();
             }
+          else if (event.key.keysym.sym == SDLK_ESCAPE)
+            {
+              exit(EXIT_SUCCESS);
+            }
           break;
 
         case SDL_MOUSEBUTTONDOWN:
@@ -190,147 +196,229 @@
 
   void on_press  (Button* button) 
   {
-    std::cout << "Press: " << button << std::endl;
+    //std::cout << "Press: " << button << std::endl;
   }
 
   void on_release(Button* button) 
   {
-    std::cout << "Release: " << button << std::endl;
+    //std::cout << "Release: " << button << std::endl;
   }
   
   void on_click  (Button* button) 
   {
-    std::cout << "Setting tool: " << tool << std::endl;
+    //std::cout << "Setting tool: " << tool << std::endl;
     client_draw_param->tool = tool;
   }
 };
 
 int main(int argc, char** argv)
 {
-  if(SDL_Init(SDL_INIT_VIDEO)== -1) {
-    printf("SDL_Init: %s\n", SDL_GetError());
-    exit(1);
-  }
-  atexit(SDL_Quit);
+  try {
+    bool fullscreen = false;
+    int screen_width  = 800;
+    int screen_height = 600;
+    std::string hostname;
+    std::string port     = "4711";
+    int rest_arg_count = 0;
 
-  if(SDLNet_Init()==-1) {
-    printf("SDLNet_Init: %s\n", SDLNet_GetError());
-    exit(2);
-  }
-  atexit(SDLNet_Quit);
+    CommandLine argp;
 
-  screen = SDL_SetVideoMode(1024, 768, 32, SDL_HWSURFACE); 
-  if (screen == 0)
-    printf("SDL_SetVideoMode: %s\n", SDL_GetError());
-  SDL_WM_SetCaption("netBrush", "netBrush");
+    argp.add_usage("[OPTIONS] HOSTNAME PORT");
+    argp.add_group("Display:");
+    argp.add_option('g', "geometry",  "WIDTHxHEIGHT", "Set the windows size to WIDTHxHEIGHT");
+    argp.add_option('f', "fullscreen", "",            "Start the application in fullscreen mode");
+    argp.add_option('w', "window",     "",            "Start the application in window mode");
+    argp.add_option('v', "version",    "",            "Display the netBrush version");
+    argp.add_option('h', "help",       "",            "Show this help text");
 
-  // 18 is scrollbar
-  screen_buffer = new ScreenBuffer(Rect(38, 2, screen->w - 128 - 16 - 18, screen->h - 16 - 4)); 
-  draw_ctx      = new DrawingContext(2048, 2048);
-  stroke_buffer = new StrokeBuffer(2048, 2048);
+    argp.parse_args(argc, argv);
 
-  std::cout << "# clear screen" << std::endl;
+    while(argp.next())
+      {
+        switch(argp.get_key())
+          {
+          case 'g':
+            {
+              if (sscanf(argp.get_argument().c_str(), "%dx%d",
+                         &screen_width, &screen_height) == 2)
+                {
+                  std::cout << "Geometry: " << screen_width << "x" << screen_height << std::endl;
+                }
+              else
+                {
+                  throw std::runtime_error("Geometry option '-g' requires argument of type {WIDTH}x{HEIGHT}");
+                }
+            }
+            break;
 
-  // clear screen
-  draw_ctx->clear();
+          case 'f':
+            fullscreen = true;
+            break;
 
-  std::cout << "# clear screen done" << std::endl;
+          case 'w':
+            fullscreen = false;
+            break;
 
-  client_draw_param = new DrawingParameter();
-  stroke_buffer->set_param(client_draw_param);
-  
-  server = new ServerConnection();
-  if (argc == 3)
-    {
-      std::cout << "# connecting to: " << argv[1] << ":" << atoi(argv[2]) << std::endl;
-      server->connect(argv[1], atoi(argv[2]));
-      std::ostringstream title_line;
-      title_line << "netBrush - online: " << argv[1] << ":" << atoi(argv[2]);
-      SDL_WM_SetCaption(title_line.str().c_str(), "netBrush");
+          case 'h':
+            argp.print_help();
+            return 0;
+            break;
+
+          case 'v':
+            std::cout << "netBrush 0.1.0" << std::endl;
+            break;
+
+          case CommandLine::REST_ARG:
+            //std::cout << "Rest: " << argp.get_argument() << std::endl;
+            if (rest_arg_count == 0)
+              {
+                hostname = argp.get_argument();
+                rest_arg_count += 1;
+              }
+            else if (rest_arg_count == 1)
+              {
+                port = argp.get_argument();
+                rest_arg_count += 1;
+              }
+            else
+              {
+                std::cout << "Invalide argument " << argp.get_argument() << std::endl;
+                exit(EXIT_FAILURE);
+              }
+            break;
+          }
+      }
+
+    if(SDL_Init(SDL_INIT_VIDEO)== -1) {
+      printf("SDL_Init: %s\n", SDL_GetError());
+      exit(1);
     }
-  else
-    {
-      std::cout << "# use '" << argv[0] << " HOSTNAME PORT' to connect a networking session" << std::endl;
-      SDL_WM_SetCaption("netBrush - offline mode", "netBrush");
+    atexit(SDL_Quit);
+
+    if(SDLNet_Init()==-1) {
+      printf("SDLNet_Init: %s\n", SDLNet_GetError());
+      exit(2);
     }
+    atexit(SDLNet_Quit);
+
+    Uint32 flags = SDL_HWSURFACE;
+    if (fullscreen)
+      flags |= SDL_FULLSCREEN;
+    screen = SDL_SetVideoMode(screen_width, screen_height, 32, flags); 
+    if (screen == 0)
+      printf("SDL_SetVideoMode: %s\n", SDL_GetError());
+    SDL_WM_SetCaption("netBrush", "netBrush");
+
+    // 18 is scrollbar
+    screen_buffer = new ScreenBuffer(Rect(38, 2, screen->w - 128 - 18 - 2 - 2, screen->h - 16 - 4)); 
+    draw_ctx      = new DrawingContext(2048, 2048);
+    stroke_buffer = new StrokeBuffer(2048, 2048);
+
+    //std::cout << "# clear screen" << std::endl;
+
+    // clear screen
+    draw_ctx->clear();
+
+    //std::cout << "# clear screen done" << std::endl;
+
+    client_draw_param = new DrawingParameter();
+    stroke_buffer->set_param(client_draw_param);
   
-  widget_manager = new WidgetManager();
-  widget_manager->add(navigation = new Navigation(Rect(Point(screen->w - 128 - 2, screen->h - 128 - 2),
-                                                       Size(128, 128))));
-  widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-airbrush-22.png"), 
-                                 Rect(Point(2, 2+0*34), Size(34, 34)),
-                                 new ToolButtonCallback(DrawingParameter::TOOL_AIRBRUSH)));
-  widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-paintbrush-22.png"), 
-                                 Rect(Point(2, 2+1*34), Size(34, 34)),
-                                 new ToolButtonCallback(DrawingParameter::TOOL_PAINTBRUSH)));
-  if (0)
-    widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-zoom-22.png"), 
-                                   Rect(Point(2, 2+2*34), Size(34, 34)),
+    server = new ServerConnection();
+    if (!hostname.empty() && !port.empty())
+      {
+        std::cout << "Connecting to: " << hostname << ":" << atoi(port.c_str()) << std::endl;
+        server->connect(hostname.c_str(), atoi(port.c_str()));
+        std::ostringstream title_line;
+        title_line << "netBrush - online: " << hostname << ":" << atoi(port.c_str());
+        SDL_WM_SetCaption(title_line.str().c_str(), "netBrush");
+      }
+    else
+      {
+        std::cout << "# use '" << argv[0] << " HOSTNAME PORT' to connect a networking session" << std::endl;
+        SDL_WM_SetCaption("netBrush - offline mode", "netBrush");
+      }
+  
+    widget_manager = new WidgetManager();
+    widget_manager->add(navigation = new Navigation(Rect(Point(screen->w - 128 - 2, screen->h - 128 - 2),
+                                                         Size(128, 128))));
+    widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-airbrush-22.png"), 
+                                   Rect(Point(2, 2+0*34), Size(34, 34)),
+                                   new ToolButtonCallback(DrawingParameter::TOOL_AIRBRUSH)));
+    widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-paintbrush-22.png"), 
+                                   Rect(Point(2, 2+1*34), Size(34, 34)),
                                    new ToolButtonCallback(DrawingParameter::TOOL_PAINTBRUSH)));
+    if (0)
+      widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-zoom-22.png"), 
+                                     Rect(Point(2, 2+2*34), Size(34, 34)),
+                                     new ToolButtonCallback(DrawingParameter::TOOL_PAINTBRUSH)));
 
-  {
-    SDL_Rect color_rect;
-    color_rect.x = 768;
-    color_rect.y = 100;
+    {
+      SDL_Rect color_rect;
+      color_rect.x = 768;
+      color_rect.y = 100;
 
-    color_rect.w = 128;
-    color_rect.h = 128;
+      color_rect.w = 128;
+      color_rect.h = 128;
 
-    //widget_manager->add(new ColorSelector(&color_rect));
-  }
+      //widget_manager->add(new ColorSelector(&color_rect));
+    }
 
-  widget_manager->add(screen_buffer);
+    widget_manager->add(screen_buffer);
 
-  widget_manager->add(vertical_scrollbar = 
-                      new Scrollbar(0, 2048, screen_buffer->get_rect().get_height(), Scrollbar::VERTICAL,
-                                    Rect(screen->w - 128 - 16 - 16, 2,
-                                         screen->w - 128 - 16, screen->h - 16 - 4)));
+    widget_manager->add(vertical_scrollbar = 
+                        new Scrollbar(0, 2048, screen_buffer->get_rect().get_height(), Scrollbar::VERTICAL,
+                                      Rect(screen->w - 128 - 16 - 2 - 2, 2,
+                                           screen->w - 128 - 2 - 2, screen->h - 16 - 4)));
 
-  widget_manager->add(horizontal_scrollbar = 
-                      new Scrollbar(0, 2048, screen_buffer->get_rect().get_width(), Scrollbar::HORIZONTAL,
-                                    Rect(38, screen->h - 16 - 2,
-                                         screen->w - 128 - 16 - 18, screen->h - 2)));
+    widget_manager->add(horizontal_scrollbar = 
+                        new Scrollbar(0, 2048, screen_buffer->get_rect().get_width(), Scrollbar::HORIZONTAL,
+                                      Rect(38, screen->h - 16 - 2,
+                                           screen->w - 128 - 18 - 2 - 2, screen->h - 2)));
 
-  alpha_picker = new AlphaPicker(Rect(Point(screen->w-128, 128+24), Size(128, 24)));
-  saturation_value_picker = new SaturationValuePicker(Rect(Point(screen->w-128, 0), Size(128, 128)));
-  hue_picker   = new HuePicker(Rect(Point(screen->w-128, 128), Size(128, 24)));
+    alpha_picker = new AlphaPicker(Rect(Point(screen->w-128, 128+24), Size(128, 24)));
+    saturation_value_picker = new SaturationValuePicker(Rect(Point(screen->w-128, 0), Size(128, 128)));
+    hue_picker   = new HuePicker(Rect(Point(screen->w-128, 128), Size(128, 24)));
 
-  brush_widget = new BrushWidget(Rect(Point(screen->w-128, 128+24+24), Size(128, 128)));
-  brush_widget->set_brush(client_draw_param->generic_brush);
+    brush_widget = new BrushWidget(Rect(Point(screen->w-128, 128+24+24), Size(128, 128)));
+    brush_widget->set_brush(client_draw_param->generic_brush);
 
-  SliderWidget* radius_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(0)), Size(128, 24)),
-                                                 new RadiusCallback());
-  widget_manager->add(radius_slider);
+    SliderWidget* radius_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(0)), Size(128, 24)),
+                                                   new RadiusCallback());
+    widget_manager->add(radius_slider);
 
-  SliderWidget* spike_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(1)), Size(128, 24)),
-                                                 new SpikeCallback());
-  widget_manager->add(spike_slider);
+    SliderWidget* spike_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(1)), Size(128, 24)),
+                                                  new SpikeCallback());
+    widget_manager->add(spike_slider);
 
-  SliderWidget* hardness_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(2)), Size(128, 24)),
-                                                 new HardnessCallback());
-  widget_manager->add(hardness_slider);
+    SliderWidget* hardness_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(2)), Size(128, 24)),
+                                                     new HardnessCallback());
+    widget_manager->add(hardness_slider);
 
-  SliderWidget* aspect_ratio_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(3)), Size(128, 24)),
-                                                 new AspectRatioCallback());
-  widget_manager->add(aspect_ratio_slider);
+    SliderWidget* aspect_ratio_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(3)), Size(128, 24)),
+                                                         new AspectRatioCallback());
+    widget_manager->add(aspect_ratio_slider);
 
-  SliderWidget* angle_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(4)), Size(128, 24)),
-                                                 new AngleCallback());
-  widget_manager->add(angle_slider);
+    SliderWidget* angle_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(4)), Size(128, 24)),
+                                                  new AngleCallback());
+    widget_manager->add(angle_slider);
 
-  widget_manager->add(saturation_value_picker);
-  widget_manager->add(hue_picker);
-  widget_manager->add(alpha_picker);
-  widget_manager->add(brush_widget);
+    widget_manager->add(saturation_value_picker);
+    widget_manager->add(hue_picker);
+    widget_manager->add(alpha_picker);
+    widget_manager->add(brush_widget);
 
-  // Main Loop
-  while(true)
-    {
-      process_events();
-      server->update();
-      widget_manager->update();
-      SDL_Delay(10);
-    }
+    // Main Loop
+    while(true)
+      {
+        process_events();
+        server->update();
+        widget_manager->update();
+        SDL_Delay(10);
+      }
+  } catch(std::exception& err) {
+    std::cout << "Exception: " << err.what() << std::endl;
+  }
   
   return 0;
 }

Added: trunk/netbrush/src/command_line.cpp
===================================================================
--- trunk/netbrush/src/command_line.cpp	2006-10-20 09:57:21 UTC (rev 664)
+++ trunk/netbrush/src/command_line.cpp	2006-10-20 12:35:24 UTC (rev 665)
@@ -0,0 +1,96 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include "command_line.hpp"
+#include "command_line_generic.hpp"
+
+CommandLine::CommandLine()
+{
+	impl = new CommandLine_Generic();
+}
+
+CommandLine::~CommandLine()
+{
+	delete impl;
+}
+
+void CommandLine::parse_args(int argc, char** argv)
+{
+	impl->parse_args(argc, argv);
+}
+
+void CommandLine::print_help()
+{
+	impl->print_help();
+}
+
+void CommandLine::set_help_indent(int i)
+{
+	impl->set_help_indent(i);
+}
+
+void CommandLine::add_usage(const std::string& usage)
+{
+	impl->add_usage(usage);
+}
+
+void CommandLine::add_doc(const std::string& doc)
+{
+	impl->add_doc(doc);
+}
+
+void CommandLine::add_group(const std::string& grouptopic)
+{
+	impl->add_group(grouptopic);
+}
+
+void CommandLine::add_option(
+	int key, 
+	const std::string& long_option, 
+	const std::string& argument,
+	const std::string& help,
+	bool visible)
+{
+	impl->add_option(key, long_option, argument, help, visible);
+}
+
+bool CommandLine::next()
+{
+	return impl->next();
+}
+
+int CommandLine::get_key()
+{
+	return impl->get_key();
+}
+
+std::string CommandLine::get_argument()
+{
+	return impl->get_argument();
+}

Added: trunk/netbrush/src/command_line.hpp
===================================================================
--- trunk/netbrush/src/command_line.hpp	2006-10-20 09:57:21 UTC (rev 664)
+++ trunk/netbrush/src/command_line.hpp	2006-10-20 12:35:24 UTC (rev 665)
@@ -0,0 +1,157 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+//! clanCore="System"
+//! header=core.h
+
+#ifndef HEADER_COMMAND_LINE_HPP
+#define HEADER_COMMAND_LINE_HPP
+
+#if _MSC_VER > 1000
+#pragma once
+#endif
+
+#include <string>
+#include <vector>
+
+class CommandLine_Generic;
+
+//: Helper class to parse command line arguments
+//- !group=Core/System!
+//- !header=core.h!
+//- <p>The CommandLine class helps to parse command line arguments, namely
+//- the argc/argv pair that you get from main(). CommandLine mimics
+//- getopt_long() behaviour as closely as possible, while providing a
+//- cleaner interface and a few additional features, like automatic
+//- generation of '--help' output. CommandLine can parse long arguments
+//- in the following styles:</p>
+//-
+//- <p>program --file FILENAME<br>
+//- program --file=FILENAME</p>
+//-
+//- <p>Short arguments are handled like this:</p>
+//-
+//- <p>program -f FILENAME</p>
+//-
+//- <p>Concatenating short arguments is also supported, so that:</p>
+//- 
+//- <p>program -f -a -b FILENAME</p>
+//-
+//- <p>is equivalent to:</p>
+//-
+//- <p>program -fab FILENAME</p>
+//-
+//- <p>Non-option arguments (aka rest arguments) are supported as well:</p>
+//-
+//- <p>program SOMEFILE SOMEOTHERFILE ...</p>
+//- 
+//- <p>To avoid ambiguity when a filename starts with '-' CommandLine stops
+//- parsing arguments after the first encounter of a '--', so in</p>
+//-
+//- <p>program -f -b -- -f -b</p>
+//-
+//- <p>In the above example the first '-f -b' options are treated as
+//- normal while the ones after the '--' are treated as rest arguments
+//- (aka filenames in most programs).</p>
+class CommandLine
+{
+//! Construction:
+public:
+	CommandLine();
+
+	~CommandLine();
+
+//! Attributes:
+public:
+	enum
+	{
+		REST_ARG  = -2
+	};
+
+	//: Return the key of the current option
+	int get_key();
+
+	//: Return the argument to the current option
+	std::string get_argument();
+
+//! Operations:
+public:
+	//: Change the indention used for the help message, default is 18
+	void set_help_indent(int i);
+
+	//: Add a usage line to the help output, usage is for example
+	//: "[OPTIONS]... FILE", the program name will get appended
+	//: automatically
+	void add_usage(const std::string& usage);
+
+	//: Adds extra documentation to the help output, should only be
+	//: used at the beginning or at the end, to
+	void add_doc(const std::string& doc);
+	
+	//: Starts a new group of options, the grouptopic gets printed
+	//: above the group of options in the print_help() output
+	void add_group(const std::string& grouptopic);
+  
+	//: Adds a option to the parser
+	//param key: a letter for a short-option or a numeric value
+	//param key: larger than 255 that identifies the option
+	//param long_option: the long name of this option or "" if non
+	//param long_option: should be used for this option
+	//param argument: the type of the argument that this option
+	//param argument: requires (i.e. FILE, SIZE, WIDTH, etc.) or "" if no argument is
+	//param argument: required
+	//param help: the help string for this option
+	//param visible: true if the option should be listed in the help
+	//param visible: output, false will not list it in the help output which might
+	//param visible: be usefull for cheat-options or backward-compability options
+	//param visible: than would only clutter the help output
+	void add_option(
+		int key,
+		const std::string& long_option, 
+		const std::string& argument,
+		const std::string& help,
+		bool visible = true);
+	
+	//: Parse the options arcording to the options added with
+	//: add_option(), result of the parsing is accessible via
+	//: next() and get_key()/get_argument()
+	void parse_args(int argc, char** argv);
+
+	//: Print the help output, normaly done via a --help option
+	void print_help();
+
+	//: Goto the next option
+	bool next();
+
+//! Implementation:
+private:
+	CommandLine_Generic* impl;
+};
+
+#endif

Added: trunk/netbrush/src/command_line_generic.cpp
===================================================================
--- trunk/netbrush/src/command_line_generic.cpp	2006-10-20 09:57:21 UTC (rev 664)
+++ trunk/netbrush/src/command_line_generic.cpp	2006-10-20 12:35:24 UTC (rev 665)
@@ -0,0 +1,336 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#include <iomanip>
+#include <iostream>
+#include <stdexcept>
+#include <stdio.h>
+
+#include "command_line_generic.hpp"
+
+
+#ifdef WIN32
+#define snprintf _snprintf
+#endif
+
+CommandLine_Generic::CommandLine_Generic()
+{
+  help_indent = 18;
+}
+
+void CommandLine_Generic::parse_args(int argc, char** argv)
+{
+  programm = argv[0];
+
+  for(int i = 1; i < argc; ++i) 
+    {
+      if (argv[i][0] == '-') 
+        {
+          if (argv[i][1] == '-') 
+            {
+              // We got a long option
+              if (argv[i][2] == '\0') { 
+                // Got a '--', so we stop evaluating arguments
+                ++i;
+                while(i < argc) 
+                  {
+                    read_option(CommandLine::REST_ARG, argv[i]);
+                    ++i;
+                  }
+              } 
+              else
+                {
+                  std::string opt = argv[i] + 2;
+                  std::string long_opt;
+                  std::string long_opt_arg;
+
+                  std::string::size_type pos = opt.find('=');
+
+                  if (pos != std::string::npos) 
+                    {
+                      long_opt = opt.substr(0, pos);
+                      long_opt_arg = opt.substr(pos+1);
+                    }
+                  else 
+                    {
+                      long_opt = opt;
+                    }
+
+                  // Long Option
+                  Option* option = lookup_long_option(long_opt);
+
+                  if (option) 
+                    {
+                      if (option->argument.empty()) 
+                        {
+                          read_option(option->key, "");
+                        } 
+                      else
+                        {
+                          if (pos != std::string::npos) 
+                            {
+                              read_option(option->key, long_opt_arg);
+                            }
+                          else
+                            {            
+                              if (i == argc - 1) 
+                                {
+                                  throw std::runtime_error("option '" + std::string(argv[i]) + "' requires an argument");
+                                }
+                              else 
+                                {
+                                  read_option(option->key, argv[i + 1]);
+                                  ++i;
+                                }
+                            }
+                        }
+                    }
+                  else
+                    {
+                      throw std::runtime_error("unrecognized option '" + std::string(argv[i]) + "'");
+                    }
+                }
+            } 
+          else 
+            {
+              // We got a short option
+              char* p = argv[i] + 1;
+          
+              if (*p != '\0') {
+                // Handle option chains
+                while (*p) 
+                  {
+                    // Short option(s)
+                    Option* option = lookup_short_option(*p);
+
+                    if (option) 
+                      {
+                        if (option->argument.empty()) 
+                          {
+                            read_option(option->key, "");
+                          } 
+                        else 
+                          {
+                            if (i == argc - 1 || *(p+1) != '\0') 
+                              {
+                                // No more arguments
+                                throw std::runtime_error("option requires an argument -- " + std::string(1, *p));
+                              }
+                            else
+                              {
+                                read_option(option->key, argv[i + 1]);
+                                ++i;
+                              }
+                          }
+                      } 
+                    else 
+                      {
+                        throw std::runtime_error("invalid option -- " + std::string(1, *p));
+                      }
+                    ++p; 
+                  }
+              } 
+              else
+                {
+                  read_option(CommandLine::REST_ARG, "-");
+                } 
+            }
+        } 
+      else
+        {
+          read_option(CommandLine::REST_ARG, argv[i]);
+        }
+    }
+
+  current_option = parsed_options.end();
+}
+
+CommandLine_Generic::Option *CommandLine_Generic::lookup_short_option(char short_option)
+{
+  for(Options::iterator i = options.begin(); i != options.end(); ++i)
+    {
+      if (i->key == short_option)
+        return &(*i);
+    }
+  return 0;
+}
+
+CommandLine_Generic::Option *CommandLine_Generic::lookup_long_option(const std::string& long_option)
+{
+  for(Options::iterator i = options.begin(); i != options.end(); ++i)
+    {
+      if (i->long_option == long_option)
+        return &*i;
+    }
+  return 0;
+}
+
+void CommandLine_Generic::read_option(int key, const std::string& argument)
+{
+  ParsedOption parsed_option;
+  
+  parsed_option.key = key;
+  parsed_option.argument = argument;
+
+  parsed_options.push_back(parsed_option);
+}
+
+void CommandLine_Generic::print_help()
+{
+  bool first_usage = true;
+  for(Options::iterator i = options.begin(); i != options.end(); ++i)
+    {
+      if (i->visible)
+        {
+          if (i->key == USAGE) 
+            {
+              if (first_usage) 
+                {
+                  std::cout << "Usage: " << programm << " " <<  i->help << std::endl; 
+                  first_usage = false;
+                }
+              else
+                {
+                  std::cout << "or:    " << programm << " " << i->help << std::endl; 
+                }
+            } 
+          else if (i->key == GROUP) 
+            {
+              if (i != options.begin())
+                std::cout << std::endl;
+              std::cout << i->help << std::endl;
+            }
+          else if (i->key == DOC) 
+            {
+              if (i != options.begin())
+                std::cout << std::endl;
+              std::cout << i->help << std::endl;
+            }
+          else 
+            {
+              char option[256]   = { 0 };
+              char argument[256] = { 0 };
+
+              if (i->key > 255 || i->key < 0)
+                snprintf(option, 256, "--%s", i->long_option.c_str());
+              else if (i->long_option.empty())
+                snprintf(option, 256, "-%c", char(i->key));
+              else
+                snprintf(option, 256, "-%c, --%s", char(i->key), i->long_option.c_str());
+
+              if (!i->argument.empty())
+                {
+                  if (i->long_option.empty())
+                    snprintf(argument, 256, " %s", i->argument.c_str());
+                  else
+                    snprintf(argument, 256, "=%s", i->argument.c_str());
+                }
+
+              std::cout << "  " 
+                        << std::setiosflags(std::ios::left) << std::setw(help_indent)
+                        << (std::string(option) + std::string(argument)) << std::setw(0)
+                        << " " << i->help << std::endl;
+            }
+        }
+    }
+  std::cout << std::endl;
+}
+
+void CommandLine_Generic::add_usage(const std::string& usage)
+{
+  Option option;
+
+  option.key          = USAGE;
+  option.help         = usage;
+  option.visible      = true;
+
+  options.push_back(option);   
+}
+
+void CommandLine_Generic::add_doc(const std::string& grouptopic)
+{
+  Option option;
+
+  option.key          = DOC;
+  option.help         = grouptopic;
+  option.visible      = true;
+
+  options.push_back(option);  
+}
+
+void CommandLine_Generic::add_group(const std::string& grouptopic)
+{
+  Option option;
+
+  option.key          = GROUP;
+  option.help         = grouptopic;
+  option.visible      = true;
+
+  options.push_back(option);  
+}
+
+void CommandLine_Generic::add_option(int key, 
+                                        const std::string& long_option, 
+                                        const std::string& argument,
+                                        const std::string& help,
+                                        bool visible)
+{
+  Option option;
+
+  option.key          = key;
+  option.help         = help;
+  option.long_option  = long_option;
+  option.argument     = argument;
+  option.visible      = visible;
+
+  options.push_back(option);
+}
+
+bool CommandLine_Generic::next()
+{
+  if (current_option == parsed_options.end()) 
+    {
+      (current_option = parsed_options.begin());
+      return current_option != parsed_options.end();
+    }
+  else
+    {
+      return (++current_option) != parsed_options.end();
+    }
+}
+
+int CommandLine_Generic::get_key()
+{
+  return current_option->key;
+}
+
+std::string CommandLine_Generic::get_argument()
+{
+  return current_option->argument;
+}

Added: trunk/netbrush/src/command_line_generic.hpp
===================================================================
--- trunk/netbrush/src/command_line_generic.hpp	2006-10-20 09:57:21 UTC (rev 664)
+++ trunk/netbrush/src/command_line_generic.hpp	2006-10-20 12:35:24 UTC (rev 665)
@@ -0,0 +1,111 @@
+/*
+**  ClanLib SDK
+**  Copyright (c) 1997-2005 The ClanLib Team
+**
+**  This software is provided 'as-is', without any express or implied
+**  warranty.  In no event will the authors be held liable for any damages
+**  arising from the use of this software.
+**
+**  Permission is granted to anyone to use this software for any purpose,
+**  including commercial applications, and to alter it and redistribute it
+**  freely, subject to the following restrictions:
+**
+**  1. The origin of this software must not be misrepresented; you must not
+**     claim that you wrote the original software. If you use this software
+**     in a product, an acknowledgment in the product documentation would be
+**     appreciated but is not required.
+**  2. Altered source versions must be plainly marked as such, and must not be
+**     misrepresented as being the original software.
+**  3. This notice may not be removed or altered from any source distribution.
+**
+**  Note: Some of the libraries ClanLib may link to may have additional
+**  requirements or restrictions.
+**
+**  File Author(s):
+**
+**    Magnus Norddahl
+**    (if your name is missing here, please add it)
+*/
+
+#ifndef HEADER_COMMAND_LINE_GENERIC_HPP
+#define HEADER_COMMAND_LINE_GENERIC_HPP
+
+#if _MSC_VER > 1000
+#pragma once
+#endif
+
+#include <string>
+#include <vector>
+#include "command_line.hpp"
+
+class CommandLine_Generic
+{
+private:
+	int help_indent;
+
+	std::string programm;
+
+	struct Option 
+	{
+		int key;
+		std::string help;
+		std::string long_option;
+		std::string argument;
+		bool visible;
+	};
+  
+	typedef std::vector<Option> Options;
+	Options options;
+
+	struct ParsedOption
+	{
+		int key;
+		std::string argument;
+	};
+
+	typedef std::vector<ParsedOption> ParsedOptions;
+	ParsedOptions parsed_options;
+	ParsedOptions::iterator current_option;
+
+	enum
+	{
+		GROUP     = -3,
+		DOC       = -4,
+		USAGE     = -5
+	};
+
+public:  
+	CommandLine_Generic();
+
+	void set_help_indent(int i) { help_indent = i; }
+
+	void add_usage(const std::string& usage);
+	void add_doc(const std::string& doc);
+	void add_group(const std::string& grouptopic);
+  
+	void add_option(int key,
+						 const std::string& long_option, 
+						 const std::string& argument,
+						 const std::string& help,
+						 bool visible = true);
+
+	void parse_args(int argc, char** argv);
+	void print_help();
+  
+	bool next();
+	int get_key();
+	std::string get_argument();
+
+private:
+	void read_option(int id, const std::string& argument);
+
+	/** Find the Option structure that matches \a short_option */
+	Option* lookup_short_option(char short_option);
+
+	/** Find the Option structure that matches \a long_option */
+	Option* lookup_long_option (const std::string& long_option);
+};
+
+#endif
+
+/* EOF */

Modified: trunk/netbrush/src/screen_buffer.cpp
===================================================================
--- trunk/netbrush/src/screen_buffer.cpp	2006-10-20 09:57:21 UTC (rev 664)
+++ trunk/netbrush/src/screen_buffer.cpp	2006-10-20 12:35:24 UTC (rev 665)
@@ -116,39 +116,6 @@
       draw_ctx->draw(target, dirty_region, trans_x, trans_y);
       if (!scrolling)
         stroke_buffer->draw(target, dirty_region, trans_x, trans_y);
-
-      { // draw layer boundary
-        Uint32 color = SDL_MapRGB(target->format, 0, 0, 0);
-        SDL_Rect r;
-
-        r.x = trans_x;
-        r.y = trans_y;
-        r.w = draw_ctx->get_width();
-        r.h = 1;
-
-        SDL_FillRect(target, &r, color);
-
-        r.x = trans_x;
-        r.y = draw_ctx->get_height()-1 + trans_y;
-        r.w = draw_ctx->get_width();
-        r.h = 1;
-
-        SDL_FillRect(target, &r, color);
-
-        r.x = draw_ctx->get_width()-1 + trans_x;
-        r.y = trans_y;
-        r.w = 1;
-        r.h = draw_ctx->get_height();
-
-        SDL_FillRect(target, &r, color);
-
-        r.x = trans_x;
-        r.y = trans_y;
-        r.w = 1;
-        r.h = draw_ctx->get_height();
-
-        SDL_FillRect(target, &r, color);
-      }
   
       if (complete_refresh)
         { 

Modified: trunk/netbrush/src/server_connection.cpp
===================================================================
--- trunk/netbrush/src/server_connection.cpp	2006-10-20 09:57:21 UTC (rev 664)
+++ trunk/netbrush/src/server_connection.cpp	2006-10-20 12:35:24 UTC (rev 665)
@@ -207,7 +207,7 @@
                 }
               else
                 {
-                  std::cout << "# allocating new ClientState" << std::endl;
+                  //std::cout << "# allocating new ClientState" << std::endl;
                   client_state = new ClientState(client_id);
                   client_states[client_id] = client_state;
                 }
@@ -283,7 +283,7 @@
         {
           if (tokens.size() == 2)
             {
-              std::cout << "# my Id: " << atoi(tokens[1].c_str()) << std::endl;
+              //std::cout << "# my Id: " << atoi(tokens[1].c_str()) << std::endl;
             }
           else
             {



From grumbel at mail.berlios.de  Fri Oct 20 14:43:16 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Fri, 20 Oct 2006 14:43:16 +0200
Subject: [Flexlay-commit] r666 - trunk/netbrush
Message-ID: <200610201243.k9KChGtx006014@sheep.berlios.de>

Author: grumbel
Date: 2006-10-20 14:43:14 +0200 (Fri, 20 Oct 2006)
New Revision: 666

Added:
   trunk/netbrush/Makefile
   trunk/netbrush/netbrush.png
Modified:
   trunk/netbrush/
Log:
some cleanup


Property changes on: trunk/netbrush
___________________________________________________________________
Name: svn:ignore
   + 
netbrush-client
netbrush-server
.sconsign.dblite


Added: trunk/netbrush/Makefile
===================================================================
--- trunk/netbrush/Makefile	2006-10-20 12:35:24 UTC (rev 665)
+++ trunk/netbrush/Makefile	2006-10-20 12:43:14 UTC (rev 666)
@@ -0,0 +1,4 @@
+all:
+	scons -D
+
+# EOF #

Added: trunk/netbrush/netbrush.png
===================================================================
(Binary files differ)


Property changes on: trunk/netbrush/netbrush.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From grumbel at mail.berlios.de  Fri Oct 20 16:29:33 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Fri, 20 Oct 2006 16:29:33 +0200
Subject: [Flexlay-commit] r667 - trunk/netbrush/src
Message-ID: <200610201429.k9KETXWo029302@sheep.berlios.de>

Author: grumbel
Date: 2006-10-20 16:29:33 +0200 (Fri, 20 Oct 2006)
New Revision: 667

Modified:
   trunk/netbrush/src/drawing_parameter.cpp
Log:
- fixed brush clipping bug

Modified: trunk/netbrush/src/drawing_parameter.cpp
===================================================================
--- trunk/netbrush/src/drawing_parameter.cpp	2006-10-20 12:43:14 UTC (rev 666)
+++ trunk/netbrush/src/drawing_parameter.cpp	2006-10-20 14:29:33 UTC (rev 667)
@@ -79,7 +79,8 @@
 int
 DrawingParameter::thickness() const
 {
-  return brush_buffer->get_width();
+  return std::max(brush_buffer->get_width(),
+                  brush_buffer->get_height());
 }
 
 float



From grumbel at mail.berlios.de  Sat Oct 21 01:15:53 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sat, 21 Oct 2006 01:15:53 +0200
Subject: [Flexlay-commit] r668 - in trunk/netbrush: . src
Message-ID: <200610202315.k9KNFrFj015875@sheep.berlios.de>

Author: grumbel
Date: 2006-10-21 01:15:53 +0200 (Sat, 21 Oct 2006)
New Revision: 668

Added:
   trunk/netbrush/src/client_connection.cpp
   trunk/netbrush/src/client_connection.hpp
Modified:
   trunk/netbrush/
   trunk/netbrush/README
   trunk/netbrush/SConstruct
   trunk/netbrush/src/
   trunk/netbrush/src/alpha_picker.hpp
   trunk/netbrush/src/client.cpp
   trunk/netbrush/src/color.hpp
   trunk/netbrush/src/generic_brush.cpp
   trunk/netbrush/src/generic_brush.hpp
   trunk/netbrush/src/globals.cpp
   trunk/netbrush/src/globals.hpp
   trunk/netbrush/src/hue_picker.cpp
   trunk/netbrush/src/hue_picker.hpp
   trunk/netbrush/src/saturation_value_picker.cpp
   trunk/netbrush/src/saturation_value_picker.hpp
   trunk/netbrush/src/server.cpp
Log:
- moved some stuff into controller class


Property changes on: trunk/netbrush
___________________________________________________________________
Name: svn:ignore
   - 
netbrush-client
netbrush-server
.sconsign.dblite

   + 
libcommon.a
netbrush-client
netbrush-server
.sconsign.dblite


Modified: trunk/netbrush/README
===================================================================
--- trunk/netbrush/README	2006-10-20 14:29:33 UTC (rev 667)
+++ trunk/netbrush/README	2006-10-20 23:15:53 UTC (rev 668)
@@ -16,7 +16,7 @@
 
 Latest version of netBrush can be found at, no real webside exist yet:
 
- * http://pingus.seul.org/~grumbel/tmp/
+ * svn co svn://svn.berlios.de/flexlay/trunk/netbrush/
 
 Question coments can go to the author, who is reachable at
 grumbel at gmx.de.
@@ -28,13 +28,13 @@
 netBrush is client/server based, so to take full use of it, you have
 to start the server first, a simple:
 
-./server 4711
+./netbrush-server 4711
 
 will do, 4711 being the port number.
 
 To start the client you have to give it a hostname and a port, like
 this:
 
-./client localhost 4711
+./netbrush-client localhost 4711
 
 # EOF #

Modified: trunk/netbrush/SConstruct
===================================================================
--- trunk/netbrush/SConstruct	2006-10-20 14:29:33 UTC (rev 667)
+++ trunk/netbrush/SConstruct	2006-10-20 23:15:53 UTC (rev 668)
@@ -4,20 +4,27 @@
 # netbrush_env['CXXFLAGS'] += ['-O2', '-Wall', '-g']
 # netbrush_env.Program('netbrush', ['net.cpp', 'vector.cpp'])
 
+common_env = Environment()
+common_env['CXXFLAGS'] += ['-O0', '-Wall', '-g']
+libcommon = common_env.StaticLibrary('common', [
+        'src/command_line.cpp',
+        'src/command_line_generic.cpp',
+])
+
 server_env = Environment()
 server_env.ParseConfig('sdl-config --cflags --libs')
 server_env['CXXFLAGS'] += ['-O0', '-Wall', '-g']
-server_env['LIBS'] += ['SDL_net']
+server_env['LIBS'] += ['SDL_net'] + libcommon
 server_env.Program('netbrush-server', [
-        'src/server.cpp'
+        'src/server.cpp',
+        'src/client_connection.cpp',
 ])
 
-
 client_env = Environment()
 client_env.ParseConfig('sdl-config --cflags --libs')
 client_env['CXXFLAGS'] += ['-O0', '-Wall', '-g']
 client_env['CPPPATH'] += ['src/']
-client_env['LIBS'] += ['SDL_image', 'SDL_net']
+client_env['LIBS'] += ['SDL_image', 'SDL_net'] + libcommon
 client_env.Program('netbrush-client', [
         'src/alpha_picker.cpp',
         'src/brush_widget.cpp',
@@ -49,8 +56,7 @@
         'src/widget/widget_manager.cpp',
         'src/navigation.cpp',
         'src/graphic_context_state.cpp',
-        'src/command_line.cpp',
-        'src/command_line_generic.cpp'
+        'src/controller.cpp',
 #        'src/widget/events.cpp',
 ])
 


Property changes on: trunk/netbrush/src
___________________________________________________________________
Name: svn:ignore
   + .sconsign.dblite


Modified: trunk/netbrush/src/alpha_picker.hpp
===================================================================
--- trunk/netbrush/src/alpha_picker.hpp	2006-10-20 14:29:33 UTC (rev 667)
+++ trunk/netbrush/src/alpha_picker.hpp	2006-10-20 23:15:53 UTC (rev 668)
@@ -28,6 +28,8 @@
 
 #include "widget/widget.hpp"
 
+class Color;
+
 /** */
 class AlphaPicker : public Widget
 {

Modified: trunk/netbrush/src/client.cpp
===================================================================
--- trunk/netbrush/src/client.cpp	2006-10-20 14:29:33 UTC (rev 667)
+++ trunk/netbrush/src/client.cpp	2006-10-20 23:15:53 UTC (rev 668)
@@ -19,14 +19,12 @@
 #include "widget/widget_manager.hpp"
 #include "widget/scrollbar.hpp"
 #include "widget/button.hpp"
-#include "saturation_value_picker.hpp"
-#include "hue_picker.hpp"
-#include "alpha_picker.hpp"
 #include "brush_widget.hpp"
 #include "navigation.hpp"
 #include "server_connection.hpp"
 #include "command_line.hpp"
 #include "widget/slider_widget.hpp"
+#include "controller.hpp"
 
 SDL_Rect* make_rect(int x, int y, int w, int h)
 {
@@ -124,66 +122,6 @@
     }  
 }
 
-class RadiusCallback : public SliderCallback
-{
-public:
-  void operator()(float v) 
-  {
-    float radius = v * 100.0f + 0.1f;
-    client_draw_param->generic_brush.radius = radius;
-    //std::cout << "Radius: " << radius << std::endl;
-    brush_widget->set_brush(client_draw_param->generic_brush);
-  }
-};
-
-class SpikeCallback : public SliderCallback
-{
-public:
-  void operator()(float v) 
-  {
-    int spikes = int(v*18) + 2;
-    //std::cout << "Spike: " << spikes << std::endl;
-    client_draw_param->generic_brush.spikes = spikes;    
-    brush_widget->set_brush(client_draw_param->generic_brush);
-  }
-};
-
-class HardnessCallback : public SliderCallback
-{
-public:
-  void operator()(float v) 
-  {
-    float hardness = v;
-    client_draw_param->generic_brush.hardness = hardness;
-    //std::cout << "Hardness: " << hardness << std::endl;
-    brush_widget->set_brush(client_draw_param->generic_brush);
-  }
-};
-
-class AspectRatioCallback : public SliderCallback
-{
-public:
-  void operator()(float v) 
-  {
-    float aspect_ratio = v*19.0f + 1.0f;
-    client_draw_param->generic_brush.aspect_ratio = aspect_ratio;
-    //std::cout << "Aspect_Ratio: " << aspect_ratio << std::endl;
-    brush_widget->set_brush(client_draw_param->generic_brush);
-  }
-};
-
-class AngleCallback : public SliderCallback
-{
-public:
-  void operator()(float v) 
-  {
-    float angle = v * 360.0f;
-    client_draw_param->generic_brush.angle = angle;
-    //std::cout << "Angle: " << angle << std::endl;
-    brush_widget->set_brush(client_draw_param->generic_brush);
-  }
-};
-
 class ToolButtonCallback : public ButtonCallback
 {
 private:
@@ -340,6 +278,8 @@
       }
   
     widget_manager = new WidgetManager();
+    controller     = new Controller();
+
     widget_manager->add(navigation = new Navigation(Rect(Point(screen->w - 128 - 2, screen->h - 128 - 2),
                                                          Size(128, 128))));
     widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-airbrush-22.png"), 
@@ -375,37 +315,10 @@
                         new Scrollbar(0, 2048, screen_buffer->get_rect().get_width(), Scrollbar::HORIZONTAL,
                                       Rect(38, screen->h - 16 - 2,
                                            screen->w - 128 - 18 - 2 - 2, screen->h - 2)));
-
-    alpha_picker = new AlphaPicker(Rect(Point(screen->w-128, 128+24), Size(128, 24)));
-    saturation_value_picker = new SaturationValuePicker(Rect(Point(screen->w-128, 0), Size(128, 128)));
-    hue_picker   = new HuePicker(Rect(Point(screen->w-128, 128), Size(128, 24)));
-
+    
     brush_widget = new BrushWidget(Rect(Point(screen->w-128, 128+24+24), Size(128, 128)));
     brush_widget->set_brush(client_draw_param->generic_brush);
 
-    SliderWidget* radius_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(0)), Size(128, 24)),
-                                                   new RadiusCallback());
-    widget_manager->add(radius_slider);
-
-    SliderWidget* spike_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(1)), Size(128, 24)),
-                                                  new SpikeCallback());
-    widget_manager->add(spike_slider);
-
-    SliderWidget* hardness_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(2)), Size(128, 24)),
-                                                     new HardnessCallback());
-    widget_manager->add(hardness_slider);
-
-    SliderWidget* aspect_ratio_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(3)), Size(128, 24)),
-                                                         new AspectRatioCallback());
-    widget_manager->add(aspect_ratio_slider);
-
-    SliderWidget* angle_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(4)), Size(128, 24)),
-                                                  new AngleCallback());
-    widget_manager->add(angle_slider);
-
-    widget_manager->add(saturation_value_picker);
-    widget_manager->add(hue_picker);
-    widget_manager->add(alpha_picker);
     widget_manager->add(brush_widget);
 
     // Main Loop

Added: trunk/netbrush/src/client_connection.cpp
===================================================================
--- trunk/netbrush/src/client_connection.cpp	2006-10-20 14:29:33 UTC (rev 667)
+++ trunk/netbrush/src/client_connection.cpp	2006-10-20 23:15:53 UTC (rev 668)
@@ -0,0 +1,247 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#include <vector>
+#include <iostream>
+#include <sstream>
+#include <fstream>
+#include "client_connection.hpp"
+
+extern std::vector<ClientConnection*> clients;
+extern std::vector<std::string> drawing_history;
+extern std::ofstream* outfile;
+
+static std::vector<std::string>
+tokenize(const std::string& str, char split_char)
+{
+  std::string::size_type start = 0;
+  std::string::size_type end   = 0;
+
+  std::vector<std::string> tokens;
+
+  while (start < str.size())
+    {
+      if ((end = str.find(split_char, start)) == std::string::npos)
+        {
+          tokens.push_back(str.substr(start));
+          break;
+        }
+
+      const std::string& ret = str.substr(start, end - start);
+
+      if (!ret.empty())
+        tokens.push_back(ret);
+
+      start = end + 1;
+    }
+
+  return tokens;
+}
+
+ClientConnection::ClientConnection(int id_, TCPsocket socket)
+  : id(id_), 
+    tcpsock(socket),
+    invalid(false)
+{
+  buffer_pos = 0;
+  full_client = false;
+}
+  
+bool
+ClientConnection::is_invalid()
+{
+  return invalid;
+}
+
+void
+ClientConnection::update()
+{
+  if (invalid) return;
+
+  if (SDLNet_SocketReady(tcpsock))
+    {
+      const int MAXLEN = 1024;
+      char msg[MAXLEN];
+
+      int result = SDLNet_TCP_Recv(tcpsock, msg, MAXLEN);
+      if(result <= 0) 
+        {
+          // TCP Connection is broken. (because of error or closure)
+          std::cout << "# Connection break, abort" << std::endl;
+          invalid = true;
+          return;
+        }
+      else 
+        {
+          for(int i = 0; i < result; ++i)
+            {
+              if (msg[i] == '\n')
+                {
+                  process_line(buffer);
+                  buffer.clear();
+                  buffer_pos = 0;
+                }
+              else
+                {
+                  buffer += msg[i];
+                }
+            }
+        }
+    }
+}
+
+void
+ClientConnection::send_string(const std::string& line)
+{
+  if (full_client)
+    {
+      if (invalid) return;
+        
+      //std::cout << "Sending: '" << line << "' ... " << std::flush;
+      int result = SDLNet_TCP_Send(tcpsock, const_cast<char*>(line.c_str()), line.length());
+      if (result < int(line.length()))
+        {
+          // It may be good to disconnect sock because it is likely invalid now.
+          printf( "Error: SDLNet_TCP_Send: '%s'\n", SDLNet_GetError() );
+          invalid = true;
+        }
+      std::cout << "done" << std::endl;
+    }
+}
+
+void
+ClientConnection::process_line(const std::string& line)
+{
+  if (invalid) return;
+    
+  std::vector<std::string> tokens = tokenize(line, ' ');
+  if (tokens.size() == 2 && tokens[0] == "load")
+    {
+      for(int i = 0; i < int(clients.size()); ++i)
+        {
+          if (clients[i])
+            {
+              clients[i]->send_string("clear\n");
+            }
+        }
+      std::cout << "# load unimplemented" << std::endl;
+    }
+  else if (tokens.size() == 2 && tokens[0] == "import")
+    {
+      std::cout << "# import unimplemented" << std::endl;
+    }
+  else if (tokens.size() == 2 && tokens[0] == "save")
+    {
+      for(int i = 0; i < int(tokens[1].size()); ++i)
+        {
+          if (tokens[1][i] == '/' || tokens[1][i] == '.')
+            {
+              tokens[1][i] = '.';
+            }
+        }
+        
+      std::ostringstream filename;
+      filename << "images/" << tokens[1] << ".nbr";        
+
+      int j = 1;
+      std::string fname = filename.str();
+      while (access(fname.c_str(), F_OK) == 0)
+        {
+          filename.str("");
+          filename << "images/" << tokens[1] << "-" << j << ".nbr";
+          fname = filename.str();
+          j += 1;
+        }
+
+      std::cout << "# writing log to " << filename.str() << std::endl;
+      std::ofstream out(fname.c_str());
+      for(int i = 0; i < int(drawing_history.size()); ++i)
+        out << drawing_history[i];
+      out.close();
+    }
+  else if (tokens.size() == 2 && tokens[0] == "client_version")
+    {
+      if (atoi(tokens[1].c_str()) == 1)
+        {
+          full_client = true;
+          for(int i = 0; i < int(drawing_history.size()); ++i)
+            {
+              clients.back()->send_string(drawing_history[i]);
+            }
+        }
+    }
+  else if (tokens.size() == 1 && tokens[0] == "clear")
+    {
+      std::ostringstream filename;
+      filename << "sessions/session-" << time(NULL) << ".nbr";
+        
+      std::cout << "# writing log to " << filename.str() << std::endl;
+      outfile->close();
+      delete outfile;
+      outfile = new std::ofstream(filename.str().c_str());
+
+      drawing_history.clear();
+
+      for(int i = 0; i < int(clients.size()); ++i)
+        {
+          if (clients[i])
+            {
+              clients[i]->send_string("clear\n");
+            }
+        }
+    }
+  else if (tokens.size() >= 1 && 
+           (tokens[0] == "dab" ||
+            tokens[0] == "stroke_begin" ||
+            tokens[0] == "stroke_end"   ||
+            tokens[0] == "set_brush"    ||
+            tokens[0] == "set_generic_brush" ||
+            tokens[0] == "set_color"    ||
+            tokens[0] == "set_tool"     ||
+            tokens[0] == "set_opacity" 
+            ))
+    {
+      std::ostringstream str;
+      str << "client " << id << " " << line << std::endl;
+      //std::cout << "SERVER: " << str.str();
+      drawing_history.push_back(str.str());
+      (*outfile) << str.str() << std::flush;
+
+      for(int i = 0; i < int(clients.size()); ++i)
+        {
+          if (clients[i])
+            {
+              clients[i]->send_string(str.str());
+              // FIXME: write to file
+            }
+        }
+    }
+  else
+    {
+      std::cout << "# invalid command: " << line << std::endl;
+    }
+}
+
+/* EOF */

Added: trunk/netbrush/src/client_connection.hpp
===================================================================
--- trunk/netbrush/src/client_connection.hpp	2006-10-20 14:29:33 UTC (rev 667)
+++ trunk/netbrush/src/client_connection.hpp	2006-10-20 23:15:53 UTC (rev 668)
@@ -0,0 +1,53 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#ifndef HEADER_CLIENT_CONNECTION_HPP
+#define HEADER_CLIENT_CONNECTION_HPP
+
+#include <string>
+#include "SDL_net.h"
+
+class ClientConnection
+{
+public:
+  int id;
+  TCPsocket   tcpsock;
+  int         buffer_pos;
+  std::string buffer;
+  bool        invalid;
+  bool        full_client;
+
+public:
+  ClientConnection(int id_, TCPsocket socket);
+  
+  bool is_invalid();
+  void update();
+  void send_string(const std::string& line);
+  void process_line(const std::string& line);
+};
+
+#endif
+
+/* EOF */

Modified: trunk/netbrush/src/color.hpp
===================================================================
--- trunk/netbrush/src/color.hpp	2006-10-20 14:29:33 UTC (rev 667)
+++ trunk/netbrush/src/color.hpp	2006-10-20 23:15:53 UTC (rev 668)
@@ -41,6 +41,32 @@
   Uint8 r;
   Uint8 g;
   Uint8 b;
+
+  static Color from_hue(Uint8 hue)
+  {
+    static Color colors[] = { Color(255,   0,   0),
+                              Color(255,   0, 255),
+                              Color(  0,   0, 255),
+                              Color(  0, 255, 255),
+                              Color(  0, 255,   0),
+                              Color(255, 255,   0),
+                              Color(255,   0,   0) };
+  
+    int seg_len = (255/6);
+    int seg  = (hue / seg_len);
+    int prog = (hue % seg_len);
+
+    return Color((((seg_len - prog) * colors[seg].r) + (prog * colors[seg+1].r))/seg_len,
+                 (((seg_len - prog) * colors[seg].g) + (prog * colors[seg+1].g))/seg_len,
+                 (((seg_len - prog) * colors[seg].b) + (prog * colors[seg+1].b))/seg_len);
+  }
+
+  void apply_value_saturation(Uint8 value, Uint8 saturation)
+  {
+    r = (0*value + (255-value) * ((255 * saturation + r * (255 - saturation))/255))/255;
+    g = (0*value + (255-value) * ((255 * saturation + g * (255 - saturation))/255))/255;
+    b = (0*value + (255-value) * ((255 * saturation + b * (255 - saturation))/255))/255;
+  }
 };
 
 #endif

Modified: trunk/netbrush/src/generic_brush.cpp
===================================================================
--- trunk/netbrush/src/generic_brush.cpp	2006-10-20 14:29:33 UTC (rev 667)
+++ trunk/netbrush/src/generic_brush.cpp	2006-10-20 23:15:53 UTC (rev 668)
@@ -26,7 +26,7 @@
 #include "generic_brush.hpp"
 
 GrayscaleBuffer*
-GenericBrush::generate()
+GenericBrush::generate() const
 {
   return generate_brushmask(shape, radius, spikes, hardness, aspect_ratio, angle);
 }

Modified: trunk/netbrush/src/generic_brush.hpp
===================================================================
--- trunk/netbrush/src/generic_brush.hpp	2006-10-20 14:29:33 UTC (rev 667)
+++ trunk/netbrush/src/generic_brush.hpp	2006-10-20 23:15:53 UTC (rev 668)
@@ -47,7 +47,7 @@
       angle(0.0f)
   {}
 
-  GrayscaleBuffer* generate();
+  GrayscaleBuffer* generate() const;
 };
 
 #endif

Modified: trunk/netbrush/src/globals.cpp
===================================================================
--- trunk/netbrush/src/globals.cpp	2006-10-20 14:29:33 UTC (rev 667)
+++ trunk/netbrush/src/globals.cpp	2006-10-20 23:15:53 UTC (rev 668)
@@ -33,9 +33,6 @@
 
 std::map<int, ClientState*> client_states;
 
-SaturationValuePicker* saturation_value_picker =0;
-HuePicker*   hue_picker =0;
-AlphaPicker*      alpha_picker = 0;
 BrushWidget*      brush_widget = 0;
 Stroke*           current_stroke = 0;
 ServerConnection* server = 0;
@@ -45,4 +42,6 @@
 
 Navigation* navigation = 0;
 
+Controller* controller = 0;
+
 /* EOF */

Modified: trunk/netbrush/src/globals.hpp
===================================================================
--- trunk/netbrush/src/globals.hpp	2006-10-20 14:29:33 UTC (rev 667)
+++ trunk/netbrush/src/globals.hpp	2006-10-20 23:15:53 UTC (rev 668)
@@ -32,6 +32,7 @@
 #include <vector>
 #include <string>
 
+class Controller;
 class StrokeBuffer;
 class ScreenBuffer;
 class Stroke;
@@ -39,9 +40,6 @@
 class DrawingContext;
 class DrawingParameter;
 class WidgetManager;
-class SaturationValuePicker;
-class HuePicker;
-class AlphaPicker;
 class BrushWidget;
 class ServerConnection;
 class Scrollbar;
@@ -59,13 +57,11 @@
 extern StrokeBuffer*     stroke_buffer;
 extern WidgetManager* widget_manager;
 
-extern SaturationValuePicker* saturation_value_picker;
-extern HuePicker*   hue_picker;
-extern AlphaPicker* alpha_picker;
 extern ServerConnection* server;
 extern Stroke* current_stroke;
 
 extern Navigation* navigation;
+extern Controller* controller;
 
 #endif
 

Modified: trunk/netbrush/src/hue_picker.cpp
===================================================================
--- trunk/netbrush/src/hue_picker.cpp	2006-10-20 14:29:33 UTC (rev 667)
+++ trunk/netbrush/src/hue_picker.cpp	2006-10-20 23:15:53 UTC (rev 668)
@@ -28,7 +28,7 @@
 #include "color.hpp"
 #include "globals.hpp"
 #include "widget/widget_manager.hpp"
-#include "saturation_value_picker.hpp"
+#include "controller.hpp"
 #include "globals.hpp"
 
 #include "hue_picker.hpp"
@@ -45,7 +45,8 @@
     for(int x = 0; x < surface->w; ++x)
       {
         int hue = 255 * x / surface->w;
-        const Color& color = get_color(hue);
+        
+        const Color& color = Color::from_hue(hue);
         data[3*(y * surface->w + x)+0] = color.r;
         data[3*(y * surface->w + x)+1] = color.g;
         data[3*(y * surface->w + x)+2] = color.b;
@@ -53,26 +54,6 @@
   SDL_UnlockSurface(surface);  
 }
 
-Color
-HuePicker::get_color(Uint8 hue)
-{
-  static Color colors[] = { Color(255,   0,   0),
-                            Color(255,   0, 255),
-                            Color(  0,   0, 255),
-                            Color(  0, 255, 255),
-                            Color(  0, 255,   0),
-                            Color(255, 255,   0),
-                            Color(255,   0,   0) };
-  
-  int seg_len = (255/6);
-  int seg  = (hue / seg_len);
-  int prog = (hue % seg_len);
-
-  return Color((((seg_len - prog) * colors[seg].r) + (prog * colors[seg+1].r))/seg_len,
-               (((seg_len - prog) * colors[seg].g) + (prog * colors[seg+1].g))/seg_len,
-               (((seg_len - prog) * colors[seg].b) + (prog * colors[seg+1].b))/seg_len);
-}
-
 void
 HuePicker::on_mouse_motion(const MouseMotionEvent& motion)
 {
@@ -80,7 +61,7 @@
     {
       click_pos.x = motion.x;
       click_pos.y = motion.y;
-      saturation_value_picker->set_color(get_color(255 * click_pos.x / get_rect().get_width()));
+      controller->set_color_hue(255 * click_pos.x / get_rect().get_width());
       set_dirty(true);
     }
 }
@@ -102,7 +83,7 @@
           click_pos.x = button.x;
           click_pos.y = button.y;
 
-          saturation_value_picker->set_color(get_color(255 * click_pos.x / get_rect().get_width()));
+          controller->set_color_hue(255 * click_pos.x / get_rect().get_width());
 
           set_dirty(true);
           widget_manager->grab(this);

Modified: trunk/netbrush/src/hue_picker.hpp
===================================================================
--- trunk/netbrush/src/hue_picker.hpp	2006-10-20 14:29:33 UTC (rev 667)
+++ trunk/netbrush/src/hue_picker.hpp	2006-10-20 23:15:53 UTC (rev 668)
@@ -39,8 +39,6 @@
 public:
   HuePicker(const Rect& rect);
 
-  Color get_color(Uint8 hue);
-
   void on_mouse_motion(const MouseMotionEvent& motion);
   void on_mouse_button(const MouseButtonEvent& button);
 

Modified: trunk/netbrush/src/saturation_value_picker.cpp
===================================================================
--- trunk/netbrush/src/saturation_value_picker.cpp	2006-10-20 14:29:33 UTC (rev 667)
+++ trunk/netbrush/src/saturation_value_picker.cpp	2006-10-20 23:15:53 UTC (rev 668)
@@ -28,17 +28,13 @@
 #include "globals.hpp"
 #include "widget/widget_manager.hpp"
 #include "color.hpp"
-#include "alpha_picker.hpp"
+#include "controller.hpp"
 #include "saturation_value_picker.hpp"
 
 SaturationValuePicker::SaturationValuePicker(const Rect& rect_)
   : Widget(rect_), dragging(false), click_pos(64, 64)
 {
   surface = create_surface(rect_.get_width(), rect_.get_height());
-  set_color(Color(255, 0, 0));
-
-  alpha_picker->set_color(get_color(255 * click_pos.x/get_rect().get_width(),
-                                    255 * click_pos.y/get_rect().get_height()));
 }
 
 void
@@ -61,8 +57,6 @@
       }
   SDL_UnlockSurface(surface);
   
-  alpha_picker->set_color(get_color(255 - 255 * click_pos.x/get_rect().get_width(),
-                                    255 * click_pos.y/get_rect().get_height()));
   set_dirty(true);
 }
 
@@ -82,8 +76,8 @@
     {
       click_pos.x = std::min(std::max(0, motion.x), get_rect().get_width());
       click_pos.y = std::min(std::max(0, motion.y), get_rect().get_height());
-      alpha_picker->set_color(get_color(255 - 255 * click_pos.x/get_rect().get_width(),
-                                        255 * click_pos.y/get_rect().get_height()));
+      controller->set_color_value_saturation(255 - 255 * click_pos.x/get_rect().get_width(),
+                                             255 * click_pos.y/get_rect().get_height());
     }
 }
 
@@ -106,8 +100,8 @@
       
           set_dirty(true);
           widget_manager->grab(this);
-          alpha_picker->set_color(get_color(255 - 255 * click_pos.x/get_rect().get_width(),
-                                            255 * click_pos.y/get_rect().get_height()));
+          controller->set_color_value_saturation(255 - 255 * click_pos.x/get_rect().get_width(),
+                                                 255 * click_pos.y/get_rect().get_height());
         }
     }
 }

Modified: trunk/netbrush/src/saturation_value_picker.hpp
===================================================================
--- trunk/netbrush/src/saturation_value_picker.hpp	2006-10-20 14:29:33 UTC (rev 667)
+++ trunk/netbrush/src/saturation_value_picker.hpp	2006-10-20 23:15:53 UTC (rev 668)
@@ -26,6 +26,7 @@
 #ifndef HEADER_SATURATION_VALUE_PICKER_HPP
 #define HEADER_SATURATION_VALUE_PICKER_HPP
 
+#include "color.hpp"
 #include "widget/widget.hpp"
 
 /** */

Modified: trunk/netbrush/src/server.cpp
===================================================================
--- trunk/netbrush/src/server.cpp	2006-10-20 14:29:33 UTC (rev 667)
+++ trunk/netbrush/src/server.cpp	2006-10-20 23:15:53 UTC (rev 668)
@@ -5,6 +5,8 @@
 #include <vector>
 #include "SDL.h"
 #include "SDL_net.h"
+#include "client_connection.hpp"
+#include "command_line.hpp"
 
 #ifdef WIN32
 #include  <io.h>
@@ -12,8 +14,6 @@
 #define F_OK   0
 #endif
 
-class ClientConnection;
-
 std::vector<ClientConnection*> clients;
 SDLNet_SocketSet socketset;
 
@@ -23,222 +23,6 @@
 
 std::ofstream* outfile = 0;
 
-std::vector<std::string>
-tokenize(const std::string& str, char split_char)
-{
-  std::string::size_type start = 0;
-  std::string::size_type end   = 0;
-
-  std::vector<std::string> tokens;
-
-  while (start < str.size())
-    {
-      if ((end = str.find(split_char, start)) == std::string::npos)
-        {
-          tokens.push_back(str.substr(start));
-          break;
-        }
-
-      const std::string& ret = str.substr(start, end - start);
-
-      if (!ret.empty())
-        tokens.push_back(ret);
-
-      start = end + 1;
-    }
-
-  return tokens;
-}
-
-class ClientConnection
-{
-public:
-  int id;
-  TCPsocket   tcpsock;
-  int         buffer_pos;
-  std::string buffer;
-  bool        invalid;
-  bool        full_client;
-public:
-  ClientConnection(int id_, TCPsocket socket)
-    : id(id_), 
-      tcpsock(socket),
-      invalid(false)
-  {
-    buffer_pos = 0;
-    full_client = false;
-  }
-  
-  bool is_invalid()
-  {
-    return invalid;
-  }
-
-  void update()
-  {
-    if (invalid) return;
-
-    if (SDLNet_SocketReady(tcpsock))
-      {
-        const int MAXLEN = 1024;
-        char msg[MAXLEN];
-
-        int result = SDLNet_TCP_Recv(tcpsock, msg, MAXLEN);
-        if(result <= 0) 
-          {
-            // TCP Connection is broken. (because of error or closure)
-            std::cout << "# Connection break, abort" << std::endl;
-            invalid = true;
-            return;
-          }
-        else 
-          {
-            for(int i = 0; i < result; ++i)
-              {
-                if (msg[i] == '\n')
-                  {
-                    process_line(buffer);
-                    buffer.clear();
-                    buffer_pos = 0;
-                  }
-                else
-                  {
-                    buffer += msg[i];
-                  }
-              }
-          }
-      }
-  }
-
-  void send_string(const std::string& line)
-  {
-    if (full_client)
-      {
-        if (invalid) return;
-
-        int result = SDLNet_TCP_Send(tcpsock, const_cast<char*>(line.c_str()), line.length());
-        if (result < int(line.length()))
-          {
-            // It may be good to disconnect sock because it is likely invalid now.
-            printf( "Error: SDLNet_TCP_Send: '%s'\n", SDLNet_GetError() );
-            invalid = true;
-          }
-      }
-  }
-
-  void process_line(const std::string& line)
-  {
-    if (invalid) return;
-    
-    std::vector<std::string> tokens = tokenize(line, ' ');
-    if (tokens.size() == 2 && tokens[0] == "load")
-      {
-        for(int i = 0; i < int(clients.size()); ++i)
-          {
-            if (clients[i])
-              {
-                clients[i]->send_string("clear\n");
-              }
-          }
-        std::cout << "# load unimplemented" << std::endl;
-      }
-    else if (tokens.size() == 2 && tokens[0] == "import")
-      {
-        std::cout << "# import unimplemented" << std::endl;
-      }
-    else if (tokens.size() == 2 && tokens[0] == "save")
-      {
-        for(int i = 0; i < int(tokens[1].size()); ++i)
-          {
-            if (tokens[1][i] == '/' || tokens[1][i] == '.')
-              {
-                tokens[1][i] = '.';
-              }
-          }
-        
-        std::ostringstream filename;
-        filename << "images/" << tokens[1] << ".nbr";        
-
-        int j = 1;
-        std::string fname = filename.str();
-        while (access(fname.c_str(), F_OK) == 0)
-          {
-            filename.str("");
-            filename << "images/" << tokens[1] << "-" << j << ".nbr";
-            fname = filename.str();
-            j += 1;
-          }
-
-        std::cout << "# writing log to " << filename.str() << std::endl;
-        std::ofstream out(fname.c_str());
-        for(int i = 0; i < int(drawing_history.size()); ++i)
-          out << drawing_history[i];
-        out.close();
-      }
-    else if (tokens.size() == 2 && tokens[0] == "client_version")
-      {
-        if (atoi(tokens[1].c_str()) == 1)
-          {
-            full_client = true;
-            for(int i = 0; i < int(drawing_history.size()); ++i)
-              {
-                clients.back()->send_string(drawing_history[i]);
-              }
-          }
-      }
-    else if (tokens.size() == 1 && tokens[0] == "clear")
-      {
-        std::ostringstream filename;
-        filename << "sessions/session-" << time(NULL) << ".nbr";
-        
-        std::cout << "# writing log to " << filename.str() << std::endl;
-        outfile->close();
-        delete outfile;
-        outfile = new std::ofstream(filename.str().c_str());
-
-        drawing_history.clear();
-
-        for(int i = 0; i < int(clients.size()); ++i)
-          {
-            if (clients[i])
-              {
-                clients[i]->send_string("clear\n");
-              }
-          }
-      }
-    else if (tokens.size() >= 1 && 
-             (tokens[0] == "dab" ||
-              tokens[0] == "stroke_begin" ||
-              tokens[0] == "stroke_end"   ||
-              tokens[0] == "set_brush"    ||
-              tokens[0] == "set_generic_brush" ||
-              tokens[0] == "set_color"    ||
-              tokens[0] == "set_tool"     ||
-              tokens[0] == "set_opacity" 
-              ))
-      {
-        std::ostringstream str;
-        str << "client " << id << " " << line << std::endl;
-        //std::cout << "SERVER: " << str.str();
-        drawing_history.push_back(str.str());
-        (*outfile) << str.str() << std::flush;
-
-        for(int i = 0; i < int(clients.size()); ++i)
-          {
-            if (clients[i])
-              {
-                clients[i]->send_string(str.str());
-                // FIXME: write to file
-              }
-          }
-      }
-    else
-      {
-        std::cout << "# invalid command: " << line << std::endl;
-      }
-  }
-};
-
 void accept_connections()
 {
   if (SDLNet_SocketReady(serversock))
@@ -333,37 +117,83 @@
 
 int main(int argc, char** argv)
 {
-  if(SDL_Init(0)==-1) {
-    printf("SDL_Init: %s\n", SDL_GetError());
-    exit(1);
-  }
+  try {
+    std::string port;
+    CommandLine argp;
 
-  if(SDLNet_Init()==-1) {
-    printf("SDLNet_Init: %s\n", SDLNet_GetError());
-    exit(2);
-  }
+    argp.add_usage("[OPTIONS] PORT");
+    argp.add_group("General:");
+    argp.add_option('v', "version", "", "Print the netBrush server version");
+    argp.add_option('h', "help", "", "Print this help");
 
-  atexit(SDL_Quit);
-  atexit(SDLNet_Quit);
+    argp.parse_args(argc, argv);
+    while(argp.next())
+      {
+        switch(argp.get_key())
+          {
+          case 'h':
+            argp.print_help();
+            return 0;
+            break;
+            
+          case 'v':
+            std::cout << "netBrush Server 0.1.0" << std::endl;
+            return 0;
+            break;
+            
+          case CommandLine::REST_ARG:
+            if (!port.empty())
+              {
+                std::cout << "Invalid argument: " << argp.get_argument() << std::endl;
+                return 1;
+              }
+            else
+              {
+                port = argp.get_argument();
+              }
+            break;
+          }
+      }
 
-  std::ostringstream filename;
-  filename << "sessions/session-" << time(NULL) << ".nbr";
+    if (port.empty())
+      {
+        argp.print_help();
+        return 1;
+      }
 
-  std::cout << "# writing log to " << filename.str() << std::endl;
-  outfile = new std::ofstream(filename.str().c_str());
+    if(SDL_Init(0)==-1) {
+      printf("SDL_Init: %s\n", SDL_GetError());
+      exit(1);
+    }
 
-  if (argc == 2)
-    {
-      std::cout << "# listening on: " << argv[1] << std::endl;
-      connect(atoi(argv[1]));
+    if(SDLNet_Init()==-1) {
+      printf("SDLNet_Init: %s\n", SDLNet_GetError());
+      exit(2);
     }
-  else
-    {
-      std::cout << "Usage: " << argv[0] << " PORT" << std::endl;
-    }
 
-  outfile->close();
-  delete outfile;
+    atexit(SDL_Quit);
+    atexit(SDLNet_Quit);
 
+    std::ostringstream filename;
+    filename << "sessions/session-" << time(NULL) << ".nbr";
+
+    std::cout << "# writing log to " << filename.str() << std::endl;
+    outfile = new std::ofstream(filename.str().c_str());
+
+    if (argc == 2)
+      {
+        std::cout << "# listening on: " << port << std::endl;
+        connect(atoi(port.c_str()));
+      }
+    else
+      {
+        std::cout << "Usage: " << argv[0] << " PORT" << std::endl;
+      }
+
+    outfile->close();
+    delete outfile;
+  } catch (std::exception& err) {
+    std::cout << "Exception: " << err.what() << std::endl;
+  }
   return 0;
 }



From grumbel at mail.berlios.de  Sat Oct 21 03:54:25 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sat, 21 Oct 2006 03:54:25 +0200
Subject: [Flexlay-commit] r669 - trunk/netbrush/src
Message-ID: <200610210154.k9L1sP7I007587@sheep.berlios.de>

Author: grumbel
Date: 2006-10-21 03:54:22 +0200 (Sat, 21 Oct 2006)
New Revision: 669

Added:
   trunk/netbrush/src/controller.cpp
   trunk/netbrush/src/controller.hpp
Modified:
   trunk/netbrush/src/brush_widget.cpp
   trunk/netbrush/src/brush_widget.hpp
   trunk/netbrush/src/client.cpp
   trunk/netbrush/src/client_connection.cpp
Log:
- moved some brush stuff into controller

Modified: trunk/netbrush/src/brush_widget.cpp
===================================================================
--- trunk/netbrush/src/brush_widget.cpp	2006-10-20 23:15:53 UTC (rev 668)
+++ trunk/netbrush/src/brush_widget.cpp	2006-10-21 01:54:22 UTC (rev 669)
@@ -64,15 +64,8 @@
 }
 
 void 
-BrushWidget::set_brush(const GenericBrush& brush)
+BrushWidget::set_brush(GrayscaleBuffer* brushmask)
 {
-  GrayscaleBuffer* brushmask = generate_brushmask(brush.shape,
-                                                  brush.radius,
-                                                  brush.spikes,     // spikes
-                                                  brush.hardness,  // hardness
-                                                  brush.aspect_ratio,  // aspect
-                                                  brush.angle);
-  
   SDL_FillRect(surface, NULL, SDL_MapRGB(surface->format, 255, 255, 255));
   SDL_LockSurface(surface);
   Uint8* data = static_cast<Uint8*>(surface->pixels);
@@ -106,96 +99,6 @@
       
   SDL_UnlockSurface(surface); 
   set_dirty(true);
-
-  // FIXME: where is delete?!
-  client_draw_param->brush_file = "";
-  client_draw_param->brush_buffer = brushmask;
-
-  update_mouse_cursor();
 }
 
-void
-BrushWidget::update_mouse_cursor()
-{
-  if (client_draw_param->generic_brush.radius < 5.0f)
-    return ;
-
-  GrayscaleBuffer* brush = client_draw_param->brush_buffer;
-  
-  int w     = brush->get_width();
-  int pitch = brush->get_width()/8 + 1;
-  int h     = brush->get_height();
-  int len   = pitch * h;
-  Uint8 data[len];
-  Uint8 mask[len];
-
-  memset(data, 0, len);
-  memset(mask, 0, len);
-
-  for(int y = 1; y < brush->get_height()-1; ++y)
-    for(int x = 1; x < brush->get_width()-1; ++x)
-      {
-        int threshold = 64;
-
-        Uint8 check = 0;
-        if (((x / 1) % 2) ^ (y / 1) % 2)
-          check = 1;
-
-
-        if ((brush->at(x-1, y) < threshold && 
-             brush->at(x+1, y) > threshold)
-            ||
-            (brush->at(x-1, y) > threshold && 
-             brush->at(x+1, y) < threshold)
-            ||
-            (brush->at(x, y-1) < threshold && 
-             brush->at(x, y+1) > threshold)
-            ||
-            (brush->at(x, y-1) > threshold && 
-             brush->at(x, y+1) < threshold)
-            )
-          { // black
-            data[y * pitch + x/8] |= (check << (7 - (x%8)));
-            mask[y * pitch + x/8] |= (0x01 << (7 - (x%8)));
-          }
-      }
-  
-  if (w > 7 && h > 7)
-    {
-      int y = h / 2;
-      int x = 0;
-      for(x = w/2 - 3; x <= w/2 + 3; ++x)
-        {
-          data[y * pitch + x/8] |= (0x01 << (7 - (x%8)));
-          mask[y * pitch + x/8] |= (0x01 << (7 - (x%8)));
-        }
-
-      x = w / 2;
-      for(int y = h/2 - 3; y <= h/2 + 3; ++y)
-        {
-          data[y * pitch + x/8] |= (0x01 << (7 - (x%8)));
-          mask[y * pitch + x/8] |= (0x01 << (7 - (x%8)));
-        }
-
-
-      y = h / 2;
-      for(x = w/2 - 1; x <= w/2 + 1; ++x)
-        {
-          data[y * pitch + x/8] ^= (0x01 << (7 - (x%8)));
-          mask[y * pitch + x/8] |= (0x01 << (7 - (x%8)));
-        }
-      
-      x = w / 2;
-      for(int y = h/2 - 1; y <= h/2 + 1; ++y)
-        {
-          data[y * pitch + x/8] ^= (0x01 << (7 - (x%8)));
-          mask[y * pitch + x/8] |= (0x01 << (7 - (x%8)));
-        }
-    }
-
-  SDL_Cursor* cursor = SDL_CreateCursor(data, mask, pitch*8, h, 
-                                        w/2, h/2);
-  SDL_SetCursor(cursor);
-}
-
 /* EOF */

Modified: trunk/netbrush/src/brush_widget.hpp
===================================================================
--- trunk/netbrush/src/brush_widget.hpp	2006-10-20 23:15:53 UTC (rev 668)
+++ trunk/netbrush/src/brush_widget.hpp	2006-10-21 01:54:22 UTC (rev 669)
@@ -46,10 +46,8 @@
   void on_leave() {}
 
   void draw(SDL_Surface* target);
-  void set_brush(const GenericBrush& brush);
+  void set_brush(GrayscaleBuffer* brushmask);
 
-  void update_mouse_cursor();
-
 private:
   BrushWidget (const BrushWidget&);
   BrushWidget& operator= (const BrushWidget&);

Modified: trunk/netbrush/src/client.cpp
===================================================================
--- trunk/netbrush/src/client.cpp	2006-10-20 23:15:53 UTC (rev 668)
+++ trunk/netbrush/src/client.cpp	2006-10-21 01:54:22 UTC (rev 669)
@@ -317,8 +317,7 @@
                                            screen->w - 128 - 18 - 2 - 2, screen->h - 2)));
     
     brush_widget = new BrushWidget(Rect(Point(screen->w-128, 128+24+24), Size(128, 128)));
-    brush_widget->set_brush(client_draw_param->generic_brush);
-
+    
     widget_manager->add(brush_widget);
 
     // Main Loop

Modified: trunk/netbrush/src/client_connection.cpp
===================================================================
--- trunk/netbrush/src/client_connection.cpp	2006-10-20 23:15:53 UTC (rev 668)
+++ trunk/netbrush/src/client_connection.cpp	2006-10-21 01:54:22 UTC (rev 669)
@@ -127,7 +127,7 @@
           printf( "Error: SDLNet_TCP_Send: '%s'\n", SDLNet_GetError() );
           invalid = true;
         }
-      std::cout << "done" << std::endl;
+      //std::cout << "done" << std::endl;
     }
 }
 

Added: trunk/netbrush/src/controller.cpp
===================================================================
--- trunk/netbrush/src/controller.cpp	2006-10-20 23:15:53 UTC (rev 668)
+++ trunk/netbrush/src/controller.cpp	2006-10-21 01:54:22 UTC (rev 669)
@@ -0,0 +1,270 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#include <iostream>
+#include "video.hpp"
+#include "alpha_picker.hpp"
+#include "hue_picker.hpp"
+#include "saturation_value_picker.hpp"
+#include "globals.hpp"
+#include "drawing_parameter.hpp"
+#include "widget/slider_widget.hpp"
+#include "brush_widget.hpp"
+#include "widget/widget_manager.hpp"
+#include "controller.hpp"
+
+class RadiusCallback : public SliderCallback
+{
+public:
+  void operator()(float v) {
+    controller->set_generic_brush_radius(v * 100.0f + 0.1f);
+  }
+};
+
+class SpikeCallback : public SliderCallback
+{
+public:
+  void operator()(float v) {
+    controller->set_generic_brush_spikes(int(v*18) + 2);
+  }
+};
+
+class HardnessCallback : public SliderCallback
+{
+public:
+  void operator()(float v) {
+    controller->set_generic_brush_hardness(v);
+  }
+};
+
+class AspectRatioCallback : public SliderCallback
+{
+public:
+  void operator()(float v) {
+    controller->set_generic_brush_aspect_ratio(v*19.0f + 1.0f);
+  }
+};
+
+class AngleCallback : public SliderCallback
+{
+public:
+  void operator()(float v) 
+  {
+    controller->set_generic_brush_angle(v * 180.0f);
+  }
+};
+
+Controller::Controller()
+{
+  // Color Selection
+  alpha_picker            = new AlphaPicker(Rect(Point(screen->w-128, 128+24), Size(128, 24)));
+  saturation_value_picker = new SaturationValuePicker(Rect(Point(screen->w-128, 0), Size(128, 128)));
+  hue_picker              = new HuePicker(Rect(Point(screen->w-128, 128), Size(128, 24)));
+
+  widget_manager->add(saturation_value_picker);
+  widget_manager->add(hue_picker);
+  widget_manager->add(alpha_picker);
+
+  // Brush Slider
+  radius_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(0)), Size(128, 24)),
+                                   new RadiusCallback());
+  
+  spike_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(1)), Size(128, 24)),
+                                  new SpikeCallback());
+  
+  hardness_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(2)), Size(128, 24)),
+                                     new HardnessCallback());
+  
+  aspect_ratio_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(3)), Size(128, 24)),
+                                         new AspectRatioCallback());
+  
+  angle_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(4)), Size(128, 24)),
+                                  new AngleCallback());
+  widget_manager->add(radius_slider);
+  widget_manager->add(spike_slider);
+  widget_manager->add(hardness_slider);
+  widget_manager->add(aspect_ratio_slider);
+  widget_manager->add(angle_slider);
+}
+
+void
+Controller::set_color_hue(Uint8 hue_)
+{
+  hue = hue_;
+  client_draw_param->color = Color::from_hue(hue);
+  saturation_value_picker->set_color(client_draw_param->color);
+  alpha_picker->set_color(client_draw_param->color);
+}
+
+void
+Controller::set_color_value_saturation(Uint8 value_, Uint8 saturation_)
+{
+  value = value_;
+  saturation = saturation_;
+
+  Color color = Color::from_hue(hue);
+  color.apply_value_saturation(value, saturation);
+  alpha_picker->set_color(color);
+  client_draw_param->color = color;
+}
+
+void
+Controller::set_generic_brush_shape(BrushShape shape)
+{
+  client_draw_param->generic_brush.shape = shape;
+  set_generic_brush(client_draw_param->generic_brush);
+}
+
+void
+Controller::set_generic_brush_radius(float radius)
+{
+  client_draw_param->generic_brush.radius = radius;
+  set_generic_brush(client_draw_param->generic_brush);
+}
+
+void
+Controller::set_generic_brush_spikes(int spikes)
+{
+  client_draw_param->generic_brush.spikes = spikes;
+  set_generic_brush(client_draw_param->generic_brush);
+}
+
+void
+Controller::set_generic_brush_hardness(float hardness)
+{
+  client_draw_param->generic_brush.hardness = hardness;
+  set_generic_brush(client_draw_param->generic_brush);
+}
+
+void
+Controller::set_generic_brush_aspect_ratio(float aspect_ratio)
+{
+  client_draw_param->generic_brush.aspect_ratio = aspect_ratio;
+  set_generic_brush(client_draw_param->generic_brush);
+}
+
+void
+Controller::set_generic_brush_angle(float angle)
+{
+  client_draw_param->generic_brush.angle = angle;
+  set_generic_brush(client_draw_param->generic_brush);
+}
+
+void
+Controller::set_generic_brush(const GenericBrush& brush)
+{
+  // FIXME: Shouldn't allocate stuff outside of class
+  delete client_draw_param->brush_buffer;
+  client_draw_param->brush_buffer = brush.generate();
+  brush_widget->set_brush(client_draw_param->brush_buffer);
+
+  update_mouse_cursor();
+}
+
+void
+Controller::update_mouse_cursor()
+{
+  if (client_draw_param->generic_brush.radius < 5.0f)
+    return ;
+
+  GrayscaleBuffer* brush = client_draw_param->brush_buffer;
+  
+  int w     = brush->get_width();
+  int pitch = brush->get_width()/8 + 1;
+  int h     = brush->get_height();
+  int len   = pitch * h;
+  Uint8 data[len];
+  Uint8 mask[len];
+
+  memset(data, 0, len);
+  memset(mask, 0, len);
+
+  for(int y = 1; y < brush->get_height()-1; ++y)
+    for(int x = 1; x < brush->get_width()-1; ++x)
+      {
+        int threshold = 64;
+
+        Uint8 check = 0;
+        if (((x / 1) % 2) ^ (y / 1) % 2)
+          check = 1;
+
+
+        if ((brush->at(x-1, y) < threshold && 
+             brush->at(x+1, y) > threshold)
+            ||
+            (brush->at(x-1, y) > threshold && 
+             brush->at(x+1, y) < threshold)
+            ||
+            (brush->at(x, y-1) < threshold && 
+             brush->at(x, y+1) > threshold)
+            ||
+            (brush->at(x, y-1) > threshold && 
+             brush->at(x, y+1) < threshold)
+            )
+          { // black
+            data[y * pitch + x/8] |= (check << (7 - (x%8)));
+            mask[y * pitch + x/8] |= (0x01 << (7 - (x%8)));
+          }
+      }
+  
+  if (w > 7 && h > 7)
+    {
+      int y = h / 2;
+      int x = 0;
+      for(x = w/2 - 3; x <= w/2 + 3; ++x)
+        {
+          data[y * pitch + x/8] |= (0x01 << (7 - (x%8)));
+          mask[y * pitch + x/8] |= (0x01 << (7 - (x%8)));
+        }
+
+      x = w / 2;
+      for(int y = h/2 - 3; y <= h/2 + 3; ++y)
+        {
+          data[y * pitch + x/8] |= (0x01 << (7 - (x%8)));
+          mask[y * pitch + x/8] |= (0x01 << (7 - (x%8)));
+        }
+
+
+      y = h / 2;
+      for(x = w/2 - 1; x <= w/2 + 1; ++x)
+        {
+          data[y * pitch + x/8] ^= (0x01 << (7 - (x%8)));
+          mask[y * pitch + x/8] |= (0x01 << (7 - (x%8)));
+        }
+      
+      x = w / 2;
+      for(int y = h/2 - 1; y <= h/2 + 1; ++y)
+        {
+          data[y * pitch + x/8] ^= (0x01 << (7 - (x%8)));
+          mask[y * pitch + x/8] |= (0x01 << (7 - (x%8)));
+        }
+    }
+
+  SDL_Cursor* cursor = SDL_CreateCursor(data, mask, pitch*8, h, 
+                                        w/2, h/2);
+  SDL_SetCursor(cursor);
+}
+
+/* EOF */

Added: trunk/netbrush/src/controller.hpp
===================================================================
--- trunk/netbrush/src/controller.hpp	2006-10-20 23:15:53 UTC (rev 668)
+++ trunk/netbrush/src/controller.hpp	2006-10-21 01:54:22 UTC (rev 669)
@@ -0,0 +1,77 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#ifndef HEADER_CONTROLLER_HPP
+#define HEADER_CONTROLLER_HPP
+
+#include "saturation_value_picker.hpp"
+#include "alpha_picker.hpp"
+#include "hue_picker.hpp"
+#include "generic_brush.hpp"
+
+class SliderWidget;
+
+/** */
+class Controller
+{
+private:
+  SaturationValuePicker* saturation_value_picker;
+  HuePicker*             hue_picker;
+  AlphaPicker*           alpha_picker;
+
+  SliderWidget* radius_slider;
+  SliderWidget* spike_slider;
+  SliderWidget* hardness_slider;
+  SliderWidget* aspect_ratio_slider;
+  SliderWidget* angle_slider;
+  
+  Uint8 hue;
+  Uint8 saturation;
+  Uint8 value;
+
+public:
+  Controller();
+  ~Controller();
+
+  void set_color_hue(Uint8 hue);
+  void set_color_value_saturation(Uint8 value, Uint8 saturation);
+
+  void set_generic_brush_shape(BrushShape shape);
+  void set_generic_brush_radius(float radius);
+  void set_generic_brush_spikes(int spikes);
+  void set_generic_brush_hardness(float hardness);
+  void set_generic_brush_aspect_ratio(float aspect_ratio);
+  void set_generic_brush_angle(float angle);
+  void set_generic_brush(const GenericBrush& brush);
+
+  void update_mouse_cursor();
+private:
+  Controller (const Controller&);
+  Controller& operator= (const Controller&);
+};
+
+#endif
+
+/* EOF */



From grumbel at mail.berlios.de  Sat Oct 21 04:11:20 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sat, 21 Oct 2006 04:11:20 +0200
Subject: [Flexlay-commit] r670 - trunk/netbrush/src
Message-ID: <200610210211.k9L2BKL2009253@sheep.berlios.de>

Author: grumbel
Date: 2006-10-21 04:11:19 +0200 (Sat, 21 Oct 2006)
New Revision: 670

Modified:
   trunk/netbrush/src/controller.cpp
Log:
- changed stack allocation to heap

Modified: trunk/netbrush/src/controller.cpp
===================================================================
--- trunk/netbrush/src/controller.cpp	2006-10-21 01:54:22 UTC (rev 669)
+++ trunk/netbrush/src/controller.cpp	2006-10-21 02:11:19 UTC (rev 670)
@@ -195,8 +195,8 @@
   int pitch = brush->get_width()/8 + 1;
   int h     = brush->get_height();
   int len   = pitch * h;
-  Uint8 data[len];
-  Uint8 mask[len];
+  Uint8* data = new Uint8[len];
+  Uint8* mask = new Uint8[len];
 
   memset(data, 0, len);
   memset(mask, 0, len);
@@ -265,6 +265,9 @@
   SDL_Cursor* cursor = SDL_CreateCursor(data, mask, pitch*8, h, 
                                         w/2, h/2);
   SDL_SetCursor(cursor);
+
+  delete[] mask;
+  delete[] data;
 }
 
 /* EOF */



From grumbel at mail.berlios.de  Mon Oct 23 22:57:11 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Mon, 23 Oct 2006 22:57:11 +0200
Subject: [Flexlay-commit] r671 - in trunk/netbrush: . data/icons sessions
	src src/widget
Message-ID: <200610232057.k9NKvBHc025146@sheep.berlios.de>

Author: grumbel
Date: 2006-10-23 22:57:09 +0200 (Mon, 23 Oct 2006)
New Revision: 671

Added:
   trunk/netbrush/data/icons/stock-tool-color-picker-22.png
   trunk/netbrush/src/airbrush_tool.cpp
   trunk/netbrush/src/airbrush_tool.hpp
   trunk/netbrush/src/color.cpp
   trunk/netbrush/src/colorpicker_tool.cpp
   trunk/netbrush/src/colorpicker_tool.hpp
   trunk/netbrush/src/paintbrush_tool.cpp
   trunk/netbrush/src/paintbrush_tool.hpp
   trunk/netbrush/src/scroll_tool.cpp
   trunk/netbrush/src/scroll_tool.hpp
   trunk/netbrush/src/tool.hpp
Modified:
   trunk/netbrush/SConstruct
   trunk/netbrush/sessions/
   trunk/netbrush/src/client.cpp
   trunk/netbrush/src/color.hpp
   trunk/netbrush/src/controller.cpp
   trunk/netbrush/src/drawing_parameter.hpp
   trunk/netbrush/src/navigation.cpp
   trunk/netbrush/src/screen_buffer.cpp
   trunk/netbrush/src/screen_buffer.hpp
   trunk/netbrush/src/stroke_buffer.hpp
   trunk/netbrush/src/widget/events.hpp
Log:
- splitted Tool out of ScreenBuffer

Modified: trunk/netbrush/SConstruct
===================================================================
--- trunk/netbrush/SConstruct	2006-10-21 02:11:19 UTC (rev 670)
+++ trunk/netbrush/SConstruct	2006-10-23 20:57:09 UTC (rev 671)
@@ -57,6 +57,11 @@
         'src/navigation.cpp',
         'src/graphic_context_state.cpp',
         'src/controller.cpp',
+        'src/airbrush_tool.cpp',
+        'src/paintbrush_tool.cpp',
+        'src/scroll_tool.cpp',
+        'src/colorpicker_tool.cpp',
+        'src/color.cpp',
 #        'src/widget/events.cpp',
 ])
 

Added: trunk/netbrush/data/icons/stock-tool-color-picker-22.png
===================================================================
(Binary files differ)


Property changes on: trunk/netbrush/data/icons/stock-tool-color-picker-22.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream


Property changes on: trunk/netbrush/sessions
___________________________________________________________________
Name: svn:ignore
   + *.nbr


Added: trunk/netbrush/src/airbrush_tool.cpp
===================================================================
--- trunk/netbrush/src/airbrush_tool.cpp	2006-10-21 02:11:19 UTC (rev 670)
+++ trunk/netbrush/src/airbrush_tool.cpp	2006-10-23 20:57:09 UTC (rev 671)
@@ -0,0 +1,95 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#include "globals.hpp"
+#include "stroke.hpp"
+#include "stroke_buffer.hpp"
+#include "screen_buffer.hpp"
+#include "server_connection.hpp"
+#include "drawing_parameter.hpp"
+#include "widget/widget_manager.hpp"
+#include "airbrush_tool.hpp"
+
+AirbrushTool::AirbrushTool()
+{
+}
+
+AirbrushTool::~AirbrushTool()
+{
+}
+
+void
+AirbrushTool::on_motion(const ToolMotionEvent& ev)
+{
+  if (current_stroke)
+    {
+      current_stroke->add_dab(Dab(ev.x, ev.y));
+      stroke_buffer->add_dab(Dab(ev.x, ev.y));
+
+      // sync
+      Rect rect = current_stroke->get_bounding_rect(); 
+              
+      // calculate bounding rectangle by taking brush thickness into account
+      // FIXME: Handle x/y thickness independetly to get a smaller clip rect
+      rect.left -= client_draw_param->thickness()/2;
+      rect.top  -= client_draw_param->thickness()/2;
+
+      rect.right  += client_draw_param->thickness()/2;
+      rect.bottom += client_draw_param->thickness()/2;
+                  
+      screen_buffer->mark_dirty(rect);
+    } 
+}
+
+void
+AirbrushTool::on_button_press(const ToolButtonEvent& ev)
+{
+  widget_manager->grab(screen_buffer); // FIXME: ugly out of place widget class abuse
+
+  // FIXME: activate this and test: delete current_stroke;
+
+  current_stroke = new Stroke();
+
+  current_stroke->add_dab(Dab(ev.x, ev.y));
+  stroke_buffer->add_dab(Dab(ev.x, ev.y));
+
+  // FIXME: First dab is lost
+}
+
+void
+AirbrushTool::on_button_release(const ToolButtonEvent& ev)
+{
+  if (current_stroke)
+    {
+      widget_manager->ungrab(screen_buffer); // FIXME: ugly out of place widget class abuse
+
+      stroke_buffer->clear();
+      server->send_stroke(*current_stroke, client_draw_param);
+
+      current_stroke = 0;
+    }
+}
+
+/* EOF */

Added: trunk/netbrush/src/airbrush_tool.hpp
===================================================================
--- trunk/netbrush/src/airbrush_tool.hpp	2006-10-21 02:11:19 UTC (rev 670)
+++ trunk/netbrush/src/airbrush_tool.hpp	2006-10-23 20:57:09 UTC (rev 671)
@@ -0,0 +1,51 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#ifndef HEADER_AIRBRUSH_TOOL_HPP
+#define HEADER_AIRBRUSH_TOOL_HPP
+
+#include "tool.hpp"
+
+/** */
+class AirbrushTool : public Tool
+{
+private:
+
+public:
+  AirbrushTool();
+  ~AirbrushTool();
+
+  void on_motion(const ToolMotionEvent& ev);
+  void on_button_press(const ToolButtonEvent& ev);
+  void on_button_release(const ToolButtonEvent& ev);
+
+private:
+  AirbrushTool (const AirbrushTool&);
+  AirbrushTool& operator= (const AirbrushTool&);
+};
+
+#endif
+
+/* EOF */

Modified: trunk/netbrush/src/client.cpp
===================================================================
--- trunk/netbrush/src/client.cpp	2006-10-21 02:11:19 UTC (rev 670)
+++ trunk/netbrush/src/client.cpp	2006-10-23 20:57:09 UTC (rev 671)
@@ -122,33 +122,6 @@
     }  
 }
 
-class ToolButtonCallback : public ButtonCallback
-{
-private:
-  DrawingParameter::Tool tool;
-public:
-  ToolButtonCallback(DrawingParameter::Tool tool_)
-    : tool(tool_)
-  {
-  }
-
-  void on_press  (Button* button) 
-  {
-    //std::cout << "Press: " << button << std::endl;
-  }
-
-  void on_release(Button* button) 
-  {
-    //std::cout << "Release: " << button << std::endl;
-  }
-  
-  void on_click  (Button* button) 
-  {
-    //std::cout << "Setting tool: " << tool << std::endl;
-    client_draw_param->tool = tool;
-  }
-};
-
 int main(int argc, char** argv)
 {
   try {
@@ -282,17 +255,6 @@
 
     widget_manager->add(navigation = new Navigation(Rect(Point(screen->w - 128 - 2, screen->h - 128 - 2),
                                                          Size(128, 128))));
-    widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-airbrush-22.png"), 
-                                   Rect(Point(2, 2+0*34), Size(34, 34)),
-                                   new ToolButtonCallback(DrawingParameter::TOOL_AIRBRUSH)));
-    widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-paintbrush-22.png"), 
-                                   Rect(Point(2, 2+1*34), Size(34, 34)),
-                                   new ToolButtonCallback(DrawingParameter::TOOL_PAINTBRUSH)));
-    if (0)
-      widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-zoom-22.png"), 
-                                     Rect(Point(2, 2+2*34), Size(34, 34)),
-                                     new ToolButtonCallback(DrawingParameter::TOOL_PAINTBRUSH)));
-
     {
       SDL_Rect color_rect;
       color_rect.x = 768;

Added: trunk/netbrush/src/color.cpp
===================================================================
--- trunk/netbrush/src/color.cpp	2006-10-21 02:11:19 UTC (rev 670)
+++ trunk/netbrush/src/color.cpp	2006-10-23 20:57:09 UTC (rev 671)
@@ -0,0 +1,112 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#include <algorithm>
+#include "color.hpp"
+
+HSVColor::HSVColor()
+  : hue(0), saturation(0), value(0)
+{
+}
+
+HSVColor
+HSVColor::from_rgb(const Color& color)
+{ // untested
+  HSVColor hsvcolor;
+    
+  Uint8 min = std::min(std::min(color.r, color.g), color.b);
+  Uint8 max = std::max(std::max(color.r, color.g), color.b);
+
+  if (min == max)
+    {
+      hsvcolor.hue = 0;
+    }
+  else
+    {
+      if (max == color.r)
+        hsvcolor.hue = (0 + (color.g - color.b) / (max - min)) * 43;
+      else if (max == color.g)
+        hsvcolor.hue = (2 + (color.b - color.r) / (max - min)) * 43;
+      else if (max == color.b)
+        hsvcolor.hue = (4 + (color.r - color.g) / (max - min)) * 43;
+    }
+
+  if (max == 0)
+    hsvcolor.saturation = 0;
+  else
+    hsvcolor.saturation = 255 * (max - min) / max;
+
+  hsvcolor.value = 255 * max;
+
+  return hsvcolor;
+}
+
+Color::Color()
+  : r(0), g(0), b(0)
+{}
+
+Color::Color(Uint8 r_, Uint8 g_, Uint8 b_)
+  : r(r_), g(g_), b(b_)
+{}
+
+Color
+Color::from_hsv(Uint8 hue, Uint8 saturation, Uint8 value)
+{
+  Color color = Color::from_hue(hue);
+  color.apply_value_saturation(value, saturation);
+  return color;
+}
+  
+  
+
+Color
+Color::from_hue(Uint8 hue)
+{
+  static Color colors[] = { Color(255,   0,   0),
+                            Color(255,   0, 255),
+                            Color(  0,   0, 255),
+                            Color(  0, 255, 255),
+                            Color(  0, 255,   0),
+                            Color(255, 255,   0),
+                            Color(255,   0,   0) };
+  
+  int seg_len = (255/6);
+  int seg  = (hue / seg_len);
+  int prog = (hue % seg_len);
+
+  return Color((((seg_len - prog) * colors[seg].r) + (prog * colors[seg+1].r))/seg_len,
+               (((seg_len - prog) * colors[seg].g) + (prog * colors[seg+1].g))/seg_len,
+               (((seg_len - prog) * colors[seg].b) + (prog * colors[seg+1].b))/seg_len);
+}
+
+void
+Color::apply_value_saturation(Uint8 value, Uint8 saturation)
+{
+  r = (0*value + (255-value) * ((255 * saturation + r * (255 - saturation))/255))/255;
+  g = (0*value + (255-value) * ((255 * saturation + g * (255 - saturation))/255))/255;
+  b = (0*value + (255-value) * ((255 * saturation + b * (255 - saturation))/255))/255;
+}
+
+/* EOF */

Modified: trunk/netbrush/src/color.hpp
===================================================================
--- trunk/netbrush/src/color.hpp	2006-10-21 02:11:19 UTC (rev 670)
+++ trunk/netbrush/src/color.hpp	2006-10-23 20:57:09 UTC (rev 671)
@@ -28,45 +28,30 @@
 
 #include "SDL.h"
 
-struct Color
+struct Color;
+
+struct HSVColor
 {
-  Color()
-    : r(0), g(0), b(0)
-  {}
+public:
+  Uint8 hue;
+  Uint8 saturation;
+  Uint8 value;
+  
+  HSVColor();
+  static HSVColor from_rgb(const Color& color);
+};
 
-  Color(Uint8 r_, Uint8 g_, Uint8 b_)
-    : r(r_), g(g_), b(b_)
-  {}
-
+struct Color
+{
   Uint8 r;
   Uint8 g;
   Uint8 b;
 
-  static Color from_hue(Uint8 hue)
-  {
-    static Color colors[] = { Color(255,   0,   0),
-                              Color(255,   0, 255),
-                              Color(  0,   0, 255),
-                              Color(  0, 255, 255),
-                              Color(  0, 255,   0),
-                              Color(255, 255,   0),
-                              Color(255,   0,   0) };
-  
-    int seg_len = (255/6);
-    int seg  = (hue / seg_len);
-    int prog = (hue % seg_len);
-
-    return Color((((seg_len - prog) * colors[seg].r) + (prog * colors[seg+1].r))/seg_len,
-                 (((seg_len - prog) * colors[seg].g) + (prog * colors[seg+1].g))/seg_len,
-                 (((seg_len - prog) * colors[seg].b) + (prog * colors[seg+1].b))/seg_len);
-  }
-
-  void apply_value_saturation(Uint8 value, Uint8 saturation)
-  {
-    r = (0*value + (255-value) * ((255 * saturation + r * (255 - saturation))/255))/255;
-    g = (0*value + (255-value) * ((255 * saturation + g * (255 - saturation))/255))/255;
-    b = (0*value + (255-value) * ((255 * saturation + b * (255 - saturation))/255))/255;
-  }
+  Color();
+  Color(Uint8 r_, Uint8 g_, Uint8 b_);
+  static Color from_hsv(Uint8 hue, Uint8 saturation, Uint8 value);
+  static Color from_hue(Uint8 hue);
+  void apply_value_saturation(Uint8 value, Uint8 saturation);
 };
 
 #endif

Added: trunk/netbrush/src/colorpicker_tool.cpp
===================================================================
--- trunk/netbrush/src/colorpicker_tool.cpp	2006-10-21 02:11:19 UTC (rev 670)
+++ trunk/netbrush/src/colorpicker_tool.cpp	2006-10-23 20:57:09 UTC (rev 671)
@@ -0,0 +1,51 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#include "colorpicker_tool.hpp"
+
+ColorpickerTool::ColorpickerTool()
+{
+}
+
+ColorpickerTool::~ColorpickerTool()
+{
+}
+
+void
+ColorpickerTool::on_motion(const ToolMotionEvent& ev)
+{
+}
+
+void
+ColorpickerTool::on_button_press(const ToolButtonEvent& ev)
+{
+}
+
+void
+ColorpickerTool::on_button_release(const ToolButtonEvent& ev)
+{
+}
+
+/* EOF */

Added: trunk/netbrush/src/colorpicker_tool.hpp
===================================================================
--- trunk/netbrush/src/colorpicker_tool.hpp	2006-10-21 02:11:19 UTC (rev 670)
+++ trunk/netbrush/src/colorpicker_tool.hpp	2006-10-23 20:57:09 UTC (rev 671)
@@ -0,0 +1,49 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#ifndef HEADER_COLORPICKER_TOOL_HPP
+#define HEADER_COLORPICKER_TOOL_HPP
+
+#include "tool.hpp"
+
+/** */
+class ColorpickerTool : public Tool
+{
+private:
+public:
+  ColorpickerTool();
+  ~ColorpickerTool();
+
+  void on_motion(const ToolMotionEvent& ev);
+  void on_button_press(const ToolButtonEvent& ev);
+  void on_button_release(const ToolButtonEvent& ev);
+private:
+  ColorpickerTool (const ColorpickerTool&);
+  ColorpickerTool& operator= (const ColorpickerTool&);
+};
+
+#endif
+
+/* EOF */

Modified: trunk/netbrush/src/controller.cpp
===================================================================
--- trunk/netbrush/src/controller.cpp	2006-10-21 02:11:19 UTC (rev 670)
+++ trunk/netbrush/src/controller.cpp	2006-10-23 20:57:09 UTC (rev 671)
@@ -32,6 +32,7 @@
 #include "drawing_parameter.hpp"
 #include "widget/slider_widget.hpp"
 #include "brush_widget.hpp"
+#include "widget/button.hpp"
 #include "widget/widget_manager.hpp"
 #include "controller.hpp"
 
@@ -76,8 +77,46 @@
   }
 };
 
+class ToolButtonCallback : public ButtonCallback
+{
+private:
+  DrawingParameter::Tool tool;
+public:
+  ToolButtonCallback(DrawingParameter::Tool tool_)
+    : tool(tool_)
+  {
+  }
+
+  void on_press  (Button* button) 
+  {
+    //std::cout << "Press: " << button << std::endl;
+  }
+
+  void on_release(Button* button) 
+  {
+    //std::cout << "Release: " << button << std::endl;
+  }
+  
+  void on_click  (Button* button) 
+  {
+    //std::cout << "Setting tool: " << tool << std::endl;
+    client_draw_param->tool = tool;
+  }
+};
+
 Controller::Controller()
 {
+  // Toolbar
+    widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-airbrush-22.png"), 
+                                   Rect(Point(2, 2+0*34), Size(34, 34)),
+                                   new ToolButtonCallback(DrawingParameter::TOOL_AIRBRUSH)));
+    widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-paintbrush-22.png"), 
+                                   Rect(Point(2, 2+1*34), Size(34, 34)),
+                                   new ToolButtonCallback(DrawingParameter::TOOL_PAINTBRUSH)));
+    widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-color-picker-22.png"), 
+                                     Rect(Point(2, 2+2*34), Size(34, 34)),
+                                     new ToolButtonCallback(DrawingParameter::TOOL_COLOR_PICKER)));
+
   // Color Selection
   alpha_picker            = new AlphaPicker(Rect(Point(screen->w-128, 128+24), Size(128, 24)));
   saturation_value_picker = new SaturationValuePicker(Rect(Point(screen->w-128, 0), Size(128, 128)));
@@ -107,6 +146,7 @@
   widget_manager->add(hardness_slider);
   widget_manager->add(aspect_ratio_slider);
   widget_manager->add(angle_slider);
+
 }
 
 void

Modified: trunk/netbrush/src/drawing_parameter.hpp
===================================================================
--- trunk/netbrush/src/drawing_parameter.hpp	2006-10-21 02:11:19 UTC (rev 670)
+++ trunk/netbrush/src/drawing_parameter.hpp	2006-10-23 20:57:09 UTC (rev 671)
@@ -37,7 +37,7 @@
 class DrawingParameter
 {
 public:
-  enum Tool { TOOL_AIRBRUSH, TOOL_PAINTBRUSH };
+  enum Tool { TOOL_AIRBRUSH, TOOL_PAINTBRUSH, TOOL_COLOR_PICKER };
   Tool             tool;
   std::string      brush_file;
   GenericBrush     generic_brush;

Modified: trunk/netbrush/src/navigation.cpp
===================================================================
--- trunk/netbrush/src/navigation.cpp	2006-10-21 02:11:19 UTC (rev 670)
+++ trunk/netbrush/src/navigation.cpp	2006-10-23 20:57:09 UTC (rev 671)
@@ -41,8 +41,8 @@
 {
   if (dragging)
     {
-      screen_buffer->move_to(draw_ctx->get_width()  * motion.x / get_rect().get_width(),
-                             draw_ctx->get_height() * motion.y / get_rect().get_height());
+      screen_buffer->move_to(Point(draw_ctx->get_width()  * motion.x / get_rect().get_width(),
+                                   draw_ctx->get_height() * motion.y / get_rect().get_height()));
     }
 }
 
@@ -53,14 +53,14 @@
     {
       if (button.state == SDL_RELEASED)
         {
-          screen_buffer->move_to(draw_ctx->get_width()  * button.x / get_rect().get_width(),
-                                 draw_ctx->get_height() * button.y / get_rect().get_height());
+          screen_buffer->move_to(Point(draw_ctx->get_width()  * button.x / get_rect().get_width(),
+                                       draw_ctx->get_height() * button.y / get_rect().get_height()));
           dragging = false;
         }
       else if (button.state == SDL_PRESSED)
         {
-          screen_buffer->move_to(draw_ctx->get_width()  * button.x / get_rect().get_width(),
-                                 draw_ctx->get_height() * button.y / get_rect().get_height());
+          screen_buffer->move_to(Point(draw_ctx->get_width()  * button.x / get_rect().get_width(),
+                                       draw_ctx->get_height() * button.y / get_rect().get_height()));
           dragging = true;
         }
     }

Added: trunk/netbrush/src/paintbrush_tool.cpp
===================================================================
--- trunk/netbrush/src/paintbrush_tool.cpp	2006-10-21 02:11:19 UTC (rev 670)
+++ trunk/netbrush/src/paintbrush_tool.cpp	2006-10-23 20:57:09 UTC (rev 671)
@@ -0,0 +1,52 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#include "paintbrush_tool.hpp"
+
+PaintbrushTool::PaintbrushTool()
+{
+}
+
+PaintbrushTool::~PaintbrushTool()
+{
+}
+
+void
+PaintbrushTool::on_motion(const ToolMotionEvent& ev)
+{
+}
+
+void
+PaintbrushTool::on_button_press(const ToolButtonEvent& ev)
+{
+}
+
+void
+PaintbrushTool::on_button_release(const ToolButtonEvent& ev)
+{
+  
+}
+
+/* EOF */

Added: trunk/netbrush/src/paintbrush_tool.hpp
===================================================================
--- trunk/netbrush/src/paintbrush_tool.hpp	2006-10-21 02:11:19 UTC (rev 670)
+++ trunk/netbrush/src/paintbrush_tool.hpp	2006-10-23 20:57:09 UTC (rev 671)
@@ -0,0 +1,50 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#ifndef HEADER_PAINTBRUSH_TOOL_HPP
+#define HEADER_PAINTBRUSH_TOOL_HPP
+
+#include "tool.hpp"
+
+/** */
+class PaintbrushTool : public Tool
+{
+private:
+public:
+  PaintbrushTool();
+  ~PaintbrushTool();
+
+  void on_motion(const ToolMotionEvent& ev);
+  void on_button_press(const ToolButtonEvent& ev);
+  void on_button_release(const ToolButtonEvent& ev);
+
+private:
+  PaintbrushTool (const PaintbrushTool&);
+  PaintbrushTool& operator= (const PaintbrushTool&);
+};
+
+#endif
+
+/* EOF */

Modified: trunk/netbrush/src/screen_buffer.cpp
===================================================================
--- trunk/netbrush/src/screen_buffer.cpp	2006-10-21 02:11:19 UTC (rev 670)
+++ trunk/netbrush/src/screen_buffer.cpp	2006-10-23 20:57:09 UTC (rev 671)
@@ -33,19 +33,20 @@
 #include "globals.hpp"
 #include "server_connection.hpp"
 #include "widget/scrollbar.hpp"
+#include "tool.hpp"
+#include "airbrush_tool.hpp"
+#include "scroll_tool.hpp"
 #include "screen_buffer.hpp"
 
 ScreenBuffer::ScreenBuffer(const Rect& rect)
   : Widget(rect),
+    complete_refresh(false),
     scroll_offset_x(0),
-    scroll_offset_y(0),
-    old_scroll_offset_x(0),
-    old_scroll_offset_y(0),
-    click_pos_x(0),
-    click_pos_y(0),
-    scrolling(false),
-    complete_refresh(false)
+    scroll_offset_y(0)
 {
+  tools.push_back(new AirbrushTool());
+  tools.push_back(new ScrollTool());
+  tools.push_back(new AirbrushTool());
 }
 
 ScreenBuffer::~ScreenBuffer()
@@ -204,105 +205,64 @@
 void
 ScreenBuffer::on_mouse_motion(const MouseMotionEvent& motion)
 {
-  //satd::cout << motion.x << " " << motion.y << std::endl;
-  if (current_stroke)
-    {
-      current_stroke->add_dab(Dab(motion.x - scroll_offset_x, motion.y - scroll_offset_y));
-      stroke_buffer->add_dab(Dab(motion.x - scroll_offset_x, motion.y - scroll_offset_y));
+  ToolMotionEvent tool_motion;
 
-      // sync
-      Rect rect = current_stroke->get_bounding_rect(); 
-              
-      // calculate bounding rectangle by taking brush thickness into account
-      rect.left -= client_draw_param->thickness()/2;
-      rect.top  -= client_draw_param->thickness()/2;
+  tool_motion.x = motion.x - scroll_offset_x;
+  tool_motion.y = motion.y - scroll_offset_y;
 
-      rect.right  += client_draw_param->thickness()/2;
-      rect.bottom += client_draw_param->thickness()/2;
-                  
-      mark_dirty(rect);
-    }
-
-  if (scrolling)
-    {
-      scroll_offset_x = old_scroll_offset_x + (motion.x - click_pos_x);
-      scroll_offset_y = old_scroll_offset_y + (motion.y - click_pos_y);
-
-      Rect r(0, 0, get_rect().get_width(), get_rect().get_height());
-      r.left   -= scroll_offset_x;
-      r.right  -= scroll_offset_x;
-      r.top    -= scroll_offset_y;
-      r.bottom -= scroll_offset_y;
-      mark_dirty(r);
-      complete_refresh = true;
-      //std::cout << "Scrolling: " << scroll_offset_x << " " << scroll_offset_y << std::endl;
-    } 
+  tool_motion.screen = Point(motion.x, motion.y);
+  
+  for(Tools::iterator i = tools.begin(); i != tools.end(); ++i)
+    (*i)->on_motion(tool_motion);
 }
 
 void
 ScreenBuffer::on_mouse_button(const MouseButtonEvent& button)
 {
-  if (button.state == SDL_RELEASED)
-    {
-      if (button.button == 1)
-        {
-          if (current_stroke)
-            {
-              widget_manager->ungrab(this);
+  ToolButtonEvent tool_button;
 
-              stroke_buffer->clear();
-              server->send_stroke(*current_stroke, client_draw_param);
+  tool_button.screen = Point(button.x, button.y);
 
-              current_stroke = 0;
-            }
-        }
-      else if (button.button == 2)
-        {
-          scroll_offset_x = old_scroll_offset_x + (button.x - click_pos_x);
-          scroll_offset_y = old_scroll_offset_y + (button.y - click_pos_y);
-          scrolling = false;
-        }
-    }  
-  else if (button.state == SDL_PRESSED)
+  tool_button.x = button.x - scroll_offset_x;
+  tool_button.y = button.y - scroll_offset_y;
+  
+  if (button.button >= 1 && button.button <= int(tools.size()))
     {
-      if (button.button == 1)
-        {
-          widget_manager->grab(this);
-          current_stroke = new Stroke();
-
-          current_stroke->add_dab(Dab(button.x - scroll_offset_x, button.y - scroll_offset_y));
-          stroke_buffer->add_dab(Dab(button.x - scroll_offset_x, button.y - scroll_offset_y));
-
-          // FIXME: First dab is lost
-        }
-      else if (button.button == 2)
-        {
-          click_pos_x = button.x;
-          click_pos_y = button.y;
-
-          old_scroll_offset_x = scroll_offset_x;
-          old_scroll_offset_y = scroll_offset_y;
-
-          scrolling = true;
-        }
+      if (button.state == SDL_PRESSED)
+        tools[button.button-1]->on_button_press(tool_button);
+      else if (button.state == SDL_RELEASED)
+        tools[button.button-1]->on_button_release(tool_button);
     }
 }
 
 void
-ScreenBuffer::move_to(int x, int y)
+ScreenBuffer::force_full_refresh()
 {
-  scroll_offset_x = get_rect().get_width()/2  - x;
-  scroll_offset_y = get_rect().get_height()/2 - y;
-  //std::cout << "MoveTo: " << x << " " << y << std::endl;
-
-  Rect r(0, 0, get_rect().get_width(), get_rect().get_height());
+  // FIXME: Ugly! Add function for fullscreen refresh in screenbuffer
+  Rect r(0, 0, screen_buffer->get_rect().get_width(), screen_buffer->get_rect().get_height());
   r.left   -= scroll_offset_x;
   r.right  -= scroll_offset_x;
   r.top    -= scroll_offset_y;
   r.bottom -= scroll_offset_y;
-  mark_dirty(r);
+  screen_buffer->mark_dirty(r);
   complete_refresh = true;
   set_dirty(true);
 }
 
+void
+ScreenBuffer::move_to(const Point& p)
+{
+  scroll_offset_x = get_rect().get_width()/2  - p.x;
+  scroll_offset_y = get_rect().get_height()/2 - p.y;
+
+  force_full_refresh();
+}
+
+Point
+ScreenBuffer::get_pos()
+{
+  return Point(get_rect().get_width()/2  - scroll_offset_x,
+               get_rect().get_height()/2 - scroll_offset_y);
+}
+
 /* EOF */

Modified: trunk/netbrush/src/screen_buffer.hpp
===================================================================
--- trunk/netbrush/src/screen_buffer.hpp	2006-10-21 02:11:19 UTC (rev 670)
+++ trunk/netbrush/src/screen_buffer.hpp	2006-10-23 20:57:09 UTC (rev 671)
@@ -29,6 +29,8 @@
 #include "SDL.h"
 #include "widget/widget.hpp"
 
+class Tool;
+
 /** */
 class ScreenBuffer : public Widget
 {
@@ -36,17 +38,14 @@
   //SDL_Surface* buffer;
   Rect dirty_region;
 
+  bool scrolling;
+  bool complete_refresh;
+
   int scroll_offset_x;
   int scroll_offset_y;
 
-  int old_scroll_offset_x;
-  int old_scroll_offset_y;
-
-  int click_pos_x;
-  int click_pos_y;
-
-  bool scrolling;
-  bool complete_refresh;
+  typedef std::vector<Tool*> Tools;
+  Tools tools;
 public:
   ScreenBuffer(const Rect& rect);
   ~ScreenBuffer();
@@ -54,6 +53,7 @@
   // Mark an region as dirty in canvas space, not screen space
   void mark_dirty(int x, int y, int w, int h);
   void mark_dirty(const Rect& region);
+  void force_full_refresh();
   
   void draw(SDL_Surface* target);
 
@@ -65,8 +65,8 @@
 
   bool do_update() { return false; }
 
-  void move_to(int x, int y);
-
+  void move_to(const Point& p);
+  Point get_pos();
 private:
   ScreenBuffer (const ScreenBuffer&);
   ScreenBuffer& operator= (const ScreenBuffer&);

Added: trunk/netbrush/src/scroll_tool.cpp
===================================================================
--- trunk/netbrush/src/scroll_tool.cpp	2006-10-21 02:11:19 UTC (rev 670)
+++ trunk/netbrush/src/scroll_tool.cpp	2006-10-23 20:57:09 UTC (rev 671)
@@ -0,0 +1,73 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#include "globals.hpp"
+#include "screen_buffer.hpp"
+#include "math/rect.hpp"
+#include "scroll_tool.hpp"
+
+ScrollTool::ScrollTool()
+  : scrolling(false),
+    old_pos(0,0),
+    click_pos(0,0)
+{
+}
+
+ScrollTool::~ScrollTool()
+{
+}
+
+void
+ScrollTool::on_motion(const ToolMotionEvent& ev)
+{
+  if (scrolling)
+    {
+      screen_buffer->move_to(Point(old_pos.x - (ev.screen.x - click_pos.x),
+                                   old_pos.y - (ev.screen.y - click_pos.y)));
+    }
+}
+
+void
+ScrollTool::on_button_press(const ToolButtonEvent& ev)
+{
+  click_pos.x = ev.screen.x;
+  click_pos.y = ev.screen.y;
+
+  old_pos = screen_buffer->get_pos();
+
+  scrolling = true;
+}
+
+void
+ScrollTool::on_button_release(const ToolButtonEvent& ev)
+{ 
+  // FIXME: grab
+  screen_buffer->move_to(Point(old_pos.x - (ev.screen.x - click_pos.x),
+                               old_pos.y - (ev.screen.y - click_pos.y)));
+
+  scrolling = false;
+}
+
+/* EOF */

Added: trunk/netbrush/src/scroll_tool.hpp
===================================================================
--- trunk/netbrush/src/scroll_tool.hpp	2006-10-21 02:11:19 UTC (rev 670)
+++ trunk/netbrush/src/scroll_tool.hpp	2006-10-23 20:57:09 UTC (rev 671)
@@ -0,0 +1,55 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#ifndef HEADER_SCROLL_TOOL_HPP
+#define HEADER_SCROLL_TOOL_HPP
+
+#include "tool.hpp"
+
+/** */
+class ScrollTool : public Tool
+{
+private:
+  bool scrolling;
+
+  Point old_pos;
+  Point click_pos;
+
+public:
+  ScrollTool();
+  ~ScrollTool();
+
+  void on_motion(const ToolMotionEvent& ev);
+  void on_button_press(const ToolButtonEvent& ev);
+  void on_button_release(const ToolButtonEvent& ev);
+  
+private:
+  ScrollTool (const ScrollTool&);
+  ScrollTool& operator= (const ScrollTool&);
+};
+
+#endif
+
+/* EOF */

Modified: trunk/netbrush/src/stroke_buffer.hpp
===================================================================
--- trunk/netbrush/src/stroke_buffer.hpp	2006-10-21 02:11:19 UTC (rev 670)
+++ trunk/netbrush/src/stroke_buffer.hpp	2006-10-23 20:57:09 UTC (rev 671)
@@ -29,6 +29,7 @@
 class Rect;
 class DrawingParameter;
 class Dab;
+class GrayscaleBuffer;
 
 /** */
 class StrokeBuffer

Added: trunk/netbrush/src/tool.hpp
===================================================================
--- trunk/netbrush/src/tool.hpp	2006-10-21 02:11:19 UTC (rev 670)
+++ trunk/netbrush/src/tool.hpp	2006-10-23 20:57:09 UTC (rev 671)
@@ -0,0 +1,67 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#ifndef HEADER_TOOL_HPP
+#define HEADER_TOOL_HPP
+
+#include "math/point.hpp"
+#include "widget/events.hpp"
+
+struct ToolMotionEvent
+{
+  int x;
+  int y;
+
+  Point screen;
+};
+
+struct ToolButtonEvent
+{
+  int x;
+  int y;
+
+  Point screen;
+};
+
+/** */
+class Tool
+{
+private:
+public:
+  Tool() {}
+  virtual ~Tool() {}
+
+  virtual void on_motion(const ToolMotionEvent& ev) =0;
+  virtual void on_button_press(const ToolButtonEvent& ev) =0;
+  virtual void on_button_release(const ToolButtonEvent& ev) =0;
+
+private:
+  Tool (const Tool&);
+  Tool& operator= (const Tool&);
+};
+
+#endif
+
+/* EOF */

Modified: trunk/netbrush/src/widget/events.hpp
===================================================================
--- trunk/netbrush/src/widget/events.hpp	2006-10-21 02:11:19 UTC (rev 670)
+++ trunk/netbrush/src/widget/events.hpp	2006-10-23 20:57:09 UTC (rev 671)
@@ -26,6 +26,8 @@
 #ifndef HEADER_EVENTS_HPP
 #define HEADER_EVENTS_HPP
 
+#include "SDL.h"
+
 class MouseButtonEvent
 {
 public:



From grumbel at mail.berlios.de  Mon Oct 23 23:36:14 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Mon, 23 Oct 2006 23:36:14 +0200
Subject: [Flexlay-commit] r672 - in trunk/netbrush: . src
Message-ID: <200610232136.k9NLaEZ6031425@sheep.berlios.de>

Author: grumbel
Date: 2006-10-23 23:36:13 +0200 (Mon, 23 Oct 2006)
New Revision: 672

Added:
   trunk/netbrush/src/color_display.cpp
   trunk/netbrush/src/color_display.hpp
Modified:
   trunk/netbrush/SConstruct
   trunk/netbrush/src/colorpicker_tool.cpp
   trunk/netbrush/src/colorpicker_tool.hpp
   trunk/netbrush/src/controller.cpp
   trunk/netbrush/src/controller.hpp
   trunk/netbrush/src/drawing_context.cpp
   trunk/netbrush/src/drawing_context.hpp
   trunk/netbrush/src/screen_buffer.cpp
Log:
- added color picker

Modified: trunk/netbrush/SConstruct
===================================================================
--- trunk/netbrush/SConstruct	2006-10-23 20:57:09 UTC (rev 671)
+++ trunk/netbrush/SConstruct	2006-10-23 21:36:13 UTC (rev 672)
@@ -61,6 +61,7 @@
         'src/paintbrush_tool.cpp',
         'src/scroll_tool.cpp',
         'src/colorpicker_tool.cpp',
+        'src/color_display.cpp',
         'src/color.cpp',
 #        'src/widget/events.cpp',
 ])

Added: trunk/netbrush/src/color_display.cpp
===================================================================
--- trunk/netbrush/src/color_display.cpp	2006-10-23 20:57:09 UTC (rev 671)
+++ trunk/netbrush/src/color_display.cpp	2006-10-23 21:36:13 UTC (rev 672)
@@ -0,0 +1,54 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#include <iostream>
+#include "color_display.hpp"
+
+ColorDisplay::ColorDisplay(const Rect& rect)
+  : Widget(rect), m_color(255, 0, 255)
+{
+}
+
+void
+ColorDisplay::draw(SDL_Surface* target)
+{
+  SDL_Rect r;
+  r.x = get_rect().left;
+  r.y = get_rect().top;
+  r.w = get_rect().get_width();
+  r.h = get_rect().get_height();
+
+  SDL_FillRect(target, &r, SDL_MapRGB(target->format, m_color.r, m_color.g, m_color.b));
+  if (0) std::cout << "Color: " << (int)m_color.r << " " << (int)m_color.g << " " << (int)m_color.b << std::endl;
+}
+
+void
+ColorDisplay::set_color(const Color& color)
+{
+  m_color = color;
+  set_dirty(true);
+}
+
+/* EOF */

Added: trunk/netbrush/src/color_display.hpp
===================================================================
--- trunk/netbrush/src/color_display.hpp	2006-10-23 20:57:09 UTC (rev 671)
+++ trunk/netbrush/src/color_display.hpp	2006-10-23 21:36:13 UTC (rev 672)
@@ -0,0 +1,56 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#ifndef HEADER_COLOR_DISPLAY_HPP
+#define HEADER_COLOR_DISPLAY_HPP
+
+#include "color.hpp"
+#include "widget/widget.hpp"
+
+/** */
+class ColorDisplay : public Widget
+{
+private:
+  Color m_color;
+
+public:
+  ColorDisplay(const Rect& rect);
+  
+  void on_mouse_motion(const MouseMotionEvent& motion) {}
+  void on_mouse_button(const MouseButtonEvent& button) {}
+
+  void on_enter() {}
+  void on_leave() {}
+  
+  void draw(SDL_Surface* target);
+  void set_color(const Color& color);
+private:
+  ColorDisplay (const ColorDisplay&);
+  ColorDisplay& operator= (const ColorDisplay&);
+};
+
+#endif
+
+/* EOF */

Modified: trunk/netbrush/src/colorpicker_tool.cpp
===================================================================
--- trunk/netbrush/src/colorpicker_tool.cpp	2006-10-23 20:57:09 UTC (rev 671)
+++ trunk/netbrush/src/colorpicker_tool.cpp	2006-10-23 21:36:13 UTC (rev 672)
@@ -23,9 +23,15 @@
 **  02111-1307, USA.
 */
 
+#include <iostream>
+#include "drawing_context.hpp"
+#include "globals.hpp"
+#include "controller.hpp"
+#include "color.hpp"
 #include "colorpicker_tool.hpp"
 
 ColorpickerTool::ColorpickerTool()
+  : dragging(false)
 {
 }
 
@@ -36,16 +42,32 @@
 void
 ColorpickerTool::on_motion(const ToolMotionEvent& ev)
 {
+  if (dragging)
+    {
+      pick_color(ev.x, ev.y);
+    }
 }
 
 void
 ColorpickerTool::on_button_press(const ToolButtonEvent& ev)
 {
+  pick_color(ev.x, ev.y);
+  dragging = true;
 }
 
 void
 ColorpickerTool::on_button_release(const ToolButtonEvent& ev)
 {
+  pick_color(ev.x, ev.y);
+  dragging = false;
 }
 
+void
+ColorpickerTool::pick_color(int x, int y)
+{
+  Color color;
+  if (draw_ctx->get_color(x, y, color))
+    controller->set_color(color);
+}
+
 /* EOF */

Modified: trunk/netbrush/src/colorpicker_tool.hpp
===================================================================
--- trunk/netbrush/src/colorpicker_tool.hpp	2006-10-23 20:57:09 UTC (rev 671)
+++ trunk/netbrush/src/colorpicker_tool.hpp	2006-10-23 21:36:13 UTC (rev 672)
@@ -32,6 +32,8 @@
 class ColorpickerTool : public Tool
 {
 private:
+  bool dragging;
+
 public:
   ColorpickerTool();
   ~ColorpickerTool();
@@ -39,6 +41,9 @@
   void on_motion(const ToolMotionEvent& ev);
   void on_button_press(const ToolButtonEvent& ev);
   void on_button_release(const ToolButtonEvent& ev);
+
+  void pick_color(int x, int y);
+
 private:
   ColorpickerTool (const ColorpickerTool&);
   ColorpickerTool& operator= (const ColorpickerTool&);

Modified: trunk/netbrush/src/controller.cpp
===================================================================
--- trunk/netbrush/src/controller.cpp	2006-10-23 20:57:09 UTC (rev 671)
+++ trunk/netbrush/src/controller.cpp	2006-10-23 21:36:13 UTC (rev 672)
@@ -121,10 +121,12 @@
   alpha_picker            = new AlphaPicker(Rect(Point(screen->w-128, 128+24), Size(128, 24)));
   saturation_value_picker = new SaturationValuePicker(Rect(Point(screen->w-128, 0), Size(128, 128)));
   hue_picker              = new HuePicker(Rect(Point(screen->w-128, 128), Size(128, 24)));
+  color_display           = new ColorDisplay(Rect(Point(0, screen->h - 34), Size(34, 34)));
 
   widget_manager->add(saturation_value_picker);
   widget_manager->add(hue_picker);
   widget_manager->add(alpha_picker);
+  widget_manager->add(color_display);
 
   // Brush Slider
   radius_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(0)), Size(128, 24)),
@@ -149,7 +151,15 @@
 
 }
 
+
 void
+Controller::set_color(const Color& color)
+{
+  client_draw_param->color = color;
+  color_display->set_color(color);
+}
+
+void
 Controller::set_color_hue(Uint8 hue_)
 {
   hue = hue_;

Modified: trunk/netbrush/src/controller.hpp
===================================================================
--- trunk/netbrush/src/controller.hpp	2006-10-23 20:57:09 UTC (rev 671)
+++ trunk/netbrush/src/controller.hpp	2006-10-23 21:36:13 UTC (rev 672)
@@ -28,6 +28,7 @@
 
 #include "saturation_value_picker.hpp"
 #include "alpha_picker.hpp"
+#include "color_display.hpp"
 #include "hue_picker.hpp"
 #include "generic_brush.hpp"
 
@@ -40,6 +41,7 @@
   SaturationValuePicker* saturation_value_picker;
   HuePicker*             hue_picker;
   AlphaPicker*           alpha_picker;
+  ColorDisplay*          color_display;
 
   SliderWidget* radius_slider;
   SliderWidget* spike_slider;
@@ -55,6 +57,7 @@
   Controller();
   ~Controller();
 
+  void set_color(const Color& color);
   void set_color_hue(Uint8 hue);
   void set_color_value_saturation(Uint8 value, Uint8 saturation);
 

Modified: trunk/netbrush/src/drawing_context.cpp
===================================================================
--- trunk/netbrush/src/drawing_context.cpp	2006-10-23 20:57:09 UTC (rev 671)
+++ trunk/netbrush/src/drawing_context.cpp	2006-10-23 21:36:13 UTC (rev 672)
@@ -159,4 +159,29 @@
     }
 }
 
+bool
+DrawingContext::get_color(int x, int y, Color& color)
+{
+  if ((x >= 0 && x < drawable->w) &&
+      (y >= 0 && y < drawable->h))
+    {
+      SDL_LockSurface(drawable);
+      Uint8* source = static_cast<Uint8*>(drawable->pixels);
+
+      SDL_GetRGB(*((Uint32*)(source+(y * drawable->pitch + drawable->format->BytesPerPixel * x))),
+                 drawable->format,
+                 &color.r,
+                 &color.g,
+                 &color.b);
+
+  
+      SDL_UnlockSurface(drawable);
+      return true;
+    }
+  else
+    {
+      return false;
+    }
+}
+
 /* EOF */

Modified: trunk/netbrush/src/drawing_context.hpp
===================================================================
--- trunk/netbrush/src/drawing_context.hpp	2006-10-23 20:57:09 UTC (rev 671)
+++ trunk/netbrush/src/drawing_context.hpp	2006-10-23 21:36:13 UTC (rev 672)
@@ -30,6 +30,7 @@
 #include "math/rect.hpp"
 #include "stroke.hpp"
 
+class Color;
 class GrayscaleBuffer;
 class DrawingParameter;
 class StrokeBuffer;
@@ -52,7 +53,7 @@
 
   int get_width()  const { return drawable->w; }
   int get_height() const { return drawable->h; }
-
+  bool get_color(int x, int y, Color& color);
   SDL_Surface* get_surface() { return drawable; }
 };
 

Modified: trunk/netbrush/src/screen_buffer.cpp
===================================================================
--- trunk/netbrush/src/screen_buffer.cpp	2006-10-23 20:57:09 UTC (rev 671)
+++ trunk/netbrush/src/screen_buffer.cpp	2006-10-23 21:36:13 UTC (rev 672)
@@ -36,6 +36,7 @@
 #include "tool.hpp"
 #include "airbrush_tool.hpp"
 #include "scroll_tool.hpp"
+#include "colorpicker_tool.hpp"
 #include "screen_buffer.hpp"
 
 ScreenBuffer::ScreenBuffer(const Rect& rect)
@@ -46,7 +47,7 @@
 {
   tools.push_back(new AirbrushTool());
   tools.push_back(new ScrollTool());
-  tools.push_back(new AirbrushTool());
+  tools.push_back(new ColorpickerTool());
 }
 
 ScreenBuffer::~ScreenBuffer()



From grumbel at mail.berlios.de  Tue Oct 24 16:22:37 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Tue, 24 Oct 2006 16:22:37 +0200
Subject: [Flexlay-commit] r673 - in trunk/netbrush: . data data/fonts src
Message-ID: <200610241422.k9OEMbsH006645@sheep.berlios.de>

Author: grumbel
Date: 2006-10-24 16:22:36 +0200 (Tue, 24 Oct 2006)
New Revision: 673

Added:
   trunk/netbrush/BUGS
   trunk/netbrush/data/fonts/
   trunk/netbrush/data/fonts/8x8font.png
   trunk/netbrush/src/SDL_tty.c
   trunk/netbrush/src/SDL_tty.h
   trunk/netbrush/src/text_view.cpp
   trunk/netbrush/src/text_view.hpp
Modified:
   trunk/netbrush/SConstruct
   trunk/netbrush/scale.rb
   trunk/netbrush/src/client.cpp
   trunk/netbrush/src/color.cpp
   trunk/netbrush/src/color_display.cpp
   trunk/netbrush/src/color_display.hpp
   trunk/netbrush/src/controller.cpp
Log:
- added TextView

Added: trunk/netbrush/BUGS
===================================================================
--- trunk/netbrush/BUGS	2006-10-23 21:36:13 UTC (rev 672)
+++ trunk/netbrush/BUGS	2006-10-24 14:22:36 UTC (rev 673)
@@ -0,0 +1,5 @@
+- color format isn't handled correctly at some points in the code (Navigator) 
+- some parts of code should probally enforce a specific color format
+
+# EOF #
+ 
\ No newline at end of file

Modified: trunk/netbrush/SConstruct
===================================================================
--- trunk/netbrush/SConstruct	2006-10-23 21:36:13 UTC (rev 672)
+++ trunk/netbrush/SConstruct	2006-10-24 14:22:36 UTC (rev 673)
@@ -63,6 +63,8 @@
         'src/colorpicker_tool.cpp',
         'src/color_display.cpp',
         'src/color.cpp',
+        'src/SDL_tty.c',
+        'src/text_view.cpp',
 #        'src/widget/events.cpp',
 ])
 

Added: trunk/netbrush/data/fonts/8x8font.png
===================================================================
(Binary files differ)


Property changes on: trunk/netbrush/data/fonts/8x8font.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/netbrush/scale.rb
===================================================================
--- trunk/netbrush/scale.rb	2006-10-23 21:36:13 UTC (rev 672)
+++ trunk/netbrush/scale.rb	2006-10-24 14:22:36 UTC (rev 673)
@@ -1,14 +1,16 @@
 #!/usr/bin/ruby -w
 
-$scale = ARGV[0].to_i
+$scale = ARGV[0].to_f
 
 $stdin.readlines.each{|i|
- lst = i.split[2..-1]
- if lst[0] == "dab" then
-   print "#{lst[0]} #{lst[1]} #{lst[2].to_i * $scale} #{lst[3].to_i * $scale}"
-   else
- lst.each{|l| print "#{l} " }
- end
- puts
+  lst = i.split[2..-1]
+  if lst[0] == "dab" then
+    print "#{lst[0]} #{lst[1]} #{lst[2].to_i * $scale} #{lst[3].to_i * $scale}"
+  elsif lst[0] == "set_generic_brush" then
+    print "#{lst[0]} #{lst[1]} #{lst[2].to_f * $scale} #{lst[3]} #{lst[4]} #{lst[5]} #{lst[6]} #{lst[7]}"
+  else
+    lst.each{|l| print "#{l} " }
+  end
+  puts
 }
 

Added: trunk/netbrush/src/SDL_tty.c
===================================================================
--- trunk/netbrush/src/SDL_tty.c	2006-10-23 21:36:13 UTC (rev 672)
+++ trunk/netbrush/src/SDL_tty.c	2006-10-24 14:22:36 UTC (rev 673)
@@ -0,0 +1,461 @@
+/** 
+ ** Copyright (c) 2006 Ingo Ruhnke <grumbel at gmx.de>
+ ** 
+ ** This software is provided 'as-is', without any express or implied
+ ** warranty. In no event will the authors be held liable for any
+ ** damages arising from the use of this software.
+ ** 
+ ** Permission is granted to anyone to use this software for any
+ ** purpose, including commercial applications, and to alter it and
+ ** redistribute it freely, subject to the following restrictions:
+ ** 
+ **   1. The origin of this software must not be misrepresented; you
+ **      must not claim that you wrote the original software. If you
+ **      use this software in a product, an acknowledgment in the
+ **      product documentation would be appreciated but is not
+ **      required.
+ ** 
+ **   2. Altered source versions must be plainly marked as such, and
+ **      must not be misrepresented as being the original software.
+ ** 
+ **   3. This notice may not be removed or altered from any source
+ **      distribution.
+ ** 
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <assert.h>
+#include <SDL.h>
+#include <SDL_image.h>
+#include "SDL_tty.h"
+#include <string.h>
+
+static int modulo(int x, int y)
+{
+  int xmody = x - (x / y) * y;
+  if (xmody && ((y ^ xmody) < 0)) {
+    xmody += y;
+  }
+  return xmody;
+}
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+
+char *
+make_message(const char *fmt, va_list ap)
+{
+  /* Guess we need no more than 100 bytes. */
+  int n, size = 100;
+  char *p, *np;
+ 
+  if ((p = malloc (size)) == NULL)
+    return NULL;
+
+  while (1) {
+    /* Try to print in the allocated space. */
+    //va_start(ap, fmt);
+
+    n = vsnprintf (p, size, fmt, ap);
+    va_end(ap);
+    /* If that worked, return the string. */
+    if (n > -1 && n < size)
+      return p;
+    /* Else try again with more space. */
+    if (n > -1)    /* glibc 2.1 */
+      size = n+1; /* precisely what is needed */
+    else           /* glibc 2.0 */
+      size *= 2;  /* twice the old size */
+    if ((np = realloc (p, size)) == NULL) {
+      free(p);
+      return NULL;
+    } else {
+      p = np;
+    }
+  }
+}
+
+TTY_Font*
+TTY_CreateFont(SDL_Surface* surface, int glyph_width, int glyph_height, char* letters)
+{
+  int i;
+  TTY_Font* font = (TTY_Font*)malloc(sizeof(TTY_Font));
+
+  font->surface = SDL_DisplayFormatAlpha(surface);
+
+  if (!font->surface) 
+    {
+      TTY_SetError("TTY_CreateFont: conversation of surface failed");
+      return 0;
+    }
+  
+  memset(font->transtbl, 0, 256);
+  for(i = 0; letters[i] != '\0'; ++i)
+    font->transtbl[(int)letters[i]] = i;
+
+  font->glyph_width  = glyph_width;
+  font->glyph_height = glyph_height;
+
+  return font;
+}
+
+void
+TTY_FreeFont(TTY_Font* font)
+{
+  SDL_FreeSurface(font->surface);
+  free(font);
+}
+
+void
+TTY_GetGlyph(TTY_Font* font, char idx, SDL_Rect* rect)
+{
+  idx = font->transtbl[(int)idx];
+
+  rect->x = (idx % (font->surface->w / font->glyph_width)) * font->glyph_width;
+  rect->y = (idx / (font->surface->w / font->glyph_width)) * font->glyph_height;
+
+  rect->w = font->glyph_width;
+  rect->h = font->glyph_height;
+}
+
+void TTY_Printf(TTY_Font* font, SDL_Surface* screen, int x, int y, Uint32 flags, const char *fmt, ...)
+{
+  va_list ap;
+  va_start(ap, fmt);
+  char* str = make_message(fmt, ap);
+  TTY_Print(font, screen, x, y, flags, str);
+  free(str);
+}
+
+int FNT_GetTextHeight(TTY_Font* font, const char* text)
+{
+  int lines = 1;
+  int i;
+  for(i = 0; text[i] != '\0'; ++i)
+    {
+      if (text[i] == '\n')
+        {
+          lines += 1;
+        }
+    }
+  return lines * font->glyph_height;
+}
+
+int FNT_GetTextWidth(TTY_Font* font, const char* text)
+{
+  int longest_line = 0;
+  int line = 0;
+  int i;
+  for(i = 0; text[i] != '\0'; ++i)
+    {
+      if (text[i] == '\n')
+        {
+          if (line > longest_line)
+            longest_line = line;
+          line = 0;
+        }
+      else
+        {
+          line += 1;
+        }
+    }
+
+  if (line > longest_line)
+    longest_line = line;
+
+  return longest_line * font->glyph_width;
+}
+
+int FNT_GetTextLineWidth(TTY_Font* font, const char* text)
+{
+  int i;
+  for(i = 0; text[i] != '\0' && text[i] != '\n'; ++i);
+  return i * font->glyph_width;
+}
+
+void
+TTY_Print(TTY_Font* font, SDL_Surface* screen, int x, int y, Uint32 flags, const char *str)
+{
+  SDL_Rect src_rect;
+  SDL_Rect dst_rect;
+
+  int x_of = 0;
+  int y_of = 0;
+
+  int i;
+
+  int text_width  = FNT_GetTextWidth(font, str);
+  int text_height = FNT_GetTextHeight(font, str);
+
+  if ((flags & FNT_ALIGN_LEFT) && (flags & FNT_ALIGN_RIGHT))
+    {
+      x -= text_width/2;
+    }
+  else if (flags & FNT_ALIGN_LEFT)
+    {
+    }
+  else if (flags & FNT_ALIGN_RIGHT)
+    {
+      x -= text_width;
+    }
+
+  if ((flags & FNT_ALIGN_TOP) && (flags & FNT_ALIGN_BOTTOM))
+    {
+      y -= text_height/2;
+    }
+  else if (flags & FNT_ALIGN_TOP)
+    {
+    }
+  else if (flags & FNT_ALIGN_BOTTOM)
+    {
+      y -= text_height;
+    }
+
+  for(i = 0; str[i] != '\0'; ++i)
+    {
+      if (str[i] == '\n')
+        {
+          if ((flags & FNT_ALIGN_LEFT) && (flags & FNT_ALIGN_RIGHT))
+            {
+              x_of = text_width/2 - FNT_GetTextLineWidth(font, str+i+1)/2;
+            }
+          else if (flags & FNT_ALIGN_LEFT)
+            {
+              x_of = 0;
+            }
+          else if (flags & FNT_ALIGN_RIGHT)
+            {
+              x_of = text_width - FNT_GetTextLineWidth(font, str+i+1);
+            }
+
+          y_of += font->glyph_height;
+        }
+      else
+        {
+          TTY_GetGlyph(font, str[i], &src_rect);
+  
+          dst_rect.x = x + x_of;
+          dst_rect.y = y + y_of;
+  
+          SDL_BlitSurface(font->surface, &src_rect, screen, &dst_rect);
+
+          x_of += font->glyph_width;
+        }
+    }
+}
+
+TTY*
+TTY_Create(int width, int height, TTY_Font* font)
+{
+  int i;
+  TTY* tty = (TTY*)malloc(sizeof(TTY));
+
+  // SDL_Surface* temp = TTY_CreateRGBSurface(font8x12);
+  // SDL_Surface* temp = IMG_Load("c64_16x16.png");
+      
+  //tty->font = TTY_CreateFont(temp, 16, 16, 
+  //                         "\x7f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+  //                         "[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~");
+  tty->font = font;
+
+  //SDL_FreeSurface(temp);
+  
+  /* Create Framebuffer */
+  tty->framebuffer = (char**)malloc(sizeof(char*) * height);
+  for(i = 0; i < height; ++i)
+    tty->framebuffer[i] = (char*)malloc(sizeof(char) * width);
+  
+  tty->width  = width;
+  tty->height = height;
+
+  tty->cursor_character = 0;
+  tty->print_cursor     = 0;
+
+  tty->scroll_x = 0;
+  tty->scroll_y = 0;
+
+  tty->cursor_x = 0;
+  tty->cursor_y = 0;
+  
+  TTY_Clear(tty);
+
+  return tty;
+}
+
+void
+TTY_Free(TTY* tty)
+{
+  int i;
+  
+  // TTY_FreeFont(tty->font);
+
+  for(i = 0; i < tty->height; ++i)
+    free(tty->framebuffer[i]);
+  free(tty->framebuffer);
+  
+  free(tty);
+}
+
+void TTY_SetScrollOffset(TTY* tty, int scroll_x, int scroll_y)
+{
+  tty->scroll_x = scroll_x;
+  tty->scroll_y = scroll_y;
+}
+
+void TTY_GetScrollOffset(TTY* tty, int* scroll_x, int* scroll_y)
+{
+  *scroll_x = tty->scroll_x;
+  *scroll_y = tty->scroll_y;
+}
+
+void TTY_SetCursor(TTY* tty, int x, int y)
+{
+  tty->cursor_x = modulo(x + tty->scroll_x, tty->width);
+  tty->cursor_y = modulo(y + tty->scroll_y, tty->height);
+}
+
+void TTY_GetCursor(TTY* tty, int* x, int* y)
+{
+  *x = tty->cursor_x - tty->scroll_x;
+  *y = tty->cursor_y - tty->scroll_y;
+}
+
+void TTY_Clear(TTY* tty)
+{ 
+  int y;
+  for(y = 0; y < tty->height; ++y)
+    memset(tty->framebuffer[y], 0, tty->width);
+}
+
+void TTY_putchar_nomove(TTY* tty, char chr)
+{
+  if (chr != '\n' && chr != '\r')
+    tty->framebuffer[tty->cursor_y][tty->cursor_x] = chr;
+}
+
+void TTY_putchar(TTY* tty, char chr)
+{
+  if (chr == '\n')
+    {
+      tty->cursor_x = tty->scroll_x;
+      tty->cursor_y = modulo(tty->cursor_y  + 1, tty->height);
+
+      if (modulo(tty->cursor_y - tty->scroll_y, tty->height) == 0)
+        {
+          tty->scroll_y = modulo(tty->scroll_y + 1, tty->height);
+          memset(tty->framebuffer[tty->cursor_y], 0, tty->width);
+        }
+    }
+  else if (chr == '\r')
+    {
+      tty->cursor_x = tty->scroll_x;
+    }
+  else
+    {      
+      tty->framebuffer[tty->cursor_y][tty->cursor_x] = chr;
+
+      tty->cursor_x += 1;
+      if (tty->cursor_x == tty->width)
+        {
+          tty->cursor_x = tty->scroll_x;
+          tty->cursor_y = modulo(tty->cursor_y  + 1, tty->height);
+
+          if (modulo(tty->cursor_y - tty->scroll_y, tty->height) == 0)
+            {
+              tty->scroll_y = modulo(tty->scroll_y + 1, tty->height);
+              memset(tty->framebuffer[tty->cursor_y], 0, tty->width);
+            }
+        }
+    }
+}
+
+void TTY_write(TTY* tty, const char* buffer, int len)
+{
+  int i;
+  for(i = 0; i < len; ++i)
+    TTY_putchar(tty, buffer[i]);
+}
+
+void TTY_print(TTY* tty, const char* buffer)
+{
+  TTY_write(tty, buffer, strlen(buffer));
+}
+
+void TTY_SetCursorCharacter(TTY* tty, int chr)
+{
+  tty->cursor_character = chr;
+}
+
+void TTY_EnableVisibleCursor(TTY* tty, int i)
+{
+  tty->print_cursor = i;
+}
+
+void TTY_Blit(TTY* tty, SDL_Surface* screen, int screen_x, int screen_y)
+{
+  SDL_Rect src_rect;
+  SDL_Rect dst_rect;
+
+  int x;
+  int y;
+  for(y = 0; y < tty->height; ++y)
+    {
+      for(x = 0; x < tty->width; ++x)
+        {
+          if (tty->print_cursor)
+            {
+              if (modulo(x + tty->scroll_x, tty->width) == tty->cursor_x &&
+                  modulo(y + tty->scroll_y, tty->height) == tty->cursor_y &&
+                  (SDL_GetTicks()/200) % 2 == 0)
+                {
+                  TTY_GetGlyph(tty->font, tty->cursor_character, &src_rect);
+
+                  dst_rect.x = screen_x + x * tty->font->glyph_width;
+                  dst_rect.y = screen_y + y * tty->font->glyph_height;
+
+                  SDL_BlitSurface(tty->font->surface, &src_rect, screen, &dst_rect);
+                }
+              else
+                {
+                  char chr = tty->framebuffer[modulo(y + tty->scroll_y, tty->height)][modulo(x + tty->scroll_x, tty->width)];
+                  if (chr)
+                    {
+                      TTY_GetGlyph(tty->font, chr, &src_rect);
+
+                      dst_rect.x = screen_x + x * tty->font->glyph_width;
+                      dst_rect.y = screen_y + y * tty->font->glyph_height;
+
+                      SDL_BlitSurface(tty->font->surface, &src_rect, screen, &dst_rect);
+                    }
+                }
+            }
+          else
+            {          
+              char chr = tty->framebuffer[modulo(y + tty->scroll_y, tty->height)][modulo(x + tty->scroll_x, tty->width)];
+              if (chr)
+                {
+                  TTY_GetGlyph(tty->font, chr, &src_rect);
+
+                  dst_rect.x = screen_x + x * tty->font->glyph_width;
+                  dst_rect.y = screen_y + y * tty->font->glyph_height;
+
+                  SDL_BlitSurface(tty->font->surface, &src_rect, screen, &dst_rect);
+                }
+            }
+        }
+    }
+}
+
+void TTY_printf(TTY* tty, const char *fmt, ...)
+{
+  va_list ap;
+  va_start(ap, fmt);
+  char* str = make_message(fmt, ap);
+  TTY_print(tty, str);
+  free(str);
+}
+
+/* EOF */

Added: trunk/netbrush/src/SDL_tty.h
===================================================================
--- trunk/netbrush/src/SDL_tty.h	2006-10-23 21:36:13 UTC (rev 672)
+++ trunk/netbrush/src/SDL_tty.h	2006-10-24 14:22:36 UTC (rev 673)
@@ -0,0 +1,269 @@
+/** 
+ ** Copyright (c) 2006 Ingo Ruhnke <grumbel at gmx.de>
+ ** 
+ ** This software is provided 'as-is', without any express or implied
+ ** warranty. In no event will the authors be held liable for any
+ ** damages arising from the use of this software.
+ ** 
+ ** Permission is granted to anyone to use this software for any
+ ** purpose, including commercial applications, and to alter it and
+ ** redistribute it freely, subject to the following restrictions:
+ ** 
+ **   1. The origin of this software must not be misrepresented; you
+ **      must not claim that you wrote the original software. If you
+ **      use this software in a product, an acknowledgment in the
+ **      product documentation would be appreciated but is not
+ **      required.
+ ** 
+ **   2. Altered source versions must be plainly marked as such, and
+ **      must not be misrepresented as being the original software.
+ ** 
+ **   3. This notice may not be removed or altered from any source
+ **      distribution.
+ ** 
+ */
+
+#ifndef _SDL_TTY_H
+#define _SDL_TTY_H
+
+#include <SDL.h>
+
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define TTY_MAJOR_VERSION  0;
+#define TTY_MINOR_VERSION  0;
+#define TTY_PATH_VERSION   1;
+
+/** Reuse SDL functions for error reporting */
+#define TTY_SetError	SDL_SetError
+#define TTY_GetError	SDL_GetError
+
+/** 
+ */
+typedef struct TTY_Font
+{
+  /** 
+   *  Surface containing the glyphs, glyphs have to be fixed width and
+   *  run from left to right, seperating the glyphs to multiple lines
+   *  is allowed
+   */
+  SDL_Surface* surface;
+
+  /**
+   *  Map characters to there index inside the font file,
+   *  ie. translable['a'] will give the index of 'a'
+   */
+  char transtbl[256];
+
+  int  glyph_width;
+  int  glyph_height;
+}  TTY_Font;
+
+typedef struct TTY
+{
+  /** 
+   *  The buffer containing all characters for display, access via
+   *  framebuffer[y][x]
+   */
+  char** framebuffer;
+
+  /** 
+   *  The font that is used at default for rendering the framebuffer
+   */
+  TTY_Font* font;
+
+  /** 
+   *  The width of the framebuffer 
+   */
+  int width;
+
+  /** 
+   *  The height of the framebuffer 
+   */
+  int height;
+
+  /** 
+   *  The cursors x position in the framebuffer in screen coordinates,
+   *  use TTY_SetCursor() to avoid throuble when scrolling
+   */
+  int cursor_x;
+
+  /** 
+   *  The cursors y position in the framebuffer in screen coordinates,
+   *  use TTY_SetCursor() to avoid throuble when scrolling
+   */
+  int cursor_y;
+
+  /**
+   *  The character that should be used to display the cursor
+   */
+  int cursor_character;
+
+  /** 
+   *  If set the cursor is displayed
+   */
+  int print_cursor;
+
+  /** 
+   *  The scroll offset in x direction
+   */
+  int scroll_x;
+
+  /** 
+   *  The scroll offset in x direction
+   */
+  int scroll_y;
+
+}  TTY;
+
+#define TTY_CreateRGBSurface(name) SDL_CreateRGBSurfaceFrom( name##_data, \
+                                      name##_width, name##_height, name##_bpp, name##_pitch, \
+                                      name##_rmask, name##_gmask,  name##_bmask, name##_amask )
+
+/**
+ *  Creates a font from an SDL_Surface. The letter with index 0 is at
+ *  the top/left of the image, 
+ *
+ *  @param surface      The SDL_Surface that contains all letters
+ *  @param glyph_width  The width of a glyph
+ *  @param glyph_height The height of a glyph
+ *  @param letters      The letters that are present in the font
+ */
+TTY_Font* TTY_CreateFont(SDL_Surface* surface, int glyph_width, int glyph_height, char* letters);
+void      TTY_FreeFont(TTY_Font* font);
+
+/**
+ *  Calculate the position of character \a idx in the surface used by
+ *  \a font and write the result to \a rect
+ */
+void TTY_GetGlypth(TTY_Font* font, char idx, SDL_Rect* rect);
+
+enum {
+  FNT_ALIGN_LEFT     = (1<<0),
+  FNT_ALIGN_RIGHT    = (1<<1),
+  FNT_ALIGN_H_CENTER = FNT_ALIGN_LEFT | FNT_ALIGN_RIGHT,
+
+  FNT_ALIGN_TOP      = (1<<2),
+  FNT_ALIGN_BOTTOM   = (1<<3),
+  FNT_ALIGN_V_CENTER = FNT_ALIGN_TOP | FNT_ALIGN_BOTTOM,
+
+  FNT_ALIGN_CENTER = FNT_ALIGN_H_CENTER | FNT_ALIGN_V_CENTER
+};
+
+/** 
+ * Return the height, ie. lines * font_height, of a given text in
+ * pixel
+ */
+int FNT_GetTextHeight(TTY_Font* font, const char* text);
+
+/** 
+ * Return the width, ie. the width of the longest line, of a given
+ * text in pixel
+ */
+int FNT_GetTextWidth(TTY_Font* font, const char* text);
+
+/** 
+ * Return the width of the given line (everything after a \0 or a \n is ignored)
+ */
+int FNT_GetTextLineWidth(TTY_Font* font, const char* text);
+
+/** 
+ *  Print the given string to the screen at the given coordinates using \a font.
+ */
+void TTY_Print(TTY_Font* font, SDL_Surface* screen, int x, int y, Uint32 flags, const char *str);
+
+/** 
+ *  Print to the screen at the given coordinates, while handling \a
+ *  fmt in a printf like manner
+ */
+void TTY_Printf(TTY_Font* font, SDL_Surface* screen, int x, int y, Uint32 flags, const char *fmt, ...)
+  __attribute__ ((format (printf, 6, 7)));
+
+/** 
+ *  Allocate a new TTY with the given dimensions and font.
+ *
+ *  @param width  The width of the terminal in characters
+ *  @param height The height of the terminal in characters
+ *  @param font   The font used for displaying the terminal, the font
+ *                will not be freed upon TTY_Free()
+
+ */
+TTY* TTY_Create(int width, int height, TTY_Font* font);
+
+/**
+ *  Deallocate a given TTY
+ */
+void TTY_Free(TTY* tty);
+
+/**
+ *  The the current cursor position to \a x, \a y, if x or y are
+ *  outside the range of the TTY, they automatically wrap around 
+ */
+void TTY_SetCursor(TTY* tty, int x, int y);
+
+void TTY_SetScrollOffset(TTY* tty, int scroll_x, int scroll_y);
+void TTY_GetScrollOffset(TTY* tty, int* scroll_x, int* scroll_y);
+
+/**
+ *  Write the current cursor position to \a x and \a y 
+ */
+void TTY_GetCursor(TTY* tty, int* x, int* y);
+
+/**
+ *  Use character chr as the cursor
+ */
+void TTY_SetCursorCharacter(TTY* tty, int chr);
+
+/**
+ *  If \a i is set, display a cursor, if \a i is 0, don't display it
+ */
+void TTY_EnableVisibleCursor(TTY* tty, int i);
+
+/** 
+ *  Clear the tty's framebuffer
+ */
+void TTY_Clear(TTY* tty);
+
+/** 
+ *  Append the content of \a buffer to the given \a tty, \a len gives
+ *  the length of the buffer.
+ */
+void TTY_write(TTY* tty, const char* buffer, int len);
+
+/**
+ *  Append the content of \a buffer to the given \a tty, \a buffer
+ *  must be '\0' terminated.
+ */
+void TTY_print(TTY* tty, const char* buffer);
+
+/**
+ *  Append chr to \a tty
+ */
+void TTY_putchar(TTY* tty, char chr);
+
+/**
+ *  Put\a chr at the current cursor position without advancing the cursor
+ */
+void TTY_putchar_nomove(TTY* tty, char chr);
+
+/**
+ *  printf like way to append content to \a tty
+ */
+void TTY_printf(TTY* tty, const char *fmt, ...)  __attribute__ ((format (printf, 2, 3)));
+
+/**
+ *  Blit \a tty given to the surface \a screen at the given coordinates \a x and \a y
+ */
+void TTY_Blit(TTY* tty, SDL_Surface* screen, int x, int y);
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+/* EOF */

Modified: trunk/netbrush/src/client.cpp
===================================================================
--- trunk/netbrush/src/client.cpp	2006-10-23 21:36:13 UTC (rev 672)
+++ trunk/netbrush/src/client.cpp	2006-10-24 14:22:36 UTC (rev 673)
@@ -23,6 +23,7 @@
 #include "navigation.hpp"
 #include "server_connection.hpp"
 #include "command_line.hpp"
+#include "text_view.hpp"
 #include "widget/slider_widget.hpp"
 #include "controller.hpp"
 
@@ -97,6 +98,13 @@
             {
               client_draw_param->opacity = std::min(255, client_draw_param->opacity + 16);
             }
+          else if (event.key.keysym.sym == SDLK_F11)
+            {
+              if (SDL_WM_ToggleFullScreen(screen) == 0) {
+                std::cout << "Failed to toggle fullscreen mode: " << SDL_GetError() << std::endl;
+                //quit(1);
+              }
+            }
           else if (event.key.keysym.sym == SDLK_u)
             {
               navigation->update();
@@ -128,6 +136,8 @@
     bool fullscreen = false;
     int screen_width  = 800;
     int screen_height = 600;
+    int canvas_width  = 2048;
+    int canvas_height = 2048;
     std::string hostname;
     std::string port     = "4711";
     int rest_arg_count = 0;
@@ -137,6 +147,7 @@
     argp.add_usage("[OPTIONS] HOSTNAME PORT");
     argp.add_group("Display:");
     argp.add_option('g', "geometry",  "WIDTHxHEIGHT", "Set the windows size to WIDTHxHEIGHT");
+    argp.add_option('c', "canvas",    "WIDTHxHEIGHT", "Set the size of the paintable canvas to WIDTHxHEIGHT");
     argp.add_option('f', "fullscreen", "",            "Start the application in fullscreen mode");
     argp.add_option('w', "window",     "",            "Start the application in window mode");
     argp.add_option('v', "version",    "",            "Display the netBrush version");
@@ -162,6 +173,20 @@
             }
             break;
 
+          case 'c':
+            {
+              if (sscanf(argp.get_argument().c_str(), "%dx%d",
+                         &canvas_width, &canvas_height) == 2)
+                {
+                  std::cout << "Geometry: " << canvas_width << "x" << canvas_height << std::endl;
+                }
+              else
+                {
+                  throw std::runtime_error("Canvas option '-c' requires argument of type {WIDTH}x{HEIGHT}");
+                }
+            }
+            break;
+
           case 'f':
             fullscreen = true;
             break;
@@ -221,10 +246,11 @@
     SDL_WM_SetCaption("netBrush", "netBrush");
 
     // 18 is scrollbar
-    screen_buffer = new ScreenBuffer(Rect(38, 2, screen->w - 128 - 18 - 2 - 2, screen->h - 16 - 4)); 
-    draw_ctx      = new DrawingContext(2048, 2048);
-    stroke_buffer = new StrokeBuffer(2048, 2048);
+    screen_buffer = new ScreenBuffer(Rect(38, 2, screen->w - 128 - 18 - 2 - 2, screen->h - 16 - 4 - 38)); 
+    draw_ctx      = new DrawingContext(canvas_width, canvas_height);
+    stroke_buffer = new StrokeBuffer(canvas_width, canvas_height);
 
+
     //std::cout << "# clear screen" << std::endl;
 
     // clear screen
@@ -253,6 +279,9 @@
     widget_manager = new WidgetManager();
     controller     = new Controller();
 
+    widget_manager->add(new TextView(Rect(38, screen->h - 38,
+                                          screen->w - 128 - 18 - 2 - 2, screen->h)));
+
     widget_manager->add(navigation = new Navigation(Rect(Point(screen->w - 128 - 2, screen->h - 128 - 2),
                                                          Size(128, 128))));
     {
@@ -269,14 +298,14 @@
     widget_manager->add(screen_buffer);
 
     widget_manager->add(vertical_scrollbar = 
-                        new Scrollbar(0, 2048, screen_buffer->get_rect().get_height(), Scrollbar::VERTICAL,
+                        new Scrollbar(0, canvas_height, screen_buffer->get_rect().get_height(), Scrollbar::VERTICAL,
                                       Rect(screen->w - 128 - 16 - 2 - 2, 2,
-                                           screen->w - 128 - 2 - 2, screen->h - 16 - 4)));
+                                           screen->w - 128 - 2 - 2, screen->h - 16 - 4 - 38)));
 
     widget_manager->add(horizontal_scrollbar = 
-                        new Scrollbar(0, 2048, screen_buffer->get_rect().get_width(), Scrollbar::HORIZONTAL,
-                                      Rect(38, screen->h - 16 - 2,
-                                           screen->w - 128 - 18 - 2 - 2, screen->h - 2)));
+                        new Scrollbar(0, canvas_width, screen_buffer->get_rect().get_width(), Scrollbar::HORIZONTAL,
+                                      Rect(38, screen->h - 16 - 2 - 38,
+                                           screen->w - 128 - 18 - 2 - 2, screen->h - 2 - 38)));
     
     brush_widget = new BrushWidget(Rect(Point(screen->w-128, 128+24+24), Size(128, 128)));
     

Modified: trunk/netbrush/src/color.cpp
===================================================================
--- trunk/netbrush/src/color.cpp	2006-10-23 21:36:13 UTC (rev 672)
+++ trunk/netbrush/src/color.cpp	2006-10-24 14:22:36 UTC (rev 673)
@@ -46,11 +46,11 @@
   else
     {
       if (max == color.r)
-        hsvcolor.hue = (0 + (color.g - color.b) / (max - min)) * 43;
+        hsvcolor.hue = (0 + (color.g - color.b) / (max - min)) * 255 / 6;
       else if (max == color.g)
-        hsvcolor.hue = (2 + (color.b - color.r) / (max - min)) * 43;
+        hsvcolor.hue = (2 + (color.b - color.r) / (max - min)) * 255 / 6;
       else if (max == color.b)
-        hsvcolor.hue = (4 + (color.r - color.g) / (max - min)) * 43;
+        hsvcolor.hue = (4 + (color.r - color.g) / (max - min)) * 255 / 6;
     }
 
   if (max == 0)

Modified: trunk/netbrush/src/color_display.cpp
===================================================================
--- trunk/netbrush/src/color_display.cpp	2006-10-23 21:36:13 UTC (rev 672)
+++ trunk/netbrush/src/color_display.cpp	2006-10-24 14:22:36 UTC (rev 673)
@@ -24,30 +24,69 @@
 */
 
 #include <iostream>
+#include "globals.hpp"
+#include "controller.hpp"
 #include "color_display.hpp"
 
 ColorDisplay::ColorDisplay(const Rect& rect)
-  : Widget(rect), m_color(255, 0, 255)
+  : Widget(rect), 
+    foreground(255, 0, 255),
+    background(100, 100, 0)
 {
 }
 
 void
+ColorDisplay::on_mouse_button(const MouseButtonEvent& button) 
+{
+  if (button.state == SDL_PRESSED)
+    {
+      std::swap(background, foreground);
+      controller->set_color(foreground);
+      set_dirty(true);
+    }
+}
+
+void
 ColorDisplay::draw(SDL_Surface* target)
 {
   SDL_Rect r;
+ 
+  r.x = get_rect().left + get_rect().get_width()/3;
+  r.y = get_rect().top  + get_rect().get_height()/3;
+  r.w = 2*get_rect().get_width()/3;
+  r.h = 2*get_rect().get_height()/3;
+
+  SDL_FillRect(target, &r, SDL_MapRGB(target->format, 128, 128, 128));
+
   r.x = get_rect().left;
   r.y = get_rect().top;
-  r.w = get_rect().get_width();
-  r.h = get_rect().get_height();
+  r.w = 2*get_rect().get_width()/3;
+  r.h = 2*get_rect().get_height()/3;
 
-  SDL_FillRect(target, &r, SDL_MapRGB(target->format, m_color.r, m_color.g, m_color.b));
-  if (0) std::cout << "Color: " << (int)m_color.r << " " << (int)m_color.g << " " << (int)m_color.b << std::endl;
+  SDL_FillRect(target, &r, SDL_MapRGB(target->format, 128, 128, 128));
+
+  
+  r.x = get_rect().left + get_rect().get_width()/3+1;
+  r.y = get_rect().top  + get_rect().get_height()/3+1;
+  r.w = 2*get_rect().get_width()/3-2;
+  r.h = 2*get_rect().get_height()/3-2;
+
+  SDL_FillRect(target, &r, SDL_MapRGB(target->format, background.r, background.g, background.b));
+
+  r.x = get_rect().left+1;
+  r.y = get_rect().top+1;
+  r.w = 2*get_rect().get_width()/3-2;
+  r.h = 2*get_rect().get_height()/3-2;
+
+  SDL_FillRect(target, &r, SDL_MapRGB(target->format, foreground.r, foreground.g, foreground.b));
+
+  if (0) std::cout << "Color: " << (int)foreground.r << " " << (int)foreground.g << " " << (int)foreground.b << std::endl;
 }
 
 void
 ColorDisplay::set_color(const Color& color)
 {
-  m_color = color;
+  foreground = color;
   set_dirty(true);
 }
 

Modified: trunk/netbrush/src/color_display.hpp
===================================================================
--- trunk/netbrush/src/color_display.hpp	2006-10-23 21:36:13 UTC (rev 672)
+++ trunk/netbrush/src/color_display.hpp	2006-10-24 14:22:36 UTC (rev 673)
@@ -33,13 +33,14 @@
 class ColorDisplay : public Widget
 {
 private:
-  Color m_color;
+  Color foreground;
+  Color background;
 
 public:
   ColorDisplay(const Rect& rect);
   
   void on_mouse_motion(const MouseMotionEvent& motion) {}
-  void on_mouse_button(const MouseButtonEvent& button) {}
+  void on_mouse_button(const MouseButtonEvent& button);
 
   void on_enter() {}
   void on_leave() {}

Modified: trunk/netbrush/src/controller.cpp
===================================================================
--- trunk/netbrush/src/controller.cpp	2006-10-23 21:36:13 UTC (rev 672)
+++ trunk/netbrush/src/controller.cpp	2006-10-24 14:22:36 UTC (rev 673)
@@ -163,7 +163,7 @@
 Controller::set_color_hue(Uint8 hue_)
 {
   hue = hue_;
-  client_draw_param->color = Color::from_hue(hue);
+  set_color(Color::from_hue(hue));
   saturation_value_picker->set_color(client_draw_param->color);
   alpha_picker->set_color(client_draw_param->color);
 }
@@ -177,7 +177,7 @@
   Color color = Color::from_hue(hue);
   color.apply_value_saturation(value, saturation);
   alpha_picker->set_color(color);
-  client_draw_param->color = color;
+  set_color(color);
 }
 
 void

Added: trunk/netbrush/src/text_view.cpp
===================================================================
--- trunk/netbrush/src/text_view.cpp	2006-10-23 21:36:13 UTC (rev 672)
+++ trunk/netbrush/src/text_view.cpp	2006-10-24 14:22:36 UTC (rev 673)
@@ -0,0 +1,76 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#include <iostream>
+#include "SDL_tty.h"
+#include "SDL_image.h"
+#include "text_view.hpp"
+
+TextView::TextView(const Rect& rect)
+  : Widget(rect)
+{
+  SDL_Surface* temp = IMG_Load("data/fonts/8x8font.png");
+  font = TTY_CreateFont(temp, 8, 8, 
+                    "\x7f                                !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+                    "[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~");
+  tty = TTY_Create(rect.get_width()/8, rect.get_height()/8, font);
+  TTY_Clear(tty);
+  TTY_printf(tty, "netBrush Version 0.0.1");
+}
+ 
+TextView::~TextView()
+{
+  TTY_Free(tty);
+  TTY_FreeFont(font);
+}
+ 
+void
+TextView::on_mouse_motion(const MouseMotionEvent& motion)
+{
+  set_dirty(true);
+}
+
+void
+TextView::on_mouse_button(const MouseButtonEvent& button)
+{
+}
+
+void
+TextView::draw(SDL_Surface* target)
+{
+  if (0)
+    {
+      SDL_Rect r;
+      r.x = get_rect().left;
+      r.y = get_rect().top;
+      r.w = get_rect().get_width();
+      r.h = get_rect().get_height();
+
+      SDL_FillRect(target, &r, SDL_MapRGB(target->format, 255, 255, 255));
+    }
+  TTY_Blit(tty, target, get_rect().left, get_rect().top);
+}
+
+/* EOF */

Added: trunk/netbrush/src/text_view.hpp
===================================================================
--- trunk/netbrush/src/text_view.hpp	2006-10-23 21:36:13 UTC (rev 672)
+++ trunk/netbrush/src/text_view.hpp	2006-10-24 14:22:36 UTC (rev 673)
@@ -0,0 +1,60 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#ifndef HEADER_TEXT_VIEW_HPP
+#define HEADER_TEXT_VIEW_HPP
+
+#include "widget/widget.hpp"
+
+struct TTY;
+struct TTY_Font;
+
+/** */
+class TextView : public Widget
+{
+private:
+  TTY_Font* font;
+  TTY*      tty;
+
+public:
+  TextView(const Rect& rect);
+  ~TextView();
+  
+  void on_mouse_motion(const MouseMotionEvent& motion);
+  void on_mouse_button(const MouseButtonEvent& button);
+
+  void on_enter() {}
+  void on_leave() {}
+
+  void draw(SDL_Surface* target);
+  
+private:
+  TextView (const TextView&);
+  TextView& operator= (const TextView&);
+};
+
+#endif
+
+/* EOF */



From grumbel at mail.berlios.de  Sat Oct 28 22:27:47 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sat, 28 Oct 2006 22:27:47 +0200
Subject: [Flexlay-commit] r674 - in trunk/netbrush/src: . widget
Message-ID: <200610282027.k9SKRlBd024491@sheep.berlios.de>

Author: grumbel
Date: 2006-10-28 22:27:46 +0200 (Sat, 28 Oct 2006)
New Revision: 674

Modified:
   trunk/netbrush/src/airbrush_tool.cpp
   trunk/netbrush/src/airbrush_tool.hpp
   trunk/netbrush/src/client.cpp
   trunk/netbrush/src/client_connection.cpp
   trunk/netbrush/src/color_display.cpp
   trunk/netbrush/src/controller.cpp
   trunk/netbrush/src/controller.hpp
   trunk/netbrush/src/globals.cpp
   trunk/netbrush/src/globals.hpp
   trunk/netbrush/src/screen_buffer.cpp
   trunk/netbrush/src/screen_buffer.hpp
   trunk/netbrush/src/server_connection.cpp
   trunk/netbrush/src/text_view.cpp
   trunk/netbrush/src/text_view.hpp
   trunk/netbrush/src/widget/scrollbar.cpp
   trunk/netbrush/src/widget/slider_widget.cpp
   trunk/netbrush/src/widget/slider_widget.hpp
Log:
- added text view

Modified: trunk/netbrush/src/airbrush_tool.cpp
===================================================================
--- trunk/netbrush/src/airbrush_tool.cpp	2006-10-24 14:22:36 UTC (rev 673)
+++ trunk/netbrush/src/airbrush_tool.cpp	2006-10-28 20:27:46 UTC (rev 674)
@@ -33,6 +33,7 @@
 #include "airbrush_tool.hpp"
 
 AirbrushTool::AirbrushTool()
+  : current_stroke(0)
 {
 }
 

Modified: trunk/netbrush/src/airbrush_tool.hpp
===================================================================
--- trunk/netbrush/src/airbrush_tool.hpp	2006-10-24 14:22:36 UTC (rev 673)
+++ trunk/netbrush/src/airbrush_tool.hpp	2006-10-28 20:27:46 UTC (rev 674)
@@ -32,6 +32,7 @@
 class AirbrushTool : public Tool
 {
 private:
+  Stroke* current_stroke;
 
 public:
   AirbrushTool();

Modified: trunk/netbrush/src/client.cpp
===================================================================
--- trunk/netbrush/src/client.cpp	2006-10-24 14:22:36 UTC (rev 673)
+++ trunk/netbrush/src/client.cpp	2006-10-28 20:27:46 UTC (rev 674)
@@ -19,7 +19,6 @@
 #include "widget/widget_manager.hpp"
 #include "widget/scrollbar.hpp"
 #include "widget/button.hpp"
-#include "brush_widget.hpp"
 #include "navigation.hpp"
 #include "server_connection.hpp"
 #include "command_line.hpp"
@@ -105,10 +104,6 @@
                 //quit(1);
               }
             }
-          else if (event.key.keysym.sym == SDLK_u)
-            {
-              navigation->update();
-            }
           else if (event.key.keysym.sym == SDLK_ESCAPE)
             {
               exit(EXIT_SUCCESS);
@@ -279,9 +274,6 @@
     widget_manager = new WidgetManager();
     controller     = new Controller();
 
-    widget_manager->add(new TextView(Rect(38, screen->h - 38,
-                                          screen->w - 128 - 18 - 2 - 2, screen->h)));
-
     widget_manager->add(navigation = new Navigation(Rect(Point(screen->w - 128 - 2, screen->h - 128 - 2),
                                                          Size(128, 128))));
     {
@@ -306,10 +298,6 @@
                         new Scrollbar(0, canvas_width, screen_buffer->get_rect().get_width(), Scrollbar::HORIZONTAL,
                                       Rect(38, screen->h - 16 - 2 - 38,
                                            screen->w - 128 - 18 - 2 - 2, screen->h - 2 - 38)));
-    
-    brush_widget = new BrushWidget(Rect(Point(screen->w-128, 128+24+24), Size(128, 128)));
-    
-    widget_manager->add(brush_widget);
 
     // Main Loop
     while(true)

Modified: trunk/netbrush/src/client_connection.cpp
===================================================================
--- trunk/netbrush/src/client_connection.cpp	2006-10-24 14:22:36 UTC (rev 673)
+++ trunk/netbrush/src/client_connection.cpp	2006-10-28 20:27:46 UTC (rev 674)
@@ -215,6 +215,7 @@
   else if (tokens.size() >= 1 && 
            (tokens[0] == "dab" ||
             tokens[0] == "stroke_begin" ||
+            tokens[0] == "message"      ||
             tokens[0] == "stroke_end"   ||
             tokens[0] == "set_brush"    ||
             tokens[0] == "set_generic_brush" ||

Modified: trunk/netbrush/src/color_display.cpp
===================================================================
--- trunk/netbrush/src/color_display.cpp	2006-10-24 14:22:36 UTC (rev 673)
+++ trunk/netbrush/src/color_display.cpp	2006-10-28 20:27:46 UTC (rev 674)
@@ -43,6 +43,7 @@
       std::swap(background, foreground);
       controller->set_color(foreground);
       set_dirty(true);
+      controller->puts("Colors swapped");
     }
 }
 

Modified: trunk/netbrush/src/controller.cpp
===================================================================
--- trunk/netbrush/src/controller.cpp	2006-10-24 14:22:36 UTC (rev 673)
+++ trunk/netbrush/src/controller.cpp	2006-10-28 20:27:46 UTC (rev 674)
@@ -33,47 +33,48 @@
 #include "widget/slider_widget.hpp"
 #include "brush_widget.hpp"
 #include "widget/button.hpp"
+#include "text_view.hpp"
 #include "widget/widget_manager.hpp"
 #include "controller.hpp"
 
 class RadiusCallback : public SliderCallback
 {
 public:
-  void operator()(float v) {
-    controller->set_generic_brush_radius(v * 100.0f + 0.1f);
+  void operator()(int v) {
+    controller->set_generic_brush_radius(v/1000.0f);
   }
 };
 
 class SpikeCallback : public SliderCallback
 {
 public:
-  void operator()(float v) {
-    controller->set_generic_brush_spikes(int(v*18) + 2);
+  void operator()(int v) {
+    controller->set_generic_brush_spikes(v);
   }
 };
 
 class HardnessCallback : public SliderCallback
 {
 public:
-  void operator()(float v) {
-    controller->set_generic_brush_hardness(v);
+  void operator()(int v) {
+    controller->set_generic_brush_hardness(v/1000.0f);
   }
 };
 
 class AspectRatioCallback : public SliderCallback
 {
 public:
-  void operator()(float v) {
-    controller->set_generic_brush_aspect_ratio(v*19.0f + 1.0f);
+  void operator()(int v) {
+    controller->set_generic_brush_aspect_ratio(v/1000.0f);
   }
 };
 
 class AngleCallback : public SliderCallback
 {
 public:
-  void operator()(float v) 
+  void operator()(int v) 
   {
-    controller->set_generic_brush_angle(v * 180.0f);
+    controller->set_generic_brush_angle(v/1000.0f);
   }
 };
 
@@ -117,6 +118,9 @@
                                      Rect(Point(2, 2+2*34), Size(34, 34)),
                                      new ToolButtonCallback(DrawingParameter::TOOL_COLOR_PICKER)));
 
+    widget_manager->add(text_view = new TextView(Rect(38, screen->h - 38,
+                                                      screen->w - 128 - 18 - 2 - 2, screen->h)));
+
   // Color Selection
   alpha_picker            = new AlphaPicker(Rect(Point(screen->w-128, 128+24), Size(128, 24)));
   saturation_value_picker = new SaturationValuePicker(Rect(Point(screen->w-128, 0), Size(128, 128)));
@@ -129,19 +133,20 @@
   widget_manager->add(color_display);
 
   // Brush Slider
-  radius_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(0)), Size(128, 24)),
+  radius_slider = new SliderWidget(100, 48*1000, 1, 
+                                   Rect(Point(screen->w-128, 128+24+24+128+24*(0)), Size(128, 24)),
                                    new RadiusCallback());
   
-  spike_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(1)), Size(128, 24)),
+  spike_slider = new SliderWidget(2, 20, 1, Rect(Point(screen->w-128, 128+24+24+128+24*(1)), Size(128, 24)),
                                   new SpikeCallback());
   
-  hardness_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(2)), Size(128, 24)),
+  hardness_slider = new SliderWidget(0, 1000, 1, Rect(Point(screen->w-128, 128+24+24+128+24*(2)), Size(128, 24)),
                                      new HardnessCallback());
   
-  aspect_ratio_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(3)), Size(128, 24)),
+  aspect_ratio_slider = new SliderWidget(1 * 1000, 20 * 1000, 1, Rect(Point(screen->w-128, 128+24+24+128+24*(3)), Size(128, 24)),
                                          new AspectRatioCallback());
   
-  angle_slider = new SliderWidget(Rect(Point(screen->w-128, 128+24+24+128+24*(4)), Size(128, 24)),
+  angle_slider = new SliderWidget(0, 180 * 1000, 1, Rect(Point(screen->w-128, 128+24+24+128+24*(4)), Size(128, 24)),
                                   new AngleCallback());
   widget_manager->add(radius_slider);
   widget_manager->add(spike_slider);
@@ -149,6 +154,11 @@
   widget_manager->add(aspect_ratio_slider);
   widget_manager->add(angle_slider);
 
+  brush_widget = new BrushWidget(Rect(Point(screen->w-128, 128+24+24), Size(128, 128)));
+  widget_manager->add(brush_widget);
+
+  text_view->put("netBrush Version 0.0.1\n");
+  set_generic_brush(client_draw_param->generic_brush);
 }
 
 
@@ -185,6 +195,14 @@
 {
   client_draw_param->generic_brush.shape = shape;
   set_generic_brush(client_draw_param->generic_brush);
+  
+  /*
+    radius_slider->set_pos();
+  spike_slider->set_pos();;
+  hardness_slider->set_pos();
+  aspect_ratio_slider->set_pos();
+  angle_slider->set_pos();
+  */
 }
 
 void
@@ -229,6 +247,12 @@
   delete client_draw_param->brush_buffer;
   client_draw_param->brush_buffer = brush.generate();
   brush_widget->set_brush(client_draw_param->brush_buffer);
+  
+  radius_slider->set_pos(int(client_draw_param->generic_brush.radius * 1000));
+  spike_slider->set_pos(client_draw_param->generic_brush.spikes);
+  hardness_slider->set_pos(int(client_draw_param->generic_brush.hardness * 1000));
+  aspect_ratio_slider->set_pos(int(client_draw_param->generic_brush.aspect_ratio * 1000));
+  angle_slider->set_pos(int(client_draw_param->generic_brush.angle * 1000));
 
   update_mouse_cursor();
 }
@@ -320,4 +344,10 @@
   delete[] data;
 }
 
+void
+Controller::puts(const std::string& str)
+{
+  text_view->put(str+"\n");
+}
+
 /* EOF */

Modified: trunk/netbrush/src/controller.hpp
===================================================================
--- trunk/netbrush/src/controller.hpp	2006-10-24 14:22:36 UTC (rev 673)
+++ trunk/netbrush/src/controller.hpp	2006-10-28 20:27:46 UTC (rev 674)
@@ -33,6 +33,8 @@
 #include "generic_brush.hpp"
 
 class SliderWidget;
+class TextView;
+class BrushWidget;
 
 /** */
 class Controller
@@ -43,6 +45,9 @@
   AlphaPicker*           alpha_picker;
   ColorDisplay*          color_display;
 
+  BrushWidget* brush_widget;
+  TextView* text_view;
+
   SliderWidget* radius_slider;
   SliderWidget* spike_slider;
   SliderWidget* hardness_slider;
@@ -69,6 +74,8 @@
   void set_generic_brush_angle(float angle);
   void set_generic_brush(const GenericBrush& brush);
 
+  void puts(const std::string& str);
+
   void update_mouse_cursor();
 private:
   Controller (const Controller&);

Modified: trunk/netbrush/src/globals.cpp
===================================================================
--- trunk/netbrush/src/globals.cpp	2006-10-24 14:22:36 UTC (rev 673)
+++ trunk/netbrush/src/globals.cpp	2006-10-28 20:27:46 UTC (rev 674)
@@ -33,8 +33,6 @@
 
 std::map<int, ClientState*> client_states;
 
-BrushWidget*      brush_widget = 0;
-Stroke*           current_stroke = 0;
 ServerConnection* server = 0;
 
 Scrollbar* horizontal_scrollbar = 0;

Modified: trunk/netbrush/src/globals.hpp
===================================================================
--- trunk/netbrush/src/globals.hpp	2006-10-24 14:22:36 UTC (rev 673)
+++ trunk/netbrush/src/globals.hpp	2006-10-28 20:27:46 UTC (rev 674)
@@ -40,7 +40,6 @@
 class DrawingContext;
 class DrawingParameter;
 class WidgetManager;
-class BrushWidget;
 class ServerConnection;
 class Scrollbar;
 class Navigation;
@@ -49,7 +48,6 @@
 
 extern Scrollbar* horizontal_scrollbar;
 extern Scrollbar* vertical_scrollbar;
-extern BrushWidget* brush_widget;
 extern DrawingContext*   draw_ctx;
 extern DrawingParameter* client_draw_param;
 extern std::map<int, ClientState*> client_states;
@@ -58,7 +56,6 @@
 extern WidgetManager* widget_manager;
 
 extern ServerConnection* server;
-extern Stroke* current_stroke;
 
 extern Navigation* navigation;
 extern Controller* controller;

Modified: trunk/netbrush/src/screen_buffer.cpp
===================================================================
--- trunk/netbrush/src/screen_buffer.cpp	2006-10-24 14:22:36 UTC (rev 673)
+++ trunk/netbrush/src/screen_buffer.cpp	2006-10-28 20:27:46 UTC (rev 674)
@@ -116,7 +116,7 @@
       dirty_region.top  <  dirty_region.bottom)
     {
       draw_ctx->draw(target, dirty_region, trans_x, trans_y);
-      if (!scrolling)
+      if (!complete_refresh)
         stroke_buffer->draw(target, dirty_region, trans_x, trans_y);
   
       if (complete_refresh)
@@ -239,7 +239,6 @@
 void
 ScreenBuffer::force_full_refresh()
 {
-  // FIXME: Ugly! Add function for fullscreen refresh in screenbuffer
   Rect r(0, 0, screen_buffer->get_rect().get_width(), screen_buffer->get_rect().get_height());
   r.left   -= scroll_offset_x;
   r.right  -= scroll_offset_x;

Modified: trunk/netbrush/src/screen_buffer.hpp
===================================================================
--- trunk/netbrush/src/screen_buffer.hpp	2006-10-24 14:22:36 UTC (rev 673)
+++ trunk/netbrush/src/screen_buffer.hpp	2006-10-28 20:27:46 UTC (rev 674)
@@ -38,7 +38,6 @@
   //SDL_Surface* buffer;
   Rect dirty_region;
 
-  bool scrolling;
   bool complete_refresh;
 
   int scroll_offset_x;

Modified: trunk/netbrush/src/server_connection.cpp
===================================================================
--- trunk/netbrush/src/server_connection.cpp	2006-10-24 14:22:36 UTC (rev 673)
+++ trunk/netbrush/src/server_connection.cpp	2006-10-28 20:27:46 UTC (rev 674)
@@ -28,6 +28,7 @@
 #include "globals.hpp"
 #include "client_state.hpp"
 #include "color.hpp"
+#include "controller.hpp"
 #include "drawing_context.hpp"
 #include "drawing_parameter.hpp"
 #include "server_connection.hpp"
@@ -247,6 +248,13 @@
                                                 atoi(tokens[4].c_str()), 
                                                 atoi(tokens[5].c_str())));
                 }
+              else if (tokens.size() >= 3 && tokens[2] == "message")
+                {
+                  std::string str;
+                  for(int i = 3; i < int(tokens.size()); ++i)
+                    str += tokens[i] + " ";
+                  controller->puts(str);
+                }
               else if (tokens.size() == 6 && tokens[2] == "dab")
                 {
                   client_state->dab(atoi(tokens[3].c_str()), 

Modified: trunk/netbrush/src/text_view.cpp
===================================================================
--- trunk/netbrush/src/text_view.cpp	2006-10-24 14:22:36 UTC (rev 673)
+++ trunk/netbrush/src/text_view.cpp	2006-10-28 20:27:46 UTC (rev 674)
@@ -33,11 +33,10 @@
 {
   SDL_Surface* temp = IMG_Load("data/fonts/8x8font.png");
   font = TTY_CreateFont(temp, 8, 8, 
-                    "\x7f                                !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ"
-                    "[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~");
-  tty = TTY_Create(rect.get_width()/8, rect.get_height()/8, font);
-  TTY_Clear(tty);
-  TTY_printf(tty, "netBrush Version 0.0.1");
+                        "\x7f                                "
+                        "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+                        "[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~");
+  tty = TTY_Create(rect.get_width()/8, rect.get_height()/8+1, font);
 }
  
 TextView::~TextView()
@@ -60,7 +59,7 @@
 void
 TextView::draw(SDL_Surface* target)
 {
-  if (0)
+  if (1)
     {
       SDL_Rect r;
       r.x = get_rect().left;
@@ -68,9 +67,16 @@
       r.w = get_rect().get_width();
       r.h = get_rect().get_height();
 
-      SDL_FillRect(target, &r, SDL_MapRGB(target->format, 255, 255, 255));
+      SDL_FillRect(target, &r, SDL_MapRGB(target->format, 64, 64, 64));
     }
   TTY_Blit(tty, target, get_rect().left, get_rect().top);
 }
 
+void
+TextView::put(const std::string& str)
+{
+  TTY_write(tty, str.c_str(), str.size());
+  set_dirty(true);
+}
+
 /* EOF */

Modified: trunk/netbrush/src/text_view.hpp
===================================================================
--- trunk/netbrush/src/text_view.hpp	2006-10-24 14:22:36 UTC (rev 673)
+++ trunk/netbrush/src/text_view.hpp	2006-10-28 20:27:46 UTC (rev 674)
@@ -49,7 +49,8 @@
   void on_leave() {}
 
   void draw(SDL_Surface* target);
-  
+  void put(const std::string& str);
+
 private:
   TextView (const TextView&);
   TextView& operator= (const TextView&);

Modified: trunk/netbrush/src/widget/scrollbar.cpp
===================================================================
--- trunk/netbrush/src/widget/scrollbar.cpp	2006-10-24 14:22:36 UTC (rev 673)
+++ trunk/netbrush/src/widget/scrollbar.cpp	2006-10-28 20:27:46 UTC (rev 674)
@@ -79,8 +79,11 @@
 void
 Scrollbar::set_pos(int p)
 {
-  pos = p;
-  set_dirty(true);
+  if (p != pos)
+    {
+      pos = p;
+      set_dirty(true);
+    }
 }
 
 /* EOF */

Modified: trunk/netbrush/src/widget/slider_widget.cpp
===================================================================
--- trunk/netbrush/src/widget/slider_widget.cpp	2006-10-24 14:22:36 UTC (rev 673)
+++ trunk/netbrush/src/widget/slider_widget.cpp	2006-10-28 20:27:46 UTC (rev 674)
@@ -28,8 +28,14 @@
 #include "widget_manager.hpp"
 #include "slider_widget.hpp"
 
-SliderWidget::SliderWidget(const Rect& rect_, SliderCallback* callback_)
-  : Widget(rect_), callback(callback_), pos(0.5f), dragging(false)
+SliderWidget::SliderWidget(int min_, int max_, int page_step_, const Rect& rect_, SliderCallback* callback_)
+  : Widget(rect_), 
+    min(min_),
+    max(max_),
+    page_step(page_step_),
+    pos(min_),
+    callback(callback_), 
+    dragging(false)
 {
 }
 
@@ -44,8 +50,8 @@
   set_dirty(true);
   if (dragging)
     {
-      pos = float(motion.x) / get_rect().get_width();
-      pos = std::max(0.0f, std::min(pos, 1.0f));
+      pos = min + motion.x * (max - min) / get_rect().get_width();
+      pos = std::max(min, std::min(pos, max));
       (*callback)(pos);
     }
 
@@ -65,8 +71,8 @@
         {
           dragging = true;
 
-          pos = float(button.x) / get_rect().get_width();
-          pos = std::max(0.0f, std::min(pos, 1.0f));
+          pos = min + button.x * (max - min) / get_rect().get_width();
+          pos = std::max(min, std::min(pos, max));
 
           (*callback)(pos);
 
@@ -105,7 +111,7 @@
   SDL_FillRect(target, &rect, SDL_MapRGB(target->format, 100, 100, 100));
 
   SDL_Rect slider;
-  slider.x = int(get_rect().get_width() * pos) + get_rect().left - 4;
+  slider.x = int(get_rect().get_width() * (pos - min)/(max - min)) + get_rect().left - 4;
   slider.y = 2 + get_rect().top;
   slider.w = 8;
   slider.h = get_rect().get_height() - 4;
@@ -113,4 +119,14 @@
   SDL_FillRect(target, &slider, SDL_MapRGB(target->format, 0, 0, 0));
 }
 
+void
+SliderWidget::set_pos(int v)
+{
+  if (pos != v)
+    {
+      pos = v;
+      set_dirty(true);
+    }
+}
+
 /* EOF */

Modified: trunk/netbrush/src/widget/slider_widget.hpp
===================================================================
--- trunk/netbrush/src/widget/slider_widget.hpp	2006-10-24 14:22:36 UTC (rev 673)
+++ trunk/netbrush/src/widget/slider_widget.hpp	2006-10-28 20:27:46 UTC (rev 674)
@@ -34,7 +34,7 @@
 public:
   SliderCallback() {}
   virtual ~SliderCallback() {}
-  virtual void operator()(float) =0;
+  virtual void operator()(int) =0;
 
 private:
   SliderCallback (const SliderCallback&);
@@ -45,12 +45,16 @@
 class SliderWidget : public Widget
 {
 private:
+  int min;
+  int max;
+  int page_step;
+  int pos;
+
   SliderCallback* callback;
-  float pos;
   bool  dragging;
   
 public:
-  SliderWidget(const Rect& rect_, SliderCallback* callback);
+  SliderWidget(int min, int max, int page_step, const Rect& rect_, SliderCallback* callback);
   ~SliderWidget();
 
   void on_mouse_motion(const MouseMotionEvent& motion);
@@ -61,6 +65,8 @@
 
   void draw(SDL_Surface* target);
 
+  void set_pos(int v);
+
 private:
   SliderWidget (const SliderWidget&);
   SliderWidget& operator= (const SliderWidget&);



From grumbel at mail.berlios.de  Sat Oct 28 22:39:06 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sat, 28 Oct 2006 22:39:06 +0200
Subject: [Flexlay-commit] r675 - trunk/netbrush
Message-ID: <200610282039.k9SKd6N4026051@sheep.berlios.de>

Author: grumbel
Date: 2006-10-28 22:39:06 +0200 (Sat, 28 Oct 2006)
New Revision: 675

Modified:
   trunk/netbrush/SConstruct
Log:


Modified: trunk/netbrush/SConstruct
===================================================================
--- trunk/netbrush/SConstruct	2006-10-28 20:27:46 UTC (rev 674)
+++ trunk/netbrush/SConstruct	2006-10-28 20:39:06 UTC (rev 675)
@@ -15,6 +15,7 @@
 server_env.ParseConfig('sdl-config --cflags --libs')
 server_env['CXXFLAGS'] += ['-O0', '-Wall', '-g']
 server_env['LIBS'] += ['SDL_net'] + libcommon
+server_env['LIBPATH'] += ['.']
 server_env.Program('netbrush-server', [
         'src/server.cpp',
         'src/client_connection.cpp',
@@ -24,6 +25,7 @@
 client_env.ParseConfig('sdl-config --cflags --libs')
 client_env['CXXFLAGS'] += ['-O0', '-Wall', '-g']
 client_env['CPPPATH'] += ['src/']
+client_env['LIBPATH'] += ['.']
 client_env['LIBS'] += ['SDL_image', 'SDL_net'] + libcommon
 client_env.Program('netbrush-client', [
         'src/alpha_picker.cpp',



From grumbel at mail.berlios.de  Sun Oct 29 15:33:23 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 29 Oct 2006 15:33:23 +0100
Subject: [Flexlay-commit] r676 - trunk/netbrush/src
Message-ID: <200610291433.k9TEXNLl015306@sheep.berlios.de>

Author: grumbel
Date: 2006-10-29 15:33:22 +0100 (Sun, 29 Oct 2006)
New Revision: 676

Modified:
   trunk/netbrush/src/client.cpp
   trunk/netbrush/src/controller.cpp
   trunk/netbrush/src/controller.hpp
   trunk/netbrush/src/drawing_context.cpp
   trunk/netbrush/src/drawing_context.hpp
   trunk/netbrush/src/stroke.cpp
   trunk/netbrush/src/stroke.hpp
   trunk/netbrush/src/stroke_buffer.cpp
   trunk/netbrush/src/stroke_buffer.hpp
Log:
- added PNG saving (press F5)
- added DabInterpolater

Modified: trunk/netbrush/src/client.cpp
===================================================================
--- trunk/netbrush/src/client.cpp	2006-10-28 20:39:06 UTC (rev 675)
+++ trunk/netbrush/src/client.cpp	2006-10-29 14:33:22 UTC (rev 676)
@@ -26,6 +26,12 @@
 #include "widget/slider_widget.hpp"
 #include "controller.hpp"
 
+#ifdef WIN32
+#include  <io.h>
+#define access _access
+#define F_OK   0
+#endif
+
 SDL_Rect* make_rect(int x, int y, int w, int h)
 {
   static SDL_Rect rect;
@@ -97,6 +103,23 @@
             {
               client_draw_param->opacity = std::min(255, client_draw_param->opacity + 16);
             }
+          else if (event.key.keysym.sym == SDLK_F5)
+            {
+              int j = 1;
+              std::string fname;
+              std::ostringstream filename;
+              do 
+                {
+                  filename.str("");
+                  filename << "images/canvas-" << j << ".png";
+                  fname = filename.str();
+                  j += 1;
+              }
+              while (access(fname.c_str(), F_OK) == 0);
+              
+              controller->save_png(fname);
+
+            }
           else if (event.key.keysym.sym == SDLK_F11)
             {
               if (SDL_WM_ToggleFullScreen(screen) == 0) {
@@ -244,8 +267,7 @@
     screen_buffer = new ScreenBuffer(Rect(38, 2, screen->w - 128 - 18 - 2 - 2, screen->h - 16 - 4 - 38)); 
     draw_ctx      = new DrawingContext(canvas_width, canvas_height);
     stroke_buffer = new StrokeBuffer(canvas_width, canvas_height);
-
-
+    
     //std::cout << "# clear screen" << std::endl;
 
     // clear screen

Modified: trunk/netbrush/src/controller.cpp
===================================================================
--- trunk/netbrush/src/controller.cpp	2006-10-28 20:39:06 UTC (rev 675)
+++ trunk/netbrush/src/controller.cpp	2006-10-29 14:33:22 UTC (rev 676)
@@ -28,6 +28,7 @@
 #include "alpha_picker.hpp"
 #include "hue_picker.hpp"
 #include "saturation_value_picker.hpp"
+#include "drawing_context.hpp"
 #include "globals.hpp"
 #include "drawing_parameter.hpp"
 #include "widget/slider_widget.hpp"
@@ -350,4 +351,11 @@
   text_view->put(str+"\n");
 }
 
+void
+Controller::save_png(const std::string& filename)
+{
+  draw_ctx->save_png(filename);
+  puts("Wrote PNG: " + filename);
+}
+
 /* EOF */

Modified: trunk/netbrush/src/controller.hpp
===================================================================
--- trunk/netbrush/src/controller.hpp	2006-10-28 20:39:06 UTC (rev 675)
+++ trunk/netbrush/src/controller.hpp	2006-10-29 14:33:22 UTC (rev 676)
@@ -77,6 +77,7 @@
   void puts(const std::string& str);
 
   void update_mouse_cursor();
+  void save_png(const std::string& filename);
 private:
   Controller (const Controller&);
   Controller& operator= (const Controller&);

Modified: trunk/netbrush/src/drawing_context.cpp
===================================================================
--- trunk/netbrush/src/drawing_context.cpp	2006-10-28 20:39:06 UTC (rev 675)
+++ trunk/netbrush/src/drawing_context.cpp	2006-10-29 14:33:22 UTC (rev 676)
@@ -23,6 +23,7 @@
 **  02111-1307, USA.
 */
 
+#include <png.h>
 #include <iostream>
 #include "globals.hpp"
 #include "screen_buffer.hpp"
@@ -184,4 +185,61 @@
     }
 }
 
+void
+DrawingContext::save_png(const std::string& filename)
+{
+  SDL_LockSurface(drawable);
+
+  // FIXME: could/should check the right drawable format
+
+  FILE* fp;
+  fp = fopen(filename.c_str (), "wb");
+  if (fp == NULL)
+    {
+      std::cout << "Error: Couldn't write " << filename << std::endl;
+      return;
+    }
+
+  png_structp png_ptr;
+  png_infop info_ptr;
+
+  png_ptr  = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
+  info_ptr = png_create_info_struct(png_ptr);
+
+  png_init_io(png_ptr, fp);
+
+  png_set_IHDR(png_ptr, info_ptr, 
+               drawable->w, drawable->h, 8 /* bitdepth */,
+               PNG_COLOR_TYPE_RGB,
+               PNG_INTERLACE_NONE, 
+               PNG_COMPRESSION_TYPE_BASE, 
+               PNG_FILTER_TYPE_BASE);
+
+  png_write_info(png_ptr, info_ptr);
+
+  png_uint_32 height    = drawable->h;
+  png_uint_32 row_bytes = drawable->w * 3;
+
+  png_byte* image = new png_byte[height * row_bytes];
+  png_bytep* row_pointers = new png_bytep[height];
+
+  // fill the image with data
+  for (int i = 0; i < drawable->w*drawable->h*3; ++i)
+    image[i] = static_cast<unsigned char*>(drawable->pixels)[i];
+
+  // generate row pointers
+  for (unsigned int k = 0; k < height; k++)
+    row_pointers[k] = image + (k * row_bytes);
+
+  png_write_image(png_ptr, row_pointers);
+
+  png_write_end(png_ptr, info_ptr);
+
+  delete image;
+  delete row_pointers;
+
+  fclose(fp);
+  SDL_UnlockSurface(drawable);
+}
+
 /* EOF */

Modified: trunk/netbrush/src/drawing_context.hpp
===================================================================
--- trunk/netbrush/src/drawing_context.hpp	2006-10-28 20:39:06 UTC (rev 675)
+++ trunk/netbrush/src/drawing_context.hpp	2006-10-29 14:33:22 UTC (rev 676)
@@ -55,6 +55,8 @@
   int get_height() const { return drawable->h; }
   bool get_color(int x, int y, Color& color);
   SDL_Surface* get_surface() { return drawable; }
+
+  void save_png(const std::string& filename);
 };
 
 #endif

Modified: trunk/netbrush/src/stroke.cpp
===================================================================
--- trunk/netbrush/src/stroke.cpp	2006-10-28 20:39:06 UTC (rev 675)
+++ trunk/netbrush/src/stroke.cpp	2006-10-29 14:33:22 UTC (rev 676)
@@ -26,6 +26,65 @@
 #include <math.h>
 #include "stroke.hpp"
 
+DabInterpolater::DabInterpolater(float x_spacing_, float y_spacing_)
+  : x_spacing(x_spacing_),
+    y_spacing(y_spacing_),
+    overspace(0.0f)
+{
+  
+}
+
+const Stroke::Dabs&
+DabInterpolater::get_interpolated_dabs() const
+{
+  return interpolated_dabs;
+}
+
+void
+DabInterpolater::add_dab(const Dab& dab)
+{
+  if (dabs.empty())
+    { // First dab
+      interpolated_dabs.push_back(dab);
+      dabs.push_back(dab);
+    }
+  else
+    {
+      // The following code basically takes all the event dabs as recieved
+      // by from the InputDevice and interpolates new dabs inbetween to
+      // give them an equal spacing (ie. every dab is only 'spacing' away
+      // from the next)
+      
+      const Dab& prev_dab = dabs.back();
+      const Dab& next_dab = dab;
+
+      Vector dist  = next_dab.pos - prev_dab.pos;
+      float length = sqrt(dist.x * dist.x + dist.y * dist.y);
+      int n = 1;
+    
+      // Spacing is keep relative to the brush size
+      // FIXME: This is specific to a Sprite based drawer, might not work for others
+      // FIXME: y_spacing isn't taken into account either
+      float local_spacing = x_spacing * prev_dab.pressure;
+
+      while (length + overspace > (local_spacing * n))
+        {
+          float factor = (local_spacing/length) * n - (overspace/length);
+          
+          // FIXME: Interpolate tilting, pressure, etc. along the line
+          interpolated_dabs.push_back(Dab(prev_dab.pos.x + dist.x * factor,
+                                          prev_dab.pos.y + dist.y * factor,
+                                          prev_dab.pressure));
+          n += 1;
+        }
+
+      // calculate the space that wasn't used in the last iteration
+      overspace = (length + overspace) - (local_spacing * (n-1));
+
+      dabs.push_back(dab);
+    }
+}
+
 Stroke::Stroke()
 {
   

Modified: trunk/netbrush/src/stroke.hpp
===================================================================
--- trunk/netbrush/src/stroke.hpp	2006-10-28 20:39:06 UTC (rev 675)
+++ trunk/netbrush/src/stroke.hpp	2006-10-29 14:33:22 UTC (rev 676)
@@ -99,6 +99,23 @@
   Stroke& operator= (const Stroke&);
 };
 
+class DabInterpolater
+{
+private:
+  float x_spacing;
+  float y_spacing;
+  float overspace;
+
+  Stroke::Dabs interpolated_dabs;
+  Stroke::Dabs dabs;
+
+public: 
+  DabInterpolater(float x_spacing_, float y_spacing_);
+
+  void add_dab(const Dab& dab);
+  const Stroke::Dabs& get_interpolated_dabs() const;
+};
+
 #endif
 
 /* EOF */

Modified: trunk/netbrush/src/stroke_buffer.cpp
===================================================================
--- trunk/netbrush/src/stroke_buffer.cpp	2006-10-28 20:39:06 UTC (rev 675)
+++ trunk/netbrush/src/stroke_buffer.cpp	2006-10-29 14:33:22 UTC (rev 676)
@@ -32,7 +32,7 @@
 #include "stroke_buffer.hpp"
 
 StrokeBuffer::StrokeBuffer(int w, int h)
-  : param(0)
+  : param(0), interpolater(0)
 {
   buffer = new GrayscaleBuffer(w, h, 0);
   stroke = new Stroke();
@@ -42,6 +42,7 @@
 {
   delete stroke;
   delete buffer;
+  delete interpolater;
 }
 
 void
@@ -58,6 +59,9 @@
   // FIXME: This doesn't belong here
   delete this->stroke;
   this->stroke = new Stroke();
+
+  delete interpolater;
+  interpolater = 0;
 }
 
 void
@@ -67,21 +71,38 @@
   //for(int x = - 5; x < 10; ++x)
   //buffer->at(int(dab.pos.x)+x, int(dab.pos.y)+y) = 128;
 
+  stroke->add_dab(dab);
   GrayscaleBuffer* brush = param->get_brush_buffer();
 
-  stroke->add_dab(dab);
-  if (1)
+  if (param->tool == DrawingParameter::TOOL_PAINTBRUSH)
     {
+      if (!interpolater)
+        {
+          interpolater = new DabInterpolater(param->get_spacing(), param->get_spacing());
+        }
+
+      Stroke::Dabs::size_type last_dabs_size = interpolater->get_interpolated_dabs().size();
+      interpolater->add_dab(dab);
+      
+      if (last_dabs_size < interpolater->get_interpolated_dabs().size())
+        {
+          const Stroke::Dabs& dabs = interpolater->get_interpolated_dabs();
+          for(Stroke::Dabs::const_iterator i = dabs.begin() + last_dabs_size; i != dabs.end(); ++i)
+            {
+              buffer->blit(brush,
+                           static_cast<int>(i->pos.x - brush->get_width()/2), 
+                           static_cast<int>(i->pos.y - brush->get_height()/2), 
+                           GrayscaleBuffer::ALPHA);
+            }
+        }
+    }
+  else if (param->tool == DrawingParameter::TOOL_AIRBRUSH)
+    {
       buffer->blit(brush,
                    static_cast<int>(dab.pos.x - brush->get_width()/2), 
                    static_cast<int>(dab.pos.y - brush->get_height()/2), 
                    GrayscaleBuffer::ALPHA);
     }
-  else
-    { // FIXME: SLOW!
-      buffer->clear(0);
-      draw_stroke(*stroke, param);
-    }
 }
 
 void
@@ -113,58 +134,58 @@
     }
 }
 
-  void
-    StrokeBuffer::draw(SDL_Surface* target, const Rect& rect, int x_of, int y_of)
-  { 
-    // rect is in screenspace, x_of, y_of tell how to go from canvas to screenspace
-    SDL_LockSurface(target);
+void
+StrokeBuffer::draw(SDL_Surface* target, const Rect& rect, int x_of, int y_of)
+{ 
+  // rect is in screenspace, x_of, y_of tell how to go from canvas to screenspace
+  SDL_LockSurface(target);
 
-    Uint8* dst = static_cast<Uint8*>(target->pixels);
-    Uint8* src = buffer->get_data();
+  Uint8* dst = static_cast<Uint8*>(target->pixels);
+  Uint8* src = buffer->get_data();
   
-    assert(rect.left >= 0);
-    if (0)
-      std::cout << "StrokeBuffer::draw: " << target << " " << rect.left << " " << rect.top << " "
-                << rect.right << " " << rect.bottom << " - " << x_of << " " << y_of << std::endl;
+  assert(rect.left >= 0);
+  if (0)
+    std::cout << "StrokeBuffer::draw: " << target << " " << rect.left << " " << rect.top << " "
+              << rect.right << " " << rect.bottom << " - " << x_of << " " << y_of << std::endl;
 
-    if (target == screen) // FIXME: Ugly workaround
-      {
-        for(int y = rect.top; y < rect.bottom; ++y)
-          for(int x = rect.left; x < rect.right; ++x)
-            {
-              Uint8* d = dst + (y * target->pitch + target->format->BytesPerPixel * x);
-              Uint8  s = src[(y - y_of) * buffer->get_width() + (x - x_of)];
+  if (target == screen) // FIXME: Ugly workaround
+    {
+      for(int y = rect.top; y < rect.bottom; ++y)
+        for(int x = rect.left; x < rect.right; ++x)
+          {
+            Uint8* d = dst + (y * target->pitch + target->format->BytesPerPixel * x);
+            Uint8  s = src[(y - y_of) * buffer->get_width() + (x - x_of)];
 
-              s = (s * param->opacity)/255;
+            s = (s * param->opacity)/255;
 
-              d[0] = ((255 - s) * d[0] + (s * param->color.b))/255;
-              d[1] = ((255 - s) * d[1] + (s * param->color.g))/255;
-              d[2] = ((255 - s) * d[2] + (s * param->color.r))/255;
-            }
-      }
-    else
-      {
-        for(int y = rect.top; y < rect.bottom; ++y)
-          for(int x = rect.left; x < rect.right; ++x)
-            {
-              Uint8* d = dst + (y * target->pitch + target->format->BytesPerPixel * x);
-              Uint8  s = src[(y - y_of) * buffer->get_width() + (x - x_of)];
+            d[0] = ((255 - s) * d[0] + (s * param->color.b))/255;
+            d[1] = ((255 - s) * d[1] + (s * param->color.g))/255;
+            d[2] = ((255 - s) * d[2] + (s * param->color.r))/255;
+          }
+    }
+  else
+    {
+      for(int y = rect.top; y < rect.bottom; ++y)
+        for(int x = rect.left; x < rect.right; ++x)
+          {
+            Uint8* d = dst + (y * target->pitch + target->format->BytesPerPixel * x);
+            Uint8  s = src[(y - y_of) * buffer->get_width() + (x - x_of)];
 
-              s = (s * param->opacity)/255;
+            s = (s * param->opacity)/255;
 
-              d[0] = ((255 - s) * d[0] + (s * param->color.r))/255;
-              d[1] = ((255 - s) * d[1] + (s * param->color.g))/255;
-              d[2] = ((255 - s) * d[2] + (s * param->color.b))/255;
-            }
-      }
+            d[0] = ((255 - s) * d[0] + (s * param->color.r))/255;
+            d[1] = ((255 - s) * d[1] + (s * param->color.g))/255;
+            d[2] = ((255 - s) * d[2] + (s * param->color.b))/255;
+          }
+    }
 
-    SDL_UnlockSurface(target);
-  }
+  SDL_UnlockSurface(target);
+}
 
-  void
-    StrokeBuffer::set_param(DrawingParameter* param_)
-  {
-    param = param_;
-  }
+void
+StrokeBuffer::set_param(DrawingParameter* param_)
+{
+  param = param_;
+}
 
-  /* EOF */
+/* EOF */

Modified: trunk/netbrush/src/stroke_buffer.hpp
===================================================================
--- trunk/netbrush/src/stroke_buffer.hpp	2006-10-28 20:39:06 UTC (rev 675)
+++ trunk/netbrush/src/stroke_buffer.hpp	2006-10-29 14:33:22 UTC (rev 676)
@@ -30,6 +30,7 @@
 class DrawingParameter;
 class Dab;
 class GrayscaleBuffer;
+class DabInterpolater;
 
 /** */
 class StrokeBuffer
@@ -38,6 +39,7 @@
   GrayscaleBuffer*  buffer;
   Stroke*           stroke;
   DrawingParameter* param;
+  DabInterpolater*  interpolater;
 
 public:
   StrokeBuffer(int w, int h);



From grumbel at mail.berlios.de  Sun Oct 29 16:17:22 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 29 Oct 2006 16:17:22 +0100
Subject: [Flexlay-commit] r678 - in trunk/netbrush: . src
Message-ID: <200610291517.k9TFHMeM019651@sheep.berlios.de>

Author: grumbel
Date: 2006-10-29 16:17:22 +0100 (Sun, 29 Oct 2006)
New Revision: 678

Modified:
   trunk/netbrush/AUTHORS
   trunk/netbrush/src/controller.cpp
   trunk/netbrush/src/hue_picker.cpp
Log:
- removed colorpicker button (simply use right click for now)

Modified: trunk/netbrush/AUTHORS
===================================================================
--- trunk/netbrush/AUTHORS	2006-10-29 14:35:34 UTC (rev 677)
+++ trunk/netbrush/AUTHORS	2006-10-29 15:17:22 UTC (rev 678)
@@ -1 +1,5 @@
 Ingo Ruhnke <grumbel at gmx.de>
+
+Icons are taken from Gimp
+
+# EOF #

Modified: trunk/netbrush/src/controller.cpp
===================================================================
--- trunk/netbrush/src/controller.cpp	2006-10-29 14:35:34 UTC (rev 677)
+++ trunk/netbrush/src/controller.cpp	2006-10-29 15:17:22 UTC (rev 678)
@@ -115,9 +115,9 @@
     widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-paintbrush-22.png"), 
                                    Rect(Point(2, 2+1*34), Size(34, 34)),
                                    new ToolButtonCallback(DrawingParameter::TOOL_PAINTBRUSH)));
-    widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-color-picker-22.png"), 
-                                     Rect(Point(2, 2+2*34), Size(34, 34)),
-                                     new ToolButtonCallback(DrawingParameter::TOOL_COLOR_PICKER)));
+    //widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-color-picker-22.png"), 
+    //                               Rect(Point(2, 2+2*34), Size(34, 34)),
+    //                               new ToolButtonCallback(DrawingParameter::TOOL_COLOR_PICKER)));
 
     widget_manager->add(text_view = new TextView(Rect(38, screen->h - 38,
                                                       screen->w - 128 - 18 - 2 - 2, screen->h)));
@@ -160,14 +160,28 @@
 
   text_view->put("netBrush Version 0.0.1\n");
   set_generic_brush(client_draw_param->generic_brush);
+
+  set_color(Color(0, 0, 0));
+
+  saturation_value_picker->set_color(Color(1, 0, 0));
 }
 
-
 void
 Controller::set_color(const Color& color)
 {
   client_draw_param->color = color;
   color_display->set_color(color);
+  
+  //alpha_picker->set_color(color);
+  
+  //saturation_value_picker->set_color(color); // FIXME: Should use hue instead of color
+
+  if (0) 
+    { // FIXME: all buggy
+      HSVColor hsv = HSVColor::from_rgb(color);
+      saturation_value_picker->set_color(Color::from_hue(hsv.hue));
+      hue_picker->set_hue(hsv.hue);
+    }
 }
 
 void

Modified: trunk/netbrush/src/hue_picker.cpp
===================================================================
--- trunk/netbrush/src/hue_picker.cpp	2006-10-29 14:35:34 UTC (rev 677)
+++ trunk/netbrush/src/hue_picker.cpp	2006-10-29 15:17:22 UTC (rev 678)
@@ -108,4 +108,11 @@
   SDL_FillRect(target, &vline, SDL_MapRGB(target->format, 0, 0, 0));
 }
 
+void
+HuePicker::set_hue(Uint8 hue)
+{
+  click_pos.x = (hue * get_rect().get_width()) / 255;
+  set_dirty(true);
+}
+
 /* EOF */



From grumbel at mail.berlios.de  Sun Oct 29 16:37:12 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 29 Oct 2006 16:37:12 +0100
Subject: [Flexlay-commit] r679 - in trunk/netbrush: . src
Message-ID: <200610291537.k9TFbCVp021368@sheep.berlios.de>

Author: grumbel
Date: 2006-10-29 16:37:12 +0100 (Sun, 29 Oct 2006)
New Revision: 679

Added:
   trunk/netbrush/INSTALL
Modified:
   trunk/netbrush/AUTHORS
   trunk/netbrush/BUGS
   trunk/netbrush/NEWS
   trunk/netbrush/README
   trunk/netbrush/src/controller.cpp
Log:
- some release polishing

Modified: trunk/netbrush/AUTHORS
===================================================================
--- trunk/netbrush/AUTHORS	2006-10-29 15:17:22 UTC (rev 678)
+++ trunk/netbrush/AUTHORS	2006-10-29 15:37:12 UTC (rev 679)
@@ -1,5 +1,5 @@
 Ingo Ruhnke <grumbel at gmx.de>
 
-Icons are taken from Gimp
+Icons are taken from Gimp, generic brush code as well
 
 # EOF #

Modified: trunk/netbrush/BUGS
===================================================================
--- trunk/netbrush/BUGS	2006-10-29 15:17:22 UTC (rev 678)
+++ trunk/netbrush/BUGS	2006-10-29 15:37:12 UTC (rev 679)
@@ -1,5 +1,17 @@
+           _   ___             _           ___ _   _  ___ ___  ||
+  _ _  ___| |_| _ )_ _ _  _ __| |_   ___  | _ ) | | |/ __/ __| ||
+ | ' \/ -_)  _| _ \ '_| || (_-<   | |___| | _ \ |_| | (_ \__ \ ||
+ |_||_\___|\__|___/_|  \_,_/__/_|_|       |___/\___/ \___|___/ ||
+==============================================================='
+
 - color format isn't handled correctly at some points in the code (Navigator) 
+
 - some parts of code should probally enforce a specific color format
 
+- server is single thread, so it gets a little unresponsive from time
+  to time
+
+- picking a color doesn't change the color widgets correctly
+
+
 # EOF #
- 
\ No newline at end of file

Added: trunk/netbrush/INSTALL
===================================================================
--- trunk/netbrush/INSTALL	2006-10-29 15:17:22 UTC (rev 678)
+++ trunk/netbrush/INSTALL	2006-10-29 15:37:12 UTC (rev 679)
@@ -0,0 +1,3 @@
+see README
+
+# EOF #

Modified: trunk/netbrush/NEWS
===================================================================
--- trunk/netbrush/NEWS	2006-10-29 15:17:22 UTC (rev 678)
+++ trunk/netbrush/NEWS	2006-10-29 15:37:12 UTC (rev 679)
@@ -1,3 +1,12 @@
+netbrush 0.1.0
+==============
+- fixed airbrush and paintbrush
+- added PNG save (press F5)
+- added color picker (press right mouse button)
+- added text widget for log messages
+- added color swap widget
+
+
 netbrush 0.0.7
 ==============
 - fixed scrolling 
@@ -4,14 +13,16 @@
 - added thumbnail-navigation widget
 - added airbrush and paintbrush tools
 
+
 netbrush 0.0.6
 ==============
-
 - Gimp-style generic brushes
 - scrolling (buggy)
 - load/save on the server side
 
+
 netbrush 0.0.0 (Oct 12 2006)
 ============================
+- initial version
 
 # EOF #

Modified: trunk/netbrush/README
===================================================================
--- trunk/netbrush/README	2006-10-29 15:17:22 UTC (rev 678)
+++ trunk/netbrush/README	2006-10-29 15:37:12 UTC (rev 679)
@@ -6,35 +6,56 @@
 
 netBrush is a network based drawing programming, meaning it allows
 multiple people to draw on the same canvas at the same time. The
-current feature set of netBrush is limited to a fixed size canvas and
-a simple brush tool, changing brush size, hardness, color, opacity,
-etc. is possible. 
+feature set of netBrush includes a variable sized canvas canvas and a
+simple brush and airbrush tools, changing brush size, hardness, color,
+opacity, etc. is possible. You can also record and play back events
+send to the server as well as manipulate them, for example to scale up
+an image.
 
 netBrush is based on SDL and doesn't use any external widget
-libraries, so it should be very portable. In addition to the base SDL
-library netBrush also uses SDL_net and SDL_image.
+libraries, so it should be reasonably portable. In addition to the
+base SDL library netBrush also uses scons, SDL_net and SDL_image.
 
 Latest version of netBrush can be found at, no real webside exist yet:
 
  * svn co svn://svn.berlios.de/flexlay/trunk/netbrush/
 
-Question coments can go to the author, who is reachable at
+Question and comments can go to the author, who is reachable at
 grumbel at gmx.de.
 
 
+Compile:
+~~~~~~~~
+
+Just type 'scons', rest should happen automatically.
+
+
 Usage:
 ~~~~~~
 
-netBrush is client/server based, so to take full use of it, you have
+netBrush is client/server based, so to make full use of it, you have
 to start the server first, a simple:
 
-./netbrush-server 4711
+  $ ./netbrush-server 4711
 
 will do, 4711 being the port number.
 
 To start the client you have to give it a hostname and a port, like
 this:
 
-./netbrush-client localhost 4711
+  $ ./netbrush-client localhost 4711
 
+You can save the canvas by pressing F5 and you can cause the server to
+save the event data by sending a "save NAME" to the server port:
+
+ $ nc localhost 4711
+ save mypicture
+
+You can also replay an event log back to the server, to do so use:
+
+ $ cat images/nolok-1.nbr | ./scale.rb 1 | nc localhost 4711
+
+Changing the value you give to scale.rb scales the image up or down.
+
+
 # EOF #

Modified: trunk/netbrush/src/controller.cpp
===================================================================
--- trunk/netbrush/src/controller.cpp	2006-10-29 15:17:22 UTC (rev 678)
+++ trunk/netbrush/src/controller.cpp	2006-10-29 15:37:12 UTC (rev 679)
@@ -158,7 +158,7 @@
   brush_widget = new BrushWidget(Rect(Point(screen->w-128, 128+24+24), Size(128, 128)));
   widget_manager->add(brush_widget);
 
-  text_view->put("netBrush Version 0.0.1\n");
+  text_view->put("netBrush Version 0.1.0\n");
   set_generic_brush(client_draw_param->generic_brush);
 
   set_color(Color(0, 0, 0));



From grumbel at mail.berlios.de  Mon Oct 30 16:12:29 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Mon, 30 Oct 2006 16:12:29 +0100
Subject: [Flexlay-commit] r680 - trunk/netbrush/src
Message-ID: <200610301512.k9UFCTej026482@sheep.berlios.de>

Author: grumbel
Date: 2006-10-30 16:12:28 +0100 (Mon, 30 Oct 2006)
New Revision: 680

Modified:
   trunk/netbrush/src/client_connection.cpp
   trunk/netbrush/src/client_state.cpp
   trunk/netbrush/src/client_state.hpp
   trunk/netbrush/src/drawing_context.cpp
   trunk/netbrush/src/drawing_context.hpp
   trunk/netbrush/src/server_connection.cpp
Log:
- added copy_region

Modified: trunk/netbrush/src/client_connection.cpp
===================================================================
--- trunk/netbrush/src/client_connection.cpp	2006-10-29 15:37:12 UTC (rev 679)
+++ trunk/netbrush/src/client_connection.cpp	2006-10-30 15:12:28 UTC (rev 680)
@@ -221,6 +221,7 @@
             tokens[0] == "set_generic_brush" ||
             tokens[0] == "set_color"    ||
             tokens[0] == "set_tool"     ||
+            tokens[0] == "copy_region"  ||
             tokens[0] == "set_opacity" 
             ))
     {

Modified: trunk/netbrush/src/client_state.cpp
===================================================================
--- trunk/netbrush/src/client_state.cpp	2006-10-29 15:37:12 UTC (rev 679)
+++ trunk/netbrush/src/client_state.cpp	2006-10-30 15:12:28 UTC (rev 680)
@@ -119,4 +119,12 @@
     }
 }
 
+void
+ClientState::copy_region(const Rect& rect, const Point& target)
+{ // FIXME: use float position here instead of int
+  SDL_Surface* surface = draw_ctx->get_surface(rect);
+  draw_ctx->blit(surface, target);
+  SDL_FreeSurface(surface);
+}
+
 /* EOF */

Modified: trunk/netbrush/src/client_state.hpp
===================================================================
--- trunk/netbrush/src/client_state.hpp	2006-10-29 15:37:12 UTC (rev 679)
+++ trunk/netbrush/src/client_state.hpp	2006-10-30 15:12:28 UTC (rev 680)
@@ -30,6 +30,8 @@
 #include "brushmask.hpp"
 #include "drawing_parameter.hpp"
 
+class Rect;
+class Point;
 class Color;
 class Stroke;
 class DrawingParameter;
@@ -58,6 +60,8 @@
   void stroke_begin();
   void stroke_end();
 
+  void copy_region(const Rect& rect, const Point& target);
+
   void dab(unsigned int time, int x, int y);
 };
 

Modified: trunk/netbrush/src/drawing_context.cpp
===================================================================
--- trunk/netbrush/src/drawing_context.cpp	2006-10-29 15:37:12 UTC (rev 679)
+++ trunk/netbrush/src/drawing_context.cpp	2006-10-30 15:12:28 UTC (rev 680)
@@ -36,29 +36,7 @@
 
 DrawingContext::DrawingContext(int w, int h) 
 {
-  Uint32 rmask, gmask, bmask, amask;
-
-  /* SDL interprets each pixel as a 32-bit number, so our masks must depend
-     on the endianness (byte order) of the machine */
-#if SDL_BYTEORDER == SDL_BIG_ENDIAN
-  rmask = 0xff000000;
-  gmask = 0x00ff0000;
-  bmask = 0x0000ff00;
-  amask = 0; //0x000000ff;
-#else
-  rmask = 0x000000ff;
-  gmask = 0x0000ff00;
-  bmask = 0x00ff0000;
-  amask = 0; //0xff000000;
-#endif
-
-  drawable = SDL_CreateRGBSurface(SDL_SWSURFACE, w, h, 24,
-                                  rmask, gmask, bmask, amask);
-  if(drawable == NULL) {
-    fprintf(stderr, "CreateRGBSurface failed: %s\n", SDL_GetError());
-    exit(1);
-  }
-
+  drawable = create_surface(w, h);
   stroke_buffer = new StrokeBuffer(w, h);
 }
 
@@ -242,4 +220,37 @@
   SDL_UnlockSurface(drawable);
 }
 
+SDL_Surface*
+DrawingContext::get_surface(const Rect& rect)
+{
+  SDL_Surface* region = create_surface(rect.get_width(), rect.get_height());
+  // Fill with white (FIXME: should be alpha or background color)
+  SDL_FillRect(region, NULL, SDL_MapRGB(region->format, 255, 255, 255));
+  
+  SDL_Rect source_pos;
+  // FIXME: Do we need to clip those?
+  source_pos.x = rect.left;
+  source_pos.y = rect.top;
+  source_pos.w = rect.get_width();
+  source_pos.h = rect.get_height();
+
+  SDL_Rect target_pos;
+  target_pos.x = 0;
+  target_pos.y = 0;
+
+  SDL_BlitSurface(drawable, &source_pos, region, &target_pos);  
+
+  return region;
+}
+
+void
+DrawingContext::blit(SDL_Surface* source, const Point& pos)
+{
+  SDL_Rect target_pos;
+  target_pos.x = pos.x;
+  target_pos.y = pos.y;
+
+  SDL_BlitSurface(source, NULL, drawable, &target_pos);
+}
+
 /* EOF */

Modified: trunk/netbrush/src/drawing_context.hpp
===================================================================
--- trunk/netbrush/src/drawing_context.hpp	2006-10-29 15:37:12 UTC (rev 679)
+++ trunk/netbrush/src/drawing_context.hpp	2006-10-30 15:12:28 UTC (rev 680)
@@ -51,11 +51,17 @@
 
   void draw(SDL_Surface* target, const Rect& region, int x_of, int y_of);
 
+  /** Blits \a source onto \a drawable at position \a pos */
+  void blit(SDL_Surface* source, const Point& pos);
+
   int get_width()  const { return drawable->w; }
   int get_height() const { return drawable->h; }
   bool get_color(int x, int y, Color& color);
   SDL_Surface* get_surface() { return drawable; }
 
+  /** Creates a surface of the given region */
+  SDL_Surface* get_surface(const Rect& rect);
+
   void save_png(const std::string& filename);
 };
 

Modified: trunk/netbrush/src/server_connection.cpp
===================================================================
--- trunk/netbrush/src/server_connection.cpp	2006-10-29 15:37:12 UTC (rev 679)
+++ trunk/netbrush/src/server_connection.cpp	2006-10-30 15:12:28 UTC (rev 680)
@@ -217,6 +217,15 @@
                 {
                   client_state->stroke_begin();
                 }
+              else if (tokens.size() == 9 && tokens[2] == "copy_region")
+                { // copy_region X1 Y2 X2 Y2 TARGET_X TARGET_Y
+                  client_state->copy_region(Rect(atoi(tokens[3].c_str()),
+                                                 atoi(tokens[4].c_str()),
+                                                 atoi(tokens[5].c_str()),
+                                                 atoi(tokens[6].c_str())),
+                                            Point(atoi(tokens[7].c_str()),
+                                                  atoi(tokens[8].c_str())));
+                }
               else if (tokens.size() == 3 && tokens[2] == "stroke_end")
                 {
                   client_state->stroke_end();



From grumbel at mail.berlios.de  Mon Oct 30 17:03:03 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Mon, 30 Oct 2006 17:03:03 +0100
Subject: [Flexlay-commit] r681 - in trunk/netbrush: . src
Message-ID: <200610301603.k9UG330C031244@sheep.berlios.de>

Author: grumbel
Date: 2006-10-30 17:03:02 +0100 (Mon, 30 Oct 2006)
New Revision: 681

Modified:
   trunk/netbrush/SConstruct
   trunk/netbrush/src/drawing_context.cpp
   trunk/netbrush/src/screen_buffer.cpp
Log:
- added region select tool (use fourth mouse button for now)

Modified: trunk/netbrush/SConstruct
===================================================================
--- trunk/netbrush/SConstruct	2006-10-30 15:12:28 UTC (rev 680)
+++ trunk/netbrush/SConstruct	2006-10-30 16:03:02 UTC (rev 681)
@@ -63,6 +63,7 @@
         'src/paintbrush_tool.cpp',
         'src/scroll_tool.cpp',
         'src/colorpicker_tool.cpp',
+        'src/region_tool.cpp',
         'src/color_display.cpp',
         'src/color.cpp',
         'src/SDL_tty.c',

Modified: trunk/netbrush/src/drawing_context.cpp
===================================================================
--- trunk/netbrush/src/drawing_context.cpp	2006-10-30 15:12:28 UTC (rev 680)
+++ trunk/netbrush/src/drawing_context.cpp	2006-10-30 16:03:02 UTC (rev 681)
@@ -251,6 +251,8 @@
   target_pos.y = pos.y;
 
   SDL_BlitSurface(source, NULL, drawable, &target_pos);
+
+  screen_buffer->mark_dirty(Rect(pos, Size(source->w, source->h)));
 }
 
 /* EOF */

Modified: trunk/netbrush/src/screen_buffer.cpp
===================================================================
--- trunk/netbrush/src/screen_buffer.cpp	2006-10-30 15:12:28 UTC (rev 680)
+++ trunk/netbrush/src/screen_buffer.cpp	2006-10-30 16:03:02 UTC (rev 681)
@@ -37,6 +37,7 @@
 #include "airbrush_tool.hpp"
 #include "scroll_tool.hpp"
 #include "colorpicker_tool.hpp"
+#include "region_tool.hpp"
 #include "screen_buffer.hpp"
 
 ScreenBuffer::ScreenBuffer(const Rect& rect)
@@ -48,6 +49,7 @@
   tools.push_back(new AirbrushTool());
   tools.push_back(new ScrollTool());
   tools.push_back(new ColorpickerTool());
+  tools.push_back(new RegionTool());
 }
 
 ScreenBuffer::~ScreenBuffer()



From grumbel at mail.berlios.de  Mon Oct 30 19:53:25 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Mon, 30 Oct 2006 19:53:25 +0100
Subject: [Flexlay-commit] r683 - in trunk/netbrush: data/icons src
Message-ID: <200610301853.k9UIrPA5025185@sheep.berlios.de>

Author: grumbel
Date: 2006-10-30 19:53:25 +0100 (Mon, 30 Oct 2006)
New Revision: 683

Added:
   trunk/netbrush/data/icons/stock-tool-rect-22.png
   trunk/netbrush/data/icons/stock-tool-rect-select-22.png
   trunk/netbrush/src/region_tool.cpp
   trunk/netbrush/src/region_tool.hpp
Modified:
   trunk/netbrush/src/controller.cpp
   trunk/netbrush/src/screen_buffer.cpp
   trunk/netbrush/src/screen_buffer.hpp
   trunk/netbrush/src/tool.hpp
Log:
- hooked up tools to GUI

Added: trunk/netbrush/data/icons/stock-tool-rect-22.png
===================================================================
(Binary files differ)


Property changes on: trunk/netbrush/data/icons/stock-tool-rect-22.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/netbrush/data/icons/stock-tool-rect-select-22.png
===================================================================
(Binary files differ)


Property changes on: trunk/netbrush/data/icons/stock-tool-rect-select-22.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/netbrush/src/controller.cpp
===================================================================
--- trunk/netbrush/src/controller.cpp	2006-10-30 17:32:08 UTC (rev 682)
+++ trunk/netbrush/src/controller.cpp	2006-10-30 18:53:25 UTC (rev 683)
@@ -33,8 +33,10 @@
 #include "drawing_parameter.hpp"
 #include "widget/slider_widget.hpp"
 #include "brush_widget.hpp"
+#include "screen_buffer.hpp"
 #include "widget/button.hpp"
 #include "text_view.hpp"
+#include "tool.hpp"
 #include "widget/widget_manager.hpp"
 #include "controller.hpp"
 
@@ -79,12 +81,13 @@
   }
 };
 
-class ToolButtonCallback : public ButtonCallback
+class ToolParameterButtonCallback : public ButtonCallback
 {
 private:
   DrawingParameter::Tool tool;
+
 public:
-  ToolButtonCallback(DrawingParameter::Tool tool_)
+  ToolParameterButtonCallback(DrawingParameter::Tool tool_)
     : tool(tool_)
   {
   }
@@ -103,22 +106,48 @@
   {
     //std::cout << "Setting tool: " << tool << std::endl;
     client_draw_param->tool = tool;
+    screen_buffer->set_tool(PAINTBRUSH_TOOL);
   }
 };
 
+class ToolButtonCallback : public ButtonCallback
+{
+private:
+  ToolName tool;
+
+public:
+  ToolButtonCallback(ToolName tool_)
+    : tool(tool_)
+  {
+  }
+
+  void on_press  (Button* button) {}
+  void on_release(Button* button) {}
+  
+  void on_click  (Button* button) 
+  {
+    screen_buffer->set_tool(tool);
+  }
+};
+
 Controller::Controller()
 {
   // Toolbar
     widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-airbrush-22.png"), 
                                    Rect(Point(2, 2+0*34), Size(34, 34)),
-                                   new ToolButtonCallback(DrawingParameter::TOOL_AIRBRUSH)));
+                                   new ToolParameterButtonCallback(DrawingParameter::TOOL_AIRBRUSH)));
     widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-paintbrush-22.png"), 
                                    Rect(Point(2, 2+1*34), Size(34, 34)),
-                                   new ToolButtonCallback(DrawingParameter::TOOL_PAINTBRUSH)));
-    //widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-color-picker-22.png"), 
-    //                               Rect(Point(2, 2+2*34), Size(34, 34)),
-    //                               new ToolButtonCallback(DrawingParameter::TOOL_COLOR_PICKER)));
-
+                                   new ToolParameterButtonCallback(DrawingParameter::TOOL_PAINTBRUSH)));
+    widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-color-picker-22.png"), 
+                                   Rect(Point(2, 2+2*34), Size(34, 34)),
+                                   new ToolButtonCallback(COLOR_PICKER_TOOL)));
+    widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-rect-22.png"), 
+                                   Rect(Point(2, 2+3*34), Size(34, 34)),
+                                   new ToolButtonCallback(RECT_TOOL)));
+    widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-rect-select-22.png"), 
+                                   Rect(Point(2, 2+4*34), Size(34, 34)),
+                                   new ToolButtonCallback(REGION_TOOL)));
     widget_manager->add(text_view = new TextView(Rect(38, screen->h - 38,
                                                       screen->w - 128 - 18 - 2 - 2, screen->h)));
 
@@ -274,7 +303,7 @@
 
 void
 Controller::update_mouse_cursor()
-{
+{ // FIXME: This could need some cleanup/feature enhancements
   if (client_draw_param->generic_brush.radius < 5.0f)
     return ;
 

Added: trunk/netbrush/src/region_tool.cpp
===================================================================
--- trunk/netbrush/src/region_tool.cpp	2006-10-30 17:32:08 UTC (rev 682)
+++ trunk/netbrush/src/region_tool.cpp	2006-10-30 18:53:25 UTC (rev 683)
@@ -0,0 +1,86 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#include <sstream>
+#include "globals.hpp"
+#include "server_connection.hpp"
+#include "controller.hpp"
+#include "region_tool.hpp"
+
+RegionTool::RegionTool()
+  : have_region(false)
+{
+}
+
+RegionTool::~RegionTool()
+{
+
+}
+
+void
+RegionTool::on_motion(const ToolMotionEvent& ev)
+{
+}
+
+void
+RegionTool::on_button_press(const ToolButtonEvent& ev)
+{
+  if (have_region)
+    {
+      controller->puts("region dropped");     
+      std::ostringstream str;
+      str << "copy_region "
+          << rect.left  << " " << rect.top << " " 
+          << rect.right << " " << rect.bottom << " "
+          << ev.x << " " << ev.y << std::endl;
+      server->send(str.str());
+    }
+  else
+    {
+      rect.left = ev.x;
+      rect.top  = ev.y;
+      controller->puts("region select started");
+    }
+}
+
+void
+RegionTool::on_button_release(const ToolButtonEvent& ev)
+{
+  if (!have_region)
+    {
+      rect.right  = ev.x;
+      rect.bottom = ev.y;
+
+      rect.normalize();
+      controller->puts("region selected");
+      have_region = true;
+    }
+  else
+    {
+      have_region = false;
+    }
+}
+
+/* EOF */

Added: trunk/netbrush/src/region_tool.hpp
===================================================================
--- trunk/netbrush/src/region_tool.hpp	2006-10-30 17:32:08 UTC (rev 682)
+++ trunk/netbrush/src/region_tool.hpp	2006-10-30 18:53:25 UTC (rev 683)
@@ -0,0 +1,53 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#ifndef HEADER_REGION_TOOL_HPP
+#define HEADER_REGION_TOOL_HPP
+
+#include "tool.hpp"
+
+/** */
+class RegionTool : public Tool
+{
+private:
+  Rect rect;
+  bool have_region;
+
+public:
+  RegionTool();
+  ~RegionTool();
+
+  void on_motion(const ToolMotionEvent& ev);
+  void on_button_press(const ToolButtonEvent& ev);
+  void on_button_release(const ToolButtonEvent& ev);
+  
+private:
+  RegionTool (const RegionTool&);
+  RegionTool& operator= (const RegionTool&);
+};
+
+#endif
+
+/* EOF */

Modified: trunk/netbrush/src/screen_buffer.cpp
===================================================================
--- trunk/netbrush/src/screen_buffer.cpp	2006-10-30 17:32:08 UTC (rev 682)
+++ trunk/netbrush/src/screen_buffer.cpp	2006-10-30 18:53:25 UTC (rev 683)
@@ -47,16 +47,20 @@
     scroll_offset_x(0),
     scroll_offset_y(0)
 {
-  tools.push_back(new AirbrushTool());
-  tools.push_back(new ScrollTool());
-  tools.push_back(new ColorpickerTool());
-  tools.push_back(new RectTool());
-  tools.push_back(new RegionTool());
+  tools.push_back(airbrush_tool    = new AirbrushTool());
+  tools.push_back(scroll_tool      = new ScrollTool());
+  tools.push_back(colorpicker_tool = new ColorpickerTool());
+  tools.push_back(rect_tool        = new RectTool());
+  tools.push_back(region_tool      = new RegionTool());
 }
 
 ScreenBuffer::~ScreenBuffer()
 {
-  //  SDL_FreeSurface(buffer);
+  delete colorpicker_tool;
+  delete region_tool;
+  delete rect_tool;
+  delete scroll_tool;
+  delete airbrush_tool;
 }
 
 void
@@ -269,4 +273,27 @@
                get_rect().get_height()/2 - scroll_offset_y);
 }
 
+void
+ScreenBuffer::set_tool(ToolName tool)
+{
+  switch(tool)
+    {
+    case PAINTBRUSH_TOOL:
+      tools[0] = airbrush_tool;
+      break;
+
+    case COLOR_PICKER_TOOL:
+      tools[0] = colorpicker_tool;
+      break;
+
+    case RECT_TOOL:
+      tools[0] = rect_tool;
+      break;
+
+    case REGION_TOOL:
+      tools[0] = region_tool;
+      break;
+    }
+}
+
 /* EOF */

Modified: trunk/netbrush/src/screen_buffer.hpp
===================================================================
--- trunk/netbrush/src/screen_buffer.hpp	2006-10-30 17:32:08 UTC (rev 682)
+++ trunk/netbrush/src/screen_buffer.hpp	2006-10-30 18:53:25 UTC (rev 683)
@@ -27,10 +27,17 @@
 #define HEADER_SCREEN_BUFFER_HPP
 
 #include "SDL.h"
+#include "tool.hpp"
 #include "widget/widget.hpp"
 
 class Tool;
 
+class ColorpickerTool;
+class ScrollTool;
+class RegionTool;
+class RectTool;
+class AirbrushTool;
+
 /** */
 class ScreenBuffer : public Widget
 {
@@ -43,6 +50,12 @@
   int scroll_offset_x;
   int scroll_offset_y;
 
+  ColorpickerTool* colorpicker_tool;
+  RegionTool*      region_tool;
+  RectTool*        rect_tool;
+  ScrollTool*      scroll_tool;
+  AirbrushTool*    airbrush_tool;
+
   typedef std::vector<Tool*> Tools;
   Tools tools;
 public:
@@ -64,8 +77,9 @@
 
   bool do_update() { return false; }
 
-  void move_to(const Point& p);
+  void  move_to(const Point& p);
   Point get_pos();
+  void  set_tool(ToolName tool);
 private:
   ScreenBuffer (const ScreenBuffer&);
   ScreenBuffer& operator= (const ScreenBuffer&);

Modified: trunk/netbrush/src/tool.hpp
===================================================================
--- trunk/netbrush/src/tool.hpp	2006-10-30 17:32:08 UTC (rev 682)
+++ trunk/netbrush/src/tool.hpp	2006-10-30 18:53:25 UTC (rev 683)
@@ -29,6 +29,8 @@
 #include "math/point.hpp"
 #include "widget/events.hpp"
 
+enum ToolName { PAINTBRUSH_TOOL, RECT_TOOL, REGION_TOOL, COLOR_PICKER_TOOL };
+
 struct ToolMotionEvent
 {
   int x;



From grumbel at mail.berlios.de  Mon Oct 30 21:18:16 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Mon, 30 Oct 2006 21:18:16 +0100
Subject: [Flexlay-commit] r684 - in trunk/netbrush: . data/icons src
Message-ID: <200610302018.k9UKIGDd002836@sheep.berlios.de>

Author: grumbel
Date: 2006-10-30 21:18:15 +0100 (Mon, 30 Oct 2006)
New Revision: 684

Added:
   trunk/netbrush/data/icons/stock-tool-circle-22.png
   trunk/netbrush/src/circle_tool.cpp
   trunk/netbrush/src/circle_tool.hpp
Modified:
   trunk/netbrush/SConstruct
   trunk/netbrush/data/icons/stock-tool-rect-22.png
   trunk/netbrush/src/client_connection.cpp
   trunk/netbrush/src/client_state.cpp
   trunk/netbrush/src/client_state.hpp
   trunk/netbrush/src/controller.cpp
   trunk/netbrush/src/screen_buffer.cpp
   trunk/netbrush/src/screen_buffer.hpp
   trunk/netbrush/src/server_connection.cpp
   trunk/netbrush/src/tool.hpp
Log:
- added circle drawing tool

Modified: trunk/netbrush/SConstruct
===================================================================
--- trunk/netbrush/SConstruct	2006-10-30 18:53:25 UTC (rev 683)
+++ trunk/netbrush/SConstruct	2006-10-30 20:18:15 UTC (rev 684)
@@ -69,6 +69,7 @@
         'src/SDL_tty.c',
         'src/text_view.cpp',
         'src/rect_tool.cpp',
+        'src/circle_tool.cpp',
         'src/SDL_gfx/SDL_gfxPrimitives.c',
 #        'src/widget/events.cpp',
 ])

Added: trunk/netbrush/data/icons/stock-tool-circle-22.png
===================================================================
(Binary files differ)


Property changes on: trunk/netbrush/data/icons/stock-tool-circle-22.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/netbrush/data/icons/stock-tool-rect-22.png
===================================================================
(Binary files differ)

Added: trunk/netbrush/src/circle_tool.cpp
===================================================================
--- trunk/netbrush/src/circle_tool.cpp	2006-10-30 18:53:25 UTC (rev 683)
+++ trunk/netbrush/src/circle_tool.cpp	2006-10-30 20:18:15 UTC (rev 684)
@@ -0,0 +1,70 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#include <sstream>
+#include "globals.hpp"
+#include "drawing_parameter.hpp"
+#include "server_connection.hpp"
+#include "circle_tool.hpp"
+
+CircleTool::CircleTool()
+{
+}
+
+void
+CircleTool::on_motion(const ToolMotionEvent& ev)
+{
+}
+
+void
+CircleTool::on_button_press(const ToolButtonEvent& ev)
+{
+  click_pos.x = ev.x;
+  click_pos.y = ev.y;
+}
+
+void
+CircleTool::on_button_release(const ToolButtonEvent& ev)
+{
+  Vector pos(ev.x, ev.y);
+  float radius = (click_pos - pos).length();
+
+  std::ostringstream str;
+  str << "set_color "
+      << int(client_draw_param->color.r) << " " 
+      << int(client_draw_param->color.g) << " " 
+      << int(client_draw_param->color.b) << std::endl;
+
+  str << "set_opacity " << int(client_draw_param->opacity) << std::endl;
+
+  str << "fill_circle "
+      << int(click_pos.x) << " " << int(click_pos.y) << " "
+      << int(radius)
+      << std::endl;
+
+  server->send(str.str());
+}
+
+/* EOF */

Added: trunk/netbrush/src/circle_tool.hpp
===================================================================
--- trunk/netbrush/src/circle_tool.hpp	2006-10-30 18:53:25 UTC (rev 683)
+++ trunk/netbrush/src/circle_tool.hpp	2006-10-30 20:18:15 UTC (rev 684)
@@ -0,0 +1,52 @@
+/*  $Id$
+**   __      __ __             ___        __   __ __   __
+**  /  \    /  \__| ____    __| _/_______/  |_|__|  | |  |   ____
+**  \   \/\/   /  |/    \  / __ |/  ___/\   __\  |  | |  | _/ __ \
+**   \        /|  |   |  \/ /_/ |\___ \  |  | |  |  |_|  |_\  ___/
+**    \__/\  / |__|___|  /\____ /____  > |__| |__|____/____/\___  >
+**         \/          \/      \/    \/                         \/
+**  Copyright (C) 2005 Ingo Ruhnke <grumbel at gmx.de>
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  as published by the Free Software Foundation; either version 2
+**  of the License, or (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+** 
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+**  02111-1307, USA.
+*/
+
+#ifndef HEADER_CIRCLE_TOOL_HPP
+#define HEADER_CIRCLE_TOOL_HPP
+
+#include "tool.hpp"
+
+/** */
+class CircleTool : public Tool
+{
+private:
+  Vector click_pos;
+
+public:
+  CircleTool();
+  virtual ~CircleTool() {}
+
+  void on_motion(const ToolMotionEvent& ev);
+  void on_button_press(const ToolButtonEvent& ev);
+  void on_button_release(const ToolButtonEvent& ev);
+
+private:
+  CircleTool (const CircleTool&);
+  CircleTool& operator= (const CircleTool&);
+};
+
+#endif
+
+/* EOF */

Modified: trunk/netbrush/src/client_connection.cpp
===================================================================
--- trunk/netbrush/src/client_connection.cpp	2006-10-30 18:53:25 UTC (rev 683)
+++ trunk/netbrush/src/client_connection.cpp	2006-10-30 20:18:15 UTC (rev 684)
@@ -222,7 +222,8 @@
             tokens[0] == "set_color"    ||
             tokens[0] == "set_tool"     ||
             tokens[0] == "copy_region"  ||
-            tokens[0] == "fill_rect"  ||
+            tokens[0] == "fill_rect"    ||
+            tokens[0] == "fill_circle"  ||
             tokens[0] == "set_opacity" 
             ))
     {

Modified: trunk/netbrush/src/client_state.cpp
===================================================================
--- trunk/netbrush/src/client_state.cpp	2006-10-30 18:53:25 UTC (rev 683)
+++ trunk/netbrush/src/client_state.cpp	2006-10-30 20:18:15 UTC (rev 684)
@@ -141,4 +141,15 @@
   screen_buffer->mark_dirty(rect);
 }
 
+void
+ClientState::fill_circle(const Point& pos, int radius)
+{
+  filledCircleRGBA(draw_ctx->get_surface(),
+             pos.x, pos.y, radius,
+             draw_param->color.r, draw_param->color.g, draw_param->color.b, 
+             draw_param->opacity);
+  screen_buffer->mark_dirty(Rect(pos.x - radius,   pos.y - radius, 
+                                 pos.x + radius+1, pos.y + radius+1));  
+}
+
 /* EOF */

Modified: trunk/netbrush/src/client_state.hpp
===================================================================
--- trunk/netbrush/src/client_state.hpp	2006-10-30 18:53:25 UTC (rev 683)
+++ trunk/netbrush/src/client_state.hpp	2006-10-30 20:18:15 UTC (rev 684)
@@ -62,6 +62,7 @@
 
   void copy_region(const Rect& rect, const Point& target);
   void fill_rect(const Rect& rect);
+  void fill_circle(const Point& pos, int radius);
 
   void dab(unsigned int time, int x, int y);
 };

Modified: trunk/netbrush/src/controller.cpp
===================================================================
--- trunk/netbrush/src/controller.cpp	2006-10-30 18:53:25 UTC (rev 683)
+++ trunk/netbrush/src/controller.cpp	2006-10-30 20:18:15 UTC (rev 684)
@@ -145,8 +145,11 @@
     widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-rect-22.png"), 
                                    Rect(Point(2, 2+3*34), Size(34, 34)),
                                    new ToolButtonCallback(RECT_TOOL)));
+    widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-circle-22.png"), 
+                                   Rect(Point(2, 2+4*34), Size(34, 34)),
+                                   new ToolButtonCallback(CIRCLE_TOOL)));
     widget_manager->add(new Button(IMG_Load("data/icons/stock-tool-rect-select-22.png"), 
-                                   Rect(Point(2, 2+4*34), Size(34, 34)),
+                                   Rect(Point(2, 2+5*34), Size(34, 34)),
                                    new ToolButtonCallback(REGION_TOOL)));
     widget_manager->add(text_view = new TextView(Rect(38, screen->h - 38,
                                                       screen->w - 128 - 18 - 2 - 2, screen->h)));

Modified: trunk/netbrush/src/screen_buffer.cpp
===================================================================
--- trunk/netbrush/src/screen_buffer.cpp	2006-10-30 18:53:25 UTC (rev 683)
+++ trunk/netbrush/src/screen_buffer.cpp	2006-10-30 20:18:15 UTC (rev 684)
@@ -39,6 +39,7 @@
 #include "colorpicker_tool.hpp"
 #include "region_tool.hpp"
 #include "rect_tool.hpp"
+#include "circle_tool.hpp"
 #include "screen_buffer.hpp"
 
 ScreenBuffer::ScreenBuffer(const Rect& rect)
@@ -52,6 +53,7 @@
   tools.push_back(colorpicker_tool = new ColorpickerTool());
   tools.push_back(rect_tool        = new RectTool());
   tools.push_back(region_tool      = new RegionTool());
+  tools.push_back(circle_tool      = new CircleTool());
 }
 
 ScreenBuffer::~ScreenBuffer()
@@ -61,6 +63,7 @@
   delete rect_tool;
   delete scroll_tool;
   delete airbrush_tool;
+  delete circle_tool;
 }
 
 void
@@ -282,6 +285,10 @@
       tools[0] = airbrush_tool;
       break;
 
+    case CIRCLE_TOOL:
+      tools[0] = circle_tool;
+      break;
+
     case COLOR_PICKER_TOOL:
       tools[0] = colorpicker_tool;
       break;

Modified: trunk/netbrush/src/screen_buffer.hpp
===================================================================
--- trunk/netbrush/src/screen_buffer.hpp	2006-10-30 18:53:25 UTC (rev 683)
+++ trunk/netbrush/src/screen_buffer.hpp	2006-10-30 20:18:15 UTC (rev 684)
@@ -36,6 +36,7 @@
 class ScrollTool;
 class RegionTool;
 class RectTool;
+class CircleTool;
 class AirbrushTool;
 
 /** */
@@ -53,6 +54,7 @@
   ColorpickerTool* colorpicker_tool;
   RegionTool*      region_tool;
   RectTool*        rect_tool;
+  CircleTool*      circle_tool;
   ScrollTool*      scroll_tool;
   AirbrushTool*    airbrush_tool;
 

Modified: trunk/netbrush/src/server_connection.cpp
===================================================================
--- trunk/netbrush/src/server_connection.cpp	2006-10-30 18:53:25 UTC (rev 683)
+++ trunk/netbrush/src/server_connection.cpp	2006-10-30 20:18:15 UTC (rev 684)
@@ -233,6 +233,12 @@
                                                atoi(tokens[5].c_str()),
                                                atoi(tokens[6].c_str())));
                 }
+              else if (tokens.size() == 6 && tokens[2] == "fill_circle")
+                { // fill_circle X Y RADIUS
+                  client_state->fill_circle(Point(atoi(tokens[3].c_str()),
+                                                  atoi(tokens[4].c_str())),
+                                            atoi(tokens[5].c_str()));
+                }
               else if (tokens.size() == 3 && tokens[2] == "stroke_end")
                 {
                   client_state->stroke_end();

Modified: trunk/netbrush/src/tool.hpp
===================================================================
--- trunk/netbrush/src/tool.hpp	2006-10-30 18:53:25 UTC (rev 683)
+++ trunk/netbrush/src/tool.hpp	2006-10-30 20:18:15 UTC (rev 684)
@@ -29,7 +29,7 @@
 #include "math/point.hpp"
 #include "widget/events.hpp"
 
-enum ToolName { PAINTBRUSH_TOOL, RECT_TOOL, REGION_TOOL, COLOR_PICKER_TOOL };
+enum ToolName { PAINTBRUSH_TOOL, RECT_TOOL, REGION_TOOL, COLOR_PICKER_TOOL, CIRCLE_TOOL };
 
 struct ToolMotionEvent
 {



From grumbel at mail.berlios.de  Mon Oct 30 22:51:05 2006
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Mon, 30 Oct 2006 22:51:05 +0100
Subject: [Flexlay-commit] r685 - trunk/netbrush/src
Message-ID: <200610302151.k9ULp5nv015609@sheep.berlios.de>

Author: grumbel
Date: 2006-10-30 22:51:04 +0100 (Mon, 30 Oct 2006)
New Revision: 685

Modified:
   trunk/netbrush/src/airbrush_tool.hpp
   trunk/netbrush/src/circle_tool.cpp
   trunk/netbrush/src/circle_tool.hpp
   trunk/netbrush/src/colorpicker_tool.hpp
   trunk/netbrush/src/rect_tool.cpp
   trunk/netbrush/src/rect_tool.hpp
   trunk/netbrush/src/region_tool.hpp
   trunk/netbrush/src/screen_buffer.cpp
   trunk/netbrush/src/scroll_tool.hpp
   trunk/netbrush/src/tool.hpp
Log:
- added visible dragging for rect and circle tools

Modified: trunk/netbrush/src/airbrush_tool.hpp
===================================================================
--- trunk/netbrush/src/airbrush_tool.hpp	2006-10-30 20:18:15 UTC (rev 684)
+++ trunk/netbrush/src/airbrush_tool.hpp	2006-10-30 21:51:04 UTC (rev 685)
@@ -41,7 +41,7 @@
   void on_motion(const ToolMotionEvent& ev);
   void on_button_press(const ToolButtonEvent& ev);
   void on_button_release(const ToolButtonEvent& ev);
-
+  void draw(SDL_Surface* target, const Rect& rect, int x_of, int y_of) {}
 private:
   AirbrushTool (const AirbrushTool&);
   AirbrushTool& operator= (const AirbrushTool&);

Modified: trunk/netbrush/src/circle_tool.cpp
===================================================================
--- trunk/netbrush/src/circle_tool.cpp	2006-10-30 20:18:15 UTC (rev 684)
+++ trunk/netbrush/src/circle_tool.cpp	2006-10-30 21:51:04 UTC (rev 685)
@@ -24,23 +24,36 @@
 */
 
 #include <sstream>
+#include <iostream>
+#include "SDL_gfx/SDL_gfxPrimitives.h"
 #include "globals.hpp"
+#include "screen_buffer.hpp"
 #include "drawing_parameter.hpp"
 #include "server_connection.hpp"
 #include "circle_tool.hpp"
 
 CircleTool::CircleTool()
+  : radius(0.0f), dragging(false)
 {
 }
 
 void
 CircleTool::on_motion(const ToolMotionEvent& ev)
 {
+  Vector pos(ev.x, ev.y);
+  radius = (click_pos - pos).length();
+
+  if (dragging)
+    screen_buffer->force_full_refresh();
+  
+  //std::cout << "drawing: " << click_pos.x << " " << click_pos.y << " " << radius << std::endl;
 }
 
 void
 CircleTool::on_button_press(const ToolButtonEvent& ev)
 {
+  dragging = true;
+
   click_pos.x = ev.x;
   click_pos.y = ev.y;
 }
@@ -48,8 +61,10 @@
 void
 CircleTool::on_button_release(const ToolButtonEvent& ev)
 {
+  dragging = false;
+
   Vector pos(ev.x, ev.y);
-  float radius = (click_pos - pos).length();
+  radius = (click_pos - pos).length();
 
   std::ostringstream str;
   str << "set_color "
@@ -67,4 +82,18 @@
   server->send(str.str());
 }
 
+void
+CircleTool::draw(SDL_Surface* target, const Rect& rect, int x_of, int y_of)
+{
+  if (dragging)
+    filledCircleRGBA(target,
+                     int(click_pos.x + x_of), 
+                     int(click_pos.y + y_of),
+                     int(radius),
+                     client_draw_param->color.r,
+                     client_draw_param->color.g,
+                     client_draw_param->color.b,
+                     client_draw_param->opacity);
+}
+
 /* EOF */

Modified: trunk/netbrush/src/circle_tool.hpp
===================================================================
--- trunk/netbrush/src/circle_tool.hpp	2006-10-30 20:18:15 UTC (rev 684)
+++ trunk/netbrush/src/circle_tool.hpp	2006-10-30 21:51:04 UTC (rev 685)
@@ -33,7 +33,8 @@
 {
 private:
   Vector click_pos;
-
+  float  radius;
+  bool   dragging;
 public:
   CircleTool();
   virtual ~CircleTool() {}
@@ -41,7 +42,7 @@
   void on_motion(const ToolMotionEvent& ev);
   void on_button_press(const ToolButtonEvent& ev);
   void on_button_release(const ToolButtonEvent& ev);
-
+  void draw(SDL_Surface* target, const Rect& rect, int x_of, int y_of);
 private:
   CircleTool (const CircleTool&);
   CircleTool& operator= (const CircleTool&);

Modified: trunk/netbrush/src/colorpicker_tool.hpp
===================================================================
--- trunk/netbrush/src/colorpicker_tool.hpp	2006-10-30 20:18:15 UTC (rev 684)
+++ trunk/netbrush/src/colorpicker_tool.hpp	2006-10-30 21:51:04 UTC (rev 685)
@@ -41,7 +41,7 @@
   void on_motion(const ToolMotionEvent& ev);
   void on_button_press(const ToolButtonEvent& ev);
   void on_button_release(const ToolButtonEvent& ev);
-
+  void draw(SDL_Surface* target, const Rect& rect, int x_of, int y_of) {}
   void pick_color(int x, int y);
 
 private:

Modified: trunk/netbrush/src/rect_tool.cpp
===================================================================
--- trunk/netbrush/src/rect_tool.cpp	2006-10-30 20:18:15 UTC (rev 684)
+++ trunk/netbrush/src/rect_tool.cpp	2006-10-30 21:51:04 UTC (rev 685)
@@ -24,13 +24,16 @@
 */
 
 #include <sstream>
+#include "SDL_gfx/SDL_gfxPrimitives.h"
 #include "globals.hpp"
 #include "server_connection.hpp"
 #include "controller.hpp"
+#include "screen_buffer.hpp"
 #include "drawing_parameter.hpp"
 #include "rect_tool.hpp"
 
 RectTool::RectTool()
+  : dragging(false)
 {
 }
 
@@ -42,27 +45,32 @@
 void
 RectTool::on_motion(const ToolMotionEvent& ev)
 {
+  if (dragging)
+    {
+      rect.right  = ev.x;
+      rect.bottom = ev.y;
+     
+      screen_buffer->force_full_refresh();
+    }
 }
 
 void
 RectTool::on_button_press(const ToolButtonEvent& ev)
 {
+  dragging = true;
   rect.left = ev.x;
   rect.top  = ev.y;
-  controller->puts("RectTool: press");
 }
 
 void
 RectTool::on_button_release(const ToolButtonEvent& ev)
 {
-  controller->puts("RectTool: release");
-
+  dragging = false;
   rect.right  = ev.x;
   rect.bottom = ev.y;
   
   rect.normalize();
   
-  controller->puts("rect dropped");     
   std::ostringstream str;
   str << "set_color "
       << int(client_draw_param->color.r) << " " 
@@ -78,4 +86,23 @@
   server->send(str.str());
 }
 
+void
+RectTool::draw(SDL_Surface* target, const Rect& rect__, int x_of, int y_of)
+{
+  Rect rect_ = rect;
+  rect_.normalize();
+  if (dragging)
+    boxRGBA(target,
+            int(rect_.left   + x_of), 
+            int(rect_.top    + y_of), 
+            int(rect_.right  + x_of), 
+            int(rect_.bottom + y_of), 
+                   
+            client_draw_param->color.r,
+            client_draw_param->color.g,
+            client_draw_param->color.b,
+            client_draw_param->opacity);
+
+}
+
 /* EOF */

Modified: trunk/netbrush/src/rect_tool.hpp
===================================================================
--- trunk/netbrush/src/rect_tool.hpp	2006-10-30 20:18:15 UTC (rev 684)
+++ trunk/netbrush/src/rect_tool.hpp	2006-10-30 21:51:04 UTC (rev 685)
@@ -33,7 +33,7 @@
 {
 private:
   Rect rect;
-
+  bool dragging;
 public:
   RectTool();
   ~RectTool();
@@ -41,7 +41,7 @@
   void on_motion(const ToolMotionEvent& ev);
   void on_button_press(const ToolButtonEvent& ev);
   void on_button_release(const ToolButtonEvent& ev);
-  
+  void draw(SDL_Surface* target, const Rect& rect, int x_of, int y_of);
 private:
   RectTool (const RectTool&);
   RectTool& operator= (const RectTool&);

Modified: trunk/netbrush/src/region_tool.hpp
===================================================================
--- trunk/netbrush/src/region_tool.hpp	2006-10-30 20:18:15 UTC (rev 684)
+++ trunk/netbrush/src/region_tool.hpp	2006-10-30 21:51:04 UTC (rev 685)
@@ -42,7 +42,7 @@
   void on_motion(const ToolMotionEvent& ev);
   void on_button_press(const ToolButtonEvent& ev);
   void on_button_release(const ToolButtonEvent& ev);
-  
+  void draw(SDL_Surface* target, const Rect& rect, int x_of, int y_of) {} 
 private:
   RegionTool (const RegionTool&);
   RegionTool& operator= (const RegionTool&);

Modified: trunk/netbrush/src/screen_buffer.cpp
===================================================================
--- trunk/netbrush/src/screen_buffer.cpp	2006-10-30 20:18:15 UTC (rev 684)
+++ trunk/netbrush/src/screen_buffer.cpp	2006-10-30 21:51:04 UTC (rev 685)
@@ -101,7 +101,7 @@
   vertical_scrollbar->set_pos(-scroll_offset_y);
 
   if (complete_refresh)
-    { 
+    { // draw checkboard pattern for the background
       Uint32 black = SDL_MapRGB(target->format, 200, 200, 200);
       Uint32 white = SDL_MapRGB(target->format, 100, 100, 100);
 
@@ -138,6 +138,9 @@
           r.w = get_rect().get_width();
           r.h = get_rect().get_height();
             
+          // FIXME: Dirty
+          tools[0]->draw(target, get_rect(), trans_x, trans_y);
+
           SDL_UpdateRect(target, r.x, r.y, r.w, r.h);
         }
       else
@@ -157,6 +160,9 @@
           r.w = get_rect().get_width();
           r.h = get_rect().get_height();
             
+          // FIXME: Dirty
+          tools[0]->draw(target, get_rect(), trans_x, trans_y);
+
           SDL_UpdateRect(target, r.x, r.y, r.w, r.h);
         }
     }

Modified: trunk/netbrush/src/scroll_tool.hpp
===================================================================
--- trunk/netbrush/src/scroll_tool.hpp	2006-10-30 20:18:15 UTC (rev 684)
+++ trunk/netbrush/src/scroll_tool.hpp	2006-10-30 21:51:04 UTC (rev 685)
@@ -44,7 +44,7 @@
   void on_motion(const ToolMotionEvent& ev);
   void on_button_press(const ToolButtonEvent& ev);
   void on_button_release(const ToolButtonEvent& ev);
-  
+  void draw(SDL_Surface* target, const Rect& rect, int x_of, int y_of) {}  
 private:
   ScrollTool (const ScrollTool&);
   ScrollTool& operator= (const ScrollTool&);

Modified: trunk/netbrush/src/tool.hpp
===================================================================
--- trunk/netbrush/src/tool.hpp	2006-10-30 20:18:15 UTC (rev 684)
+++ trunk/netbrush/src/tool.hpp	2006-10-30 21:51:04 UTC (rev 685)
@@ -26,7 +26,9 @@
 #ifndef HEADER_TOOL_HPP
 #define HEADER_TOOL_HPP
 
+#include "SDL.h"
 #include "math/point.hpp"
+#include "math/rect.hpp"
 #include "widget/events.hpp"
 
 enum ToolName { PAINTBRUSH_TOOL, RECT_TOOL, REGION_TOOL, COLOR_PICKER_TOOL, CIRCLE_TOOL };
@@ -59,6 +61,13 @@
   virtual void on_button_press(const ToolButtonEvent& ev) =0;
   virtual void on_button_release(const ToolButtonEvent& ev) =0;
 
+  /** @param target SDL_Surface to which should be drawn 
+      @param rect   rectangle in screenspace which should be redrawn
+      @param x_of   scroll factor used to translate from screenspace to worldspace
+      @param y_of   scroll factor used to translate from screenspace to worldspace
+   */
+  virtual void draw(SDL_Surface* target, const Rect& rect, int x_of, int y_of) =0;
+
 private:
   Tool (const Tool&);
   Tool& operator= (const Tool&);



