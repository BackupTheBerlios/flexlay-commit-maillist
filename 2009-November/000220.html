<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Flexlay-commit] r713 - in trunk/flexlay: clanlib/GL clanlib/GL/GLX	lib lib/tools netpanzer ruby
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/flexlay-commit/2009-November/index.html" >
   <LINK REL="made" HREF="mailto:flexlay-commit%40lists.berlios.de?Subject=Re%3A%20%5BFlexlay-commit%5D%20r713%20-%20in%20trunk/flexlay%3A%20clanlib/GL%20clanlib/GL/GLX%0A%09lib%20lib/tools%20netpanzer%20ruby&In-Reply-To=%3C200911220302.nAM32NPq021097%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000206.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Flexlay-commit] r713 - in trunk/flexlay: clanlib/GL clanlib/GL/GLX	lib lib/tools netpanzer ruby</H1>
    <B>grumbel at BerliOS</B> 
    <A HREF="mailto:flexlay-commit%40lists.berlios.de?Subject=Re%3A%20%5BFlexlay-commit%5D%20r713%20-%20in%20trunk/flexlay%3A%20clanlib/GL%20clanlib/GL/GLX%0A%09lib%20lib/tools%20netpanzer%20ruby&In-Reply-To=%3C200911220302.nAM32NPq021097%40sheep.berlios.de%3E"
       TITLE="[Flexlay-commit] r713 - in trunk/flexlay: clanlib/GL clanlib/GL/GLX	lib lib/tools netpanzer ruby">grumbel at mail.berlios.de
       </A><BR>
    <I>Sun Nov 22 04:02:23 CET 2009</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000206.html">[Flexlay-commit] r714 - in trunk/flexlay/lib: . tools
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#220">[ date ]</a>
              <a href="thread.html#220">[ thread ]</a>
              <a href="subject.html#220">[ subject ]</a>
              <a href="author.html#220">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: grumbel
Date: 2009-11-22 04:02:03 +0100 (Sun, 22 Nov 2009)
New Revision: 713

Added:
   trunk/flexlay/lib/bitmap_layer.cpp
   trunk/flexlay/lib/bitmap_layer.hpp
   trunk/flexlay/lib/blitter.cpp
   trunk/flexlay/lib/blitter.hpp
   trunk/flexlay/lib/box.cpp
   trunk/flexlay/lib/box.hpp
   trunk/flexlay/lib/brush.cpp
   trunk/flexlay/lib/brush.hpp
   trunk/flexlay/lib/brush_impl.hpp
   trunk/flexlay/lib/brushmask.cpp
   trunk/flexlay/lib/brushmask.hpp
   trunk/flexlay/lib/colorpicker.cpp
   trunk/flexlay/lib/colorpicker.hpp
   trunk/flexlay/lib/command.cpp
   trunk/flexlay/lib/command.hpp
   trunk/flexlay/lib/command_group.cpp
   trunk/flexlay/lib/command_group.hpp
   trunk/flexlay/lib/command_impl.hpp
   trunk/flexlay/lib/console.cpp
   trunk/flexlay/lib/console.hpp
   trunk/flexlay/lib/directory_view.cpp
   trunk/flexlay/lib/directory_view.hpp
   trunk/flexlay/lib/drawer_properties.cpp
   trunk/flexlay/lib/drawer_properties.hpp
   trunk/flexlay/lib/editor_map.cpp
   trunk/flexlay/lib/editor_map.hpp
   trunk/flexlay/lib/editor_map_component.cpp
   trunk/flexlay/lib/editor_map_component.hpp
   trunk/flexlay/lib/editor_names.hpp
   trunk/flexlay/lib/field.hpp
   trunk/flexlay/lib/flexlay.cpp
   trunk/flexlay/lib/flexlay.hpp
   trunk/flexlay/lib/fonts.cpp
   trunk/flexlay/lib/fonts.hpp
   trunk/flexlay/lib/generated_brush.cpp
   trunk/flexlay/lib/generated_brush.hpp
   trunk/flexlay/lib/globals.cpp
   trunk/flexlay/lib/globals.hpp
   trunk/flexlay/lib/graphic_context_state.cpp
   trunk/flexlay/lib/graphic_context_state.hpp
   trunk/flexlay/lib/gui_manager.cpp
   trunk/flexlay/lib/gui_manager.hpp
   trunk/flexlay/lib/helper.cpp
   trunk/flexlay/lib/helper.hpp
   trunk/flexlay/lib/icon.cpp
   trunk/flexlay/lib/icon.hpp
   trunk/flexlay/lib/layer.cpp
   trunk/flexlay/lib/layer.hpp
   trunk/flexlay/lib/layer_impl.hpp
   trunk/flexlay/lib/lispreader.cpp
   trunk/flexlay/lib/lispreader.hpp
   trunk/flexlay/lib/marker_stroke_drawer.cpp
   trunk/flexlay/lib/marker_stroke_drawer.hpp
   trunk/flexlay/lib/math.hpp
   trunk/flexlay/lib/menu.cpp
   trunk/flexlay/lib/menu.hpp
   trunk/flexlay/lib/menubar.cpp
   trunk/flexlay/lib/menubar.hpp
   trunk/flexlay/lib/meta_data.cpp
   trunk/flexlay/lib/meta_data.hpp
   trunk/flexlay/lib/meta_data_impl.hpp
   trunk/flexlay/lib/minimap.cpp
   trunk/flexlay/lib/minimap.hpp
   trunk/flexlay/lib/object_add_command.cpp
   trunk/flexlay/lib/object_add_command.hpp
   trunk/flexlay/lib/object_brush.cpp
   trunk/flexlay/lib/object_brush.hpp
   trunk/flexlay/lib/object_delete_command.cpp
   trunk/flexlay/lib/object_delete_command.hpp
   trunk/flexlay/lib/object_layer.cpp
   trunk/flexlay/lib/object_layer.hpp
   trunk/flexlay/lib/object_move_command.cpp
   trunk/flexlay/lib/object_move_command.hpp
   trunk/flexlay/lib/object_selector.cpp
   trunk/flexlay/lib/object_selector.hpp
   trunk/flexlay/lib/object_transform_command.cpp
   trunk/flexlay/lib/object_transform_command.hpp
   trunk/flexlay/lib/objmap_control_point.cpp
   trunk/flexlay/lib/objmap_control_point.hpp
   trunk/flexlay/lib/objmap_object.cpp
   trunk/flexlay/lib/objmap_object.hpp
   trunk/flexlay/lib/objmap_object_impl.cpp
   trunk/flexlay/lib/objmap_object_impl.hpp
   trunk/flexlay/lib/objmap_path_node.cpp
   trunk/flexlay/lib/objmap_path_node.hpp
   trunk/flexlay/lib/objmap_rect_object.cpp
   trunk/flexlay/lib/objmap_rect_object.hpp
   trunk/flexlay/lib/objmap_sprite_object.cpp
   trunk/flexlay/lib/objmap_sprite_object.hpp
   trunk/flexlay/lib/onion_skin_layer.cpp
   trunk/flexlay/lib/onion_skin_layer.hpp
   trunk/flexlay/lib/paint_command.cpp
   trunk/flexlay/lib/paint_command.hpp
   trunk/flexlay/lib/paned.cpp
   trunk/flexlay/lib/paned.hpp
   trunk/flexlay/lib/panel.cpp
   trunk/flexlay/lib/panel.hpp
   trunk/flexlay/lib/popup_menu.cpp
   trunk/flexlay/lib/popup_menu.hpp
   trunk/flexlay/lib/scrollbar.cpp
   trunk/flexlay/lib/scrollbar.hpp
   trunk/flexlay/lib/serializer.cpp
   trunk/flexlay/lib/serializer.hpp
   trunk/flexlay/lib/sexpr_serializer.cpp
   trunk/flexlay/lib/sexpr_serializer.hpp
   trunk/flexlay/lib/shared_ptr.hpp
   trunk/flexlay/lib/shared_ptr_comp.hpp
   trunk/flexlay/lib/sharedptrtest.cpp
   trunk/flexlay/lib/sharedptrtest.hpp
   trunk/flexlay/lib/simpleed.cpp
   trunk/flexlay/lib/simpleed.hpp
   trunk/flexlay/lib/sketch_layer.cpp
   trunk/flexlay/lib/sketch_layer.hpp
   trunk/flexlay/lib/slider.cpp
   trunk/flexlay/lib/slider.hpp
   trunk/flexlay/lib/sprite_brush.cpp
   trunk/flexlay/lib/sprite_brush.hpp
   trunk/flexlay/lib/sprite_stroke_drawer.cpp
   trunk/flexlay/lib/sprite_stroke_drawer.hpp
   trunk/flexlay/lib/string_converter.hpp
   trunk/flexlay/lib/stroke.cpp
   trunk/flexlay/lib/stroke.hpp
   trunk/flexlay/lib/stroke_drawer.cpp
   trunk/flexlay/lib/stroke_drawer.hpp
   trunk/flexlay/lib/stroke_drawer_impl.hpp
   trunk/flexlay/lib/tile.cpp
   trunk/flexlay/lib/tile.hpp
   trunk/flexlay/lib/tile_brush.cpp
   trunk/flexlay/lib/tile_brush.hpp
   trunk/flexlay/lib/tile_editor.cpp
   trunk/flexlay/lib/tile_editor.hpp
   trunk/flexlay/lib/tile_provider.cpp
   trunk/flexlay/lib/tile_provider.hpp
   trunk/flexlay/lib/tile_provider_impl.hpp
   trunk/flexlay/lib/tile_selection.cpp
   trunk/flexlay/lib/tile_selection.hpp
   trunk/flexlay/lib/tile_selector.cpp
   trunk/flexlay/lib/tile_selector.hpp
   trunk/flexlay/lib/tilemap_layer.cpp
   trunk/flexlay/lib/tilemap_layer.hpp
   trunk/flexlay/lib/tilemap_minimap.hpp
   trunk/flexlay/lib/tileset.cpp
   trunk/flexlay/lib/tileset.hpp
   trunk/flexlay/lib/titlebar.cpp
   trunk/flexlay/lib/titlebar.hpp
   trunk/flexlay/lib/tools/layer_move_tool.cpp
   trunk/flexlay/lib/tools/layer_move_tool.hpp
   trunk/flexlay/lib/tools/objmap_select_tool.cpp
   trunk/flexlay/lib/tools/objmap_select_tool.hpp
   trunk/flexlay/lib/tools/sketch_stroke_tool.cpp
   trunk/flexlay/lib/tools/sketch_stroke_tool.hpp
   trunk/flexlay/lib/tools/tilemap_paint_tool.cpp
   trunk/flexlay/lib/tools/tilemap_paint_tool.hpp
   trunk/flexlay/lib/tools/tilemap_select_tool.cpp
   trunk/flexlay/lib/tools/tilemap_select_tool.hpp
   trunk/flexlay/lib/tools/tool.cpp
   trunk/flexlay/lib/tools/tool.hpp
   trunk/flexlay/lib/tools/tool_impl.hpp
   trunk/flexlay/lib/tools/workspace_move_tool.cpp
   trunk/flexlay/lib/tools/workspace_move_tool.hpp
   trunk/flexlay/lib/tools/zoom2_tool.cpp
   trunk/flexlay/lib/tools/zoom2_tool.hpp
   trunk/flexlay/lib/tools/zoom_tool.cpp
   trunk/flexlay/lib/tools/zoom_tool.hpp
   trunk/flexlay/lib/viewport.cpp
   trunk/flexlay/lib/viewport.hpp
   trunk/flexlay/lib/window.cpp
   trunk/flexlay/lib/window.hpp
   trunk/flexlay/lib/workspace.cpp
   trunk/flexlay/lib/workspace.hpp
   trunk/flexlay/netpanzer/averagecolor.cpp
   trunk/flexlay/netpanzer/netpanzer.cpp
   trunk/flexlay/netpanzer/netpanzer.hpp
   trunk/flexlay/ruby/flexlay_wrap.hpp
   trunk/flexlay/ruby/ruby_converter.cpp
   trunk/flexlay/ruby/ruby_functor.cpp
   trunk/flexlay/ruby/ruby_functor.hpp
   trunk/flexlay/ruby/ruby_meta_data.cpp
   trunk/flexlay/ruby/ruby_meta_data.hpp
   trunk/flexlay/ruby/ruby_object.cpp
   trunk/flexlay/ruby/ruby_object.hpp
   trunk/flexlay/ruby/ruby_sexpr_parser.cpp
   trunk/flexlay/ruby/ruby_sexpr_parser.hpp
Removed:
   trunk/flexlay/lib/bitmap_layer.cxx
   trunk/flexlay/lib/bitmap_layer.hxx
   trunk/flexlay/lib/blitter.cxx
   trunk/flexlay/lib/blitter.hxx
   trunk/flexlay/lib/box.cxx
   trunk/flexlay/lib/box.hxx
   trunk/flexlay/lib/brush.cxx
   trunk/flexlay/lib/brush.hxx
   trunk/flexlay/lib/brush_impl.hxx
   trunk/flexlay/lib/brushmask.cxx
   trunk/flexlay/lib/brushmask.hxx
   trunk/flexlay/lib/colorpicker.cxx
   trunk/flexlay/lib/colorpicker.hxx
   trunk/flexlay/lib/command.cxx
   trunk/flexlay/lib/command.hxx
   trunk/flexlay/lib/command_group.cxx
   trunk/flexlay/lib/command_group.hxx
   trunk/flexlay/lib/command_impl.hxx
   trunk/flexlay/lib/console.cxx
   trunk/flexlay/lib/console.hxx
   trunk/flexlay/lib/directory_view.cxx
   trunk/flexlay/lib/directory_view.hxx
   trunk/flexlay/lib/drawer_properties.cxx
   trunk/flexlay/lib/drawer_properties.hxx
   trunk/flexlay/lib/editor_map.cxx
   trunk/flexlay/lib/editor_map.hxx
   trunk/flexlay/lib/editor_map_component.cxx
   trunk/flexlay/lib/editor_map_component.hxx
   trunk/flexlay/lib/editor_names.hxx
   trunk/flexlay/lib/field.hxx
   trunk/flexlay/lib/flexlay.cxx
   trunk/flexlay/lib/flexlay.hxx
   trunk/flexlay/lib/fonts.cxx
   trunk/flexlay/lib/fonts.hxx
   trunk/flexlay/lib/generated_brush.cxx
   trunk/flexlay/lib/generated_brush.hxx
   trunk/flexlay/lib/globals.cxx
   trunk/flexlay/lib/globals.hxx
   trunk/flexlay/lib/graphic_context_state.cxx
   trunk/flexlay/lib/graphic_context_state.hxx
   trunk/flexlay/lib/gui_manager.cxx
   trunk/flexlay/lib/gui_manager.hxx
   trunk/flexlay/lib/helper.cxx
   trunk/flexlay/lib/helper.hxx
   trunk/flexlay/lib/icon.cxx
   trunk/flexlay/lib/icon.hxx
   trunk/flexlay/lib/layer.cxx
   trunk/flexlay/lib/layer.hxx
   trunk/flexlay/lib/layer_impl.hxx
   trunk/flexlay/lib/lispreader.cxx
   trunk/flexlay/lib/lispreader.hxx
   trunk/flexlay/lib/marker_stroke_drawer.cxx
   trunk/flexlay/lib/marker_stroke_drawer.hxx
   trunk/flexlay/lib/math.hxx
   trunk/flexlay/lib/menu.cxx
   trunk/flexlay/lib/menu.hxx
   trunk/flexlay/lib/menubar.cxx
   trunk/flexlay/lib/menubar.hxx
   trunk/flexlay/lib/meta_data.cxx
   trunk/flexlay/lib/meta_data.hxx
   trunk/flexlay/lib/meta_data_impl.hxx
   trunk/flexlay/lib/minimap.cxx
   trunk/flexlay/lib/minimap.hxx
   trunk/flexlay/lib/object_add_command.cxx
   trunk/flexlay/lib/object_add_command.hxx
   trunk/flexlay/lib/object_brush.cxx
   trunk/flexlay/lib/object_brush.hxx
   trunk/flexlay/lib/object_delete_command.cxx
   trunk/flexlay/lib/object_delete_command.hxx
   trunk/flexlay/lib/object_layer.cxx
   trunk/flexlay/lib/object_layer.hxx
   trunk/flexlay/lib/object_move_command.cxx
   trunk/flexlay/lib/object_move_command.hxx
   trunk/flexlay/lib/object_selector.cxx
   trunk/flexlay/lib/object_selector.hxx
   trunk/flexlay/lib/object_transform_command.cxx
   trunk/flexlay/lib/object_transform_command.hxx
   trunk/flexlay/lib/objmap_control_point.cxx
   trunk/flexlay/lib/objmap_control_point.hxx
   trunk/flexlay/lib/objmap_object.cxx
   trunk/flexlay/lib/objmap_object.hxx
   trunk/flexlay/lib/objmap_object_impl.cxx
   trunk/flexlay/lib/objmap_object_impl.hxx
   trunk/flexlay/lib/objmap_path_node.cxx
   trunk/flexlay/lib/objmap_path_node.hxx
   trunk/flexlay/lib/objmap_rect_object.cxx
   trunk/flexlay/lib/objmap_rect_object.hxx
   trunk/flexlay/lib/objmap_sprite_object.cxx
   trunk/flexlay/lib/objmap_sprite_object.hxx
   trunk/flexlay/lib/onion_skin_layer.cxx
   trunk/flexlay/lib/onion_skin_layer.hxx
   trunk/flexlay/lib/paint_command.cxx
   trunk/flexlay/lib/paint_command.hxx
   trunk/flexlay/lib/paned.cxx
   trunk/flexlay/lib/paned.hxx
   trunk/flexlay/lib/panel.cxx
   trunk/flexlay/lib/panel.hxx
   trunk/flexlay/lib/popup_menu.cxx
   trunk/flexlay/lib/popup_menu.hxx
   trunk/flexlay/lib/scrollbar.cxx
   trunk/flexlay/lib/scrollbar.hxx
   trunk/flexlay/lib/serializer.cxx
   trunk/flexlay/lib/serializer.hxx
   trunk/flexlay/lib/sexpr_serializer.cxx
   trunk/flexlay/lib/sexpr_serializer.hxx
   trunk/flexlay/lib/shared_ptr.hxx
   trunk/flexlay/lib/shared_ptr_comp.hxx
   trunk/flexlay/lib/sharedptrtest.cxx
   trunk/flexlay/lib/sharedptrtest.hxx
   trunk/flexlay/lib/simpleed.cxx
   trunk/flexlay/lib/simpleed.hxx
   trunk/flexlay/lib/sketch_layer.cxx
   trunk/flexlay/lib/sketch_layer.hxx
   trunk/flexlay/lib/slider.cxx
   trunk/flexlay/lib/slider.hxx
   trunk/flexlay/lib/sprite_brush.cxx
   trunk/flexlay/lib/sprite_brush.hxx
   trunk/flexlay/lib/sprite_stroke_drawer.cxx
   trunk/flexlay/lib/sprite_stroke_drawer.hxx
   trunk/flexlay/lib/string_converter.hxx
   trunk/flexlay/lib/stroke.cxx
   trunk/flexlay/lib/stroke.hxx
   trunk/flexlay/lib/stroke_drawer.cxx
   trunk/flexlay/lib/stroke_drawer.hxx
   trunk/flexlay/lib/stroke_drawer_impl.hxx
   trunk/flexlay/lib/tile.cxx
   trunk/flexlay/lib/tile.hxx
   trunk/flexlay/lib/tile_brush.cxx
   trunk/flexlay/lib/tile_brush.hxx
   trunk/flexlay/lib/tile_editor.cxx
   trunk/flexlay/lib/tile_editor.hxx
   trunk/flexlay/lib/tile_provider.cxx
   trunk/flexlay/lib/tile_provider.hxx
   trunk/flexlay/lib/tile_provider_impl.hxx
   trunk/flexlay/lib/tile_selection.cxx
   trunk/flexlay/lib/tile_selection.hxx
   trunk/flexlay/lib/tile_selector.cxx
   trunk/flexlay/lib/tile_selector.hxx
   trunk/flexlay/lib/tilemap_layer.cxx
   trunk/flexlay/lib/tilemap_layer.hxx
   trunk/flexlay/lib/tilemap_minimap.hxx
   trunk/flexlay/lib/tileset.cxx
   trunk/flexlay/lib/tileset.hxx
   trunk/flexlay/lib/titlebar.cxx
   trunk/flexlay/lib/titlebar.hxx
   trunk/flexlay/lib/tools/layer_move_tool.cxx
   trunk/flexlay/lib/tools/layer_move_tool.hxx
   trunk/flexlay/lib/tools/objmap_select_tool.cxx
   trunk/flexlay/lib/tools/objmap_select_tool.hxx
   trunk/flexlay/lib/tools/sketch_stroke_tool.cxx
   trunk/flexlay/lib/tools/sketch_stroke_tool.hxx
   trunk/flexlay/lib/tools/tilemap_paint_tool.cxx
   trunk/flexlay/lib/tools/tilemap_paint_tool.hxx
   trunk/flexlay/lib/tools/tilemap_select_tool.cxx
   trunk/flexlay/lib/tools/tilemap_select_tool.hxx
   trunk/flexlay/lib/tools/tool.cxx
   trunk/flexlay/lib/tools/tool.hxx
   trunk/flexlay/lib/tools/tool_impl.hxx
   trunk/flexlay/lib/tools/workspace_move_tool.cxx
   trunk/flexlay/lib/tools/workspace_move_tool.hxx
   trunk/flexlay/lib/tools/zoom2_tool.cxx
   trunk/flexlay/lib/tools/zoom2_tool.hxx
   trunk/flexlay/lib/tools/zoom_tool.cxx
   trunk/flexlay/lib/tools/zoom_tool.hxx
   trunk/flexlay/lib/viewport.cxx
   trunk/flexlay/lib/viewport.hxx
   trunk/flexlay/lib/window.cxx
   trunk/flexlay/lib/window.hxx
   trunk/flexlay/lib/workspace.cxx
   trunk/flexlay/lib/workspace.hxx
   trunk/flexlay/netpanzer/averagecolor.cxx
   trunk/flexlay/netpanzer/netpanzer.cxx
   trunk/flexlay/netpanzer/netpanzer.hxx
   trunk/flexlay/ruby/flexlay_wrap.hxx
   trunk/flexlay/ruby/ruby_converter.cxx
   trunk/flexlay/ruby/ruby_functor.cxx
   trunk/flexlay/ruby/ruby_functor.hxx
   trunk/flexlay/ruby/ruby_meta_data.cxx
   trunk/flexlay/ruby/ruby_meta_data.hxx
   trunk/flexlay/ruby/ruby_object.cxx
   trunk/flexlay/ruby/ruby_object.hxx
   trunk/flexlay/ruby/ruby_sexpr_parser.cxx
   trunk/flexlay/ruby/ruby_sexpr_parser.hxx
Modified:
   trunk/flexlay/clanlib/GL/GLX/input_device_linuxevent.cpp
   trunk/flexlay/clanlib/GL/GLX/input_device_xinput.cpp
   trunk/flexlay/clanlib/GL/canvas_opengl.cpp
   trunk/flexlay/lib/SConscript
   trunk/flexlay/lib/flexlay_wrap.i
   trunk/flexlay/netpanzer/SConscript
   trunk/flexlay/netpanzer/netpanzer.i
   trunk/flexlay/ruby/SConscript
Log:
Switched from .?pp to .?pp

Modified: trunk/flexlay/clanlib/GL/GLX/input_device_linuxevent.cpp
===================================================================
--- trunk/flexlay/clanlib/GL/GLX/input_device_linuxevent.cpp	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/clanlib/GL/GLX/input_device_linuxevent.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -34,6 +34,7 @@
 #include &lt;fcntl.h&gt;
 #include &lt;unistd.h&gt;
 #include &lt;iostream&gt;
+#include &lt;stdio.h&gt;
 #include &lt;errno.h&gt;
 
 #include &quot;API/Core/System/error.h&quot;

Modified: trunk/flexlay/clanlib/GL/GLX/input_device_xinput.cpp
===================================================================
--- trunk/flexlay/clanlib/GL/GLX/input_device_xinput.cpp	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/clanlib/GL/GLX/input_device_xinput.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -29,6 +29,7 @@
 
 #include &lt;iostream&gt;
 #include &lt;string.h&gt;
+#include &lt;stdio.h&gt;
 #include &quot;API/Core/System/log.h&quot;
 #include &quot;API/Display/input_device.h&quot;
 #include &quot;API/Display/input_event.h&quot;

Modified: trunk/flexlay/clanlib/GL/canvas_opengl.cpp
===================================================================
--- trunk/flexlay/clanlib/GL/canvas_opengl.cpp	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/clanlib/GL/canvas_opengl.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -28,6 +28,7 @@
 */
 
 #include &lt;string.h&gt;
+#include &lt;stdio.h&gt;
 #include &quot;Display/display_precomp.h&quot;
 #include &quot;canvas_opengl.h&quot;
 #include &quot;API/Core/System/error.h&quot;

Modified: trunk/flexlay/lib/SConscript
===================================================================
--- trunk/flexlay/lib/SConscript	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/SConscript	2009-11-22 03:02:03 UTC (rev 713)
@@ -37,11 +37,11 @@
                   options=opts)
 Help(opts.GenerateHelpText(env))
 
-#env.Program('sharedptrtest', 'sharedptrtest.cxx',
+#env.Program('sharedptrtest', 'sharedptrtest.cpp',
 #            CPPPATH=['/home/ingo/run/ClanLib-0.8-current/include/ClanLib-0.8/'])
 
 # env.Program('simpleed',
-#             ['simpleed.cxx'],
+#             ['simpleed.cpp'],
 #             CPPPATH=['.', 
 #                     '/home/ingo/run/ClanLib-0.8-current//include/ClanLib-0.8/'],
 #            LIBPATH=['.', '/home/ingo/run/ClanLib-0.8-current//lib/'],
@@ -51,80 +51,80 @@
 flexlay_lib = libflexlay_env.StaticLibrary(
     target = 'libflexlay.a',
     source = [
-    'blitter.cxx',
-    'box.cxx',
-    'brush.cxx',
-    'generated_brush.cxx',
-    'brushmask.cxx',
-    'command_group.cxx',
-    'command.cxx',
-    'console.cxx',
-    'colorpicker.cxx',
-    'drawer_properties.cxx',
-    'editor_map.cxx',
-    'editor_map_component.cxx',
-    'flexlay.cxx',
-    'globals.cxx',
-    'layer.cxx',
-    'helper.cxx', 
-    'graphic_context_state.cxx',
-    'gui_manager.cxx',
-    'icon.cxx',
-    'directory_view.cxx',
-    'fonts.cxx',
-    'minimap.cxx',
-    'meta_data.cxx',
-    'onion_skin_layer.cxx',
-    'object_layer.cxx',
-    'object_add_command.cxx',
-    'object_brush.cxx',
-    'object_delete_command.cxx',
-    'object_move_command.cxx',
-    'object_selector.cxx',
-    'object_transform_command.cxx',
-    'objmap_object.cxx',
-    'objmap_path_node.cxx',
-    'objmap_object_impl.cxx',
-    'objmap_sprite_object.cxx',
-    'objmap_control_point.cxx',
-    'objmap_rect_object.cxx',
-    'paint_command.cxx',
-    'panel.cxx',
-    'menu.cxx',
-    'menubar.cxx',
-    'popup_menu.cxx',
-    'lispreader.cxx',
-    'bitmap_layer.cxx',
-    'sketch_layer.cxx',
-    'stroke.cxx',
-    'stroke_drawer.cxx',
-    'sprite_stroke_drawer.cxx',
-    'sprite_brush.cxx',
-    'marker_stroke_drawer.cxx',
-    'slider.cxx', 
-    'scrollbar.cxx',
-    'tile.cxx',
-    'titlebar.cxx',
-    'tile_brush.cxx',
-    'tile_provider.cxx',
-    'tile_editor.cxx',
-    'tile_selection.cxx',
-    'tile_selector.cxx',
-    'tilemap_layer.cxx',
-    'tileset.cxx',
-    'workspace.cxx',
-    'window.cxx',
-    'viewport.cxx',
+    'blitter.cpp',
+    'box.cpp',
+    'brush.cpp',
+    'generated_brush.cpp',
+    'brushmask.cpp',
+    'command_group.cpp',
+    'command.cpp',
+    'console.cpp',
+    'colorpicker.cpp',
+    'drawer_properties.cpp',
+    'editor_map.cpp',
+    'editor_map_component.cpp',
+    'flexlay.cpp',
+    'globals.cpp',
+    'layer.cpp',
+    'helper.cpp', 
+    'graphic_context_state.cpp',
+    'gui_manager.cpp',
+    'icon.cpp',
+    'directory_view.cpp',
+    'fonts.cpp',
+    'minimap.cpp',
+    'meta_data.cpp',
+    'onion_skin_layer.cpp',
+    'object_layer.cpp',
+    'object_add_command.cpp',
+    'object_brush.cpp',
+    'object_delete_command.cpp',
+    'object_move_command.cpp',
+    'object_selector.cpp',
+    'object_transform_command.cpp',
+    'objmap_object.cpp',
+    'objmap_path_node.cpp',
+    'objmap_object_impl.cpp',
+    'objmap_sprite_object.cpp',
+    'objmap_control_point.cpp',
+    'objmap_rect_object.cpp',
+    'paint_command.cpp',
+    'panel.cpp',
+    'menu.cpp',
+    'menubar.cpp',
+    'popup_menu.cpp',
+    'lispreader.cpp',
+    'bitmap_layer.cpp',
+    'sketch_layer.cpp',
+    'stroke.cpp',
+    'stroke_drawer.cpp',
+    'sprite_stroke_drawer.cpp',
+    'sprite_brush.cpp',
+    'marker_stroke_drawer.cpp',
+    'slider.cpp', 
+    'scrollbar.cpp',
+    'tile.cpp',
+    'titlebar.cpp',
+    'tile_brush.cpp',
+    'tile_provider.cpp',
+    'tile_editor.cpp',
+    'tile_selection.cpp',
+    'tile_selector.cpp',
+    'tilemap_layer.cpp',
+    'tileset.cpp',
+    'workspace.cpp',
+    'window.cpp',
+    'viewport.cpp',
 
-    'tools/tool.cxx',
-    'tools/tilemap_paint_tool.cxx',
-    'tools/tilemap_select_tool.cxx',
-    'tools/sketch_stroke_tool.cxx',
-    'tools/objmap_select_tool.cxx',
-    'tools/layer_move_tool.cxx',
-    'tools/workspace_move_tool.cxx',
-    'tools/zoom_tool.cxx',
-    'tools/zoom2_tool.cxx'
+    'tools/tool.cpp',
+    'tools/tilemap_paint_tool.cpp',
+    'tools/tilemap_select_tool.cpp',
+    'tools/sketch_stroke_tool.cpp',
+    'tools/objmap_select_tool.cpp',
+    'tools/layer_move_tool.cpp',
+    'tools/workspace_move_tool.cpp',
+    'tools/zoom_tool.cpp',
+    'tools/zoom2_tool.cpp'
     ],
     CPPPATH = ['.', '..'] + clanLib_env['CPPPATH'],
     CXXFLAGS  = env['CXXFLAGS'] + clanLib_env['CCFLAGS'],

Copied: trunk/flexlay/lib/bitmap_layer.cpp (from rev 712, trunk/flexlay/lib/bitmap_layer.cxx)
===================================================================
--- trunk/flexlay/lib/bitmap_layer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/bitmap_layer.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,198 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &lt;assert.h&gt;
+#include &lt;ClanLib/gl.h&gt;
+#include &lt;ClanLib/Core/core_iostream.h&gt;
+#include &lt;ClanLib/Core/System/error.h&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &lt;ClanLib/Display/sprite.h&gt;
+#include &lt;ClanLib/Display/pixel_buffer.h&gt;
+#include &lt;ClanLib/Display/canvas.h&gt;
+#include &lt;ClanLib/Display/blend_func.h&gt;
+#include &lt;ClanLib/Display/graphic_context.h&gt;
+#include &lt;ClanLib/Display/display_window.h&gt;
+#include &quot;flexlay.hpp&quot;
+#include &quot;editor_map_component.hpp&quot;
+#include &quot;layer_impl.hpp&quot;
+#include &quot;bitmap_layer.hpp&quot;
+#include &quot;objmap_object_impl.hpp&quot;
+#include &quot;math.hpp&quot;
+
+BitmapLayer* BitmapLayer::current_ = 0;
+
+class BitmapLayerImpl : public ObjMapObjectImpl
+{
+public:
+  typedef std::vector&lt;Stroke&gt; Strokes;
+  /** All strokes done on this image are recorded for possible later
+      playback on a larger size canvas */
+  Strokes strokes;
+
+  /** Used to cache drawings */
+  CL_Surface  surface;
+  CL_Canvas*  canvas;
+  CL_Pointf   last_pos;
+
+  BitmapLayerImpl(CL_Surface surface_)
+    : surface(surface_),
+      canvas(0)
+  {
+    try {
+      canvas = new CL_Canvas(surface);
+      canvas-&gt;sync_surface();
+    } catch(CL_Error&amp; err) {
+      std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
+      throw err;
+    }
+  }
+  
+  BitmapLayerImpl(CL_PixelBuffer buffer)
+    : surface(buffer),
+      canvas(0)
+  {
+    try {
+      canvas = new CL_Canvas(surface);
+      canvas-&gt;sync_surface();
+    } catch(CL_Error&amp; err) {
+      std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
+      throw err;
+    }
+  }
+
+  BitmapLayerImpl(int width, int height) 
+    : surface(CL_PixelBuffer(width, height, width*4, CL_PixelFormat::rgba8888)),
+      canvas(0)
+  {
+    try {
+      canvas = new CL_Canvas(surface);
+      canvas-&gt;get_gc()-&gt;clear(CL_Color(0, 0, 0, 0));
+      canvas-&gt;get_gc()-&gt;flush();
+      canvas-&gt;sync_surface();
+    } catch(CL_Error&amp; err) {
+      std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
+      throw err;
+    }
+  }
+
+  ~BitmapLayerImpl() {
+    delete canvas;
+  }
+
+  void draw(CL_GraphicContext* gc)
+  {
+    assert(canvas);
+
+    // Nothing to draw, so we go byebye
+    if (strokes.empty()) 
+      return;
+
+    surface.set_blend_func(blend_one, blend_one_minus_src_alpha);
+    surface.draw(pos.x, pos.y, gc);
+
+    gc-&gt;draw_rect(get_bounding_rect(), CL_Color(155, 155, 155, 100));
+  }
+
+  CL_Rectf get_bound_rect() const  
+  {
+    return CL_Rectf(CL_Pointf(ObjMapObjectImpl::pos), CL_Sizef(surface.get_width(), surface.get_height()));
+  }
+
+  CL_Rect get_bounding_rect() { 
+    // FIXME: Do we need to handle its position here or does the Layer keep care of that?
+    return CL_Rect(CL_Point(0, 0),
+                   CL_Size(surface.get_width(), surface.get_height())); 
+  }
+
+  bool has_bounding_rect() const { 
+    return true;
+  }
+};
+
+BitmapLayer::BitmapLayer(CL_Surface surface)
+  : impl(new BitmapLayerImpl(surface))
+{
+  current_ = this;
+}
+
+BitmapLayer::BitmapLayer(int width, int height)
+  : impl(new BitmapLayerImpl(width, height))
+{
+  current_ = this;
+}
+
+BitmapLayer::BitmapLayer(CL_PixelBuffer buffer)
+  : impl(new BitmapLayerImpl(buffer))
+{
+  current_ = this;
+}
+
+void
+BitmapLayer::add_stroke(const Stroke&amp; stroke)
+{
+  if (stroke.get_dab_count() &gt; 0)
+    {
+      impl-&gt;strokes.push_back(stroke);
+      stroke.draw(impl-&gt;canvas-&gt;get_gc());
+      // FIXME: doesn't sync when manually manipulating the canvas
+      impl-&gt;canvas-&gt;get_gc()-&gt;flush();
+      impl-&gt;canvas-&gt;sync_surface();
+    }
+}
+
+std::vector&lt;Stroke&gt;
+BitmapLayer::get_strokes()
+{
+  return impl-&gt;strokes;
+}
+
+CL_Surface
+BitmapLayer::get_background_surface()
+{
+  return impl-&gt;surface;
+}
+
+CL_Canvas*
+BitmapLayer::get_canvas() const
+{
+  return impl-&gt;canvas;
+}
+
+void
+BitmapLayer::set_pixeldata(CL_PixelBuffer buffer)
+{
+  //impl-&gt;canvas-&gt;set_pixeldata(buffer);
+  CL_Surface(buffer).draw(0, 0, impl-&gt;canvas-&gt;get_gc());
+  impl-&gt;canvas-&gt;get_gc()-&gt;flush();
+  impl-&gt;canvas-&gt;sync_surface();
+}
+
+CL_PixelBuffer
+BitmapLayer::get_pixeldata() const
+{
+  return impl-&gt;canvas-&gt;get_pixeldata();
+}
+
+ObjMapObject
+BitmapLayer::to_object()
+{
+  return ObjMapObject(impl);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/bitmap_layer.cxx
===================================================================
--- trunk/flexlay/lib/bitmap_layer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/bitmap_layer.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,198 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &lt;assert.h&gt;
-#include &lt;ClanLib/gl.h&gt;
-#include &lt;ClanLib/Core/core_iostream.h&gt;
-#include &lt;ClanLib/Core/System/error.h&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-#include &lt;ClanLib/Display/sprite.h&gt;
-#include &lt;ClanLib/Display/pixel_buffer.h&gt;
-#include &lt;ClanLib/Display/canvas.h&gt;
-#include &lt;ClanLib/Display/blend_func.h&gt;
-#include &lt;ClanLib/Display/graphic_context.h&gt;
-#include &lt;ClanLib/Display/display_window.h&gt;
-#include &quot;flexlay.hxx&quot;
-#include &quot;editor_map_component.hxx&quot;
-#include &quot;layer_impl.hxx&quot;
-#include &quot;bitmap_layer.hxx&quot;
-#include &quot;objmap_object_impl.hxx&quot;
-#include &quot;math.hxx&quot;
-
-BitmapLayer* BitmapLayer::current_ = 0;
-
-class BitmapLayerImpl : public ObjMapObjectImpl
-{
-public:
-  typedef std::vector&lt;Stroke&gt; Strokes;
-  /** All strokes done on this image are recorded for possible later
-      playback on a larger size canvas */
-  Strokes strokes;
-
-  /** Used to cache drawings */
-  CL_Surface  surface;
-  CL_Canvas*  canvas;
-  CL_Pointf   last_pos;
-
-  BitmapLayerImpl(CL_Surface surface_)
-    : surface(surface_),
-      canvas(0)
-  {
-    try {
-      canvas = new CL_Canvas(surface);
-      canvas-&gt;sync_surface();
-    } catch(CL_Error&amp; err) {
-      std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
-      throw err;
-    }
-  }
-  
-  BitmapLayerImpl(CL_PixelBuffer buffer)
-    : surface(buffer),
-      canvas(0)
-  {
-    try {
-      canvas = new CL_Canvas(surface);
-      canvas-&gt;sync_surface();
-    } catch(CL_Error&amp; err) {
-      std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
-      throw err;
-    }
-  }
-
-  BitmapLayerImpl(int width, int height) 
-    : surface(CL_PixelBuffer(width, height, width*4, CL_PixelFormat::rgba8888)),
-      canvas(0)
-  {
-    try {
-      canvas = new CL_Canvas(surface);
-      canvas-&gt;get_gc()-&gt;clear(CL_Color(0, 0, 0, 0));
-      canvas-&gt;get_gc()-&gt;flush();
-      canvas-&gt;sync_surface();
-    } catch(CL_Error&amp; err) {
-      std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
-      throw err;
-    }
-  }
-
-  ~BitmapLayerImpl() {
-    delete canvas;
-  }
-
-  void draw(CL_GraphicContext* gc)
-  {
-    assert(canvas);
-
-    // Nothing to draw, so we go byebye
-    if (strokes.empty()) 
-      return;
-
-    surface.set_blend_func(blend_one, blend_one_minus_src_alpha);
-    surface.draw(pos.x, pos.y, gc);
-
-    gc-&gt;draw_rect(get_bounding_rect(), CL_Color(155, 155, 155, 100));
-  }
-
-  CL_Rectf get_bound_rect() const  
-  {
-    return CL_Rectf(CL_Pointf(ObjMapObjectImpl::pos), CL_Sizef(surface.get_width(), surface.get_height()));
-  }
-
-  CL_Rect get_bounding_rect() { 
-    // FIXME: Do we need to handle its position here or does the Layer keep care of that?
-    return CL_Rect(CL_Point(0, 0),
-                   CL_Size(surface.get_width(), surface.get_height())); 
-  }
-
-  bool has_bounding_rect() const { 
-    return true;
-  }
-};
-
-BitmapLayer::BitmapLayer(CL_Surface surface)
-  : impl(new BitmapLayerImpl(surface))
-{
-  current_ = this;
-}
-
-BitmapLayer::BitmapLayer(int width, int height)
-  : impl(new BitmapLayerImpl(width, height))
-{
-  current_ = this;
-}
-
-BitmapLayer::BitmapLayer(CL_PixelBuffer buffer)
-  : impl(new BitmapLayerImpl(buffer))
-{
-  current_ = this;
-}
-
-void
-BitmapLayer::add_stroke(const Stroke&amp; stroke)
-{
-  if (stroke.get_dab_count() &gt; 0)
-    {
-      impl-&gt;strokes.push_back(stroke);
-      stroke.draw(impl-&gt;canvas-&gt;get_gc());
-      // FIXME: doesn't sync when manually manipulating the canvas
-      impl-&gt;canvas-&gt;get_gc()-&gt;flush();
-      impl-&gt;canvas-&gt;sync_surface();
-    }
-}
-
-std::vector&lt;Stroke&gt;
-BitmapLayer::get_strokes()
-{
-  return impl-&gt;strokes;
-}
-
-CL_Surface
-BitmapLayer::get_background_surface()
-{
-  return impl-&gt;surface;
-}
-
-CL_Canvas*
-BitmapLayer::get_canvas() const
-{
-  return impl-&gt;canvas;
-}
-
-void
-BitmapLayer::set_pixeldata(CL_PixelBuffer buffer)
-{
-  //impl-&gt;canvas-&gt;set_pixeldata(buffer);
-  CL_Surface(buffer).draw(0, 0, impl-&gt;canvas-&gt;get_gc());
-  impl-&gt;canvas-&gt;get_gc()-&gt;flush();
-  impl-&gt;canvas-&gt;sync_surface();
-}
-
-CL_PixelBuffer
-BitmapLayer::get_pixeldata() const
-{
-  return impl-&gt;canvas-&gt;get_pixeldata();
-}
-
-ObjMapObject
-BitmapLayer::to_object()
-{
-  return ObjMapObject(impl);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/bitmap_layer.hpp (from rev 712, trunk/flexlay/lib/bitmap_layer.hxx)
===================================================================
--- trunk/flexlay/lib/bitmap_layer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/bitmap_layer.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,67 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_BITMAP_LAYER_HXX
+#define HEADER_BITMAP_LAYER_HXX
+
+#include &lt;vector&gt;
+#include &lt;ClanLib/Core/Math/point.h&gt;
+#include &lt;ClanLib/Display/color.h&gt;
+#include &quot;objmap_object.hpp&quot;
+#include &quot;layer.hpp&quot;
+#include &quot;stroke.hpp&quot;
+
+class BitmapLayerImpl;
+
+/** This layer holds a simple bitmap, size and color format are
+    configurable, it works similar to the SketchLayer, however it
+    doesn't rerender the image all the time, but simply holds it in a
+    CL_Canvas making it a whole lot faster. */
+class BitmapLayer
+{
+  friend class BitmapLayerImpl;
+private:
+  static BitmapLayer* current_;
+public:
+  static BitmapLayer* current() { return current_; }
+  static void set_current(BitmapLayer* c) { current_ = c; }
+
+  BitmapLayer(CL_Surface surface);
+  BitmapLayer(CL_PixelBuffer buffer);
+  BitmapLayer(int width, int height);
+  
+  void add_stroke(const Stroke&amp;);
+
+  std::vector&lt;Stroke&gt; get_strokes();
+
+  CL_Surface get_background_surface();
+
+  void set_pixeldata(CL_PixelBuffer buffer);
+  CL_PixelBuffer get_pixeldata() const;
+  CL_Canvas*     get_canvas() const;
+  
+  bool is_null() const { return !impl.get(); }
+  ObjMapObject to_object();
+
+private:
+  SharedPtr&lt;BitmapLayerImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/bitmap_layer.hxx
===================================================================
--- trunk/flexlay/lib/bitmap_layer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/bitmap_layer.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,67 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_BITMAP_LAYER_HXX
-#define HEADER_BITMAP_LAYER_HXX
-
-#include &lt;vector&gt;
-#include &lt;ClanLib/Core/Math/point.h&gt;
-#include &lt;ClanLib/Display/color.h&gt;
-#include &quot;objmap_object.hxx&quot;
-#include &quot;layer.hxx&quot;
-#include &quot;stroke.hxx&quot;
-
-class BitmapLayerImpl;
-
-/** This layer holds a simple bitmap, size and color format are
-    configurable, it works similar to the SketchLayer, however it
-    doesn't rerender the image all the time, but simply holds it in a
-    CL_Canvas making it a whole lot faster. */
-class BitmapLayer
-{
-  friend class BitmapLayerImpl;
-private:
-  static BitmapLayer* current_;
-public:
-  static BitmapLayer* current() { return current_; }
-  static void set_current(BitmapLayer* c) { current_ = c; }
-
-  BitmapLayer(CL_Surface surface);
-  BitmapLayer(CL_PixelBuffer buffer);
-  BitmapLayer(int width, int height);
-  
-  void add_stroke(const Stroke&amp;);
-
-  std::vector&lt;Stroke&gt; get_strokes();
-
-  CL_Surface get_background_surface();
-
-  void set_pixeldata(CL_PixelBuffer buffer);
-  CL_PixelBuffer get_pixeldata() const;
-  CL_Canvas*     get_canvas() const;
-  
-  bool is_null() const { return !impl.get(); }
-  ObjMapObject to_object();
-
-private:
-  SharedPtr&lt;BitmapLayerImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/blitter.cpp (from rev 712, trunk/flexlay/lib/blitter.cxx)
===================================================================
--- trunk/flexlay/lib/blitter.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/blitter.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,207 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;assert.h&gt;
+#include &lt;iostream&gt;
+#include &lt;algorithm&gt;
+#include &lt;ClanLib/Display/pixel_format.h&gt;
+#include &lt;ClanLib/Display/palette.h&gt;
+#include &quot;blitter.hpp&quot;
+
+void 
+blit_opaque(CL_PixelBuffer target, CL_PixelBuffer brush, int x_pos, int y_pos)
+{
+  target.lock();
+  brush.lock();
+
+  int start_x = std::max(0, -x_pos);
+  int start_y = std::max(0, -y_pos);
+  
+  int end_x = std::min(brush.get_width(),  target.get_width()  - x_pos);
+  int end_y = std::min(brush.get_height(), target.get_height() - y_pos);
+
+  unsigned char* target_buf = static_cast&lt;unsigned char*&gt;(target.get_data());
+  unsigned char* brush_buf  = static_cast&lt;unsigned char*&gt;(brush.get_data());
+
+  int target_pitch = target.get_pitch();
+  int brush_pitch  = brush.get_pitch();
+
+  if (brush.get_format().get_type() == pixelformat_rgba)
+    {
+      if (brush.get_format().get_depth() == 32)
+        {
+          for (int y = start_y; y &lt; end_y; ++y)
+            for (int x = start_x; x &lt; end_x; ++x)
+              {
+                int target_pos = (y + y_pos) * target_pitch + 4*(x + x_pos);
+                int brush_pos  = y * brush_pitch + x*4;
+
+                target_buf[target_pos + 0] = brush_buf[brush_pos + 0];
+                target_buf[target_pos + 1] = brush_buf[brush_pos + 1];
+                target_buf[target_pos + 2] = brush_buf[brush_pos + 2];
+                target_buf[target_pos + 3] = brush_buf[brush_pos + 3];
+              } 
+        }
+      else if (brush.get_format().get_depth() == 24)
+        {
+          for (int y = start_y; y &lt; end_y; ++y)
+            for (int x = start_x; x &lt; end_x; ++x)
+              {
+                int target_pos = (y + y_pos) * target_pitch + 3*(x + x_pos);
+                int brush_pos  = y * brush_pitch + 3*x;
+
+                target_buf[target_pos + 0] = 255;
+                target_buf[target_pos + 1] = brush_buf[brush_pos + 0];
+                target_buf[target_pos + 2] = brush_buf[brush_pos + 1];
+                target_buf[target_pos + 3] = brush_buf[brush_pos + 2];
+              }
+        }
+      else
+        {
+          std::cout &lt;&lt; &quot;Unsupported bpp: &quot; &lt;&lt; brush.get_format().get_depth() &lt;&lt; std::endl;
+        }
+    }
+  else if (brush.get_format().get_type() == pixelformat_index)
+    {
+      CL_Palette palette = brush.get_palette();
+      for (int y = start_y; y &lt; end_y; ++y)
+        for (int x = start_x; x &lt; end_x; ++x)
+          {
+            int target_pos = (y + y_pos) * target_pitch + 4*(x + x_pos);
+            int brush_pos  = y * brush_pitch + x;
+            
+            target_buf[target_pos + 0] = 255;
+            target_buf[target_pos + 1] = palette.colors[brush_buf[brush_pos]].get_blue();
+            target_buf[target_pos + 2] = palette.colors[brush_buf[brush_pos]].get_green();
+            target_buf[target_pos + 3] = palette.colors[brush_buf[brush_pos]].get_red();
+          }
+    }
+  else
+    {
+      assert(!&quot;Unknown pixelformat type&quot;);
+    }
+    
+
+
+  brush.unlock();
+  target.unlock();
+}
+
+void 
+blit(CL_PixelBuffer target, CL_PixelBuffer brush, int x_pos, int y_pos)
+{
+  target.lock();
+  brush.lock();
+
+  int start_x = std::max(0, -x_pos);
+  int start_y = std::max(0, -y_pos);
+  
+  int end_x = std::min(brush.get_width(),  target.get_width()  - x_pos);
+  int end_y = std::min(brush.get_height(), target.get_height() - y_pos);
+
+  unsigned char* target_buf = static_cast&lt;unsigned char*&gt;(target.get_data());
+  unsigned char* brush_buf  = static_cast&lt;unsigned char*&gt;(brush.get_data());
+
+  // FIXME: This doesn't take pitch into account
+  int target_width = target.get_width();
+  int brush_width  = brush.get_width();
+
+  if (brush.get_format().get_type() == pixelformat_rgba)
+    {
+      if (brush.get_format().get_depth() == 32)
+        {
+          for (int y = start_y; y &lt; end_y; ++y)
+            for (int x = start_x; x &lt; end_x; ++x)
+              {
+                int target_pos = (y + y_pos) * target_width + x + x_pos;
+                int brush_pos  = y * brush_width + x;
+
+                unsigned char a  = brush_buf[4*brush_pos + 0];
+                unsigned char r  = brush_buf[4*brush_pos + 1];
+                unsigned char g  = brush_buf[4*brush_pos + 2];
+                unsigned char b  = brush_buf[4*brush_pos + 3];
+
+                unsigned char ta = target_buf[4*target_pos + 0];
+                unsigned char tr = target_buf[4*target_pos + 1];
+                unsigned char tg = target_buf[4*target_pos + 2];
+                unsigned char tb = target_buf[4*target_pos + 3];
+
+                float alpha  = a/255.0f;
+        
+                target_buf[4*target_pos + 0] = std::min(255, ta + a);
+                target_buf[4*target_pos + 1] = std::min(255, int((1-alpha)*tr + alpha*r));
+                target_buf[4*target_pos + 2] = std::min(255, int((1-alpha)*tg + alpha*g));
+                target_buf[4*target_pos + 3] = std::min(255, int((1-alpha)*tb + alpha*b));
+              }
+        }
+      else if (brush.get_format().get_depth() == 24)
+        {
+          for (int y = start_y; y &lt; end_y; ++y)
+            for (int x = start_x; x &lt; end_x; ++x)
+              {
+                int target_pos = (y + y_pos) * target_width + x + x_pos;
+                int brush_pos  = y * brush_width + x;
+
+                target_buf[4*target_pos + 0] = 255;
+                target_buf[4*target_pos + 1] = brush_buf[3*brush_pos + 0];
+                target_buf[4*target_pos + 2] = brush_buf[3*brush_pos + 1];
+                target_buf[4*target_pos + 3] = brush_buf[3*brush_pos + 2];
+              }
+        }
+      else
+        {
+          std::cout &lt;&lt; &quot;Unsupported bpp: &quot; &lt;&lt; brush.get_format().get_depth() &lt;&lt; std::endl;
+        }
+    }
+  else if (brush.get_format().get_type() == pixelformat_index)
+    {
+      CL_Palette palette = brush.get_palette();
+      for (int y = start_y; y &lt; end_y; ++y)
+        for (int x = start_x; x &lt; end_x; ++x)
+          {
+            int target_pos = (y + y_pos) * target_width + x + x_pos;
+            int brush_pos  = y * brush_width + x;
+            
+            target_buf[4*target_pos + 0] = 255;
+            target_buf[4*target_pos + 1] = palette.colors[brush_buf[brush_pos]].get_blue();
+            target_buf[4*target_pos + 2] = palette.colors[brush_buf[brush_pos]].get_green();
+            target_buf[4*target_pos + 3] = palette.colors[brush_buf[brush_pos]].get_red();
+          }
+    }
+  else
+    {
+      assert(!&quot;Unknown pixelformat type&quot;);
+    }
+    
+
+
+  brush.unlock();
+  target.unlock();
+}
+
+void clear(CL_PixelBuffer canvas)
+{
+  unsigned char* buffer;
+
+  canvas.lock();
+  buffer = static_cast&lt;unsigned char*&gt;(canvas.get_data());
+  memset(buffer, 0, sizeof(unsigned char) * canvas.get_pitch() * canvas.get_height());
+  canvas.unlock();
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/blitter.cxx
===================================================================
--- trunk/flexlay/lib/blitter.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/blitter.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,207 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;assert.h&gt;
-#include &lt;iostream&gt;
-#include &lt;algorithm&gt;
-#include &lt;ClanLib/Display/pixel_format.h&gt;
-#include &lt;ClanLib/Display/palette.h&gt;
-#include &quot;blitter.hxx&quot;
-
-void 
-blit_opaque(CL_PixelBuffer target, CL_PixelBuffer brush, int x_pos, int y_pos)
-{
-  target.lock();
-  brush.lock();
-
-  int start_x = std::max(0, -x_pos);
-  int start_y = std::max(0, -y_pos);
-  
-  int end_x = std::min(brush.get_width(),  target.get_width()  - x_pos);
-  int end_y = std::min(brush.get_height(), target.get_height() - y_pos);
-
-  unsigned char* target_buf = static_cast&lt;unsigned char*&gt;(target.get_data());
-  unsigned char* brush_buf  = static_cast&lt;unsigned char*&gt;(brush.get_data());
-
-  int target_pitch = target.get_pitch();
-  int brush_pitch  = brush.get_pitch();
-
-  if (brush.get_format().get_type() == pixelformat_rgba)
-    {
-      if (brush.get_format().get_depth() == 32)
-        {
-          for (int y = start_y; y &lt; end_y; ++y)
-            for (int x = start_x; x &lt; end_x; ++x)
-              {
-                int target_pos = (y + y_pos) * target_pitch + 4*(x + x_pos);
-                int brush_pos  = y * brush_pitch + x*4;
-
-                target_buf[target_pos + 0] = brush_buf[brush_pos + 0];
-                target_buf[target_pos + 1] = brush_buf[brush_pos + 1];
-                target_buf[target_pos + 2] = brush_buf[brush_pos + 2];
-                target_buf[target_pos + 3] = brush_buf[brush_pos + 3];
-              } 
-        }
-      else if (brush.get_format().get_depth() == 24)
-        {
-          for (int y = start_y; y &lt; end_y; ++y)
-            for (int x = start_x; x &lt; end_x; ++x)
-              {
-                int target_pos = (y + y_pos) * target_pitch + 3*(x + x_pos);
-                int brush_pos  = y * brush_pitch + 3*x;
-
-                target_buf[target_pos + 0] = 255;
-                target_buf[target_pos + 1] = brush_buf[brush_pos + 0];
-                target_buf[target_pos + 2] = brush_buf[brush_pos + 1];
-                target_buf[target_pos + 3] = brush_buf[brush_pos + 2];
-              }
-        }
-      else
-        {
-          std::cout &lt;&lt; &quot;Unsupported bpp: &quot; &lt;&lt; brush.get_format().get_depth() &lt;&lt; std::endl;
-        }
-    }
-  else if (brush.get_format().get_type() == pixelformat_index)
-    {
-      CL_Palette palette = brush.get_palette();
-      for (int y = start_y; y &lt; end_y; ++y)
-        for (int x = start_x; x &lt; end_x; ++x)
-          {
-            int target_pos = (y + y_pos) * target_pitch + 4*(x + x_pos);
-            int brush_pos  = y * brush_pitch + x;
-            
-            target_buf[target_pos + 0] = 255;
-            target_buf[target_pos + 1] = palette.colors[brush_buf[brush_pos]].get_blue();
-            target_buf[target_pos + 2] = palette.colors[brush_buf[brush_pos]].get_green();
-            target_buf[target_pos + 3] = palette.colors[brush_buf[brush_pos]].get_red();
-          }
-    }
-  else
-    {
-      assert(!&quot;Unknown pixelformat type&quot;);
-    }
-    
-
-
-  brush.unlock();
-  target.unlock();
-}
-
-void 
-blit(CL_PixelBuffer target, CL_PixelBuffer brush, int x_pos, int y_pos)
-{
-  target.lock();
-  brush.lock();
-
-  int start_x = std::max(0, -x_pos);
-  int start_y = std::max(0, -y_pos);
-  
-  int end_x = std::min(brush.get_width(),  target.get_width()  - x_pos);
-  int end_y = std::min(brush.get_height(), target.get_height() - y_pos);
-
-  unsigned char* target_buf = static_cast&lt;unsigned char*&gt;(target.get_data());
-  unsigned char* brush_buf  = static_cast&lt;unsigned char*&gt;(brush.get_data());
-
-  // FIXME: This doesn't take pitch into account
-  int target_width = target.get_width();
-  int brush_width  = brush.get_width();
-
-  if (brush.get_format().get_type() == pixelformat_rgba)
-    {
-      if (brush.get_format().get_depth() == 32)
-        {
-          for (int y = start_y; y &lt; end_y; ++y)
-            for (int x = start_x; x &lt; end_x; ++x)
-              {
-                int target_pos = (y + y_pos) * target_width + x + x_pos;
-                int brush_pos  = y * brush_width + x;
-
-                unsigned char a  = brush_buf[4*brush_pos + 0];
-                unsigned char r  = brush_buf[4*brush_pos + 1];
-                unsigned char g  = brush_buf[4*brush_pos + 2];
-                unsigned char b  = brush_buf[4*brush_pos + 3];
-
-                unsigned char ta = target_buf[4*target_pos + 0];
-                unsigned char tr = target_buf[4*target_pos + 1];
-                unsigned char tg = target_buf[4*target_pos + 2];
-                unsigned char tb = target_buf[4*target_pos + 3];
-
-                float alpha  = a/255.0f;
-        
-                target_buf[4*target_pos + 0] = std::min(255, ta + a);
-                target_buf[4*target_pos + 1] = std::min(255, int((1-alpha)*tr + alpha*r));
-                target_buf[4*target_pos + 2] = std::min(255, int((1-alpha)*tg + alpha*g));
-                target_buf[4*target_pos + 3] = std::min(255, int((1-alpha)*tb + alpha*b));
-              }
-        }
-      else if (brush.get_format().get_depth() == 24)
-        {
-          for (int y = start_y; y &lt; end_y; ++y)
-            for (int x = start_x; x &lt; end_x; ++x)
-              {
-                int target_pos = (y + y_pos) * target_width + x + x_pos;
-                int brush_pos  = y * brush_width + x;
-
-                target_buf[4*target_pos + 0] = 255;
-                target_buf[4*target_pos + 1] = brush_buf[3*brush_pos + 0];
-                target_buf[4*target_pos + 2] = brush_buf[3*brush_pos + 1];
-                target_buf[4*target_pos + 3] = brush_buf[3*brush_pos + 2];
-              }
-        }
-      else
-        {
-          std::cout &lt;&lt; &quot;Unsupported bpp: &quot; &lt;&lt; brush.get_format().get_depth() &lt;&lt; std::endl;
-        }
-    }
-  else if (brush.get_format().get_type() == pixelformat_index)
-    {
-      CL_Palette palette = brush.get_palette();
-      for (int y = start_y; y &lt; end_y; ++y)
-        for (int x = start_x; x &lt; end_x; ++x)
-          {
-            int target_pos = (y + y_pos) * target_width + x + x_pos;
-            int brush_pos  = y * brush_width + x;
-            
-            target_buf[4*target_pos + 0] = 255;
-            target_buf[4*target_pos + 1] = palette.colors[brush_buf[brush_pos]].get_blue();
-            target_buf[4*target_pos + 2] = palette.colors[brush_buf[brush_pos]].get_green();
-            target_buf[4*target_pos + 3] = palette.colors[brush_buf[brush_pos]].get_red();
-          }
-    }
-  else
-    {
-      assert(!&quot;Unknown pixelformat type&quot;);
-    }
-    
-
-
-  brush.unlock();
-  target.unlock();
-}
-
-void clear(CL_PixelBuffer canvas)
-{
-  unsigned char* buffer;
-
-  canvas.lock();
-  buffer = static_cast&lt;unsigned char*&gt;(canvas.get_data());
-  memset(buffer, 0, sizeof(unsigned char) * canvas.get_pitch() * canvas.get_height());
-  canvas.unlock();
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/blitter.hpp (from rev 712, trunk/flexlay/lib/blitter.hxx)

Deleted: trunk/flexlay/lib/blitter.hxx
===================================================================
--- trunk/flexlay/lib/blitter.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/blitter.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,30 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_BLITTER_HXX
-#define HEADER_BLITTER_HXX
-
-#include &lt;ClanLib/Display/pixel_buffer.h&gt;
-
-void blit(CL_PixelBuffer target, CL_PixelBuffer brush, int x_pos, int y_pos);
-void blit_opaque(CL_PixelBuffer target, CL_PixelBuffer brush, int x_pos, int y_pos);
-void clear(CL_PixelBuffer target);
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/box.cpp (from rev 712, trunk/flexlay/lib/box.cxx)
===================================================================
--- trunk/flexlay/lib/box.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/box.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,104 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;ClanLib/Display/color.h&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &quot;box.hpp&quot;
+
+CL_Color background   (210, 210, 210);
+CL_Color background_hl(240, 240, 240);
+CL_Color background_sw(200, 200, 200);
+CL_Color highlight    (255, 255, 255);
+CL_Color midtone      (150, 150, 150);
+CL_Color shadow       (100, 100, 100);
+
+void
+Box::draw_button_up(const CL_Rect&amp; rect)
+{
+  CL_Display::fill_rect(rect, background_hl);
+  CL_Display::draw_line(rect.left, rect.top, 
+                        rect.right, rect.top, highlight);
+  CL_Display::draw_line(rect.left, rect.top, 
+                        rect.left, rect.bottom, highlight);
+
+  CL_Display::draw_line(rect.left, rect.bottom, 
+                        rect.right, rect.bottom, shadow);
+  CL_Display::draw_line(rect.right, rect.top, 
+                        rect.right, rect.bottom, shadow);
+}
+
+void
+Box::draw_button_down(const CL_Rect&amp; rect)
+{
+  CL_Display::fill_rect(rect, background_sw);
+
+  CL_Display::draw_line(rect.left, rect.bottom, 
+                        rect.right, rect.bottom, highlight);
+  CL_Display::draw_line(rect.right, rect.top, 
+                        rect.right, rect.bottom, highlight);
+
+  CL_Display::draw_line(rect.left, rect.top, 
+                        rect.right, rect.top, shadow);
+  CL_Display::draw_line(rect.left, rect.top, 
+                        rect.left, rect.bottom, shadow);
+}
+
+void
+Box::draw_button_neutral(const CL_Rect&amp; rect)
+{
+  CL_Display::fill_rect(rect, background);
+}
+
+void
+Box::draw_panel(const CL_Rect&amp; rect)
+{
+  CL_Display::fill_rect(rect, background);
+  CL_Display::draw_line(rect.left, rect.top, 
+                        rect.right, rect.top, highlight);
+  CL_Display::draw_line(rect.left, rect.top, 
+                        rect.left, rect.bottom, highlight);
+
+  CL_Display::draw_line(rect.left, rect.bottom, 
+                        rect.right, rect.bottom, shadow);
+  CL_Display::draw_line(rect.right, rect.top, 
+                        rect.right, rect.bottom, shadow);
+}
+
+void
+Box::draw_panel_down(const CL_Rect&amp; rect)
+{
+  CL_Display::fill_rect(rect, background);
+  CL_Display::draw_line(rect.left, rect.top, 
+                        rect.right, rect.top, shadow);
+  CL_Display::draw_line(rect.left, rect.top, 
+                        rect.left, rect.bottom, shadow);
+
+  CL_Display::draw_line(rect.left, rect.bottom, 
+                        rect.right, rect.bottom, highlight);
+  CL_Display::draw_line(rect.right, rect.top, 
+                        rect.right, rect.bottom, highlight);
+}
+
+void
+Box::draw_window(const CL_Rect&amp; rect)
+{
+  draw_panel(CL_Rect(rect.left+1, rect.top+1, rect.right-2, rect.bottom-2));
+  CL_Display::draw_rect(rect, CL_Color(0, 0, 0));
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/box.cxx
===================================================================
--- trunk/flexlay/lib/box.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/box.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,104 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;ClanLib/Display/color.h&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-#include &quot;box.hxx&quot;
-
-CL_Color background   (210, 210, 210);
-CL_Color background_hl(240, 240, 240);
-CL_Color background_sw(200, 200, 200);
-CL_Color highlight    (255, 255, 255);
-CL_Color midtone      (150, 150, 150);
-CL_Color shadow       (100, 100, 100);
-
-void
-Box::draw_button_up(const CL_Rect&amp; rect)
-{
-  CL_Display::fill_rect(rect, background_hl);
-  CL_Display::draw_line(rect.left, rect.top, 
-                        rect.right, rect.top, highlight);
-  CL_Display::draw_line(rect.left, rect.top, 
-                        rect.left, rect.bottom, highlight);
-
-  CL_Display::draw_line(rect.left, rect.bottom, 
-                        rect.right, rect.bottom, shadow);
-  CL_Display::draw_line(rect.right, rect.top, 
-                        rect.right, rect.bottom, shadow);
-}
-
-void
-Box::draw_button_down(const CL_Rect&amp; rect)
-{
-  CL_Display::fill_rect(rect, background_sw);
-
-  CL_Display::draw_line(rect.left, rect.bottom, 
-                        rect.right, rect.bottom, highlight);
-  CL_Display::draw_line(rect.right, rect.top, 
-                        rect.right, rect.bottom, highlight);
-
-  CL_Display::draw_line(rect.left, rect.top, 
-                        rect.right, rect.top, shadow);
-  CL_Display::draw_line(rect.left, rect.top, 
-                        rect.left, rect.bottom, shadow);
-}
-
-void
-Box::draw_button_neutral(const CL_Rect&amp; rect)
-{
-  CL_Display::fill_rect(rect, background);
-}
-
-void
-Box::draw_panel(const CL_Rect&amp; rect)
-{
-  CL_Display::fill_rect(rect, background);
-  CL_Display::draw_line(rect.left, rect.top, 
-                        rect.right, rect.top, highlight);
-  CL_Display::draw_line(rect.left, rect.top, 
-                        rect.left, rect.bottom, highlight);
-
-  CL_Display::draw_line(rect.left, rect.bottom, 
-                        rect.right, rect.bottom, shadow);
-  CL_Display::draw_line(rect.right, rect.top, 
-                        rect.right, rect.bottom, shadow);
-}
-
-void
-Box::draw_panel_down(const CL_Rect&amp; rect)
-{
-  CL_Display::fill_rect(rect, background);
-  CL_Display::draw_line(rect.left, rect.top, 
-                        rect.right, rect.top, shadow);
-  CL_Display::draw_line(rect.left, rect.top, 
-                        rect.left, rect.bottom, shadow);
-
-  CL_Display::draw_line(rect.left, rect.bottom, 
-                        rect.right, rect.bottom, highlight);
-  CL_Display::draw_line(rect.right, rect.top, 
-                        rect.right, rect.bottom, highlight);
-}
-
-void
-Box::draw_window(const CL_Rect&amp; rect)
-{
-  draw_panel(CL_Rect(rect.left+1, rect.top+1, rect.right-2, rect.bottom-2));
-  CL_Display::draw_rect(rect, CL_Color(0, 0, 0));
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/box.hpp (from rev 712, trunk/flexlay/lib/box.hxx)

Deleted: trunk/flexlay/lib/box.hxx
===================================================================
--- trunk/flexlay/lib/box.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/box.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,38 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_BOX_HXX
-#define HEADER_BOX_HXX
-
-#include &lt;ClanLib/Core/Math/rect.h&gt;
-
-/** Little helper class to draw boxes and stuff in the GUI */
-class Box
-{
-public:
-  static void draw_button_up(const CL_Rect&amp; rect);
-  static void draw_button_down(const CL_Rect&amp; rect);
-  static void draw_button_neutral(const CL_Rect&amp; rect);
-  static void draw_panel(const CL_Rect&amp; rect);
-  static void draw_panel_down(const CL_Rect&amp; rect);
-  static void draw_window(const CL_Rect&amp; rect);
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/brush.cpp (from rev 712, trunk/flexlay/lib/brush.cxx)
===================================================================
--- trunk/flexlay/lib/brush.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/brush.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,43 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &quot;brush.hpp&quot;
+
+Brush::Brush()
+{
+}
+
+Brush::Brush(SharedPtr&lt;BrushImpl&gt; impl_)
+  : impl(impl_)
+{
+  
+}
+
+Brush
+Brush::clone() const
+{
+  return Brush(impl-&gt;clone());
+}
+
+CL_Sprite
+Brush::get_sprite()
+{
+  return impl-&gt;get_sprite();
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/brush.cxx
===================================================================
--- trunk/flexlay/lib/brush.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/brush.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,43 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &quot;brush.hxx&quot;
-
-Brush::Brush()
-{
-}
-
-Brush::Brush(SharedPtr&lt;BrushImpl&gt; impl_)
-  : impl(impl_)
-{
-  
-}
-
-Brush
-Brush::clone() const
-{
-  return Brush(impl-&gt;clone());
-}
-
-CL_Sprite
-Brush::get_sprite()
-{
-  return impl-&gt;get_sprite();
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/brush.hpp (from rev 712, trunk/flexlay/lib/brush.hxx)
===================================================================
--- trunk/flexlay/lib/brush.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/brush.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,41 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_BRUSH_HXX
+#define HEADER_BRUSH_HXX
+
+#include &quot;brush_impl.hpp&quot;
+#include &quot;shared_ptr.hpp&quot;
+
+/** */
+class Brush
+{
+public:
+  Brush();
+  Brush(SharedPtr&lt;BrushImpl&gt; impl);
+
+  CL_Sprite get_sprite();
+  Brush clone() const;
+  bool is_null() const { return !impl.get(); }
+public:
+  SharedPtr&lt;BrushImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/brush.hxx
===================================================================
--- trunk/flexlay/lib/brush.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/brush.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,41 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_BRUSH_HXX
-#define HEADER_BRUSH_HXX
-
-#include &quot;brush_impl.hxx&quot;
-#include &quot;shared_ptr.hxx&quot;
-
-/** */
-class Brush
-{
-public:
-  Brush();
-  Brush(SharedPtr&lt;BrushImpl&gt; impl);
-
-  CL_Sprite get_sprite();
-  Brush clone() const;
-  bool is_null() const { return !impl.get(); }
-public:
-  SharedPtr&lt;BrushImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/brush_impl.hpp (from rev 712, trunk/flexlay/lib/brush_impl.hxx)

Deleted: trunk/flexlay/lib/brush_impl.hxx
===================================================================
--- trunk/flexlay/lib/brush_impl.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/brush_impl.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,35 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_BRUSH_IMPL_HXX
-#define HEADER_BRUSH_IMPL_HXX
-
-#include &lt;ClanLib/Display/sprite.h&gt;
-
-/** */
-class BrushImpl
-{
-public:
-  virtual ~BrushImpl() {}
-  virtual CL_Sprite get_sprite() =0;
-  virtual BrushImpl* clone() const =0;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/brushmask.cpp (from rev 712, trunk/flexlay/lib/brushmask.cxx)
===================================================================
--- trunk/flexlay/lib/brushmask.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/brushmask.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,353 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2004 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+/* Most of the code below is taken from Gimp2.2:
+   gimp_brush_generated module Copyright 1998 Jay Cox &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">jaycox at earthlink.net</A>&gt; 
+ */
+
+#include &lt;iostream&gt;
+#include &lt;math.h&gt;
+#include &lt;string.h&gt;
+#include &lt;ClanLib/Display/pixel_format.h&gt;
+#include &quot;brushmask.hpp&quot;
+
+#define OVERSAMPLING 5
+
+typedef int gint;
+typedef unsigned char guchar;
+
+struct TempBuf {
+  gint      width;
+  gint      height;
+
+  guchar   *data;       /*  The data buffer. Do never access this field
+                            directly, use temp_buf_data() instead !!       */
+};
+
+void
+temp_buf_free (TempBuf *temp_buf)
+{
+  // FIXME:
+  delete temp_buf;
+}
+
+guchar *
+temp_buf_data (TempBuf *temp_buf)
+{
+  return temp_buf-&gt;data;
+}
+
+TempBuf *
+temp_buf_new (gint    width,
+	      gint    height,
+	      gint    bytes,
+	      gint    x,
+	      gint    y,
+	      guchar *col)
+{
+  TempBuf* buf = new TempBuf;
+
+  buf-&gt;data   = new guchar[width*height];
+  memset(buf-&gt;data, 0, width*height*sizeof(guchar));
+ 
+  buf-&gt;width  = width;
+  buf-&gt;height = height;
+
+  return buf;
+}
+
+#define gimp_deg_to_rad(angle) ((angle) * (2.0 * M_PI) / 360.0)
+#define gimp_rad_to_deg(angle) ((angle) * 360.0 / (2.0 * M_PI))
+
+static double
+gauss (double f)
+{
+  /* this aint' a real gauss function */
+  if (f &lt; -0.5)
+    {
+      f = -1.0 - f;
+      return (2.0 * f*f);
+    }
+
+  if (f &lt; 0.5)
+    return (1.0 - 2.0 * f*f);
+
+  f = 1.0 - f;
+  return (2.0 * f*f);
+}
+
+struct GimpVector2
+{
+  double x, y;
+};
+
+struct GimpBrushGenerated
+{
+  TempBuf      *mask;       /*  the actual mask                */
+
+  GimpVector2   x_axis;     /*  for calculating brush spacing  */
+  GimpVector2   y_axis;     /*  for calculating brush spacing  */
+
+  BrushShape shape;
+  float                  radius;
+  gint                    spikes;       /* 2 - 20     */
+  float                  hardness;     /* 0.0 - 1.0  */
+  float                  aspect_ratio; /* y/x        */
+  float                  angle;        /* in degrees */
+};
+
+
+static void
+gimp_brush_generated_dirty (GimpBrushGenerated *brush)
+{
+  gint                x, y;
+  guchar             *centerp;
+  double             d;
+  double             exponent;
+  guchar              a;
+  gint                length;
+  gint                width  = 0;
+  gint                height = 0;
+  guchar             *lookup;
+  double             sum;
+  double             c, s, cs, ss;
+  double             short_radius;
+  double             buffer[OVERSAMPLING];
+
+  if (brush-&gt;mask)
+    temp_buf_free (brush-&gt;mask);
+
+  s = sin (gimp_deg_to_rad (brush-&gt;angle));
+  c = cos (gimp_deg_to_rad (brush-&gt;angle));
+
+  short_radius = brush-&gt;radius / brush-&gt;aspect_ratio;
+
+  brush-&gt;x_axis.x =        c * brush-&gt;radius;
+  brush-&gt;x_axis.y = -1.0 * s * brush-&gt;radius;
+  brush-&gt;y_axis.x =        s * short_radius;
+  brush-&gt;y_axis.y =        c * short_radius;
+
+  switch (brush-&gt;shape)
+    {
+    case BRUSH_SHAPE_CIRCLE:
+      width  = static_cast&lt;int&gt;(ceil (sqrt (brush-&gt;x_axis.x * brush-&gt;x_axis.x +
+                                            brush-&gt;y_axis.x * brush-&gt;y_axis.x)));
+      height = static_cast&lt;int&gt;(ceil (sqrt (brush-&gt;x_axis.y * brush-&gt;x_axis.y +
+                                            brush-&gt;y_axis.y * brush-&gt;y_axis.y)));
+      break;
+
+    case BRUSH_SHAPE_SQUARE:
+      width  = static_cast&lt;int&gt;(ceil (fabs (brush-&gt;x_axis.x) + fabs (brush-&gt;y_axis.x)));
+      height = static_cast&lt;int&gt;(ceil (fabs (brush-&gt;x_axis.y) + fabs (brush-&gt;y_axis.y)));
+      break;
+
+    case BRUSH_SHAPE_DIAMOND:
+      width  = static_cast&lt;int&gt;(ceil (std::max(fabs (brush-&gt;x_axis.x), fabs (brush-&gt;y_axis.x))));
+      height = static_cast&lt;int&gt;(ceil (std::max(fabs (brush-&gt;x_axis.y), fabs (brush-&gt;y_axis.y))));
+      break;
+
+    default:
+      return;
+    }
+
+  if (brush-&gt;spikes &gt; 2)
+    {
+      /* could be optimized by respecting the angle */
+      width = height = static_cast&lt;int&gt;(ceil (sqrt (brush-&gt;radius * brush-&gt;radius +
+                                                    short_radius * short_radius)));
+      brush-&gt;y_axis.x =        s * brush-&gt;radius;
+      brush-&gt;y_axis.y =        c * brush-&gt;radius;
+    }
+
+  brush-&gt;mask = temp_buf_new (width  * 2 + 1,
+                              height * 2 + 1,
+                              1, width, height, NULL);
+
+  centerp = temp_buf_data (brush-&gt;mask) + height * brush-&gt;mask-&gt;width + width;
+
+  /* set up lookup table */
+  length = static_cast&lt;int&gt;(OVERSAMPLING * ceil (1 + sqrt (2 *
+                                                           ceil (brush-&gt;radius + 1.0) *
+                                                           ceil (brush-&gt;radius + 1.0))));
+
+  if ((1.0 - brush-&gt;hardness) &lt; 0.0000004)
+    exponent = 1000000.0;
+  else
+    exponent = 0.4 / (1.0 - brush-&gt;hardness);
+
+  lookup = new guchar[length];
+  sum = 0.0;
+
+  for (x = 0; x &lt; OVERSAMPLING; x++)
+    {
+      d = fabs ((x + 0.5) / OVERSAMPLING - 0.5);
+
+      if (d &gt; brush-&gt;radius)
+        buffer[x] = 0.0;
+      else
+        buffer[x] = gauss (pow (d / brush-&gt;radius, exponent));
+
+      sum += buffer[x];
+    }
+
+  for (x = 0; d &lt; brush-&gt;radius || sum &gt; 0.00001; d += 1.0 / OVERSAMPLING)
+    {
+      sum -= buffer[x % OVERSAMPLING];
+
+      if (d &gt; brush-&gt;radius)
+        buffer[x % OVERSAMPLING] = 0.0;
+      else
+        buffer[x % OVERSAMPLING] = gauss (pow (d / brush-&gt;radius, exponent));
+
+      sum += buffer[x % OVERSAMPLING];
+      lookup[x++] = static_cast&lt;int&gt;(rint(sum * (255.0 / OVERSAMPLING)));
+    }
+
+  while (x &lt; length)
+    {
+      lookup[x++] = 0;
+    }
+
+  cs = cos (- 2 * M_PI / brush-&gt;spikes);
+  ss = sin (- 2 * M_PI / brush-&gt;spikes);
+
+  /* for an even number of spikes compute one half and mirror it */
+  for (y = (brush-&gt;spikes % 2 ? -height : 0); y &lt;= height; y++)
+    {
+      for (x = -width; x &lt;= width; x++)
+        {
+          double tx, ty, angle;
+
+          tx = c*x - s*y;
+          ty = fabs (s*x + c*y);
+
+          if (brush-&gt;spikes &gt; 2)
+            {
+              angle = atan2 (ty, tx);
+
+              while (angle &gt; M_PI / brush-&gt;spikes)
+                {
+                  double sx = tx, sy = ty;
+
+                  tx = cs * sx - ss * sy;
+                  ty = ss * sx + cs * sy;
+
+                  angle -= 2 * M_PI / brush-&gt;spikes;
+                }
+            }
+
+          ty *= brush-&gt;aspect_ratio;
+          switch (brush-&gt;shape)
+            {
+            case BRUSH_SHAPE_CIRCLE:
+              d = sqrt (tx*tx + ty*ty);
+              break;
+            case BRUSH_SHAPE_SQUARE:
+              d = std::max (fabs (tx), fabs (ty));
+              break;
+            case BRUSH_SHAPE_DIAMOND:
+              d = fabs (tx) + fabs (ty);
+              break;
+            }
+
+          if (d &lt; brush-&gt;radius + 1)
+            a = lookup[(gint) rint (d * OVERSAMPLING)];
+          else
+            a = 0;
+
+          centerp[ y * brush-&gt;mask-&gt;width + x] = a;
+
+          if (brush-&gt;spikes % 2 == 0)
+            centerp[-1 * y * brush-&gt;mask-&gt;width - x] = a;
+        }
+    }
+
+  delete lookup;
+}
+
+CL_PixelBuffer generate_brushmask(BrushShape shape,
+                                  float  radius,
+                                  int    spikes,        /* 2 - 20     */
+                                  float  hardness,      /* 0.0 - 1.0  */
+                                  float  aspect_ratio,  /* y/x        */
+                                  float  angle)         /* in degrees */
+{
+  GimpBrushGenerated brush;
+  
+  brush.mask         = 0;
+  brush.shape        = shape;
+  brush.radius       = radius;
+  brush.spikes       = spikes;
+  brush.hardness     = hardness;
+  brush.aspect_ratio = aspect_ratio;
+  brush.angle        = angle;
+
+  gimp_brush_generated_dirty(&amp;brush);
+
+  CL_PixelBuffer buffer(brush.mask-&gt;width, brush.mask-&gt;height, brush.mask-&gt;width*4,
+                        CL_PixelFormat::rgba8888);
+  
+  buffer.lock();
+  unsigned char* buf = static_cast&lt;unsigned char*&gt;(buffer.get_data());
+
+  // FIXME: Leaving out the right/bottom border, since thats full of
+  // random spots... more a workaround than a fix really
+  for (int i = 0; i &lt; brush.mask-&gt;height * brush.mask-&gt;width; ++i)
+    {
+      buf[i*4+0] = brush.mask-&gt;data[i];
+      buf[i*4+1] = 255;
+      buf[i*4+2] = 255;
+      buf[i*4+3] = 255;
+    }
+  buffer.unlock();
+
+  return buffer;
+}
+
+#ifdef TEST
+int main()
+{
+  GimpBrushGenerated brush;
+  
+  brush.mask         = 0;
+  brush.shape        = BRUSH_SHAPE_DIAMOND;
+  brush.radius       = 512;
+  brush.spikes       = 19;
+  brush.hardness     = 0.9;
+  brush.aspect_ratio = 1;
+  brush.angle        = 0;
+
+  gimp_brush_generated_dirty(&amp;brush);
+
+  std::cout &lt;&lt; &quot;P2\n&quot;;
+  std::cout &lt;&lt; &quot;# Gimp Brush Generator\n&quot;;
+  std::cout &lt;&lt; brush.mask-&gt;width &lt;&lt; &quot; &quot; &lt;&lt; brush.mask-&gt;height &lt;&lt; &quot;\n&quot;;
+  std::cout &lt;&lt; &quot;255\n&quot;;
+
+  for (int i = 0; i &lt; brush.mask-&gt;width * brush.mask-&gt;height; ++i)
+    std::cout &lt;&lt; int(brush.mask-&gt;data[i]) &lt;&lt; &quot; &quot;;
+
+  temp_buf_free(brush.mask);
+  
+  std::cout &lt;&lt; std::endl;
+
+  return 0;
+}
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/brushmask.cxx
===================================================================
--- trunk/flexlay/lib/brushmask.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/brushmask.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,353 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2004 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-/* Most of the code below is taken from Gimp2.2:
-   gimp_brush_generated module Copyright 1998 Jay Cox &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">jaycox at earthlink.net</A>&gt; 
- */
-
-#include &lt;iostream&gt;
-#include &lt;math.h&gt;
-#include &lt;string.h&gt;
-#include &lt;ClanLib/Display/pixel_format.h&gt;
-#include &quot;brushmask.hxx&quot;
-
-#define OVERSAMPLING 5
-
-typedef int gint;
-typedef unsigned char guchar;
-
-struct TempBuf {
-  gint      width;
-  gint      height;
-
-  guchar   *data;       /*  The data buffer. Do never access this field
-                            directly, use temp_buf_data() instead !!       */
-};
-
-void
-temp_buf_free (TempBuf *temp_buf)
-{
-  // FIXME:
-  delete temp_buf;
-}
-
-guchar *
-temp_buf_data (TempBuf *temp_buf)
-{
-  return temp_buf-&gt;data;
-}
-
-TempBuf *
-temp_buf_new (gint    width,
-	      gint    height,
-	      gint    bytes,
-	      gint    x,
-	      gint    y,
-	      guchar *col)
-{
-  TempBuf* buf = new TempBuf;
-
-  buf-&gt;data   = new guchar[width*height];
-  memset(buf-&gt;data, 0, width*height*sizeof(guchar));
- 
-  buf-&gt;width  = width;
-  buf-&gt;height = height;
-
-  return buf;
-}
-
-#define gimp_deg_to_rad(angle) ((angle) * (2.0 * M_PI) / 360.0)
-#define gimp_rad_to_deg(angle) ((angle) * 360.0 / (2.0 * M_PI))
-
-static double
-gauss (double f)
-{
-  /* this aint' a real gauss function */
-  if (f &lt; -0.5)
-    {
-      f = -1.0 - f;
-      return (2.0 * f*f);
-    }
-
-  if (f &lt; 0.5)
-    return (1.0 - 2.0 * f*f);
-
-  f = 1.0 - f;
-  return (2.0 * f*f);
-}
-
-struct GimpVector2
-{
-  double x, y;
-};
-
-struct GimpBrushGenerated
-{
-  TempBuf      *mask;       /*  the actual mask                */
-
-  GimpVector2   x_axis;     /*  for calculating brush spacing  */
-  GimpVector2   y_axis;     /*  for calculating brush spacing  */
-
-  BrushShape shape;
-  float                  radius;
-  gint                    spikes;       /* 2 - 20     */
-  float                  hardness;     /* 0.0 - 1.0  */
-  float                  aspect_ratio; /* y/x        */
-  float                  angle;        /* in degrees */
-};
-
-
-static void
-gimp_brush_generated_dirty (GimpBrushGenerated *brush)
-{
-  gint                x, y;
-  guchar             *centerp;
-  double             d;
-  double             exponent;
-  guchar              a;
-  gint                length;
-  gint                width  = 0;
-  gint                height = 0;
-  guchar             *lookup;
-  double             sum;
-  double             c, s, cs, ss;
-  double             short_radius;
-  double             buffer[OVERSAMPLING];
-
-  if (brush-&gt;mask)
-    temp_buf_free (brush-&gt;mask);
-
-  s = sin (gimp_deg_to_rad (brush-&gt;angle));
-  c = cos (gimp_deg_to_rad (brush-&gt;angle));
-
-  short_radius = brush-&gt;radius / brush-&gt;aspect_ratio;
-
-  brush-&gt;x_axis.x =        c * brush-&gt;radius;
-  brush-&gt;x_axis.y = -1.0 * s * brush-&gt;radius;
-  brush-&gt;y_axis.x =        s * short_radius;
-  brush-&gt;y_axis.y =        c * short_radius;
-
-  switch (brush-&gt;shape)
-    {
-    case BRUSH_SHAPE_CIRCLE:
-      width  = static_cast&lt;int&gt;(ceil (sqrt (brush-&gt;x_axis.x * brush-&gt;x_axis.x +
-                                            brush-&gt;y_axis.x * brush-&gt;y_axis.x)));
-      height = static_cast&lt;int&gt;(ceil (sqrt (brush-&gt;x_axis.y * brush-&gt;x_axis.y +
-                                            brush-&gt;y_axis.y * brush-&gt;y_axis.y)));
-      break;
-
-    case BRUSH_SHAPE_SQUARE:
-      width  = static_cast&lt;int&gt;(ceil (fabs (brush-&gt;x_axis.x) + fabs (brush-&gt;y_axis.x)));
-      height = static_cast&lt;int&gt;(ceil (fabs (brush-&gt;x_axis.y) + fabs (brush-&gt;y_axis.y)));
-      break;
-
-    case BRUSH_SHAPE_DIAMOND:
-      width  = static_cast&lt;int&gt;(ceil (std::max(fabs (brush-&gt;x_axis.x), fabs (brush-&gt;y_axis.x))));
-      height = static_cast&lt;int&gt;(ceil (std::max(fabs (brush-&gt;x_axis.y), fabs (brush-&gt;y_axis.y))));
-      break;
-
-    default:
-      return;
-    }
-
-  if (brush-&gt;spikes &gt; 2)
-    {
-      /* could be optimized by respecting the angle */
-      width = height = static_cast&lt;int&gt;(ceil (sqrt (brush-&gt;radius * brush-&gt;radius +
-                                                    short_radius * short_radius)));
-      brush-&gt;y_axis.x =        s * brush-&gt;radius;
-      brush-&gt;y_axis.y =        c * brush-&gt;radius;
-    }
-
-  brush-&gt;mask = temp_buf_new (width  * 2 + 1,
-                              height * 2 + 1,
-                              1, width, height, NULL);
-
-  centerp = temp_buf_data (brush-&gt;mask) + height * brush-&gt;mask-&gt;width + width;
-
-  /* set up lookup table */
-  length = static_cast&lt;int&gt;(OVERSAMPLING * ceil (1 + sqrt (2 *
-                                                           ceil (brush-&gt;radius + 1.0) *
-                                                           ceil (brush-&gt;radius + 1.0))));
-
-  if ((1.0 - brush-&gt;hardness) &lt; 0.0000004)
-    exponent = 1000000.0;
-  else
-    exponent = 0.4 / (1.0 - brush-&gt;hardness);
-
-  lookup = new guchar[length];
-  sum = 0.0;
-
-  for (x = 0; x &lt; OVERSAMPLING; x++)
-    {
-      d = fabs ((x + 0.5) / OVERSAMPLING - 0.5);
-
-      if (d &gt; brush-&gt;radius)
-        buffer[x] = 0.0;
-      else
-        buffer[x] = gauss (pow (d / brush-&gt;radius, exponent));
-
-      sum += buffer[x];
-    }
-
-  for (x = 0; d &lt; brush-&gt;radius || sum &gt; 0.00001; d += 1.0 / OVERSAMPLING)
-    {
-      sum -= buffer[x % OVERSAMPLING];
-
-      if (d &gt; brush-&gt;radius)
-        buffer[x % OVERSAMPLING] = 0.0;
-      else
-        buffer[x % OVERSAMPLING] = gauss (pow (d / brush-&gt;radius, exponent));
-
-      sum += buffer[x % OVERSAMPLING];
-      lookup[x++] = static_cast&lt;int&gt;(rint(sum * (255.0 / OVERSAMPLING)));
-    }
-
-  while (x &lt; length)
-    {
-      lookup[x++] = 0;
-    }
-
-  cs = cos (- 2 * M_PI / brush-&gt;spikes);
-  ss = sin (- 2 * M_PI / brush-&gt;spikes);
-
-  /* for an even number of spikes compute one half and mirror it */
-  for (y = (brush-&gt;spikes % 2 ? -height : 0); y &lt;= height; y++)
-    {
-      for (x = -width; x &lt;= width; x++)
-        {
-          double tx, ty, angle;
-
-          tx = c*x - s*y;
-          ty = fabs (s*x + c*y);
-
-          if (brush-&gt;spikes &gt; 2)
-            {
-              angle = atan2 (ty, tx);
-
-              while (angle &gt; M_PI / brush-&gt;spikes)
-                {
-                  double sx = tx, sy = ty;
-
-                  tx = cs * sx - ss * sy;
-                  ty = ss * sx + cs * sy;
-
-                  angle -= 2 * M_PI / brush-&gt;spikes;
-                }
-            }
-
-          ty *= brush-&gt;aspect_ratio;
-          switch (brush-&gt;shape)
-            {
-            case BRUSH_SHAPE_CIRCLE:
-              d = sqrt (tx*tx + ty*ty);
-              break;
-            case BRUSH_SHAPE_SQUARE:
-              d = std::max (fabs (tx), fabs (ty));
-              break;
-            case BRUSH_SHAPE_DIAMOND:
-              d = fabs (tx) + fabs (ty);
-              break;
-            }
-
-          if (d &lt; brush-&gt;radius + 1)
-            a = lookup[(gint) rint (d * OVERSAMPLING)];
-          else
-            a = 0;
-
-          centerp[ y * brush-&gt;mask-&gt;width + x] = a;
-
-          if (brush-&gt;spikes % 2 == 0)
-            centerp[-1 * y * brush-&gt;mask-&gt;width - x] = a;
-        }
-    }
-
-  delete lookup;
-}
-
-CL_PixelBuffer generate_brushmask(BrushShape shape,
-                                  float  radius,
-                                  int    spikes,        /* 2 - 20     */
-                                  float  hardness,      /* 0.0 - 1.0  */
-                                  float  aspect_ratio,  /* y/x        */
-                                  float  angle)         /* in degrees */
-{
-  GimpBrushGenerated brush;
-  
-  brush.mask         = 0;
-  brush.shape        = shape;
-  brush.radius       = radius;
-  brush.spikes       = spikes;
-  brush.hardness     = hardness;
-  brush.aspect_ratio = aspect_ratio;
-  brush.angle        = angle;
-
-  gimp_brush_generated_dirty(&amp;brush);
-
-  CL_PixelBuffer buffer(brush.mask-&gt;width, brush.mask-&gt;height, brush.mask-&gt;width*4,
-                        CL_PixelFormat::rgba8888);
-  
-  buffer.lock();
-  unsigned char* buf = static_cast&lt;unsigned char*&gt;(buffer.get_data());
-
-  // FIXME: Leaving out the right/bottom border, since thats full of
-  // random spots... more a workaround than a fix really
-  for (int i = 0; i &lt; brush.mask-&gt;height * brush.mask-&gt;width; ++i)
-    {
-      buf[i*4+0] = brush.mask-&gt;data[i];
-      buf[i*4+1] = 255;
-      buf[i*4+2] = 255;
-      buf[i*4+3] = 255;
-    }
-  buffer.unlock();
-
-  return buffer;
-}
-
-#ifdef TEST
-int main()
-{
-  GimpBrushGenerated brush;
-  
-  brush.mask         = 0;
-  brush.shape        = BRUSH_SHAPE_DIAMOND;
-  brush.radius       = 512;
-  brush.spikes       = 19;
-  brush.hardness     = 0.9;
-  brush.aspect_ratio = 1;
-  brush.angle        = 0;
-
-  gimp_brush_generated_dirty(&amp;brush);
-
-  std::cout &lt;&lt; &quot;P2\n&quot;;
-  std::cout &lt;&lt; &quot;# Gimp Brush Generator\n&quot;;
-  std::cout &lt;&lt; brush.mask-&gt;width &lt;&lt; &quot; &quot; &lt;&lt; brush.mask-&gt;height &lt;&lt; &quot;\n&quot;;
-  std::cout &lt;&lt; &quot;255\n&quot;;
-
-  for (int i = 0; i &lt; brush.mask-&gt;width * brush.mask-&gt;height; ++i)
-    std::cout &lt;&lt; int(brush.mask-&gt;data[i]) &lt;&lt; &quot; &quot;;
-
-  temp_buf_free(brush.mask);
-  
-  std::cout &lt;&lt; std::endl;
-
-  return 0;
-}
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/brushmask.hpp (from rev 712, trunk/flexlay/lib/brushmask.hxx)

Deleted: trunk/flexlay/lib/brushmask.hxx
===================================================================
--- trunk/flexlay/lib/brushmask.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/brushmask.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,39 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2004 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_BRUSHMASK_HXX
-#define HEADER_BRUSHMASK_HXX
-
-#include &lt;ClanLib/Display/pixel_buffer.h&gt;
-
-enum BrushShape {
-  BRUSH_SHAPE_CIRCLE,
-  BRUSH_SHAPE_SQUARE,
-  BRUSH_SHAPE_DIAMOND
-};
-
-CL_PixelBuffer generate_brushmask(BrushShape shape,
-                                  float  radius,
-                                  int    spikes,        /* 2 - 20     */
-                                  float  hardness,      /* 0.0 - 1.0  */
-                                  float  aspect_ratio,  /* y/x        */
-                                  float  angle);        /* in degrees */
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/colorpicker.cpp (from rev 712, trunk/flexlay/lib/colorpicker.cxx)
===================================================================
--- trunk/flexlay/lib/colorpicker.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/colorpicker.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,409 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;vector&gt;
+#include &lt;iostream&gt;
+#include &lt;ClanLib/Display/display_iostream.h&gt;
+#include &lt;ClanLib/Display/color.h&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &lt;ClanLib/Display/keys.h&gt;
+#include &lt;ClanLib/Core/Math/rect.h&gt;
+#include &lt;ClanLib/Core/Math/point.h&gt;
+#include &lt;ClanLib/GUI/component.h&gt;
+#include &quot;colorpicker.hpp&quot;
+#include &quot;math.hpp&quot;
+
+class ColorPickerHue : public CL_Component
+{
+public:
+  std::vector&lt;CL_Slot&gt; slots;
+  typedef std::vector&lt;CL_Color&gt; Colors;
+  Colors  colors;
+  bool pressed;
+  CL_Signal_v1&lt;CL_Color&gt; on_color_change;
+  
+  ColorPickerHue(const CL_Rect&amp; rect, CL_Component* parent) 
+    : CL_Component(rect, parent),
+      pressed(false)
+  {
+    colors.push_back(CL_Color(255,   0,   0));
+    colors.push_back(CL_Color(255,   0, 255));
+    colors.push_back(CL_Color(  0,   0, 255));
+    colors.push_back(CL_Color(  0, 255, 255));
+    colors.push_back(CL_Color(  0, 255,   0));
+    colors.push_back(CL_Color(255, 255,   0));
+    colors.push_back(CL_Color(255,   0,   0));
+
+    slots.push_back(sig_paint().connect(this, &amp;ColorPickerHue::draw));
+
+    slots.push_back(sig_mouse_down().connect(this, &amp;ColorPickerHue::on_mouse_down));
+    slots.push_back(sig_mouse_up().connect(this, &amp;ColorPickerHue::on_mouse_up));
+    slots.push_back(sig_mouse_move().connect(this, &amp;ColorPickerHue::on_mouse_move));
+  }
+
+  void update_pointer(const CL_InputEvent&amp; event)
+  {
+    CL_Color new_color; 
+
+    if (event.mouse_pos.y &gt;= get_height() || event.mouse_pos.y &lt; 0)
+      {
+        new_color = colors[0];
+      }
+    else
+      {
+        float factor  = (float(event.mouse_pos.y) / get_height()) * (colors.size()-1);
+        int   prevcol = int(factor);
+        int   nextcol = prevcol+1;
+
+        float val  = factor - prevcol;
+        float ival = 1.0f - val;
+
+
+        if (val &gt;= 0 &amp;&amp; val &lt; 1.0f)
+          {
+            new_color = CL_Color(int(val * colors[nextcol].get_red()   + ival * colors[prevcol].get_red()),
+                                 int(val * colors[nextcol].get_green() + ival * colors[prevcol].get_green()),
+                                 int(val * colors[nextcol].get_blue()  + ival * colors[prevcol].get_blue()),
+                                 int(val * colors[nextcol].get_alpha() + ival * colors[prevcol].get_alpha()));
+          }
+        else
+          {
+            std::cout &lt;&lt; &quot;Out of range&quot; &lt;&lt; std::endl;
+            new_color = colors[0];
+          }
+      }
+    on_color_change(new_color);
+
+    /*
+    std::cout &lt;&lt; new_color.get_red() &lt;&lt; &quot;, &quot;
+              &lt;&lt; new_color.get_green() &lt;&lt; &quot;, &quot;
+              &lt;&lt; new_color.get_blue() &lt;&lt; &quot;, &quot;
+              &lt;&lt; new_color.get_alpha()
+              &lt;&lt; std::endl;*/
+  }
+  
+  void on_mouse_up(const CL_InputEvent&amp; event)
+  {
+    if (event.id == CL_MOUSE_LEFT)
+      {
+        pressed = false;
+        release_mouse();
+        update_pointer(event);
+      }
+  }
+
+  void on_mouse_down(const CL_InputEvent&amp; event)
+  {
+    if (event.id == CL_MOUSE_LEFT)
+      {
+        pressed = true;
+        capture_mouse();
+        update_pointer(event);
+      }  
+  }
+  
+  void on_mouse_move(const CL_InputEvent&amp; event)
+  {
+    if (pressed)
+      {
+        update_pointer(event);
+      }
+  }
+
+  void draw()
+  {
+    CL_Display::push_modelview();
+    CL_Display::add_translate(get_screen_x(), get_screen_y());
+    
+    int psize = get_height()/6;
+    
+    for(Colors::size_type i = 0; i &lt; colors.size()-1; ++i)
+      {
+        CL_Display::fill_rect(CL_Rect(CL_Point(0, i*psize),
+                                      CL_Size(get_width(), psize)),
+                              CL_Gradient(colors[i],
+                                          colors[i],
+                                          colors[i+1],
+                                          colors[i+1]));
+      }
+
+    CL_Display::pop_modelview();    
+  }
+};
+
+class ColorPickerAlpha : public CL_Component
+{
+public:
+  std::vector&lt;CL_Slot&gt; slots;
+  bool pressed;
+  CL_Signal_v1&lt;float&gt; on_color_change;
+  float alpha;
+
+  ColorPickerAlpha(const CL_Rect&amp; rect, CL_Component* parent) 
+    : CL_Component(rect, parent),
+      pressed(false),
+      alpha(0.5f)
+  {
+    slots.push_back(sig_paint().connect(this, &amp;ColorPickerAlpha::draw));
+
+    slots.push_back(sig_mouse_down().connect(this, &amp;ColorPickerAlpha::on_mouse_down));
+    slots.push_back(sig_mouse_up().connect(this, &amp;ColorPickerAlpha::on_mouse_up));
+    slots.push_back(sig_mouse_move().connect(this, &amp;ColorPickerAlpha::on_mouse_move));
+  }
+
+  void set_alpha(float alpha_)
+  {
+    alpha = alpha_;
+    on_color_change(alpha);
+  }  
+
+  void draw()
+  {
+    CL_Display::push_modelview();
+    CL_Display::add_translate(get_screen_x(), get_screen_y());    
+   
+    CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
+                                  CL_Size(get_width(), get_height())),
+                          CL_Gradient(CL_Color(0, 0, 0),
+                                      CL_Color(255, 255, 255),
+                                      CL_Color(0, 0, 0),
+                                      CL_Color(255, 255, 255)));
+
+    CL_Display::pop_modelview();
+  }
+
+  void update_pointer(const CL_InputEvent&amp; event)
+  {
+    alpha = 1.0f - (Math::mid(0.0f, float(event.mouse_pos.x) / get_width(), 1.0f));
+    on_color_change(alpha);
+  }
+
+  void on_mouse_up(const CL_InputEvent&amp; event)
+  {
+    if (event.id == CL_MOUSE_LEFT)
+      {
+        pressed = false;
+        release_mouse();
+        update_pointer(event);
+      }
+  }
+
+  void on_mouse_down(const CL_InputEvent&amp; event)
+  {
+    if (event.id == CL_MOUSE_LEFT)
+      {
+        pressed = true;
+        capture_mouse();
+        update_pointer(event);
+      }
+  }
+
+  void on_mouse_move(const CL_InputEvent&amp; event)
+  {
+    if (pressed)
+      {
+        update_pointer(event);    
+      }
+  }
+};
+
+class ColorPickerBrightness : public CL_Component
+{
+public:
+  std::vector&lt;CL_Slot&gt; slots;
+  CL_Color color;
+  bool pressed;
+  CL_Signal_v1&lt;CL_Color&gt; on_color_change;
+  float factor_x;
+  float factor_y;
+  ColorPickerBrightness(const CL_Rect&amp; rect, CL_Component* parent) 
+    : CL_Component(rect, parent),
+      pressed(false),
+      factor_x(1.0f),
+      factor_y(1.0f)
+  {
+    color = CL_Color(255, 0, 0);
+    slots.push_back(sig_paint().connect(this, &amp;ColorPickerBrightness::draw));
+
+    slots.push_back(sig_mouse_down().connect(this, &amp;ColorPickerBrightness::on_mouse_down));
+    slots.push_back(sig_mouse_up().connect(this, &amp;ColorPickerBrightness::on_mouse_up));
+    slots.push_back(sig_mouse_move().connect(this, &amp;ColorPickerBrightness::on_mouse_move));
+  }
+
+  void draw()
+  {
+    CL_Display::push_modelview();
+    CL_Display::add_translate(get_screen_x(), get_screen_y());
+
+    CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
+                                  CL_Size(get_width(), get_height())),
+                          CL_Gradient(CL_Color(0, 0, 0),
+                                      color,
+                                      CL_Color(0, 0, 0),
+                                      CL_Color(255, 255, 255)));
+
+    CL_Display::draw_line(factor_x * get_width(),
+                          0,
+                          factor_x * get_width(),
+                          get_height(),
+                          CL_Color(255, 255, 255));
+
+    CL_Display::draw_line(0,
+                          factor_y * get_height(),
+                          get_width(),
+                          factor_y * get_height(),
+                          CL_Color(255, 255, 255));
+
+    CL_Display::pop_modelview();
+  }
+
+  void set_color(CL_Color color_) {
+    color = color_;
+    update_color();
+  }
+
+  void update_color()
+  {
+    CL_Color new_color(Math::mid(0, int(factor_x * color.get_red()   * (1.0f - factor_y) + factor_x * 255 * (factor_y)), 255),
+                       Math::mid(0, int(factor_x * color.get_green() * (1.0f - factor_y) + factor_x * 255 * (factor_y)), 255),   
+                       Math::mid(0, int(factor_x * color.get_blue()  * (1.0f - factor_y) + factor_x * 255 * (factor_y)), 255),
+                       color.get_alpha());
+    on_color_change(new_color);
+    /*
+    std::cout &lt;&lt; new_color.get_red() &lt;&lt; &quot;, &quot;
+              &lt;&lt; new_color.get_green() &lt;&lt; &quot;, &quot;
+              &lt;&lt; new_color.get_blue() &lt;&lt; &quot;, &quot;
+              &lt;&lt; new_color.get_alpha()
+              &lt;&lt; std::endl;
+    */
+  }
+
+  void update_pointer(const CL_InputEvent&amp; event)
+  {
+    factor_x = Math::mid(0.0f, float(event.mouse_pos.x)/get_width(), 1.0f);
+    factor_y = Math::mid(0.0f, float(event.mouse_pos.y)/get_height(), 1.0f);
+
+    update_color();
+  }
+
+  void on_mouse_up(const CL_InputEvent&amp; event)
+  {
+    if (event.id == CL_MOUSE_LEFT)
+      {
+        pressed = false;
+        release_mouse();
+        update_pointer(event);
+      }    
+  }
+
+  void on_mouse_down(const CL_InputEvent&amp; event)
+  {
+    if (event.id == CL_MOUSE_LEFT)
+      {
+        pressed = true;
+        capture_mouse();
+        update_pointer(event);
+      }
+  }
+
+  void on_mouse_move(const CL_InputEvent&amp; event)
+  {
+    if (pressed)
+      {
+        update_pointer(event);
+      }
+  }
+};
+
+ColorPicker::ColorPicker(const CL_Rect&amp; rect, CL_Component* parent)
+  : CL_Component(rect, parent)
+{
+  float pwidth  = rect.get_width()/11.0;
+  float pheight = rect.get_height()/11.0;
+
+  brightness = new ColorPickerBrightness(CL_Rect(CL_Point(0, 0),
+                                                 CL_Size(int(pwidth*10), int(pheight*10))), 
+                                         this);
+  
+  hue        = new ColorPickerHue(CL_Rect(CL_Point(int(pwidth*10), 0),
+                                          CL_Size(int(pwidth*1), int(pheight*10))),
+                                  this);
+
+  alpha      = new ColorPickerAlpha(CL_Rect(CL_Point(0, int(pheight*10)),
+                                            CL_Size(int(pwidth*10), int(pheight*1))),
+                                    this);
+
+  slots.push_back(hue-&gt;on_color_change.connect(brightness, &amp;ColorPickerBrightness::set_color));
+  slots.push_back(brightness-&gt;on_color_change.connect(this, &amp;ColorPicker::update_brightness_color));
+  slots.push_back(alpha-&gt;on_color_change.connect(this, &amp;ColorPicker::update_alpha_color));
+  slots.push_back(sig_paint().connect(this, &amp;ColorPicker::draw));
+
+  brightness-&gt;set_color(CL_Color(255, 0, 0));
+  alpha-&gt;set_alpha(0.5f);
+}
+
+void
+ColorPicker::update_alpha_color(float alpha)
+{
+  color.set_alpha(int(255 * alpha));
+  on_color_change(color);  
+}
+
+void
+ColorPicker::update_brightness_color(CL_Color color_)
+{
+  color.set_red(color_.get_red());
+  color.set_green(color_.get_green());
+  color.set_blue(color_.get_blue());
+  on_color_change(color);
+}
+
+void
+ColorPicker::draw()
+{
+  CL_Display::push_modelview();
+  CL_Display::add_translate(get_screen_x(), get_screen_y());
+  
+  float pwidth  = get_width()/11.0;
+  float pheight = get_height()/11.0;
+  CL_Display::fill_rect(CL_Rect(CL_Point(int(pwidth*10), int(pheight*10)),
+                                CL_Size(int(pwidth), int(pheight))),
+                        color);
+
+  CL_Display::pop_modelview();
+}
+
+CL_Signal_v1&lt;CL_Color&gt;&amp;
+ColorPicker::sig_color_change()
+{
+  return on_color_change;
+}
+
+CL_Color
+ColorPicker::get_color()
+{
+  return color;
+}
+
+void
+ColorPicker::set_color(const CL_Color&amp; color_)
+{
+  color = color_;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/colorpicker.cxx
===================================================================
--- trunk/flexlay/lib/colorpicker.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/colorpicker.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,409 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;vector&gt;
-#include &lt;iostream&gt;
-#include &lt;ClanLib/Display/display_iostream.h&gt;
-#include &lt;ClanLib/Display/color.h&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-#include &lt;ClanLib/Display/keys.h&gt;
-#include &lt;ClanLib/Core/Math/rect.h&gt;
-#include &lt;ClanLib/Core/Math/point.h&gt;
-#include &lt;ClanLib/GUI/component.h&gt;
-#include &quot;colorpicker.hxx&quot;
-#include &quot;math.hxx&quot;
-
-class ColorPickerHue : public CL_Component
-{
-public:
-  std::vector&lt;CL_Slot&gt; slots;
-  typedef std::vector&lt;CL_Color&gt; Colors;
-  Colors  colors;
-  bool pressed;
-  CL_Signal_v1&lt;CL_Color&gt; on_color_change;
-  
-  ColorPickerHue(const CL_Rect&amp; rect, CL_Component* parent) 
-    : CL_Component(rect, parent),
-      pressed(false)
-  {
-    colors.push_back(CL_Color(255,   0,   0));
-    colors.push_back(CL_Color(255,   0, 255));
-    colors.push_back(CL_Color(  0,   0, 255));
-    colors.push_back(CL_Color(  0, 255, 255));
-    colors.push_back(CL_Color(  0, 255,   0));
-    colors.push_back(CL_Color(255, 255,   0));
-    colors.push_back(CL_Color(255,   0,   0));
-
-    slots.push_back(sig_paint().connect(this, &amp;ColorPickerHue::draw));
-
-    slots.push_back(sig_mouse_down().connect(this, &amp;ColorPickerHue::on_mouse_down));
-    slots.push_back(sig_mouse_up().connect(this, &amp;ColorPickerHue::on_mouse_up));
-    slots.push_back(sig_mouse_move().connect(this, &amp;ColorPickerHue::on_mouse_move));
-  }
-
-  void update_pointer(const CL_InputEvent&amp; event)
-  {
-    CL_Color new_color; 
-
-    if (event.mouse_pos.y &gt;= get_height() || event.mouse_pos.y &lt; 0)
-      {
-        new_color = colors[0];
-      }
-    else
-      {
-        float factor  = (float(event.mouse_pos.y) / get_height()) * (colors.size()-1);
-        int   prevcol = int(factor);
-        int   nextcol = prevcol+1;
-
-        float val  = factor - prevcol;
-        float ival = 1.0f - val;
-
-
-        if (val &gt;= 0 &amp;&amp; val &lt; 1.0f)
-          {
-            new_color = CL_Color(int(val * colors[nextcol].get_red()   + ival * colors[prevcol].get_red()),
-                                 int(val * colors[nextcol].get_green() + ival * colors[prevcol].get_green()),
-                                 int(val * colors[nextcol].get_blue()  + ival * colors[prevcol].get_blue()),
-                                 int(val * colors[nextcol].get_alpha() + ival * colors[prevcol].get_alpha()));
-          }
-        else
-          {
-            std::cout &lt;&lt; &quot;Out of range&quot; &lt;&lt; std::endl;
-            new_color = colors[0];
-          }
-      }
-    on_color_change(new_color);
-
-    /*
-    std::cout &lt;&lt; new_color.get_red() &lt;&lt; &quot;, &quot;
-              &lt;&lt; new_color.get_green() &lt;&lt; &quot;, &quot;
-              &lt;&lt; new_color.get_blue() &lt;&lt; &quot;, &quot;
-              &lt;&lt; new_color.get_alpha()
-              &lt;&lt; std::endl;*/
-  }
-  
-  void on_mouse_up(const CL_InputEvent&amp; event)
-  {
-    if (event.id == CL_MOUSE_LEFT)
-      {
-        pressed = false;
-        release_mouse();
-        update_pointer(event);
-      }
-  }
-
-  void on_mouse_down(const CL_InputEvent&amp; event)
-  {
-    if (event.id == CL_MOUSE_LEFT)
-      {
-        pressed = true;
-        capture_mouse();
-        update_pointer(event);
-      }  
-  }
-  
-  void on_mouse_move(const CL_InputEvent&amp; event)
-  {
-    if (pressed)
-      {
-        update_pointer(event);
-      }
-  }
-
-  void draw()
-  {
-    CL_Display::push_modelview();
-    CL_Display::add_translate(get_screen_x(), get_screen_y());
-    
-    int psize = get_height()/6;
-    
-    for(Colors::size_type i = 0; i &lt; colors.size()-1; ++i)
-      {
-        CL_Display::fill_rect(CL_Rect(CL_Point(0, i*psize),
-                                      CL_Size(get_width(), psize)),
-                              CL_Gradient(colors[i],
-                                          colors[i],
-                                          colors[i+1],
-                                          colors[i+1]));
-      }
-
-    CL_Display::pop_modelview();    
-  }
-};
-
-class ColorPickerAlpha : public CL_Component
-{
-public:
-  std::vector&lt;CL_Slot&gt; slots;
-  bool pressed;
-  CL_Signal_v1&lt;float&gt; on_color_change;
-  float alpha;
-
-  ColorPickerAlpha(const CL_Rect&amp; rect, CL_Component* parent) 
-    : CL_Component(rect, parent),
-      pressed(false),
-      alpha(0.5f)
-  {
-    slots.push_back(sig_paint().connect(this, &amp;ColorPickerAlpha::draw));
-
-    slots.push_back(sig_mouse_down().connect(this, &amp;ColorPickerAlpha::on_mouse_down));
-    slots.push_back(sig_mouse_up().connect(this, &amp;ColorPickerAlpha::on_mouse_up));
-    slots.push_back(sig_mouse_move().connect(this, &amp;ColorPickerAlpha::on_mouse_move));
-  }
-
-  void set_alpha(float alpha_)
-  {
-    alpha = alpha_;
-    on_color_change(alpha);
-  }  
-
-  void draw()
-  {
-    CL_Display::push_modelview();
-    CL_Display::add_translate(get_screen_x(), get_screen_y());    
-   
-    CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
-                                  CL_Size(get_width(), get_height())),
-                          CL_Gradient(CL_Color(0, 0, 0),
-                                      CL_Color(255, 255, 255),
-                                      CL_Color(0, 0, 0),
-                                      CL_Color(255, 255, 255)));
-
-    CL_Display::pop_modelview();
-  }
-
-  void update_pointer(const CL_InputEvent&amp; event)
-  {
-    alpha = 1.0f - (Math::mid(0.0f, float(event.mouse_pos.x) / get_width(), 1.0f));
-    on_color_change(alpha);
-  }
-
-  void on_mouse_up(const CL_InputEvent&amp; event)
-  {
-    if (event.id == CL_MOUSE_LEFT)
-      {
-        pressed = false;
-        release_mouse();
-        update_pointer(event);
-      }
-  }
-
-  void on_mouse_down(const CL_InputEvent&amp; event)
-  {
-    if (event.id == CL_MOUSE_LEFT)
-      {
-        pressed = true;
-        capture_mouse();
-        update_pointer(event);
-      }
-  }
-
-  void on_mouse_move(const CL_InputEvent&amp; event)
-  {
-    if (pressed)
-      {
-        update_pointer(event);    
-      }
-  }
-};
-
-class ColorPickerBrightness : public CL_Component
-{
-public:
-  std::vector&lt;CL_Slot&gt; slots;
-  CL_Color color;
-  bool pressed;
-  CL_Signal_v1&lt;CL_Color&gt; on_color_change;
-  float factor_x;
-  float factor_y;
-  ColorPickerBrightness(const CL_Rect&amp; rect, CL_Component* parent) 
-    : CL_Component(rect, parent),
-      pressed(false),
-      factor_x(1.0f),
-      factor_y(1.0f)
-  {
-    color = CL_Color(255, 0, 0);
-    slots.push_back(sig_paint().connect(this, &amp;ColorPickerBrightness::draw));
-
-    slots.push_back(sig_mouse_down().connect(this, &amp;ColorPickerBrightness::on_mouse_down));
-    slots.push_back(sig_mouse_up().connect(this, &amp;ColorPickerBrightness::on_mouse_up));
-    slots.push_back(sig_mouse_move().connect(this, &amp;ColorPickerBrightness::on_mouse_move));
-  }
-
-  void draw()
-  {
-    CL_Display::push_modelview();
-    CL_Display::add_translate(get_screen_x(), get_screen_y());
-
-    CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
-                                  CL_Size(get_width(), get_height())),
-                          CL_Gradient(CL_Color(0, 0, 0),
-                                      color,
-                                      CL_Color(0, 0, 0),
-                                      CL_Color(255, 255, 255)));
-
-    CL_Display::draw_line(factor_x * get_width(),
-                          0,
-                          factor_x * get_width(),
-                          get_height(),
-                          CL_Color(255, 255, 255));
-
-    CL_Display::draw_line(0,
-                          factor_y * get_height(),
-                          get_width(),
-                          factor_y * get_height(),
-                          CL_Color(255, 255, 255));
-
-    CL_Display::pop_modelview();
-  }
-
-  void set_color(CL_Color color_) {
-    color = color_;
-    update_color();
-  }
-
-  void update_color()
-  {
-    CL_Color new_color(Math::mid(0, int(factor_x * color.get_red()   * (1.0f - factor_y) + factor_x * 255 * (factor_y)), 255),
-                       Math::mid(0, int(factor_x * color.get_green() * (1.0f - factor_y) + factor_x * 255 * (factor_y)), 255),   
-                       Math::mid(0, int(factor_x * color.get_blue()  * (1.0f - factor_y) + factor_x * 255 * (factor_y)), 255),
-                       color.get_alpha());
-    on_color_change(new_color);
-    /*
-    std::cout &lt;&lt; new_color.get_red() &lt;&lt; &quot;, &quot;
-              &lt;&lt; new_color.get_green() &lt;&lt; &quot;, &quot;
-              &lt;&lt; new_color.get_blue() &lt;&lt; &quot;, &quot;
-              &lt;&lt; new_color.get_alpha()
-              &lt;&lt; std::endl;
-    */
-  }
-
-  void update_pointer(const CL_InputEvent&amp; event)
-  {
-    factor_x = Math::mid(0.0f, float(event.mouse_pos.x)/get_width(), 1.0f);
-    factor_y = Math::mid(0.0f, float(event.mouse_pos.y)/get_height(), 1.0f);
-
-    update_color();
-  }
-
-  void on_mouse_up(const CL_InputEvent&amp; event)
-  {
-    if (event.id == CL_MOUSE_LEFT)
-      {
-        pressed = false;
-        release_mouse();
-        update_pointer(event);
-      }    
-  }
-
-  void on_mouse_down(const CL_InputEvent&amp; event)
-  {
-    if (event.id == CL_MOUSE_LEFT)
-      {
-        pressed = true;
-        capture_mouse();
-        update_pointer(event);
-      }
-  }
-
-  void on_mouse_move(const CL_InputEvent&amp; event)
-  {
-    if (pressed)
-      {
-        update_pointer(event);
-      }
-  }
-};
-
-ColorPicker::ColorPicker(const CL_Rect&amp; rect, CL_Component* parent)
-  : CL_Component(rect, parent)
-{
-  float pwidth  = rect.get_width()/11.0;
-  float pheight = rect.get_height()/11.0;
-
-  brightness = new ColorPickerBrightness(CL_Rect(CL_Point(0, 0),
-                                                 CL_Size(int(pwidth*10), int(pheight*10))), 
-                                         this);
-  
-  hue        = new ColorPickerHue(CL_Rect(CL_Point(int(pwidth*10), 0),
-                                          CL_Size(int(pwidth*1), int(pheight*10))),
-                                  this);
-
-  alpha      = new ColorPickerAlpha(CL_Rect(CL_Point(0, int(pheight*10)),
-                                            CL_Size(int(pwidth*10), int(pheight*1))),
-                                    this);
-
-  slots.push_back(hue-&gt;on_color_change.connect(brightness, &amp;ColorPickerBrightness::set_color));
-  slots.push_back(brightness-&gt;on_color_change.connect(this, &amp;ColorPicker::update_brightness_color));
-  slots.push_back(alpha-&gt;on_color_change.connect(this, &amp;ColorPicker::update_alpha_color));
-  slots.push_back(sig_paint().connect(this, &amp;ColorPicker::draw));
-
-  brightness-&gt;set_color(CL_Color(255, 0, 0));
-  alpha-&gt;set_alpha(0.5f);
-}
-
-void
-ColorPicker::update_alpha_color(float alpha)
-{
-  color.set_alpha(int(255 * alpha));
-  on_color_change(color);  
-}
-
-void
-ColorPicker::update_brightness_color(CL_Color color_)
-{
-  color.set_red(color_.get_red());
-  color.set_green(color_.get_green());
-  color.set_blue(color_.get_blue());
-  on_color_change(color);
-}
-
-void
-ColorPicker::draw()
-{
-  CL_Display::push_modelview();
-  CL_Display::add_translate(get_screen_x(), get_screen_y());
-  
-  float pwidth  = get_width()/11.0;
-  float pheight = get_height()/11.0;
-  CL_Display::fill_rect(CL_Rect(CL_Point(int(pwidth*10), int(pheight*10)),
-                                CL_Size(int(pwidth), int(pheight))),
-                        color);
-
-  CL_Display::pop_modelview();
-}
-
-CL_Signal_v1&lt;CL_Color&gt;&amp;
-ColorPicker::sig_color_change()
-{
-  return on_color_change;
-}
-
-CL_Color
-ColorPicker::get_color()
-{
-  return color;
-}
-
-void
-ColorPicker::set_color(const CL_Color&amp; color_)
-{
-  color = color_;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/colorpicker.hpp (from rev 712, trunk/flexlay/lib/colorpicker.hxx)

Deleted: trunk/flexlay/lib/colorpicker.hxx
===================================================================
--- trunk/flexlay/lib/colorpicker.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/colorpicker.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,59 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_COLORPICKER_HXX
-#define HEADER_COLORPICKER_HXX
-
-#include &lt;ClanLib/Display/display.h&gt;
-#include &lt;ClanLib/Display/color.h&gt;
-#include &lt;ClanLib/Display/gradient.h&gt;
-
-class ColorPickerHue;
-class ColorPickerAlpha;
-class ColorPickerBrightness;
-
-/** */
-class ColorPicker : public CL_Component
-{
-protected:
-  ~ColorPicker() {}
-private:
-  CL_Signal_v1&lt;CL_Color&gt; on_color_change;
-  std::vector&lt;CL_Slot&gt; slots;
-  CL_Color color;
-
-  ColorPickerHue*     hue;
-  ColorPickerBrightness* brightness;
-  ColorPickerAlpha*      alpha;
-
-  void update_brightness_color(CL_Color color);
-  void update_alpha_color(float alpha);
-public:
-  ColorPicker(const CL_Rect&amp; rect, CL_Component* parent);
-  
-  void draw();
-
-  CL_Signal_v1&lt;CL_Color&gt;&amp; sig_color_change();
-
-  CL_Color get_color();
-  void set_color(const CL_Color&amp; color);
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/command.cpp (from rev 712, trunk/flexlay/lib/command.cxx)
===================================================================
--- trunk/flexlay/lib/command.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/command.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,55 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;string&gt;
+#include &quot;command.hpp&quot;
+
+Command::Command()
+{
+}
+
+Command::Command(const SharedPtr&lt;CommandImpl&gt;&amp; impl_)
+  : impl(impl_)
+{
+}
+
+void
+Command::execute()
+{
+  impl-&gt;execute();
+}
+  
+void
+Command::redo()
+{
+  impl-&gt;redo();
+}
+
+void
+Command::undo()
+{
+  impl-&gt;undo();
+}
+
+std::string
+Command::serialize()
+{
+  return impl-&gt;serialize();
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/command.cxx
===================================================================
--- trunk/flexlay/lib/command.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/command.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,55 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;string&gt;
-#include &quot;command.hxx&quot;
-
-Command::Command()
-{
-}
-
-Command::Command(const SharedPtr&lt;CommandImpl&gt;&amp; impl_)
-  : impl(impl_)
-{
-}
-
-void
-Command::execute()
-{
-  impl-&gt;execute();
-}
-  
-void
-Command::redo()
-{
-  impl-&gt;redo();
-}
-
-void
-Command::undo()
-{
-  impl-&gt;undo();
-}
-
-std::string
-Command::serialize()
-{
-  return impl-&gt;serialize();
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/command.hpp (from rev 712, trunk/flexlay/lib/command.hxx)
===================================================================
--- trunk/flexlay/lib/command.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/command.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,55 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_COMMAND_HXX
+#define HEADER_COMMAND_HXX
+
+#include &lt;iosfwd&gt;
+#include &quot;shared_ptr.hpp&quot;
+#include &quot;command_impl.hpp&quot;
+
+/** Command is an abstract base class for all data manipulating
+    operations on EditorLayer or even EditorMap metedata. Each Command
+    that manipulates data must provide a way to undo and redo the
+    operations. */
+class Command
+{
+private:
+public:
+  Command();
+  Command(const SharedPtr&lt;CommandImpl&gt;&amp; impl_);
+
+  /** Execute the command */
+  void execute();
+  
+  /** Execute the command a second time after the command got
+      undo'ed */
+  void redo();
+
+  /** Undo the effects caused by execute() */
+  void undo();
+
+  std::string serialize();
+
+private:
+  SharedPtr&lt;CommandImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/command.hxx
===================================================================
--- trunk/flexlay/lib/command.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/command.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,55 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_COMMAND_HXX
-#define HEADER_COMMAND_HXX
-
-#include &lt;iosfwd&gt;
-#include &quot;shared_ptr.hxx&quot;
-#include &quot;command_impl.hxx&quot;
-
-/** Command is an abstract base class for all data manipulating
-    operations on EditorLayer or even EditorMap metedata. Each Command
-    that manipulates data must provide a way to undo and redo the
-    operations. */
-class Command
-{
-private:
-public:
-  Command();
-  Command(const SharedPtr&lt;CommandImpl&gt;&amp; impl_);
-
-  /** Execute the command */
-  void execute();
-  
-  /** Execute the command a second time after the command got
-      undo'ed */
-  void redo();
-
-  /** Undo the effects caused by execute() */
-  void undo();
-
-  std::string serialize();
-
-private:
-  SharedPtr&lt;CommandImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/command_group.cpp (from rev 712, trunk/flexlay/lib/command_group.cxx)
===================================================================
--- trunk/flexlay/lib/command_group.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/command_group.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,62 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &quot;command_group.hpp&quot;
+
+class CommandGroupImpl : public CommandImpl
+{
+public:
+};
+
+CommandGroup::CommandGroup()
+{
+  
+}
+
+CommandGroup::~CommandGroup()
+{
+}
+  
+void
+CommandGroup::add_command(Command* c)
+{
+  commands.push_back(c);
+}
+
+void
+CommandGroup::execute()
+{
+  for(Commands::iterator i = commands.begin(); i != commands.end(); ++i)
+    (*i)-&gt;execute();    
+}
+
+void
+CommandGroup::undo()
+{
+  for(Commands::iterator i = commands.begin(); i != commands.end(); ++i)
+    (*i)-&gt;undo();
+}
+
+void
+CommandGroup::redo()
+{
+  for(Commands::iterator i = commands.begin(); i != commands.end(); ++i)
+    (*i)-&gt;redo();
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/command_group.cxx
===================================================================
--- trunk/flexlay/lib/command_group.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/command_group.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,62 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &quot;command_group.hxx&quot;
-
-class CommandGroupImpl : public CommandImpl
-{
-public:
-};
-
-CommandGroup::CommandGroup()
-{
-  
-}
-
-CommandGroup::~CommandGroup()
-{
-}
-  
-void
-CommandGroup::add_command(Command* c)
-{
-  commands.push_back(c);
-}
-
-void
-CommandGroup::execute()
-{
-  for(Commands::iterator i = commands.begin(); i != commands.end(); ++i)
-    (*i)-&gt;execute();    
-}
-
-void
-CommandGroup::undo()
-{
-  for(Commands::iterator i = commands.begin(); i != commands.end(); ++i)
-    (*i)-&gt;undo();
-}
-
-void
-CommandGroup::redo()
-{
-  for(Commands::iterator i = commands.begin(); i != commands.end(); ++i)
-    (*i)-&gt;redo();
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/command_group.hpp (from rev 712, trunk/flexlay/lib/command_group.hxx)
===================================================================
--- trunk/flexlay/lib/command_group.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/command_group.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,44 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_COMMAND_GROUP_HXX
+#define HEADER_COMMAND_GROUP_HXX
+
+#include &lt;vector&gt;
+#include &quot;command.hpp&quot;
+
+/** */
+class CommandGroup
+{
+private:
+  typedef std::vector&lt;Command*&gt; Commands;
+  Commands commands;
+public:
+  CommandGroup();
+  virtual ~CommandGroup();
+
+  void add_command(Command* c);
+  
+  void execute();
+  void undo();
+  void redo();
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/command_group.hxx
===================================================================
--- trunk/flexlay/lib/command_group.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/command_group.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,44 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_COMMAND_GROUP_HXX
-#define HEADER_COMMAND_GROUP_HXX
-
-#include &lt;vector&gt;
-#include &quot;command.hxx&quot;
-
-/** */
-class CommandGroup
-{
-private:
-  typedef std::vector&lt;Command*&gt; Commands;
-  Commands commands;
-public:
-  CommandGroup();
-  virtual ~CommandGroup();
-
-  void add_command(Command* c);
-  
-  void execute();
-  void undo();
-  void redo();
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/command_impl.hpp (from rev 712, trunk/flexlay/lib/command_impl.hxx)

Deleted: trunk/flexlay/lib/command_impl.hxx
===================================================================
--- trunk/flexlay/lib/command_impl.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/command_impl.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,43 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-#ifndef HEADER_COMMAND_IMPL_HXX
-#define HEADER_COMMAND_IMPL_HXX
-
-/** */
-class CommandImpl
-{
-private:
-public:
-  virtual ~CommandImpl() {}
-
-  /** Execute the command */
-  virtual void execute() =0;
-
-  /** Execute the command a second time after the command got
-      undo'ed */
-  virtual void redo() =0;
-
-  /** Undo the effects caused by execute() */
-  virtual void undo() =0;
-
-  virtual std::string serialize() =0;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/console.cpp (from rev 712, trunk/flexlay/lib/console.cxx)
===================================================================
--- trunk/flexlay/lib/console.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/console.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,127 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &lt;ClanLib/Display/font.h&gt;
+#include &quot;fonts.hpp&quot;
+#include &quot;field.hpp&quot;
+#include &quot;console.hpp&quot;
+
+class ConsoleImpl
+{
+public:
+  std::vector&lt;CL_Slot&gt; slots;
+
+  CL_Size size;
+
+  /** Complete log of everything that got written to the console */
+  std::string full_buffer;
+
+  /** Buffer of the stuff currently visible on the screen */
+  Field&lt;char&gt; screen;
+
+  CL_Point cursor_pos;
+
+  CL_Font font;
+
+  ConsoleImpl(int w, int h);
+  void putchar(char c);
+  void draw();
+};
+
+ConsoleImpl::ConsoleImpl(int w, int h)
+  : size(w, h),
+    screen(w, h),
+    cursor_pos(0, 0)
+{
+}
+
+void
+ConsoleImpl::draw()
+{
+  //std::cout &lt;&lt; &quot;ConsoleImpl::draw()&quot; &lt;&lt; std::endl;
+
+  int font_w = font.get_width(&quot;W&quot;);
+  int font_h = font.get_height();
+
+  for(int y = 0; y &lt; size.height; ++y)
+    for(int x = 0; x &lt; size.width; ++x)
+      {
+        font.draw_character(x * font_w, y * font_h, screen.at(x, y));
+      }
+}
+
+Console::Console(/*const CL_Font&amp; font,*/ const CL_Rect&amp; rect, CL_Component* parent)
+  : CL_Component(rect, parent),
+    impl(new ConsoleImpl(40, 24))
+{
+  impl-&gt;font = Fonts::verdana11_yellow;
+  impl-&gt;slots.push_back(sig_paint().connect(impl.get(), &amp;ConsoleImpl::draw));
+}
+
+Console::~Console()
+{
+  
+}
+
+void
+Console::clearscr()
+{
+  for(int y = 0; y &lt; impl-&gt;size.height; ++y)
+    for(int x = 0; x &lt; impl-&gt;size.width; ++x)
+      impl-&gt;screen.at(x, y) = 0;
+}
+
+void
+ConsoleImpl::putchar(char c)
+{
+  full_buffer += c; 
+
+  if (c == '\n')
+    {
+      cursor_pos.x = 0;
+      cursor_pos.y += 1;
+    }
+  else
+    {
+      screen.at(cursor_pos.x, cursor_pos.y) = c;
+
+      cursor_pos.x += 1;
+
+      if (cursor_pos.x &gt;= size.width)
+        cursor_pos.x = 0;
+    }
+
+  // Move all content one line up
+  if (cursor_pos.y &gt;= size.height)
+    screen.resize(size.width, size.height, 0, -1);
+}
+
+void
+Console::write(const std::string&amp; str)
+{
+  std::cout &lt;&lt; str &lt;&lt; std::flush;
+
+  for(std::string::const_iterator i = str.begin(); i != str.end(); ++i)
+    {
+      if (*i != 0)
+        impl-&gt;putchar(*i);
+    }
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/console.cxx
===================================================================
--- trunk/flexlay/lib/console.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/console.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,127 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &lt;ClanLib/Display/font.h&gt;
-#include &quot;fonts.hxx&quot;
-#include &quot;field.hxx&quot;
-#include &quot;console.hxx&quot;
-
-class ConsoleImpl
-{
-public:
-  std::vector&lt;CL_Slot&gt; slots;
-
-  CL_Size size;
-
-  /** Complete log of everything that got written to the console */
-  std::string full_buffer;
-
-  /** Buffer of the stuff currently visible on the screen */
-  Field&lt;char&gt; screen;
-
-  CL_Point cursor_pos;
-
-  CL_Font font;
-
-  ConsoleImpl(int w, int h);
-  void putchar(char c);
-  void draw();
-};
-
-ConsoleImpl::ConsoleImpl(int w, int h)
-  : size(w, h),
-    screen(w, h),
-    cursor_pos(0, 0)
-{
-}
-
-void
-ConsoleImpl::draw()
-{
-  //std::cout &lt;&lt; &quot;ConsoleImpl::draw()&quot; &lt;&lt; std::endl;
-
-  int font_w = font.get_width(&quot;W&quot;);
-  int font_h = font.get_height();
-
-  for(int y = 0; y &lt; size.height; ++y)
-    for(int x = 0; x &lt; size.width; ++x)
-      {
-        font.draw_character(x * font_w, y * font_h, screen.at(x, y));
-      }
-}
-
-Console::Console(/*const CL_Font&amp; font,*/ const CL_Rect&amp; rect, CL_Component* parent)
-  : CL_Component(rect, parent),
-    impl(new ConsoleImpl(40, 24))
-{
-  impl-&gt;font = Fonts::verdana11_yellow;
-  impl-&gt;slots.push_back(sig_paint().connect(impl.get(), &amp;ConsoleImpl::draw));
-}
-
-Console::~Console()
-{
-  
-}
-
-void
-Console::clearscr()
-{
-  for(int y = 0; y &lt; impl-&gt;size.height; ++y)
-    for(int x = 0; x &lt; impl-&gt;size.width; ++x)
-      impl-&gt;screen.at(x, y) = 0;
-}
-
-void
-ConsoleImpl::putchar(char c)
-{
-  full_buffer += c; 
-
-  if (c == '\n')
-    {
-      cursor_pos.x = 0;
-      cursor_pos.y += 1;
-    }
-  else
-    {
-      screen.at(cursor_pos.x, cursor_pos.y) = c;
-
-      cursor_pos.x += 1;
-
-      if (cursor_pos.x &gt;= size.width)
-        cursor_pos.x = 0;
-    }
-
-  // Move all content one line up
-  if (cursor_pos.y &gt;= size.height)
-    screen.resize(size.width, size.height, 0, -1);
-}
-
-void
-Console::write(const std::string&amp; str)
-{
-  std::cout &lt;&lt; str &lt;&lt; std::flush;
-
-  for(std::string::const_iterator i = str.begin(); i != str.end(); ++i)
-    {
-      if (*i != 0)
-        impl-&gt;putchar(*i);
-    }
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/console.hpp (from rev 712, trunk/flexlay/lib/console.hxx)
===================================================================
--- trunk/flexlay/lib/console.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/console.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,46 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_CONSOLE_HXX
+#define HEADER_CONSOLE_HXX
+
+#include &lt;ClanLib/GUI/component.h&gt;
+#include &quot;shared_ptr.hpp&quot;
+
+class CL_Font;
+class CL_Size;
+class ConsoleImpl;
+
+/** */
+class Console : public CL_Component
+{
+protected:
+  virtual ~Console();
+public:
+  Console(/*const CL_Font&amp; font, */const CL_Rect&amp; rect, CL_Component* parent);
+
+  /** Write something to the console */
+  void write(const std::string&amp; );
+  void clearscr();
+private:
+  SharedPtr&lt;ConsoleImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/console.hxx
===================================================================
--- trunk/flexlay/lib/console.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/console.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,46 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_CONSOLE_HXX
-#define HEADER_CONSOLE_HXX
-
-#include &lt;ClanLib/GUI/component.h&gt;
-#include &quot;shared_ptr.hxx&quot;
-
-class CL_Font;
-class CL_Size;
-class ConsoleImpl;
-
-/** */
-class Console : public CL_Component
-{
-protected:
-  virtual ~Console();
-public:
-  Console(/*const CL_Font&amp; font, */const CL_Rect&amp; rect, CL_Component* parent);
-
-  /** Write something to the console */
-  void write(const std::string&amp; );
-  void clearscr();
-private:
-  SharedPtr&lt;ConsoleImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/directory_view.cpp (from rev 712, trunk/flexlay/lib/directory_view.cxx)
===================================================================
--- trunk/flexlay/lib/directory_view.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/directory_view.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,209 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;assert.h&gt;
+#include &lt;ClanLib/Core/Math/rect.h&gt;
+#include &lt;ClanLib/Core/IOData/directory_scanner.h&gt;
+#include &lt;ClanLib/Display/font.h&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &quot;fonts.hpp&quot;
+#include &quot;directory_view.hpp&quot;
+
+class DirectoryViewEntry
+{
+public:
+  std::string name;
+  bool directory;
+  bool hidden;
+};
+
+struct DirectoryViewSorter
+{
+  bool operator()(const DirectoryViewEntry&amp; lhs, const DirectoryViewEntry&amp; rhs)
+  {
+    if (lhs.directory &gt; rhs.directory)
+      return true;
+    else if (lhs.directory &lt; rhs.directory)
+      return false;
+    else
+      return lhs.name &lt; rhs.name;
+  }
+};
+
+class DirectoryViewImpl
+{
+public:
+  DirectoryView* parent;
+
+  std::vector&lt;CL_Slot&gt; slots;
+
+  std::string path;
+  CL_Signal_v1&lt;std::string&gt; sig_on_click;
+  typedef std::vector&lt;DirectoryViewEntry&gt; Items;
+  Items items;
+  int current_item;
+  int column_width;
+  int num_columns;
+
+  void update_items();
+  void draw();
+  int get_item(const CL_Point&amp; pos);
+  void on_mouse_move(const CL_InputEvent&amp; event);
+  void on_mouse_down(const CL_InputEvent&amp; event);
+};
+
+DirectoryView::DirectoryView(const CL_Rect&amp; rect, CL_Component* parent)
+  : CL_Component(rect, parent),
+    impl(new DirectoryViewImpl())
+{ 
+  impl-&gt;parent = this;
+
+  //  impl-&gt;slots.push_back(sig_mouse_down().connect(impl.get(), &amp;DirectoryViewImpl::draw));
+  impl-&gt;slots.push_back(sig_paint().connect(impl.get(), &amp;DirectoryViewImpl::draw));
+  impl-&gt;slots.push_back(sig_mouse_move().connect(impl.get(), &amp;DirectoryViewImpl::on_mouse_move));
+  impl-&gt;slots.push_back(sig_mouse_down().connect(impl.get(), &amp;DirectoryViewImpl::on_mouse_down));
+
+  impl-&gt;current_item = -1;
+}
+
+DirectoryView::~DirectoryView()
+{
+}
+
+void
+DirectoryView::set_directory(const std::string&amp; path_)
+{
+  impl-&gt;path = path_;
+  impl-&gt;update_items();
+}
+
+CL_Signal_v1&lt;std::string&gt;&amp;
+DirectoryView::sig_on_click()
+{
+  return impl-&gt;sig_on_click;
+}
+
+void 
+DirectoryViewImpl::draw()
+{
+  CL_Font font = Fonts::verdana11; 
+
+  int horizontal_spacing = 10;
+  int vertical_spacing   = 5;
+  int x_pos = 0;
+  int y_pos = 0;
+
+  CL_Display::clear(CL_Color(255, 255, 0));
+
+  int j = 0;
+  for(Items::iterator i = items.begin(); i != items.begin()+50 &amp;&amp; i != items.end(); ++i)
+    {
+      if (current_item &amp;&amp; current_item &lt; int(items.size()) &amp;&amp; j == current_item)
+        {
+          CL_Rect rect = font.bounding_rect(x_pos * (column_width + horizontal_spacing) + 1, 
+                                            y_pos * (font.get_height() + vertical_spacing) + 1,
+                                            i-&gt;name);
+          CL_Display::fill_rect(CL_Rect(rect.left-5, rect.top-3,
+                                        rect.left+5+column_width, rect.bottom+3),
+                                CL_Color(250, 200, 0));
+        }
+
+      // draw item
+      if (!i-&gt;directory)
+        {
+          font.draw(x_pos * (column_width + horizontal_spacing), 
+                    y_pos * (font.get_height() + vertical_spacing),
+                    i-&gt;name);
+        }
+      else
+        {
+          font.draw(x_pos * (column_width + horizontal_spacing), 
+                    y_pos * (font.get_height() + vertical_spacing),
+                    &quot;[&quot; + i-&gt;name + &quot;]&quot;);
+        }
+
+      x_pos += 1;
+      if (x_pos &gt;= num_columns)
+        {
+          x_pos = 0;
+          y_pos += 1;
+        }
+      ++j;
+    }
+}
+
+int
+DirectoryViewImpl::get_item(const CL_Point&amp; pos)
+{
+  CL_Font font = Fonts::verdana11; 
+
+  int horizontal_spacing = 10;
+  int vertical_spacing   = 5;
+
+  return (pos.x / (column_width + horizontal_spacing))
+    + num_columns * (pos.y / (font.get_height() + vertical_spacing));    
+}
+
+void 
+DirectoryViewImpl::on_mouse_down(const CL_InputEvent&amp; event)
+{
+  current_item = get_item(event.mouse_pos);
+  if (current_item &gt;= 0 &amp;&amp; current_item &lt; int(items.size()))
+    {
+      if (items[current_item].directory)
+      parent-&gt;set_directory(path + &quot;/&quot; + items[current_item].name);
+    }
+}
+
+void 
+DirectoryViewImpl::on_mouse_move(const CL_InputEvent&amp; event)
+{
+  current_item = get_item(event.mouse_pos);
+}
+
+void
+DirectoryViewImpl::update_items()
+{
+  items.clear();
+  CL_DirectoryScanner scanner;
+
+  scanner.scan(path);
+  while(scanner.next())
+    {
+      DirectoryViewEntry entry;
+      entry.name = scanner.get_name();
+      entry.hidden = (scanner.get_name()[0] == '.');
+      entry.directory = scanner.is_directory();
+      items.push_back(entry);
+    }
+
+  std::sort(items.begin(), items.end(), DirectoryViewSorter());
+
+  CL_Font font = Fonts::verdana11; 
+
+  column_width = 60; // min_colum_width
+  for(Items::iterator i = items.begin(); i != items.end(); ++i)
+    {
+      CL_Rect rect = font.bounding_rect(0, 0, i-&gt;name + &quot;[]&quot;);
+      column_width = std::max(column_width, rect.get_width());
+    }
+
+  num_columns = parent-&gt;get_width()/column_width;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/directory_view.cxx
===================================================================
--- trunk/flexlay/lib/directory_view.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/directory_view.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,209 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;assert.h&gt;
-#include &lt;ClanLib/Core/Math/rect.h&gt;
-#include &lt;ClanLib/Core/IOData/directory_scanner.h&gt;
-#include &lt;ClanLib/Display/font.h&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-#include &quot;fonts.hxx&quot;
-#include &quot;directory_view.hxx&quot;
-
-class DirectoryViewEntry
-{
-public:
-  std::string name;
-  bool directory;
-  bool hidden;
-};
-
-struct DirectoryViewSorter
-{
-  bool operator()(const DirectoryViewEntry&amp; lhs, const DirectoryViewEntry&amp; rhs)
-  {
-    if (lhs.directory &gt; rhs.directory)
-      return true;
-    else if (lhs.directory &lt; rhs.directory)
-      return false;
-    else
-      return lhs.name &lt; rhs.name;
-  }
-};
-
-class DirectoryViewImpl
-{
-public:
-  DirectoryView* parent;
-
-  std::vector&lt;CL_Slot&gt; slots;
-
-  std::string path;
-  CL_Signal_v1&lt;std::string&gt; sig_on_click;
-  typedef std::vector&lt;DirectoryViewEntry&gt; Items;
-  Items items;
-  int current_item;
-  int column_width;
-  int num_columns;
-
-  void update_items();
-  void draw();
-  int get_item(const CL_Point&amp; pos);
-  void on_mouse_move(const CL_InputEvent&amp; event);
-  void on_mouse_down(const CL_InputEvent&amp; event);
-};
-
-DirectoryView::DirectoryView(const CL_Rect&amp; rect, CL_Component* parent)
-  : CL_Component(rect, parent),
-    impl(new DirectoryViewImpl())
-{ 
-  impl-&gt;parent = this;
-
-  //  impl-&gt;slots.push_back(sig_mouse_down().connect(impl.get(), &amp;DirectoryViewImpl::draw));
-  impl-&gt;slots.push_back(sig_paint().connect(impl.get(), &amp;DirectoryViewImpl::draw));
-  impl-&gt;slots.push_back(sig_mouse_move().connect(impl.get(), &amp;DirectoryViewImpl::on_mouse_move));
-  impl-&gt;slots.push_back(sig_mouse_down().connect(impl.get(), &amp;DirectoryViewImpl::on_mouse_down));
-
-  impl-&gt;current_item = -1;
-}
-
-DirectoryView::~DirectoryView()
-{
-}
-
-void
-DirectoryView::set_directory(const std::string&amp; path_)
-{
-  impl-&gt;path = path_;
-  impl-&gt;update_items();
-}
-
-CL_Signal_v1&lt;std::string&gt;&amp;
-DirectoryView::sig_on_click()
-{
-  return impl-&gt;sig_on_click;
-}
-
-void 
-DirectoryViewImpl::draw()
-{
-  CL_Font font = Fonts::verdana11; 
-
-  int horizontal_spacing = 10;
-  int vertical_spacing   = 5;
-  int x_pos = 0;
-  int y_pos = 0;
-
-  CL_Display::clear(CL_Color(255, 255, 0));
-
-  int j = 0;
-  for(Items::iterator i = items.begin(); i != items.begin()+50 &amp;&amp; i != items.end(); ++i)
-    {
-      if (current_item &amp;&amp; current_item &lt; int(items.size()) &amp;&amp; j == current_item)
-        {
-          CL_Rect rect = font.bounding_rect(x_pos * (column_width + horizontal_spacing) + 1, 
-                                            y_pos * (font.get_height() + vertical_spacing) + 1,
-                                            i-&gt;name);
-          CL_Display::fill_rect(CL_Rect(rect.left-5, rect.top-3,
-                                        rect.left+5+column_width, rect.bottom+3),
-                                CL_Color(250, 200, 0));
-        }
-
-      // draw item
-      if (!i-&gt;directory)
-        {
-          font.draw(x_pos * (column_width + horizontal_spacing), 
-                    y_pos * (font.get_height() + vertical_spacing),
-                    i-&gt;name);
-        }
-      else
-        {
-          font.draw(x_pos * (column_width + horizontal_spacing), 
-                    y_pos * (font.get_height() + vertical_spacing),
-                    &quot;[&quot; + i-&gt;name + &quot;]&quot;);
-        }
-
-      x_pos += 1;
-      if (x_pos &gt;= num_columns)
-        {
-          x_pos = 0;
-          y_pos += 1;
-        }
-      ++j;
-    }
-}
-
-int
-DirectoryViewImpl::get_item(const CL_Point&amp; pos)
-{
-  CL_Font font = Fonts::verdana11; 
-
-  int horizontal_spacing = 10;
-  int vertical_spacing   = 5;
-
-  return (pos.x / (column_width + horizontal_spacing))
-    + num_columns * (pos.y / (font.get_height() + vertical_spacing));    
-}
-
-void 
-DirectoryViewImpl::on_mouse_down(const CL_InputEvent&amp; event)
-{
-  current_item = get_item(event.mouse_pos);
-  if (current_item &gt;= 0 &amp;&amp; current_item &lt; int(items.size()))
-    {
-      if (items[current_item].directory)
-      parent-&gt;set_directory(path + &quot;/&quot; + items[current_item].name);
-    }
-}
-
-void 
-DirectoryViewImpl::on_mouse_move(const CL_InputEvent&amp; event)
-{
-  current_item = get_item(event.mouse_pos);
-}
-
-void
-DirectoryViewImpl::update_items()
-{
-  items.clear();
-  CL_DirectoryScanner scanner;
-
-  scanner.scan(path);
-  while(scanner.next())
-    {
-      DirectoryViewEntry entry;
-      entry.name = scanner.get_name();
-      entry.hidden = (scanner.get_name()[0] == '.');
-      entry.directory = scanner.is_directory();
-      items.push_back(entry);
-    }
-
-  std::sort(items.begin(), items.end(), DirectoryViewSorter());
-
-  CL_Font font = Fonts::verdana11; 
-
-  column_width = 60; // min_colum_width
-  for(Items::iterator i = items.begin(); i != items.end(); ++i)
-    {
-      CL_Rect rect = font.bounding_rect(0, 0, i-&gt;name + &quot;[]&quot;);
-      column_width = std::max(column_width, rect.get_width());
-    }
-
-  num_columns = parent-&gt;get_width()/column_width;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/directory_view.hpp (from rev 712, trunk/flexlay/lib/directory_view.hxx)
===================================================================
--- trunk/flexlay/lib/directory_view.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/directory_view.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,48 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_DIRECTORY_VIEW_HXX
+#define HEADER_DIRECTORY_VIEW_HXX
+
+#include &lt;ClanLib/GUI/component.h&gt;
+#include &quot;shared_ptr.hpp&quot;
+
+class DirectoryViewImpl;
+
+/** */
+class DirectoryView : public CL_Component
+{
+private:
+protected:
+  virtual ~DirectoryView();
+public:
+  DirectoryView(const CL_Rect&amp; rect, CL_Component* parent);
+
+  /** Set the directory which should be shown */
+  void set_directory(const std::string&amp; path_);
+
+  /** Call the callback on click on a directory item */
+  CL_Signal_v1&lt;std::string&gt;&amp; sig_on_click();
+
+private:
+  SharedPtr&lt;DirectoryViewImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/directory_view.hxx
===================================================================
--- trunk/flexlay/lib/directory_view.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/directory_view.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,48 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_DIRECTORY_VIEW_HXX
-#define HEADER_DIRECTORY_VIEW_HXX
-
-#include &lt;ClanLib/GUI/component.h&gt;
-#include &quot;shared_ptr.hxx&quot;
-
-class DirectoryViewImpl;
-
-/** */
-class DirectoryView : public CL_Component
-{
-private:
-protected:
-  virtual ~DirectoryView();
-public:
-  DirectoryView(const CL_Rect&amp; rect, CL_Component* parent);
-
-  /** Set the directory which should be shown */
-  void set_directory(const std::string&amp; path_);
-
-  /** Call the callback on click on a directory item */
-  CL_Signal_v1&lt;std::string&gt;&amp; sig_on_click();
-
-private:
-  SharedPtr&lt;DirectoryViewImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/drawer_properties.cpp (from rev 712, trunk/flexlay/lib/drawer_properties.cxx)
===================================================================
--- trunk/flexlay/lib/drawer_properties.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/drawer_properties.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,99 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &quot;drawer_properties.hpp&quot;
+
+DrawerProperties* DrawerProperties::current_ = 0;
+
+class DrawerPropertiesImpl
+{
+public:
+  CL_Color  color;
+  float     base_size;
+  float     spacing;
+  Brush     brush;
+};
+
+DrawerProperties*
+DrawerProperties::current()
+{
+  if (!current_)
+    return (current_ = new DrawerProperties());
+  else
+    return current_;
+}
+
+DrawerProperties::DrawerProperties()
+  : impl(new DrawerPropertiesImpl())
+{
+  impl-&gt;color     = CL_Color(255, 255, 255, 255);
+  impl-&gt;base_size = 1.0f;
+    
+  impl-&gt;base_size = 1.0f;
+  impl-&gt;spacing   = 15.0f;
+}
+
+void
+DrawerProperties::set_spacing(float spacing_)
+{
+  impl-&gt;spacing = spacing_;
+}
+
+float
+DrawerProperties::get_spacing() const
+{
+  return impl-&gt;spacing;
+}
+
+void
+DrawerProperties::set_size(float s)
+{
+  impl-&gt;base_size = s;
+}
+
+float
+DrawerProperties::get_size() const
+{
+  return impl-&gt;base_size;
+}
+
+void
+DrawerProperties::set_color(const CL_Color&amp; color_)
+{
+  impl-&gt;color = color_;
+}
+
+CL_Color
+DrawerProperties::get_color() const
+{
+  return impl-&gt;color;
+}
+
+void
+DrawerProperties::set_brush(const Brush&amp; brush)
+{
+  impl-&gt;brush = brush;
+}
+
+Brush
+DrawerProperties::get_brush() const
+{
+  return impl-&gt;brush;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/drawer_properties.cxx
===================================================================
--- trunk/flexlay/lib/drawer_properties.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/drawer_properties.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,99 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &quot;drawer_properties.hxx&quot;
-
-DrawerProperties* DrawerProperties::current_ = 0;
-
-class DrawerPropertiesImpl
-{
-public:
-  CL_Color  color;
-  float     base_size;
-  float     spacing;
-  Brush     brush;
-};
-
-DrawerProperties*
-DrawerProperties::current()
-{
-  if (!current_)
-    return (current_ = new DrawerProperties());
-  else
-    return current_;
-}
-
-DrawerProperties::DrawerProperties()
-  : impl(new DrawerPropertiesImpl())
-{
-  impl-&gt;color     = CL_Color(255, 255, 255, 255);
-  impl-&gt;base_size = 1.0f;
-    
-  impl-&gt;base_size = 1.0f;
-  impl-&gt;spacing   = 15.0f;
-}
-
-void
-DrawerProperties::set_spacing(float spacing_)
-{
-  impl-&gt;spacing = spacing_;
-}
-
-float
-DrawerProperties::get_spacing() const
-{
-  return impl-&gt;spacing;
-}
-
-void
-DrawerProperties::set_size(float s)
-{
-  impl-&gt;base_size = s;
-}
-
-float
-DrawerProperties::get_size() const
-{
-  return impl-&gt;base_size;
-}
-
-void
-DrawerProperties::set_color(const CL_Color&amp; color_)
-{
-  impl-&gt;color = color_;
-}
-
-CL_Color
-DrawerProperties::get_color() const
-{
-  return impl-&gt;color;
-}
-
-void
-DrawerProperties::set_brush(const Brush&amp; brush)
-{
-  impl-&gt;brush = brush;
-}
-
-Brush
-DrawerProperties::get_brush() const
-{
-  return impl-&gt;brush;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/drawer_properties.hpp (from rev 712, trunk/flexlay/lib/drawer_properties.hxx)
===================================================================
--- trunk/flexlay/lib/drawer_properties.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/drawer_properties.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,64 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_DRAWER_PROPERTIES_HXX
+#define HEADER_DRAWER_PROPERTIES_HXX
+
+#include &lt;ClanLib/Display/color.h&gt;
+#include &quot;brush.hpp&quot;
+
+class DrawerPropertiesImpl;
+
+/** */
+class DrawerProperties
+{
+private:
+  static DrawerProperties* current_;
+public:
+  static DrawerProperties* current();
+
+  DrawerProperties();
+
+  /** Set the spacing that will be between the sprites that are drawn
+      along the dabs */
+  void  set_spacing(float spacing);
+  float get_spacing() const;
+
+  /** Set the base size of the Sprite, the real size itself can be
+      affected by pressure and is than calculated by combining
+      basesize and pressure or tilting */
+  void  set_size(float s);
+  float get_size() const;
+
+  /** Set the base color, the real color itself is calculated from
+      combining the base color with the current pressure or tilting */
+  void     set_color(const CL_Color&amp; color);
+  CL_Color get_color() const;
+
+  /** Set the brush to be used, its color and size settings are
+      ignored */
+  void  set_brush(const Brush&amp; brush);
+  Brush get_brush() const;
+
+private:
+  SharedPtr&lt;DrawerPropertiesImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/drawer_properties.hxx
===================================================================
--- trunk/flexlay/lib/drawer_properties.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/drawer_properties.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,64 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_DRAWER_PROPERTIES_HXX
-#define HEADER_DRAWER_PROPERTIES_HXX
-
-#include &lt;ClanLib/Display/color.h&gt;
-#include &quot;brush.hxx&quot;
-
-class DrawerPropertiesImpl;
-
-/** */
-class DrawerProperties
-{
-private:
-  static DrawerProperties* current_;
-public:
-  static DrawerProperties* current();
-
-  DrawerProperties();
-
-  /** Set the spacing that will be between the sprites that are drawn
-      along the dabs */
-  void  set_spacing(float spacing);
-  float get_spacing() const;
-
-  /** Set the base size of the Sprite, the real size itself can be
-      affected by pressure and is than calculated by combining
-      basesize and pressure or tilting */
-  void  set_size(float s);
-  float get_size() const;
-
-  /** Set the base color, the real color itself is calculated from
-      combining the base color with the current pressure or tilting */
-  void     set_color(const CL_Color&amp; color);
-  CL_Color get_color() const;
-
-  /** Set the brush to be used, its color and size settings are
-      ignored */
-  void  set_brush(const Brush&amp; brush);
-  Brush get_brush() const;
-
-private:
-  SharedPtr&lt;DrawerPropertiesImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/editor_map.cpp (from rev 712, trunk/flexlay/lib/editor_map.cxx)
===================================================================
--- trunk/flexlay/lib/editor_map.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/editor_map.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,281 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &lt;assert.h&gt;
+#include &lt;ClanLib/Core/core_iostream.h&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &lt;ClanLib/Display/keys.h&gt;
+#include &quot;editor_names.hpp&quot;
+#include &quot;editor_map.hpp&quot;
+#include &quot;editor_map_component.hpp&quot;
+
+class EditorMapImpl
+{
+public:
+  /** Flag if the map got modified, used for 'Some maps are unsaved'
+      style massages */
+  bool modified;
+
+  /** Gets incremented with each map change so that other component
+      can update if required */
+  int serial;
+
+  typedef std::vector&lt;Layer&gt; Layers;
+  Layers layers;
+
+  CL_Color background_color;
+  CL_Color foreground_color;
+
+  /** Metadata attached to this map (ie. mapname, description, scripts, etc.) */
+  MetaData metadata;
+
+  typedef std::vector&lt;Command&gt; Commands;
+
+  Commands undo_stack;
+  Commands redo_stack;
+
+  CL_Signal_v0 on_change;
+
+  bool    has_bounding_rect;
+  CL_Rect bounding_rect;
+};
+
+EditorMap::EditorMap(bool create)
+  : impl(0)
+{
+  if (create)
+    {
+      impl = new EditorMapImpl();
+      impl-&gt;background_color = CL_Color(100, 80, 100);
+      impl-&gt;foreground_color = CL_Color(255, 80, 255);
+      impl-&gt;modified = false;
+      impl-&gt;serial = 0;
+      impl-&gt;has_bounding_rect = false;
+      impl-&gt;bounding_rect = CL_Rect(0,0,0,0);
+    }
+}
+
+void
+EditorMap::add_layer(const Layer&amp; layer, int pos)
+{
+  std::cout &lt;&lt; impl &lt;&lt; &quot; EditorMap::add_layer&quot; &lt;&lt; std::endl;
+
+  assert(pos == -1 || (pos &gt;= 0 &amp;&amp; pos &lt; int(impl-&gt;layers.size())));
+
+  if (pos == -1) // insert at last pos
+    impl-&gt;layers.push_back(layer);
+  else
+    impl-&gt;layers.insert(impl-&gt;layers.begin() + pos, layer);
+
+  impl-&gt;serial += 1;
+}
+
+void 
+EditorMap::draw_gui(CL_GraphicContext* gc)
+{
+  CL_Rect rect = get_bounding_rect();
+
+  if (rect != CL_Rect(0,0,0,0))
+    {
+      gc-&gt;fill_rect(rect, impl-&gt;background_color);
+      gc-&gt;draw_rect(rect, impl-&gt;foreground_color);
+    }
+  else
+    {
+      gc-&gt;clear(impl-&gt;background_color);
+    }
+}
+
+void
+EditorMap::draw (EditorMapComponent* parent, CL_GraphicContext* gc)
+{
+  for(EditorMapImpl::Layers::iterator i = impl-&gt;layers.begin(); i != impl-&gt;layers.end(); ++i)
+    (*i).draw(parent, gc);
+  
+  gc-&gt;flush();
+}
+
+bool
+EditorMap::is_modified() const
+{
+  return impl-&gt;modified;
+}
+
+void
+EditorMap::set_unmodified() 
+{
+  impl-&gt;modified = false; 
+}
+
+void
+EditorMap::modify()
+{
+  impl-&gt;modified = true; 
+  impl-&gt;serial += 1; 
+}
+
+int
+EditorMap::get_serial() const 
+{ 
+  return impl-&gt;serial; 
+}
+
+int
+EditorMap::get_layer_count() const
+{
+  return static_cast&lt;int&gt;(impl-&gt;layers.size());
+}
+
+Layer
+EditorMap::get_layer(int i)
+{
+  if (i &gt;= 0 &amp;&amp; i &lt; static_cast&lt;int&gt;(impl-&gt;layers.size()))
+    return impl-&gt;layers[i];
+  else
+    return Layer();
+}
+
+void
+EditorMap::set_metadata(const MetaData&amp; obj)
+{
+  impl-&gt;metadata = obj; 
+}
+
+MetaData
+EditorMap::get_metadata() const
+{
+  return impl-&gt;metadata; 
+}
+
+bool
+EditorMap::has_bounding_rect() const
+{
+  return impl-&gt;has_bounding_rect;
+}
+
+void
+EditorMap::set_bounding_rect(const CL_Rect&amp; rect)
+{
+  if (rect != CL_Rect(0,0,0,0))
+    {
+      impl-&gt;has_bounding_rect = true;
+      impl-&gt;bounding_rect     = rect;
+    }
+  else
+    {
+      impl-&gt;has_bounding_rect = false;
+      impl-&gt;bounding_rect     = rect;
+    }
+}
+
+CL_Rect
+EditorMap::get_bounding_rect()
+{
+  if (impl-&gt;has_bounding_rect)
+    {
+      return impl-&gt;bounding_rect;
+    }
+  else
+    {
+      bool init = false;
+      CL_Rect rect(0,0,0,0);
+
+      for(EditorMapImpl::Layers::iterator i = impl-&gt;layers.begin(); i != impl-&gt;layers.end(); ++i)
+        {
+          if (i-&gt;has_bounding_rect())
+            {
+              if (!init)
+                {
+                  rect = i-&gt;get_bounding_rect();
+                  init = true;
+                }
+              else
+                {
+                  CL_Rect other = i-&gt;get_bounding_rect();
+                  rect.top    = std::min(rect.top,    other.top);
+                  rect.bottom = std::max(rect.bottom, other.bottom);
+                  rect.left   = std::min(rect.left,   other.left);
+                  rect.right  = std::max(rect.right,  other.right);              
+                }
+            }
+        }
+      return rect;
+    }
+}
+
+void
+EditorMap::set_background_color(const CL_Color&amp; color)
+{
+  impl-&gt; background_color = color;
+}
+
+void
+EditorMap::execute(Command command)
+{
+  impl-&gt;redo_stack.clear();
+  command.execute();
+  impl-&gt;undo_stack.push_back(command);
+  impl-&gt;on_change();
+}
+
+void
+EditorMap::undo()
+{
+  if (!impl-&gt;undo_stack.empty())
+    {
+      Command command = impl-&gt;undo_stack.back();
+      impl-&gt;undo_stack.pop_back();
+      command.undo();
+      impl-&gt;redo_stack.push_back(command);
+      impl-&gt;on_change();
+    }
+}
+
+void
+EditorMap::redo()
+{
+  if (!impl-&gt;redo_stack.empty())
+    {
+      Command command = impl-&gt;redo_stack.back();
+      impl-&gt;redo_stack.pop_back();
+      command.redo();
+      impl-&gt;undo_stack.push_back(command);
+      impl-&gt;on_change();
+    }
+}
+
+int
+EditorMap::undo_stack_size()
+{
+  return impl-&gt;undo_stack.size();
+}
+
+int
+EditorMap::redo_stack_size()
+{
+  return impl-&gt;redo_stack.size();
+}
+
+CL_Signal_v0&amp;
+EditorMap::sig_change()
+{
+  return impl-&gt;on_change;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/editor_map.cxx
===================================================================
--- trunk/flexlay/lib/editor_map.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/editor_map.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,281 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &lt;assert.h&gt;
-#include &lt;ClanLib/Core/core_iostream.h&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-#include &lt;ClanLib/Display/keys.h&gt;
-#include &quot;editor_names.hxx&quot;
-#include &quot;editor_map.hxx&quot;
-#include &quot;editor_map_component.hxx&quot;
-
-class EditorMapImpl
-{
-public:
-  /** Flag if the map got modified, used for 'Some maps are unsaved'
-      style massages */
-  bool modified;
-
-  /** Gets incremented with each map change so that other component
-      can update if required */
-  int serial;
-
-  typedef std::vector&lt;Layer&gt; Layers;
-  Layers layers;
-
-  CL_Color background_color;
-  CL_Color foreground_color;
-
-  /** Metadata attached to this map (ie. mapname, description, scripts, etc.) */
-  MetaData metadata;
-
-  typedef std::vector&lt;Command&gt; Commands;
-
-  Commands undo_stack;
-  Commands redo_stack;
-
-  CL_Signal_v0 on_change;
-
-  bool    has_bounding_rect;
-  CL_Rect bounding_rect;
-};
-
-EditorMap::EditorMap(bool create)
-  : impl(0)
-{
-  if (create)
-    {
-      impl = new EditorMapImpl();
-      impl-&gt;background_color = CL_Color(100, 80, 100);
-      impl-&gt;foreground_color = CL_Color(255, 80, 255);
-      impl-&gt;modified = false;
-      impl-&gt;serial = 0;
-      impl-&gt;has_bounding_rect = false;
-      impl-&gt;bounding_rect = CL_Rect(0,0,0,0);
-    }
-}
-
-void
-EditorMap::add_layer(const Layer&amp; layer, int pos)
-{
-  std::cout &lt;&lt; impl &lt;&lt; &quot; EditorMap::add_layer&quot; &lt;&lt; std::endl;
-
-  assert(pos == -1 || (pos &gt;= 0 &amp;&amp; pos &lt; int(impl-&gt;layers.size())));
-
-  if (pos == -1) // insert at last pos
-    impl-&gt;layers.push_back(layer);
-  else
-    impl-&gt;layers.insert(impl-&gt;layers.begin() + pos, layer);
-
-  impl-&gt;serial += 1;
-}
-
-void 
-EditorMap::draw_gui(CL_GraphicContext* gc)
-{
-  CL_Rect rect = get_bounding_rect();
-
-  if (rect != CL_Rect(0,0,0,0))
-    {
-      gc-&gt;fill_rect(rect, impl-&gt;background_color);
-      gc-&gt;draw_rect(rect, impl-&gt;foreground_color);
-    }
-  else
-    {
-      gc-&gt;clear(impl-&gt;background_color);
-    }
-}
-
-void
-EditorMap::draw (EditorMapComponent* parent, CL_GraphicContext* gc)
-{
-  for(EditorMapImpl::Layers::iterator i = impl-&gt;layers.begin(); i != impl-&gt;layers.end(); ++i)
-    (*i).draw(parent, gc);
-  
-  gc-&gt;flush();
-}
-
-bool
-EditorMap::is_modified() const
-{
-  return impl-&gt;modified;
-}
-
-void
-EditorMap::set_unmodified() 
-{
-  impl-&gt;modified = false; 
-}
-
-void
-EditorMap::modify()
-{
-  impl-&gt;modified = true; 
-  impl-&gt;serial += 1; 
-}
-
-int
-EditorMap::get_serial() const 
-{ 
-  return impl-&gt;serial; 
-}
-
-int
-EditorMap::get_layer_count() const
-{
-  return static_cast&lt;int&gt;(impl-&gt;layers.size());
-}
-
-Layer
-EditorMap::get_layer(int i)
-{
-  if (i &gt;= 0 &amp;&amp; i &lt; static_cast&lt;int&gt;(impl-&gt;layers.size()))
-    return impl-&gt;layers[i];
-  else
-    return Layer();
-}
-
-void
-EditorMap::set_metadata(const MetaData&amp; obj)
-{
-  impl-&gt;metadata = obj; 
-}
-
-MetaData
-EditorMap::get_metadata() const
-{
-  return impl-&gt;metadata; 
-}
-
-bool
-EditorMap::has_bounding_rect() const
-{
-  return impl-&gt;has_bounding_rect;
-}
-
-void
-EditorMap::set_bounding_rect(const CL_Rect&amp; rect)
-{
-  if (rect != CL_Rect(0,0,0,0))
-    {
-      impl-&gt;has_bounding_rect = true;
-      impl-&gt;bounding_rect     = rect;
-    }
-  else
-    {
-      impl-&gt;has_bounding_rect = false;
-      impl-&gt;bounding_rect     = rect;
-    }
-}
-
-CL_Rect
-EditorMap::get_bounding_rect()
-{
-  if (impl-&gt;has_bounding_rect)
-    {
-      return impl-&gt;bounding_rect;
-    }
-  else
-    {
-      bool init = false;
-      CL_Rect rect(0,0,0,0);
-
-      for(EditorMapImpl::Layers::iterator i = impl-&gt;layers.begin(); i != impl-&gt;layers.end(); ++i)
-        {
-          if (i-&gt;has_bounding_rect())
-            {
-              if (!init)
-                {
-                  rect = i-&gt;get_bounding_rect();
-                  init = true;
-                }
-              else
-                {
-                  CL_Rect other = i-&gt;get_bounding_rect();
-                  rect.top    = std::min(rect.top,    other.top);
-                  rect.bottom = std::max(rect.bottom, other.bottom);
-                  rect.left   = std::min(rect.left,   other.left);
-                  rect.right  = std::max(rect.right,  other.right);              
-                }
-            }
-        }
-      return rect;
-    }
-}
-
-void
-EditorMap::set_background_color(const CL_Color&amp; color)
-{
-  impl-&gt; background_color = color;
-}
-
-void
-EditorMap::execute(Command command)
-{
-  impl-&gt;redo_stack.clear();
-  command.execute();
-  impl-&gt;undo_stack.push_back(command);
-  impl-&gt;on_change();
-}
-
-void
-EditorMap::undo()
-{
-  if (!impl-&gt;undo_stack.empty())
-    {
-      Command command = impl-&gt;undo_stack.back();
-      impl-&gt;undo_stack.pop_back();
-      command.undo();
-      impl-&gt;redo_stack.push_back(command);
-      impl-&gt;on_change();
-    }
-}
-
-void
-EditorMap::redo()
-{
-  if (!impl-&gt;redo_stack.empty())
-    {
-      Command command = impl-&gt;redo_stack.back();
-      impl-&gt;redo_stack.pop_back();
-      command.redo();
-      impl-&gt;undo_stack.push_back(command);
-      impl-&gt;on_change();
-    }
-}
-
-int
-EditorMap::undo_stack_size()
-{
-  return impl-&gt;undo_stack.size();
-}
-
-int
-EditorMap::redo_stack_size()
-{
-  return impl-&gt;redo_stack.size();
-}
-
-CL_Signal_v0&amp;
-EditorMap::sig_change()
-{
-  return impl-&gt;on_change;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/editor_map.hpp (from rev 712, trunk/flexlay/lib/editor_map.hxx)
===================================================================
--- trunk/flexlay/lib/editor_map.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/editor_map.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,97 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_EDITOR_MAP_HXX
+#define HEADER_EDITOR_MAP_HXX
+
+#include &lt;vector&gt;
+#include &lt;ClanLib/Display/sprite.h&gt;
+#include &lt;ClanLib/GUI/component.h&gt;
+#include &lt;ClanLib/Core/Math/point.h&gt;
+#include &quot;field.hpp&quot;
+#include &quot;object_layer.hpp&quot;
+#include &quot;tilemap_layer.hpp&quot;
+#include &quot;layer.hpp&quot;
+#include &quot;command.hpp&quot;
+
+class Command;
+class EditorMapComponent;
+class EditorMapImpl;
+
+/** Object which represents a level, quirled together with the GUI
+    stuff */
+class EditorMap
+{
+public:
+  EditorMap(bool create = false);
+
+  /** FIXME: EditorMapComponent parameter shouldn't really be here */
+  void draw(EditorMapComponent* parent, CL_GraphicContext* gc);
+  
+  /** Draw stuff that is only relevant on the GUI (bounding rects and such) */
+  void draw_gui(CL_GraphicContext* gc);
+
+  void add_layer(const Layer&amp; layer, int pos = -1);
+
+  bool is_modified() const;
+  void set_unmodified();
+  void modify();
+
+  int get_serial() const;
+
+  int get_layer_count() const;
+  Layer get_layer(int i);
+
+  void   set_metadata(const MetaData&amp; obj);
+  MetaData get_metadata() const;
+
+  bool has_bounding_rect() const;
+  CL_Rect get_bounding_rect();
+
+  /** Set the bounding rect for this map, if the given rect is
+      CL_Rect() the bounding rect will be calculated automatically
+      from the content of the map */
+  void    set_bounding_rect(const CL_Rect&amp; rect);
+
+  void set_background_color(const CL_Color&amp; color);
+
+  /** Execute a command and place it on the undo stack, commands given
+      to this function will be deleted by the Editor class, so they
+      have to be new'ed */
+  void execute(Command command);
+
+  /** Move backward in the undo stack */
+  void undo();
+
+  /** Move forward in the undo stack */
+  void redo();
+
+  int undo_stack_size();
+
+  int redo_stack_size();
+
+  CL_Signal_v0&amp; sig_change();
+
+  bool is_null() const { return !impl.get(); }
+private:
+  CL_SharedPtr&lt;EditorMapImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/editor_map.hxx
===================================================================
--- trunk/flexlay/lib/editor_map.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/editor_map.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,97 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_EDITOR_MAP_HXX
-#define HEADER_EDITOR_MAP_HXX
-
-#include &lt;vector&gt;
-#include &lt;ClanLib/Display/sprite.h&gt;
-#include &lt;ClanLib/GUI/component.h&gt;
-#include &lt;ClanLib/Core/Math/point.h&gt;
-#include &quot;field.hxx&quot;
-#include &quot;object_layer.hxx&quot;
-#include &quot;tilemap_layer.hxx&quot;
-#include &quot;layer.hxx&quot;
-#include &quot;command.hxx&quot;
-
-class Command;
-class EditorMapComponent;
-class EditorMapImpl;
-
-/** Object which represents a level, quirled together with the GUI
-    stuff */
-class EditorMap
-{
-public:
-  EditorMap(bool create = false);
-
-  /** FIXME: EditorMapComponent parameter shouldn't really be here */
-  void draw(EditorMapComponent* parent, CL_GraphicContext* gc);
-  
-  /** Draw stuff that is only relevant on the GUI (bounding rects and such) */
-  void draw_gui(CL_GraphicContext* gc);
-
-  void add_layer(const Layer&amp; layer, int pos = -1);
-
-  bool is_modified() const;
-  void set_unmodified();
-  void modify();
-
-  int get_serial() const;
-
-  int get_layer_count() const;
-  Layer get_layer(int i);
-
-  void   set_metadata(const MetaData&amp; obj);
-  MetaData get_metadata() const;
-
-  bool has_bounding_rect() const;
-  CL_Rect get_bounding_rect();
-
-  /** Set the bounding rect for this map, if the given rect is
-      CL_Rect() the bounding rect will be calculated automatically
-      from the content of the map */
-  void    set_bounding_rect(const CL_Rect&amp; rect);
-
-  void set_background_color(const CL_Color&amp; color);
-
-  /** Execute a command and place it on the undo stack, commands given
-      to this function will be deleted by the Editor class, so they
-      have to be new'ed */
-  void execute(Command command);
-
-  /** Move backward in the undo stack */
-  void undo();
-
-  /** Move forward in the undo stack */
-  void redo();
-
-  int undo_stack_size();
-
-  int redo_stack_size();
-
-  CL_Signal_v0&amp; sig_change();
-
-  bool is_null() const { return !impl.get(); }
-private:
-  CL_SharedPtr&lt;EditorMapImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/editor_map_component.cpp (from rev 712, trunk/flexlay/lib/editor_map_component.cxx)
===================================================================
--- trunk/flexlay/lib/editor_map_component.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/editor_map_component.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,275 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &lt;ClanLib/Core/core_iostream.h&gt;
+#include &lt;ClanLib/Display/keyboard.h&gt;
+#include &lt;ClanLib/Display/mouse.h&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &lt;ClanLib/Display/display_iostream.h&gt;
+#include &lt;ClanLib/Display/keys.h&gt;
+#include &quot;tileset.hpp&quot;
+#include &quot;editor_names.hpp&quot;
+#include &quot;editor_map.hpp&quot;
+#include &quot;workspace.hpp&quot;
+#include &quot;scrollbar.hpp&quot;
+#include &quot;editor_map_component.hpp&quot;
+
+EditorMapComponent* EditorMapComponent::current_ = 0; 
+
+class EditorMapComponentImpl
+{
+public:
+  EditorMapComponent* parent;
+  GraphicContextState gc_state;
+  Scrollbar* scrollbar_h;
+  Scrollbar* scrollbar_v;
+  CL_SlotContainer slots;
+  Workspace workspace;
+  CL_Signal_v2&lt;int, int&gt; key_bindings[256];
+
+  EditorMapComponentImpl()
+    :workspace(true) 
+  {}
+
+  void draw();
+  void mouse_up  (const CL_InputEvent&amp; event);
+  void mouse_down(const CL_InputEvent&amp; event);
+  void mouse_move(const CL_InputEvent&amp; event);
+  void on_key_up(const CL_InputEvent&amp; event);
+  void on_key_down(const CL_InputEvent&amp; event);
+  void on_resize(int old_w, int old_h);
+};
+
+EditorMapComponent::EditorMapComponent(const CL_Rect&amp; rect, CL_Component* parent)
+  : CL_Component(rect, parent),
+    impl(new EditorMapComponentImpl())
+{
+  impl-&gt;parent = this;
+  impl-&gt;gc_state  = GraphicContextState(rect.get_width(), rect.get_height());
+
+  current_ = this;
+
+  impl-&gt;scrollbar_v = new Scrollbar(CL_Rect(CL_Point(rect.get_width() - 14, 2) + CL_Point(rect.left, rect.top), 
+                                            CL_Size(12, rect.get_height() - 4 - 14)),
+                                    Scrollbar::VERTICAL,
+                                    parent);
+
+  impl-&gt;scrollbar_h = new Scrollbar(CL_Rect(CL_Point(2, rect.get_height() - 14) + CL_Point(rect.left, rect.top), 
+                                            CL_Size(rect.get_width() - 4 - 14, 12)),
+                                    Scrollbar::HORIZONTAL,
+                                    parent);
+
+  impl-&gt;slots.connect(impl-&gt;scrollbar_h-&gt;sig_scrollbar_move(), this, &amp;EditorMapComponent::move_to_x);
+  impl-&gt;slots.connect(impl-&gt;scrollbar_v-&gt;sig_scrollbar_move(), this, &amp;EditorMapComponent::move_to_y);
+
+  impl-&gt;slots.connect(sig_paint(),      impl.get(), &amp;EditorMapComponentImpl::draw);
+  impl-&gt;slots.connect(sig_mouse_up(),   impl.get(), &amp;EditorMapComponentImpl::mouse_up);
+  impl-&gt;slots.connect(sig_mouse_down(), impl.get(), &amp;EditorMapComponentImpl::mouse_down);
+  impl-&gt;slots.connect(sig_mouse_move(), impl.get(), &amp;EditorMapComponentImpl::mouse_move);
+  impl-&gt;slots.connect(sig_key_down(),   impl.get(), &amp;EditorMapComponentImpl::on_key_down);
+  impl-&gt;slots.connect(sig_key_up(),     impl.get(), &amp;EditorMapComponentImpl::on_key_up);
+  impl-&gt;slots.connect(sig_resize(),     impl.get(), &amp;EditorMapComponentImpl::on_resize);
+}
+
+EditorMapComponent::~EditorMapComponent()
+{
+  std::cout &lt;&lt; &quot;~EditorMapComponent()&quot; &lt;&lt; std::endl;
+}
+
+Workspace
+EditorMapComponent::get_workspace() const
+{
+  return impl-&gt;workspace;
+}
+
+void
+EditorMapComponent::set_workspace(Workspace m)
+{
+  impl-&gt;workspace = m;
+}
+
+void
+EditorMapComponentImpl::on_key_down(const CL_InputEvent&amp; event)
+{
+  if (event.id &gt;= 0 &amp;&amp; event.id &lt; 256)
+    { 
+      CL_Rect rect = parent-&gt;get_position();
+      key_bindings[event.id](CL_Mouse::get_x() - rect.left,
+                             CL_Mouse::get_y() - rect.top);
+    }
+
+  if (event.repeat_count == 0)
+    {
+      CL_Rect rect = parent-&gt;get_position();
+      CL_InputEvent ev2 = event;
+      ev2.mouse_pos = CL_Point(CL_Mouse::get_x() - rect.left,
+                               CL_Mouse::get_y() - rect.top);
+      workspace.key_down(ev2);
+    }
+}
+
+void
+EditorMapComponentImpl::on_key_up(const CL_InputEvent&amp; event)
+{
+  CL_Rect rect = parent-&gt;get_position();
+  CL_InputEvent ev2 = event;
+  ev2.mouse_pos = CL_Point(CL_Mouse::get_x() - rect.left,
+                           CL_Mouse::get_y() - rect.top);
+  workspace.key_up(ev2);
+}
+
+void
+EditorMapComponentImpl::mouse_up(const CL_InputEvent&amp; event)
+{
+  workspace.mouse_up(event);
+}
+
+void
+EditorMapComponentImpl::mouse_move(const CL_InputEvent&amp; event)
+{
+  workspace.mouse_move(event);
+}
+
+void
+EditorMapComponentImpl::mouse_down(const CL_InputEvent&amp; event)
+{
+  workspace.mouse_down(event);
+}
+  
+void
+EditorMapComponentImpl::draw ()
+{
+  if (workspace.get_map().is_null()) return;
+
+  CL_Display::push_cliprect(parent-&gt;get_screen_rect());
+
+  CL_Display::push_translate(parent-&gt;get_screen_x(), parent-&gt;get_screen_y());
+
+  // Update scrollbars (FIXME: move me to function)
+  scrollbar_v-&gt;set_range(0, workspace.get_map().get_bounding_rect().get_height());
+  scrollbar_v-&gt;set_pagesize(parent-&gt;get_height()/gc_state.get_zoom());
+  scrollbar_v-&gt;set_pos(gc_state.get_pos().y);
+
+  scrollbar_h-&gt;set_range(0, workspace.get_map().get_bounding_rect().get_width());
+  scrollbar_h-&gt;set_pagesize(parent-&gt;get_width()/gc_state.get_zoom());
+  scrollbar_h-&gt;set_pos(gc_state.get_pos().x);
+
+  gc_state.push();
+  workspace.draw();
+  gc_state.pop();
+
+  CL_Display::pop_modelview();
+  CL_Display::pop_cliprect();
+}
+
+CL_Pointf
+EditorMapComponent::screen2world(const CL_Point&amp; pos)
+{
+  return impl-&gt;gc_state.screen2world(pos);
+}
+
+void
+EditorMapComponent::set_zoom(float z)
+{
+  impl-&gt;gc_state.set_zoom(z);
+}
+
+void
+EditorMapComponent::zoom_out(CL_Point pos)
+{
+  impl-&gt;gc_state.set_zoom(CL_Pointf(pos.x, pos.y),
+                          impl-&gt;gc_state.get_zoom()/1.25f);
+}
+
+void
+EditorMapComponent::zoom_in(CL_Point pos)
+{
+  impl-&gt;gc_state.set_zoom(CL_Pointf(pos.x, pos.y), 
+                          impl-&gt;gc_state.get_zoom()*1.25f);
+}
+
+void
+EditorMapComponent::zoom_to(CL_Rectf rect)
+{
+  impl-&gt;gc_state.zoom_to(rect);
+}
+
+CL_Rectf
+EditorMapComponent::get_clip_rect()
+{
+  return impl-&gt;gc_state.get_clip_rect();
+}
+
+void
+EditorMapComponent::move_to(int x, int y)
+{
+  impl-&gt;gc_state.set_pos(CL_Pointf(x, y));
+}
+
+void
+EditorMapComponent::move_to_x(float x)
+{
+  impl-&gt;gc_state.set_pos(CL_Pointf(x, impl-&gt;gc_state.get_pos().y));
+}
+
+void
+EditorMapComponent::move_to_y(float y)
+{
+  impl-&gt;gc_state.set_pos(CL_Pointf(impl-&gt;gc_state.get_pos().x, y));
+}
+
+void
+EditorMapComponentImpl::on_resize(int old_w, int old_h)
+{
+  CL_Rect rect = parent-&gt;get_screen_rect();
+
+  scrollbar_v-&gt;set_position(rect.get_width() - 14 + rect.left,  2 + rect.top);
+  scrollbar_v-&gt;set_size(12, rect.get_height() - 4 - 14);
+  
+  scrollbar_h-&gt;set_position(2 + rect.left, rect.get_height() - 14 + rect.top);
+  scrollbar_h-&gt;set_size(rect.get_width() - 4 - 14, 12);
+
+  gc_state.set_size(rect.get_width(), rect.get_height());
+}
+
+CL_Signal_v2&lt;int, int&gt;&amp;
+EditorMapComponent::sig_on_key(const std::string&amp; str)
+{
+  int id = CL_Keyboard::get_device().string_to_keyid(str);
+
+  //std::cout &lt;&lt; str &lt;&lt; &quot; =&gt; &quot; &lt;&lt; id &lt;&lt; std::endl;
+
+  if (id &gt; 0 &amp;&amp; id &lt; 256)
+    {
+      return impl-&gt;key_bindings[id];
+    }
+  else
+    {
+      std::cout &lt;&lt; &quot;EditorMapComponent::sig_on_key: invalid key id: &quot; &lt;&lt; id &lt;&lt; std::endl;
+      return impl-&gt;key_bindings[0];
+    }
+}
+
+GraphicContextState&amp;
+EditorMapComponent::get_gc_state()
+{
+  return impl-&gt;gc_state;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/editor_map_component.cxx
===================================================================
--- trunk/flexlay/lib/editor_map_component.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/editor_map_component.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,275 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &lt;ClanLib/Core/core_iostream.h&gt;
-#include &lt;ClanLib/Display/keyboard.h&gt;
-#include &lt;ClanLib/Display/mouse.h&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-#include &lt;ClanLib/Display/display_iostream.h&gt;
-#include &lt;ClanLib/Display/keys.h&gt;
-#include &quot;tileset.hxx&quot;
-#include &quot;editor_names.hxx&quot;
-#include &quot;editor_map.hxx&quot;
-#include &quot;workspace.hxx&quot;
-#include &quot;scrollbar.hxx&quot;
-#include &quot;editor_map_component.hxx&quot;
-
-EditorMapComponent* EditorMapComponent::current_ = 0; 
-
-class EditorMapComponentImpl
-{
-public:
-  EditorMapComponent* parent;
-  GraphicContextState gc_state;
-  Scrollbar* scrollbar_h;
-  Scrollbar* scrollbar_v;
-  CL_SlotContainer slots;
-  Workspace workspace;
-  CL_Signal_v2&lt;int, int&gt; key_bindings[256];
-
-  EditorMapComponentImpl()
-    :workspace(true) 
-  {}
-
-  void draw();
-  void mouse_up  (const CL_InputEvent&amp; event);
-  void mouse_down(const CL_InputEvent&amp; event);
-  void mouse_move(const CL_InputEvent&amp; event);
-  void on_key_up(const CL_InputEvent&amp; event);
-  void on_key_down(const CL_InputEvent&amp; event);
-  void on_resize(int old_w, int old_h);
-};
-
-EditorMapComponent::EditorMapComponent(const CL_Rect&amp; rect, CL_Component* parent)
-  : CL_Component(rect, parent),
-    impl(new EditorMapComponentImpl())
-{
-  impl-&gt;parent = this;
-  impl-&gt;gc_state  = GraphicContextState(rect.get_width(), rect.get_height());
-
-  current_ = this;
-
-  impl-&gt;scrollbar_v = new Scrollbar(CL_Rect(CL_Point(rect.get_width() - 14, 2) + CL_Point(rect.left, rect.top), 
-                                            CL_Size(12, rect.get_height() - 4 - 14)),
-                                    Scrollbar::VERTICAL,
-                                    parent);
-
-  impl-&gt;scrollbar_h = new Scrollbar(CL_Rect(CL_Point(2, rect.get_height() - 14) + CL_Point(rect.left, rect.top), 
-                                            CL_Size(rect.get_width() - 4 - 14, 12)),
-                                    Scrollbar::HORIZONTAL,
-                                    parent);
-
-  impl-&gt;slots.connect(impl-&gt;scrollbar_h-&gt;sig_scrollbar_move(), this, &amp;EditorMapComponent::move_to_x);
-  impl-&gt;slots.connect(impl-&gt;scrollbar_v-&gt;sig_scrollbar_move(), this, &amp;EditorMapComponent::move_to_y);
-
-  impl-&gt;slots.connect(sig_paint(),      impl.get(), &amp;EditorMapComponentImpl::draw);
-  impl-&gt;slots.connect(sig_mouse_up(),   impl.get(), &amp;EditorMapComponentImpl::mouse_up);
-  impl-&gt;slots.connect(sig_mouse_down(), impl.get(), &amp;EditorMapComponentImpl::mouse_down);
-  impl-&gt;slots.connect(sig_mouse_move(), impl.get(), &amp;EditorMapComponentImpl::mouse_move);
-  impl-&gt;slots.connect(sig_key_down(),   impl.get(), &amp;EditorMapComponentImpl::on_key_down);
-  impl-&gt;slots.connect(sig_key_up(),     impl.get(), &amp;EditorMapComponentImpl::on_key_up);
-  impl-&gt;slots.connect(sig_resize(),     impl.get(), &amp;EditorMapComponentImpl::on_resize);
-}
-
-EditorMapComponent::~EditorMapComponent()
-{
-  std::cout &lt;&lt; &quot;~EditorMapComponent()&quot; &lt;&lt; std::endl;
-}
-
-Workspace
-EditorMapComponent::get_workspace() const
-{
-  return impl-&gt;workspace;
-}
-
-void
-EditorMapComponent::set_workspace(Workspace m)
-{
-  impl-&gt;workspace = m;
-}
-
-void
-EditorMapComponentImpl::on_key_down(const CL_InputEvent&amp; event)
-{
-  if (event.id &gt;= 0 &amp;&amp; event.id &lt; 256)
-    { 
-      CL_Rect rect = parent-&gt;get_position();
-      key_bindings[event.id](CL_Mouse::get_x() - rect.left,
-                             CL_Mouse::get_y() - rect.top);
-    }
-
-  if (event.repeat_count == 0)
-    {
-      CL_Rect rect = parent-&gt;get_position();
-      CL_InputEvent ev2 = event;
-      ev2.mouse_pos = CL_Point(CL_Mouse::get_x() - rect.left,
-                               CL_Mouse::get_y() - rect.top);
-      workspace.key_down(ev2);
-    }
-}
-
-void
-EditorMapComponentImpl::on_key_up(const CL_InputEvent&amp; event)
-{
-  CL_Rect rect = parent-&gt;get_position();
-  CL_InputEvent ev2 = event;
-  ev2.mouse_pos = CL_Point(CL_Mouse::get_x() - rect.left,
-                           CL_Mouse::get_y() - rect.top);
-  workspace.key_up(ev2);
-}
-
-void
-EditorMapComponentImpl::mouse_up(const CL_InputEvent&amp; event)
-{
-  workspace.mouse_up(event);
-}
-
-void
-EditorMapComponentImpl::mouse_move(const CL_InputEvent&amp; event)
-{
-  workspace.mouse_move(event);
-}
-
-void
-EditorMapComponentImpl::mouse_down(const CL_InputEvent&amp; event)
-{
-  workspace.mouse_down(event);
-}
-  
-void
-EditorMapComponentImpl::draw ()
-{
-  if (workspace.get_map().is_null()) return;
-
-  CL_Display::push_cliprect(parent-&gt;get_screen_rect());
-
-  CL_Display::push_translate(parent-&gt;get_screen_x(), parent-&gt;get_screen_y());
-
-  // Update scrollbars (FIXME: move me to function)
-  scrollbar_v-&gt;set_range(0, workspace.get_map().get_bounding_rect().get_height());
-  scrollbar_v-&gt;set_pagesize(parent-&gt;get_height()/gc_state.get_zoom());
-  scrollbar_v-&gt;set_pos(gc_state.get_pos().y);
-
-  scrollbar_h-&gt;set_range(0, workspace.get_map().get_bounding_rect().get_width());
-  scrollbar_h-&gt;set_pagesize(parent-&gt;get_width()/gc_state.get_zoom());
-  scrollbar_h-&gt;set_pos(gc_state.get_pos().x);
-
-  gc_state.push();
-  workspace.draw();
-  gc_state.pop();
-
-  CL_Display::pop_modelview();
-  CL_Display::pop_cliprect();
-}
-
-CL_Pointf
-EditorMapComponent::screen2world(const CL_Point&amp; pos)
-{
-  return impl-&gt;gc_state.screen2world(pos);
-}
-
-void
-EditorMapComponent::set_zoom(float z)
-{
-  impl-&gt;gc_state.set_zoom(z);
-}
-
-void
-EditorMapComponent::zoom_out(CL_Point pos)
-{
-  impl-&gt;gc_state.set_zoom(CL_Pointf(pos.x, pos.y),
-                          impl-&gt;gc_state.get_zoom()/1.25f);
-}
-
-void
-EditorMapComponent::zoom_in(CL_Point pos)
-{
-  impl-&gt;gc_state.set_zoom(CL_Pointf(pos.x, pos.y), 
-                          impl-&gt;gc_state.get_zoom()*1.25f);
-}
-
-void
-EditorMapComponent::zoom_to(CL_Rectf rect)
-{
-  impl-&gt;gc_state.zoom_to(rect);
-}
-
-CL_Rectf
-EditorMapComponent::get_clip_rect()
-{
-  return impl-&gt;gc_state.get_clip_rect();
-}
-
-void
-EditorMapComponent::move_to(int x, int y)
-{
-  impl-&gt;gc_state.set_pos(CL_Pointf(x, y));
-}
-
-void
-EditorMapComponent::move_to_x(float x)
-{
-  impl-&gt;gc_state.set_pos(CL_Pointf(x, impl-&gt;gc_state.get_pos().y));
-}
-
-void
-EditorMapComponent::move_to_y(float y)
-{
-  impl-&gt;gc_state.set_pos(CL_Pointf(impl-&gt;gc_state.get_pos().x, y));
-}
-
-void
-EditorMapComponentImpl::on_resize(int old_w, int old_h)
-{
-  CL_Rect rect = parent-&gt;get_screen_rect();
-
-  scrollbar_v-&gt;set_position(rect.get_width() - 14 + rect.left,  2 + rect.top);
-  scrollbar_v-&gt;set_size(12, rect.get_height() - 4 - 14);
-  
-  scrollbar_h-&gt;set_position(2 + rect.left, rect.get_height() - 14 + rect.top);
-  scrollbar_h-&gt;set_size(rect.get_width() - 4 - 14, 12);
-
-  gc_state.set_size(rect.get_width(), rect.get_height());
-}
-
-CL_Signal_v2&lt;int, int&gt;&amp;
-EditorMapComponent::sig_on_key(const std::string&amp; str)
-{
-  int id = CL_Keyboard::get_device().string_to_keyid(str);
-
-  //std::cout &lt;&lt; str &lt;&lt; &quot; =&gt; &quot; &lt;&lt; id &lt;&lt; std::endl;
-
-  if (id &gt; 0 &amp;&amp; id &lt; 256)
-    {
-      return impl-&gt;key_bindings[id];
-    }
-  else
-    {
-      std::cout &lt;&lt; &quot;EditorMapComponent::sig_on_key: invalid key id: &quot; &lt;&lt; id &lt;&lt; std::endl;
-      return impl-&gt;key_bindings[0];
-    }
-}
-
-GraphicContextState&amp;
-EditorMapComponent::get_gc_state()
-{
-  return impl-&gt;gc_state;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/editor_map_component.hpp (from rev 712, trunk/flexlay/lib/editor_map_component.hxx)
===================================================================
--- trunk/flexlay/lib/editor_map_component.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/editor_map_component.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,73 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_EDITOR_MAP_COMPONENT_HXX
+#define HEADER_EDITOR_MAP_COMPONENT_HXX
+
+#include &lt;vector&gt;
+#include &lt;ClanLib/Display/sprite.h&gt;
+#include &lt;ClanLib/GUI/component.h&gt;
+#include &lt;ClanLib/Core/Math/point.h&gt;
+#include &quot;field.hpp&quot;
+#include &quot;object_layer.hpp&quot;
+#include &quot;graphic_context_state.hpp&quot;
+#include &quot;workspace.hpp&quot;
+
+class Scrollbar;
+class EditorMapComponentImpl;
+
+/** Object which represents a level, quirled together with the GUI
+    stuff */
+class EditorMapComponent : public CL_Component
+{
+private:
+  static EditorMapComponent* current_; 
+protected:
+  virtual ~EditorMapComponent();
+public:
+  static EditorMapComponent* current() { return current_; } 
+
+  EditorMapComponent(const CL_Rect&amp; rect, CL_Component* parent);
+ 
+  Workspace get_workspace() const;
+  void      set_workspace(Workspace m);
+
+  void  set_zoom(float z);
+  void  zoom_to(CL_Rectf rect);
+  void  zoom_out(CL_Point pos);
+  void  zoom_in (CL_Point pos);
+
+  void move_to(int x, int y);
+  void move_to_x(float x);
+  void move_to_y(float y);
+
+  CL_Signal_v2&lt;int, int&gt;&amp; sig_on_key(const std::string&amp; str);
+
+  CL_Pointf screen2world(const CL_Point&amp; pos);
+
+  CL_Rectf get_clip_rect();
+
+  GraphicContextState&amp; get_gc_state();
+
+private:
+  SharedPtr&lt;EditorMapComponentImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/editor_map_component.hxx
===================================================================
--- trunk/flexlay/lib/editor_map_component.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/editor_map_component.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,73 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_EDITOR_MAP_COMPONENT_HXX
-#define HEADER_EDITOR_MAP_COMPONENT_HXX
-
-#include &lt;vector&gt;
-#include &lt;ClanLib/Display/sprite.h&gt;
-#include &lt;ClanLib/GUI/component.h&gt;
-#include &lt;ClanLib/Core/Math/point.h&gt;
-#include &quot;field.hxx&quot;
-#include &quot;object_layer.hxx&quot;
-#include &quot;graphic_context_state.hxx&quot;
-#include &quot;workspace.hxx&quot;
-
-class Scrollbar;
-class EditorMapComponentImpl;
-
-/** Object which represents a level, quirled together with the GUI
-    stuff */
-class EditorMapComponent : public CL_Component
-{
-private:
-  static EditorMapComponent* current_; 
-protected:
-  virtual ~EditorMapComponent();
-public:
-  static EditorMapComponent* current() { return current_; } 
-
-  EditorMapComponent(const CL_Rect&amp; rect, CL_Component* parent);
- 
-  Workspace get_workspace() const;
-  void      set_workspace(Workspace m);
-
-  void  set_zoom(float z);
-  void  zoom_to(CL_Rectf rect);
-  void  zoom_out(CL_Point pos);
-  void  zoom_in (CL_Point pos);
-
-  void move_to(int x, int y);
-  void move_to_x(float x);
-  void move_to_y(float y);
-
-  CL_Signal_v2&lt;int, int&gt;&amp; sig_on_key(const std::string&amp; str);
-
-  CL_Pointf screen2world(const CL_Point&amp; pos);
-
-  CL_Rectf get_clip_rect();
-
-  GraphicContextState&amp; get_gc_state();
-
-private:
-  SharedPtr&lt;EditorMapComponentImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/editor_names.hpp (from rev 712, trunk/flexlay/lib/editor_names.hxx)

Deleted: trunk/flexlay/lib/editor_names.hxx
===================================================================
--- trunk/flexlay/lib/editor_names.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/editor_names.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,27 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_EDITOR_NAMES_HXX
-#define HEADER_EDITOR_NAMES_HXX
-
-enum { TILEMAP_NAME = 0, OBJECTMAP_NAME = 1 };
-enum { PAINT_TOOL_NAME = 0, SELECT_TOOL_NAME = 1, DIAMOND_TOOL = 2, OBJECT_TOOL_NAME = 3 }; 
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/field.hpp (from rev 712, trunk/flexlay/lib/field.hxx)
===================================================================
--- trunk/flexlay/lib/field.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/field.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,139 @@
+//  $Id: field.hpp,v 1.4 2003/09/12 09:25:48 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2000 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef FIELD_HXX
+#define FIELD_HXX
+
+#include &lt;vector&gt;
+#include &lt;assert.h&gt;
+
+template&lt;class T&gt;
+class Field
+{
+private:
+  int width;
+  int height;
+  std::vector&lt;T&gt; vec;
+
+public:
+  typedef typename std::vector&lt;T&gt;::iterator iterator;
+
+  Field()
+    : width(0), height(0)
+  {
+  }
+
+  Field (int w, int h) 
+    : width (w), height (h), vec (width * height)
+  {
+  }
+
+  Field(const Field&lt;T&gt;&amp; copy)
+    : width(copy.width), height(copy.height), vec(copy.vec)
+  {
+  }
+
+  /** Creates a new field out of a subsection from an already excisting one 
+   *  @param pos_x The position of the old field in the new resized one
+   *  @param pos_y The position of the old field in the new resized one */
+  Field(const Field&lt;T&gt;&amp; arg_field, int w, int h, int pos_x, int pos_y)
+    : width (w), height (h), vec (width * height)
+  {
+    int start_x = std::max(0, -pos_x);
+    int start_y = std::max(0, -pos_y);
+
+    int end_x = std::min(arg_field.get_width(),  get_width()  - pos_x);
+    int end_y = std::min(arg_field.get_height(), get_height() - pos_y);
+
+    for(int y = start_y; y &lt; end_y; ++y)
+      for(int x = start_x; x &lt; end_x; ++x)
+        at(pos_x + x, pos_y + y) = arg_field.at(x, y);
+  }
+
+  Field&lt;T&gt;&amp; operator=(const Field&lt;T&gt;&amp; copy)
+  {
+    if (this != &amp;copy)
+      {
+        width  = copy.width;
+        height = copy.height;
+        vec    = copy.vec;
+      }
+    return *this;
+  }
+
+  const T&amp; operator[] (int i) const {
+    return vec[i];
+  }
+
+  T&amp; operator[] (int i) {
+    return vec[i];
+  }
+
+  T&amp; operator() (int x, int y) 
+  {
+    assert (x &gt;= 0 || x &lt; (int) width || y &gt;= 0 || y &lt; (int) height);
+    return vec [width*y + x];
+  }
+
+  const T&amp; operator() (int x, int y) const
+  {
+    assert (x &gt;= 0 || x &lt; (int) width || y &gt;= 0 || y &lt; (int) height);
+    return vec [width*y + x];
+  }
+  
+  inline const T&amp; at (int x, int y) const {
+    return vec [width*y + x];
+  }
+
+  inline T&amp; at (int x, int y) {
+    return (*this) (x, y);
+  }
+
+  /** Resize a field to a new size
+   *  @param pos_x The position of the old field in the new resized one
+   *  @param pos_y The position of the old field in the new resized one
+   **/
+  void resize(int w, int h, int pos_x = 0, int pos_y = 0) 
+  {
+    *this = Field&lt;T&gt;(*this, w, h, pos_x, pos_y);
+  }
+
+  void clear()
+  {
+    width  = 0;
+    height = 0;
+    vec.clear();
+  }
+
+  std::vector&lt;T&gt;&amp; get_data() { return vec; }
+  void set_data(const std::vector&lt;T&gt;&amp; d) { 
+    for(typename std::vector&lt;T&gt;::size_type i = 0; i &lt; vec.size() &amp;&amp; i &lt; d.size(); ++i)
+      vec[i] = d[i]; 
+  }
+
+  iterator begin () { return vec.begin (); }
+  iterator end () { return vec.end (); }
+
+  int size() const { return vec.size(); }
+  int get_width () const { return width; }
+  int get_height () const { return height; }
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/field.hxx
===================================================================
--- trunk/flexlay/lib/field.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/field.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,139 +0,0 @@
-//  $Id: field.hxx,v 1.4 2003/09/12 09:25:48 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2000 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef FIELD_HXX
-#define FIELD_HXX
-
-#include &lt;vector&gt;
-#include &lt;assert.h&gt;
-
-template&lt;class T&gt;
-class Field
-{
-private:
-  int width;
-  int height;
-  std::vector&lt;T&gt; vec;
-
-public:
-  typedef typename std::vector&lt;T&gt;::iterator iterator;
-
-  Field()
-    : width(0), height(0)
-  {
-  }
-
-  Field (int w, int h) 
-    : width (w), height (h), vec (width * height)
-  {
-  }
-
-  Field(const Field&lt;T&gt;&amp; copy)
-    : width(copy.width), height(copy.height), vec(copy.vec)
-  {
-  }
-
-  /** Creates a new field out of a subsection from an already excisting one 
-   *  @param pos_x The position of the old field in the new resized one
-   *  @param pos_y The position of the old field in the new resized one */
-  Field(const Field&lt;T&gt;&amp; arg_field, int w, int h, int pos_x, int pos_y)
-    : width (w), height (h), vec (width * height)
-  {
-    int start_x = std::max(0, -pos_x);
-    int start_y = std::max(0, -pos_y);
-
-    int end_x = std::min(arg_field.get_width(),  get_width()  - pos_x);
-    int end_y = std::min(arg_field.get_height(), get_height() - pos_y);
-
-    for(int y = start_y; y &lt; end_y; ++y)
-      for(int x = start_x; x &lt; end_x; ++x)
-        at(pos_x + x, pos_y + y) = arg_field.at(x, y);
-  }
-
-  Field&lt;T&gt;&amp; operator=(const Field&lt;T&gt;&amp; copy)
-  {
-    if (this != &amp;copy)
-      {
-        width  = copy.width;
-        height = copy.height;
-        vec    = copy.vec;
-      }
-    return *this;
-  }
-
-  const T&amp; operator[] (int i) const {
-    return vec[i];
-  }
-
-  T&amp; operator[] (int i) {
-    return vec[i];
-  }
-
-  T&amp; operator() (int x, int y) 
-  {
-    assert (x &gt;= 0 || x &lt; (int) width || y &gt;= 0 || y &lt; (int) height);
-    return vec [width*y + x];
-  }
-
-  const T&amp; operator() (int x, int y) const
-  {
-    assert (x &gt;= 0 || x &lt; (int) width || y &gt;= 0 || y &lt; (int) height);
-    return vec [width*y + x];
-  }
-  
-  inline const T&amp; at (int x, int y) const {
-    return vec [width*y + x];
-  }
-
-  inline T&amp; at (int x, int y) {
-    return (*this) (x, y);
-  }
-
-  /** Resize a field to a new size
-   *  @param pos_x The position of the old field in the new resized one
-   *  @param pos_y The position of the old field in the new resized one
-   **/
-  void resize(int w, int h, int pos_x = 0, int pos_y = 0) 
-  {
-    *this = Field&lt;T&gt;(*this, w, h, pos_x, pos_y);
-  }
-
-  void clear()
-  {
-    width  = 0;
-    height = 0;
-    vec.clear();
-  }
-
-  std::vector&lt;T&gt;&amp; get_data() { return vec; }
-  void set_data(const std::vector&lt;T&gt;&amp; d) { 
-    for(typename std::vector&lt;T&gt;::size_type i = 0; i &lt; vec.size() &amp;&amp; i &lt; d.size(); ++i)
-      vec[i] = d[i]; 
-  }
-
-  iterator begin () { return vec.begin (); }
-  iterator end () { return vec.end (); }
-
-  int size() const { return vec.size(); }
-  int get_width () const { return width; }
-  int get_height () const { return height; }
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/flexlay.cpp (from rev 712, trunk/flexlay/lib/flexlay.cxx)
===================================================================
--- trunk/flexlay/lib/flexlay.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/flexlay.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,105 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;ClanLib/core.h&gt;
+#include &lt;ClanLib/display.h&gt;
+#include &lt;ClanLib/gui.h&gt;
+#include &lt;ClanLib/guistylesilver.h&gt;
+#include &lt;ClanLib/gl.h&gt;
+#include &quot;config.h&quot;
+#include &quot;globals.hpp&quot;
+#include &quot;fonts.hpp&quot;
+#include &quot;flexlay.hpp&quot;
+
+Flexlay* Flexlay::current_ = 0;
+
+Flexlay::Flexlay()
+{
+  screen_width  = 800;
+  screen_height = 600;
+  fullscreen    = false;
+  allow_resize  = false;
+  use_opengl    = true;
+  
+  current_ = this;
+}
+
+CL_Signal_v2&lt;int, int&gt;&amp;
+Flexlay::sig_resize()
+{
+  return window-&gt;sig_resize();
+}
+
+void
+Flexlay::init(const std::string&amp; title, int width, int height, bool fullscreen_, bool allow_resize_)
+{
+  screen_width  = width;
+  screen_height = height;
+  fullscreen    = fullscreen_; 
+  allow_resize  = allow_resize_;
+
+  std::cout &lt;&lt; &quot;Flexlay::init()&quot; &lt;&lt; std::endl;
+  try {
+    #ifdef WIN32
+    CL_SetupCore::set_instance(GetModuleHandle(&quot;flexlay_wrap.dll&quot;));
+    #endif
+    CL_SetupCore::init();
+#ifdef HAVE_LIBSDL
+    if (use_opengl)
+      CL_SetupGL::init();
+    else
+      CL_SetupSDL::init();
+#else
+    CL_SetupGL::init();
+#endif
+    CL_SetupDisplay::init();
+    CL_SetupGUI::init();
+  
+    datadir = &quot;../data/&quot;;
+
+    window = new CL_DisplayWindow(title,
+                                  screen_width, screen_height, fullscreen, allow_resize);
+
+    resources = CL_ResourceManager(datadir + &quot;flexlay.xml&quot;);
+    Fonts::verdana11        = CL_Font(&quot;verdana11_black&quot;, &amp;resources);
+    Fonts::verdana11_yellow = CL_Font(&quot;verdana11_yellow&quot;, &amp;resources);
+  } catch (CL_Error&amp; err) {
+    std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
+  }
+}
+
+void
+Flexlay::deinit()
+{
+  std::cout &lt;&lt; &quot;Flexlay::deinit()&quot; &lt;&lt; std::endl;
+
+  CL_SetupDisplay::deinit();
+
+#ifdef HAVE_LIBSDL
+  if (use_opengl)
+    CL_SetupGL::deinit();
+  else
+    CL_SetupSDL::init();
+#else
+  CL_SetupGL::deinit();
+#endif
+
+  CL_SetupCore::deinit();
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/flexlay.cxx
===================================================================
--- trunk/flexlay/lib/flexlay.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/flexlay.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,105 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;ClanLib/core.h&gt;
-#include &lt;ClanLib/display.h&gt;
-#include &lt;ClanLib/gui.h&gt;
-#include &lt;ClanLib/guistylesilver.h&gt;
-#include &lt;ClanLib/gl.h&gt;
-#include &quot;config.h&quot;
-#include &quot;globals.hxx&quot;
-#include &quot;fonts.hxx&quot;
-#include &quot;flexlay.hxx&quot;
-
-Flexlay* Flexlay::current_ = 0;
-
-Flexlay::Flexlay()
-{
-  screen_width  = 800;
-  screen_height = 600;
-  fullscreen    = false;
-  allow_resize  = false;
-  use_opengl    = true;
-  
-  current_ = this;
-}
-
-CL_Signal_v2&lt;int, int&gt;&amp;
-Flexlay::sig_resize()
-{
-  return window-&gt;sig_resize();
-}
-
-void
-Flexlay::init(const std::string&amp; title, int width, int height, bool fullscreen_, bool allow_resize_)
-{
-  screen_width  = width;
-  screen_height = height;
-  fullscreen    = fullscreen_; 
-  allow_resize  = allow_resize_;
-
-  std::cout &lt;&lt; &quot;Flexlay::init()&quot; &lt;&lt; std::endl;
-  try {
-    #ifdef WIN32
-    CL_SetupCore::set_instance(GetModuleHandle(&quot;flexlay_wrap.dll&quot;));
-    #endif
-    CL_SetupCore::init();
-#ifdef HAVE_LIBSDL
-    if (use_opengl)
-      CL_SetupGL::init();
-    else
-      CL_SetupSDL::init();
-#else
-    CL_SetupGL::init();
-#endif
-    CL_SetupDisplay::init();
-    CL_SetupGUI::init();
-  
-    datadir = &quot;../data/&quot;;
-
-    window = new CL_DisplayWindow(title,
-                                  screen_width, screen_height, fullscreen, allow_resize);
-
-    resources = CL_ResourceManager(datadir + &quot;flexlay.xml&quot;);
-    Fonts::verdana11        = CL_Font(&quot;verdana11_black&quot;, &amp;resources);
-    Fonts::verdana11_yellow = CL_Font(&quot;verdana11_yellow&quot;, &amp;resources);
-  } catch (CL_Error&amp; err) {
-    std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
-  }
-}
-
-void
-Flexlay::deinit()
-{
-  std::cout &lt;&lt; &quot;Flexlay::deinit()&quot; &lt;&lt; std::endl;
-
-  CL_SetupDisplay::deinit();
-
-#ifdef HAVE_LIBSDL
-  if (use_opengl)
-    CL_SetupGL::deinit();
-  else
-    CL_SetupSDL::init();
-#else
-  CL_SetupGL::deinit();
-#endif
-
-  CL_SetupCore::deinit();
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/flexlay.hpp (from rev 712, trunk/flexlay/lib/flexlay.hxx)

Deleted: trunk/flexlay/lib/flexlay.hxx
===================================================================
--- trunk/flexlay/lib/flexlay.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/flexlay.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,106 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_FLEXLAY_HXX
-#define HEADER_FLEXLAY_HXX
-
-#include &lt;ClanLib/Display/display_window.h&gt;
-#include &lt;ClanLib/Core/Resources/resource_manager.h&gt;
-
-/*! \mainpage Flexlay - A Flexible Layered 2D Editor
-  
-\section intro Introduction
-
-Flexlay is a rather flexible layered editor mainly meant for editing
-game data such as levels, tilemaps, enemy placement and such. It
-provides a basic framework which makes it easy to add new
-functionality, special dialog windows and such needed to customize it
-for a specific game. Flexlay itself is actually a Python module and
-not an editor in itself, however due to reasonably simple Python
-scripts one can already have a fully working editor.
-
-\section structure Structure
-
-Flexlay provides the following basic classes on which everything else
-is build:
-
-Command: each operation on data is encapsuled in a Command object
-which provides undo/redo capability, together with a way to easily
-record macros and write scripts with it.
-
-EditorMapLayer: a map layer is the class that holds the data, special
-layers such as object or tilemap layers derive from this class to
-provide the capabilites needed to use them
-
-Tool: A tool manages and dispatches mouse input to Commands, thus
-giving the user an interactive way to manipulate map data.
-
-GUI: Flexlay provides a simple GUI framework that can be used from
-Python to create dialogboxes, add buttons to the main window and such.
-
-\section games Games
-
-Currently Flexlay supports the following games with different levels
-of completeness:
-
-netPanzer: fully working load/save and map editing capabilites
-
-SuperTux: fully working load/save and map editing capabilites, however
-a bit limited when it comes to object properties
-
-Windstille: fully working load/save support, however due to the game
-itself not being ready this is not so usefull
-
-Pingus: just very basic load support
-
-*/
-
-/** Flexlay holds the DisplayWindow and manages the graphic mode and
-    screen resolution that should be. Its the top most class that
-    needs to be inited before the rest becomes useable. FIXME: Make
-    Flexlay 'batchable' so that it can run without a GUI */
-class Flexlay
-{
-private:
-  CL_DisplayWindow* window;
-
-public:
-  int  screen_width;
-  int  screen_height;
-  bool fullscreen;
-  bool allow_resize;
-  bool use_opengl;
-
-  CL_ResourceManager resources;
-
-  static Flexlay* current() { return current_; }
-public:
-  static Flexlay* current_;
-
-  Flexlay();
-
-  CL_Signal_v2&lt;int, int&gt;&amp; sig_resize();
-
-  void init(const std::string&amp; title = &quot;Flexlay&quot;, int width = 800, int height = 600,
-            bool fullscreen = false, bool allow_resize = false);
-  void deinit();
-};
-
-#endif
-
-/* EOF */

Modified: trunk/flexlay/lib/flexlay_wrap.i
===================================================================
--- trunk/flexlay/lib/flexlay_wrap.i	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/flexlay_wrap.i	2009-11-22 03:02:03 UTC (rev 713)
@@ -22,76 +22,76 @@
 #include &lt;ClanLib/GUI/window.h&gt;
 #include &lt;ClanLib/Core/Math/rect.h&gt;
 #include &lt;ClanLib/Core/Math/point.h&gt;
-#include &quot;command.hxx&quot;
-#include &quot;paint_command.hxx&quot;
-#include &quot;object_move_command.hxx&quot;
-#include &quot;object_add_command.hxx&quot;
-#include &quot;object_delete_command.hxx&quot;
-#include &quot;tile.hxx&quot;
-#include &quot;tile_brush.hxx&quot;
-#include &quot;meta_data.hxx&quot;
-#include &quot;console.hxx&quot;
-#include &quot;blitter.hxx&quot;
+#include &quot;command.hpp&quot;
+#include &quot;paint_command.hpp&quot;
+#include &quot;object_move_command.hpp&quot;
+#include &quot;object_add_command.hpp&quot;
+#include &quot;object_delete_command.hpp&quot;
+#include &quot;tile.hpp&quot;
+#include &quot;tile_brush.hpp&quot;
+#include &quot;meta_data.hpp&quot;
+#include &quot;console.hpp&quot;
+#include &quot;blitter.hpp&quot;
 
-#include &quot;layer.hxx&quot;
-#include &quot;tilemap_layer.hxx&quot;
-#include &quot;object_layer.hxx&quot;
-#include &quot;onion_skin_layer.hxx&quot;
+#include &quot;layer.hpp&quot;
+#include &quot;tilemap_layer.hpp&quot;
+#include &quot;object_layer.hpp&quot;
+#include &quot;onion_skin_layer.hpp&quot;
 
-#include &quot;minimap.hxx&quot;
-#include &quot;editor_map.hxx&quot;
-#include &quot;workspace.hxx&quot;
-#include &quot;tileset.hxx&quot;
-#include &quot;editor_map_component.hxx&quot;
-#include &quot;flexlay.hxx&quot;
-#include &quot;globals.hxx&quot;
-#include &quot;gui_manager.hxx&quot;
-#include &quot;tile_selector.hxx&quot;
-#include &quot;object_brush.hxx&quot;
-#include &quot;object_selector.hxx&quot;
-#include &quot;icon.hxx&quot;
-#include &quot;window.hxx&quot;
-#include &quot;panel.hxx&quot;
-#include &quot;directory_view.hxx&quot;
-#include &quot;menu.hxx&quot;
-#include &quot;menubar.hxx&quot;
-#include &quot;scrollbar.hxx&quot;
-#include &quot;graphic_context_state.hxx&quot;
+#include &quot;minimap.hpp&quot;
+#include &quot;editor_map.hpp&quot;
+#include &quot;workspace.hpp&quot;
+#include &quot;tileset.hpp&quot;
+#include &quot;editor_map_component.hpp&quot;
+#include &quot;flexlay.hpp&quot;
+#include &quot;globals.hpp&quot;
+#include &quot;gui_manager.hpp&quot;
+#include &quot;tile_selector.hpp&quot;
+#include &quot;object_brush.hpp&quot;
+#include &quot;object_selector.hpp&quot;
+#include &quot;icon.hpp&quot;
+#include &quot;window.hpp&quot;
+#include &quot;panel.hpp&quot;
+#include &quot;directory_view.hpp&quot;
+#include &quot;menu.hpp&quot;
+#include &quot;menubar.hpp&quot;
+#include &quot;scrollbar.hpp&quot;
+#include &quot;graphic_context_state.hpp&quot;
  
-#include &quot;tools/workspace_move_tool.hxx&quot;
-#include &quot;tools/layer_move_tool.hxx&quot;
-#include &quot;tools/sketch_stroke_tool.hxx&quot;
-#include &quot;sketch_layer.hxx&quot;
-#include &quot;bitmap_layer.hxx&quot;
-#include &quot;stroke.hxx&quot;
-#include &quot;stroke_drawer.hxx&quot;
-#include &quot;drawer_properties.hxx&quot;
-#include &quot;sprite_stroke_drawer.hxx&quot;
-#include &quot;marker_stroke_drawer.hxx&quot;
-#include &quot;brushmask.hxx&quot;
-#include &quot;brush.hxx&quot;
-#include &quot;generated_brush.hxx&quot;
-#include &quot;sprite_brush.hxx&quot;
+#include &quot;tools/workspace_move_tool.hpp&quot;
+#include &quot;tools/layer_move_tool.hpp&quot;
+#include &quot;tools/sketch_stroke_tool.hpp&quot;
+#include &quot;sketch_layer.hpp&quot;
+#include &quot;bitmap_layer.hpp&quot;
+#include &quot;stroke.hpp&quot;
+#include &quot;stroke_drawer.hpp&quot;
+#include &quot;drawer_properties.hpp&quot;
+#include &quot;sprite_stroke_drawer.hpp&quot;
+#include &quot;marker_stroke_drawer.hpp&quot;
+#include &quot;brushmask.hpp&quot;
+#include &quot;brush.hpp&quot;
+#include &quot;generated_brush.hpp&quot;
+#include &quot;sprite_brush.hpp&quot;
 
-#include &quot;colorpicker.hxx&quot;
-#include &quot;slider.hxx&quot;
-#include &quot;tools/tilemap_paint_tool.hxx&quot;
-#include &quot;tools/tilemap_select_tool.hxx&quot;
-#include &quot;tools/objmap_select_tool.hxx&quot;
-#include &quot;objmap_sprite_object.hxx&quot;
-#include &quot;objmap_rect_object.hxx&quot;
-#include &quot;objmap_object.hxx&quot;
-#include &quot;tools/zoom_tool.hxx&quot;
-#include &quot;tools/zoom2_tool.hxx&quot;
-#include &quot;objmap_path_node.hxx&quot;
+#include &quot;colorpicker.hpp&quot;
+#include &quot;slider.hpp&quot;
+#include &quot;tools/tilemap_paint_tool.hpp&quot;
+#include &quot;tools/tilemap_select_tool.hpp&quot;
+#include &quot;tools/objmap_select_tool.hpp&quot;
+#include &quot;objmap_sprite_object.hpp&quot;
+#include &quot;objmap_rect_object.hpp&quot;
+#include &quot;objmap_object.hpp&quot;
+#include &quot;tools/zoom_tool.hpp&quot;
+#include &quot;tools/zoom2_tool.hpp&quot;
+#include &quot;objmap_path_node.hpp&quot;
 
-// #include &quot;netpanzer.hxx&quot; 
-#include &quot;helper.hxx&quot;
+// #include &quot;netpanzer.hpp&quot; 
+#include &quot;helper.hpp&quot;
 
 #ifdef SWIGRUBY
-#include &quot;ruby_sexpr_parser.hxx&quot;
-#include &quot;ruby_meta_data.hxx&quot;
-#include &quot;ruby_functor.hxx&quot;
+#include &quot;ruby_sexpr_parser.hpp&quot;
+#include &quot;ruby_meta_data.hpp&quot;
+#include &quot;ruby_functor.hpp&quot;
 
 VALUE ObjMapObject2Value(const ObjMapObject&amp; arg)
 {
@@ -137,76 +137,76 @@
 %template(Std_vector_Dab) std::vector&lt;Dab&gt;;
 
 %include &quot;clanlib.i&quot;
-%include &quot;command.hxx&quot;
-%include &quot;paint_command.hxx&quot;
-%include &quot;object_move_command.hxx&quot;
-%include &quot;object_add_command.hxx&quot;
-%include &quot;object_delete_command.hxx&quot;
-%include &quot;tile.hxx&quot;
-%include &quot;tile_brush.hxx&quot;
-%include &quot;meta_data.hxx&quot;
-%include &quot;console.hxx&quot;
-%include &quot;blitter.hxx&quot;
+%include &quot;command.hpp&quot;
+%include &quot;paint_command.hpp&quot;
+%include &quot;object_move_command.hpp&quot;
+%include &quot;object_add_command.hpp&quot;
+%include &quot;object_delete_command.hpp&quot;
+%include &quot;tile.hpp&quot;
+%include &quot;tile_brush.hpp&quot;
+%include &quot;meta_data.hpp&quot;
+%include &quot;console.hpp&quot;
+%include &quot;blitter.hpp&quot;
  
-%include &quot;layer.hxx&quot;
-%include &quot;tilemap_layer.hxx&quot;
-%include &quot;object_layer.hxx&quot;
-%include &quot;onion_skin_layer.hxx&quot;
+%include &quot;layer.hpp&quot;
+%include &quot;tilemap_layer.hpp&quot;
+%include &quot;object_layer.hpp&quot;
+%include &quot;onion_skin_layer.hpp&quot;
 
-%include &quot;editor_map.hxx&quot;
-%include &quot;workspace.hxx&quot;
-%include &quot;tileset.hxx&quot;
-%include &quot;editor_map_component.hxx&quot;
-%include &quot;flexlay.hxx&quot;
-%include &quot;globals.hxx&quot;
-%include &quot;gui_manager.hxx&quot;
-%include &quot;tile_selector.hxx&quot;
-%include &quot;object_brush.hxx&quot;
-%include &quot;object_selector.hxx&quot;
-%include &quot;icon.hxx&quot;
-%include &quot;window.hxx&quot;
-%include &quot;panel.hxx&quot;
-%include &quot;minimap.hxx&quot;
-%include &quot;directory_view.hxx&quot;
-%include &quot;menu.hxx&quot;
-%include &quot;menubar.hxx&quot;
-%include &quot;scrollbar.hxx&quot;
+%include &quot;editor_map.hpp&quot;
+%include &quot;workspace.hpp&quot;
+%include &quot;tileset.hpp&quot;
+%include &quot;editor_map_component.hpp&quot;
+%include &quot;flexlay.hpp&quot;
+%include &quot;globals.hpp&quot;
+%include &quot;gui_manager.hpp&quot;
+%include &quot;tile_selector.hpp&quot;
+%include &quot;object_brush.hpp&quot;
+%include &quot;object_selector.hpp&quot;
+%include &quot;icon.hpp&quot;
+%include &quot;window.hpp&quot;
+%include &quot;panel.hpp&quot;
+%include &quot;minimap.hpp&quot;
+%include &quot;directory_view.hpp&quot;
+%include &quot;menu.hpp&quot;
+%include &quot;menubar.hpp&quot;
+%include &quot;scrollbar.hpp&quot;
 
-%include &quot;tools/workspace_move_tool.hxx&quot;
-%include &quot;tools/layer_move_tool.hxx&quot;
-%include &quot;tools/sketch_stroke_tool.hxx&quot;
-%include &quot;sketch_layer.hxx&quot;
-%include &quot;bitmap_layer.hxx&quot;
-%include &quot;stroke.hxx&quot;
-%include &quot;stroke_drawer.hxx&quot;
-%include &quot;drawer_properties.hxx&quot;
-%include &quot;sprite_stroke_drawer.hxx&quot;
-%include &quot;marker_stroke_drawer.hxx&quot;
-%include &quot;brushmask.hxx&quot;
-%include &quot;brush.hxx&quot;
-%include &quot;generated_brush.hxx&quot;
-%include &quot;sprite_brush.hxx&quot;
+%include &quot;tools/workspace_move_tool.hpp&quot;
+%include &quot;tools/layer_move_tool.hpp&quot;
+%include &quot;tools/sketch_stroke_tool.hpp&quot;
+%include &quot;sketch_layer.hpp&quot;
+%include &quot;bitmap_layer.hpp&quot;
+%include &quot;stroke.hpp&quot;
+%include &quot;stroke_drawer.hpp&quot;
+%include &quot;drawer_properties.hpp&quot;
+%include &quot;sprite_stroke_drawer.hpp&quot;
+%include &quot;marker_stroke_drawer.hpp&quot;
+%include &quot;brushmask.hpp&quot;
+%include &quot;brush.hpp&quot;
+%include &quot;generated_brush.hpp&quot;
+%include &quot;sprite_brush.hpp&quot;
 
-%include &quot;colorpicker.hxx&quot;
-%include &quot;slider.hxx&quot;
-%include &quot;tools/tilemap_paint_tool.hxx&quot;
-%include &quot;tools/tilemap_select_tool.hxx&quot;
-%include &quot;tools/objmap_select_tool.hxx&quot;
-%include &quot;objmap_sprite_object.hxx&quot;
-%include &quot;objmap_rect_object.hxx&quot;
-%include &quot;objmap_object.hxx&quot;
-%include &quot;tools/zoom_tool.hxx&quot; 
-%include &quot;tools/zoom2_tool.hxx&quot; 
-%include &quot;graphic_context_state.hxx&quot;
-%include &quot;objmap_path_node.hxx&quot;
-# %include &quot;scripting/editor.hxx&quot;
+%include &quot;colorpicker.hpp&quot;
+%include &quot;slider.hpp&quot;
+%include &quot;tools/tilemap_paint_tool.hpp&quot;
+%include &quot;tools/tilemap_select_tool.hpp&quot;
+%include &quot;tools/objmap_select_tool.hpp&quot;
+%include &quot;objmap_sprite_object.hpp&quot;
+%include &quot;objmap_rect_object.hpp&quot;
+%include &quot;objmap_object.hpp&quot;
+%include &quot;tools/zoom_tool.hpp&quot; 
+%include &quot;tools/zoom2_tool.hpp&quot; 
+%include &quot;graphic_context_state.hpp&quot;
+%include &quot;objmap_path_node.hpp&quot;
+# %include &quot;scripting/editor.hpp&quot;
 
-// %include &quot;netpanzer.hxx&quot; 
-%include &quot;helper.hxx&quot;
+// %include &quot;netpanzer.hpp&quot; 
+%include &quot;helper.hpp&quot;
 
 #ifdef SWIGRUBY
-%include &quot;../ruby/ruby_meta_data.hxx&quot;
-%include &quot;../ruby/ruby_sexpr_parser.hxx&quot;
+%include &quot;../ruby/ruby_meta_data.hpp&quot;
+%include &quot;../ruby/ruby_sexpr_parser.hpp&quot;
 #endif
 
 // 8

Copied: trunk/flexlay/lib/fonts.cpp (from rev 712, trunk/flexlay/lib/fonts.cxx)
===================================================================
--- trunk/flexlay/lib/fonts.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/fonts.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,24 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &quot;fonts.hpp&quot;
+
+CL_Font Fonts::verdana11;
+CL_Font Fonts::verdana11_yellow;
+
+/* EOF */

Deleted: trunk/flexlay/lib/fonts.cxx
===================================================================
--- trunk/flexlay/lib/fonts.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/fonts.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,24 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &quot;fonts.hxx&quot;
-
-CL_Font Fonts::verdana11;
-CL_Font Fonts::verdana11_yellow;
-
-/* EOF */

Copied: trunk/flexlay/lib/fonts.hpp (from rev 712, trunk/flexlay/lib/fonts.hxx)

Deleted: trunk/flexlay/lib/fonts.hxx
===================================================================
--- trunk/flexlay/lib/fonts.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/fonts.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,34 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_FONTS_HXX
-#define HEADER_FONTS_HXX
-
-#include &lt;ClanLib/Display/font.h&gt;
-
-/** */
-class Fonts
-{
-public:
-  static CL_Font verdana11;
-  static CL_Font verdana11_yellow;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/generated_brush.cpp (from rev 712, trunk/flexlay/lib/generated_brush.cxx)
===================================================================
--- trunk/flexlay/lib/generated_brush.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/generated_brush.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,185 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;ClanLib/Display/sprite_description.h&gt;
+#include &quot;brush_impl.hpp&quot;
+#include &quot;generated_brush.hpp&quot;
+
+class GeneratedBrushImpl : public BrushImpl
+{
+public:
+  BrushShape shape;
+  float  radius;
+  int    spikes;
+  float  hardness;
+  float  aspect_ratio;
+  float  angle;
+
+  /** When set surface is out of date and needs updating */
+  bool dirty;
+
+  CL_Sprite sprite;
+
+  virtual ~GeneratedBrushImpl() {}
+  CL_Sprite get_sprite();
+  void update();
+  BrushImpl* clone() const;
+};
+
+GeneratedBrush::GeneratedBrush(const Brush&amp; brush)
+: impl(dynamic_cast&lt;GeneratedBrushImpl*&gt;(brush.impl.get())) // FIXME: WANT WORK WITH REAL SMARTPTR!!!
+{
+}
+
+GeneratedBrush::GeneratedBrush(BrushShape shape,
+                               float  radius,
+                               int    spikes,        /* 2 - 20     */
+                               float  hardness,      /* 0.0 - 1.0  */
+                               float  aspect_ratio,  /* y/x        */
+                               float  angle)
+  : impl(new GeneratedBrushImpl())
+{
+  impl-&gt;shape        = shape;
+  impl-&gt;radius       = radius;
+  impl-&gt;spikes       = spikes;
+  impl-&gt;hardness     = hardness;
+  impl-&gt;aspect_ratio = aspect_ratio;
+  impl-&gt;angle        = angle;
+  impl-&gt;dirty        = true;
+}
+
+void
+GeneratedBrushImpl::update()
+{
+  if (dirty)
+    {
+      CL_SpriteDescription desc;
+      desc.add_frame(generate_brushmask(shape,
+                                        radius, 
+                                        spikes,
+                                        hardness, 
+                                        aspect_ratio, 
+                                        angle));
+      sprite = CL_Sprite(desc);
+      sprite.set_alignment(origin_center);
+      dirty = false;
+    }
+}
+
+void
+GeneratedBrush::set_shape(BrushShape shape)
+{
+  impl-&gt;shape = shape;
+  impl-&gt;dirty = true;
+}
+
+BrushShape
+GeneratedBrush::get_shape()
+{
+  return impl-&gt;shape;
+}
+
+void
+GeneratedBrush::set_radius(float radius)
+{
+  impl-&gt;radius = radius;
+  impl-&gt;dirty = true;
+}
+
+float
+GeneratedBrush::get_radius()
+{
+  return impl-&gt;radius;
+}
+
+void
+GeneratedBrush::set_spikes(int spikes)
+{
+  impl-&gt;spikes = spikes;
+  impl-&gt;dirty = true;
+}
+
+int
+GeneratedBrush::get_spikes()
+{
+  return impl-&gt;spikes;
+}
+
+void
+GeneratedBrush::set_hardness(float hardness)
+{
+  impl-&gt;hardness = hardness;
+  impl-&gt;dirty = true;
+}
+
+float
+GeneratedBrush::get_hardness()
+{
+  return impl-&gt;hardness;
+}
+
+void
+GeneratedBrush::set_aspect_ratio(float aspect)
+{
+  impl-&gt;aspect_ratio = aspect;
+  impl-&gt;dirty = true;
+}
+
+float
+GeneratedBrush::get_aspect_ratio()
+{
+  return impl-&gt;aspect_ratio;
+}
+
+void
+GeneratedBrush::set_angle(float angle)
+{
+  impl-&gt;angle = angle;
+  impl-&gt;dirty = true;
+}
+
+float
+GeneratedBrush::get_angle()
+{
+  return impl-&gt;angle;
+}
+
+CL_Sprite
+GeneratedBrushImpl::get_sprite() 
+{
+  update();
+  return sprite;
+}
+
+BrushImpl*
+GeneratedBrushImpl::clone() const
+{
+  // FIXME: Make this Copy-On-Write cloning, else it might get a
+  // little bit expensive with all the CL_Sprite's per stroke
+  GeneratedBrushImpl* c = new GeneratedBrushImpl();
+  *c = *this;
+  return c;
+}
+
+Brush
+GeneratedBrush::to_brush()
+{
+  return Brush(impl);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/generated_brush.cxx
===================================================================
--- trunk/flexlay/lib/generated_brush.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/generated_brush.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,185 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;ClanLib/Display/sprite_description.h&gt;
-#include &quot;brush_impl.hxx&quot;
-#include &quot;generated_brush.hxx&quot;
-
-class GeneratedBrushImpl : public BrushImpl
-{
-public:
-  BrushShape shape;
-  float  radius;
-  int    spikes;
-  float  hardness;
-  float  aspect_ratio;
-  float  angle;
-
-  /** When set surface is out of date and needs updating */
-  bool dirty;
-
-  CL_Sprite sprite;
-
-  virtual ~GeneratedBrushImpl() {}
-  CL_Sprite get_sprite();
-  void update();
-  BrushImpl* clone() const;
-};
-
-GeneratedBrush::GeneratedBrush(const Brush&amp; brush)
-: impl(dynamic_cast&lt;GeneratedBrushImpl*&gt;(brush.impl.get())) // FIXME: WANT WORK WITH REAL SMARTPTR!!!
-{
-}
-
-GeneratedBrush::GeneratedBrush(BrushShape shape,
-                               float  radius,
-                               int    spikes,        /* 2 - 20     */
-                               float  hardness,      /* 0.0 - 1.0  */
-                               float  aspect_ratio,  /* y/x        */
-                               float  angle)
-  : impl(new GeneratedBrushImpl())
-{
-  impl-&gt;shape        = shape;
-  impl-&gt;radius       = radius;
-  impl-&gt;spikes       = spikes;
-  impl-&gt;hardness     = hardness;
-  impl-&gt;aspect_ratio = aspect_ratio;
-  impl-&gt;angle        = angle;
-  impl-&gt;dirty        = true;
-}
-
-void
-GeneratedBrushImpl::update()
-{
-  if (dirty)
-    {
-      CL_SpriteDescription desc;
-      desc.add_frame(generate_brushmask(shape,
-                                        radius, 
-                                        spikes,
-                                        hardness, 
-                                        aspect_ratio, 
-                                        angle));
-      sprite = CL_Sprite(desc);
-      sprite.set_alignment(origin_center);
-      dirty = false;
-    }
-}
-
-void
-GeneratedBrush::set_shape(BrushShape shape)
-{
-  impl-&gt;shape = shape;
-  impl-&gt;dirty = true;
-}
-
-BrushShape
-GeneratedBrush::get_shape()
-{
-  return impl-&gt;shape;
-}
-
-void
-GeneratedBrush::set_radius(float radius)
-{
-  impl-&gt;radius = radius;
-  impl-&gt;dirty = true;
-}
-
-float
-GeneratedBrush::get_radius()
-{
-  return impl-&gt;radius;
-}
-
-void
-GeneratedBrush::set_spikes(int spikes)
-{
-  impl-&gt;spikes = spikes;
-  impl-&gt;dirty = true;
-}
-
-int
-GeneratedBrush::get_spikes()
-{
-  return impl-&gt;spikes;
-}
-
-void
-GeneratedBrush::set_hardness(float hardness)
-{
-  impl-&gt;hardness = hardness;
-  impl-&gt;dirty = true;
-}
-
-float
-GeneratedBrush::get_hardness()
-{
-  return impl-&gt;hardness;
-}
-
-void
-GeneratedBrush::set_aspect_ratio(float aspect)
-{
-  impl-&gt;aspect_ratio = aspect;
-  impl-&gt;dirty = true;
-}
-
-float
-GeneratedBrush::get_aspect_ratio()
-{
-  return impl-&gt;aspect_ratio;
-}
-
-void
-GeneratedBrush::set_angle(float angle)
-{
-  impl-&gt;angle = angle;
-  impl-&gt;dirty = true;
-}
-
-float
-GeneratedBrush::get_angle()
-{
-  return impl-&gt;angle;
-}
-
-CL_Sprite
-GeneratedBrushImpl::get_sprite() 
-{
-  update();
-  return sprite;
-}
-
-BrushImpl*
-GeneratedBrushImpl::clone() const
-{
-  // FIXME: Make this Copy-On-Write cloning, else it might get a
-  // little bit expensive with all the CL_Sprite's per stroke
-  GeneratedBrushImpl* c = new GeneratedBrushImpl();
-  *c = *this;
-  return c;
-}
-
-Brush
-GeneratedBrush::to_brush()
-{
-  return Brush(impl);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/generated_brush.hpp (from rev 712, trunk/flexlay/lib/generated_brush.hxx)
===================================================================
--- trunk/flexlay/lib/generated_brush.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/generated_brush.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,66 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_GENERATED_BRUSH_HXX
+#define HEADER_GENERATED_BRUSH_HXX
+
+#include &quot;shared_ptr.hpp&quot;
+#include &quot;brushmask.hpp&quot;
+#include &quot;brush.hpp&quot;
+
+class GeneratedBrushImpl;
+
+/** */
+class GeneratedBrush
+{
+private:
+public:
+  GeneratedBrush(const Brush&amp; brush);
+  GeneratedBrush(BrushShape shape,
+                 float  radius,
+                 int    spikes,        /* 2 - 20     */
+                 float  hardness,      /* 0.0 - 1.0  */
+                 float  aspect_ratio,  /* y/x        */
+                 float  angle);
+
+  void set_shape(BrushShape shape);
+  BrushShape get_shape();
+
+  void  set_radius(float radius);
+  float get_radius();
+
+  void  set_spikes(int spikes);
+  int   get_spikes();
+
+  void  set_hardness(float hardness);
+  float get_hardness();
+
+  void  set_aspect_ratio(float aspect);
+  float get_aspect_ratio();
+
+  void  set_angle(float angle);
+  float get_angle();
+
+  Brush to_brush();
+private:
+  SharedPtr&lt;GeneratedBrushImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/generated_brush.hxx
===================================================================
--- trunk/flexlay/lib/generated_brush.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/generated_brush.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,66 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_GENERATED_BRUSH_HXX
-#define HEADER_GENERATED_BRUSH_HXX
-
-#include &quot;shared_ptr.hxx&quot;
-#include &quot;brushmask.hxx&quot;
-#include &quot;brush.hxx&quot;
-
-class GeneratedBrushImpl;
-
-/** */
-class GeneratedBrush
-{
-private:
-public:
-  GeneratedBrush(const Brush&amp; brush);
-  GeneratedBrush(BrushShape shape,
-                 float  radius,
-                 int    spikes,        /* 2 - 20     */
-                 float  hardness,      /* 0.0 - 1.0  */
-                 float  aspect_ratio,  /* y/x        */
-                 float  angle);
-
-  void set_shape(BrushShape shape);
-  BrushShape get_shape();
-
-  void  set_radius(float radius);
-  float get_radius();
-
-  void  set_spikes(int spikes);
-  int   get_spikes();
-
-  void  set_hardness(float hardness);
-  float get_hardness();
-
-  void  set_aspect_ratio(float aspect);
-  float get_aspect_ratio();
-
-  void  set_angle(float angle);
-  float get_angle();
-
-  Brush to_brush();
-private:
-  SharedPtr&lt;GeneratedBrushImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/globals.cpp (from rev 712, trunk/flexlay/lib/globals.cxx)
===================================================================
--- trunk/flexlay/lib/globals.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/globals.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,27 @@
+//  $Id: globals.cxx,v 1.6 2003/11/07 22:41:18 grumbel Exp $
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &quot;globals.hpp&quot;
+
+std::string datadir;
+std::string bindir;
+std::string homedir;
+
+int  debug = 0;
+
+/* EOF */

Deleted: trunk/flexlay/lib/globals.cxx
===================================================================
--- trunk/flexlay/lib/globals.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/globals.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,27 +0,0 @@
-//  $Id: globals.cxx,v 1.6 2003/11/07 22:41:18 grumbel Exp $
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &quot;globals.hxx&quot;
-
-std::string datadir;
-std::string bindir;
-std::string homedir;
-
-int  debug = 0;
-
-/* EOF */

Copied: trunk/flexlay/lib/globals.hpp (from rev 712, trunk/flexlay/lib/globals.hxx)
===================================================================
--- trunk/flexlay/lib/globals.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/globals.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,38 @@
+//  $Id: globals.hpp,v 1.11 2003/11/07 13:00:39 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2000 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef GLOBALS_HXX
+#define GLOBALS_HXX
+
+#include &lt;string&gt;
+#include &lt;ClanLib/Core/Resources/resource_manager.h&gt;
+
+/** datadir =&gt; /usr/local/share/games/windstille/ */
+extern std::string datadir;
+
+/** bindir =&gt; /usr/local/games/ */
+extern std::string bindir;
+
+/** homedir =&gt; /home/juser/.windstille/ */
+extern std::string homedir;
+
+extern int   debug;
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/globals.hxx
===================================================================
--- trunk/flexlay/lib/globals.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/globals.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,38 +0,0 @@
-//  $Id: globals.hxx,v 1.11 2003/11/07 13:00:39 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2000 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef GLOBALS_HXX
-#define GLOBALS_HXX
-
-#include &lt;string&gt;
-#include &lt;ClanLib/Core/Resources/resource_manager.h&gt;
-
-/** datadir =&gt; /usr/local/share/games/windstille/ */
-extern std::string datadir;
-
-/** bindir =&gt; /usr/local/games/ */
-extern std::string bindir;
-
-/** homedir =&gt; /home/juser/.windstille/ */
-extern std::string homedir;
-
-extern int   debug;
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/graphic_context_state.cpp (from rev 712, trunk/flexlay/lib/graphic_context_state.cxx)
===================================================================
--- trunk/flexlay/lib/graphic_context_state.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/graphic_context_state.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,201 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;ClanLib/Display/display.h&gt;
+#include &lt;ClanLib/Display/display_window.h&gt;
+#include &lt;ClanLib/Display/graphic_context.h&gt;
+#include &lt;ClanLib/GUI/component.h&gt;
+#include &lt;math.h&gt;
+#include &quot;graphic_context_state.hpp&quot;
+
+class GraphicContextStateImpl
+{
+public:
+  int width;
+  int height;
+  
+  CL_Pointf offset;
+  float zoom;
+  float rotation;
+};
+
+GraphicContextState::GraphicContextState()
+  : impl(new GraphicContextStateImpl())
+{
+  impl-&gt;width  = 1;
+  impl-&gt;height = 1; 
+  impl-&gt;offset = CL_Pointf(0,0);
+  impl-&gt;zoom   = 1.0f;
+  impl-&gt;rotation = 0;
+}
+
+GraphicContextState::GraphicContextState(int w, int h)
+  : impl(new GraphicContextStateImpl())
+{  
+  impl-&gt;width  = w;
+  impl-&gt;height = h;
+  impl-&gt;offset = CL_Pointf(0,0); 
+  impl-&gt;zoom   = 1.0f;
+  impl-&gt;rotation = 0;
+}
+
+void
+GraphicContextState::set_size(int w, int h)
+{
+  impl-&gt;width  = w;
+  impl-&gt;height = h;
+}
+
+void
+GraphicContextState::push(CL_GraphicContext* gc)
+{
+  if (gc == 0)
+    gc = CL_Display::get_current_window()-&gt;get_gc();
+  
+  gc-&gt;push_modelview();
+
+  gc-&gt;add_translate(impl-&gt;width/2, impl-&gt;height/2);
+  gc-&gt;add_rotate(impl-&gt;rotation, 0, 0, 1.0);
+  gc-&gt;add_translate(-impl-&gt;width/2, -impl-&gt;height/2);
+
+  gc-&gt;add_scale(get_zoom(), get_zoom());
+  gc-&gt;add_translate(impl-&gt;offset.x, impl-&gt;offset.y);
+}
+
+void
+GraphicContextState::pop(CL_GraphicContext* gc)
+{
+  if (gc == 0)
+    gc = CL_Display::get_current_window()-&gt;get_gc();
+  
+  gc-&gt;pop_modelview();
+}
+
+CL_Rectf
+GraphicContextState::get_clip_rect()
+{
+  return CL_Rectf(CL_Pointf(-impl-&gt;offset.x,
+                            -impl-&gt;offset.y),
+                  CL_Sizef(get_width()  / impl-&gt;zoom,
+                           get_height() / impl-&gt;zoom));
+}
+
+void
+GraphicContextState::set_pos(const CL_Pointf&amp; pos)
+{
+  impl-&gt;offset.x = -pos.x + (get_width()/2  / impl-&gt;zoom);
+  impl-&gt;offset.y = -pos.y + (get_height()/2 / impl-&gt;zoom);
+}
+
+CL_Pointf
+GraphicContextState::get_pos() const
+{
+  return CL_Pointf(-impl-&gt;offset.x + (get_width()/2  / impl-&gt;zoom),
+                   -impl-&gt;offset.y + (get_height()/2  / impl-&gt;zoom));
+}
+
+void
+GraphicContextState::set_zoom(CL_Pointf pos, float z)
+{
+  float old_zoom = impl-&gt;zoom;
+  set_zoom(z);
+  impl-&gt;offset.x = pos.x/impl-&gt;zoom - pos.x/old_zoom + impl-&gt;offset.x;
+  impl-&gt;offset.y = pos.y/impl-&gt;zoom - pos.y/old_zoom + impl-&gt;offset.y;
+}
+
+void
+GraphicContextState::set_zoom(float z)
+{
+  impl-&gt;zoom = z;
+}
+
+float
+GraphicContextState::get_zoom()
+{
+  return impl-&gt;zoom;
+}
+
+void
+GraphicContextState::zoom_to (const CL_Rectf&amp; rect)
+{
+  float center_x = (rect.left + rect.right) / 2.0f;
+  float center_y = (rect.top + rect.bottom) / 2.0f;
+
+  float width  = rect.right - rect.left;
+  float height = rect.bottom - rect.top;
+  float screen_relation = float(get_height())/float(get_width ());
+  float rect_relation   = height/width; 
+  
+  //std::cout &lt;&lt; &quot;Screen: &quot; &lt;&lt; screen_relation &lt;&lt; &quot; Zoom: &quot; &lt;&lt; rect_relation &lt;&lt; std::endl;
+  if (rect_relation &lt; screen_relation) // take width, ignore height
+    {
+      impl-&gt;zoom = get_width()/width; 
+    }
+  else // take height, ignore width
+    {
+      impl-&gt;zoom = get_height()/height;
+    }
+
+  impl-&gt;offset.x = (get_width()  / (2*impl-&gt;zoom)) - center_x;
+  impl-&gt;offset.y = (get_height() / (2*impl-&gt;zoom)) - center_y;
+}
+
+CL_Pointf
+GraphicContextState::screen2world(const CL_Point&amp; pos_)
+{
+  CL_Pointf pos = pos_;
+  float sa = sin(-impl-&gt;rotation/180.0f*M_PI);
+  float ca = cos(-impl-&gt;rotation/180.0f*M_PI);
+
+  float dx = pos.x - impl-&gt;width/2;
+  float dy = pos.y - impl-&gt;height/2;
+
+  pos.x = impl-&gt;width/2  + (ca * dx - sa * dy);
+  pos.y = impl-&gt;height/2 + (sa * dx + ca * dy);
+
+  CL_Pointf p((float(pos.x) / impl-&gt;zoom) - impl-&gt;offset.x, 
+              (float(pos.y) / impl-&gt;zoom) - impl-&gt;offset.y);
+
+  return p;
+}
+
+void
+GraphicContextState::set_rotation(float angle)
+{
+  impl-&gt;rotation = angle;
+}
+
+float
+GraphicContextState::get_rotation()
+{
+  return impl-&gt;rotation;
+}
+
+int
+GraphicContextState::get_width()  const 
+{
+  return impl-&gt;width; 
+}
+
+int
+GraphicContextState::get_height() const 
+{ 
+  return impl-&gt;height; 
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/graphic_context_state.cxx
===================================================================
--- trunk/flexlay/lib/graphic_context_state.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/graphic_context_state.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,201 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;ClanLib/Display/display.h&gt;
-#include &lt;ClanLib/Display/display_window.h&gt;
-#include &lt;ClanLib/Display/graphic_context.h&gt;
-#include &lt;ClanLib/GUI/component.h&gt;
-#include &lt;math.h&gt;
-#include &quot;graphic_context_state.hxx&quot;
-
-class GraphicContextStateImpl
-{
-public:
-  int width;
-  int height;
-  
-  CL_Pointf offset;
-  float zoom;
-  float rotation;
-};
-
-GraphicContextState::GraphicContextState()
-  : impl(new GraphicContextStateImpl())
-{
-  impl-&gt;width  = 1;
-  impl-&gt;height = 1; 
-  impl-&gt;offset = CL_Pointf(0,0);
-  impl-&gt;zoom   = 1.0f;
-  impl-&gt;rotation = 0;
-}
-
-GraphicContextState::GraphicContextState(int w, int h)
-  : impl(new GraphicContextStateImpl())
-{  
-  impl-&gt;width  = w;
-  impl-&gt;height = h;
-  impl-&gt;offset = CL_Pointf(0,0); 
-  impl-&gt;zoom   = 1.0f;
-  impl-&gt;rotation = 0;
-}
-
-void
-GraphicContextState::set_size(int w, int h)
-{
-  impl-&gt;width  = w;
-  impl-&gt;height = h;
-}
-
-void
-GraphicContextState::push(CL_GraphicContext* gc)
-{
-  if (gc == 0)
-    gc = CL_Display::get_current_window()-&gt;get_gc();
-  
-  gc-&gt;push_modelview();
-
-  gc-&gt;add_translate(impl-&gt;width/2, impl-&gt;height/2);
-  gc-&gt;add_rotate(impl-&gt;rotation, 0, 0, 1.0);
-  gc-&gt;add_translate(-impl-&gt;width/2, -impl-&gt;height/2);
-
-  gc-&gt;add_scale(get_zoom(), get_zoom());
-  gc-&gt;add_translate(impl-&gt;offset.x, impl-&gt;offset.y);
-}
-
-void
-GraphicContextState::pop(CL_GraphicContext* gc)
-{
-  if (gc == 0)
-    gc = CL_Display::get_current_window()-&gt;get_gc();
-  
-  gc-&gt;pop_modelview();
-}
-
-CL_Rectf
-GraphicContextState::get_clip_rect()
-{
-  return CL_Rectf(CL_Pointf(-impl-&gt;offset.x,
-                            -impl-&gt;offset.y),
-                  CL_Sizef(get_width()  / impl-&gt;zoom,
-                           get_height() / impl-&gt;zoom));
-}
-
-void
-GraphicContextState::set_pos(const CL_Pointf&amp; pos)
-{
-  impl-&gt;offset.x = -pos.x + (get_width()/2  / impl-&gt;zoom);
-  impl-&gt;offset.y = -pos.y + (get_height()/2 / impl-&gt;zoom);
-}
-
-CL_Pointf
-GraphicContextState::get_pos() const
-{
-  return CL_Pointf(-impl-&gt;offset.x + (get_width()/2  / impl-&gt;zoom),
-                   -impl-&gt;offset.y + (get_height()/2  / impl-&gt;zoom));
-}
-
-void
-GraphicContextState::set_zoom(CL_Pointf pos, float z)
-{
-  float old_zoom = impl-&gt;zoom;
-  set_zoom(z);
-  impl-&gt;offset.x = pos.x/impl-&gt;zoom - pos.x/old_zoom + impl-&gt;offset.x;
-  impl-&gt;offset.y = pos.y/impl-&gt;zoom - pos.y/old_zoom + impl-&gt;offset.y;
-}
-
-void
-GraphicContextState::set_zoom(float z)
-{
-  impl-&gt;zoom = z;
-}
-
-float
-GraphicContextState::get_zoom()
-{
-  return impl-&gt;zoom;
-}
-
-void
-GraphicContextState::zoom_to (const CL_Rectf&amp; rect)
-{
-  float center_x = (rect.left + rect.right) / 2.0f;
-  float center_y = (rect.top + rect.bottom) / 2.0f;
-
-  float width  = rect.right - rect.left;
-  float height = rect.bottom - rect.top;
-  float screen_relation = float(get_height())/float(get_width ());
-  float rect_relation   = height/width; 
-  
-  //std::cout &lt;&lt; &quot;Screen: &quot; &lt;&lt; screen_relation &lt;&lt; &quot; Zoom: &quot; &lt;&lt; rect_relation &lt;&lt; std::endl;
-  if (rect_relation &lt; screen_relation) // take width, ignore height
-    {
-      impl-&gt;zoom = get_width()/width; 
-    }
-  else // take height, ignore width
-    {
-      impl-&gt;zoom = get_height()/height;
-    }
-
-  impl-&gt;offset.x = (get_width()  / (2*impl-&gt;zoom)) - center_x;
-  impl-&gt;offset.y = (get_height() / (2*impl-&gt;zoom)) - center_y;
-}
-
-CL_Pointf
-GraphicContextState::screen2world(const CL_Point&amp; pos_)
-{
-  CL_Pointf pos = pos_;
-  float sa = sin(-impl-&gt;rotation/180.0f*M_PI);
-  float ca = cos(-impl-&gt;rotation/180.0f*M_PI);
-
-  float dx = pos.x - impl-&gt;width/2;
-  float dy = pos.y - impl-&gt;height/2;
-
-  pos.x = impl-&gt;width/2  + (ca * dx - sa * dy);
-  pos.y = impl-&gt;height/2 + (sa * dx + ca * dy);
-
-  CL_Pointf p((float(pos.x) / impl-&gt;zoom) - impl-&gt;offset.x, 
-              (float(pos.y) / impl-&gt;zoom) - impl-&gt;offset.y);
-
-  return p;
-}
-
-void
-GraphicContextState::set_rotation(float angle)
-{
-  impl-&gt;rotation = angle;
-}
-
-float
-GraphicContextState::get_rotation()
-{
-  return impl-&gt;rotation;
-}
-
-int
-GraphicContextState::get_width()  const 
-{
-  return impl-&gt;width; 
-}
-
-int
-GraphicContextState::get_height() const 
-{ 
-  return impl-&gt;height; 
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/graphic_context_state.hpp (from rev 712, trunk/flexlay/lib/graphic_context_state.hxx)
===================================================================
--- trunk/flexlay/lib/graphic_context_state.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/graphic_context_state.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,78 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_GRAPHIC_CONTEXT_STATE_HXX
+#define HEADER_GRAPHIC_CONTEXT_STATE_HXX
+
+#include &lt;ClanLib/Core/Math/point.h&gt;
+#include &lt;ClanLib/Core/Math/rect.h&gt;
+#include &quot;shared_ptr.hpp&quot;
+
+class CL_GraphicContext;
+
+class GraphicContextStateImpl;
+
+/** Helper class for capturing the state of a GraphicContext, with
+    additional convenience functions to make handling GraphicContexts
+    easier */
+class GraphicContextState
+{
+public:
+  GraphicContextState();
+  GraphicContextState(int w, int h);
+
+  void set_size(int w, int h);
+
+  void push(CL_GraphicContext* gc = 0);
+  void pop (CL_GraphicContext* gc = 0);
+
+  /** Return a rectangle in world coordinates that represents the area
+      visible on the screen */
+  CL_Rectf get_clip_rect();
+
+  int get_width()  const;
+  int get_height() const;
+
+  /** Set the current rotation angel */
+  void  set_rotation(float angle);
+
+  /** Return the current rotation angel */
+  float get_rotation();
+
+  /** Move the center of the visible area to pos */
+  void      set_pos(const CL_Pointf&amp; pos);
+  CL_Pointf get_pos() const;
+
+  /** Set zoom to z, while ensuring that the screen position \a pos
+      (normaly the position of the mouse pointer) stays in the same
+      position even after zoomed in/out */
+  void  set_zoom(CL_Pointf pos, float z);
+  void  set_zoom(float z);
+  float get_zoom(); 
+
+  void zoom_to (const CL_Rectf&amp; rect);
+
+  CL_Pointf screen2world(const CL_Point&amp; pos);
+
+private:
+  SharedPtr&lt;GraphicContextStateImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/graphic_context_state.hxx
===================================================================
--- trunk/flexlay/lib/graphic_context_state.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/graphic_context_state.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,78 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_GRAPHIC_CONTEXT_STATE_HXX
-#define HEADER_GRAPHIC_CONTEXT_STATE_HXX
-
-#include &lt;ClanLib/Core/Math/point.h&gt;
-#include &lt;ClanLib/Core/Math/rect.h&gt;
-#include &quot;shared_ptr.hxx&quot;
-
-class CL_GraphicContext;
-
-class GraphicContextStateImpl;
-
-/** Helper class for capturing the state of a GraphicContext, with
-    additional convenience functions to make handling GraphicContexts
-    easier */
-class GraphicContextState
-{
-public:
-  GraphicContextState();
-  GraphicContextState(int w, int h);
-
-  void set_size(int w, int h);
-
-  void push(CL_GraphicContext* gc = 0);
-  void pop (CL_GraphicContext* gc = 0);
-
-  /** Return a rectangle in world coordinates that represents the area
-      visible on the screen */
-  CL_Rectf get_clip_rect();
-
-  int get_width()  const;
-  int get_height() const;
-
-  /** Set the current rotation angel */
-  void  set_rotation(float angle);
-
-  /** Return the current rotation angel */
-  float get_rotation();
-
-  /** Move the center of the visible area to pos */
-  void      set_pos(const CL_Pointf&amp; pos);
-  CL_Pointf get_pos() const;
-
-  /** Set zoom to z, while ensuring that the screen position \a pos
-      (normaly the position of the mouse pointer) stays in the same
-      position even after zoomed in/out */
-  void  set_zoom(CL_Pointf pos, float z);
-  void  set_zoom(float z);
-  float get_zoom(); 
-
-  void zoom_to (const CL_Rectf&amp; rect);
-
-  CL_Pointf screen2world(const CL_Point&amp; pos);
-
-private:
-  SharedPtr&lt;GraphicContextStateImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/gui_manager.cpp (from rev 712, trunk/flexlay/lib/gui_manager.cxx)
===================================================================
--- trunk/flexlay/lib/gui_manager.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/gui_manager.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,133 @@
+//  $Id: gui_manager.cxx,v 1.3 2003/11/05 12:41:37 grumbel Exp $
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &lt;ClanLib/gui.h&gt;
+#include &lt;ClanLib/guistylesilver.h&gt;
+#include &lt;ClanLib/core.h&gt;
+
+#include &quot;globals.hpp&quot;
+#include &quot;gui_manager.hpp&quot;
+
+GUIManager* GUIManager::current_ = 0;
+
+class GUIManagerImpl
+{
+public:
+  std::stack&lt;CL_Component*&gt; components;
+
+  CL_GUIManager*      manager;
+  CL_StyleManager*    style;
+  CL_ResourceManager* resources;
+  CL_SlotContainer*   slot_container;
+};
+
+GUIManager::GUIManager()
+  : impl(new GUIManagerImpl())
+{
+  std::cout &lt;&lt; &quot;Creating GUIManager: &quot; &lt;&lt; datadir + &quot;gui/gui.xml&quot; &lt;&lt; std::endl;
+  impl-&gt;slot_container = new CL_SlotContainer();
+  impl-&gt;resources = new CL_ResourceManager(datadir + &quot;gui/gui.xml&quot;, false);
+  impl-&gt;style     = new CL_StyleManager_Silver(impl-&gt;resources);
+  impl-&gt;manager   = new CL_GUIManager(impl-&gt;style);
+  current_  = this;
+
+  // Make the manager the first component on the stack
+  push_component(impl-&gt;manager);
+}
+
+GUIManager::~GUIManager()
+{
+  pop_component();
+
+  delete impl-&gt;manager;
+  //delete style; FIXME: Memory hole?!
+  //delete resources;  FIXME: Memory hole?!
+  delete impl-&gt;slot_container;
+}
+  
+void
+GUIManager::draw()
+{
+  if (impl-&gt;manager-&gt;is_input_enabled())
+    impl-&gt;manager-&gt;show();
+}
+
+void
+GUIManager::update()
+{
+  // nothing to do
+}
+
+void
+GUIManager::run()
+{
+  impl-&gt;manager-&gt;run();
+}
+
+CL_Component* 
+GUIManager::get_component()
+{
+  return impl-&gt;components.top();
+}
+
+CL_SlotContainer*
+GUIManager::get_slot_container()
+{
+  return impl-&gt;slot_container;
+}
+
+void
+GUIManager::hide()
+{
+  if (impl-&gt;manager-&gt;is_input_enabled())
+    impl-&gt;manager-&gt;disable_input();
+}
+
+void
+GUIManager::show()
+{
+  if (!impl-&gt;manager-&gt;is_input_enabled())
+    impl-&gt;manager-&gt;enable_input();
+}
+
+bool
+GUIManager::is_visible()
+{
+  return impl-&gt;manager-&gt;is_input_enabled();
+}
+
+void
+GUIManager::quit()
+{
+  impl-&gt;manager-&gt;quit(); 
+} 
+
+void
+GUIManager::push_component(CL_Component* c)
+{
+  impl-&gt;components.push(c); 
+}
+
+void
+GUIManager::pop_component() 
+{ 
+  impl-&gt;components.pop(); 
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/gui_manager.cxx
===================================================================
--- trunk/flexlay/lib/gui_manager.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/gui_manager.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,133 +0,0 @@
-//  $Id: gui_manager.cxx,v 1.3 2003/11/05 12:41:37 grumbel Exp $
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &lt;ClanLib/gui.h&gt;
-#include &lt;ClanLib/guistylesilver.h&gt;
-#include &lt;ClanLib/core.h&gt;
-
-#include &quot;globals.hxx&quot;
-#include &quot;gui_manager.hxx&quot;
-
-GUIManager* GUIManager::current_ = 0;
-
-class GUIManagerImpl
-{
-public:
-  std::stack&lt;CL_Component*&gt; components;
-
-  CL_GUIManager*      manager;
-  CL_StyleManager*    style;
-  CL_ResourceManager* resources;
-  CL_SlotContainer*   slot_container;
-};
-
-GUIManager::GUIManager()
-  : impl(new GUIManagerImpl())
-{
-  std::cout &lt;&lt; &quot;Creating GUIManager: &quot; &lt;&lt; datadir + &quot;gui/gui.xml&quot; &lt;&lt; std::endl;
-  impl-&gt;slot_container = new CL_SlotContainer();
-  impl-&gt;resources = new CL_ResourceManager(datadir + &quot;gui/gui.xml&quot;, false);
-  impl-&gt;style     = new CL_StyleManager_Silver(impl-&gt;resources);
-  impl-&gt;manager   = new CL_GUIManager(impl-&gt;style);
-  current_  = this;
-
-  // Make the manager the first component on the stack
-  push_component(impl-&gt;manager);
-}
-
-GUIManager::~GUIManager()
-{
-  pop_component();
-
-  delete impl-&gt;manager;
-  //delete style; FIXME: Memory hole?!
-  //delete resources;  FIXME: Memory hole?!
-  delete impl-&gt;slot_container;
-}
-  
-void
-GUIManager::draw()
-{
-  if (impl-&gt;manager-&gt;is_input_enabled())
-    impl-&gt;manager-&gt;show();
-}
-
-void
-GUIManager::update()
-{
-  // nothing to do
-}
-
-void
-GUIManager::run()
-{
-  impl-&gt;manager-&gt;run();
-}
-
-CL_Component* 
-GUIManager::get_component()
-{
-  return impl-&gt;components.top();
-}
-
-CL_SlotContainer*
-GUIManager::get_slot_container()
-{
-  return impl-&gt;slot_container;
-}
-
-void
-GUIManager::hide()
-{
-  if (impl-&gt;manager-&gt;is_input_enabled())
-    impl-&gt;manager-&gt;disable_input();
-}
-
-void
-GUIManager::show()
-{
-  if (!impl-&gt;manager-&gt;is_input_enabled())
-    impl-&gt;manager-&gt;enable_input();
-}
-
-bool
-GUIManager::is_visible()
-{
-  return impl-&gt;manager-&gt;is_input_enabled();
-}
-
-void
-GUIManager::quit()
-{
-  impl-&gt;manager-&gt;quit(); 
-} 
-
-void
-GUIManager::push_component(CL_Component* c)
-{
-  impl-&gt;components.push(c); 
-}
-
-void
-GUIManager::pop_component() 
-{ 
-  impl-&gt;components.pop(); 
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/gui_manager.hpp (from rev 712, trunk/flexlay/lib/gui_manager.hxx)
===================================================================
--- trunk/flexlay/lib/gui_manager.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/gui_manager.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,60 @@
+//  $Id: gui_manager.hpp,v 1.2 2003/10/12 11:58:09 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_GUI_MANAGER_HXX
+#define HEADER_GUI_MANAGER_HXX
+
+#include &quot;shared_ptr.hpp&quot;
+
+class GUIManagerImpl;
+
+/** */
+class GUIManager
+{
+private:
+  static GUIManager* current_;
+
+public:
+  static GUIManager* current() { return current_; }
+
+  GUIManager();
+  ~GUIManager();
+
+  void draw();
+  void update();
+
+  void run();
+  void quit();
+
+  void push_component(CL_Component* c);
+  void pop_component();
+
+  void hide();
+  void show();
+  bool is_visible();
+
+  CL_Component* get_component();  
+  CL_SlotContainer* get_slot_container();
+
+private:
+  SharedPtr&lt;GUIManagerImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/gui_manager.hxx
===================================================================
--- trunk/flexlay/lib/gui_manager.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/gui_manager.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,60 +0,0 @@
-//  $Id: gui_manager.hxx,v 1.2 2003/10/12 11:58:09 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_GUI_MANAGER_HXX
-#define HEADER_GUI_MANAGER_HXX
-
-#include &quot;shared_ptr.hxx&quot;
-
-class GUIManagerImpl;
-
-/** */
-class GUIManager
-{
-private:
-  static GUIManager* current_;
-
-public:
-  static GUIManager* current() { return current_; }
-
-  GUIManager();
-  ~GUIManager();
-
-  void draw();
-  void update();
-
-  void run();
-  void quit();
-
-  void push_component(CL_Component* c);
-  void pop_component();
-
-  void hide();
-  void show();
-  bool is_visible();
-
-  CL_Component* get_component();  
-  CL_SlotContainer* get_slot_container();
-
-private:
-  SharedPtr&lt;GUIManagerImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/helper.cpp (from rev 712, trunk/flexlay/lib/helper.cxx)
===================================================================
--- trunk/flexlay/lib/helper.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/helper.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,168 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;map&gt;
+#include &lt;string&gt;
+#include &lt;ClanLib/Display/sprite_description.h&gt;
+#include &lt;ClanLib/Display/pixel_format.h&gt;
+#include &lt;ClanLib/Display/Providers/provider_factory.h&gt;
+#include &lt;ClanLib/core.h&gt;
+#include &quot;blitter.hpp&quot;
+#include &quot;helper.hpp&quot;
+
+typedef std::map&lt;std::string, CL_PixelBuffer&gt; PixelBufferCache;
+PixelBufferCache pixelbuffer_cache;
+
+CL_PixelBuffer get_pixelbuffer(const std::string&amp; filename)
+{
+  PixelBufferCache::iterator it = pixelbuffer_cache.find(filename);
+  
+  if (it == pixelbuffer_cache.end())
+    return (pixelbuffer_cache[filename] = CL_ProviderFactory::load(filename));
+  else
+    return it-&gt;second;
+}
+
+CL_Sprite
+pixelbuffer2sprite(const CL_PixelBuffer&amp; buffer)
+{
+  CL_SpriteDescription desc;
+  desc.add_frame(buffer);
+  return CL_Sprite(desc);
+}
+
+CL_Sprite
+make_sprite(const std::string&amp; filename)
+{
+  try {
+    CL_SpriteDescription desc;
+    desc.add_frame(get_pixelbuffer(filename));
+    return CL_Sprite(desc);
+  } catch (CL_Error&amp; err) {
+    std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
+    return CL_Sprite();
+  }
+}
+
+CL_PixelBuffer
+make_pixelbuffer(const std::string&amp; filename)
+{
+  try {
+    return get_pixelbuffer(filename);
+  } catch (CL_Error&amp; err) {
+    std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
+    return CL_PixelBuffer();
+  }
+}
+
+CL_PixelBuffer
+make_region_pixelbuffer(const std::string&amp; filename, int x, int y, int w, int h)
+{
+  try {
+    CL_PixelBuffer buffer = get_pixelbuffer(filename);
+
+    CL_PixelBuffer target(w, h, w * (buffer.get_format().get_depth()/8), buffer.get_format());
+    clear(target);
+    blit_opaque(target, buffer, -x, -y);
+
+    return target;
+  } catch (CL_Error&amp; err) {
+    std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
+    return CL_PixelBuffer();
+  }
+
+}
+
+CL_Sprite
+make_sprite_from_resource(const std::string&amp; filename, CL_ResourceManager&amp; resources)
+{
+  try {
+    return CL_Sprite(filename, &amp;resources);
+  } catch (CL_Error&amp; err) {
+    std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
+    return CL_Sprite();
+  }  
+}
+
+CL_PixelBuffer
+make_pixelbuffer_from_resource(const std::string&amp; filename, CL_ResourceManager&amp; resources)
+{
+  try {
+    // FIXME: expects a sprite, won't work with 'surface'
+    CL_SpriteDescription descr(filename, &amp;resources);
+    return CL_PixelBuffer(descr.get_frames().begin()-&gt;first);
+  } catch (CL_Error&amp; err) {
+    std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
+    return CL_PixelBuffer();
+  }
+}
+
+CL_PixelBuffer
+make_pixelbuffer(int width, int height)
+{
+  return CL_PixelBuffer(width, height, width*4, CL_PixelFormat::rgba8888);
+}
+
+CL_PixelBuffer
+make_region_pixelbuffer(const CL_PixelBuffer&amp; buffer, int x, int y, int w, int h)
+{
+  try {
+    CL_PixelBuffer target(w, h, w * (buffer.get_format().get_depth()/8), buffer.get_format());
+    clear(target);
+    blit_opaque(target, buffer, -x, -y);
+
+    return target;
+  } catch (CL_Error&amp; err) {
+    std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
+    return CL_PixelBuffer();
+  }
+}
+
+CL_PixelBuffer
+scale_pixelbuffer(CL_PixelBuffer buffer)
+{
+  CL_PixelBuffer target(buffer.get_width()/2, buffer.get_height()/2, (buffer.get_width()/2)*4, 
+                        CL_PixelFormat::rgba8888);
+
+  target.lock();
+  buffer.lock();
+
+  unsigned char* target_buf = static_cast&lt;unsigned char*&gt;(target.get_data());
+  unsigned char* buffer_buf = static_cast&lt;unsigned char*&gt;(buffer.get_data());
+  
+  int width  = target.get_width();
+  int height = target.get_height();
+  int target_pitch = target.get_pitch();
+  int buffer_pitch = buffer.get_pitch();
+  
+  for(int y = 0; y &lt; height; ++y)
+    for(int x = 0; x &lt; width; ++x)
+      {
+        target_buf[target_pitch*y + 4*x + 0] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 0];
+        target_buf[target_pitch*y + 4*x + 1] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 1];
+        target_buf[target_pitch*y + 4*x + 2] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 2];
+        target_buf[target_pitch*y + 4*x + 3] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 3];
+      }
+
+  buffer.unlock();
+  target.unlock();
+  
+  return target;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/helper.cxx
===================================================================
--- trunk/flexlay/lib/helper.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/helper.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,168 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;map&gt;
-#include &lt;string&gt;
-#include &lt;ClanLib/Display/sprite_description.h&gt;
-#include &lt;ClanLib/Display/pixel_format.h&gt;
-#include &lt;ClanLib/Display/Providers/provider_factory.h&gt;
-#include &lt;ClanLib/core.h&gt;
-#include &quot;blitter.hxx&quot;
-#include &quot;helper.hxx&quot;
-
-typedef std::map&lt;std::string, CL_PixelBuffer&gt; PixelBufferCache;
-PixelBufferCache pixelbuffer_cache;
-
-CL_PixelBuffer get_pixelbuffer(const std::string&amp; filename)
-{
-  PixelBufferCache::iterator it = pixelbuffer_cache.find(filename);
-  
-  if (it == pixelbuffer_cache.end())
-    return (pixelbuffer_cache[filename] = CL_ProviderFactory::load(filename));
-  else
-    return it-&gt;second;
-}
-
-CL_Sprite
-pixelbuffer2sprite(const CL_PixelBuffer&amp; buffer)
-{
-  CL_SpriteDescription desc;
-  desc.add_frame(buffer);
-  return CL_Sprite(desc);
-}
-
-CL_Sprite
-make_sprite(const std::string&amp; filename)
-{
-  try {
-    CL_SpriteDescription desc;
-    desc.add_frame(get_pixelbuffer(filename));
-    return CL_Sprite(desc);
-  } catch (CL_Error&amp; err) {
-    std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
-    return CL_Sprite();
-  }
-}
-
-CL_PixelBuffer
-make_pixelbuffer(const std::string&amp; filename)
-{
-  try {
-    return get_pixelbuffer(filename);
-  } catch (CL_Error&amp; err) {
-    std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
-    return CL_PixelBuffer();
-  }
-}
-
-CL_PixelBuffer
-make_region_pixelbuffer(const std::string&amp; filename, int x, int y, int w, int h)
-{
-  try {
-    CL_PixelBuffer buffer = get_pixelbuffer(filename);
-
-    CL_PixelBuffer target(w, h, w * (buffer.get_format().get_depth()/8), buffer.get_format());
-    clear(target);
-    blit_opaque(target, buffer, -x, -y);
-
-    return target;
-  } catch (CL_Error&amp; err) {
-    std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
-    return CL_PixelBuffer();
-  }
-
-}
-
-CL_Sprite
-make_sprite_from_resource(const std::string&amp; filename, CL_ResourceManager&amp; resources)
-{
-  try {
-    return CL_Sprite(filename, &amp;resources);
-  } catch (CL_Error&amp; err) {
-    std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
-    return CL_Sprite();
-  }  
-}
-
-CL_PixelBuffer
-make_pixelbuffer_from_resource(const std::string&amp; filename, CL_ResourceManager&amp; resources)
-{
-  try {
-    // FIXME: expects a sprite, won't work with 'surface'
-    CL_SpriteDescription descr(filename, &amp;resources);
-    return CL_PixelBuffer(descr.get_frames().begin()-&gt;first);
-  } catch (CL_Error&amp; err) {
-    std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
-    return CL_PixelBuffer();
-  }
-}
-
-CL_PixelBuffer
-make_pixelbuffer(int width, int height)
-{
-  return CL_PixelBuffer(width, height, width*4, CL_PixelFormat::rgba8888);
-}
-
-CL_PixelBuffer
-make_region_pixelbuffer(const CL_PixelBuffer&amp; buffer, int x, int y, int w, int h)
-{
-  try {
-    CL_PixelBuffer target(w, h, w * (buffer.get_format().get_depth()/8), buffer.get_format());
-    clear(target);
-    blit_opaque(target, buffer, -x, -y);
-
-    return target;
-  } catch (CL_Error&amp; err) {
-    std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
-    return CL_PixelBuffer();
-  }
-}
-
-CL_PixelBuffer
-scale_pixelbuffer(CL_PixelBuffer buffer)
-{
-  CL_PixelBuffer target(buffer.get_width()/2, buffer.get_height()/2, (buffer.get_width()/2)*4, 
-                        CL_PixelFormat::rgba8888);
-
-  target.lock();
-  buffer.lock();
-
-  unsigned char* target_buf = static_cast&lt;unsigned char*&gt;(target.get_data());
-  unsigned char* buffer_buf = static_cast&lt;unsigned char*&gt;(buffer.get_data());
-  
-  int width  = target.get_width();
-  int height = target.get_height();
-  int target_pitch = target.get_pitch();
-  int buffer_pitch = buffer.get_pitch();
-  
-  for(int y = 0; y &lt; height; ++y)
-    for(int x = 0; x &lt; width; ++x)
-      {
-        target_buf[target_pitch*y + 4*x + 0] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 0];
-        target_buf[target_pitch*y + 4*x + 1] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 1];
-        target_buf[target_pitch*y + 4*x + 2] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 2];
-        target_buf[target_pitch*y + 4*x + 3] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 3];
-      }
-
-  buffer.unlock();
-  target.unlock();
-  
-  return target;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/helper.hpp (from rev 712, trunk/flexlay/lib/helper.hxx)

Deleted: trunk/flexlay/lib/helper.hxx
===================================================================
--- trunk/flexlay/lib/helper.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/helper.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,37 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_HELPER_HXX
-#define HEADER_HELPER_HXX
-
-#include &lt;ClanLib/Display/sprite.h&gt;
-#include &lt;ClanLib/Display/pixel_buffer.h&gt;
-
-CL_Sprite      pixelbuffer2sprite(const CL_PixelBuffer&amp; buffer);
-CL_Sprite      make_sprite(const std::string&amp; filename);
-CL_PixelBuffer make_pixelbuffer(const std::string&amp; filename);
-CL_PixelBuffer make_region_pixelbuffer(const std::string&amp; filename, int x, int y, int w, int h);
-CL_PixelBuffer make_region_pixelbuffer(const CL_PixelBuffer&amp; buffer, int x, int y, int w, int h);
-CL_PixelBuffer make_pixelbuffer(int width, int height);
-CL_PixelBuffer scale_pixelbuffer(CL_PixelBuffer buffer);
-
-CL_Sprite      make_sprite_from_resource(const std::string&amp; filename, CL_ResourceManager&amp; resources);
-CL_PixelBuffer make_pixelbuffer_from_resource(const std::string&amp; filename, CL_ResourceManager&amp; resources);
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/icon.cpp (from rev 712, trunk/flexlay/lib/icon.cxx)
===================================================================
--- trunk/flexlay/lib/icon.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/icon.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,168 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &lt;ClanLib/Display/display_iostream.h&gt;
+#include &quot;box.hpp&quot;
+#include &quot;fonts.hpp&quot;
+#include &quot;icon.hpp&quot;
+
+class IconImpl
+{
+public:
+  IconImpl(Icon* p) : parent(p) {}
+
+  Icon* parent;
+
+  std::vector&lt;CL_Slot&gt; slots;
+  CL_Sprite sprite;
+  std::string tooltip;
+  bool draw_tooltip;
+  bool down;
+
+  /** Parameter to keep the button down all the time, aka togglebutton
+      like */
+  bool is_down;
+
+  bool is_enabled;
+  CL_Signal_v0 sig_on_click;
+
+  void draw();
+
+  void mouse_up  (const CL_InputEvent&amp; event);
+  void mouse_down(const CL_InputEvent&amp; event);
+  void mouse_move(const CL_InputEvent&amp; event);
+};
+
+Icon::Icon(const CL_Rect&amp; rect, const CL_Sprite&amp; sprite, const std::string&amp; tooltip, 
+           CL_Component* parent)
+  : CL_Component(rect, parent),
+    impl(new IconImpl(this))
+{
+  impl-&gt;sprite       = sprite;
+  impl-&gt;tooltip      = tooltip;
+  impl-&gt;draw_tooltip = true;
+  impl-&gt;down         = false;
+  impl-&gt;is_down      = false;
+  impl-&gt;is_enabled   = true;
+
+  impl-&gt;slots.push_back(sig_paint().connect(impl.get(), &amp;IconImpl::draw));
+  impl-&gt;slots.push_back(sig_mouse_down().connect(impl.get(), &amp;IconImpl::mouse_down));
+  impl-&gt;slots.push_back(sig_mouse_up().connect(impl.get(),   &amp;IconImpl::mouse_up));
+}
+
+CL_Signal_v0&amp;
+Icon::sig_clicked()
+{
+  return impl-&gt;sig_on_click;
+}
+  
+void
+IconImpl::draw()
+{
+  CL_Display::push_translate(parent-&gt;get_screen_x(), parent-&gt;get_screen_y());
+  CL_Rect rect(CL_Point(0, 0), CL_Size(parent-&gt;get_width()-4, parent-&gt;get_height()-4));
+
+  sprite.set_alignment(origin_center);
+
+  if (is_enabled)
+    {
+      if (is_down)
+        {
+          Box::draw_button_down(rect);
+        }
+      else
+        {
+          if (parent-&gt;has_mouse_over())
+            {
+              if (down)
+                Box::draw_button_down(rect);
+              else
+                Box::draw_button_up(rect);
+            }
+          else
+            Box::draw_button_neutral(rect);
+        }
+      sprite.set_alpha(1.0f);
+    }
+  else
+    {
+      Box::draw_button_neutral(rect);
+      sprite.set_alpha(0.3f);
+    }
+  sprite.draw((rect.get_width()+1)/2, (rect.get_height()+1)/2);
+  CL_Display::pop_modelview();
+}
+
+void
+IconImpl::mouse_up  (const CL_InputEvent&amp; event)
+{
+  if (is_enabled)
+    {
+      down         = false;
+      parent-&gt;release_mouse();  
+
+      if (parent-&gt;has_mouse_over())
+        {
+          sig_on_click();
+        }
+    }
+}
+
+void
+IconImpl::mouse_down(const CL_InputEvent&amp; event)
+{
+  if (is_enabled)
+    {
+      down         = true;
+      parent-&gt;capture_mouse();
+    }
+}
+
+void 
+IconImpl::mouse_move(const CL_InputEvent&amp; event)
+{
+  //std::cout &lt;&lt; &quot;icon: mouse_move: &quot; &lt;&lt; event &lt;&lt; std::endl;
+}
+
+void
+Icon::disable()
+{
+  impl-&gt;is_enabled = false;
+}
+
+void
+Icon::enable()
+{
+  impl-&gt;is_enabled = true;
+}
+
+void
+Icon::set_up()
+{
+  impl-&gt;is_down = false;
+}
+
+void
+Icon::set_down()
+{
+  impl-&gt;is_down = true;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/icon.cxx
===================================================================
--- trunk/flexlay/lib/icon.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/icon.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,168 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-#include &lt;ClanLib/Display/display_iostream.h&gt;
-#include &quot;box.hxx&quot;
-#include &quot;fonts.hxx&quot;
-#include &quot;icon.hxx&quot;
-
-class IconImpl
-{
-public:
-  IconImpl(Icon* p) : parent(p) {}
-
-  Icon* parent;
-
-  std::vector&lt;CL_Slot&gt; slots;
-  CL_Sprite sprite;
-  std::string tooltip;
-  bool draw_tooltip;
-  bool down;
-
-  /** Parameter to keep the button down all the time, aka togglebutton
-      like */
-  bool is_down;
-
-  bool is_enabled;
-  CL_Signal_v0 sig_on_click;
-
-  void draw();
-
-  void mouse_up  (const CL_InputEvent&amp; event);
-  void mouse_down(const CL_InputEvent&amp; event);
-  void mouse_move(const CL_InputEvent&amp; event);
-};
-
-Icon::Icon(const CL_Rect&amp; rect, const CL_Sprite&amp; sprite, const std::string&amp; tooltip, 
-           CL_Component* parent)
-  : CL_Component(rect, parent),
-    impl(new IconImpl(this))
-{
-  impl-&gt;sprite       = sprite;
-  impl-&gt;tooltip      = tooltip;
-  impl-&gt;draw_tooltip = true;
-  impl-&gt;down         = false;
-  impl-&gt;is_down      = false;
-  impl-&gt;is_enabled   = true;
-
-  impl-&gt;slots.push_back(sig_paint().connect(impl.get(), &amp;IconImpl::draw));
-  impl-&gt;slots.push_back(sig_mouse_down().connect(impl.get(), &amp;IconImpl::mouse_down));
-  impl-&gt;slots.push_back(sig_mouse_up().connect(impl.get(),   &amp;IconImpl::mouse_up));
-}
-
-CL_Signal_v0&amp;
-Icon::sig_clicked()
-{
-  return impl-&gt;sig_on_click;
-}
-  
-void
-IconImpl::draw()
-{
-  CL_Display::push_translate(parent-&gt;get_screen_x(), parent-&gt;get_screen_y());
-  CL_Rect rect(CL_Point(0, 0), CL_Size(parent-&gt;get_width()-4, parent-&gt;get_height()-4));
-
-  sprite.set_alignment(origin_center);
-
-  if (is_enabled)
-    {
-      if (is_down)
-        {
-          Box::draw_button_down(rect);
-        }
-      else
-        {
-          if (parent-&gt;has_mouse_over())
-            {
-              if (down)
-                Box::draw_button_down(rect);
-              else
-                Box::draw_button_up(rect);
-            }
-          else
-            Box::draw_button_neutral(rect);
-        }
-      sprite.set_alpha(1.0f);
-    }
-  else
-    {
-      Box::draw_button_neutral(rect);
-      sprite.set_alpha(0.3f);
-    }
-  sprite.draw((rect.get_width()+1)/2, (rect.get_height()+1)/2);
-  CL_Display::pop_modelview();
-}
-
-void
-IconImpl::mouse_up  (const CL_InputEvent&amp; event)
-{
-  if (is_enabled)
-    {
-      down         = false;
-      parent-&gt;release_mouse();  
-
-      if (parent-&gt;has_mouse_over())
-        {
-          sig_on_click();
-        }
-    }
-}
-
-void
-IconImpl::mouse_down(const CL_InputEvent&amp; event)
-{
-  if (is_enabled)
-    {
-      down         = true;
-      parent-&gt;capture_mouse();
-    }
-}
-
-void 
-IconImpl::mouse_move(const CL_InputEvent&amp; event)
-{
-  //std::cout &lt;&lt; &quot;icon: mouse_move: &quot; &lt;&lt; event &lt;&lt; std::endl;
-}
-
-void
-Icon::disable()
-{
-  impl-&gt;is_enabled = false;
-}
-
-void
-Icon::enable()
-{
-  impl-&gt;is_enabled = true;
-}
-
-void
-Icon::set_up()
-{
-  impl-&gt;is_down = false;
-}
-
-void
-Icon::set_down()
-{
-  impl-&gt;is_down = true;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/icon.hpp (from rev 712, trunk/flexlay/lib/icon.hxx)
===================================================================
--- trunk/flexlay/lib/icon.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/icon.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,54 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_ICON_HXX
+#define HEADER_ICON_HXX
+
+#include &lt;ClanLib/GUI/component.h&gt;
+#include &lt;ClanLib/Core/Math/point.h&gt;
+#include &lt;ClanLib/Display/sprite.h&gt;
+#include &quot;shared_ptr.hpp&quot;
+
+class IconImpl;
+
+/** */
+class Icon : public CL_Component
+{
+protected:
+  virtual ~Icon() {}
+public:
+  Icon(const CL_Rect&amp; rect, const CL_Sprite&amp; sprite, const std::string&amp; tooltip, CL_Component* parent);
+
+  void disable();
+  void enable();
+
+  void set_up();
+  void set_down();
+  
+  CL_Signal_v0&amp; sig_clicked();
+
+private:
+  Icon (const Icon&amp;);
+  Icon&amp; operator= (const Icon&amp;);
+
+  SharedPtr&lt;IconImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/icon.hxx
===================================================================
--- trunk/flexlay/lib/icon.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/icon.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,54 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_ICON_HXX
-#define HEADER_ICON_HXX
-
-#include &lt;ClanLib/GUI/component.h&gt;
-#include &lt;ClanLib/Core/Math/point.h&gt;
-#include &lt;ClanLib/Display/sprite.h&gt;
-#include &quot;shared_ptr.hxx&quot;
-
-class IconImpl;
-
-/** */
-class Icon : public CL_Component
-{
-protected:
-  virtual ~Icon() {}
-public:
-  Icon(const CL_Rect&amp; rect, const CL_Sprite&amp; sprite, const std::string&amp; tooltip, CL_Component* parent);
-
-  void disable();
-  void enable();
-
-  void set_up();
-  void set_down();
-  
-  CL_Signal_v0&amp; sig_clicked();
-
-private:
-  Icon (const Icon&amp;);
-  Icon&amp; operator= (const Icon&amp;);
-
-  SharedPtr&lt;IconImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/layer.cpp (from rev 712, trunk/flexlay/lib/layer.cxx)
===================================================================
--- trunk/flexlay/lib/layer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/layer.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,117 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &quot;layer_impl.hpp&quot;
+#include &quot;layer.hpp&quot;
+
+Layer::Layer()
+  : impl(0)
+{
+}
+
+Layer::Layer(SharedPtr&lt;LayerImpl&gt; i)
+  : impl(i)
+{
+}
+
+Layer::~Layer()
+{
+}
+
+void
+Layer::draw(EditorMapComponent* parent, CL_GraphicContext* gc) 
+{ 
+  if (impl.get())
+    {
+      if (impl-&gt;pos.x != 0 || impl-&gt;pos.y != 0)
+        {
+          gc-&gt;push_modelview();
+          gc-&gt;add_translate(impl-&gt;pos.x, impl-&gt;pos.y);
+          impl-&gt;draw(parent, gc);
+          gc-&gt;pop_modelview();
+        }
+      else
+        {
+          impl-&gt;draw(parent, gc);
+        }
+    }
+}
+  
+bool
+Layer::has_bounding_rect() const 
+{
+  if (impl.get())
+    return impl-&gt;has_bounding_rect(); 
+  else
+    return false;
+} 
+
+CL_Rect
+Layer::get_bounding_rect() 
+{ 
+  CL_Rect rect;
+  
+  if (impl.get())
+    {
+      rect = impl-&gt;get_bounding_rect();
+      rect.left   += static_cast&lt;int&gt;(impl-&gt;pos.x);
+      rect.top    += static_cast&lt;int&gt;(impl-&gt;pos.y);
+      rect.right  += static_cast&lt;int&gt;(impl-&gt;pos.x);
+      rect.bottom += static_cast&lt;int&gt;(impl-&gt;pos.y);
+    }
+  
+  return rect;
+}
+
+MetaData
+Layer::get_metadata() const
+{
+  if (impl.get())
+    return impl-&gt;data; 
+  else
+    return MetaData();
+}
+
+void
+Layer::set_metadata(MetaData data_)
+{
+  if (impl.get())
+    impl-&gt;data = data_;
+}
+
+void
+Layer::set_pos(const CL_Pointf&amp; pos)
+{
+  impl-&gt;pos = pos;
+}
+
+CL_Pointf
+Layer::get_pos() const
+{
+  return impl-&gt;pos;
+}
+
+bool
+Layer::is_null() const
+{
+  return impl.get() == 0;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/layer.cxx
===================================================================
--- trunk/flexlay/lib/layer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/layer.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,117 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-#include &quot;layer_impl.hxx&quot;
-#include &quot;layer.hxx&quot;
-
-Layer::Layer()
-  : impl(0)
-{
-}
-
-Layer::Layer(SharedPtr&lt;LayerImpl&gt; i)
-  : impl(i)
-{
-}
-
-Layer::~Layer()
-{
-}
-
-void
-Layer::draw(EditorMapComponent* parent, CL_GraphicContext* gc) 
-{ 
-  if (impl.get())
-    {
-      if (impl-&gt;pos.x != 0 || impl-&gt;pos.y != 0)
-        {
-          gc-&gt;push_modelview();
-          gc-&gt;add_translate(impl-&gt;pos.x, impl-&gt;pos.y);
-          impl-&gt;draw(parent, gc);
-          gc-&gt;pop_modelview();
-        }
-      else
-        {
-          impl-&gt;draw(parent, gc);
-        }
-    }
-}
-  
-bool
-Layer::has_bounding_rect() const 
-{
-  if (impl.get())
-    return impl-&gt;has_bounding_rect(); 
-  else
-    return false;
-} 
-
-CL_Rect
-Layer::get_bounding_rect() 
-{ 
-  CL_Rect rect;
-  
-  if (impl.get())
-    {
-      rect = impl-&gt;get_bounding_rect();
-      rect.left   += static_cast&lt;int&gt;(impl-&gt;pos.x);
-      rect.top    += static_cast&lt;int&gt;(impl-&gt;pos.y);
-      rect.right  += static_cast&lt;int&gt;(impl-&gt;pos.x);
-      rect.bottom += static_cast&lt;int&gt;(impl-&gt;pos.y);
-    }
-  
-  return rect;
-}
-
-MetaData
-Layer::get_metadata() const
-{
-  if (impl.get())
-    return impl-&gt;data; 
-  else
-    return MetaData();
-}
-
-void
-Layer::set_metadata(MetaData data_)
-{
-  if (impl.get())
-    impl-&gt;data = data_;
-}
-
-void
-Layer::set_pos(const CL_Pointf&amp; pos)
-{
-  impl-&gt;pos = pos;
-}
-
-CL_Pointf
-Layer::get_pos() const
-{
-  return impl-&gt;pos;
-}
-
-bool
-Layer::is_null() const
-{
-  return impl.get() == 0;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/layer.hpp (from rev 712, trunk/flexlay/lib/layer.hxx)
===================================================================
--- trunk/flexlay/lib/layer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/layer.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,67 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_LAYER_HXX
+#define HEADER_LAYER_HXX
+
+#include &lt;ClanLib/Core/Math/rect.h&gt;
+#include &lt;ClanLib/Display/graphic_context.h&gt;
+#include &quot;meta_data.hpp&quot;
+#include &quot;shared_ptr.hpp&quot;
+
+class EditorMapComponent;
+class LayerImpl;
+
+/** Each \a EditorMap consists out of one or more \a Layer,
+    The \a Layer is an abstract base class from which the
+    data holding layers derive. The basic functionality of a layer
+    consists only of data holding and visualization. (FIXME: move
+    visuals off into another class) */
+class Layer
+{
+private:
+public:
+  Layer();
+  Layer(SharedPtr&lt;LayerImpl&gt; i);
+  ~Layer();
+
+  MetaData get_metadata() const;
+  
+  /** Attaches a piece of MetaData to the layer, metadata is some user
+      supplied piece of data that is associated with a layer (ie. the
+      name of the layer or similar properties which aren't handled by
+      the layer itself) */
+  void     set_metadata(MetaData data_);
+
+  void draw(EditorMapComponent* parent, CL_GraphicContext* gc);
+  bool has_bounding_rect() const;
+  CL_Rect get_bounding_rect();
+
+  /** Moves the layer to the given position */
+  void set_pos(const CL_Pointf&amp; pos);
+
+  /** Returns the current position of the layer */
+  CL_Pointf get_pos() const;
+  bool is_null() const;
+public:
+  SharedPtr&lt;LayerImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/layer.hxx
===================================================================
--- trunk/flexlay/lib/layer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/layer.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,67 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_LAYER_HXX
-#define HEADER_LAYER_HXX
-
-#include &lt;ClanLib/Core/Math/rect.h&gt;
-#include &lt;ClanLib/Display/graphic_context.h&gt;
-#include &quot;meta_data.hxx&quot;
-#include &quot;shared_ptr.hxx&quot;
-
-class EditorMapComponent;
-class LayerImpl;
-
-/** Each \a EditorMap consists out of one or more \a Layer,
-    The \a Layer is an abstract base class from which the
-    data holding layers derive. The basic functionality of a layer
-    consists only of data holding and visualization. (FIXME: move
-    visuals off into another class) */
-class Layer
-{
-private:
-public:
-  Layer();
-  Layer(SharedPtr&lt;LayerImpl&gt; i);
-  ~Layer();
-
-  MetaData get_metadata() const;
-  
-  /** Attaches a piece of MetaData to the layer, metadata is some user
-      supplied piece of data that is associated with a layer (ie. the
-      name of the layer or similar properties which aren't handled by
-      the layer itself) */
-  void     set_metadata(MetaData data_);
-
-  void draw(EditorMapComponent* parent, CL_GraphicContext* gc);
-  bool has_bounding_rect() const;
-  CL_Rect get_bounding_rect();
-
-  /** Moves the layer to the given position */
-  void set_pos(const CL_Pointf&amp; pos);
-
-  /** Returns the current position of the layer */
-  CL_Pointf get_pos() const;
-  bool is_null() const;
-public:
-  SharedPtr&lt;LayerImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/layer_impl.hpp (from rev 712, trunk/flexlay/lib/layer_impl.hxx)
===================================================================
--- trunk/flexlay/lib/layer_impl.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/layer_impl.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,55 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_LAYER_IMPL_HXX
+#define HEADER_LAYER_IMPL_HXX
+
+#include &lt;ClanLib/Core/Math/rect.h&gt;
+#include &lt;ClanLib/Display/graphic_context.h&gt;
+#include &quot;meta_data.hpp&quot;
+
+class EditorMapComponent;
+
+class LayerImpl
+{
+public:
+  /** MetaData attached to the layer, MetaData can be any data
+      supplied by the user, but most commonly it is used to associate
+      the given layer with a scripting language object (PyObj, SCM,
+      etc.), so that the user can attach additional data to a layer
+      from the scripting side. */
+  MetaData  data;
+  
+  /** The position of the layer */
+  CL_Pointf pos;
+
+  LayerImpl() 
+    : pos(0, 0)
+  {}
+  virtual ~LayerImpl() {}
+
+  virtual void draw(EditorMapComponent* parent, CL_GraphicContext* gc) =0;
+  virtual bool has_bounding_rect() const =0;
+
+  // FIXME: Should use CL_Rectf
+  virtual CL_Rect get_bounding_rect() { return CL_Rect(); }
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/layer_impl.hxx
===================================================================
--- trunk/flexlay/lib/layer_impl.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/layer_impl.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,55 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_LAYER_IMPL_HXX
-#define HEADER_LAYER_IMPL_HXX
-
-#include &lt;ClanLib/Core/Math/rect.h&gt;
-#include &lt;ClanLib/Display/graphic_context.h&gt;
-#include &quot;meta_data.hxx&quot;
-
-class EditorMapComponent;
-
-class LayerImpl
-{
-public:
-  /** MetaData attached to the layer, MetaData can be any data
-      supplied by the user, but most commonly it is used to associate
-      the given layer with a scripting language object (PyObj, SCM,
-      etc.), so that the user can attach additional data to a layer
-      from the scripting side. */
-  MetaData  data;
-  
-  /** The position of the layer */
-  CL_Pointf pos;
-
-  LayerImpl() 
-    : pos(0, 0)
-  {}
-  virtual ~LayerImpl() {}
-
-  virtual void draw(EditorMapComponent* parent, CL_GraphicContext* gc) =0;
-  virtual bool has_bounding_rect() const =0;
-
-  // FIXME: Should use CL_Rectf
-  virtual CL_Rect get_bounding_rect() { return CL_Rect(); }
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/lispreader.cpp (from rev 712, trunk/flexlay/lib/lispreader.cxx)
===================================================================
--- trunk/flexlay/lib/lispreader.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/lispreader.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,1358 @@
+/* $Id: lispreader.cpp,v 1.19 2004/05/11 22:16:12 sik0fewl Exp $ */
+/*
+ * lispreader.c
+ *
+ * Copyright (C) 1998-2000 Mark Probst
+ * Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include &lt;iostream&gt;
+#include &lt;string&gt;
+#include &lt;ctype.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &quot;lispreader.hpp&quot;
+
+#define TOKEN_ERROR                   -1
+#define TOKEN_EOF                     0
+#define TOKEN_OPEN_PAREN              1
+#define TOKEN_CLOSE_PAREN             2
+#define TOKEN_SYMBOL                  3
+#define TOKEN_STRING                  4
+#define TOKEN_INTEGER                 5
+#define TOKEN_REAL                    6
+#define TOKEN_PATTERN_OPEN_PAREN      7
+#define TOKEN_DOT                     8
+#define TOKEN_TRUE                    9
+#define TOKEN_FALSE                   10
+
+
+#define MAX_TOKEN_LENGTH           1024
+
+static char token_string[MAX_TOKEN_LENGTH + 1] = &quot;&quot;;
+static int token_length = 0;
+
+static lisp_object_t end_marker = { LISP_TYPE_EOF, {{0, 0}} };
+static lisp_object_t error_object = { LISP_TYPE_PARSE_ERROR , {{0,0}}  };
+static lisp_object_t close_paren_marker = { LISP_TYPE_PARSE_ERROR , {{0,0}}  };
+static lisp_object_t dot_marker = { LISP_TYPE_PARSE_ERROR , {{0,0}} };
+
+static void
+_token_clear (void)
+{
+  token_string[0] = '\0';
+  token_length = 0;
+}
+
+static void
+_token_append (char c)
+{
+  if (token_length &gt;= MAX_TOKEN_LENGTH)
+    throw LispReaderException(&quot;_token_append()&quot;, __FILE__, __LINE__);
+
+  token_string[token_length++] = c;
+  token_string[token_length] = '\0';
+}
+
+static int
+_next_char (lisp_stream_t *stream)
+{
+  switch (stream-&gt;type)
+    {
+    case LISP_STREAM_FILE :
+      return getc(stream-&gt;v.file);
+
+    case LISP_STREAM_STRING :
+      {
+        char c = stream-&gt;v.string.buf[stream-&gt;v.string.pos];
+
+        if (c == 0)
+          return EOF;
+
+        ++stream-&gt;v.string.pos;
+
+        return c;
+      }
+
+    case LISP_STREAM_ANY:
+      return stream-&gt;v.any.next_char(stream-&gt;v.any.data);
+    }
+
+  throw LispReaderException(&quot;_next_char()&quot;, __FILE__, __LINE__);
+  return EOF;
+}
+
+static void
+_unget_char (char c, lisp_stream_t *stream)
+{
+  switch (stream-&gt;type)
+    {
+    case LISP_STREAM_FILE :
+      ungetc(c, stream-&gt;v.file);
+      break;
+
+    case LISP_STREAM_STRING :
+      --stream-&gt;v.string.pos;
+      break;
+
+    case LISP_STREAM_ANY:
+      stream-&gt;v.any.unget_char(c, stream-&gt;v.any.data);
+      break;
+
+    default :
+      throw LispReaderException(&quot;_unget_char()&quot;, __FILE__, __LINE__);
+    }
+}
+
+static int
+_scan (lisp_stream_t *stream)
+{
+  static char *delims = &quot;\&quot;();&quot;;
+
+  int c;
+
+  _token_clear();
+
+  do
+    {
+      c = _next_char(stream);
+      if (c == EOF)
+        return TOKEN_EOF;
+      else if (c == ';')     	 /* comment start */
+        while (1)
+          {
+            c = _next_char(stream);
+            if (c == EOF)
+              return TOKEN_EOF;
+            else if (c == '\n')
+              break;
+          }
+    }
+  while (isspace(c));
+
+  switch (c)
+    {
+    case '(' :
+      return TOKEN_OPEN_PAREN;
+
+    case ')' :
+      return TOKEN_CLOSE_PAREN;
+
+    case '&quot;' :
+      while (1)
+        {
+          c = _next_char(stream);
+          if (c == EOF)
+            return TOKEN_ERROR;
+          if (c == '&quot;')
+            break;
+          if (c == '\\')
+            {
+              c = _next_char(stream);
+
+              switch (c)
+                {
+                case EOF :
+                  return TOKEN_ERROR;
+
+                case 'n' :
+                  c = '\n';
+                  break;
+
+                case 't' :
+                  c = '\t';
+                  break;
+                }
+            }
+
+          _token_append(c);
+        }
+      return TOKEN_STRING;
+
+    case '#' :
+      c = _next_char(stream);
+      if (c == EOF)
+        return TOKEN_ERROR;
+
+      switch (c)
+        {
+        case 't' :
+          return TOKEN_TRUE;
+
+        case 'f' :
+          return TOKEN_FALSE;
+
+        case '?' :
+          c = _next_char(stream);
+          if (c == EOF)
+            return TOKEN_ERROR;
+
+          if (c == '(')
+            return TOKEN_PATTERN_OPEN_PAREN;
+          else
+            return TOKEN_ERROR;
+        }
+      return TOKEN_ERROR;
+
+    default :
+      if (isdigit(c) || c == '-')
+        {
+          int have_nondigits = 0;
+          int have_digits = 0;
+          int have_floating_point = 0;
+
+          do
+            {
+              if (isdigit(c))
+                have_digits = 1;
+              else if (c == '.')
+                have_floating_point++;
+              _token_append(c);
+
+              c = _next_char(stream);
+
+              if (c != EOF &amp;&amp; !isdigit(c) &amp;&amp; !isspace(c) &amp;&amp; c != '.' &amp;&amp; !strchr(delims, c))
+                have_nondigits = 1;
+            }
+          while (c != EOF &amp;&amp; !isspace(c) &amp;&amp; !strchr(delims, c));
+
+          if (c != EOF)
+            _unget_char(c, stream);
+
+          if (have_nondigits || !have_digits || have_floating_point &gt; 1)
+            return TOKEN_SYMBOL;
+          else if (have_floating_point == 1)
+            return TOKEN_REAL;
+          else
+            return TOKEN_INTEGER;
+        }
+      else
+        {
+          if (c == '.')
+            {
+              c = _next_char(stream);
+              if (c != EOF &amp;&amp; !isspace(c) &amp;&amp; !strchr(delims, c))
+                _token_append('.');
+              else
+                {
+                  _unget_char(c, stream);
+                  return TOKEN_DOT;
+                }
+            }
+          do
+            {
+              _token_append(c);
+              c = _next_char(stream);
+            }
+          while (c != EOF &amp;&amp; !isspace(c) &amp;&amp; !strchr(delims, c));
+          if (c != EOF)
+            _unget_char(c, stream);
+
+          return TOKEN_SYMBOL;
+        }
+    }
+
+  throw LispReaderException(&quot;_scan()&quot;, __FILE__, __LINE__);
+  return TOKEN_ERROR;
+}
+
+static lisp_object_t*
+lisp_object_alloc (int type)
+{
+  lisp_object_t *obj = (lisp_object_t*)malloc(sizeof(lisp_object_t));
+
+  obj-&gt;type = type;
+
+  return obj;
+}
+
+lisp_stream_t*
+lisp_stream_init_file (lisp_stream_t *stream, FILE *file)
+{
+  stream-&gt;type = LISP_STREAM_FILE;
+  stream-&gt;v.file = file;
+
+  return stream;
+}
+
+lisp_stream_t*
+lisp_stream_init_string (lisp_stream_t *stream, char *buf)
+{
+  stream-&gt;type = LISP_STREAM_STRING;
+  stream-&gt;v.string.buf = buf;
+  stream-&gt;v.string.pos = 0;
+
+  return stream;
+}
+
+lisp_stream_t*
+lisp_stream_init_any (lisp_stream_t *stream, void *data,
+                      int (*next_char) (void *data),
+                      void (*unget_char) (char c, void *data))
+{
+  if (next_char == 0 || unget_char == 0)
+    throw LispReaderException(&quot;lisp_stream_init_any()&quot;, __FILE__, __LINE__);
+
+  stream-&gt;type = LISP_STREAM_ANY;
+  stream-&gt;v.any.data = data;
+  stream-&gt;v.any.next_char= next_char;
+  stream-&gt;v.any.unget_char = unget_char;
+
+  return stream;
+}
+
+lisp_object_t*
+lisp_make_integer (int value)
+{
+  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_INTEGER);
+
+  obj-&gt;v.integer = value;
+
+  return obj;
+}
+
+lisp_object_t*
+lisp_make_real (float value)
+{
+  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_REAL);
+
+  obj-&gt;v.real = value;
+
+  return obj;
+}
+
+lisp_object_t*
+lisp_make_symbol (const char *value)
+{
+  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_SYMBOL);
+
+  obj-&gt;v.string = strdup(value);
+
+  return obj;
+}
+
+lisp_object_t*
+lisp_make_string (const char *value)
+{
+  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_STRING);
+
+  obj-&gt;v.string = strdup(value);
+
+  return obj;
+}
+
+lisp_object_t*
+lisp_make_cons (lisp_object_t *car, lisp_object_t *cdr)
+{
+  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_CONS);
+
+  obj-&gt;v.cons.car = car;
+  obj-&gt;v.cons.cdr = cdr;
+
+  return obj;
+}
+
+lisp_object_t*
+lisp_make_boolean (int value)
+{
+  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_BOOLEAN);
+
+  obj-&gt;v.integer = value ? 1 : 0;
+
+  return obj;
+}
+
+static lisp_object_t*
+lisp_make_pattern_cons (lisp_object_t *car, lisp_object_t *cdr)
+{
+  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_PATTERN_CONS);
+
+  obj-&gt;v.cons.car = car;
+  obj-&gt;v.cons.cdr = cdr;
+
+  return obj;
+}
+
+static lisp_object_t*
+lisp_make_pattern_var (int type, int index, lisp_object_t *sub)
+{
+  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_PATTERN_VAR);
+
+  obj-&gt;v.pattern.type = type;
+  obj-&gt;v.pattern.index = index;
+  obj-&gt;v.pattern.sub = sub;
+
+  return obj;
+}
+
+lisp_object_t*
+lisp_read (lisp_stream_t *in)
+{
+  int token = _scan(in);
+  lisp_object_t *obj = lisp_nil();
+
+  if (token == TOKEN_EOF)
+    return &amp;end_marker;
+
+  switch (token)
+    {
+    case TOKEN_ERROR :
+      return &amp;error_object;
+
+    case TOKEN_EOF :
+      return &amp;end_marker;
+
+    case TOKEN_OPEN_PAREN :
+    case TOKEN_PATTERN_OPEN_PAREN :
+      {
+        lisp_object_t *last = lisp_nil(), *car;
+
+        do
+          {
+            car = lisp_read(in);
+            if (car == &amp;error_object || car == &amp;end_marker)
+              {
+                lisp_free(obj);
+                return &amp;error_object;
+              }
+            else if (car == &amp;dot_marker)
+              {
+                if (lisp_nil_p(last))
+                  {
+                    lisp_free(obj);
+                    return &amp;error_object;
+                  }
+
+                car = lisp_read(in);
+                if (car == &amp;error_object || car == &amp;end_marker)
+                  {
+                    lisp_free(obj);
+                    return car;
+                  }
+                else
+                  {
+                    last-&gt;v.cons.cdr = car;
+
+                    if (_scan(in) != TOKEN_CLOSE_PAREN)
+                      {
+                        lisp_free(obj);
+                        return &amp;error_object;
+                      }
+
+                    car = &amp;close_paren_marker;
+                  }
+              }
+            else if (car != &amp;close_paren_marker)
+              {
+                if (lisp_nil_p(last))
+                  obj = last = (token == TOKEN_OPEN_PAREN ? lisp_make_cons(car, lisp_nil()) : lisp_make_pattern_cons(car, lisp_nil()));
+                else
+                  last = last-&gt;v.cons.cdr = lisp_make_cons(car, lisp_nil());
+              }
+          }
+        while (car != &amp;close_paren_marker);
+      }
+      return obj;
+
+    case TOKEN_CLOSE_PAREN :
+      return &amp;close_paren_marker;
+
+    case TOKEN_SYMBOL :
+      return lisp_make_symbol(token_string);
+
+    case TOKEN_STRING :
+      return lisp_make_string(token_string);
+
+    case TOKEN_INTEGER :
+      return lisp_make_integer(atoi(token_string));
+
+    case TOKEN_REAL :
+      return lisp_make_real((float)atof(token_string));
+
+    case TOKEN_DOT :
+      return &amp;dot_marker;
+
+    case TOKEN_TRUE :
+      return lisp_make_boolean(1);
+
+    case TOKEN_FALSE :
+      return lisp_make_boolean(0);
+    }
+
+  throw LispReaderException(&quot;lisp_read()&quot;, __FILE__, __LINE__);
+  return &amp;error_object;
+}
+
+void
+lisp_free (lisp_object_t *obj)
+{
+  if (obj == 0)
+    return;
+
+  switch (obj-&gt;type)
+    {
+    case LISP_TYPE_INTERNAL :
+    case LISP_TYPE_PARSE_ERROR :
+    case LISP_TYPE_EOF :
+      return;
+
+    case LISP_TYPE_SYMBOL :
+    case LISP_TYPE_STRING :
+      free(obj-&gt;v.string);
+      break;
+
+    case LISP_TYPE_CONS :
+    case LISP_TYPE_PATTERN_CONS :
+      lisp_free(obj-&gt;v.cons.car);
+      lisp_free(obj-&gt;v.cons.cdr);
+      break;
+
+    case LISP_TYPE_PATTERN_VAR :
+      lisp_free(obj-&gt;v.pattern.sub);
+      break;
+    }
+
+  free(obj);
+}
+
+lisp_object_t*
+lisp_read_from_string (const char *buf)
+{
+  lisp_stream_t stream;
+
+  lisp_stream_init_string(&amp;stream, (char*)buf);
+  return lisp_read(&amp;stream);
+}
+
+static int
+_compile_pattern (lisp_object_t **obj, int *index)
+{
+  if (*obj == 0)
+    return 1;
+
+  switch (lisp_type(*obj))
+    {
+    case LISP_TYPE_PATTERN_CONS :
+      {
+        struct
+          {
+            char *name;
+            int type;
+          }
+        types[] =
+          {
+            { &quot;any&quot;, LISP_PATTERN_ANY },
+            { &quot;symbol&quot;, LISP_PATTERN_SYMBOL },
+            { &quot;string&quot;, LISP_PATTERN_STRING },
+            { &quot;integer&quot;, LISP_PATTERN_INTEGER },
+            { &quot;real&quot;, LISP_PATTERN_REAL },
+            { &quot;boolean&quot;, LISP_PATTERN_BOOLEAN },
+            { &quot;list&quot;, LISP_PATTERN_LIST },
+            { &quot;or&quot;, LISP_PATTERN_OR },
+            { 0, 0 }
+          };
+        char *type_name;
+        int type;
+        int i;
+        lisp_object_t *pattern;
+        type = -1;
+	
+        if (lisp_type(lisp_car(*obj)) != LISP_TYPE_SYMBOL)
+          return 0;
+
+        type_name = lisp_symbol(lisp_car(*obj));
+        for (i = 0; types[i].name != 0; ++i)
+          {
+            if (strcmp(types[i].name, type_name) == 0)
+              {
+                type = types[i].type;
+                break;
+              }
+          }
+
+        if (types[i].name == 0)
+          return 0;
+
+        if (type != LISP_PATTERN_OR &amp;&amp; lisp_cdr(*obj) != 0)
+          return 0;
+
+        pattern = lisp_make_pattern_var(type, (*index)++, lisp_nil());
+
+        if (type == LISP_PATTERN_OR)
+          {
+            lisp_object_t *cdr = lisp_cdr(*obj);
+
+            if (!_compile_pattern(&amp;cdr, index))
+              {
+                lisp_free(pattern);
+                return 0;
+              }
+
+            pattern-&gt;v.pattern.sub = cdr;
+
+            (*obj)-&gt;v.cons.cdr = lisp_nil();
+          }
+
+        lisp_free(*obj);
+
+        *obj = pattern;
+      }
+      break;
+
+    case LISP_TYPE_CONS :
+      if (!_compile_pattern(&amp;(*obj)-&gt;v.cons.car, index))
+        return 0;
+      if (!_compile_pattern(&amp;(*obj)-&gt;v.cons.cdr, index))
+        return 0;
+      break;
+    }
+
+  return 1;
+}
+
+int
+lisp_compile_pattern (lisp_object_t **obj, int *num_subs)
+{
+  int index = 0;
+  int result;
+
+  result = _compile_pattern(obj, &amp;index);
+
+  if (result &amp;&amp; num_subs != 0)
+    *num_subs = index;
+
+  return result;
+}
+
+static int _match_pattern (lisp_object_t *pattern, lisp_object_t *obj, lisp_object_t **vars);
+
+static int
+_match_pattern_var (lisp_object_t *pattern, lisp_object_t *obj, lisp_object_t **vars)
+{
+  if (lisp_type(pattern) != LISP_TYPE_PATTERN_VAR)
+    throw LispReaderException(&quot;_match_pattern_var&quot;, __FILE__, __LINE__);
+
+  switch (pattern-&gt;v.pattern.type)
+    {
+    case LISP_PATTERN_ANY :
+      break;
+
+    case LISP_PATTERN_SYMBOL :
+      if (obj == 0 || lisp_type(obj) != LISP_TYPE_SYMBOL)
+        return 0;
+      break;
+
+    case LISP_PATTERN_STRING :
+      if (obj == 0 || lisp_type(obj) != LISP_TYPE_STRING)
+        return 0;
+      break;
+
+    case LISP_PATTERN_INTEGER :
+      if (obj == 0 || lisp_type(obj) != LISP_TYPE_INTEGER)
+        return 0;
+      break;
+
+    case LISP_PATTERN_REAL :
+      if (obj == 0 || lisp_type(obj) != LISP_TYPE_REAL)
+        return 0;
+      break;
+
+    case LISP_PATTERN_BOOLEAN :
+      if (obj == 0 || lisp_type(obj) != LISP_TYPE_BOOLEAN)
+        return 0;
+      break;
+
+    case LISP_PATTERN_LIST :
+      if (obj == 0 || lisp_type(obj) != LISP_TYPE_CONS)
+        return 0;
+      break;
+
+    case LISP_PATTERN_OR :
+      {
+        lisp_object_t *sub;
+        int matched = 0;
+
+        for (sub = pattern-&gt;v.pattern.sub; sub != 0; sub = lisp_cdr(sub))
+          {
+            if (lisp_type(sub) != LISP_TYPE_CONS)
+              throw LispReaderException(&quot;_match_pattern_var()&quot;, __FILE__, __LINE__);
+
+            if (_match_pattern(lisp_car(sub), obj, vars))
+              matched = 1;
+          }
+
+        if (!matched)
+          return 0;
+      }
+      break;
+
+    default :
+      throw LispReaderException(&quot;_match_pattern_var()&quot;, __FILE__, __LINE__);
+    }
+
+  if (vars != 0)
+    vars[pattern-&gt;v.pattern.index] = obj;
+
+  return 1;
+}
+
+static int
+_match_pattern (lisp_object_t *pattern, lisp_object_t *obj, lisp_object_t **vars)
+{
+  if (pattern == 0)
+    return obj == 0;
+
+  if (obj == 0)
+    return 0;
+
+  if (lisp_type(pattern) == LISP_TYPE_PATTERN_VAR)
+    return _match_pattern_var(pattern, obj, vars);
+
+  if (lisp_type(pattern) != lisp_type(obj))
+    return 0;
+
+  switch (lisp_type(pattern))
+    {
+    case LISP_TYPE_SYMBOL :
+      return strcmp(lisp_symbol(pattern), lisp_symbol(obj)) == 0;
+
+    case LISP_TYPE_STRING :
+      return strcmp(lisp_string(pattern), lisp_string(obj)) == 0;
+
+    case LISP_TYPE_INTEGER :
+      return lisp_integer(pattern) == lisp_integer(obj);
+
+    case LISP_TYPE_REAL :
+      return lisp_real(pattern) == lisp_real(obj);
+
+    case LISP_TYPE_CONS :
+      {
+        int result1, result2;
+
+        result1 = _match_pattern(lisp_car(pattern), lisp_car(obj), vars);
+        result2 = _match_pattern(lisp_cdr(pattern), lisp_cdr(obj), vars);
+
+        return result1 &amp;&amp; result2;
+      }
+      break;
+
+    default :
+      throw LispReaderException(&quot;_match_pattern()&quot;, __FILE__, __LINE__);
+    }
+
+  return 0;
+}
+
+int
+lisp_match_pattern (lisp_object_t *pattern, lisp_object_t *obj, lisp_object_t **vars, int num_subs)
+{
+  int i;
+
+  if (vars != 0)
+    for (i = 0; i &lt; num_subs; ++i)
+      vars[i] = &amp;error_object;
+
+  return _match_pattern(pattern, obj, vars);
+}
+
+int
+lisp_match_string (const char *pattern_string, lisp_object_t *obj, lisp_object_t **vars)
+{
+  lisp_object_t *pattern;
+  int result;
+  int num_subs;
+
+  pattern = lisp_read_from_string(pattern_string);
+
+  if (pattern != 0 &amp;&amp; (lisp_type(pattern) == LISP_TYPE_EOF
+                       || lisp_type(pattern) == LISP_TYPE_PARSE_ERROR))
+    return 0;
+
+  if (!lisp_compile_pattern(&amp;pattern, &amp;num_subs))
+    {
+      lisp_free(pattern);
+      return 0;
+    }
+
+  result = lisp_match_pattern(pattern, obj, vars, num_subs);
+
+  lisp_free(pattern);
+
+  return result;
+}
+
+int
+lisp_type (lisp_object_t *obj)
+{
+  if (obj == 0)
+    return LISP_TYPE_NIL;
+  return obj-&gt;type;
+}
+
+int
+lisp_integer (lisp_object_t *obj)
+{
+  if (obj-&gt;type != LISP_TYPE_INTEGER)
+    throw LispReaderException(&quot;lisp_integer()&quot;, __FILE__, __LINE__);
+
+  return obj-&gt;v.integer;
+}
+
+char*
+lisp_symbol (lisp_object_t *obj)
+{
+  if (obj-&gt;type != LISP_TYPE_SYMBOL)
+    throw LispReaderException(&quot;lisp_symbol()&quot;, __FILE__, __LINE__);
+
+  return obj-&gt;v.string;
+}
+
+char*
+lisp_string (lisp_object_t *obj)
+{
+  if (obj-&gt;type != LISP_TYPE_STRING)
+    throw LispReaderException(&quot;lisp_string()&quot;, __FILE__, __LINE__);
+
+  return obj-&gt;v.string;
+}
+
+int
+lisp_boolean (lisp_object_t *obj)
+{
+  if (obj-&gt;type != LISP_TYPE_BOOLEAN)
+    throw LispReaderException(&quot;lisp_boolean()&quot;, __FILE__, __LINE__);
+
+  return obj-&gt;v.integer;
+}
+
+float
+lisp_real (lisp_object_t *obj)
+{
+  if (obj-&gt;type != LISP_TYPE_REAL &amp;&amp; obj-&gt;type != LISP_TYPE_INTEGER)
+    throw LispReaderException(&quot;lisp_real()&quot;, __FILE__, __LINE__);
+
+  if (obj-&gt;type == LISP_TYPE_INTEGER)
+    return obj-&gt;v.integer;
+  return obj-&gt;v.real;
+}
+
+lisp_object_t*
+lisp_car (lisp_object_t *obj)
+{
+  if (obj-&gt;type != LISP_TYPE_CONS &amp;&amp; obj-&gt;type != LISP_TYPE_PATTERN_CONS)
+    throw LispReaderException(&quot;lisp_car()&quot;, __FILE__, __LINE__);
+
+  return obj-&gt;v.cons.car;
+}
+
+lisp_object_t*
+lisp_cdr (lisp_object_t *obj)
+{
+  if (obj-&gt;type != LISP_TYPE_CONS &amp;&amp; obj-&gt;type != LISP_TYPE_PATTERN_CONS)
+    throw LispReaderException(&quot;lisp_cdr()&quot;, __FILE__, __LINE__);
+
+  return obj-&gt;v.cons.cdr;
+}
+
+lisp_object_t*
+lisp_cxr (lisp_object_t *obj, const char *x)
+{
+  int i;
+
+  for (i = strlen(x) - 1; i &gt;= 0; --i)
+    if (x[i] == 'a')
+      obj = lisp_car(obj);
+    else if (x[i] == 'd')
+      obj = lisp_cdr(obj);
+    else
+      throw LispReaderException(&quot;lisp_cxr()&quot;, __FILE__, __LINE__);
+
+  return obj;
+}
+
+int
+lisp_list_length (lisp_object_t *obj)
+{
+  int length = 0;
+
+  while (obj != 0)
+    {
+      if (obj-&gt;type != LISP_TYPE_CONS &amp;&amp; obj-&gt;type != LISP_TYPE_PATTERN_CONS)
+        throw LispReaderException(&quot;lisp_list_length()&quot;, __FILE__, __LINE__);
+
+      ++length;
+      obj = obj-&gt;v.cons.cdr;
+    }
+
+  return length;
+}
+
+lisp_object_t*
+lisp_list_nth_cdr (lisp_object_t *obj, int index)
+{
+  while (index &gt; 0)
+    {
+      if (obj == 0)
+        throw LispReaderException(&quot;lisp_list_nth_cdr()&quot;, __FILE__, __LINE__);
+      if (obj-&gt;type != LISP_TYPE_CONS &amp;&amp; obj-&gt;type != LISP_TYPE_PATTERN_CONS)
+        throw LispReaderException(&quot;lisp_list_nth_cdr()&quot;, __FILE__, __LINE__);
+
+      --index;
+      obj = obj-&gt;v.cons.cdr;
+    }
+
+  return obj;
+}
+
+lisp_object_t*
+lisp_list_nth (lisp_object_t *obj, int index)
+{
+  obj = lisp_list_nth_cdr(obj, index);
+
+  if (obj == 0)
+    throw LispReaderException(&quot;lisp_list_nth()&quot;, __FILE__, __LINE__);
+
+  return obj-&gt;v.cons.car;
+}
+
+void
+lisp_dump (lisp_object_t *obj, FILE *out)
+{
+  if (obj == 0)
+    {
+      fprintf(out, &quot;()&quot;);
+      return;
+    }
+
+  switch (lisp_type(obj))
+    {
+    case LISP_TYPE_EOF :
+      fputs(&quot;#&lt;eof&gt;&quot;, out);
+      break;
+
+    case LISP_TYPE_PARSE_ERROR :
+      fputs(&quot;#&lt;error&gt;&quot;, out);
+      break;
+
+    case LISP_TYPE_INTEGER :
+      fprintf(out, &quot;%d&quot;, lisp_integer(obj));
+      break;
+
+    case LISP_TYPE_REAL :
+      fprintf(out, &quot;%f&quot;, lisp_real(obj));
+      break;
+
+    case LISP_TYPE_SYMBOL :
+      fputs(lisp_symbol(obj), out);
+      break;
+
+    case LISP_TYPE_STRING :
+      {
+        char *p;
+
+        fputc('&quot;', out);
+        for (p = lisp_string(obj); *p != 0; ++p)
+          {
+            if (*p == '&quot;' || *p == '\\')
+              fputc('\\', out);
+            fputc(*p, out);
+          }
+        fputc('&quot;', out);
+      }
+      break;
+
+    case LISP_TYPE_CONS :
+    case LISP_TYPE_PATTERN_CONS :
+      fputs(lisp_type(obj) == LISP_TYPE_CONS ? &quot;(&quot; : &quot;#?(&quot;, out);
+      while (obj != 0)
+        {
+          lisp_dump(lisp_car(obj), out);
+          obj = lisp_cdr(obj);
+          if (obj != 0)
+            {
+              if (lisp_type(obj) != LISP_TYPE_CONS
+                  &amp;&amp; lisp_type(obj) != LISP_TYPE_PATTERN_CONS)
+                {
+                  fputs(&quot; . &quot;, out);
+                  lisp_dump(obj, out);
+                  break;
+                }
+              else
+                fputc(' ', out);
+            }
+        }
+      fputc(')', out);
+      break;
+
+    case LISP_TYPE_BOOLEAN :
+      if (lisp_boolean(obj))
+        fputs(&quot;#t&quot;, out);
+      else
+        fputs(&quot;#f&quot;, out);
+      break;
+
+    default :
+      throw LispReaderException(&quot;lisp_dump()&quot;, __FILE__, __LINE__);
+    }
+}
+
+using namespace std;
+
+LispReader::LispReader (lisp_object_t* l)
+    : lst (l)
+{
+  //std::cout &lt;&lt; &quot;LispReader: &quot; &lt;&lt; std::flush;
+  //lisp_dump(lst, stdout);
+  //std::cout &lt;&lt; std::endl;
+}
+
+lisp_object_t*
+LispReader::search_for(const char* name)
+{
+  //std::cout &lt;&lt; &quot;LispReader::search_for(&quot; &lt;&lt; name &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
+  lisp_object_t* cursor = lst;
+
+  while(!lisp_nil_p(cursor))
+    {
+      lisp_object_t* cur = lisp_car(cursor);
+
+      if (!lisp_cons_p(cur) || !lisp_symbol_p (lisp_car(cur)))
+        {
+          lisp_dump(cur, stdout);
+          //throw ConstruoError (std::string(&quot;LispReader: Read error in search_for &quot;) + name);
+	  printf(&quot;LispReader: Read error in search\n&quot;);
+        }
+      else
+        {
+          if (strcmp(lisp_symbol(lisp_car(cur)), name) == 0)
+            {
+              return lisp_cdr(cur);
+            }
+        }
+
+      cursor = lisp_cdr (cursor);
+    }
+  return 0;
+}
+
+bool
+LispReader::read_int (const char* name, int* i)
+{
+  lisp_object_t* obj = search_for (name);
+  if (obj)
+    {
+      if (!lisp_integer_p(lisp_car(obj)))
+      {
+        //st_abort(&quot;LispReader expected type integer at token: &quot;, name); /* Instead of giving up, we return with false now. */
+	return false;
+	}
+      *i = lisp_integer(lisp_car(obj));
+      return true;
+    }
+  return false;
+}
+
+bool
+LispReader::read_lisp(const char* name, lisp_object_t** b)
+{
+  lisp_object_t* obj = search_for (name);
+  if (obj)
+    {
+      *b = obj;
+      return true;
+    }
+  else
+    return false;
+}
+
+bool
+LispReader::read_float (const char* name, float* f)
+{
+  lisp_object_t* obj = search_for (name);
+  if (obj)
+    {
+      if (!lisp_real_p(lisp_car(obj)) &amp;&amp; !lisp_integer_p(lisp_car(obj)))
+        throw LispReaderException(&quot;LispReader expected type real at token: &quot;,
+                                  __FILE__, __LINE__);
+      *f = lisp_real(lisp_car(obj));
+      return true;
+    }
+  return false;
+}
+
+bool
+LispReader::read_string_vector (const char* name, std::vector&lt;std::string&gt;* vec)
+{
+  lisp_object_t* obj = search_for (name);
+  if (obj)
+    {
+      while(!lisp_nil_p(obj))
+        {
+          if (!lisp_string_p(lisp_car(obj)))
+            throw LispReaderException(&quot;LispReader expected type string at token: &quot;, name);
+          vec-&gt;push_back(lisp_string(lisp_car(obj)));
+          obj = lisp_cdr(obj);
+        }
+      return true;
+    }
+  return false;    
+}
+
+bool
+LispReader::read_int_vector (const char* name, std::vector&lt;int&gt;* vec)
+{
+  lisp_object_t* obj = search_for (name);
+  if (obj)
+    {
+      while(!lisp_nil_p(obj))
+        {
+          if (!lisp_integer_p(lisp_car(obj)))
+            throw LispReaderException(&quot;LispReader expected type integer at token: &quot;, name);
+          vec-&gt;push_back(lisp_integer(lisp_car(obj)));
+          obj = lisp_cdr(obj);
+        }
+      return true;
+    }
+  return false;    
+}
+
+bool
+LispReader::read_char_vector (const char* name, std::vector&lt;char&gt;* vec)
+{
+  lisp_object_t* obj = search_for (name);
+  if (obj)
+    {
+      while(!lisp_nil_p(obj))
+        {
+          vec-&gt;push_back(*lisp_string(lisp_car(obj)));
+          obj = lisp_cdr(obj);
+        }
+      return true;
+    }
+  return false;    
+}
+
+bool
+LispReader::read_string (const char* name, std::string* str)
+{
+  lisp_object_t* obj = search_for (name);
+  if (obj)
+    {
+      if (!lisp_string_p(lisp_car(obj)))
+        throw LispReaderException(&quot;LispReader expected type string at token: &quot;, name);
+     *str = lisp_string(lisp_car(obj));
+      return true;
+    }
+  return false;  
+}
+
+bool
+LispReader::read_bool (const char* name, bool* b)
+{
+  lisp_object_t* obj = search_for (name);
+  if (obj)
+    {
+      if (!lisp_boolean_p(lisp_car(obj)))
+        throw LispReaderException(&quot;LispReader expected type bool at token: &quot;);
+      *b = lisp_boolean(lisp_car(obj));
+      return true;
+    }
+  return false;
+}
+
+LispWriter::LispWriter (const char* name)
+{
+  lisp_objs.push_back(lisp_make_symbol (name));
+}
+
+void
+LispWriter::append (lisp_object_t* obj)
+{
+  lisp_objs.push_back(obj);
+}
+
+lisp_object_t*
+LispWriter::make_list3 (lisp_object_t* a, lisp_object_t* b, lisp_object_t* c)
+{
+  return lisp_make_cons (a, lisp_make_cons(b, lisp_make_cons(c, lisp_nil())));
+}
+
+lisp_object_t*
+LispWriter::make_list2 (lisp_object_t* a, lisp_object_t* b)
+{
+  return lisp_make_cons (a, lisp_make_cons(b, lisp_nil()));
+}
+
+void
+LispWriter::write_float (const char* name, float f)
+{
+  append(make_list2 (lisp_make_symbol (name),
+                     lisp_make_real(f)));
+}
+
+void
+LispWriter::write_int (const char* name, int i)
+{
+  append(make_list2 (lisp_make_symbol (name),
+                     lisp_make_integer(i)));
+}
+
+void
+LispWriter::write_string (const char* name, const char* str)
+{
+  append(make_list2 (lisp_make_symbol (name),
+                     lisp_make_string(str)));
+}
+
+void
+LispWriter::write_symbol (const char* name, const char* symname)
+{
+  append(make_list2 (lisp_make_symbol (name),
+                     lisp_make_symbol(symname)));
+}
+
+void
+LispWriter::write_lisp_obj(const char* name, lisp_object_t* lst)
+{
+  append(make_list2 (lisp_make_symbol (name),
+                     lst));
+}
+
+void
+LispWriter::write_boolean (const char* name, bool b)
+{
+  append(make_list2 (lisp_make_symbol (name),
+                     lisp_make_boolean(b)));
+}
+
+lisp_object_t*
+LispWriter::create_lisp ()
+{
+  lisp_object_t* lisp_obj = lisp_nil();
+
+  for(std::vector&lt;lisp_object_t*&gt;::reverse_iterator i = lisp_objs.rbegin ();
+      i != lisp_objs.rend (); ++i)
+    {
+      lisp_obj = lisp_make_cons (*i, lisp_obj);
+    }
+  lisp_objs.clear();
+
+  return lisp_obj;
+}
+
+#if 0
+void mygzungetc(char c, void* file)
+{
+  gzungetc(c, file);
+}
+
+lisp_stream_t* lisp_stream_init_gzfile (lisp_stream_t *stream, gzFile file)
+{
+  return lisp_stream_init_any (stream, file, gzgetc, mygzungetc);
+}
+#endif
+
+lisp_object_t* lisp_read_from_gzfile(const char* filename)
+{
+  bool done = false;
+  lisp_object_t* root_obj = 0;
+  int chunk_size = 128 * 1024;
+  int buf_pos = 0;
+  int try_number = 1;
+  char* buf = static_cast&lt;char*&gt;(malloc(chunk_size));
+  if (!buf)
+    throw LispReaderException(&quot;lisp_read_from_gzfile()&quot;, __FILE__, __LINE__);
+
+  gzFile in = gzopen(filename, &quot;r&quot;);
+
+  while (!done)
+    {
+      int ret = gzread(in, buf + buf_pos, chunk_size);
+      if (ret == -1)
+        {
+          free (buf);
+          throw LispReaderException(&quot;Error while reading from file&quot;, __FILE__, __LINE__);
+        }
+      else if (ret == chunk_size) // buffer got full, eof not yet there so resize
+        {
+          buf_pos = chunk_size * try_number;
+          try_number += 1;
+          buf = static_cast&lt;char*&gt;(realloc(buf, chunk_size * try_number));
+
+          if (!buf)
+            throw LispReaderException(&quot;lisp_read_from_gzfile()&quot;, __FILE__, __LINE__);
+        }
+      else 
+        {
+          // everything fine, encountered EOF 
+          done = true;
+        }
+    }
+      
+  lisp_stream_t stream;
+  lisp_stream_init_string (&amp;stream, buf);
+  root_obj = lisp_read (&amp;stream);
+      
+  free(buf);
+  gzclose(in);
+
+  return root_obj;
+}
+
+bool has_suffix(const char* data, const char* suffix)
+{
+  int suffix_len = strlen(suffix);
+  int data_len   = strlen(data);
+  
+  const char* data_suffix = (data + data_len - suffix_len);
+
+  if (data_suffix &gt;= data)
+    {
+      return (strcmp(data_suffix, suffix) == 0);
+    }
+  else
+    {
+      return false;
+    }
+}
+
+lisp_object_t* lisp_read_from_file(const std::string&amp; filename)
+{
+  lisp_stream_t stream;
+
+  if (has_suffix(filename.c_str(), &quot;.gz&quot;))
+    {
+      return lisp_read_from_gzfile(filename.c_str());
+    }
+  else
+    {
+      lisp_object_t* obj = 0;
+      FILE* in = fopen(filename.c_str(), &quot;r&quot;);
+
+      if (in)
+        {
+          lisp_stream_init_file(&amp;stream, in);
+          obj = lisp_read(&amp;stream);
+          fclose(in);
+        }
+
+      return obj;
+    }
+}
+
+// EOF //

Deleted: trunk/flexlay/lib/lispreader.cxx
===================================================================
--- trunk/flexlay/lib/lispreader.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/lispreader.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,1358 +0,0 @@
-/* $Id: lispreader.cpp,v 1.19 2004/05/11 22:16:12 sik0fewl Exp $ */
-/*
- * lispreader.c
- *
- * Copyright (C) 1998-2000 Mark Probst
- * Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include &lt;iostream&gt;
-#include &lt;string&gt;
-#include &lt;ctype.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &quot;lispreader.hxx&quot;
-
-#define TOKEN_ERROR                   -1
-#define TOKEN_EOF                     0
-#define TOKEN_OPEN_PAREN              1
-#define TOKEN_CLOSE_PAREN             2
-#define TOKEN_SYMBOL                  3
-#define TOKEN_STRING                  4
-#define TOKEN_INTEGER                 5
-#define TOKEN_REAL                    6
-#define TOKEN_PATTERN_OPEN_PAREN      7
-#define TOKEN_DOT                     8
-#define TOKEN_TRUE                    9
-#define TOKEN_FALSE                   10
-
-
-#define MAX_TOKEN_LENGTH           1024
-
-static char token_string[MAX_TOKEN_LENGTH + 1] = &quot;&quot;;
-static int token_length = 0;
-
-static lisp_object_t end_marker = { LISP_TYPE_EOF, {{0, 0}} };
-static lisp_object_t error_object = { LISP_TYPE_PARSE_ERROR , {{0,0}}  };
-static lisp_object_t close_paren_marker = { LISP_TYPE_PARSE_ERROR , {{0,0}}  };
-static lisp_object_t dot_marker = { LISP_TYPE_PARSE_ERROR , {{0,0}} };
-
-static void
-_token_clear (void)
-{
-  token_string[0] = '\0';
-  token_length = 0;
-}
-
-static void
-_token_append (char c)
-{
-  if (token_length &gt;= MAX_TOKEN_LENGTH)
-    throw LispReaderException(&quot;_token_append()&quot;, __FILE__, __LINE__);
-
-  token_string[token_length++] = c;
-  token_string[token_length] = '\0';
-}
-
-static int
-_next_char (lisp_stream_t *stream)
-{
-  switch (stream-&gt;type)
-    {
-    case LISP_STREAM_FILE :
-      return getc(stream-&gt;v.file);
-
-    case LISP_STREAM_STRING :
-      {
-        char c = stream-&gt;v.string.buf[stream-&gt;v.string.pos];
-
-        if (c == 0)
-          return EOF;
-
-        ++stream-&gt;v.string.pos;
-
-        return c;
-      }
-
-    case LISP_STREAM_ANY:
-      return stream-&gt;v.any.next_char(stream-&gt;v.any.data);
-    }
-
-  throw LispReaderException(&quot;_next_char()&quot;, __FILE__, __LINE__);
-  return EOF;
-}
-
-static void
-_unget_char (char c, lisp_stream_t *stream)
-{
-  switch (stream-&gt;type)
-    {
-    case LISP_STREAM_FILE :
-      ungetc(c, stream-&gt;v.file);
-      break;
-
-    case LISP_STREAM_STRING :
-      --stream-&gt;v.string.pos;
-      break;
-
-    case LISP_STREAM_ANY:
-      stream-&gt;v.any.unget_char(c, stream-&gt;v.any.data);
-      break;
-
-    default :
-      throw LispReaderException(&quot;_unget_char()&quot;, __FILE__, __LINE__);
-    }
-}
-
-static int
-_scan (lisp_stream_t *stream)
-{
-  static char *delims = &quot;\&quot;();&quot;;
-
-  int c;
-
-  _token_clear();
-
-  do
-    {
-      c = _next_char(stream);
-      if (c == EOF)
-        return TOKEN_EOF;
-      else if (c == ';')     	 /* comment start */
-        while (1)
-          {
-            c = _next_char(stream);
-            if (c == EOF)
-              return TOKEN_EOF;
-            else if (c == '\n')
-              break;
-          }
-    }
-  while (isspace(c));
-
-  switch (c)
-    {
-    case '(' :
-      return TOKEN_OPEN_PAREN;
-
-    case ')' :
-      return TOKEN_CLOSE_PAREN;
-
-    case '&quot;' :
-      while (1)
-        {
-          c = _next_char(stream);
-          if (c == EOF)
-            return TOKEN_ERROR;
-          if (c == '&quot;')
-            break;
-          if (c == '\\')
-            {
-              c = _next_char(stream);
-
-              switch (c)
-                {
-                case EOF :
-                  return TOKEN_ERROR;
-
-                case 'n' :
-                  c = '\n';
-                  break;
-
-                case 't' :
-                  c = '\t';
-                  break;
-                }
-            }
-
-          _token_append(c);
-        }
-      return TOKEN_STRING;
-
-    case '#' :
-      c = _next_char(stream);
-      if (c == EOF)
-        return TOKEN_ERROR;
-
-      switch (c)
-        {
-        case 't' :
-          return TOKEN_TRUE;
-
-        case 'f' :
-          return TOKEN_FALSE;
-
-        case '?' :
-          c = _next_char(stream);
-          if (c == EOF)
-            return TOKEN_ERROR;
-
-          if (c == '(')
-            return TOKEN_PATTERN_OPEN_PAREN;
-          else
-            return TOKEN_ERROR;
-        }
-      return TOKEN_ERROR;
-
-    default :
-      if (isdigit(c) || c == '-')
-        {
-          int have_nondigits = 0;
-          int have_digits = 0;
-          int have_floating_point = 0;
-
-          do
-            {
-              if (isdigit(c))
-                have_digits = 1;
-              else if (c == '.')
-                have_floating_point++;
-              _token_append(c);
-
-              c = _next_char(stream);
-
-              if (c != EOF &amp;&amp; !isdigit(c) &amp;&amp; !isspace(c) &amp;&amp; c != '.' &amp;&amp; !strchr(delims, c))
-                have_nondigits = 1;
-            }
-          while (c != EOF &amp;&amp; !isspace(c) &amp;&amp; !strchr(delims, c));
-
-          if (c != EOF)
-            _unget_char(c, stream);
-
-          if (have_nondigits || !have_digits || have_floating_point &gt; 1)
-            return TOKEN_SYMBOL;
-          else if (have_floating_point == 1)
-            return TOKEN_REAL;
-          else
-            return TOKEN_INTEGER;
-        }
-      else
-        {
-          if (c == '.')
-            {
-              c = _next_char(stream);
-              if (c != EOF &amp;&amp; !isspace(c) &amp;&amp; !strchr(delims, c))
-                _token_append('.');
-              else
-                {
-                  _unget_char(c, stream);
-                  return TOKEN_DOT;
-                }
-            }
-          do
-            {
-              _token_append(c);
-              c = _next_char(stream);
-            }
-          while (c != EOF &amp;&amp; !isspace(c) &amp;&amp; !strchr(delims, c));
-          if (c != EOF)
-            _unget_char(c, stream);
-
-          return TOKEN_SYMBOL;
-        }
-    }
-
-  throw LispReaderException(&quot;_scan()&quot;, __FILE__, __LINE__);
-  return TOKEN_ERROR;
-}
-
-static lisp_object_t*
-lisp_object_alloc (int type)
-{
-  lisp_object_t *obj = (lisp_object_t*)malloc(sizeof(lisp_object_t));
-
-  obj-&gt;type = type;
-
-  return obj;
-}
-
-lisp_stream_t*
-lisp_stream_init_file (lisp_stream_t *stream, FILE *file)
-{
-  stream-&gt;type = LISP_STREAM_FILE;
-  stream-&gt;v.file = file;
-
-  return stream;
-}
-
-lisp_stream_t*
-lisp_stream_init_string (lisp_stream_t *stream, char *buf)
-{
-  stream-&gt;type = LISP_STREAM_STRING;
-  stream-&gt;v.string.buf = buf;
-  stream-&gt;v.string.pos = 0;
-
-  return stream;
-}
-
-lisp_stream_t*
-lisp_stream_init_any (lisp_stream_t *stream, void *data,
-                      int (*next_char) (void *data),
-                      void (*unget_char) (char c, void *data))
-{
-  if (next_char == 0 || unget_char == 0)
-    throw LispReaderException(&quot;lisp_stream_init_any()&quot;, __FILE__, __LINE__);
-
-  stream-&gt;type = LISP_STREAM_ANY;
-  stream-&gt;v.any.data = data;
-  stream-&gt;v.any.next_char= next_char;
-  stream-&gt;v.any.unget_char = unget_char;
-
-  return stream;
-}
-
-lisp_object_t*
-lisp_make_integer (int value)
-{
-  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_INTEGER);
-
-  obj-&gt;v.integer = value;
-
-  return obj;
-}
-
-lisp_object_t*
-lisp_make_real (float value)
-{
-  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_REAL);
-
-  obj-&gt;v.real = value;
-
-  return obj;
-}
-
-lisp_object_t*
-lisp_make_symbol (const char *value)
-{
-  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_SYMBOL);
-
-  obj-&gt;v.string = strdup(value);
-
-  return obj;
-}
-
-lisp_object_t*
-lisp_make_string (const char *value)
-{
-  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_STRING);
-
-  obj-&gt;v.string = strdup(value);
-
-  return obj;
-}
-
-lisp_object_t*
-lisp_make_cons (lisp_object_t *car, lisp_object_t *cdr)
-{
-  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_CONS);
-
-  obj-&gt;v.cons.car = car;
-  obj-&gt;v.cons.cdr = cdr;
-
-  return obj;
-}
-
-lisp_object_t*
-lisp_make_boolean (int value)
-{
-  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_BOOLEAN);
-
-  obj-&gt;v.integer = value ? 1 : 0;
-
-  return obj;
-}
-
-static lisp_object_t*
-lisp_make_pattern_cons (lisp_object_t *car, lisp_object_t *cdr)
-{
-  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_PATTERN_CONS);
-
-  obj-&gt;v.cons.car = car;
-  obj-&gt;v.cons.cdr = cdr;
-
-  return obj;
-}
-
-static lisp_object_t*
-lisp_make_pattern_var (int type, int index, lisp_object_t *sub)
-{
-  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_PATTERN_VAR);
-
-  obj-&gt;v.pattern.type = type;
-  obj-&gt;v.pattern.index = index;
-  obj-&gt;v.pattern.sub = sub;
-
-  return obj;
-}
-
-lisp_object_t*
-lisp_read (lisp_stream_t *in)
-{
-  int token = _scan(in);
-  lisp_object_t *obj = lisp_nil();
-
-  if (token == TOKEN_EOF)
-    return &amp;end_marker;
-
-  switch (token)
-    {
-    case TOKEN_ERROR :
-      return &amp;error_object;
-
-    case TOKEN_EOF :
-      return &amp;end_marker;
-
-    case TOKEN_OPEN_PAREN :
-    case TOKEN_PATTERN_OPEN_PAREN :
-      {
-        lisp_object_t *last = lisp_nil(), *car;
-
-        do
-          {
-            car = lisp_read(in);
-            if (car == &amp;error_object || car == &amp;end_marker)
-              {
-                lisp_free(obj);
-                return &amp;error_object;
-              }
-            else if (car == &amp;dot_marker)
-              {
-                if (lisp_nil_p(last))
-                  {
-                    lisp_free(obj);
-                    return &amp;error_object;
-                  }
-
-                car = lisp_read(in);
-                if (car == &amp;error_object || car == &amp;end_marker)
-                  {
-                    lisp_free(obj);
-                    return car;
-                  }
-                else
-                  {
-                    last-&gt;v.cons.cdr = car;
-
-                    if (_scan(in) != TOKEN_CLOSE_PAREN)
-                      {
-                        lisp_free(obj);
-                        return &amp;error_object;
-                      }
-
-                    car = &amp;close_paren_marker;
-                  }
-              }
-            else if (car != &amp;close_paren_marker)
-              {
-                if (lisp_nil_p(last))
-                  obj = last = (token == TOKEN_OPEN_PAREN ? lisp_make_cons(car, lisp_nil()) : lisp_make_pattern_cons(car, lisp_nil()));
-                else
-                  last = last-&gt;v.cons.cdr = lisp_make_cons(car, lisp_nil());
-              }
-          }
-        while (car != &amp;close_paren_marker);
-      }
-      return obj;
-
-    case TOKEN_CLOSE_PAREN :
-      return &amp;close_paren_marker;
-
-    case TOKEN_SYMBOL :
-      return lisp_make_symbol(token_string);
-
-    case TOKEN_STRING :
-      return lisp_make_string(token_string);
-
-    case TOKEN_INTEGER :
-      return lisp_make_integer(atoi(token_string));
-
-    case TOKEN_REAL :
-      return lisp_make_real((float)atof(token_string));
-
-    case TOKEN_DOT :
-      return &amp;dot_marker;
-
-    case TOKEN_TRUE :
-      return lisp_make_boolean(1);
-
-    case TOKEN_FALSE :
-      return lisp_make_boolean(0);
-    }
-
-  throw LispReaderException(&quot;lisp_read()&quot;, __FILE__, __LINE__);
-  return &amp;error_object;
-}
-
-void
-lisp_free (lisp_object_t *obj)
-{
-  if (obj == 0)
-    return;
-
-  switch (obj-&gt;type)
-    {
-    case LISP_TYPE_INTERNAL :
-    case LISP_TYPE_PARSE_ERROR :
-    case LISP_TYPE_EOF :
-      return;
-
-    case LISP_TYPE_SYMBOL :
-    case LISP_TYPE_STRING :
-      free(obj-&gt;v.string);
-      break;
-
-    case LISP_TYPE_CONS :
-    case LISP_TYPE_PATTERN_CONS :
-      lisp_free(obj-&gt;v.cons.car);
-      lisp_free(obj-&gt;v.cons.cdr);
-      break;
-
-    case LISP_TYPE_PATTERN_VAR :
-      lisp_free(obj-&gt;v.pattern.sub);
-      break;
-    }
-
-  free(obj);
-}
-
-lisp_object_t*
-lisp_read_from_string (const char *buf)
-{
-  lisp_stream_t stream;
-
-  lisp_stream_init_string(&amp;stream, (char*)buf);
-  return lisp_read(&amp;stream);
-}
-
-static int
-_compile_pattern (lisp_object_t **obj, int *index)
-{
-  if (*obj == 0)
-    return 1;
-
-  switch (lisp_type(*obj))
-    {
-    case LISP_TYPE_PATTERN_CONS :
-      {
-        struct
-          {
-            char *name;
-            int type;
-          }
-        types[] =
-          {
-            { &quot;any&quot;, LISP_PATTERN_ANY },
-            { &quot;symbol&quot;, LISP_PATTERN_SYMBOL },
-            { &quot;string&quot;, LISP_PATTERN_STRING },
-            { &quot;integer&quot;, LISP_PATTERN_INTEGER },
-            { &quot;real&quot;, LISP_PATTERN_REAL },
-            { &quot;boolean&quot;, LISP_PATTERN_BOOLEAN },
-            { &quot;list&quot;, LISP_PATTERN_LIST },
-            { &quot;or&quot;, LISP_PATTERN_OR },
-            { 0, 0 }
-          };
-        char *type_name;
-        int type;
-        int i;
-        lisp_object_t *pattern;
-        type = -1;
-	
-        if (lisp_type(lisp_car(*obj)) != LISP_TYPE_SYMBOL)
-          return 0;
-
-        type_name = lisp_symbol(lisp_car(*obj));
-        for (i = 0; types[i].name != 0; ++i)
-          {
-            if (strcmp(types[i].name, type_name) == 0)
-              {
-                type = types[i].type;
-                break;
-              }
-          }
-
-        if (types[i].name == 0)
-          return 0;
-
-        if (type != LISP_PATTERN_OR &amp;&amp; lisp_cdr(*obj) != 0)
-          return 0;
-
-        pattern = lisp_make_pattern_var(type, (*index)++, lisp_nil());
-
-        if (type == LISP_PATTERN_OR)
-          {
-            lisp_object_t *cdr = lisp_cdr(*obj);
-
-            if (!_compile_pattern(&amp;cdr, index))
-              {
-                lisp_free(pattern);
-                return 0;
-              }
-
-            pattern-&gt;v.pattern.sub = cdr;
-
-            (*obj)-&gt;v.cons.cdr = lisp_nil();
-          }
-
-        lisp_free(*obj);
-
-        *obj = pattern;
-      }
-      break;
-
-    case LISP_TYPE_CONS :
-      if (!_compile_pattern(&amp;(*obj)-&gt;v.cons.car, index))
-        return 0;
-      if (!_compile_pattern(&amp;(*obj)-&gt;v.cons.cdr, index))
-        return 0;
-      break;
-    }
-
-  return 1;
-}
-
-int
-lisp_compile_pattern (lisp_object_t **obj, int *num_subs)
-{
-  int index = 0;
-  int result;
-
-  result = _compile_pattern(obj, &amp;index);
-
-  if (result &amp;&amp; num_subs != 0)
-    *num_subs = index;
-
-  return result;
-}
-
-static int _match_pattern (lisp_object_t *pattern, lisp_object_t *obj, lisp_object_t **vars);
-
-static int
-_match_pattern_var (lisp_object_t *pattern, lisp_object_t *obj, lisp_object_t **vars)
-{
-  if (lisp_type(pattern) != LISP_TYPE_PATTERN_VAR)
-    throw LispReaderException(&quot;_match_pattern_var&quot;, __FILE__, __LINE__);
-
-  switch (pattern-&gt;v.pattern.type)
-    {
-    case LISP_PATTERN_ANY :
-      break;
-
-    case LISP_PATTERN_SYMBOL :
-      if (obj == 0 || lisp_type(obj) != LISP_TYPE_SYMBOL)
-        return 0;
-      break;
-
-    case LISP_PATTERN_STRING :
-      if (obj == 0 || lisp_type(obj) != LISP_TYPE_STRING)
-        return 0;
-      break;
-
-    case LISP_PATTERN_INTEGER :
-      if (obj == 0 || lisp_type(obj) != LISP_TYPE_INTEGER)
-        return 0;
-      break;
-
-    case LISP_PATTERN_REAL :
-      if (obj == 0 || lisp_type(obj) != LISP_TYPE_REAL)
-        return 0;
-      break;
-
-    case LISP_PATTERN_BOOLEAN :
-      if (obj == 0 || lisp_type(obj) != LISP_TYPE_BOOLEAN)
-        return 0;
-      break;
-
-    case LISP_PATTERN_LIST :
-      if (obj == 0 || lisp_type(obj) != LISP_TYPE_CONS)
-        return 0;
-      break;
-
-    case LISP_PATTERN_OR :
-      {
-        lisp_object_t *sub;
-        int matched = 0;
-
-        for (sub = pattern-&gt;v.pattern.sub; sub != 0; sub = lisp_cdr(sub))
-          {
-            if (lisp_type(sub) != LISP_TYPE_CONS)
-              throw LispReaderException(&quot;_match_pattern_var()&quot;, __FILE__, __LINE__);
-
-            if (_match_pattern(lisp_car(sub), obj, vars))
-              matched = 1;
-          }
-
-        if (!matched)
-          return 0;
-      }
-      break;
-
-    default :
-      throw LispReaderException(&quot;_match_pattern_var()&quot;, __FILE__, __LINE__);
-    }
-
-  if (vars != 0)
-    vars[pattern-&gt;v.pattern.index] = obj;
-
-  return 1;
-}
-
-static int
-_match_pattern (lisp_object_t *pattern, lisp_object_t *obj, lisp_object_t **vars)
-{
-  if (pattern == 0)
-    return obj == 0;
-
-  if (obj == 0)
-    return 0;
-
-  if (lisp_type(pattern) == LISP_TYPE_PATTERN_VAR)
-    return _match_pattern_var(pattern, obj, vars);
-
-  if (lisp_type(pattern) != lisp_type(obj))
-    return 0;
-
-  switch (lisp_type(pattern))
-    {
-    case LISP_TYPE_SYMBOL :
-      return strcmp(lisp_symbol(pattern), lisp_symbol(obj)) == 0;
-
-    case LISP_TYPE_STRING :
-      return strcmp(lisp_string(pattern), lisp_string(obj)) == 0;
-
-    case LISP_TYPE_INTEGER :
-      return lisp_integer(pattern) == lisp_integer(obj);
-
-    case LISP_TYPE_REAL :
-      return lisp_real(pattern) == lisp_real(obj);
-
-    case LISP_TYPE_CONS :
-      {
-        int result1, result2;
-
-        result1 = _match_pattern(lisp_car(pattern), lisp_car(obj), vars);
-        result2 = _match_pattern(lisp_cdr(pattern), lisp_cdr(obj), vars);
-
-        return result1 &amp;&amp; result2;
-      }
-      break;
-
-    default :
-      throw LispReaderException(&quot;_match_pattern()&quot;, __FILE__, __LINE__);
-    }
-
-  return 0;
-}
-
-int
-lisp_match_pattern (lisp_object_t *pattern, lisp_object_t *obj, lisp_object_t **vars, int num_subs)
-{
-  int i;
-
-  if (vars != 0)
-    for (i = 0; i &lt; num_subs; ++i)
-      vars[i] = &amp;error_object;
-
-  return _match_pattern(pattern, obj, vars);
-}
-
-int
-lisp_match_string (const char *pattern_string, lisp_object_t *obj, lisp_object_t **vars)
-{
-  lisp_object_t *pattern;
-  int result;
-  int num_subs;
-
-  pattern = lisp_read_from_string(pattern_string);
-
-  if (pattern != 0 &amp;&amp; (lisp_type(pattern) == LISP_TYPE_EOF
-                       || lisp_type(pattern) == LISP_TYPE_PARSE_ERROR))
-    return 0;
-
-  if (!lisp_compile_pattern(&amp;pattern, &amp;num_subs))
-    {
-      lisp_free(pattern);
-      return 0;
-    }
-
-  result = lisp_match_pattern(pattern, obj, vars, num_subs);
-
-  lisp_free(pattern);
-
-  return result;
-}
-
-int
-lisp_type (lisp_object_t *obj)
-{
-  if (obj == 0)
-    return LISP_TYPE_NIL;
-  return obj-&gt;type;
-}
-
-int
-lisp_integer (lisp_object_t *obj)
-{
-  if (obj-&gt;type != LISP_TYPE_INTEGER)
-    throw LispReaderException(&quot;lisp_integer()&quot;, __FILE__, __LINE__);
-
-  return obj-&gt;v.integer;
-}
-
-char*
-lisp_symbol (lisp_object_t *obj)
-{
-  if (obj-&gt;type != LISP_TYPE_SYMBOL)
-    throw LispReaderException(&quot;lisp_symbol()&quot;, __FILE__, __LINE__);
-
-  return obj-&gt;v.string;
-}
-
-char*
-lisp_string (lisp_object_t *obj)
-{
-  if (obj-&gt;type != LISP_TYPE_STRING)
-    throw LispReaderException(&quot;lisp_string()&quot;, __FILE__, __LINE__);
-
-  return obj-&gt;v.string;
-}
-
-int
-lisp_boolean (lisp_object_t *obj)
-{
-  if (obj-&gt;type != LISP_TYPE_BOOLEAN)
-    throw LispReaderException(&quot;lisp_boolean()&quot;, __FILE__, __LINE__);
-
-  return obj-&gt;v.integer;
-}
-
-float
-lisp_real (lisp_object_t *obj)
-{
-  if (obj-&gt;type != LISP_TYPE_REAL &amp;&amp; obj-&gt;type != LISP_TYPE_INTEGER)
-    throw LispReaderException(&quot;lisp_real()&quot;, __FILE__, __LINE__);
-
-  if (obj-&gt;type == LISP_TYPE_INTEGER)
-    return obj-&gt;v.integer;
-  return obj-&gt;v.real;
-}
-
-lisp_object_t*
-lisp_car (lisp_object_t *obj)
-{
-  if (obj-&gt;type != LISP_TYPE_CONS &amp;&amp; obj-&gt;type != LISP_TYPE_PATTERN_CONS)
-    throw LispReaderException(&quot;lisp_car()&quot;, __FILE__, __LINE__);
-
-  return obj-&gt;v.cons.car;
-}
-
-lisp_object_t*
-lisp_cdr (lisp_object_t *obj)
-{
-  if (obj-&gt;type != LISP_TYPE_CONS &amp;&amp; obj-&gt;type != LISP_TYPE_PATTERN_CONS)
-    throw LispReaderException(&quot;lisp_cdr()&quot;, __FILE__, __LINE__);
-
-  return obj-&gt;v.cons.cdr;
-}
-
-lisp_object_t*
-lisp_cxr (lisp_object_t *obj, const char *x)
-{
-  int i;
-
-  for (i = strlen(x) - 1; i &gt;= 0; --i)
-    if (x[i] == 'a')
-      obj = lisp_car(obj);
-    else if (x[i] == 'd')
-      obj = lisp_cdr(obj);
-    else
-      throw LispReaderException(&quot;lisp_cxr()&quot;, __FILE__, __LINE__);
-
-  return obj;
-}
-
-int
-lisp_list_length (lisp_object_t *obj)
-{
-  int length = 0;
-
-  while (obj != 0)
-    {
-      if (obj-&gt;type != LISP_TYPE_CONS &amp;&amp; obj-&gt;type != LISP_TYPE_PATTERN_CONS)
-        throw LispReaderException(&quot;lisp_list_length()&quot;, __FILE__, __LINE__);
-
-      ++length;
-      obj = obj-&gt;v.cons.cdr;
-    }
-
-  return length;
-}
-
-lisp_object_t*
-lisp_list_nth_cdr (lisp_object_t *obj, int index)
-{
-  while (index &gt; 0)
-    {
-      if (obj == 0)
-        throw LispReaderException(&quot;lisp_list_nth_cdr()&quot;, __FILE__, __LINE__);
-      if (obj-&gt;type != LISP_TYPE_CONS &amp;&amp; obj-&gt;type != LISP_TYPE_PATTERN_CONS)
-        throw LispReaderException(&quot;lisp_list_nth_cdr()&quot;, __FILE__, __LINE__);
-
-      --index;
-      obj = obj-&gt;v.cons.cdr;
-    }
-
-  return obj;
-}
-
-lisp_object_t*
-lisp_list_nth (lisp_object_t *obj, int index)
-{
-  obj = lisp_list_nth_cdr(obj, index);
-
-  if (obj == 0)
-    throw LispReaderException(&quot;lisp_list_nth()&quot;, __FILE__, __LINE__);
-
-  return obj-&gt;v.cons.car;
-}
-
-void
-lisp_dump (lisp_object_t *obj, FILE *out)
-{
-  if (obj == 0)
-    {
-      fprintf(out, &quot;()&quot;);
-      return;
-    }
-
-  switch (lisp_type(obj))
-    {
-    case LISP_TYPE_EOF :
-      fputs(&quot;#&lt;eof&gt;&quot;, out);
-      break;
-
-    case LISP_TYPE_PARSE_ERROR :
-      fputs(&quot;#&lt;error&gt;&quot;, out);
-      break;
-
-    case LISP_TYPE_INTEGER :
-      fprintf(out, &quot;%d&quot;, lisp_integer(obj));
-      break;
-
-    case LISP_TYPE_REAL :
-      fprintf(out, &quot;%f&quot;, lisp_real(obj));
-      break;
-
-    case LISP_TYPE_SYMBOL :
-      fputs(lisp_symbol(obj), out);
-      break;
-
-    case LISP_TYPE_STRING :
-      {
-        char *p;
-
-        fputc('&quot;', out);
-        for (p = lisp_string(obj); *p != 0; ++p)
-          {
-            if (*p == '&quot;' || *p == '\\')
-              fputc('\\', out);
-            fputc(*p, out);
-          }
-        fputc('&quot;', out);
-      }
-      break;
-
-    case LISP_TYPE_CONS :
-    case LISP_TYPE_PATTERN_CONS :
-      fputs(lisp_type(obj) == LISP_TYPE_CONS ? &quot;(&quot; : &quot;#?(&quot;, out);
-      while (obj != 0)
-        {
-          lisp_dump(lisp_car(obj), out);
-          obj = lisp_cdr(obj);
-          if (obj != 0)
-            {
-              if (lisp_type(obj) != LISP_TYPE_CONS
-                  &amp;&amp; lisp_type(obj) != LISP_TYPE_PATTERN_CONS)
-                {
-                  fputs(&quot; . &quot;, out);
-                  lisp_dump(obj, out);
-                  break;
-                }
-              else
-                fputc(' ', out);
-            }
-        }
-      fputc(')', out);
-      break;
-
-    case LISP_TYPE_BOOLEAN :
-      if (lisp_boolean(obj))
-        fputs(&quot;#t&quot;, out);
-      else
-        fputs(&quot;#f&quot;, out);
-      break;
-
-    default :
-      throw LispReaderException(&quot;lisp_dump()&quot;, __FILE__, __LINE__);
-    }
-}
-
-using namespace std;
-
-LispReader::LispReader (lisp_object_t* l)
-    : lst (l)
-{
-  //std::cout &lt;&lt; &quot;LispReader: &quot; &lt;&lt; std::flush;
-  //lisp_dump(lst, stdout);
-  //std::cout &lt;&lt; std::endl;
-}
-
-lisp_object_t*
-LispReader::search_for(const char* name)
-{
-  //std::cout &lt;&lt; &quot;LispReader::search_for(&quot; &lt;&lt; name &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
-  lisp_object_t* cursor = lst;
-
-  while(!lisp_nil_p(cursor))
-    {
-      lisp_object_t* cur = lisp_car(cursor);
-
-      if (!lisp_cons_p(cur) || !lisp_symbol_p (lisp_car(cur)))
-        {
-          lisp_dump(cur, stdout);
-          //throw ConstruoError (std::string(&quot;LispReader: Read error in search_for &quot;) + name);
-	  printf(&quot;LispReader: Read error in search\n&quot;);
-        }
-      else
-        {
-          if (strcmp(lisp_symbol(lisp_car(cur)), name) == 0)
-            {
-              return lisp_cdr(cur);
-            }
-        }
-
-      cursor = lisp_cdr (cursor);
-    }
-  return 0;
-}
-
-bool
-LispReader::read_int (const char* name, int* i)
-{
-  lisp_object_t* obj = search_for (name);
-  if (obj)
-    {
-      if (!lisp_integer_p(lisp_car(obj)))
-      {
-        //st_abort(&quot;LispReader expected type integer at token: &quot;, name); /* Instead of giving up, we return with false now. */
-	return false;
-	}
-      *i = lisp_integer(lisp_car(obj));
-      return true;
-    }
-  return false;
-}
-
-bool
-LispReader::read_lisp(const char* name, lisp_object_t** b)
-{
-  lisp_object_t* obj = search_for (name);
-  if (obj)
-    {
-      *b = obj;
-      return true;
-    }
-  else
-    return false;
-}
-
-bool
-LispReader::read_float (const char* name, float* f)
-{
-  lisp_object_t* obj = search_for (name);
-  if (obj)
-    {
-      if (!lisp_real_p(lisp_car(obj)) &amp;&amp; !lisp_integer_p(lisp_car(obj)))
-        throw LispReaderException(&quot;LispReader expected type real at token: &quot;,
-                                  __FILE__, __LINE__);
-      *f = lisp_real(lisp_car(obj));
-      return true;
-    }
-  return false;
-}
-
-bool
-LispReader::read_string_vector (const char* name, std::vector&lt;std::string&gt;* vec)
-{
-  lisp_object_t* obj = search_for (name);
-  if (obj)
-    {
-      while(!lisp_nil_p(obj))
-        {
-          if (!lisp_string_p(lisp_car(obj)))
-            throw LispReaderException(&quot;LispReader expected type string at token: &quot;, name);
-          vec-&gt;push_back(lisp_string(lisp_car(obj)));
-          obj = lisp_cdr(obj);
-        }
-      return true;
-    }
-  return false;    
-}
-
-bool
-LispReader::read_int_vector (const char* name, std::vector&lt;int&gt;* vec)
-{
-  lisp_object_t* obj = search_for (name);
-  if (obj)
-    {
-      while(!lisp_nil_p(obj))
-        {
-          if (!lisp_integer_p(lisp_car(obj)))
-            throw LispReaderException(&quot;LispReader expected type integer at token: &quot;, name);
-          vec-&gt;push_back(lisp_integer(lisp_car(obj)));
-          obj = lisp_cdr(obj);
-        }
-      return true;
-    }
-  return false;    
-}
-
-bool
-LispReader::read_char_vector (const char* name, std::vector&lt;char&gt;* vec)
-{
-  lisp_object_t* obj = search_for (name);
-  if (obj)
-    {
-      while(!lisp_nil_p(obj))
-        {
-          vec-&gt;push_back(*lisp_string(lisp_car(obj)));
-          obj = lisp_cdr(obj);
-        }
-      return true;
-    }
-  return false;    
-}
-
-bool
-LispReader::read_string (const char* name, std::string* str)
-{
-  lisp_object_t* obj = search_for (name);
-  if (obj)
-    {
-      if (!lisp_string_p(lisp_car(obj)))
-        throw LispReaderException(&quot;LispReader expected type string at token: &quot;, name);
-     *str = lisp_string(lisp_car(obj));
-      return true;
-    }
-  return false;  
-}
-
-bool
-LispReader::read_bool (const char* name, bool* b)
-{
-  lisp_object_t* obj = search_for (name);
-  if (obj)
-    {
-      if (!lisp_boolean_p(lisp_car(obj)))
-        throw LispReaderException(&quot;LispReader expected type bool at token: &quot;);
-      *b = lisp_boolean(lisp_car(obj));
-      return true;
-    }
-  return false;
-}
-
-LispWriter::LispWriter (const char* name)
-{
-  lisp_objs.push_back(lisp_make_symbol (name));
-}
-
-void
-LispWriter::append (lisp_object_t* obj)
-{
-  lisp_objs.push_back(obj);
-}
-
-lisp_object_t*
-LispWriter::make_list3 (lisp_object_t* a, lisp_object_t* b, lisp_object_t* c)
-{
-  return lisp_make_cons (a, lisp_make_cons(b, lisp_make_cons(c, lisp_nil())));
-}
-
-lisp_object_t*
-LispWriter::make_list2 (lisp_object_t* a, lisp_object_t* b)
-{
-  return lisp_make_cons (a, lisp_make_cons(b, lisp_nil()));
-}
-
-void
-LispWriter::write_float (const char* name, float f)
-{
-  append(make_list2 (lisp_make_symbol (name),
-                     lisp_make_real(f)));
-}
-
-void
-LispWriter::write_int (const char* name, int i)
-{
-  append(make_list2 (lisp_make_symbol (name),
-                     lisp_make_integer(i)));
-}
-
-void
-LispWriter::write_string (const char* name, const char* str)
-{
-  append(make_list2 (lisp_make_symbol (name),
-                     lisp_make_string(str)));
-}
-
-void
-LispWriter::write_symbol (const char* name, const char* symname)
-{
-  append(make_list2 (lisp_make_symbol (name),
-                     lisp_make_symbol(symname)));
-}
-
-void
-LispWriter::write_lisp_obj(const char* name, lisp_object_t* lst)
-{
-  append(make_list2 (lisp_make_symbol (name),
-                     lst));
-}
-
-void
-LispWriter::write_boolean (const char* name, bool b)
-{
-  append(make_list2 (lisp_make_symbol (name),
-                     lisp_make_boolean(b)));
-}
-
-lisp_object_t*
-LispWriter::create_lisp ()
-{
-  lisp_object_t* lisp_obj = lisp_nil();
-
-  for(std::vector&lt;lisp_object_t*&gt;::reverse_iterator i = lisp_objs.rbegin ();
-      i != lisp_objs.rend (); ++i)
-    {
-      lisp_obj = lisp_make_cons (*i, lisp_obj);
-    }
-  lisp_objs.clear();
-
-  return lisp_obj;
-}
-
-#if 0
-void mygzungetc(char c, void* file)
-{
-  gzungetc(c, file);
-}
-
-lisp_stream_t* lisp_stream_init_gzfile (lisp_stream_t *stream, gzFile file)
-{
-  return lisp_stream_init_any (stream, file, gzgetc, mygzungetc);
-}
-#endif
-
-lisp_object_t* lisp_read_from_gzfile(const char* filename)
-{
-  bool done = false;
-  lisp_object_t* root_obj = 0;
-  int chunk_size = 128 * 1024;
-  int buf_pos = 0;
-  int try_number = 1;
-  char* buf = static_cast&lt;char*&gt;(malloc(chunk_size));
-  if (!buf)
-    throw LispReaderException(&quot;lisp_read_from_gzfile()&quot;, __FILE__, __LINE__);
-
-  gzFile in = gzopen(filename, &quot;r&quot;);
-
-  while (!done)
-    {
-      int ret = gzread(in, buf + buf_pos, chunk_size);
-      if (ret == -1)
-        {
-          free (buf);
-          throw LispReaderException(&quot;Error while reading from file&quot;, __FILE__, __LINE__);
-        }
-      else if (ret == chunk_size) // buffer got full, eof not yet there so resize
-        {
-          buf_pos = chunk_size * try_number;
-          try_number += 1;
-          buf = static_cast&lt;char*&gt;(realloc(buf, chunk_size * try_number));
-
-          if (!buf)
-            throw LispReaderException(&quot;lisp_read_from_gzfile()&quot;, __FILE__, __LINE__);
-        }
-      else 
-        {
-          // everything fine, encountered EOF 
-          done = true;
-        }
-    }
-      
-  lisp_stream_t stream;
-  lisp_stream_init_string (&amp;stream, buf);
-  root_obj = lisp_read (&amp;stream);
-      
-  free(buf);
-  gzclose(in);
-
-  return root_obj;
-}
-
-bool has_suffix(const char* data, const char* suffix)
-{
-  int suffix_len = strlen(suffix);
-  int data_len   = strlen(data);
-  
-  const char* data_suffix = (data + data_len - suffix_len);
-
-  if (data_suffix &gt;= data)
-    {
-      return (strcmp(data_suffix, suffix) == 0);
-    }
-  else
-    {
-      return false;
-    }
-}
-
-lisp_object_t* lisp_read_from_file(const std::string&amp; filename)
-{
-  lisp_stream_t stream;
-
-  if (has_suffix(filename.c_str(), &quot;.gz&quot;))
-    {
-      return lisp_read_from_gzfile(filename.c_str());
-    }
-  else
-    {
-      lisp_object_t* obj = 0;
-      FILE* in = fopen(filename.c_str(), &quot;r&quot;);
-
-      if (in)
-        {
-          lisp_stream_init_file(&amp;stream, in);
-          obj = lisp_read(&amp;stream);
-          fclose(in);
-        }
-
-      return obj;
-    }
-}
-
-// EOF //

Copied: trunk/flexlay/lib/lispreader.hpp (from rev 712, trunk/flexlay/lib/lispreader.hxx)

Deleted: trunk/flexlay/lib/lispreader.hxx
===================================================================
--- trunk/flexlay/lib/lispreader.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/lispreader.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,222 +0,0 @@
-/* $Id: lispreader.h,v 1.9 2004/05/11 22:16:12 sik0fewl Exp $ */
-/*
- * lispreader.h
- *
- * Copyright (C) 1998-2000 Mark Probst
- * Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef __LISPREADER_H__
-#define __LISPREADER_H__
-
-#include &lt;stdio.h&gt;
-#include &lt;zlib.h&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;exception&gt;
-
-#define LISP_STREAM_FILE       1
-#define LISP_STREAM_STRING     2
-#define LISP_STREAM_ANY        3
-
-#define LISP_TYPE_INTERNAL      -3
-#define LISP_TYPE_PARSE_ERROR   -2
-#define LISP_TYPE_EOF           -1
-#define LISP_TYPE_NIL           0
-#define LISP_TYPE_SYMBOL        1
-#define LISP_TYPE_INTEGER       2
-#define LISP_TYPE_STRING        3
-#define LISP_TYPE_REAL          4
-#define LISP_TYPE_CONS          5
-#define LISP_TYPE_PATTERN_CONS  6
-#define LISP_TYPE_BOOLEAN       7
-#define LISP_TYPE_PATTERN_VAR   8
-
-#define LISP_PATTERN_ANY        1
-#define LISP_PATTERN_SYMBOL     2
-#define LISP_PATTERN_STRING     3
-#define LISP_PATTERN_INTEGER    4
-#define LISP_PATTERN_REAL       5
-#define LISP_PATTERN_BOOLEAN    6
-#define LISP_PATTERN_LIST       7
-#define LISP_PATTERN_OR         8
-
-class LispReaderException : public std::exception
-{
-  public:
-    LispReaderException(const char* _message, const char* _file = &quot;&quot;, const unsigned int _line = 0)
-      : message(_message), file(_file), line(_line) { };
-    virtual ~LispReaderException() throw() { };
-
-    const char* what() const throw() { return message; };
-    const char* what_file() const throw() { return file; };
-    const unsigned int what_line() const throw() { return line; };
-    
-  private:
-    const char* message;
-    const char* file;
-    const unsigned int line;
-};
-
-typedef struct
-{
-  int type;
-
-  union
-  {
-    FILE *file;
-    struct
-    {
-      char *buf;
-      int pos;
-    }
-    string;
-    struct
-    {
-      void *data;
-      int (*next_char) (void *data);
-      void (*unget_char) (char c, void *data);
-    }
-    any;
-  } v;
-}
-lisp_stream_t;
-
-typedef struct _lisp_object_t lisp_object_t;
-struct _lisp_object_t
-{
-  int type;
-
-  union
-  {
-    struct
-    {
-      struct _lisp_object_t *car;
-      struct _lisp_object_t *cdr;
-    }
-    cons;
-
-    char *string;
-    int integer;
-    float real;
-
-    struct
-    {
-      int type;
-      int index;
-      struct _lisp_object_t *sub;
-    }
-    pattern;
-  } v;
-};
-
-lisp_stream_t* lisp_stream_init_gzfile (lisp_stream_t *stream, gzFile file);
-lisp_stream_t* lisp_stream_init_file (lisp_stream_t *stream, FILE *file);
-lisp_stream_t* lisp_stream_init_string (lisp_stream_t *stream, char *buf);
-lisp_stream_t* lisp_stream_init_any (lisp_stream_t *stream, void *data,
-                                     int (*next_char) (void *data),
-                                     void (*unget_char) (char c, void *data));
-
-lisp_object_t* lisp_read (lisp_stream_t *in);
-lisp_object_t* lisp_read_from_file(const std::string&amp; filename);
-void lisp_free (lisp_object_t *obj);
-
-lisp_object_t* lisp_read_from_string (const char *buf);
-
-int lisp_compile_pattern (lisp_object_t **obj, int *num_subs);
-int lisp_match_pattern (lisp_object_t *pattern, lisp_object_t *obj, lisp_object_t **vars, int num_subs);
-int lisp_match_string (const char *pattern_string, lisp_object_t *obj, lisp_object_t **vars);
-
-int lisp_type (lisp_object_t *obj);
-int lisp_integer (lisp_object_t *obj);
-float lisp_real (lisp_object_t *obj);
-char* lisp_symbol (lisp_object_t *obj);
-char* lisp_string (lisp_object_t *obj);
-int lisp_boolean (lisp_object_t *obj);
-lisp_object_t* lisp_car (lisp_object_t *obj);
-lisp_object_t* lisp_cdr (lisp_object_t *obj);
-
-lisp_object_t* lisp_cxr (lisp_object_t *obj, const char *x);
-
-lisp_object_t* lisp_make_integer (int value);
-lisp_object_t* lisp_make_real (float value);
-lisp_object_t* lisp_make_symbol (const char *value);
-lisp_object_t* lisp_make_string (const char *value);
-lisp_object_t* lisp_make_cons (lisp_object_t *car, lisp_object_t *cdr);
-lisp_object_t* lisp_make_boolean (int value);
-
-int lisp_list_length (lisp_object_t *obj);
-lisp_object_t* lisp_list_nth_cdr (lisp_object_t *obj, int index);
-lisp_object_t* lisp_list_nth (lisp_object_t *obj, int index);
-
-void lisp_dump (lisp_object_t *obj, FILE *out);
-
-#define lisp_nil()           ((lisp_object_t*)0)
-
-#define lisp_nil_p(obj)      (obj == 0)
-#define lisp_integer_p(obj)  (lisp_type((obj)) == LISP_TYPE_INTEGER)
-#define lisp_real_p(obj)     (lisp_type((obj)) == LISP_TYPE_REAL)
-#define lisp_symbol_p(obj)   (lisp_type((obj)) == LISP_TYPE_SYMBOL)
-#define lisp_string_p(obj)   (lisp_type((obj)) == LISP_TYPE_STRING)
-#define lisp_cons_p(obj)     (lisp_type((obj)) == LISP_TYPE_CONS)
-#define lisp_boolean_p(obj)  (lisp_type((obj)) == LISP_TYPE_BOOLEAN)
-
-/** */
-class LispReader
-{
-private:
-  lisp_object_t* lst;
-
-  lisp_object_t* search_for(const char* name);
-public:
-  /** cur == ((pos 1 2 3) (id 12 3 4)...) */
-  LispReader (lisp_object_t* l);
-
-  bool read_int_vector (const char* name, std::vector&lt;int&gt;* vec);
-  bool read_char_vector (const char* name, std::vector&lt;char&gt;* vec);
-  bool read_string_vector (const char* name, std::vector&lt;std::string&gt;* vec);
-  bool read_string (const char* name, std::string* str);
-  bool read_int (const char* name, int* i);
-  bool read_float (const char* name, float* f);
-  bool read_bool (const char* name, bool* b);
-  bool read_lisp (const char* name, lisp_object_t** b);
-};
-
-/** */
-class LispWriter
-{
-private:
-  std::vector&lt;lisp_object_t*&gt; lisp_objs;
-
-  void append (lisp_object_t* obj);
-  lisp_object_t* make_list3 (lisp_object_t*, lisp_object_t*, lisp_object_t*);
-  lisp_object_t* make_list2 (lisp_object_t*, lisp_object_t*);
-public:
-  LispWriter (const char* name);
-  void write_float (const char* name, float f);
-  void write_int (const char* name, int i);
-  void write_boolean (const char* name, bool b);
-  void write_string (const char* name, const char* str);
-  void write_symbol (const char* name, const char* symname);
-  void write_lisp_obj(const char* name, lisp_object_t* lst);
-
-  /** caller is responible to free the returned lisp_object_t */
-  lisp_object_t* create_lisp ();
-};
-
-#endif

Copied: trunk/flexlay/lib/marker_stroke_drawer.cpp (from rev 712, trunk/flexlay/lib/marker_stroke_drawer.cxx)
===================================================================
--- trunk/flexlay/lib/marker_stroke_drawer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/marker_stroke_drawer.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,135 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;ClanLib/gl.h&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &quot;stroke_drawer_impl.hpp&quot;
+#include &quot;stroke.hpp&quot;
+#include &quot;drawer_properties.hpp&quot;
+#include &quot;marker_stroke_drawer.hpp&quot;
+
+class MarkerStrokeDrawerImpl : public StrokeDrawerImpl
+{
+public:
+  MarkerStrokeDrawerImpl() {}
+
+  void draw(const Stroke&amp; stroke, CL_GraphicContext* gc)
+  {
+    CL_OpenGLState state(CL_Display::get_current_window()-&gt;get_gc());
+    state.set_active();
+    state.setup_2d();
+
+    CL_Color color = DrawerProperties::current()-&gt;get_color();
+
+    const Stroke::Dabs&amp; dabs = stroke.get_interpolated_dabs(DrawerProperties::current()-&gt;get_spacing(),
+                                                            DrawerProperties::current()-&gt;get_spacing());
+
+    if (dabs.size() &gt;= 2)
+      {
+        std::vector&lt;CL_Pointf&gt; normals;
+        
+        if (stroke.get_dab_count() == 2)
+          {
+            normals.push_back(CL_Pointf(1.0f, 1.0f));
+            normals.push_back(CL_Pointf(1.0f, 1.0f));
+          }
+        else if (stroke.get_dab_count() &gt;= 3)
+          {
+            for(Stroke::Dabs::size_type i = 0; i &lt; dabs.size()-1; ++i)
+              {
+                CL_Pointf normal((dabs[i].pos.y - dabs[i+1].pos.y),
+                                 -(dabs[i].pos.x - dabs[i+1].pos.x));
+
+                float length = sqrt(normal.x * normal.x + normal.y * normal.y);
+
+                normal.x /= length;
+                normal.y /= length;
+          
+                normals.push_back(normal);
+              }
+      
+            normals.push_back(CL_Pointf(1.0f, 1.0f));
+          }
+
+        float len  = DrawerProperties::current()-&gt;get_size() * 8.0f;
+        float len2 = DrawerProperties::current()-&gt;get_size() * 16.0f;
+            
+        glEnable(GL_BLEND);
+        glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );
+
+        glBegin(GL_QUAD_STRIP);
+        for(unsigned int j = 0; j &lt; dabs.size()-2; ++j)
+          {
+            glColor4ub(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
+            glVertex2f(dabs[j].pos.x + normals[j].x * len,
+                       dabs[j].pos.y + normals[j].y * len);
+
+            glColor4ub(color.get_red(), color.get_green(), color.get_blue(), 0);
+            glVertex2f(dabs[j].pos.x + normals[j].x * len2,
+                       dabs[j].pos.y + normals[j].y * len2);
+          }
+        glEnd();
+
+        glBegin(GL_QUAD_STRIP);
+        for(unsigned int j = 0; j &lt; dabs.size()-2; ++j)
+          {
+            glColor4ub(color.get_red(), color.get_green(), color.get_blue(), 0);
+            glVertex2f(dabs[j].pos.x - normals[j].x * len2,
+                       dabs[j].pos.y - normals[j].y * len2);
+
+            glColor4ub(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
+            glVertex2f(dabs[j].pos.x - normals[j].x * len,
+                       dabs[j].pos.y - normals[j].y * len);
+          }
+        glEnd();
+
+        glBegin(GL_QUAD_STRIP);
+        glColor4ub(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
+        for(unsigned int j = 0; j &lt; dabs.size()-2; ++j)
+          {
+            glVertex2f(dabs[j].pos.x + normals[j].x * len,
+                       dabs[j].pos.y + normals[j].y * len);
+            glVertex2f(dabs[j].pos.x - normals[j].x * len,
+                       dabs[j].pos.y - normals[j].y * len);
+          }
+        glEnd();
+      }
+  }
+
+  StrokeDrawerImpl* clone() const 
+  {
+    MarkerStrokeDrawerImpl* drawer = new MarkerStrokeDrawerImpl();
+  
+    *drawer = *this;
+    
+    return drawer;
+  }
+};
+
+MarkerStrokeDrawer::MarkerStrokeDrawer()
+  : impl(new MarkerStrokeDrawerImpl())
+{
+}
+
+StrokeDrawer
+MarkerStrokeDrawer::to_drawer()
+{
+  return StrokeDrawer(impl);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/marker_stroke_drawer.cxx
===================================================================
--- trunk/flexlay/lib/marker_stroke_drawer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/marker_stroke_drawer.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,135 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;ClanLib/gl.h&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-#include &quot;stroke_drawer_impl.hxx&quot;
-#include &quot;stroke.hxx&quot;
-#include &quot;drawer_properties.hxx&quot;
-#include &quot;marker_stroke_drawer.hxx&quot;
-
-class MarkerStrokeDrawerImpl : public StrokeDrawerImpl
-{
-public:
-  MarkerStrokeDrawerImpl() {}
-
-  void draw(const Stroke&amp; stroke, CL_GraphicContext* gc)
-  {
-    CL_OpenGLState state(CL_Display::get_current_window()-&gt;get_gc());
-    state.set_active();
-    state.setup_2d();
-
-    CL_Color color = DrawerProperties::current()-&gt;get_color();
-
-    const Stroke::Dabs&amp; dabs = stroke.get_interpolated_dabs(DrawerProperties::current()-&gt;get_spacing(),
-                                                            DrawerProperties::current()-&gt;get_spacing());
-
-    if (dabs.size() &gt;= 2)
-      {
-        std::vector&lt;CL_Pointf&gt; normals;
-        
-        if (stroke.get_dab_count() == 2)
-          {
-            normals.push_back(CL_Pointf(1.0f, 1.0f));
-            normals.push_back(CL_Pointf(1.0f, 1.0f));
-          }
-        else if (stroke.get_dab_count() &gt;= 3)
-          {
-            for(Stroke::Dabs::size_type i = 0; i &lt; dabs.size()-1; ++i)
-              {
-                CL_Pointf normal((dabs[i].pos.y - dabs[i+1].pos.y),
-                                 -(dabs[i].pos.x - dabs[i+1].pos.x));
-
-                float length = sqrt(normal.x * normal.x + normal.y * normal.y);
-
-                normal.x /= length;
-                normal.y /= length;
-          
-                normals.push_back(normal);
-              }
-      
-            normals.push_back(CL_Pointf(1.0f, 1.0f));
-          }
-
-        float len  = DrawerProperties::current()-&gt;get_size() * 8.0f;
-        float len2 = DrawerProperties::current()-&gt;get_size() * 16.0f;
-            
-        glEnable(GL_BLEND);
-        glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );
-
-        glBegin(GL_QUAD_STRIP);
-        for(unsigned int j = 0; j &lt; dabs.size()-2; ++j)
-          {
-            glColor4ub(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
-            glVertex2f(dabs[j].pos.x + normals[j].x * len,
-                       dabs[j].pos.y + normals[j].y * len);
-
-            glColor4ub(color.get_red(), color.get_green(), color.get_blue(), 0);
-            glVertex2f(dabs[j].pos.x + normals[j].x * len2,
-                       dabs[j].pos.y + normals[j].y * len2);
-          }
-        glEnd();
-
-        glBegin(GL_QUAD_STRIP);
-        for(unsigned int j = 0; j &lt; dabs.size()-2; ++j)
-          {
-            glColor4ub(color.get_red(), color.get_green(), color.get_blue(), 0);
-            glVertex2f(dabs[j].pos.x - normals[j].x * len2,
-                       dabs[j].pos.y - normals[j].y * len2);
-
-            glColor4ub(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
-            glVertex2f(dabs[j].pos.x - normals[j].x * len,
-                       dabs[j].pos.y - normals[j].y * len);
-          }
-        glEnd();
-
-        glBegin(GL_QUAD_STRIP);
-        glColor4ub(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
-        for(unsigned int j = 0; j &lt; dabs.size()-2; ++j)
-          {
-            glVertex2f(dabs[j].pos.x + normals[j].x * len,
-                       dabs[j].pos.y + normals[j].y * len);
-            glVertex2f(dabs[j].pos.x - normals[j].x * len,
-                       dabs[j].pos.y - normals[j].y * len);
-          }
-        glEnd();
-      }
-  }
-
-  StrokeDrawerImpl* clone() const 
-  {
-    MarkerStrokeDrawerImpl* drawer = new MarkerStrokeDrawerImpl();
-  
-    *drawer = *this;
-    
-    return drawer;
-  }
-};
-
-MarkerStrokeDrawer::MarkerStrokeDrawer()
-  : impl(new MarkerStrokeDrawerImpl())
-{
-}
-
-StrokeDrawer
-MarkerStrokeDrawer::to_drawer()
-{
-  return StrokeDrawer(impl);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/marker_stroke_drawer.hpp (from rev 712, trunk/flexlay/lib/marker_stroke_drawer.hxx)
===================================================================
--- trunk/flexlay/lib/marker_stroke_drawer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/marker_stroke_drawer.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,41 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_MARKER_STROKE_DRAWER_HXX
+#define HEADER_MARKER_STROKE_DRAWER_HXX
+
+#include &quot;stroke_drawer.hpp&quot;
+
+class MarkerStrokeDrawerImpl;
+
+/** */
+class MarkerStrokeDrawer
+{
+private:
+public:
+  MarkerStrokeDrawer();
+  
+  StrokeDrawer to_drawer();
+
+private:
+  SharedPtr&lt;MarkerStrokeDrawerImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/marker_stroke_drawer.hxx
===================================================================
--- trunk/flexlay/lib/marker_stroke_drawer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/marker_stroke_drawer.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,41 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_MARKER_STROKE_DRAWER_HXX
-#define HEADER_MARKER_STROKE_DRAWER_HXX
-
-#include &quot;stroke_drawer.hxx&quot;
-
-class MarkerStrokeDrawerImpl;
-
-/** */
-class MarkerStrokeDrawer
-{
-private:
-public:
-  MarkerStrokeDrawer();
-  
-  StrokeDrawer to_drawer();
-
-private:
-  SharedPtr&lt;MarkerStrokeDrawerImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/math.hpp (from rev 712, trunk/flexlay/lib/math.hxx)

Deleted: trunk/flexlay/lib/math.hxx
===================================================================
--- trunk/flexlay/lib/math.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/math.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,52 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_MATH_HXX
-#define HEADER_MATH_HXX
-
-namespace Math {
-
-template&lt;class T&gt; 
-T min (const T&amp; a, const T&amp; b) 
-{
-  if (a &lt; b)
-    return a;
-  else
-    return b;
-}
-
-template&lt;class T&gt; 
-T max (const T&amp; a, const T&amp; b) 
-{
-  if (a &gt; b)
-    return a;
-  else
-    return b;
-}
-
-template&lt;class T&gt; 
-T mid (const T&amp; a, const T&amp; b, const T&amp; c) 
-{
-  return max&lt;T&gt;((a), min&lt;T&gt;((b), (c)));
-}
-
-} // namespace Math
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/menu.cpp (from rev 712, trunk/flexlay/lib/menu.cxx)
===================================================================
--- trunk/flexlay/lib/menu.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/menu.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,292 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &lt;string&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &lt;ClanLib/Display/sprite.h&gt;
+#include &quot;fonts.hpp&quot;
+#include &quot;box.hpp&quot;
+#include &quot;menu.hpp&quot;
+
+class MenuItem;
+
+class MenuImpl
+{
+public:
+  Menu* parent;
+  std::vector&lt;CL_Slot&gt; slots;
+
+  typedef std::vector&lt;MenuItem*&gt; Items;
+  Items items;
+  
+  int current_item;
+
+  int width;
+  int height;
+
+  MenuImpl() {
+    current_item = -1;
+  }
+
+  void draw();
+  void recalc_size();
+  int  get_width();
+  int  get_height();
+
+  void on_mouse_move(const CL_InputEvent&amp; event);
+  void on_mouse_down(const CL_InputEvent&amp; event);
+};
+
+class MenuItem
+{
+protected:
+  MenuImpl* parent;
+  CL_Signal_v0 on_clicked;
+
+public:
+  MenuItem(MenuImpl* parent_) 
+    : parent(parent_) {}
+
+  virtual ~MenuItem() {}
+
+  virtual void draw(int x, int y, bool active) =0;
+  virtual int get_width() =0;
+  virtual int get_height() =0;
+
+  CL_Signal_v0&amp; sig_clicked() { return on_clicked; }
+};
+
+class SeparatorMenuItem : public MenuItem
+{
+public:
+  SeparatorMenuItem(MenuImpl* parent_) 
+    : MenuItem(parent_)
+  {}
+  virtual ~SeparatorMenuItem() {}
+
+  void draw(int x, int y, bool active) 
+  {
+    CL_Display::fill_rect(CL_Rect(CL_Point(x, y), CL_Size(parent-&gt;get_width()-7, 2)), 
+                          CL_Color(150, 150, 150));
+    CL_Display::fill_rect(CL_Rect(CL_Point(x, y+1), CL_Size(parent-&gt;get_width()-7, 1)),
+                          CL_Color(255, 255, 255));
+  }
+
+  int get_width()  { return 10; }
+  int get_height() { return 2; }
+};
+
+class TextMenuItem : public MenuItem
+{
+private:
+  CL_Sprite sprite;
+  std::string text;
+
+public:
+  TextMenuItem(const CL_Sprite&amp; sprite_, const std::string&amp; text_, MenuImpl* parent_)
+    : MenuItem(parent_),
+      sprite(sprite_),
+      text(text_) 
+  {
+    if (sprite)
+      sprite.set_alignment(origin_center);
+  }
+
+  virtual ~TextMenuItem() {}
+
+  void draw(int x, int y, bool active) {
+    if (active)
+      CL_Display::fill_rect(CL_Rect(CL_Point(x, y-2), CL_Size(parent-&gt;get_width() - 7, 18)), 
+                            CL_Color(255, 255, 255));
+    if (sprite)
+      {
+        sprite.draw(x+10, y+7);
+      }
+    Fonts::verdana11.draw(x+24, y, text);
+  }
+  int get_width()  { return Fonts::verdana11.bounding_rect(0, 0, text).get_width() + 16; }
+  int get_height() { return Fonts::verdana11.get_height(); }
+};
+
+Menu::Menu(const CL_Point&amp; pos, CL_Component* parent)
+  : CL_Component(CL_Rect(pos, CL_Size(1,1)), parent),
+    impl(new MenuImpl())
+{
+  impl-&gt;parent = this;
+
+  impl-&gt;width  = 1;
+  impl-&gt;height = 1;
+
+  impl-&gt;slots.push_back(sig_paint().connect(impl.get(), &amp;MenuImpl::draw));
+  impl-&gt;slots.push_back(sig_mouse_move().connect(impl.get(), &amp;MenuImpl::on_mouse_move));
+  impl-&gt;slots.push_back(sig_mouse_down().connect(impl.get(), &amp;MenuImpl::on_mouse_down));
+
+  show(false);
+}
+
+Menu::~Menu()
+{
+  clear();
+}
+
+void
+Menu::clear()
+{
+  for(MenuImpl::Items::iterator i = impl-&gt;items.begin(); i != impl-&gt;items.end(); ++i)
+    delete *i;
+  impl-&gt;items.clear();
+}
+
+MenuItemHandle
+Menu::add_separator()
+{
+  impl-&gt;items.push_back(new SeparatorMenuItem(impl.get()));
+  impl-&gt;recalc_size();
+  return impl-&gt;items.size()-1;
+}
+
+MenuItemHandle
+Menu::add_item(const std::string&amp; name)
+{
+  impl-&gt;items.push_back(new TextMenuItem(CL_Sprite(), name, impl.get()));
+  impl-&gt;recalc_size();
+  return impl-&gt;items.size()-1;
+}
+
+MenuItemHandle
+Menu::add_item(const CL_Sprite&amp; sprite, const std::string&amp; name)
+{
+  impl-&gt;items.push_back(new TextMenuItem(sprite, name, impl.get()));
+  impl-&gt;recalc_size();
+  return impl-&gt;items.size()-1;
+}
+
+MenuItemHandle
+Menu::add_submenu(const std::string&amp; name, const Menu&amp; submenu)
+{
+  impl-&gt;recalc_size();
+  return -1;
+}
+
+void
+MenuImpl::recalc_size()
+{
+  height = 0;
+  width = 0;
+
+  for(Items::iterator i = items.begin(); i != items.end(); ++i)
+    width = std::max(width, (*i)-&gt;get_width());
+
+  for(Items::iterator i = items.begin(); i != items.end(); ++i)
+    height += (*i)-&gt;get_height() + 6;
+  
+  width  += 12 + 24;
+  height += 8;
+
+  parent-&gt;set_size(width, height);
+}
+
+void
+MenuImpl::draw()
+{
+  CL_Display::push_translate(parent-&gt;get_screen_x(), parent-&gt;get_screen_y());
+
+  Box::draw_window(CL_Rect(CL_Point(0, 0), 
+                           CL_Size(parent-&gt;get_width(),
+                                   parent-&gt;get_height())));
+  int x_pos = 3;
+  int y_pos = 6;
+
+  for(int i = 0; i &lt; int(items.size()); ++i)
+    {
+      if (i == current_item)
+        items[i]-&gt;draw(x_pos, y_pos, true);
+      else
+        items[i]-&gt;draw(x_pos, y_pos, false);
+      y_pos += items[i]-&gt;get_height() + 6;
+    }
+  CL_Display::pop_modelview();
+}
+
+int
+MenuImpl::get_width()
+{
+  return width;
+}
+
+int
+MenuImpl::get_height()
+{
+  return height;
+}
+
+void
+MenuImpl::on_mouse_down(const CL_InputEvent&amp; event)
+{
+  if (current_item != -1)
+    {
+      items[current_item]-&gt;sig_clicked()();
+    }
+  parent-&gt;release_mouse();
+  parent-&gt;show(false);
+}
+
+void
+MenuImpl::on_mouse_move(const CL_InputEvent&amp; event)
+{
+  if (parent-&gt;has_mouse_over())
+    {
+      int y_pos = 6;
+
+      for(int i = 0; i &lt; int(items.size()); ++i)
+        {
+          y_pos += items[i]-&gt;get_height() + 6;      
+          if (y_pos &gt; event.mouse_pos.y)
+            {
+              current_item = i;
+              return;
+            }
+        }
+      current_item = -1;
+    }
+  else
+    {
+      current_item = -1;
+    }
+}
+
+CL_Signal_v0&amp;
+Menu::sig_clicked(MenuItemHandle item)
+{
+  return impl-&gt;items[item]-&gt;sig_clicked();
+}
+
+void
+Menu::run()
+{
+  // FIXME: Make menu act sane on == 0 items
+  if (impl-&gt;items.size() &gt; 0)
+    {
+      show(true);
+      capture_mouse();
+      raise();
+    }
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/menu.cxx
===================================================================
--- trunk/flexlay/lib/menu.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/menu.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,292 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &lt;string&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-#include &lt;ClanLib/Display/sprite.h&gt;
-#include &quot;fonts.hxx&quot;
-#include &quot;box.hxx&quot;
-#include &quot;menu.hxx&quot;
-
-class MenuItem;
-
-class MenuImpl
-{
-public:
-  Menu* parent;
-  std::vector&lt;CL_Slot&gt; slots;
-
-  typedef std::vector&lt;MenuItem*&gt; Items;
-  Items items;
-  
-  int current_item;
-
-  int width;
-  int height;
-
-  MenuImpl() {
-    current_item = -1;
-  }
-
-  void draw();
-  void recalc_size();
-  int  get_width();
-  int  get_height();
-
-  void on_mouse_move(const CL_InputEvent&amp; event);
-  void on_mouse_down(const CL_InputEvent&amp; event);
-};
-
-class MenuItem
-{
-protected:
-  MenuImpl* parent;
-  CL_Signal_v0 on_clicked;
-
-public:
-  MenuItem(MenuImpl* parent_) 
-    : parent(parent_) {}
-
-  virtual ~MenuItem() {}
-
-  virtual void draw(int x, int y, bool active) =0;
-  virtual int get_width() =0;
-  virtual int get_height() =0;
-
-  CL_Signal_v0&amp; sig_clicked() { return on_clicked; }
-};
-
-class SeparatorMenuItem : public MenuItem
-{
-public:
-  SeparatorMenuItem(MenuImpl* parent_) 
-    : MenuItem(parent_)
-  {}
-  virtual ~SeparatorMenuItem() {}
-
-  void draw(int x, int y, bool active) 
-  {
-    CL_Display::fill_rect(CL_Rect(CL_Point(x, y), CL_Size(parent-&gt;get_width()-7, 2)), 
-                          CL_Color(150, 150, 150));
-    CL_Display::fill_rect(CL_Rect(CL_Point(x, y+1), CL_Size(parent-&gt;get_width()-7, 1)),
-                          CL_Color(255, 255, 255));
-  }
-
-  int get_width()  { return 10; }
-  int get_height() { return 2; }
-};
-
-class TextMenuItem : public MenuItem
-{
-private:
-  CL_Sprite sprite;
-  std::string text;
-
-public:
-  TextMenuItem(const CL_Sprite&amp; sprite_, const std::string&amp; text_, MenuImpl* parent_)
-    : MenuItem(parent_),
-      sprite(sprite_),
-      text(text_) 
-  {
-    if (sprite)
-      sprite.set_alignment(origin_center);
-  }
-
-  virtual ~TextMenuItem() {}
-
-  void draw(int x, int y, bool active) {
-    if (active)
-      CL_Display::fill_rect(CL_Rect(CL_Point(x, y-2), CL_Size(parent-&gt;get_width() - 7, 18)), 
-                            CL_Color(255, 255, 255));
-    if (sprite)
-      {
-        sprite.draw(x+10, y+7);
-      }
-    Fonts::verdana11.draw(x+24, y, text);
-  }
-  int get_width()  { return Fonts::verdana11.bounding_rect(0, 0, text).get_width() + 16; }
-  int get_height() { return Fonts::verdana11.get_height(); }
-};
-
-Menu::Menu(const CL_Point&amp; pos, CL_Component* parent)
-  : CL_Component(CL_Rect(pos, CL_Size(1,1)), parent),
-    impl(new MenuImpl())
-{
-  impl-&gt;parent = this;
-
-  impl-&gt;width  = 1;
-  impl-&gt;height = 1;
-
-  impl-&gt;slots.push_back(sig_paint().connect(impl.get(), &amp;MenuImpl::draw));
-  impl-&gt;slots.push_back(sig_mouse_move().connect(impl.get(), &amp;MenuImpl::on_mouse_move));
-  impl-&gt;slots.push_back(sig_mouse_down().connect(impl.get(), &amp;MenuImpl::on_mouse_down));
-
-  show(false);
-}
-
-Menu::~Menu()
-{
-  clear();
-}
-
-void
-Menu::clear()
-{
-  for(MenuImpl::Items::iterator i = impl-&gt;items.begin(); i != impl-&gt;items.end(); ++i)
-    delete *i;
-  impl-&gt;items.clear();
-}
-
-MenuItemHandle
-Menu::add_separator()
-{
-  impl-&gt;items.push_back(new SeparatorMenuItem(impl.get()));
-  impl-&gt;recalc_size();
-  return impl-&gt;items.size()-1;
-}
-
-MenuItemHandle
-Menu::add_item(const std::string&amp; name)
-{
-  impl-&gt;items.push_back(new TextMenuItem(CL_Sprite(), name, impl.get()));
-  impl-&gt;recalc_size();
-  return impl-&gt;items.size()-1;
-}
-
-MenuItemHandle
-Menu::add_item(const CL_Sprite&amp; sprite, const std::string&amp; name)
-{
-  impl-&gt;items.push_back(new TextMenuItem(sprite, name, impl.get()));
-  impl-&gt;recalc_size();
-  return impl-&gt;items.size()-1;
-}
-
-MenuItemHandle
-Menu::add_submenu(const std::string&amp; name, const Menu&amp; submenu)
-{
-  impl-&gt;recalc_size();
-  return -1;
-}
-
-void
-MenuImpl::recalc_size()
-{
-  height = 0;
-  width = 0;
-
-  for(Items::iterator i = items.begin(); i != items.end(); ++i)
-    width = std::max(width, (*i)-&gt;get_width());
-
-  for(Items::iterator i = items.begin(); i != items.end(); ++i)
-    height += (*i)-&gt;get_height() + 6;
-  
-  width  += 12 + 24;
-  height += 8;
-
-  parent-&gt;set_size(width, height);
-}
-
-void
-MenuImpl::draw()
-{
-  CL_Display::push_translate(parent-&gt;get_screen_x(), parent-&gt;get_screen_y());
-
-  Box::draw_window(CL_Rect(CL_Point(0, 0), 
-                           CL_Size(parent-&gt;get_width(),
-                                   parent-&gt;get_height())));
-  int x_pos = 3;
-  int y_pos = 6;
-
-  for(int i = 0; i &lt; int(items.size()); ++i)
-    {
-      if (i == current_item)
-        items[i]-&gt;draw(x_pos, y_pos, true);
-      else
-        items[i]-&gt;draw(x_pos, y_pos, false);
-      y_pos += items[i]-&gt;get_height() + 6;
-    }
-  CL_Display::pop_modelview();
-}
-
-int
-MenuImpl::get_width()
-{
-  return width;
-}
-
-int
-MenuImpl::get_height()
-{
-  return height;
-}
-
-void
-MenuImpl::on_mouse_down(const CL_InputEvent&amp; event)
-{
-  if (current_item != -1)
-    {
-      items[current_item]-&gt;sig_clicked()();
-    }
-  parent-&gt;release_mouse();
-  parent-&gt;show(false);
-}
-
-void
-MenuImpl::on_mouse_move(const CL_InputEvent&amp; event)
-{
-  if (parent-&gt;has_mouse_over())
-    {
-      int y_pos = 6;
-
-      for(int i = 0; i &lt; int(items.size()); ++i)
-        {
-          y_pos += items[i]-&gt;get_height() + 6;      
-          if (y_pos &gt; event.mouse_pos.y)
-            {
-              current_item = i;
-              return;
-            }
-        }
-      current_item = -1;
-    }
-  else
-    {
-      current_item = -1;
-    }
-}
-
-CL_Signal_v0&amp;
-Menu::sig_clicked(MenuItemHandle item)
-{
-  return impl-&gt;items[item]-&gt;sig_clicked();
-}
-
-void
-Menu::run()
-{
-  // FIXME: Make menu act sane on == 0 items
-  if (impl-&gt;items.size() &gt; 0)
-    {
-      show(true);
-      capture_mouse();
-      raise();
-    }
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/menu.hpp (from rev 712, trunk/flexlay/lib/menu.hxx)
===================================================================
--- trunk/flexlay/lib/menu.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/menu.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,57 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_MENU_HXX
+#define HEADER_MENU_HXX
+
+#include &lt;string&gt;
+#include &lt;ClanLib/GUI/component.h&gt;
+#include &lt;ClanLib/Core/Math/rect.h&gt;
+#include &quot;shared_ptr.hpp&quot;
+
+class MenuImpl;
+class CL_Sprite;
+
+typedef int MenuItemHandle;
+
+/** */
+class Menu : public CL_Component
+{
+protected:
+  virtual ~Menu();
+
+public:
+  Menu(const CL_Point&amp; pos, CL_Component* parent);
+
+  void clear();
+
+  MenuItemHandle add_item(const std::string&amp; name);
+  MenuItemHandle add_item(const CL_Sprite&amp; sprite, const std::string&amp; name);
+  MenuItemHandle add_submenu(const std::string&amp; name, const Menu&amp; submenu);
+  MenuItemHandle add_separator();
+
+  CL_Signal_v0&amp; sig_clicked(MenuItemHandle item);
+
+  void run();
+private:
+  SharedPtr&lt;MenuImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/menu.hxx
===================================================================
--- trunk/flexlay/lib/menu.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/menu.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,57 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_MENU_HXX
-#define HEADER_MENU_HXX
-
-#include &lt;string&gt;
-#include &lt;ClanLib/GUI/component.h&gt;
-#include &lt;ClanLib/Core/Math/rect.h&gt;
-#include &quot;shared_ptr.hxx&quot;
-
-class MenuImpl;
-class CL_Sprite;
-
-typedef int MenuItemHandle;
-
-/** */
-class Menu : public CL_Component
-{
-protected:
-  virtual ~Menu();
-
-public:
-  Menu(const CL_Point&amp; pos, CL_Component* parent);
-
-  void clear();
-
-  MenuItemHandle add_item(const std::string&amp; name);
-  MenuItemHandle add_item(const CL_Sprite&amp; sprite, const std::string&amp; name);
-  MenuItemHandle add_submenu(const std::string&amp; name, const Menu&amp; submenu);
-  MenuItemHandle add_separator();
-
-  CL_Signal_v0&amp; sig_clicked(MenuItemHandle item);
-
-  void run();
-private:
-  SharedPtr&lt;MenuImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/menubar.cpp (from rev 712, trunk/flexlay/lib/menubar.cxx)
===================================================================
--- trunk/flexlay/lib/menubar.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/menubar.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,52 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &quot;menu.hpp&quot;
+#include &quot;menubar.hpp&quot;
+
+class MenubarItem
+{
+public:
+  MenubarItem(const std::string&amp; name_, Menu* menu_)
+    : name(name_), menu(menu_){}
+
+  std::string name;
+  Menu* menu;
+};
+
+class MenubarImpl
+{
+public:
+  typedef std::vector&lt;MenubarItem&gt; Items;
+  Items items;
+};
+
+Menubar::Menubar(const CL_Point&amp; pos, CL_Component* parent)
+  : CL_Component(CL_Rect(pos, CL_Size(1, 1)), parent),
+    impl(new MenubarImpl())
+{
+  
+}
+
+void
+Menubar::add_submenu(const std::string&amp; name, Menu* menu)
+{
+  impl-&gt;items.push_back(MenubarItem(name, menu));
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/menubar.cxx
===================================================================
--- trunk/flexlay/lib/menubar.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/menubar.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,52 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &quot;menu.hxx&quot;
-#include &quot;menubar.hxx&quot;
-
-class MenubarItem
-{
-public:
-  MenubarItem(const std::string&amp; name_, Menu* menu_)
-    : name(name_), menu(menu_){}
-
-  std::string name;
-  Menu* menu;
-};
-
-class MenubarImpl
-{
-public:
-  typedef std::vector&lt;MenubarItem&gt; Items;
-  Items items;
-};
-
-Menubar::Menubar(const CL_Point&amp; pos, CL_Component* parent)
-  : CL_Component(CL_Rect(pos, CL_Size(1, 1)), parent),
-    impl(new MenubarImpl())
-{
-  
-}
-
-void
-Menubar::add_submenu(const std::string&amp; name, Menu* menu)
-{
-  impl-&gt;items.push_back(MenubarItem(name, menu));
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/menubar.hpp (from rev 712, trunk/flexlay/lib/menubar.hxx)
===================================================================
--- trunk/flexlay/lib/menubar.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/menubar.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,44 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_MENUBAR_HXX
+#define HEADER_MENUBAR_HXX
+
+#include &lt;ClanLib/GUI/component.h&gt;
+#include &lt;ClanLib/Core/Math/rect.h&gt;
+#include &quot;shared_ptr.hpp&quot;
+
+class Menu;
+class MenubarImpl;
+
+/** */
+class Menubar : public CL_Component
+{
+protected:
+  virtual ~Menubar() {}
+public:
+  Menubar(const CL_Point&amp; pos, CL_Component* parent);
+
+  void add_submenu(const std::string&amp; name, Menu* menu);
+private:
+  SharedPtr&lt;MenubarImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/menubar.hxx
===================================================================
--- trunk/flexlay/lib/menubar.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/menubar.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,44 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_MENUBAR_HXX
-#define HEADER_MENUBAR_HXX
-
-#include &lt;ClanLib/GUI/component.h&gt;
-#include &lt;ClanLib/Core/Math/rect.h&gt;
-#include &quot;shared_ptr.hxx&quot;
-
-class Menu;
-class MenubarImpl;
-
-/** */
-class Menubar : public CL_Component
-{
-protected:
-  virtual ~Menubar() {}
-public:
-  Menubar(const CL_Point&amp; pos, CL_Component* parent);
-
-  void add_submenu(const std::string&amp; name, Menu* menu);
-private:
-  SharedPtr&lt;MenubarImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/meta_data.cpp (from rev 712, trunk/flexlay/lib/meta_data.cxx)
===================================================================
--- trunk/flexlay/lib/meta_data.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/meta_data.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,40 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &quot;meta_data.hpp&quot;
+
+MetaData::MetaData()
+{
+}
+
+MetaData::MetaData(SharedPtr&lt;MetaDataImpl&gt; impl_)
+  : impl(impl_)
+{
+}
+
+MetaData::~MetaData()
+{
+}
+
+SharedPtr&lt;MetaDataImpl&gt;
+MetaData::get_impl() const
+{
+  return impl;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/meta_data.cxx
===================================================================
--- trunk/flexlay/lib/meta_data.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/meta_data.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,40 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &quot;meta_data.hxx&quot;
-
-MetaData::MetaData()
-{
-}
-
-MetaData::MetaData(SharedPtr&lt;MetaDataImpl&gt; impl_)
-  : impl(impl_)
-{
-}
-
-MetaData::~MetaData()
-{
-}
-
-SharedPtr&lt;MetaDataImpl&gt;
-MetaData::get_impl() const
-{
-  return impl;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/meta_data.hpp (from rev 712, trunk/flexlay/lib/meta_data.hxx)
===================================================================
--- trunk/flexlay/lib/meta_data.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/meta_data.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,42 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_META_DATA_HXX
+#define HEADER_META_DATA_HXX
+
+#include &quot;shared_ptr.hpp&quot;
+
+class MetaDataImpl;
+
+/** */
+class MetaData
+{
+private:
+public:
+  MetaData();
+  MetaData(SharedPtr&lt;MetaDataImpl&gt; impl_);
+  ~MetaData();
+  
+  SharedPtr&lt;MetaDataImpl&gt; get_impl() const;
+private:
+  SharedPtr&lt;MetaDataImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/meta_data.hxx
===================================================================
--- trunk/flexlay/lib/meta_data.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/meta_data.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,42 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_META_DATA_HXX
-#define HEADER_META_DATA_HXX
-
-#include &quot;shared_ptr.hxx&quot;
-
-class MetaDataImpl;
-
-/** */
-class MetaData
-{
-private:
-public:
-  MetaData();
-  MetaData(SharedPtr&lt;MetaDataImpl&gt; impl_);
-  ~MetaData();
-  
-  SharedPtr&lt;MetaDataImpl&gt; get_impl() const;
-private:
-  SharedPtr&lt;MetaDataImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/meta_data_impl.hpp (from rev 712, trunk/flexlay/lib/meta_data_impl.hxx)

Deleted: trunk/flexlay/lib/meta_data_impl.hxx
===================================================================
--- trunk/flexlay/lib/meta_data_impl.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/meta_data_impl.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,43 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_META_DATA_IMPL_HXX
-#define HEADER_META_DATA_IMPL_HXX
-
-/** */
-class MetaDataImpl
-{
-private:
-public:
-  MetaDataImpl() {}
-  virtual ~MetaDataImpl() {}
-};
-
-template&lt;class T&gt; 
-class MetaDataGeneric : public MetaDataImpl
-{
-public:
-  T data;
-
-  MetaDataGeneric(const T&amp; d)
-    : data(d) {}
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/minimap.cpp (from rev 712, trunk/flexlay/lib/minimap.cxx)
===================================================================
--- trunk/flexlay/lib/minimap.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/minimap.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,235 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &lt;ClanLib/Display/pixel_format.h&gt;
+#include &lt;ClanLib/Display/pixel_buffer.h&gt;
+#include &quot;tile.hpp&quot;
+#include &quot;tileset.hpp&quot;
+#include &quot;editor_map.hpp&quot;
+#include &quot;editor_map_component.hpp&quot;
+#include &quot;tilemap_layer.hpp&quot;
+#include &quot;workspace.hpp&quot;
+#include &quot;minimap.hpp&quot;
+
+class MinimapImpl
+{
+public:
+  std::vector&lt;CL_Slot&gt; slots;
+  bool drag_active;
+  
+  int last_serial;
+  EditorMap editor_map;
+
+  EditorMapComponent* parent;
+  CL_Surface minimap_surface;
+
+  MinimapImpl() 
+    : editor_map(false)
+  {}
+  void update_minimap_surface();
+};
+
+Minimap::Minimap(EditorMapComponent* p, const CL_Rect&amp; rect,
+                 CL_Component* parent)
+  : CL_Component(rect, parent), 
+    impl(new MinimapImpl())
+{
+  impl-&gt;slots.push_back(sig_paint().connect(this, &amp;Minimap::draw));
+  impl-&gt;slots.push_back(sig_mouse_move().connect(this, &amp;Minimap::mouse_move));
+  impl-&gt;slots.push_back(sig_mouse_down().connect(this, &amp;Minimap::mouse_down));
+  impl-&gt;slots.push_back(sig_mouse_up().connect(this, &amp;Minimap::mouse_up));
+
+  impl-&gt;parent = p ? p : EditorMapComponent::current();
+  impl-&gt;drag_active = false;
+  impl-&gt;last_serial = -1;
+}
+
+void
+Minimap::draw()
+{
+  if (impl-&gt;parent-&gt;get_workspace().get_map().is_null()) return;
+
+  if (!impl-&gt;parent || impl-&gt;parent-&gt;get_workspace().is_null())
+    return;
+
+  CL_Display::push_cliprect(get_screen_rect());
+  CL_Display::push_translate(get_screen_x(), get_screen_y());
+
+  // FIXME: Do this only on map changes
+  if (impl-&gt;last_serial != impl-&gt;parent-&gt;get_workspace().get_map().get_serial())
+    //      || editor_map != parent-&gt;get_workspace().get_map())
+    {
+      impl-&gt;update_minimap_surface();
+      impl-&gt;last_serial = impl-&gt;parent-&gt;get_workspace().get_map().get_serial();
+      impl-&gt;editor_map  = impl-&gt;parent-&gt;get_workspace().get_map();
+    }
+
+  if (1)
+    { // Draw background color
+      CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
+                                    CL_Size(get_width(),
+                                            get_height())),
+                            CL_Color(200, 200, 200, 225));
+    }
+
+  // FIXME: This doesn't work all that well
+  TilemapLayer tilemap = TilemapLayer::current();
+
+  if (!tilemap.is_null() &amp;&amp; tilemap.get_height() != 0 &amp;&amp; tilemap.get_width() != 0)
+    {
+      int tile_size = tilemap.get_tileset().get_tile_size();
+
+      int map_width  = tilemap.get_width()  * tile_size;
+      int map_height = tilemap.get_height() * tile_size;
+
+      CL_Size small_tile(tile_size * get_width() / map_width + 1,
+                         tile_size * get_height() / map_height + 1);
+
+      Field&lt;int&gt;* field = tilemap.get_field();
+
+      // FIXME: No current tileset
+      if (0)
+        {
+          for(int y = 0; y &lt; field-&gt;get_height(); ++y)
+            for(int x = 0; x &lt; field-&gt;get_width(); ++x)
+              {
+                Tile* tile = tilemap.get_tileset().create(field-&gt;at(x, y));
+                if (tile)
+                  CL_Display::fill_rect(CL_Rect(CL_Point((x * tile_size) * get_width() / map_width,
+                                                         (y * tile_size) * get_height() / map_height),
+                                                small_tile),
+                                        tile-&gt;get_color());
+                CL_Display::flush();
+              }
+        }
+      impl-&gt;minimap_surface.draw(CL_Rect(CL_Point(0, 0),
+                                   CL_Size(get_width(), get_height())));
+
+      // Draw cursor
+      CL_Rect rect(impl-&gt;parent-&gt;get_clip_rect());
+      CL_Rect screen_rect(CL_Point(rect.left  * get_width()  / map_width,
+                                   rect.top   * get_height() / map_height),
+                          CL_Size(rect.get_width() * get_width() /map_width,
+                                  rect.get_height()* get_height()/map_height));
+      CL_Display::fill_rect(screen_rect,
+                            CL_Color(255, 255, 0, 50));
+      CL_Display::draw_rect(screen_rect,
+                            CL_Color(0, 0, 0));
+    }
+
+  CL_Display::pop_modelview();
+  CL_Display::pop_cliprect();
+}
+
+void
+MinimapImpl::update_minimap_surface()
+{
+  // FIXME: This doesn't work all that well
+  TilemapLayer tilemap = TilemapLayer::current();
+  
+  if (!tilemap.is_null())
+    {
+      Field&lt;int&gt;* field = tilemap.get_field();
+
+      CL_PixelBuffer buffer(tilemap.get_width(), tilemap.get_height(), 
+                            tilemap.get_width()*4, CL_PixelFormat::rgba8888);
+  
+      int map_width  = tilemap.get_width();
+      int map_height = tilemap.get_height();
+
+      // FIXME: No Tileset::current()
+      unsigned char* buf = static_cast&lt;unsigned char*&gt;(buffer.get_data());
+      for(int y = 0; y &lt; map_height; ++y)
+        for(int x = 0; x &lt; map_width; ++x)
+          {
+            Tile* tile = tilemap.get_tileset().create(field-&gt;at(x, y));
+            if (tile)
+              {
+                buf[4*(x + y * map_width) + 3] = tile-&gt;get_color().get_red();
+                buf[4*(x + y * map_width) + 2] = tile-&gt;get_color().get_green();
+                buf[4*(x + y * map_width) + 1] = tile-&gt;get_color().get_blue();
+                buf[4*(x + y * map_width) + 0] = tile-&gt;get_color().get_alpha();
+              } 
+            else
+              {
+                buf[4*(x + y * map_width) + 0] = 0;
+                buf[4*(x + y * map_width) + 1] = 0;
+                buf[4*(x + y * map_width) + 2] = 0;
+                buf[4*(x + y * map_width) + 3] = 0;
+              }
+          }
+
+      minimap_surface = CL_Surface(buffer);
+    }
+}
+
+void
+Minimap::mouse_move(const CL_InputEvent&amp; event)
+{
+  // FIXME: This doesn't work all that well
+  TilemapLayer tilemap = TilemapLayer::current();
+  if (!tilemap.is_null())
+    {
+      int tile_size  = tilemap.get_tileset().get_tile_size();
+      int map_width  = tilemap.get_width()  * tile_size;
+      int map_height = tilemap.get_height() * tile_size;
+
+      if (impl-&gt;drag_active)
+        impl-&gt;parent-&gt;move_to(event.mouse_pos.x * map_width / get_width(),
+                              event.mouse_pos.y * map_height / get_height());
+    }
+}
+
+void
+Minimap::mouse_down(const CL_InputEvent&amp; event)
+{
+  // FIXME: This doesn't work all that well
+  TilemapLayer tilemap = TilemapLayer::current();
+  if (!tilemap.is_null())
+    {
+      int tile_size  = tilemap.get_tileset().get_tile_size();
+      int map_width  = tilemap.get_width()  * tile_size;
+      int map_height = tilemap.get_height() * tile_size;
+
+      impl-&gt;parent-&gt;move_to(event.mouse_pos.x * map_width / get_width(),
+                            event.mouse_pos.y * map_height / get_height());
+      impl-&gt;drag_active = true;
+      capture_mouse();
+    }
+}
+
+void
+Minimap::mouse_up  (const CL_InputEvent&amp; event)
+{
+  TilemapLayer tilemap = TilemapLayer::current();
+  if (!tilemap.is_null())
+    {
+      impl-&gt;drag_active = false;
+      release_mouse();
+    }
+}
+
+void
+Minimap::update_minimap()
+{
+  impl-&gt;update_minimap_surface();
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/minimap.cxx
===================================================================
--- trunk/flexlay/lib/minimap.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/minimap.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,235 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-#include &lt;ClanLib/Display/pixel_format.h&gt;
-#include &lt;ClanLib/Display/pixel_buffer.h&gt;
-#include &quot;tile.hxx&quot;
-#include &quot;tileset.hxx&quot;
-#include &quot;editor_map.hxx&quot;
-#include &quot;editor_map_component.hxx&quot;
-#include &quot;tilemap_layer.hxx&quot;
-#include &quot;workspace.hxx&quot;
-#include &quot;minimap.hxx&quot;
-
-class MinimapImpl
-{
-public:
-  std::vector&lt;CL_Slot&gt; slots;
-  bool drag_active;
-  
-  int last_serial;
-  EditorMap editor_map;
-
-  EditorMapComponent* parent;
-  CL_Surface minimap_surface;
-
-  MinimapImpl() 
-    : editor_map(false)
-  {}
-  void update_minimap_surface();
-};
-
-Minimap::Minimap(EditorMapComponent* p, const CL_Rect&amp; rect,
-                 CL_Component* parent)
-  : CL_Component(rect, parent), 
-    impl(new MinimapImpl())
-{
-  impl-&gt;slots.push_back(sig_paint().connect(this, &amp;Minimap::draw));
-  impl-&gt;slots.push_back(sig_mouse_move().connect(this, &amp;Minimap::mouse_move));
-  impl-&gt;slots.push_back(sig_mouse_down().connect(this, &amp;Minimap::mouse_down));
-  impl-&gt;slots.push_back(sig_mouse_up().connect(this, &amp;Minimap::mouse_up));
-
-  impl-&gt;parent = p ? p : EditorMapComponent::current();
-  impl-&gt;drag_active = false;
-  impl-&gt;last_serial = -1;
-}
-
-void
-Minimap::draw()
-{
-  if (impl-&gt;parent-&gt;get_workspace().get_map().is_null()) return;
-
-  if (!impl-&gt;parent || impl-&gt;parent-&gt;get_workspace().is_null())
-    return;
-
-  CL_Display::push_cliprect(get_screen_rect());
-  CL_Display::push_translate(get_screen_x(), get_screen_y());
-
-  // FIXME: Do this only on map changes
-  if (impl-&gt;last_serial != impl-&gt;parent-&gt;get_workspace().get_map().get_serial())
-    //      || editor_map != parent-&gt;get_workspace().get_map())
-    {
-      impl-&gt;update_minimap_surface();
-      impl-&gt;last_serial = impl-&gt;parent-&gt;get_workspace().get_map().get_serial();
-      impl-&gt;editor_map  = impl-&gt;parent-&gt;get_workspace().get_map();
-    }
-
-  if (1)
-    { // Draw background color
-      CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
-                                    CL_Size(get_width(),
-                                            get_height())),
-                            CL_Color(200, 200, 200, 225));
-    }
-
-  // FIXME: This doesn't work all that well
-  TilemapLayer tilemap = TilemapLayer::current();
-
-  if (!tilemap.is_null() &amp;&amp; tilemap.get_height() != 0 &amp;&amp; tilemap.get_width() != 0)
-    {
-      int tile_size = tilemap.get_tileset().get_tile_size();
-
-      int map_width  = tilemap.get_width()  * tile_size;
-      int map_height = tilemap.get_height() * tile_size;
-
-      CL_Size small_tile(tile_size * get_width() / map_width + 1,
-                         tile_size * get_height() / map_height + 1);
-
-      Field&lt;int&gt;* field = tilemap.get_field();
-
-      // FIXME: No current tileset
-      if (0)
-        {
-          for(int y = 0; y &lt; field-&gt;get_height(); ++y)
-            for(int x = 0; x &lt; field-&gt;get_width(); ++x)
-              {
-                Tile* tile = tilemap.get_tileset().create(field-&gt;at(x, y));
-                if (tile)
-                  CL_Display::fill_rect(CL_Rect(CL_Point((x * tile_size) * get_width() / map_width,
-                                                         (y * tile_size) * get_height() / map_height),
-                                                small_tile),
-                                        tile-&gt;get_color());
-                CL_Display::flush();
-              }
-        }
-      impl-&gt;minimap_surface.draw(CL_Rect(CL_Point(0, 0),
-                                   CL_Size(get_width(), get_height())));
-
-      // Draw cursor
-      CL_Rect rect(impl-&gt;parent-&gt;get_clip_rect());
-      CL_Rect screen_rect(CL_Point(rect.left  * get_width()  / map_width,
-                                   rect.top   * get_height() / map_height),
-                          CL_Size(rect.get_width() * get_width() /map_width,
-                                  rect.get_height()* get_height()/map_height));
-      CL_Display::fill_rect(screen_rect,
-                            CL_Color(255, 255, 0, 50));
-      CL_Display::draw_rect(screen_rect,
-                            CL_Color(0, 0, 0));
-    }
-
-  CL_Display::pop_modelview();
-  CL_Display::pop_cliprect();
-}
-
-void
-MinimapImpl::update_minimap_surface()
-{
-  // FIXME: This doesn't work all that well
-  TilemapLayer tilemap = TilemapLayer::current();
-  
-  if (!tilemap.is_null())
-    {
-      Field&lt;int&gt;* field = tilemap.get_field();
-
-      CL_PixelBuffer buffer(tilemap.get_width(), tilemap.get_height(), 
-                            tilemap.get_width()*4, CL_PixelFormat::rgba8888);
-  
-      int map_width  = tilemap.get_width();
-      int map_height = tilemap.get_height();
-
-      // FIXME: No Tileset::current()
-      unsigned char* buf = static_cast&lt;unsigned char*&gt;(buffer.get_data());
-      for(int y = 0; y &lt; map_height; ++y)
-        for(int x = 0; x &lt; map_width; ++x)
-          {
-            Tile* tile = tilemap.get_tileset().create(field-&gt;at(x, y));
-            if (tile)
-              {
-                buf[4*(x + y * map_width) + 3] = tile-&gt;get_color().get_red();
-                buf[4*(x + y * map_width) + 2] = tile-&gt;get_color().get_green();
-                buf[4*(x + y * map_width) + 1] = tile-&gt;get_color().get_blue();
-                buf[4*(x + y * map_width) + 0] = tile-&gt;get_color().get_alpha();
-              } 
-            else
-              {
-                buf[4*(x + y * map_width) + 0] = 0;
-                buf[4*(x + y * map_width) + 1] = 0;
-                buf[4*(x + y * map_width) + 2] = 0;
-                buf[4*(x + y * map_width) + 3] = 0;
-              }
-          }
-
-      minimap_surface = CL_Surface(buffer);
-    }
-}
-
-void
-Minimap::mouse_move(const CL_InputEvent&amp; event)
-{
-  // FIXME: This doesn't work all that well
-  TilemapLayer tilemap = TilemapLayer::current();
-  if (!tilemap.is_null())
-    {
-      int tile_size  = tilemap.get_tileset().get_tile_size();
-      int map_width  = tilemap.get_width()  * tile_size;
-      int map_height = tilemap.get_height() * tile_size;
-
-      if (impl-&gt;drag_active)
-        impl-&gt;parent-&gt;move_to(event.mouse_pos.x * map_width / get_width(),
-                              event.mouse_pos.y * map_height / get_height());
-    }
-}
-
-void
-Minimap::mouse_down(const CL_InputEvent&amp; event)
-{
-  // FIXME: This doesn't work all that well
-  TilemapLayer tilemap = TilemapLayer::current();
-  if (!tilemap.is_null())
-    {
-      int tile_size  = tilemap.get_tileset().get_tile_size();
-      int map_width  = tilemap.get_width()  * tile_size;
-      int map_height = tilemap.get_height() * tile_size;
-
-      impl-&gt;parent-&gt;move_to(event.mouse_pos.x * map_width / get_width(),
-                            event.mouse_pos.y * map_height / get_height());
-      impl-&gt;drag_active = true;
-      capture_mouse();
-    }
-}
-
-void
-Minimap::mouse_up  (const CL_InputEvent&amp; event)
-{
-  TilemapLayer tilemap = TilemapLayer::current();
-  if (!tilemap.is_null())
-    {
-      impl-&gt;drag_active = false;
-      release_mouse();
-    }
-}
-
-void
-Minimap::update_minimap()
-{
-  impl-&gt;update_minimap_surface();
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/minimap.hpp (from rev 712, trunk/flexlay/lib/minimap.hxx)

Deleted: trunk/flexlay/lib/minimap.hxx
===================================================================
--- trunk/flexlay/lib/minimap.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/minimap.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,47 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_MINIMAP_HXX
-#define HEADER_MINIMAP_HXX
-
-#include &lt;ClanLib/GUI/component.h&gt;
-
-class MinimapImpl;
-
-/** */
-class Minimap : public CL_Component
-{
-protected:
-  virtual ~Minimap() {}
-public:
-  Minimap(EditorMapComponent* p, const CL_Rect&amp; rect, CL_Component* parent);
-  
-  void draw();
-  void update_minimap();
-
-  void mouse_move(const CL_InputEvent&amp; event);
-  void mouse_down(const CL_InputEvent&amp; event);
-  void mouse_up  (const CL_InputEvent&amp; event);
-  
-private:
-  SharedPtr&lt;MinimapImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/object_add_command.cpp (from rev 712, trunk/flexlay/lib/object_add_command.cxx)
===================================================================
--- trunk/flexlay/lib/object_add_command.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_add_command.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,93 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &quot;object_layer.hpp&quot;
+#include &quot;objmap_object.hpp&quot;
+#include &quot;object_add_command.hpp&quot;
+
+class ObjectAddCommandImpl : public CommandImpl
+{
+public:
+  ObjectLayer objmap;
+  std::vector&lt;ObjMapObject&gt; objs;
+
+  ObjectAddCommandImpl() {}
+  virtual ~ObjectAddCommandImpl() {}
+
+  void execute();
+  void undo();
+  void redo();
+
+  std::string serialize();
+};
+
+ObjectAddCommand::ObjectAddCommand(const ObjectLayer&amp; objmap_)
+  : impl(new ObjectAddCommandImpl())
+{
+  impl-&gt;objmap = objmap_;
+}
+
+ObjectAddCommand::~ObjectAddCommand()
+{
+}
+
+/*int
+ObjectAddCommand::get_handle() const
+{ 
+  return impl-&gt;obj-&gt;get_handle(); 
+}*/
+
+void
+ObjectAddCommand::add_object(const ObjMapObject&amp; obj)
+{
+  impl-&gt;objs.push_back(obj);
+}
+
+void
+ObjectAddCommandImpl::execute()
+{
+  for(std::vector&lt;ObjMapObject&gt;::iterator i = objs.begin(); i != objs.end(); ++i)
+    objmap.add_object(*i);
+}
+
+void
+ObjectAddCommandImpl::undo()
+{
+  for(std::vector&lt;ObjMapObject&gt;::iterator i = objs.begin(); i != objs.end(); ++i)
+    objmap.delete_object(*i);
+}
+
+void
+ObjectAddCommandImpl::redo()
+{
+  execute();
+}
+
+std::string
+ObjectAddCommandImpl::serialize()
+{
+  return &quot;&quot;;
+}
+
+Command
+ObjectAddCommand::to_command()
+{
+  return Command(impl);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_add_command.cxx
===================================================================
--- trunk/flexlay/lib/object_add_command.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_add_command.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,93 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &quot;object_layer.hxx&quot;
-#include &quot;objmap_object.hxx&quot;
-#include &quot;object_add_command.hxx&quot;
-
-class ObjectAddCommandImpl : public CommandImpl
-{
-public:
-  ObjectLayer objmap;
-  std::vector&lt;ObjMapObject&gt; objs;
-
-  ObjectAddCommandImpl() {}
-  virtual ~ObjectAddCommandImpl() {}
-
-  void execute();
-  void undo();
-  void redo();
-
-  std::string serialize();
-};
-
-ObjectAddCommand::ObjectAddCommand(const ObjectLayer&amp; objmap_)
-  : impl(new ObjectAddCommandImpl())
-{
-  impl-&gt;objmap = objmap_;
-}
-
-ObjectAddCommand::~ObjectAddCommand()
-{
-}
-
-/*int
-ObjectAddCommand::get_handle() const
-{ 
-  return impl-&gt;obj-&gt;get_handle(); 
-}*/
-
-void
-ObjectAddCommand::add_object(const ObjMapObject&amp; obj)
-{
-  impl-&gt;objs.push_back(obj);
-}
-
-void
-ObjectAddCommandImpl::execute()
-{
-  for(std::vector&lt;ObjMapObject&gt;::iterator i = objs.begin(); i != objs.end(); ++i)
-    objmap.add_object(*i);
-}
-
-void
-ObjectAddCommandImpl::undo()
-{
-  for(std::vector&lt;ObjMapObject&gt;::iterator i = objs.begin(); i != objs.end(); ++i)
-    objmap.delete_object(*i);
-}
-
-void
-ObjectAddCommandImpl::redo()
-{
-  execute();
-}
-
-std::string
-ObjectAddCommandImpl::serialize()
-{
-  return &quot;&quot;;
-}
-
-Command
-ObjectAddCommand::to_command()
-{
-  return Command(impl);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/object_add_command.hpp (from rev 712, trunk/flexlay/lib/object_add_command.hxx)
===================================================================
--- trunk/flexlay/lib/object_add_command.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_add_command.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,50 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_OBJECT_ADD_COMMAND_HXX
+#define HEADER_OBJECT_ADD_COMMAND_HXX
+
+#include &quot;objmap_object.hpp&quot;
+#include &quot;command.hpp&quot;
+
+class ObjectLayer;
+class ObjectAddCommandImpl;
+
+/** ObjectAddCommand adds on object to an ObjectLayer, the user needs
+    to supply an Object together with the \a ObjectLayer to which it
+    should be added. FIXME: position should be part of the command,
+    not the object */
+class ObjectAddCommand
+{
+public:
+  ObjectAddCommand(const ObjectLayer&amp; layer);
+  virtual ~ObjectAddCommand();
+
+  void add_object(const ObjMapObject&amp; obj);
+
+  //int get_handle() const;
+
+  Command to_command();
+
+private:
+  SharedPtr&lt;ObjectAddCommandImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_add_command.hxx
===================================================================
--- trunk/flexlay/lib/object_add_command.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_add_command.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,50 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_OBJECT_ADD_COMMAND_HXX
-#define HEADER_OBJECT_ADD_COMMAND_HXX
-
-#include &quot;objmap_object.hxx&quot;
-#include &quot;command.hxx&quot;
-
-class ObjectLayer;
-class ObjectAddCommandImpl;
-
-/** ObjectAddCommand adds on object to an ObjectLayer, the user needs
-    to supply an Object together with the \a ObjectLayer to which it
-    should be added. FIXME: position should be part of the command,
-    not the object */
-class ObjectAddCommand
-{
-public:
-  ObjectAddCommand(const ObjectLayer&amp; layer);
-  virtual ~ObjectAddCommand();
-
-  void add_object(const ObjMapObject&amp; obj);
-
-  //int get_handle() const;
-
-  Command to_command();
-
-private:
-  SharedPtr&lt;ObjectAddCommandImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/object_brush.cpp (from rev 712, trunk/flexlay/lib/object_brush.cxx)
===================================================================
--- trunk/flexlay/lib/object_brush.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_brush.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,64 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &quot;objmap_sprite_object.hpp&quot;
+#include &quot;object_add_command.hpp&quot;
+#include &quot;objmap_sprite_object.hpp&quot;
+#include &quot;object_brush.hpp&quot;
+#include &quot;editor_map.hpp&quot;
+
+class ObjectBrushImpl
+{
+public:
+  CL_Sprite sprite;
+  MetaData  data;
+};
+
+ObjectBrush::ObjectBrush()
+{
+  
+}
+
+ObjectBrush::ObjectBrush(const CL_Sprite&amp; sprite_,
+                         const MetaData&amp; data_)
+  : impl(new ObjectBrushImpl())
+{
+  impl-&gt;sprite = sprite_;
+  impl-&gt;data   = data_;
+}
+
+CL_Sprite
+ObjectBrush::get_sprite()
+{
+  return impl-&gt;sprite;
+}
+
+MetaData
+ObjectBrush::get_data()
+{
+  return impl-&gt;data;
+}
+
+ObjMapSpriteObject
+ObjectBrush::to_sprite_object(const CL_Pointf&amp; pos)
+{
+  ObjMapSpriteObject obj(impl-&gt;sprite, pos, impl-&gt;data);  
+  return obj;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_brush.cxx
===================================================================
--- trunk/flexlay/lib/object_brush.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_brush.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,64 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &quot;objmap_sprite_object.hxx&quot;
-#include &quot;object_add_command.hxx&quot;
-#include &quot;objmap_sprite_object.hxx&quot;
-#include &quot;object_brush.hxx&quot;
-#include &quot;editor_map.hxx&quot;
-
-class ObjectBrushImpl
-{
-public:
-  CL_Sprite sprite;
-  MetaData  data;
-};
-
-ObjectBrush::ObjectBrush()
-{
-  
-}
-
-ObjectBrush::ObjectBrush(const CL_Sprite&amp; sprite_,
-                         const MetaData&amp; data_)
-  : impl(new ObjectBrushImpl())
-{
-  impl-&gt;sprite = sprite_;
-  impl-&gt;data   = data_;
-}
-
-CL_Sprite
-ObjectBrush::get_sprite()
-{
-  return impl-&gt;sprite;
-}
-
-MetaData
-ObjectBrush::get_data()
-{
-  return impl-&gt;data;
-}
-
-ObjMapSpriteObject
-ObjectBrush::to_sprite_object(const CL_Pointf&amp; pos)
-{
-  ObjMapSpriteObject obj(impl-&gt;sprite, pos, impl-&gt;data);  
-  return obj;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/object_brush.hpp (from rev 712, trunk/flexlay/lib/object_brush.hxx)
===================================================================
--- trunk/flexlay/lib/object_brush.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_brush.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,48 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_OBJECT_BRUSH_HXX
+#define HEADER_OBJECT_BRUSH_HXX
+
+#include &lt;ClanLib/Display/sprite.h&gt;
+#include &lt;ClanLib/Core/Math/point.h&gt;
+#include &quot;object_layer.hpp&quot;
+#include &quot;objmap_object.hpp&quot;
+#include &quot;objmap_sprite_object.hpp&quot;
+#include &quot;meta_data.hpp&quot;
+
+class ObjectBrushImpl;
+
+class ObjectBrush
+{
+public:
+  ObjectBrush();
+  ObjectBrush(const CL_Sprite&amp; sprite_,
+              const MetaData&amp; data_);
+
+  CL_Sprite get_sprite();
+  MetaData get_data();
+
+  ObjMapSpriteObject to_sprite_object(const CL_Pointf&amp; pos);
+private:
+  SharedPtr&lt;ObjectBrushImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_brush.hxx
===================================================================
--- trunk/flexlay/lib/object_brush.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_brush.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,48 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_OBJECT_BRUSH_HXX
-#define HEADER_OBJECT_BRUSH_HXX
-
-#include &lt;ClanLib/Display/sprite.h&gt;
-#include &lt;ClanLib/Core/Math/point.h&gt;
-#include &quot;object_layer.hxx&quot;
-#include &quot;objmap_object.hxx&quot;
-#include &quot;objmap_sprite_object.hxx&quot;
-#include &quot;meta_data.hxx&quot;
-
-class ObjectBrushImpl;
-
-class ObjectBrush
-{
-public:
-  ObjectBrush();
-  ObjectBrush(const CL_Sprite&amp; sprite_,
-              const MetaData&amp; data_);
-
-  CL_Sprite get_sprite();
-  MetaData get_data();
-
-  ObjMapSpriteObject to_sprite_object(const CL_Pointf&amp; pos);
-private:
-  SharedPtr&lt;ObjectBrushImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/object_delete_command.cpp (from rev 712, trunk/flexlay/lib/object_delete_command.cxx)
===================================================================
--- trunk/flexlay/lib/object_delete_command.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_delete_command.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,83 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &quot;object_layer.hpp&quot;
+#include &quot;objmap_object.hpp&quot;
+#include &quot;command_impl.hpp&quot;
+#include &quot;object_delete_command.hpp&quot;
+
+class ObjectDeleteCommandImpl : public CommandImpl
+{
+public:
+  typedef std::vector&lt;ObjMapObject&gt; Objects;
+
+  ObjectLayer object_layer;
+  Objects objects;
+  
+  ObjectDeleteCommandImpl() {}
+  virtual ~ObjectDeleteCommandImpl() {}
+
+  void execute();
+  void redo();
+  void undo();
+  std::string serialize() { return &quot;&quot;; }
+};
+
+ObjectDeleteCommand::ObjectDeleteCommand(const ObjectLayer&amp; o)
+  : impl(new ObjectDeleteCommandImpl())
+{
+  impl-&gt;object_layer = o;
+}
+
+void
+ObjectDeleteCommand::add_object(const ObjMapObject&amp; obj)
+{
+  impl-&gt;objects.push_back(obj);
+}
+
+void
+ObjectDeleteCommandImpl::execute()
+{
+  for(Objects::iterator i = objects.begin(); i != objects.end(); ++i)
+    {
+      object_layer.delete_object(*i);
+    }
+}
+
+void
+ObjectDeleteCommandImpl::redo()
+{
+  execute();
+}
+
+void
+ObjectDeleteCommandImpl::undo()
+{
+  for(Objects::iterator i = objects.begin(); i != objects.end(); ++i)
+    {
+      object_layer.add_object(*i);
+    }
+}
+
+Command
+ObjectDeleteCommand::to_command()
+{
+  return Command(impl);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_delete_command.cxx
===================================================================
--- trunk/flexlay/lib/object_delete_command.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_delete_command.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,83 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &quot;object_layer.hxx&quot;
-#include &quot;objmap_object.hxx&quot;
-#include &quot;command_impl.hxx&quot;
-#include &quot;object_delete_command.hxx&quot;
-
-class ObjectDeleteCommandImpl : public CommandImpl
-{
-public:
-  typedef std::vector&lt;ObjMapObject&gt; Objects;
-
-  ObjectLayer object_layer;
-  Objects objects;
-  
-  ObjectDeleteCommandImpl() {}
-  virtual ~ObjectDeleteCommandImpl() {}
-
-  void execute();
-  void redo();
-  void undo();
-  std::string serialize() { return &quot;&quot;; }
-};
-
-ObjectDeleteCommand::ObjectDeleteCommand(const ObjectLayer&amp; o)
-  : impl(new ObjectDeleteCommandImpl())
-{
-  impl-&gt;object_layer = o;
-}
-
-void
-ObjectDeleteCommand::add_object(const ObjMapObject&amp; obj)
-{
-  impl-&gt;objects.push_back(obj);
-}
-
-void
-ObjectDeleteCommandImpl::execute()
-{
-  for(Objects::iterator i = objects.begin(); i != objects.end(); ++i)
-    {
-      object_layer.delete_object(*i);
-    }
-}
-
-void
-ObjectDeleteCommandImpl::redo()
-{
-  execute();
-}
-
-void
-ObjectDeleteCommandImpl::undo()
-{
-  for(Objects::iterator i = objects.begin(); i != objects.end(); ++i)
-    {
-      object_layer.add_object(*i);
-    }
-}
-
-Command
-ObjectDeleteCommand::to_command()
-{
-  return Command(impl);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/object_delete_command.hpp (from rev 712, trunk/flexlay/lib/object_delete_command.hxx)
===================================================================
--- trunk/flexlay/lib/object_delete_command.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_delete_command.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,45 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_OBJECT_DELETE_COMMAND_HXX
+#define HEADER_OBJECT_DELETE_COMMAND_HXX
+
+#include &lt;vector&gt;
+#include &quot;objmap_object.hpp&quot;
+#include &quot;command.hpp&quot;
+
+class ObjectDeleteCommandImpl;
+class ObjectLayer;
+
+/** Delete all objects added with add_object() on the ObjectLayer
+    given at construction time */
+class ObjectDeleteCommand
+{
+public:
+  ObjectDeleteCommand(const ObjectLayer&amp; o);
+
+  void add_object(const ObjMapObject&amp; obj);
+
+  Command to_command();
+private:
+  SharedPtr&lt;ObjectDeleteCommandImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_delete_command.hxx
===================================================================
--- trunk/flexlay/lib/object_delete_command.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_delete_command.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,45 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_OBJECT_DELETE_COMMAND_HXX
-#define HEADER_OBJECT_DELETE_COMMAND_HXX
-
-#include &lt;vector&gt;
-#include &quot;objmap_object.hxx&quot;
-#include &quot;command.hxx&quot;
-
-class ObjectDeleteCommandImpl;
-class ObjectLayer;
-
-/** Delete all objects added with add_object() on the ObjectLayer
-    given at construction time */
-class ObjectDeleteCommand
-{
-public:
-  ObjectDeleteCommand(const ObjectLayer&amp; o);
-
-  void add_object(const ObjMapObject&amp; obj);
-
-  Command to_command();
-private:
-  SharedPtr&lt;ObjectDeleteCommandImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/object_layer.cpp (from rev 712, trunk/flexlay/lib/object_layer.cxx)
===================================================================
--- trunk/flexlay/lib/object_layer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_layer.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,199 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &lt;ClanLib/Core/Math/origin.h&gt;
+#include &lt;ClanLib/Core/System/error.h&gt;
+#include &quot;objmap_object.hpp&quot;
+#include &quot;objmap_sprite_object.hpp&quot;
+#include &quot;objmap_control_point.hpp&quot;
+#include &quot;object_layer.hpp&quot;
+#include &quot;editor_map_component.hpp&quot;
+#include &quot;layer_impl.hpp&quot;
+
+ObjectLayer ObjectLayer::current_;
+
+class ObjectLayerImpl : public LayerImpl
+{
+public:
+  ObjectLayer::Objects objects;
+  ObjectLayer::ControlPoints control_points;
+  CL_SlotContainer slots;
+
+  ObjectLayerImpl() {}
+  virtual ~ObjectLayerImpl() {}
+  
+  void draw(EditorMapComponent* parent, CL_GraphicContext* gc);
+  bool has_bounding_rect() const { return false; }
+};
+
+ObjectLayer::ObjectLayer()
+  : impl(new ObjectLayerImpl())
+{
+}
+
+ObjectLayer::~ObjectLayer()
+{
+}
+
+void
+ObjectLayerImpl::draw(EditorMapComponent* parent, CL_GraphicContext* gc)
+{
+  for(ObjectLayer::Objects::iterator i = objects.begin(); i != objects.end(); ++i)
+    {
+      // FIXME: Add clipping here
+      if (parent-&gt;get_clip_rect().is_overlapped((*i).get_bound_rect()))
+        (*i).draw(gc);
+    }
+
+  for(ObjectLayer::ControlPoints::iterator i = control_points.begin(); i != control_points.end(); ++i)
+    {
+      (*i).draw(gc);
+    }
+}
+
+ObjMapControlPoint
+ObjectLayer::find_control_point(const CL_Pointf&amp; click_pos)
+{
+  for(ControlPoints::reverse_iterator i = impl-&gt;control_points.rbegin(); 
+      i != impl-&gt;control_points.rend(); 
+      ++i)
+    {
+      CL_Rect rect = (*i).get_bound_rect();
+     
+      if (rect.is_inside(CL_Point(click_pos)))
+        return *i;
+    }
+  return ObjMapControlPoint(); 
+}
+
+ObjMapObject
+ObjectLayer::find_object(const CL_Pointf&amp; click_pos)
+{
+  for(Objects::reverse_iterator i = impl-&gt;objects.rbegin(); i != impl-&gt;objects.rend(); ++i)
+    {
+      CL_Rectf rect = (*i).get_bound_rect();
+     
+      if (rect.is_inside(CL_Point(click_pos)))
+        return *i;
+    }
+  return ObjMapObject();
+}
+
+void
+ObjectLayer::delete_object(const ObjMapObject&amp; obj)
+{
+  for(Objects::iterator i = impl-&gt;objects.begin(); i != impl-&gt;objects.end(); ++i)
+    {
+      if (obj == (*i))
+        {
+          impl-&gt;objects.erase(i);
+          break;
+        }
+    }
+}
+
+ObjectLayer::Objects
+ObjectLayer::get_selection(const CL_Rectf&amp; rect)
+{
+  Objects selection;
+
+  for(Objects::iterator i = impl-&gt;objects.begin(); i != impl-&gt;objects.end(); ++i)
+    {
+      // FIXME:
+      if (rect.is_inside((*i).get_pos()))
+        {
+          selection.push_back(*i);
+        }
+    }
+  
+  return selection;
+}
+
+ObjectLayer::Objects
+ObjectLayer::get_objects()
+{
+  return impl-&gt;objects;
+}
+
+void
+ObjectLayer::add_object(const ObjMapObject&amp; obj)
+{
+  impl-&gt;objects.push_back(obj);
+}
+
+void
+ObjectLayer::add_control_point(const ObjMapControlPoint&amp; obj)
+{
+  impl-&gt;control_points.push_back(obj);
+}
+
+void
+ObjectLayer::delete_control_points()
+{
+  impl-&gt;control_points.clear();
+}
+
+Layer
+ObjectLayer::to_layer()
+{
+  return Layer(impl);
+}
+
+int
+ObjectLayer::get_object_index(const ObjMapObject&amp; obj)
+{
+  Objects::size_type i;
+  for(i = 0; i &lt; impl-&gt;objects.size(); ++i)
+    {
+      if (impl-&gt;objects[i] == obj)
+        {
+          return i;
+        }
+    }
+  return -1;
+}
+
+void
+ObjectLayer::move_to(const ObjMapObject&amp; obj, int height)
+{
+  // FIXME: Implement me
+}
+
+void
+ObjectLayer::raise(const ObjMapObject&amp; obj)
+{
+  int i = get_object_index(obj);
+  if (i != -1 &amp;&amp; impl-&gt;objects.size() &gt; 1 &amp;&amp; i &lt; int(impl-&gt;objects.size())-1)
+    {
+      std::swap(impl-&gt;objects[i], impl-&gt;objects[i+1]);
+    }
+}
+
+void
+ObjectLayer::lower(const ObjMapObject&amp; obj)
+{
+  int i = get_object_index(obj);
+  if (i != -1 &amp;&amp; i &gt; 0)
+    {
+      std::swap(impl-&gt;objects[i], impl-&gt;objects[i-1]);
+    }
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_layer.cxx
===================================================================
--- trunk/flexlay/lib/object_layer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_layer.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,199 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-#include &lt;ClanLib/Core/Math/origin.h&gt;
-#include &lt;ClanLib/Core/System/error.h&gt;
-#include &quot;objmap_object.hxx&quot;
-#include &quot;objmap_sprite_object.hxx&quot;
-#include &quot;objmap_control_point.hxx&quot;
-#include &quot;object_layer.hxx&quot;
-#include &quot;editor_map_component.hxx&quot;
-#include &quot;layer_impl.hxx&quot;
-
-ObjectLayer ObjectLayer::current_;
-
-class ObjectLayerImpl : public LayerImpl
-{
-public:
-  ObjectLayer::Objects objects;
-  ObjectLayer::ControlPoints control_points;
-  CL_SlotContainer slots;
-
-  ObjectLayerImpl() {}
-  virtual ~ObjectLayerImpl() {}
-  
-  void draw(EditorMapComponent* parent, CL_GraphicContext* gc);
-  bool has_bounding_rect() const { return false; }
-};
-
-ObjectLayer::ObjectLayer()
-  : impl(new ObjectLayerImpl())
-{
-}
-
-ObjectLayer::~ObjectLayer()
-{
-}
-
-void
-ObjectLayerImpl::draw(EditorMapComponent* parent, CL_GraphicContext* gc)
-{
-  for(ObjectLayer::Objects::iterator i = objects.begin(); i != objects.end(); ++i)
-    {
-      // FIXME: Add clipping here
-      if (parent-&gt;get_clip_rect().is_overlapped((*i).get_bound_rect()))
-        (*i).draw(gc);
-    }
-
-  for(ObjectLayer::ControlPoints::iterator i = control_points.begin(); i != control_points.end(); ++i)
-    {
-      (*i).draw(gc);
-    }
-}
-
-ObjMapControlPoint
-ObjectLayer::find_control_point(const CL_Pointf&amp; click_pos)
-{
-  for(ControlPoints::reverse_iterator i = impl-&gt;control_points.rbegin(); 
-      i != impl-&gt;control_points.rend(); 
-      ++i)
-    {
-      CL_Rect rect = (*i).get_bound_rect();
-     
-      if (rect.is_inside(CL_Point(click_pos)))
-        return *i;
-    }
-  return ObjMapControlPoint(); 
-}
-
-ObjMapObject
-ObjectLayer::find_object(const CL_Pointf&amp; click_pos)
-{
-  for(Objects::reverse_iterator i = impl-&gt;objects.rbegin(); i != impl-&gt;objects.rend(); ++i)
-    {
-      CL_Rectf rect = (*i).get_bound_rect();
-     
-      if (rect.is_inside(CL_Point(click_pos)))
-        return *i;
-    }
-  return ObjMapObject();
-}
-
-void
-ObjectLayer::delete_object(const ObjMapObject&amp; obj)
-{
-  for(Objects::iterator i = impl-&gt;objects.begin(); i != impl-&gt;objects.end(); ++i)
-    {
-      if (obj == (*i))
-        {
-          impl-&gt;objects.erase(i);
-          break;
-        }
-    }
-}
-
-ObjectLayer::Objects
-ObjectLayer::get_selection(const CL_Rectf&amp; rect)
-{
-  Objects selection;
-
-  for(Objects::iterator i = impl-&gt;objects.begin(); i != impl-&gt;objects.end(); ++i)
-    {
-      // FIXME:
-      if (rect.is_inside((*i).get_pos()))
-        {
-          selection.push_back(*i);
-        }
-    }
-  
-  return selection;
-}
-
-ObjectLayer::Objects
-ObjectLayer::get_objects()
-{
-  return impl-&gt;objects;
-}
-
-void
-ObjectLayer::add_object(const ObjMapObject&amp; obj)
-{
-  impl-&gt;objects.push_back(obj);
-}
-
-void
-ObjectLayer::add_control_point(const ObjMapControlPoint&amp; obj)
-{
-  impl-&gt;control_points.push_back(obj);
-}
-
-void
-ObjectLayer::delete_control_points()
-{
-  impl-&gt;control_points.clear();
-}
-
-Layer
-ObjectLayer::to_layer()
-{
-  return Layer(impl);
-}
-
-int
-ObjectLayer::get_object_index(const ObjMapObject&amp; obj)
-{
-  Objects::size_type i;
-  for(i = 0; i &lt; impl-&gt;objects.size(); ++i)
-    {
-      if (impl-&gt;objects[i] == obj)
-        {
-          return i;
-        }
-    }
-  return -1;
-}
-
-void
-ObjectLayer::move_to(const ObjMapObject&amp; obj, int height)
-{
-  // FIXME: Implement me
-}
-
-void
-ObjectLayer::raise(const ObjMapObject&amp; obj)
-{
-  int i = get_object_index(obj);
-  if (i != -1 &amp;&amp; impl-&gt;objects.size() &gt; 1 &amp;&amp; i &lt; int(impl-&gt;objects.size())-1)
-    {
-      std::swap(impl-&gt;objects[i], impl-&gt;objects[i+1]);
-    }
-}
-
-void
-ObjectLayer::lower(const ObjMapObject&amp; obj)
-{
-  int i = get_object_index(obj);
-  if (i != -1 &amp;&amp; i &gt; 0)
-    {
-      std::swap(impl-&gt;objects[i], impl-&gt;objects[i-1]);
-    }
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/object_layer.hpp (from rev 712, trunk/flexlay/lib/object_layer.hxx)
===================================================================
--- trunk/flexlay/lib/object_layer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_layer.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,85 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_OBJECT_LAYER_HXX
+#define HEADER_OBJECT_LAYER_HXX
+
+#include &lt;vector&gt;
+#include &lt;ClanLib/Display/sprite.h&gt;
+#include &lt;ClanLib/GUI/component.h&gt;
+#include &lt;ClanLib/Core/Math/point.h&gt;
+#include &quot;meta_data.hpp&quot;
+#include &quot;layer.hpp&quot;
+#include &quot;objmap_object.hpp&quot;
+#include &quot;objmap_control_point.hpp&quot;
+#include &quot;shared_ptr.hpp&quot;
+
+class ObjectLayerImpl;
+
+/** The ObjectLayer provides a simple Layer for holding positioned
+    objects. Objects can consist of a CL_Sprite and some properties
+    accessible from scripting languages or any other thing that is a
+    ObjMapObject. */
+class ObjectLayer
+{
+public:
+  typedef std::vector&lt;ObjMapObject&gt; Objects;
+  typedef std::vector&lt;ObjMapControlPoint&gt; ControlPoints;
+
+  static ObjectLayer current_;
+
+  static ObjectLayer current() { return current_; }
+  static void set_current(ObjectLayer c) { current_ = c; }
+
+  ObjectLayer();
+  ~ObjectLayer();
+
+  void add_object(const ObjMapObject&amp; obj);
+  void delete_object(const ObjMapObject&amp; obj);
+
+  /** Moved the given object one position up in the object stack */
+  void raise(const ObjMapObject&amp; obj);
+
+  /** Moved the given object one position down in the object stack */
+  void lower(const ObjMapObject&amp; obj);
+
+  /** Moves the object to the given height in the object stack (0 is
+      lowest position, size()-1 is highest */
+  void move_to(const ObjMapObject&amp; obj, int height);
+
+  /** Returns the index at which the given object is in the Objects
+      array or -1 if the object couldn't be found */
+  int get_object_index(const ObjMapObject&amp; obj);
+
+  void add_control_point(const ObjMapControlPoint&amp; obj);
+  void delete_control_points();
+
+  ObjMapObject find_object(const CL_Pointf&amp; pos);
+  ObjMapControlPoint find_control_point(const CL_Pointf&amp; pos);
+  std::vector&lt;ObjMapObject&gt; get_selection(const CL_Rectf&amp; rect);
+  std::vector&lt;ObjMapObject&gt; get_objects();
+
+  Layer to_layer();
+
+private:
+  SharedPtr&lt;ObjectLayerImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_layer.hxx
===================================================================
--- trunk/flexlay/lib/object_layer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_layer.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,85 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_OBJECT_LAYER_HXX
-#define HEADER_OBJECT_LAYER_HXX
-
-#include &lt;vector&gt;
-#include &lt;ClanLib/Display/sprite.h&gt;
-#include &lt;ClanLib/GUI/component.h&gt;
-#include &lt;ClanLib/Core/Math/point.h&gt;
-#include &quot;meta_data.hxx&quot;
-#include &quot;layer.hxx&quot;
-#include &quot;objmap_object.hxx&quot;
-#include &quot;objmap_control_point.hxx&quot;
-#include &quot;shared_ptr.hxx&quot;
-
-class ObjectLayerImpl;
-
-/** The ObjectLayer provides a simple Layer for holding positioned
-    objects. Objects can consist of a CL_Sprite and some properties
-    accessible from scripting languages or any other thing that is a
-    ObjMapObject. */
-class ObjectLayer
-{
-public:
-  typedef std::vector&lt;ObjMapObject&gt; Objects;
-  typedef std::vector&lt;ObjMapControlPoint&gt; ControlPoints;
-
-  static ObjectLayer current_;
-
-  static ObjectLayer current() { return current_; }
-  static void set_current(ObjectLayer c) { current_ = c; }
-
-  ObjectLayer();
-  ~ObjectLayer();
-
-  void add_object(const ObjMapObject&amp; obj);
-  void delete_object(const ObjMapObject&amp; obj);
-
-  /** Moved the given object one position up in the object stack */
-  void raise(const ObjMapObject&amp; obj);
-
-  /** Moved the given object one position down in the object stack */
-  void lower(const ObjMapObject&amp; obj);
-
-  /** Moves the object to the given height in the object stack (0 is
-      lowest position, size()-1 is highest */
-  void move_to(const ObjMapObject&amp; obj, int height);
-
-  /** Returns the index at which the given object is in the Objects
-      array or -1 if the object couldn't be found */
-  int get_object_index(const ObjMapObject&amp; obj);
-
-  void add_control_point(const ObjMapControlPoint&amp; obj);
-  void delete_control_points();
-
-  ObjMapObject find_object(const CL_Pointf&amp; pos);
-  ObjMapControlPoint find_control_point(const CL_Pointf&amp; pos);
-  std::vector&lt;ObjMapObject&gt; get_selection(const CL_Rectf&amp; rect);
-  std::vector&lt;ObjMapObject&gt; get_objects();
-
-  Layer to_layer();
-
-private:
-  SharedPtr&lt;ObjectLayerImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/object_move_command.cpp (from rev 712, trunk/flexlay/lib/object_move_command.cxx)
===================================================================
--- trunk/flexlay/lib/object_move_command.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_move_command.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,118 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &quot;object_layer.hpp&quot;
+#include &quot;objmap_object.hpp&quot;
+#include &quot;object_move_command.hpp&quot;
+
+class ObjectMoveCommandImpl : public CommandImpl
+{
+public:
+  ObjectMoveCommandImpl() {}
+  virtual ~ObjectMoveCommandImpl() {}
+
+  ObjectLayer objmap;
+  
+  struct Obj {
+    CL_Pointf old_pos;
+    CL_Pointf new_pos;
+    ObjMapObject obj;
+  };
+  
+  typedef std::vector&lt;Obj&gt; Objects;
+  Objects objects;
+
+  void execute();
+  void redo();
+  void undo();
+
+  std::string serialize();
+};
+
+ObjectMoveCommand::ObjectMoveCommand(const ObjectLayer&amp; o)
+  : impl(new ObjectMoveCommandImpl())
+{
+  impl-&gt;objmap = o;
+}
+
+ObjectMoveCommand::~ObjectMoveCommand()
+{
+}
+  
+void
+ObjectMoveCommandImpl::execute()
+{
+}
+
+void
+ObjectMoveCommand::add_obj(const ObjMapObject&amp; obj)
+{
+  ObjectMoveCommandImpl::Obj o;
+  o.obj     = obj;
+  o.old_pos = obj.get_pos();
+  impl-&gt;objects.push_back(o);
+}
+
+void
+ObjectMoveCommand::move_by(const CL_Pointf&amp; delta)
+{
+  for(ObjectMoveCommandImpl::Objects::iterator i = impl-&gt;objects.begin(); 
+      i != impl-&gt;objects.end();
+      ++i)
+    {
+      i-&gt;new_pos = i-&gt;old_pos + delta;
+      i-&gt;obj.set_pos(i-&gt;new_pos);
+      i-&gt;obj.sig_move()(i-&gt;obj);
+    }
+}
+
+void
+ObjectMoveCommandImpl::redo()
+{
+  for(ObjectMoveCommandImpl::Objects::iterator i = objects.begin(); 
+      i != objects.end();
+      ++i)
+    {
+      i-&gt;obj.set_pos(i-&gt;new_pos);
+    }  
+}
+
+void
+ObjectMoveCommandImpl::undo()
+{
+  for(ObjectMoveCommandImpl::Objects::iterator i = objects.begin(); 
+      i != objects.end();
+      ++i)
+    {
+      i-&gt;obj.set_pos(i-&gt;old_pos);
+    }
+}
+
+std::string
+ObjectMoveCommandImpl::serialize()
+{
+  return &quot;&quot;;
+}
+
+Command
+ObjectMoveCommand::to_command()
+{
+  return Command(impl);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_move_command.cxx
===================================================================
--- trunk/flexlay/lib/object_move_command.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_move_command.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,118 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &quot;object_layer.hxx&quot;
-#include &quot;objmap_object.hxx&quot;
-#include &quot;object_move_command.hxx&quot;
-
-class ObjectMoveCommandImpl : public CommandImpl
-{
-public:
-  ObjectMoveCommandImpl() {}
-  virtual ~ObjectMoveCommandImpl() {}
-
-  ObjectLayer objmap;
-  
-  struct Obj {
-    CL_Pointf old_pos;
-    CL_Pointf new_pos;
-    ObjMapObject obj;
-  };
-  
-  typedef std::vector&lt;Obj&gt; Objects;
-  Objects objects;
-
-  void execute();
-  void redo();
-  void undo();
-
-  std::string serialize();
-};
-
-ObjectMoveCommand::ObjectMoveCommand(const ObjectLayer&amp; o)
-  : impl(new ObjectMoveCommandImpl())
-{
-  impl-&gt;objmap = o;
-}
-
-ObjectMoveCommand::~ObjectMoveCommand()
-{
-}
-  
-void
-ObjectMoveCommandImpl::execute()
-{
-}
-
-void
-ObjectMoveCommand::add_obj(const ObjMapObject&amp; obj)
-{
-  ObjectMoveCommandImpl::Obj o;
-  o.obj     = obj;
-  o.old_pos = obj.get_pos();
-  impl-&gt;objects.push_back(o);
-}
-
-void
-ObjectMoveCommand::move_by(const CL_Pointf&amp; delta)
-{
-  for(ObjectMoveCommandImpl::Objects::iterator i = impl-&gt;objects.begin(); 
-      i != impl-&gt;objects.end();
-      ++i)
-    {
-      i-&gt;new_pos = i-&gt;old_pos + delta;
-      i-&gt;obj.set_pos(i-&gt;new_pos);
-      i-&gt;obj.sig_move()(i-&gt;obj);
-    }
-}
-
-void
-ObjectMoveCommandImpl::redo()
-{
-  for(ObjectMoveCommandImpl::Objects::iterator i = objects.begin(); 
-      i != objects.end();
-      ++i)
-    {
-      i-&gt;obj.set_pos(i-&gt;new_pos);
-    }  
-}
-
-void
-ObjectMoveCommandImpl::undo()
-{
-  for(ObjectMoveCommandImpl::Objects::iterator i = objects.begin(); 
-      i != objects.end();
-      ++i)
-    {
-      i-&gt;obj.set_pos(i-&gt;old_pos);
-    }
-}
-
-std::string
-ObjectMoveCommandImpl::serialize()
-{
-  return &quot;&quot;;
-}
-
-Command
-ObjectMoveCommand::to_command()
-{
-  return Command(impl);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/object_move_command.hpp (from rev 712, trunk/flexlay/lib/object_move_command.hxx)
===================================================================
--- trunk/flexlay/lib/object_move_command.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_move_command.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,46 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_OBJECT_COMMAND_HXX
+#define HEADER_OBJECT_COMMAND_HXX
+
+#include &quot;command.hpp&quot;
+
+class ObjMapObject;
+class ObjectLayer;
+
+class ObjectMoveCommandImpl;
+
+/** */
+class ObjectMoveCommand
+{
+public:
+  ObjectMoveCommand(const ObjectLayer&amp; o);
+  virtual ~ObjectMoveCommand();
+
+  void add_obj(const ObjMapObject&amp; obj);
+  void move_by(const CL_Pointf&amp; delta);
+
+  Command to_command();
+private:
+  SharedPtr&lt;ObjectMoveCommandImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_move_command.hxx
===================================================================
--- trunk/flexlay/lib/object_move_command.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_move_command.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,46 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_OBJECT_COMMAND_HXX
-#define HEADER_OBJECT_COMMAND_HXX
-
-#include &quot;command.hxx&quot;
-
-class ObjMapObject;
-class ObjectLayer;
-
-class ObjectMoveCommandImpl;
-
-/** */
-class ObjectMoveCommand
-{
-public:
-  ObjectMoveCommand(const ObjectLayer&amp; o);
-  virtual ~ObjectMoveCommand();
-
-  void add_obj(const ObjMapObject&amp; obj);
-  void move_by(const CL_Pointf&amp; delta);
-
-  Command to_command();
-private:
-  SharedPtr&lt;ObjectMoveCommandImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/object_selector.cpp (from rev 712, trunk/flexlay/lib/object_selector.cxx)
===================================================================
--- trunk/flexlay/lib/object_selector.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_selector.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,215 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &lt;ClanLib/Core/core_iostream.h&gt;
+#include &lt;ClanLib/display.h&gt;
+#include &quot;editor_map.hpp&quot;
+#include &quot;editor_map_component.hpp&quot;
+#include &quot;object_selector.hpp&quot;
+#include &quot;object_add_command.hpp&quot;
+
+ObjectSelector::ObjectSelector(const CL_Rect&amp; rect, 
+                               int obj_w, int obj_h,
+                               CL_Component* parent)
+  : CL_Component(rect, parent),
+    width(rect.get_width()/obj_w), height(rect.get_height()/obj_h),
+    obj_width(obj_w), obj_height(obj_h)
+{
+  index = 0;
+
+  slots.push_back(sig_paint().connect(this, &amp;ObjectSelector::draw));
+  slots.push_back(sig_mouse_move().connect(this, &amp;ObjectSelector::mouse_move));
+  slots.push_back(sig_mouse_down().connect(this, &amp;ObjectSelector::mouse_down));
+  slots.push_back(sig_mouse_up().connect(this, &amp;ObjectSelector::mouse_up));
+ 
+  mouse_over_tile = -1;
+  scrolling = false;
+  offset = 0;
+  scale = 1.0f;
+  drag_obj = -1;
+}
+
+ObjectSelector::~ObjectSelector()
+{
+}
+
+void
+ObjectSelector::mouse_up(const CL_InputEvent&amp; event)
+{
+  switch(event.id)
+    {
+    case CL_MOUSE_LEFT:
+      {
+        if (drag_obj != -1)
+          {
+            release_mouse();
+      
+            if (!has_mouse_over())
+              {
+                CL_Point screen(event.mouse_pos.x + get_screen_rect().left,
+                                event.mouse_pos.y + get_screen_rect().top);
+
+                CL_Point target(screen.x - EditorMapComponent::current()-&gt;get_screen_rect().left,
+                                screen.y - EditorMapComponent::current()-&gt;get_screen_rect().top);
+      
+                // FIXME: Move this to the scripting layer
+                //ObjectAddCommand command(ObjectLayer::current());
+
+                //ObjMapObject obj = brushes[drag_obj].to_sprite_object
+                //(EditorMapComponent::current()-&gt;screen2world(target)).to_object();
+
+                //command.add_object(obj);
+                //Workspace::current().get_map().execute(command.to_command());
+                
+                //std::cout &lt;&lt; &quot;C++: Calling on_drop&quot; &lt;&lt; std::endl;
+                on_drop(brushes[drag_obj], target);
+                //std::cout &lt;&lt; &quot;C++: Calling on_drop: done&quot; &lt;&lt; std::endl;
+              }
+            drag_obj = -1;
+          }
+      }
+      break;
+
+    case CL_MOUSE_MIDDLE:
+      scrolling = false;
+      release_mouse();
+      break;
+
+    default:
+      break;
+    }
+}
+
+void
+ObjectSelector::mouse_down(const CL_InputEvent&amp; event)
+{
+  switch(event.id)
+    {
+    case CL_MOUSE_LEFT:
+      {
+        if (mouse_over_tile != -1)
+          {
+            drag_obj = mouse_over_tile;
+            capture_mouse();
+          }
+      }
+      break;
+      
+    case CL_MOUSE_MIDDLE:
+      scrolling = true;
+      click_pos = event.mouse_pos;
+      old_offset = offset;
+      capture_mouse();
+      break;
+      
+    case CL_MOUSE_WHEEL_UP:
+      offset -= static_cast&lt;int&gt;(obj_height*scale); 
+      break;
+
+    case CL_MOUSE_WHEEL_DOWN:
+      offset += static_cast&lt;int&gt;(obj_height*scale); 
+      break;
+    }
+}
+
+void
+ObjectSelector::mouse_move(const CL_InputEvent&amp; event)
+{
+  if (scrolling)
+    {
+      offset = old_offset + (click_pos.y - event.mouse_pos.y);
+    }
+
+  mouse_pos = event.mouse_pos;
+
+  int x = (event.mouse_pos.x)/static_cast&lt;int&gt;(obj_width);
+  int y = (event.mouse_pos.y+offset)/static_cast&lt;int&gt;(obj_height);
+
+  mouse_over_tile = y * width + x;
+
+  if (mouse_over_tile &lt; 0 || mouse_over_tile &gt;= (int)brushes.size())
+    mouse_over_tile = -1;
+}
+
+void 
+ObjectSelector::draw()
+{
+  if (offset &lt; 0)
+    offset = 0;
+
+  CL_Display::push_cliprect(get_screen_rect());
+
+  // Handle scrolling in the Component
+  CL_Display::push_modelview();
+  CL_Display::add_translate(0, -offset);
+  CL_Display::add_translate(get_screen_x(), get_screen_y());
+    
+  for(int i = 0; i &lt; (int)brushes.size(); ++i)
+    {
+      int x = i%width;
+      int y = i/width;
+
+      CL_Rectf rect(CL_Pointf(x * obj_width, y * obj_height),
+                    CL_Sizef(obj_width, obj_height));
+
+      CL_Sprite sprite = brushes[i].get_sprite();
+      sprite.set_alignment(origin_center, 0, 0);
+      sprite.set_scale(std::min(1.0f, (float)obj_width/(float)sprite.get_width()),
+                       std::min(1.0f, (float)obj_height/(float)sprite.get_height()));
+        
+      sprite.draw(x * obj_width + obj_width/2, 
+                  y * obj_height + obj_height/2);
+        
+      //CL_Display::draw_rect(rect, CL_Color(0,0,0,128));
+        
+      if (mouse_over_tile == i &amp;&amp; has_mouse_over())
+        {
+          CL_Display::fill_rect(rect, CL_Color(0,0,255, 20));
+        }
+    }
+
+  CL_Display::pop_modelview();
+  CL_Display::pop_cliprect();
+ 
+  // Draw drag sprite
+  if (drag_obj != -1)
+    {
+      CL_Display::set_cliprect(CL_Rect(CL_Point(0, 0), 
+                                       CL_Size(CL_Display::get_width(),
+                                               CL_Display::get_height())));
+
+      CL_Sprite sprite = brushes[drag_obj].get_sprite();
+      sprite.set_alpha(0.5f);
+      sprite.draw(mouse_pos.x + get_screen_x(), mouse_pos.y + get_screen_y());
+    }
+}
+
+void
+ObjectSelector::add_brush(const ObjectBrush&amp; brush)
+{
+  brushes.push_back(brush);
+}
+
+CL_Signal_v2&lt;ObjectBrush, CL_Point&gt;&amp;
+ObjectSelector::sig_drop()
+{
+  return on_drop;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_selector.cxx
===================================================================
--- trunk/flexlay/lib/object_selector.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_selector.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,215 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &lt;ClanLib/Core/core_iostream.h&gt;
-#include &lt;ClanLib/display.h&gt;
-#include &quot;editor_map.hxx&quot;
-#include &quot;editor_map_component.hxx&quot;
-#include &quot;object_selector.hxx&quot;
-#include &quot;object_add_command.hxx&quot;
-
-ObjectSelector::ObjectSelector(const CL_Rect&amp; rect, 
-                               int obj_w, int obj_h,
-                               CL_Component* parent)
-  : CL_Component(rect, parent),
-    width(rect.get_width()/obj_w), height(rect.get_height()/obj_h),
-    obj_width(obj_w), obj_height(obj_h)
-{
-  index = 0;
-
-  slots.push_back(sig_paint().connect(this, &amp;ObjectSelector::draw));
-  slots.push_back(sig_mouse_move().connect(this, &amp;ObjectSelector::mouse_move));
-  slots.push_back(sig_mouse_down().connect(this, &amp;ObjectSelector::mouse_down));
-  slots.push_back(sig_mouse_up().connect(this, &amp;ObjectSelector::mouse_up));
- 
-  mouse_over_tile = -1;
-  scrolling = false;
-  offset = 0;
-  scale = 1.0f;
-  drag_obj = -1;
-}
-
-ObjectSelector::~ObjectSelector()
-{
-}
-
-void
-ObjectSelector::mouse_up(const CL_InputEvent&amp; event)
-{
-  switch(event.id)
-    {
-    case CL_MOUSE_LEFT:
-      {
-        if (drag_obj != -1)
-          {
-            release_mouse();
-      
-            if (!has_mouse_over())
-              {
-                CL_Point screen(event.mouse_pos.x + get_screen_rect().left,
-                                event.mouse_pos.y + get_screen_rect().top);
-
-                CL_Point target(screen.x - EditorMapComponent::current()-&gt;get_screen_rect().left,
-                                screen.y - EditorMapComponent::current()-&gt;get_screen_rect().top);
-      
-                // FIXME: Move this to the scripting layer
-                //ObjectAddCommand command(ObjectLayer::current());
-
-                //ObjMapObject obj = brushes[drag_obj].to_sprite_object
-                //(EditorMapComponent::current()-&gt;screen2world(target)).to_object();
-
-                //command.add_object(obj);
-                //Workspace::current().get_map().execute(command.to_command());
-                
-                //std::cout &lt;&lt; &quot;C++: Calling on_drop&quot; &lt;&lt; std::endl;
-                on_drop(brushes[drag_obj], target);
-                //std::cout &lt;&lt; &quot;C++: Calling on_drop: done&quot; &lt;&lt; std::endl;
-              }
-            drag_obj = -1;
-          }
-      }
-      break;
-
-    case CL_MOUSE_MIDDLE:
-      scrolling = false;
-      release_mouse();
-      break;
-
-    default:
-      break;
-    }
-}
-
-void
-ObjectSelector::mouse_down(const CL_InputEvent&amp; event)
-{
-  switch(event.id)
-    {
-    case CL_MOUSE_LEFT:
-      {
-        if (mouse_over_tile != -1)
-          {
-            drag_obj = mouse_over_tile;
-            capture_mouse();
-          }
-      }
-      break;
-      
-    case CL_MOUSE_MIDDLE:
-      scrolling = true;
-      click_pos = event.mouse_pos;
-      old_offset = offset;
-      capture_mouse();
-      break;
-      
-    case CL_MOUSE_WHEEL_UP:
-      offset -= static_cast&lt;int&gt;(obj_height*scale); 
-      break;
-
-    case CL_MOUSE_WHEEL_DOWN:
-      offset += static_cast&lt;int&gt;(obj_height*scale); 
-      break;
-    }
-}
-
-void
-ObjectSelector::mouse_move(const CL_InputEvent&amp; event)
-{
-  if (scrolling)
-    {
-      offset = old_offset + (click_pos.y - event.mouse_pos.y);
-    }
-
-  mouse_pos = event.mouse_pos;
-
-  int x = (event.mouse_pos.x)/static_cast&lt;int&gt;(obj_width);
-  int y = (event.mouse_pos.y+offset)/static_cast&lt;int&gt;(obj_height);
-
-  mouse_over_tile = y * width + x;
-
-  if (mouse_over_tile &lt; 0 || mouse_over_tile &gt;= (int)brushes.size())
-    mouse_over_tile = -1;
-}
-
-void 
-ObjectSelector::draw()
-{
-  if (offset &lt; 0)
-    offset = 0;
-
-  CL_Display::push_cliprect(get_screen_rect());
-
-  // Handle scrolling in the Component
-  CL_Display::push_modelview();
-  CL_Display::add_translate(0, -offset);
-  CL_Display::add_translate(get_screen_x(), get_screen_y());
-    
-  for(int i = 0; i &lt; (int)brushes.size(); ++i)
-    {
-      int x = i%width;
-      int y = i/width;
-
-      CL_Rectf rect(CL_Pointf(x * obj_width, y * obj_height),
-                    CL_Sizef(obj_width, obj_height));
-
-      CL_Sprite sprite = brushes[i].get_sprite();
-      sprite.set_alignment(origin_center, 0, 0);
-      sprite.set_scale(std::min(1.0f, (float)obj_width/(float)sprite.get_width()),
-                       std::min(1.0f, (float)obj_height/(float)sprite.get_height()));
-        
-      sprite.draw(x * obj_width + obj_width/2, 
-                  y * obj_height + obj_height/2);
-        
-      //CL_Display::draw_rect(rect, CL_Color(0,0,0,128));
-        
-      if (mouse_over_tile == i &amp;&amp; has_mouse_over())
-        {
-          CL_Display::fill_rect(rect, CL_Color(0,0,255, 20));
-        }
-    }
-
-  CL_Display::pop_modelview();
-  CL_Display::pop_cliprect();
- 
-  // Draw drag sprite
-  if (drag_obj != -1)
-    {
-      CL_Display::set_cliprect(CL_Rect(CL_Point(0, 0), 
-                                       CL_Size(CL_Display::get_width(),
-                                               CL_Display::get_height())));
-
-      CL_Sprite sprite = brushes[drag_obj].get_sprite();
-      sprite.set_alpha(0.5f);
-      sprite.draw(mouse_pos.x + get_screen_x(), mouse_pos.y + get_screen_y());
-    }
-}
-
-void
-ObjectSelector::add_brush(const ObjectBrush&amp; brush)
-{
-  brushes.push_back(brush);
-}
-
-CL_Signal_v2&lt;ObjectBrush, CL_Point&gt;&amp;
-ObjectSelector::sig_drop()
-{
-  return on_drop;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/object_selector.hpp (from rev 712, trunk/flexlay/lib/object_selector.hxx)
===================================================================
--- trunk/flexlay/lib/object_selector.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_selector.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,71 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_OBJECTSELECTOR_HXX
+#define HEADER_OBJECTSELECTOR_HXX
+
+#include &lt;ClanLib/GUI/component.h&gt;
+#include &lt;ClanLib/GUI/component.h&gt;
+#include &quot;object_brush.hpp&quot;
+
+/** */
+class ObjectSelector : public CL_Component
+{
+private:
+  std::vector&lt;CL_Slot&gt; slots;
+
+  int width;
+  int height;
+
+  int obj_width;
+  int obj_height;
+
+  int index;
+  
+  int offset;
+  int old_offset;
+  int mouse_over_tile;
+  bool scrolling;
+  CL_Point click_pos;
+  CL_Point mouse_pos;
+  float scale;
+
+  std::vector&lt;ObjectBrush&gt; brushes;
+  int drag_obj;
+
+  CL_Signal_v2&lt;ObjectBrush, CL_Point&gt; on_drop;
+
+protected:
+  virtual ~ObjectSelector();
+
+public:
+  ObjectSelector(const CL_Rect&amp; rect, int obj_w, int obj_h, CL_Component* parent);
+
+  void draw();
+  void add_brush(const ObjectBrush&amp; brush);
+
+  CL_Signal_v2&lt;ObjectBrush, CL_Point&gt;&amp; sig_drop();
+private:
+  void mouse_move(const CL_InputEvent&amp; event);
+  void mouse_down(const CL_InputEvent&amp; event);
+  void mouse_up  (const CL_InputEvent&amp; event); 
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_selector.hxx
===================================================================
--- trunk/flexlay/lib/object_selector.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_selector.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,71 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_OBJECTSELECTOR_HXX
-#define HEADER_OBJECTSELECTOR_HXX
-
-#include &lt;ClanLib/GUI/component.h&gt;
-#include &lt;ClanLib/GUI/component.h&gt;
-#include &quot;object_brush.hxx&quot;
-
-/** */
-class ObjectSelector : public CL_Component
-{
-private:
-  std::vector&lt;CL_Slot&gt; slots;
-
-  int width;
-  int height;
-
-  int obj_width;
-  int obj_height;
-
-  int index;
-  
-  int offset;
-  int old_offset;
-  int mouse_over_tile;
-  bool scrolling;
-  CL_Point click_pos;
-  CL_Point mouse_pos;
-  float scale;
-
-  std::vector&lt;ObjectBrush&gt; brushes;
-  int drag_obj;
-
-  CL_Signal_v2&lt;ObjectBrush, CL_Point&gt; on_drop;
-
-protected:
-  virtual ~ObjectSelector();
-
-public:
-  ObjectSelector(const CL_Rect&amp; rect, int obj_w, int obj_h, CL_Component* parent);
-
-  void draw();
-  void add_brush(const ObjectBrush&amp; brush);
-
-  CL_Signal_v2&lt;ObjectBrush, CL_Point&gt;&amp; sig_drop();
-private:
-  void mouse_move(const CL_InputEvent&amp; event);
-  void mouse_down(const CL_InputEvent&amp; event);
-  void mouse_up  (const CL_InputEvent&amp; event); 
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/object_transform_command.cpp (from rev 712, trunk/flexlay/lib/object_transform_command.cxx)
===================================================================
--- trunk/flexlay/lib/object_transform_command.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_transform_command.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,56 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &quot;object_transform_command.hpp&quot;
+
+class ObjectTransformCommandImpl : public CommandImpl
+{
+public:
+  typedef std::vector&lt;ObjMapObject*&gt; Objects;
+  Objects objects;
+
+  ObjectTransformCommandImpl() {}
+  virtual ~ObjectTransformCommandImpl() {}
+};
+
+ObjectTransformCommand::ObjectTransformCommand()
+{
+}
+
+ObjectTransformCommand::~ObjectTransformCommand()
+{
+}
+  
+void
+ObjectTransformCommand::excute()
+{
+}
+
+void
+ObjectTransformCommand::undo()
+{
+}
+
+void
+ObjectTransformCommand::redo()
+{
+
+    
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_transform_command.cxx
===================================================================
--- trunk/flexlay/lib/object_transform_command.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_transform_command.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,56 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &quot;object_transform_command.hxx&quot;
-
-class ObjectTransformCommandImpl : public CommandImpl
-{
-public:
-  typedef std::vector&lt;ObjMapObject*&gt; Objects;
-  Objects objects;
-
-  ObjectTransformCommandImpl() {}
-  virtual ~ObjectTransformCommandImpl() {}
-};
-
-ObjectTransformCommand::ObjectTransformCommand()
-{
-}
-
-ObjectTransformCommand::~ObjectTransformCommand()
-{
-}
-  
-void
-ObjectTransformCommand::excute()
-{
-}
-
-void
-ObjectTransformCommand::undo()
-{
-}
-
-void
-ObjectTransformCommand::redo()
-{
-
-    
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/object_transform_command.hpp (from rev 712, trunk/flexlay/lib/object_transform_command.hxx)
===================================================================
--- trunk/flexlay/lib/object_transform_command.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_transform_command.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,41 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_OBJECT_TRANSFORM_COMMAND_HXX
+#define HEADER_OBJECT_TRANSFORM_COMMAND_HXX
+
+#include &lt;vector&gt;
+#include &quot;command.hpp&quot;
+
+class ObjMapObject;
+
+/** */
+class ObjectTransformCommand
+{
+public:
+  ObjectTransformCommand();
+  virtual ~ObjectTransformCommand();
+  
+  void excute();
+  void undo();
+  void redo();
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_transform_command.hxx
===================================================================
--- trunk/flexlay/lib/object_transform_command.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_transform_command.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,41 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_OBJECT_TRANSFORM_COMMAND_HXX
-#define HEADER_OBJECT_TRANSFORM_COMMAND_HXX
-
-#include &lt;vector&gt;
-#include &quot;command.hxx&quot;
-
-class ObjMapObject;
-
-/** */
-class ObjectTransformCommand
-{
-public:
-  ObjectTransformCommand();
-  virtual ~ObjectTransformCommand();
-  
-  void excute();
-  void undo();
-  void redo();
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/objmap_control_point.cpp (from rev 712, trunk/flexlay/lib/objmap_control_point.cxx)
===================================================================
--- trunk/flexlay/lib/objmap_control_point.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_control_point.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,99 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &quot;objmap_control_point.hpp&quot;
+
+class ObjMapControlPointImpl
+{
+public:
+  CL_Sprite sprite;
+  CL_Pointf  pos;
+  MetaData  data;
+
+  void draw(CL_GraphicContext* gc);
+  CL_Rect get_bound_rect() const;
+  CL_Signal_v1&lt;CL_Pointf&gt; on_set_pos;
+};
+
+CL_Signal_v1&lt;CL_Pointf&gt;&amp; 
+ObjMapControlPoint::sig_set_pos()
+{
+  return impl-&gt;on_set_pos;
+}
+
+ObjMapControlPoint::ObjMapControlPoint(CL_Sprite sprite_, CL_Pointf pos_, MetaData data_)
+  : impl(new ObjMapControlPointImpl)
+{
+  impl-&gt;sprite = sprite_;
+  impl-&gt;pos    = pos_;
+  impl-&gt;data   = data_;
+}
+
+void
+ObjMapControlPoint::draw(CL_GraphicContext* gc)
+{
+  impl-&gt;draw(gc);
+}
+
+void
+ObjMapControlPointImpl::draw(CL_GraphicContext* gc)
+{
+  sprite.draw(static_cast&lt;int&gt;(pos.x), static_cast&lt;int&gt;(pos.y), gc);
+}
+
+void
+ObjMapControlPoint::set_pos_raw(const CL_Pointf&amp; p)
+{
+  impl-&gt;pos = p;
+}
+
+void
+ObjMapControlPoint::set_pos(const CL_Pointf&amp; p)
+{
+  impl-&gt;on_set_pos(p);
+}
+
+CL_Pointf
+ObjMapControlPoint::get_pos() const
+{
+  return impl-&gt;pos;
+}
+
+CL_Rect
+ObjMapControlPoint::get_bound_rect() const
+{
+  return impl-&gt;get_bound_rect();
+}
+
+CL_Rect
+ObjMapControlPointImpl::get_bound_rect() const
+{
+  CL_Point  align = CL_Point(0, 0);
+  CL_Origin origin_e;
+
+  sprite.get_alignment(origin_e, align.x, align.y);
+
+  CL_Point origin = calc_origin(origin_e, CL_Size(sprite.get_width(),
+                                                  sprite.get_height()));
+  align.x = -align.x;
+      
+  return CL_Rect(CL_Point(pos) - origin - align,
+                 CL_Size(sprite.get_width(), sprite.get_height()));
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/objmap_control_point.cxx
===================================================================
--- trunk/flexlay/lib/objmap_control_point.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_control_point.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,99 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &quot;objmap_control_point.hxx&quot;
-
-class ObjMapControlPointImpl
-{
-public:
-  CL_Sprite sprite;
-  CL_Pointf  pos;
-  MetaData  data;
-
-  void draw(CL_GraphicContext* gc);
-  CL_Rect get_bound_rect() const;
-  CL_Signal_v1&lt;CL_Pointf&gt; on_set_pos;
-};
-
-CL_Signal_v1&lt;CL_Pointf&gt;&amp; 
-ObjMapControlPoint::sig_set_pos()
-{
-  return impl-&gt;on_set_pos;
-}
-
-ObjMapControlPoint::ObjMapControlPoint(CL_Sprite sprite_, CL_Pointf pos_, MetaData data_)
-  : impl(new ObjMapControlPointImpl)
-{
-  impl-&gt;sprite = sprite_;
-  impl-&gt;pos    = pos_;
-  impl-&gt;data   = data_;
-}
-
-void
-ObjMapControlPoint::draw(CL_GraphicContext* gc)
-{
-  impl-&gt;draw(gc);
-}
-
-void
-ObjMapControlPointImpl::draw(CL_GraphicContext* gc)
-{
-  sprite.draw(static_cast&lt;int&gt;(pos.x), static_cast&lt;int&gt;(pos.y), gc);
-}
-
-void
-ObjMapControlPoint::set_pos_raw(const CL_Pointf&amp; p)
-{
-  impl-&gt;pos = p;
-}
-
-void
-ObjMapControlPoint::set_pos(const CL_Pointf&amp; p)
-{
-  impl-&gt;on_set_pos(p);
-}
-
-CL_Pointf
-ObjMapControlPoint::get_pos() const
-{
-  return impl-&gt;pos;
-}
-
-CL_Rect
-ObjMapControlPoint::get_bound_rect() const
-{
-  return impl-&gt;get_bound_rect();
-}
-
-CL_Rect
-ObjMapControlPointImpl::get_bound_rect() const
-{
-  CL_Point  align = CL_Point(0, 0);
-  CL_Origin origin_e;
-
-  sprite.get_alignment(origin_e, align.x, align.y);
-
-  CL_Point origin = calc_origin(origin_e, CL_Size(sprite.get_width(),
-                                                  sprite.get_height()));
-  align.x = -align.x;
-      
-  return CL_Rect(CL_Point(pos) - origin - align,
-                 CL_Size(sprite.get_width(), sprite.get_height()));
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/objmap_control_point.hpp (from rev 712, trunk/flexlay/lib/objmap_control_point.hxx)
===================================================================
--- trunk/flexlay/lib/objmap_control_point.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_control_point.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,56 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_OBJMAP_CONTROL_POINT_HXX
+#define HEADER_OBJMAP_CONTROL_POINT_HXX
+
+#include &lt;ClanLib/Display/sprite.h&gt;
+#include &lt;ClanLib/Core/Math/point.h&gt;
+#include &quot;meta_data.hpp&quot;
+#include &quot;shared_ptr.hpp&quot;
+
+class ObjMapControlPointImpl;
+
+/** An ObjMapControlPoint is used to control a property of an object,
+    such as size, rotation or scaling. ControlPoints get drawn around
+    the object in a size which is independend of the current zoom
+    level and can be draged around with the mous. */
+class ObjMapControlPoint
+{
+private:
+public:
+  ObjMapControlPoint() : impl(0) {}
+  ObjMapControlPoint(CL_Sprite sprite_, CL_Pointf pos_, MetaData data_);
+
+  CL_Pointf get_pos() const;
+  void     set_pos(const CL_Pointf&amp; p);
+  void     set_pos_raw(const CL_Pointf&amp; p);
+  void     draw(CL_GraphicContext* gc);
+
+  CL_Rect get_bound_rect() const;
+
+  CL_Signal_v1&lt;CL_Pointf&gt;&amp; sig_set_pos();
+
+  bool is_null() const { return !impl.get(); }
+private:
+  SharedPtr&lt;ObjMapControlPointImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/objmap_control_point.hxx
===================================================================
--- trunk/flexlay/lib/objmap_control_point.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_control_point.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,56 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_OBJMAP_CONTROL_POINT_HXX
-#define HEADER_OBJMAP_CONTROL_POINT_HXX
-
-#include &lt;ClanLib/Display/sprite.h&gt;
-#include &lt;ClanLib/Core/Math/point.h&gt;
-#include &quot;meta_data.hxx&quot;
-#include &quot;shared_ptr.hxx&quot;
-
-class ObjMapControlPointImpl;
-
-/** An ObjMapControlPoint is used to control a property of an object,
-    such as size, rotation or scaling. ControlPoints get drawn around
-    the object in a size which is independend of the current zoom
-    level and can be draged around with the mous. */
-class ObjMapControlPoint
-{
-private:
-public:
-  ObjMapControlPoint() : impl(0) {}
-  ObjMapControlPoint(CL_Sprite sprite_, CL_Pointf pos_, MetaData data_);
-
-  CL_Pointf get_pos() const;
-  void     set_pos(const CL_Pointf&amp; p);
-  void     set_pos_raw(const CL_Pointf&amp; p);
-  void     draw(CL_GraphicContext* gc);
-
-  CL_Rect get_bound_rect() const;
-
-  CL_Signal_v1&lt;CL_Pointf&gt;&amp; sig_set_pos();
-
-  bool is_null() const { return !impl.get(); }
-private:
-  SharedPtr&lt;ObjMapControlPointImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/objmap_object.cpp (from rev 712, trunk/flexlay/lib/objmap_object.cxx)
===================================================================
--- trunk/flexlay/lib/objmap_object.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_object.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,129 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &quot;objmap_object_impl.hpp&quot;
+#include &quot;objmap_object.hpp&quot;
+
+ObjMapObject::ObjMapObject()
+{
+}
+
+ObjMapObject::ObjMapObject(const SharedPtr&lt;ObjMapObjectImpl&gt;&amp; impl_)
+  : impl(impl_)
+{
+}
+
+CL_Pointf
+ObjMapObject::get_pos() const 
+{
+  if (impl.get())
+    return impl-&gt;pos; 
+  else
+    return CL_Pointf();
+}
+
+void
+ObjMapObject::set_pos(const CL_Pointf&amp; p) 
+{
+  if (impl.get())
+    {
+      impl-&gt;pos = p; 
+    }
+}
+
+MetaData
+ObjMapObject::get_metadata() const
+{
+  if (impl.get())
+    return impl-&gt;data; 
+  else
+    return MetaData();
+}
+
+void
+ObjMapObject::set_metadata(const MetaData&amp; data_)
+{
+  if (impl.get())
+    impl-&gt;data = data_;
+}
+
+void
+ObjMapObject::draw(CL_GraphicContext* gc)
+{
+  if (impl.get())
+    impl-&gt;draw(gc);
+}
+
+CL_Rectf
+ObjMapObject::get_bound_rect() const
+{
+  if (impl.get())
+    return impl-&gt;get_bound_rect();
+  else
+    return CL_Rect();
+}
+
+bool
+ObjMapObject::is_null() const
+{
+  return !impl.get();
+}
+
+bool
+ObjMapObject::operator==(const ObjMapObject&amp; obj) const
+{
+  return impl.get() == obj.impl.get();
+}
+
+bool
+ObjMapObject::operator&lt;(const ObjMapObject&amp; obj) const
+{
+  return impl.get() &lt; obj.impl.get();
+}
+
+CL_Signal_v1&lt;ObjMapObject&gt;&amp;
+ObjMapObject::sig_select()
+{
+  return impl-&gt;on_select;
+}
+
+CL_Signal_v1&lt;ObjMapObject&gt;&amp;
+ObjMapObject::sig_deselect()
+{
+  return impl-&gt;on_deselect;
+}
+
+CL_Signal_v1&lt;ObjMapObject&gt;&amp;
+ObjMapObject::sig_move()
+{
+  return impl-&gt;on_move;
+}
+
+void
+ObjMapObject::add_control_points()
+{
+  impl-&gt;add_control_points();
+}
+
+void
+ObjMapObject::update_control_points()
+{
+  impl-&gt;update_control_points();
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/objmap_object.cxx
===================================================================
--- trunk/flexlay/lib/objmap_object.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_object.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,129 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &quot;objmap_object_impl.hxx&quot;
-#include &quot;objmap_object.hxx&quot;
-
-ObjMapObject::ObjMapObject()
-{
-}
-
-ObjMapObject::ObjMapObject(const SharedPtr&lt;ObjMapObjectImpl&gt;&amp; impl_)
-  : impl(impl_)
-{
-}
-
-CL_Pointf
-ObjMapObject::get_pos() const 
-{
-  if (impl.get())
-    return impl-&gt;pos; 
-  else
-    return CL_Pointf();
-}
-
-void
-ObjMapObject::set_pos(const CL_Pointf&amp; p) 
-{
-  if (impl.get())
-    {
-      impl-&gt;pos = p; 
-    }
-}
-
-MetaData
-ObjMapObject::get_metadata() const
-{
-  if (impl.get())
-    return impl-&gt;data; 
-  else
-    return MetaData();
-}
-
-void
-ObjMapObject::set_metadata(const MetaData&amp; data_)
-{
-  if (impl.get())
-    impl-&gt;data = data_;
-}
-
-void
-ObjMapObject::draw(CL_GraphicContext* gc)
-{
-  if (impl.get())
-    impl-&gt;draw(gc);
-}
-
-CL_Rectf
-ObjMapObject::get_bound_rect() const
-{
-  if (impl.get())
-    return impl-&gt;get_bound_rect();
-  else
-    return CL_Rect();
-}
-
-bool
-ObjMapObject::is_null() const
-{
-  return !impl.get();
-}
-
-bool
-ObjMapObject::operator==(const ObjMapObject&amp; obj) const
-{
-  return impl.get() == obj.impl.get();
-}
-
-bool
-ObjMapObject::operator&lt;(const ObjMapObject&amp; obj) const
-{
-  return impl.get() &lt; obj.impl.get();
-}
-
-CL_Signal_v1&lt;ObjMapObject&gt;&amp;
-ObjMapObject::sig_select()
-{
-  return impl-&gt;on_select;
-}
-
-CL_Signal_v1&lt;ObjMapObject&gt;&amp;
-ObjMapObject::sig_deselect()
-{
-  return impl-&gt;on_deselect;
-}
-
-CL_Signal_v1&lt;ObjMapObject&gt;&amp;
-ObjMapObject::sig_move()
-{
-  return impl-&gt;on_move;
-}
-
-void
-ObjMapObject::add_control_points()
-{
-  impl-&gt;add_control_points();
-}
-
-void
-ObjMapObject::update_control_points()
-{
-  impl-&gt;update_control_points();
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/objmap_object.hpp (from rev 712, trunk/flexlay/lib/objmap_object.hxx)
===================================================================
--- trunk/flexlay/lib/objmap_object.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_object.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,64 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_OBJMAP_OBJECT_HXX
+#define HEADER_OBJMAP_OBJECT_HXX
+
+#include &lt;ClanLib/signals.h&gt;
+#include &lt;ClanLib/Display/graphic_context.h&gt;
+#include &lt;ClanLib/Core/Math/point.h&gt;
+#include &lt;ClanLib/Core/Math/rect.h&gt;
+#include &quot;meta_data.hpp&quot;
+
+class ObjMapObjectImpl;
+
+/** */
+class ObjMapObject
+{
+public:
+  ObjMapObject();
+  ObjMapObject(const SharedPtr&lt;ObjMapObjectImpl&gt;&amp; impl_);
+  virtual ~ObjMapObject() {}
+
+  CL_Pointf get_pos() const;
+  void     set_pos(const CL_Pointf&amp; p);
+
+  MetaData get_metadata() const;
+  void     set_metadata(const MetaData&amp; data_);
+
+  CL_Signal_v1&lt;ObjMapObject&gt;&amp; sig_move();
+  CL_Signal_v1&lt;ObjMapObject&gt;&amp; sig_select();
+  CL_Signal_v1&lt;ObjMapObject&gt;&amp; sig_deselect();
+
+  void draw(CL_GraphicContext* gc);
+  CL_Rectf get_bound_rect() const;
+
+  void add_control_points();
+  void update_control_points();
+
+  bool is_null() const;
+
+  bool operator==(const ObjMapObject&amp; obj) const;
+  bool operator&lt;(const ObjMapObject&amp; obj) const;
+private:
+  SharedPtr&lt;ObjMapObjectImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/objmap_object.hxx
===================================================================
--- trunk/flexlay/lib/objmap_object.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_object.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,64 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_OBJMAP_OBJECT_HXX
-#define HEADER_OBJMAP_OBJECT_HXX
-
-#include &lt;ClanLib/signals.h&gt;
-#include &lt;ClanLib/Display/graphic_context.h&gt;
-#include &lt;ClanLib/Core/Math/point.h&gt;
-#include &lt;ClanLib/Core/Math/rect.h&gt;
-#include &quot;meta_data.hxx&quot;
-
-class ObjMapObjectImpl;
-
-/** */
-class ObjMapObject
-{
-public:
-  ObjMapObject();
-  ObjMapObject(const SharedPtr&lt;ObjMapObjectImpl&gt;&amp; impl_);
-  virtual ~ObjMapObject() {}
-
-  CL_Pointf get_pos() const;
-  void     set_pos(const CL_Pointf&amp; p);
-
-  MetaData get_metadata() const;
-  void     set_metadata(const MetaData&amp; data_);
-
-  CL_Signal_v1&lt;ObjMapObject&gt;&amp; sig_move();
-  CL_Signal_v1&lt;ObjMapObject&gt;&amp; sig_select();
-  CL_Signal_v1&lt;ObjMapObject&gt;&amp; sig_deselect();
-
-  void draw(CL_GraphicContext* gc);
-  CL_Rectf get_bound_rect() const;
-
-  void add_control_points();
-  void update_control_points();
-
-  bool is_null() const;
-
-  bool operator==(const ObjMapObject&amp; obj) const;
-  bool operator&lt;(const ObjMapObject&amp; obj) const;
-private:
-  SharedPtr&lt;ObjMapObjectImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/objmap_object_impl.cpp (from rev 712, trunk/flexlay/lib/objmap_object_impl.cxx)
===================================================================
--- trunk/flexlay/lib/objmap_object_impl.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_object_impl.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,42 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &quot;objmap_object_impl.hpp&quot;
+
+ObjMapObjectImpl::ObjMapObjectImpl()
+{
+}
+
+ObjMapObjectImpl::~ObjMapObjectImpl()
+{
+}
+
+void
+ObjMapObjectImpl::update_control_points()
+{
+  //std::cout &lt;&lt; &quot;Object doesn't have control points to upadate&quot; &lt;&lt; std::endl;
+}
+
+void
+ObjMapObjectImpl::add_control_points()
+{
+  //std::cout &lt;&lt; &quot;Object doesn't have control points&quot; &lt;&lt; std::endl;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/objmap_object_impl.cxx
===================================================================
--- trunk/flexlay/lib/objmap_object_impl.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_object_impl.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,42 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &quot;objmap_object_impl.hxx&quot;
-
-ObjMapObjectImpl::ObjMapObjectImpl()
-{
-}
-
-ObjMapObjectImpl::~ObjMapObjectImpl()
-{
-}
-
-void
-ObjMapObjectImpl::update_control_points()
-{
-  //std::cout &lt;&lt; &quot;Object doesn't have control points to upadate&quot; &lt;&lt; std::endl;
-}
-
-void
-ObjMapObjectImpl::add_control_points()
-{
-  //std::cout &lt;&lt; &quot;Object doesn't have control points&quot; &lt;&lt; std::endl;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/objmap_object_impl.hpp (from rev 712, trunk/flexlay/lib/objmap_object_impl.hxx)
===================================================================
--- trunk/flexlay/lib/objmap_object_impl.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_object_impl.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,49 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_OBJMAP_OBJECT_IMPL_HXX
+#define HEADER_OBJMAP_OBJECT_IMPL_HXX
+
+#include &lt;ClanLib/Core/Math/point.h&gt;
+#include &lt;ClanLib/Core/Math/rect.h&gt;
+#include &quot;objmap_object.hpp&quot;
+#include &quot;meta_data.hpp&quot;
+
+class ObjMapObjectImpl 
+{
+public:
+  CL_Pointf  pos;
+  MetaData  data;
+
+  CL_Signal_v1&lt;ObjMapObject&gt; on_move;
+  CL_Signal_v1&lt;ObjMapObject&gt; on_select;
+  CL_Signal_v1&lt;ObjMapObject&gt; on_deselect;
+
+  ObjMapObjectImpl();
+  virtual ~ObjMapObjectImpl();
+
+  virtual void draw(CL_GraphicContext* gc) =0;
+  virtual CL_Rectf get_bound_rect() const  =0;
+
+  virtual void add_control_points();
+  virtual void update_control_points();
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/objmap_object_impl.hxx
===================================================================
--- trunk/flexlay/lib/objmap_object_impl.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_object_impl.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,49 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_OBJMAP_OBJECT_IMPL_HXX
-#define HEADER_OBJMAP_OBJECT_IMPL_HXX
-
-#include &lt;ClanLib/Core/Math/point.h&gt;
-#include &lt;ClanLib/Core/Math/rect.h&gt;
-#include &quot;objmap_object.hxx&quot;
-#include &quot;meta_data.hxx&quot;
-
-class ObjMapObjectImpl 
-{
-public:
-  CL_Pointf  pos;
-  MetaData  data;
-
-  CL_Signal_v1&lt;ObjMapObject&gt; on_move;
-  CL_Signal_v1&lt;ObjMapObject&gt; on_select;
-  CL_Signal_v1&lt;ObjMapObject&gt; on_deselect;
-
-  ObjMapObjectImpl();
-  virtual ~ObjMapObjectImpl();
-
-  virtual void draw(CL_GraphicContext* gc) =0;
-  virtual CL_Rectf get_bound_rect() const  =0;
-
-  virtual void add_control_points();
-  virtual void update_control_points();
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/objmap_path_node.cpp (from rev 712, trunk/flexlay/lib/objmap_path_node.cxx)
===================================================================
--- trunk/flexlay/lib/objmap_path_node.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_path_node.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,107 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;ClanLib/Display/display.h&gt;
+#include &quot;objmap_object_impl.hpp&quot;
+#include &quot;objmap_path_node.hpp&quot;
+
+class ObjMapPathNodeImpl : public ObjMapObjectImpl
+{
+public:
+  ObjMapPathNodeImpl* prev;
+  ObjMapPathNodeImpl* next;
+  
+  ObjMapPathNodeImpl();
+
+  void draw(CL_GraphicContext* gc);
+  CL_Rectf get_bound_rect() const;
+};
+
+ObjMapPathNodeImpl::ObjMapPathNodeImpl()
+{
+  next = 0;
+  prev = 0;
+}
+
+void
+ObjMapPathNodeImpl::draw(CL_GraphicContext* gc)
+{
+  gc-&gt;fill_rect(CL_Rect(CL_Point(pos) - CL_Point(16,16), CL_Size(32, 32)), 
+                CL_Color(200, 255, 200));
+  if (next)
+    {
+      gc-&gt;draw_line(static_cast&lt;int&gt;(pos.x), static_cast&lt;int&gt;(pos.y),
+                    static_cast&lt;int&gt;((pos.x + next-&gt;pos.x)/2),
+                    static_cast&lt;int&gt;((pos.y+next-&gt;pos.y)/2),
+                    CL_Color(255, 255, 0));
+
+      gc-&gt;draw_line(static_cast&lt;int&gt;((pos.x + next-&gt;pos.x)/2), 
+                    static_cast&lt;int&gt;((pos.y+next-&gt;pos.y)/2),
+                    static_cast&lt;int&gt;(next-&gt;pos.x),
+                    static_cast&lt;int&gt;(next-&gt;pos.y), 
+                    CL_Color(255, 0, 0));
+    }
+}
+
+CL_Rectf
+ObjMapPathNodeImpl::get_bound_rect() const
+{
+  return CL_Rectf(pos - CL_Pointf(16,16), CL_Sizef(32, 32));
+}
+
+ObjMapPathNode::ObjMapPathNode(const CL_Pointf&amp; pos_, 
+                               const MetaData&amp; data_)
+  : impl(new ObjMapPathNodeImpl())
+{  
+  impl-&gt;pos  = pos_;
+  impl-&gt;data = data_;
+}
+
+void
+ObjMapPathNode::disconnect()
+{
+  impl-&gt;next = 0;
+  impl-&gt;prev = 0;
+
+  impl-&gt;next-&gt;prev = 0;
+  impl-&gt;prev-&gt;next = 0;
+}
+
+void
+ObjMapPathNode::connect(ObjMapPathNode next)
+{
+  if (next.impl-&gt;next != impl.get()) // avoid circular link between two nodes
+    {
+      if (next.impl-&gt;prev) // ensure that each node links exactly to one prev and one next node 
+        {
+          next.impl-&gt;prev-&gt;next = 0;
+          next.impl-&gt;prev = 0;
+        }
+
+      impl-&gt;next = next.impl.get();
+      next.impl-&gt;prev = impl.get();
+    }
+}
+
+ObjMapObject
+ObjMapPathNode::to_object()
+{
+  return ObjMapObject(impl);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/objmap_path_node.cxx
===================================================================
--- trunk/flexlay/lib/objmap_path_node.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_path_node.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,107 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;ClanLib/Display/display.h&gt;
-#include &quot;objmap_object_impl.hxx&quot;
-#include &quot;objmap_path_node.hxx&quot;
-
-class ObjMapPathNodeImpl : public ObjMapObjectImpl
-{
-public:
-  ObjMapPathNodeImpl* prev;
-  ObjMapPathNodeImpl* next;
-  
-  ObjMapPathNodeImpl();
-
-  void draw(CL_GraphicContext* gc);
-  CL_Rectf get_bound_rect() const;
-};
-
-ObjMapPathNodeImpl::ObjMapPathNodeImpl()
-{
-  next = 0;
-  prev = 0;
-}
-
-void
-ObjMapPathNodeImpl::draw(CL_GraphicContext* gc)
-{
-  gc-&gt;fill_rect(CL_Rect(CL_Point(pos) - CL_Point(16,16), CL_Size(32, 32)), 
-                CL_Color(200, 255, 200));
-  if (next)
-    {
-      gc-&gt;draw_line(static_cast&lt;int&gt;(pos.x), static_cast&lt;int&gt;(pos.y),
-                    static_cast&lt;int&gt;((pos.x + next-&gt;pos.x)/2),
-                    static_cast&lt;int&gt;((pos.y+next-&gt;pos.y)/2),
-                    CL_Color(255, 255, 0));
-
-      gc-&gt;draw_line(static_cast&lt;int&gt;((pos.x + next-&gt;pos.x)/2), 
-                    static_cast&lt;int&gt;((pos.y+next-&gt;pos.y)/2),
-                    static_cast&lt;int&gt;(next-&gt;pos.x),
-                    static_cast&lt;int&gt;(next-&gt;pos.y), 
-                    CL_Color(255, 0, 0));
-    }
-}
-
-CL_Rectf
-ObjMapPathNodeImpl::get_bound_rect() const
-{
-  return CL_Rectf(pos - CL_Pointf(16,16), CL_Sizef(32, 32));
-}
-
-ObjMapPathNode::ObjMapPathNode(const CL_Pointf&amp; pos_, 
-                               const MetaData&amp; data_)
-  : impl(new ObjMapPathNodeImpl())
-{  
-  impl-&gt;pos  = pos_;
-  impl-&gt;data = data_;
-}
-
-void
-ObjMapPathNode::disconnect()
-{
-  impl-&gt;next = 0;
-  impl-&gt;prev = 0;
-
-  impl-&gt;next-&gt;prev = 0;
-  impl-&gt;prev-&gt;next = 0;
-}
-
-void
-ObjMapPathNode::connect(ObjMapPathNode next)
-{
-  if (next.impl-&gt;next != impl.get()) // avoid circular link between two nodes
-    {
-      if (next.impl-&gt;prev) // ensure that each node links exactly to one prev and one next node 
-        {
-          next.impl-&gt;prev-&gt;next = 0;
-          next.impl-&gt;prev = 0;
-        }
-
-      impl-&gt;next = next.impl.get();
-      next.impl-&gt;prev = impl.get();
-    }
-}
-
-ObjMapObject
-ObjMapPathNode::to_object()
-{
-  return ObjMapObject(impl);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/objmap_path_node.hpp (from rev 712, trunk/flexlay/lib/objmap_path_node.hxx)
===================================================================
--- trunk/flexlay/lib/objmap_path_node.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_path_node.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,43 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_OBJMAP_PATH_NODE_HXX
+#define HEADER_OBJMAP_PATH_NODE_HXX
+
+#include &quot;objmap_object.hpp&quot;
+
+class ObjMapPathNodeImpl;
+
+/** */
+class ObjMapPathNode
+{
+public:
+  ObjMapPathNode(const CL_Pointf&amp; pos_, 
+                 const MetaData&amp; data_);
+  
+  void connect(ObjMapPathNode next);
+  void disconnect();
+
+  ObjMapObject to_object();
+private:
+  SharedPtr&lt;ObjMapPathNodeImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/objmap_path_node.hxx
===================================================================
--- trunk/flexlay/lib/objmap_path_node.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_path_node.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,43 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_OBJMAP_PATH_NODE_HXX
-#define HEADER_OBJMAP_PATH_NODE_HXX
-
-#include &quot;objmap_object.hxx&quot;
-
-class ObjMapPathNodeImpl;
-
-/** */
-class ObjMapPathNode
-{
-public:
-  ObjMapPathNode(const CL_Pointf&amp; pos_, 
-                 const MetaData&amp; data_);
-  
-  void connect(ObjMapPathNode next);
-  void disconnect();
-
-  ObjMapObject to_object();
-private:
-  SharedPtr&lt;ObjMapPathNodeImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/objmap_rect_object.cpp (from rev 712, trunk/flexlay/lib/objmap_rect_object.cxx)
===================================================================
--- trunk/flexlay/lib/objmap_rect_object.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_rect_object.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,250 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &lt;ClanLib/Core/core_iostream.h&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &lt;ClanLib/Display/sprite.h&gt;
+#include &quot;object_layer.hpp&quot;
+#include &quot;objmap_control_point.hpp&quot;
+#include &quot;objmap_rect_object.hpp&quot;
+#include &quot;flexlay.hpp&quot;
+
+class ObjMapRectObjectImpl : public ObjMapObjectImpl
+{
+public:
+  std::vector&lt;CL_Slot&gt; slots;
+  CL_Sizef size;
+  CL_Color color;
+
+  ObjMapControlPoint cp_top_left;
+  ObjMapControlPoint cp_top_right;
+  ObjMapControlPoint cp_bottom_left;
+  ObjMapControlPoint cp_bottom_right;
+  ObjMapControlPoint cp_top_middle;
+  ObjMapControlPoint cp_bottom_middle;  
+  ObjMapControlPoint cp_middle_left;
+  ObjMapControlPoint cp_middle_right;  
+
+  void set_rect(CL_Rect rect) {
+    pos  = CL_Pointf(rect.left, rect.top);
+    size = CL_Sizef(rect.get_width(), rect.get_height());
+  }
+
+  void cp_top_left_move(CL_Pointf pos_) {
+    size.width  += pos.x - pos_.x;
+    size.height += pos.y - pos_.y;
+    pos = pos_;
+
+    normalize_rect();
+    update_control_points();
+  }
+
+  void cp_top_right_move(CL_Pointf pos_) {
+    size.width  += pos_.x - (pos.x + size.width);
+    size.height += pos.y - pos_.y;
+    
+    pos.y = pos_.y;
+
+    normalize_rect();
+    update_control_points();
+  }
+
+  void cp_bottom_left_move(CL_Pointf pos_) {
+    size.width  += pos.x - pos_.x;
+    size.height += pos_.y - (pos.y + size.height);
+    pos.x = pos_.x;
+
+    normalize_rect();
+    update_control_points();
+  }
+  void cp_bottom_right_move(CL_Pointf pos_) {
+    size.width  += pos_.x - (pos.x + size.width);
+    size.height += pos_.y - (pos.y + size.height);
+
+    normalize_rect();
+    update_control_points();
+  }
+
+  void cp_top_middle_move(CL_Pointf pos_) {
+    size.height += pos.y - pos_.y;  
+    pos.y = pos_.y;
+
+    normalize_rect();
+    update_control_points();
+  }
+  void cp_bottom_middle_move(CL_Pointf pos_) {
+    size.height += pos_.y - (pos.y + size.height);
+
+    normalize_rect();
+    update_control_points();
+  }
+  void cp_middle_left_move(CL_Pointf pos_) {
+    size.width  += pos.x - pos_.x;
+    pos.x = pos_.x;
+
+    normalize_rect();
+    update_control_points();
+  }
+  void cp_middle_right_move(CL_Pointf pos_) {
+    size.width  += pos_.x - (pos.x + size.width);
+
+    normalize_rect();
+    update_control_points();
+  }
+
+  void normalize_rect() {
+    if (size.width &lt; 0) {
+      pos.x     += size.width;
+      size.width = -size.width;
+    }
+
+    if (size.height &lt; 0) {
+      pos.y      += size.height;
+      size.height = -size.height;
+    }
+  }
+
+  void draw(CL_GraphicContext* gc);
+  CL_Rectf get_bound_rect() const;
+  void add_control_points();
+  void update_control_points();
+};
+
+CL_Rectf
+ObjMapRectObject::get_rect() const
+{
+  return impl-&gt;get_bound_rect();
+}
+
+void
+ObjMapRectObject::set_color(const CL_Color&amp; color)
+{
+  impl-&gt;color = color;
+}
+
+void
+ObjMapRectObject::set_rect(const CL_Rect&amp; rect)
+{
+  impl-&gt;pos  = CL_Pointf(rect.left, rect.top);
+  impl-&gt;size = CL_Sizef(rect.get_width(), rect.get_height());
+}
+
+void
+ObjMapRectObjectImpl::update_control_points()
+{
+  cp_top_left.set_pos_raw(pos);
+  cp_top_right.set_pos_raw(pos + CL_Pointf(size.width, 0));
+  cp_bottom_left.set_pos_raw(pos + CL_Pointf(0, size.height));
+  cp_bottom_right.set_pos_raw(pos + CL_Pointf(size.width, size.height));
+  cp_top_middle.set_pos_raw(pos + CL_Pointf(size.width/2, 0));
+  cp_bottom_middle.set_pos_raw(pos + CL_Pointf(size.width/2, size.height));
+  cp_middle_left.set_pos_raw(pos + CL_Pointf(0, size.height/2));
+  cp_middle_right.set_pos_raw(pos + CL_Pointf(size.width, size.height/2));
+}
+
+ObjMapRectObject::ObjMapRectObject(const CL_Rect&amp;  rect_,
+                                   const CL_Color&amp; color_,
+                                   const MetaData&amp; data_)  
+  : impl(new ObjMapRectObjectImpl)
+{
+  impl-&gt;pos   = CL_Pointf(rect_.left, rect_.top);
+  impl-&gt;size  = CL_Sizef(rect_.get_width(), rect_.get_height());
+  impl-&gt;color = color_;
+  impl-&gt;data  = data_;
+
+  impl-&gt;cp_top_left = ObjMapControlPoint(CL_Sprite(&quot;resize1&quot;, &amp;(Flexlay::current()-&gt;resources)), 
+                                         CL_Pointf(),
+                                         MetaData());
+  
+  impl-&gt;cp_bottom_right = ObjMapControlPoint(CL_Sprite(&quot;resize1&quot;, &amp;(Flexlay::current()-&gt;resources)), 
+                                             CL_Pointf(),
+                                             MetaData());
+ 
+  impl-&gt;cp_top_right = ObjMapControlPoint(CL_Sprite(&quot;resize2&quot;, &amp;(Flexlay::current()-&gt;resources)), 
+                                             CL_Pointf(),
+                                          MetaData());
+  
+  impl-&gt;cp_bottom_left = ObjMapControlPoint(CL_Sprite(&quot;resize2&quot;, &amp;(Flexlay::current()-&gt;resources)), 
+                                                   CL_Pointf(),
+                                                   MetaData());
+  
+  impl-&gt;cp_middle_left = ObjMapControlPoint(CL_Sprite(&quot;resize_horz&quot;, &amp;(Flexlay::current()-&gt;resources)), 
+                                            CL_Pointf(),
+                                            MetaData());
+  impl-&gt;cp_middle_right  = ObjMapControlPoint(CL_Sprite(&quot;resize_horz&quot;, &amp;(Flexlay::current()-&gt;resources)), 
+                                              CL_Pointf(),
+                                              MetaData());
+  impl-&gt;cp_top_middle = ObjMapControlPoint(CL_Sprite(&quot;resize_vert&quot;, &amp;(Flexlay::current()-&gt;resources)), 
+                                           CL_Pointf(),
+                                           MetaData());
+  
+  impl-&gt;cp_bottom_middle = ObjMapControlPoint(CL_Sprite(&quot;resize_vert&quot;, &amp;(Flexlay::current()-&gt;resources)), 
+                                              CL_Pointf(),
+                                              MetaData());
+
+
+  impl-&gt;slots.push_back(impl-&gt;cp_top_right.sig_set_pos().connect(impl.get(), &amp;ObjMapRectObjectImpl::cp_top_right_move));
+  impl-&gt;slots.push_back(impl-&gt;cp_bottom_right.sig_set_pos().connect(impl.get(), &amp;ObjMapRectObjectImpl::cp_bottom_right_move));
+
+  impl-&gt;slots.push_back(impl-&gt;cp_top_left.sig_set_pos().connect(impl.get(), &amp;ObjMapRectObjectImpl::cp_top_left_move));
+  impl-&gt;slots.push_back(impl-&gt;cp_bottom_left.sig_set_pos().connect(impl.get(), &amp;ObjMapRectObjectImpl::cp_bottom_left_move));
+
+  impl-&gt;slots.push_back(impl-&gt;cp_middle_left.sig_set_pos().connect(impl.get(), &amp;ObjMapRectObjectImpl::cp_middle_left_move));
+  impl-&gt;slots.push_back(impl-&gt;cp_middle_right.sig_set_pos().connect(impl.get(), &amp;ObjMapRectObjectImpl::cp_middle_right_move));
+
+  impl-&gt;slots.push_back(impl-&gt;cp_top_middle.sig_set_pos().connect(impl.get(), &amp;ObjMapRectObjectImpl::cp_top_middle_move));
+  impl-&gt;slots.push_back(impl-&gt;cp_bottom_middle.sig_set_pos().connect(impl.get(), &amp;ObjMapRectObjectImpl::cp_bottom_middle_move));
+}
+
+void
+ObjMapRectObjectImpl::draw(CL_GraphicContext* gc)
+{
+  gc-&gt;fill_rect(get_bound_rect(), color);
+}
+
+CL_Rectf
+ObjMapRectObjectImpl::get_bound_rect() const
+{
+  return CL_Rectf(pos, size);
+}
+
+ObjMapObject
+ObjMapRectObject::to_object()
+{
+  return ObjMapObject(SharedPtr&lt;ObjMapObjectImpl&gt;(impl));
+}
+
+void
+ObjMapRectObjectImpl::add_control_points()
+{
+  update_control_points();
+  //std::cout &lt;&lt; &quot;Adding control poinst...&quot; &lt;&lt; std::endl;
+  ObjectLayer objmap = ObjectLayer::current();
+
+  objmap.add_control_point(cp_top_left);
+  objmap.add_control_point(cp_top_right);
+  objmap.add_control_point(cp_bottom_left);
+  objmap.add_control_point(cp_bottom_right);
+  objmap.add_control_point(cp_top_middle);
+  objmap.add_control_point(cp_bottom_middle);
+  objmap.add_control_point(cp_middle_left);
+  objmap.add_control_point(cp_middle_right);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/objmap_rect_object.cxx
===================================================================
--- trunk/flexlay/lib/objmap_rect_object.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_rect_object.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,250 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &lt;ClanLib/Core/core_iostream.h&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-#include &lt;ClanLib/Display/sprite.h&gt;
-#include &quot;object_layer.hxx&quot;
-#include &quot;objmap_control_point.hxx&quot;
-#include &quot;objmap_rect_object.hxx&quot;
-#include &quot;flexlay.hxx&quot;
-
-class ObjMapRectObjectImpl : public ObjMapObjectImpl
-{
-public:
-  std::vector&lt;CL_Slot&gt; slots;
-  CL_Sizef size;
-  CL_Color color;
-
-  ObjMapControlPoint cp_top_left;
-  ObjMapControlPoint cp_top_right;
-  ObjMapControlPoint cp_bottom_left;
-  ObjMapControlPoint cp_bottom_right;
-  ObjMapControlPoint cp_top_middle;
-  ObjMapControlPoint cp_bottom_middle;  
-  ObjMapControlPoint cp_middle_left;
-  ObjMapControlPoint cp_middle_right;  
-
-  void set_rect(CL_Rect rect) {
-    pos  = CL_Pointf(rect.left, rect.top);
-    size = CL_Sizef(rect.get_width(), rect.get_height());
-  }
-
-  void cp_top_left_move(CL_Pointf pos_) {
-    size.width  += pos.x - pos_.x;
-    size.height += pos.y - pos_.y;
-    pos = pos_;
-
-    normalize_rect();
-    update_control_points();
-  }
-
-  void cp_top_right_move(CL_Pointf pos_) {
-    size.width  += pos_.x - (pos.x + size.width);
-    size.height += pos.y - pos_.y;
-    
-    pos.y = pos_.y;
-
-    normalize_rect();
-    update_control_points();
-  }
-
-  void cp_bottom_left_move(CL_Pointf pos_) {
-    size.width  += pos.x - pos_.x;
-    size.height += pos_.y - (pos.y + size.height);
-    pos.x = pos_.x;
-
-    normalize_rect();
-    update_control_points();
-  }
-  void cp_bottom_right_move(CL_Pointf pos_) {
-    size.width  += pos_.x - (pos.x + size.width);
-    size.height += pos_.y - (pos.y + size.height);
-
-    normalize_rect();
-    update_control_points();
-  }
-
-  void cp_top_middle_move(CL_Pointf pos_) {
-    size.height += pos.y - pos_.y;  
-    pos.y = pos_.y;
-
-    normalize_rect();
-    update_control_points();
-  }
-  void cp_bottom_middle_move(CL_Pointf pos_) {
-    size.height += pos_.y - (pos.y + size.height);
-
-    normalize_rect();
-    update_control_points();
-  }
-  void cp_middle_left_move(CL_Pointf pos_) {
-    size.width  += pos.x - pos_.x;
-    pos.x = pos_.x;
-
-    normalize_rect();
-    update_control_points();
-  }
-  void cp_middle_right_move(CL_Pointf pos_) {
-    size.width  += pos_.x - (pos.x + size.width);
-
-    normalize_rect();
-    update_control_points();
-  }
-
-  void normalize_rect() {
-    if (size.width &lt; 0) {
-      pos.x     += size.width;
-      size.width = -size.width;
-    }
-
-    if (size.height &lt; 0) {
-      pos.y      += size.height;
-      size.height = -size.height;
-    }
-  }
-
-  void draw(CL_GraphicContext* gc);
-  CL_Rectf get_bound_rect() const;
-  void add_control_points();
-  void update_control_points();
-};
-
-CL_Rectf
-ObjMapRectObject::get_rect() const
-{
-  return impl-&gt;get_bound_rect();
-}
-
-void
-ObjMapRectObject::set_color(const CL_Color&amp; color)
-{
-  impl-&gt;color = color;
-}
-
-void
-ObjMapRectObject::set_rect(const CL_Rect&amp; rect)
-{
-  impl-&gt;pos  = CL_Pointf(rect.left, rect.top);
-  impl-&gt;size = CL_Sizef(rect.get_width(), rect.get_height());
-}
-
-void
-ObjMapRectObjectImpl::update_control_points()
-{
-  cp_top_left.set_pos_raw(pos);
-  cp_top_right.set_pos_raw(pos + CL_Pointf(size.width, 0));
-  cp_bottom_left.set_pos_raw(pos + CL_Pointf(0, size.height));
-  cp_bottom_right.set_pos_raw(pos + CL_Pointf(size.width, size.height));
-  cp_top_middle.set_pos_raw(pos + CL_Pointf(size.width/2, 0));
-  cp_bottom_middle.set_pos_raw(pos + CL_Pointf(size.width/2, size.height));
-  cp_middle_left.set_pos_raw(pos + CL_Pointf(0, size.height/2));
-  cp_middle_right.set_pos_raw(pos + CL_Pointf(size.width, size.height/2));
-}
-
-ObjMapRectObject::ObjMapRectObject(const CL_Rect&amp;  rect_,
-                                   const CL_Color&amp; color_,
-                                   const MetaData&amp; data_)  
-  : impl(new ObjMapRectObjectImpl)
-{
-  impl-&gt;pos   = CL_Pointf(rect_.left, rect_.top);
-  impl-&gt;size  = CL_Sizef(rect_.get_width(), rect_.get_height());
-  impl-&gt;color = color_;
-  impl-&gt;data  = data_;
-
-  impl-&gt;cp_top_left = ObjMapControlPoint(CL_Sprite(&quot;resize1&quot;, &amp;(Flexlay::current()-&gt;resources)), 
-                                         CL_Pointf(),
-                                         MetaData());
-  
-  impl-&gt;cp_bottom_right = ObjMapControlPoint(CL_Sprite(&quot;resize1&quot;, &amp;(Flexlay::current()-&gt;resources)), 
-                                             CL_Pointf(),
-                                             MetaData());
- 
-  impl-&gt;cp_top_right = ObjMapControlPoint(CL_Sprite(&quot;resize2&quot;, &amp;(Flexlay::current()-&gt;resources)), 
-                                             CL_Pointf(),
-                                          MetaData());
-  
-  impl-&gt;cp_bottom_left = ObjMapControlPoint(CL_Sprite(&quot;resize2&quot;, &amp;(Flexlay::current()-&gt;resources)), 
-                                                   CL_Pointf(),
-                                                   MetaData());
-  
-  impl-&gt;cp_middle_left = ObjMapControlPoint(CL_Sprite(&quot;resize_horz&quot;, &amp;(Flexlay::current()-&gt;resources)), 
-                                            CL_Pointf(),
-                                            MetaData());
-  impl-&gt;cp_middle_right  = ObjMapControlPoint(CL_Sprite(&quot;resize_horz&quot;, &amp;(Flexlay::current()-&gt;resources)), 
-                                              CL_Pointf(),
-                                              MetaData());
-  impl-&gt;cp_top_middle = ObjMapControlPoint(CL_Sprite(&quot;resize_vert&quot;, &amp;(Flexlay::current()-&gt;resources)), 
-                                           CL_Pointf(),
-                                           MetaData());
-  
-  impl-&gt;cp_bottom_middle = ObjMapControlPoint(CL_Sprite(&quot;resize_vert&quot;, &amp;(Flexlay::current()-&gt;resources)), 
-                                              CL_Pointf(),
-                                              MetaData());
-
-
-  impl-&gt;slots.push_back(impl-&gt;cp_top_right.sig_set_pos().connect(impl.get(), &amp;ObjMapRectObjectImpl::cp_top_right_move));
-  impl-&gt;slots.push_back(impl-&gt;cp_bottom_right.sig_set_pos().connect(impl.get(), &amp;ObjMapRectObjectImpl::cp_bottom_right_move));
-
-  impl-&gt;slots.push_back(impl-&gt;cp_top_left.sig_set_pos().connect(impl.get(), &amp;ObjMapRectObjectImpl::cp_top_left_move));
-  impl-&gt;slots.push_back(impl-&gt;cp_bottom_left.sig_set_pos().connect(impl.get(), &amp;ObjMapRectObjectImpl::cp_bottom_left_move));
-
-  impl-&gt;slots.push_back(impl-&gt;cp_middle_left.sig_set_pos().connect(impl.get(), &amp;ObjMapRectObjectImpl::cp_middle_left_move));
-  impl-&gt;slots.push_back(impl-&gt;cp_middle_right.sig_set_pos().connect(impl.get(), &amp;ObjMapRectObjectImpl::cp_middle_right_move));
-
-  impl-&gt;slots.push_back(impl-&gt;cp_top_middle.sig_set_pos().connect(impl.get(), &amp;ObjMapRectObjectImpl::cp_top_middle_move));
-  impl-&gt;slots.push_back(impl-&gt;cp_bottom_middle.sig_set_pos().connect(impl.get(), &amp;ObjMapRectObjectImpl::cp_bottom_middle_move));
-}
-
-void
-ObjMapRectObjectImpl::draw(CL_GraphicContext* gc)
-{
-  gc-&gt;fill_rect(get_bound_rect(), color);
-}
-
-CL_Rectf
-ObjMapRectObjectImpl::get_bound_rect() const
-{
-  return CL_Rectf(pos, size);
-}
-
-ObjMapObject
-ObjMapRectObject::to_object()
-{
-  return ObjMapObject(SharedPtr&lt;ObjMapObjectImpl&gt;(impl));
-}
-
-void
-ObjMapRectObjectImpl::add_control_points()
-{
-  update_control_points();
-  //std::cout &lt;&lt; &quot;Adding control poinst...&quot; &lt;&lt; std::endl;
-  ObjectLayer objmap = ObjectLayer::current();
-
-  objmap.add_control_point(cp_top_left);
-  objmap.add_control_point(cp_top_right);
-  objmap.add_control_point(cp_bottom_left);
-  objmap.add_control_point(cp_bottom_right);
-  objmap.add_control_point(cp_top_middle);
-  objmap.add_control_point(cp_bottom_middle);
-  objmap.add_control_point(cp_middle_left);
-  objmap.add_control_point(cp_middle_right);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/objmap_rect_object.hpp (from rev 712, trunk/flexlay/lib/objmap_rect_object.hxx)
===================================================================
--- trunk/flexlay/lib/objmap_rect_object.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_rect_object.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,48 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_OBJMAP_RECT_OBJECT_HXX
+#define HEADER_OBJMAP_RECT_OBJECT_HXX
+
+#include &lt;ClanLib/Core/Math/rect.h&gt;
+#include &lt;ClanLib/Display/color.h&gt;
+#include &quot;objmap_object.hpp&quot;
+#include &quot;objmap_object_impl.hpp&quot;
+
+class ObjMapRectObjectImpl;
+
+class ObjMapRectObject
+{
+public:
+  ObjMapRectObject(const CL_Rect&amp;  rect_,
+                   const CL_Color&amp; color_,
+                   const MetaData&amp; data_);
+    
+  void set_color(const CL_Color&amp; color);
+
+  void set_rect(const CL_Rect&amp; rect);
+  CL_Rectf get_rect() const;
+
+  ObjMapObject to_object();
+private:
+  SharedPtr&lt;ObjMapRectObjectImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/objmap_rect_object.hxx
===================================================================
--- trunk/flexlay/lib/objmap_rect_object.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_rect_object.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,48 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_OBJMAP_RECT_OBJECT_HXX
-#define HEADER_OBJMAP_RECT_OBJECT_HXX
-
-#include &lt;ClanLib/Core/Math/rect.h&gt;
-#include &lt;ClanLib/Display/color.h&gt;
-#include &quot;objmap_object.hxx&quot;
-#include &quot;objmap_object_impl.hxx&quot;
-
-class ObjMapRectObjectImpl;
-
-class ObjMapRectObject
-{
-public:
-  ObjMapRectObject(const CL_Rect&amp;  rect_,
-                   const CL_Color&amp; color_,
-                   const MetaData&amp; data_);
-    
-  void set_color(const CL_Color&amp; color);
-
-  void set_rect(const CL_Rect&amp; rect);
-  CL_Rectf get_rect() const;
-
-  ObjMapObject to_object();
-private:
-  SharedPtr&lt;ObjMapRectObjectImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/objmap_sprite_object.cpp (from rev 712, trunk/flexlay/lib/objmap_sprite_object.cxx)
===================================================================
--- trunk/flexlay/lib/objmap_sprite_object.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_sprite_object.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,127 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;ClanLib/Display/display.h&gt;
+#include &quot;objmap_object_impl.hpp&quot;
+#include &quot;objmap_sprite_object.hpp&quot;
+
+class ObjMapSpriteObjectImpl : public ObjMapObjectImpl
+{
+public:
+  CL_Sprite sprite;
+
+  void draw(CL_GraphicContext* gc);
+  CL_Rectf get_bound_rect() const;
+
+  ObjMapObject*  duplicate(int handle_);
+};
+
+ObjMapSpriteObject::ObjMapSpriteObject()
+{
+}
+
+ObjMapSpriteObject::ObjMapSpriteObject(const CL_Sprite&amp; sprite_,
+                                       const CL_Pointf&amp; pos_, 
+                                       const MetaData&amp; data_)
+  : impl(new ObjMapSpriteObjectImpl())
+{
+  impl-&gt;pos    = pos_;
+  impl-&gt;data   = data_;
+  impl-&gt;sprite = sprite_;
+}
+
+void
+ObjMapSpriteObjectImpl::draw(CL_GraphicContext* gc)
+{
+  sprite.draw(pos.x, pos.y, gc);
+}
+
+CL_Rectf
+ObjMapSpriteObjectImpl::get_bound_rect() const
+{
+  CL_Point  align = CL_Point(0, 0);
+  CL_Origin origin_e;
+  
+  sprite.get_alignment(origin_e, align.x, align.y);
+
+  CL_Point origin = calc_origin(origin_e, CL_Size(sprite.get_width(),
+                                                  sprite.get_height()));
+  align.x = -align.x;
+
+  // FIXME: This looks a bit hacky
+  float scale_x, scale_y;
+  sprite.get_scale(scale_x, scale_y);
+
+  if (scale_x &lt; 0)
+    align.x += sprite.get_width();
+  
+  if (scale_y &lt; 0)
+    align.y += sprite.get_height();
+      
+  //  if (scale_x &gt; 1.0f &amp;&amp; scale_y &gt; 1.0f)
+  //    return CL_Rectf(pos - origin - align,
+  //                   CL_Sizef(sprite.get_width() * scale_x, sprite.get_height() * scale_y));
+//  else
+  return CL_Rectf(pos - origin - align,
+                  CL_Sizef(sprite.get_width(), sprite.get_height()));  
+}
+
+void
+ObjMapSpriteObject::flip_vertical()
+{
+  float scale_x, scale_y;
+
+  impl-&gt;sprite.get_scale(scale_x, scale_y);
+  impl-&gt;sprite.set_scale(scale_x, -scale_y);
+  if (scale_y &lt; 0)
+    impl-&gt;pos.y -= impl-&gt;sprite.get_height();
+  else
+    impl-&gt;pos.y += impl-&gt;sprite.get_height();
+}
+
+void
+ObjMapSpriteObject::flip_horizontal()
+{
+  float scale_x, scale_y;
+  impl-&gt;sprite.get_scale(scale_x, scale_y);
+  impl-&gt;sprite.set_scale(-scale_x, scale_y);
+  if (scale_x &lt; 0)
+    impl-&gt;pos.x -= impl-&gt;sprite.get_width();
+  else
+    impl-&gt;pos.x += impl-&gt;sprite.get_width();
+}
+
+void
+ObjMapSpriteObject::set_sprite(const CL_Sprite&amp; sprite)
+{
+  impl-&gt;sprite = sprite;
+}
+
+void
+ObjMapSpriteObject::set_rotate(float angle)
+{
+  impl-&gt;sprite.set_angle(angle);
+}
+
+ObjMapObject
+ObjMapSpriteObject::to_object()
+{
+  return ObjMapObject(SharedPtr&lt;ObjMapObjectImpl&gt;(impl));
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/objmap_sprite_object.cxx
===================================================================
--- trunk/flexlay/lib/objmap_sprite_object.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_sprite_object.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,127 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;ClanLib/Display/display.h&gt;
-#include &quot;objmap_object_impl.hxx&quot;
-#include &quot;objmap_sprite_object.hxx&quot;
-
-class ObjMapSpriteObjectImpl : public ObjMapObjectImpl
-{
-public:
-  CL_Sprite sprite;
-
-  void draw(CL_GraphicContext* gc);
-  CL_Rectf get_bound_rect() const;
-
-  ObjMapObject*  duplicate(int handle_);
-};
-
-ObjMapSpriteObject::ObjMapSpriteObject()
-{
-}
-
-ObjMapSpriteObject::ObjMapSpriteObject(const CL_Sprite&amp; sprite_,
-                                       const CL_Pointf&amp; pos_, 
-                                       const MetaData&amp; data_)
-  : impl(new ObjMapSpriteObjectImpl())
-{
-  impl-&gt;pos    = pos_;
-  impl-&gt;data   = data_;
-  impl-&gt;sprite = sprite_;
-}
-
-void
-ObjMapSpriteObjectImpl::draw(CL_GraphicContext* gc)
-{
-  sprite.draw(pos.x, pos.y, gc);
-}
-
-CL_Rectf
-ObjMapSpriteObjectImpl::get_bound_rect() const
-{
-  CL_Point  align = CL_Point(0, 0);
-  CL_Origin origin_e;
-  
-  sprite.get_alignment(origin_e, align.x, align.y);
-
-  CL_Point origin = calc_origin(origin_e, CL_Size(sprite.get_width(),
-                                                  sprite.get_height()));
-  align.x = -align.x;
-
-  // FIXME: This looks a bit hacky
-  float scale_x, scale_y;
-  sprite.get_scale(scale_x, scale_y);
-
-  if (scale_x &lt; 0)
-    align.x += sprite.get_width();
-  
-  if (scale_y &lt; 0)
-    align.y += sprite.get_height();
-      
-  //  if (scale_x &gt; 1.0f &amp;&amp; scale_y &gt; 1.0f)
-  //    return CL_Rectf(pos - origin - align,
-  //                   CL_Sizef(sprite.get_width() * scale_x, sprite.get_height() * scale_y));
-//  else
-  return CL_Rectf(pos - origin - align,
-                  CL_Sizef(sprite.get_width(), sprite.get_height()));  
-}
-
-void
-ObjMapSpriteObject::flip_vertical()
-{
-  float scale_x, scale_y;
-
-  impl-&gt;sprite.get_scale(scale_x, scale_y);
-  impl-&gt;sprite.set_scale(scale_x, -scale_y);
-  if (scale_y &lt; 0)
-    impl-&gt;pos.y -= impl-&gt;sprite.get_height();
-  else
-    impl-&gt;pos.y += impl-&gt;sprite.get_height();
-}
-
-void
-ObjMapSpriteObject::flip_horizontal()
-{
-  float scale_x, scale_y;
-  impl-&gt;sprite.get_scale(scale_x, scale_y);
-  impl-&gt;sprite.set_scale(-scale_x, scale_y);
-  if (scale_x &lt; 0)
-    impl-&gt;pos.x -= impl-&gt;sprite.get_width();
-  else
-    impl-&gt;pos.x += impl-&gt;sprite.get_width();
-}
-
-void
-ObjMapSpriteObject::set_sprite(const CL_Sprite&amp; sprite)
-{
-  impl-&gt;sprite = sprite;
-}
-
-void
-ObjMapSpriteObject::set_rotate(float angle)
-{
-  impl-&gt;sprite.set_angle(angle);
-}
-
-ObjMapObject
-ObjMapSpriteObject::to_object()
-{
-  return ObjMapObject(SharedPtr&lt;ObjMapObjectImpl&gt;(impl));
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/objmap_sprite_object.hpp (from rev 712, trunk/flexlay/lib/objmap_sprite_object.hxx)
===================================================================
--- trunk/flexlay/lib/objmap_sprite_object.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_sprite_object.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,51 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_OBJMAP_SPRITE_OBJECT_HXX
+#define HEADER_OBJMAP_SPRITE_OBJECT_HXX
+
+#include &lt;ClanLib/Display/sprite.h&gt;
+#include &lt;ClanLib/Core/Math/point.h&gt;
+#include &quot;shared_ptr.hpp&quot;
+#include &quot;meta_data.hpp&quot;
+#include &quot;objmap_object.hpp&quot;
+
+class ObjMapSpriteObjectImpl;
+
+/** */
+class ObjMapSpriteObject
+{
+public:
+  ObjMapSpriteObject();
+  ObjMapSpriteObject(const CL_Sprite&amp; s,
+                     const CL_Pointf&amp; pos_, 
+                     const MetaData&amp; data_);
+
+  void set_rotate(float angle);
+  void flip_horizontal();
+  void flip_vertical();
+  void set_sprite(const CL_Sprite&amp; s);
+  
+  ObjMapObject to_object();
+private:
+  SharedPtr&lt;ObjMapSpriteObjectImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/objmap_sprite_object.hxx
===================================================================
--- trunk/flexlay/lib/objmap_sprite_object.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_sprite_object.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,51 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_OBJMAP_SPRITE_OBJECT_HXX
-#define HEADER_OBJMAP_SPRITE_OBJECT_HXX
-
-#include &lt;ClanLib/Display/sprite.h&gt;
-#include &lt;ClanLib/Core/Math/point.h&gt;
-#include &quot;shared_ptr.hxx&quot;
-#include &quot;meta_data.hxx&quot;
-#include &quot;objmap_object.hxx&quot;
-
-class ObjMapSpriteObjectImpl;
-
-/** */
-class ObjMapSpriteObject
-{
-public:
-  ObjMapSpriteObject();
-  ObjMapSpriteObject(const CL_Sprite&amp; s,
-                     const CL_Pointf&amp; pos_, 
-                     const MetaData&amp; data_);
-
-  void set_rotate(float angle);
-  void flip_horizontal();
-  void flip_vertical();
-  void set_sprite(const CL_Sprite&amp; s);
-  
-  ObjMapObject to_object();
-private:
-  SharedPtr&lt;ObjMapSpriteObjectImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/onion_skin_layer.cpp (from rev 712, trunk/flexlay/lib/onion_skin_layer.cxx)
===================================================================
--- trunk/flexlay/lib/onion_skin_layer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/onion_skin_layer.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,131 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &lt;vector&gt;
+#include &lt;ClanLib/Core/System/error.h&gt;
+#include &lt;ClanLib/Display/pixel_buffer.h&gt;
+#include &lt;ClanLib/Display/pixel_format.h&gt;
+#include &lt;ClanLib/Display/surface.h&gt;
+#include &lt;ClanLib/Display/canvas.h&gt;
+#include &quot;editor_map_component.hpp&quot;
+#include &quot;layer_impl.hpp&quot;
+#include &quot;onion_skin_layer.hpp&quot;
+
+#define SCALE 4
+
+class OnionSkinLayerImpl : public LayerImpl
+{
+public:
+  CL_Surface  surface;
+  CL_Canvas*  canvas;
+
+  CL_Surface  surface2;
+  CL_Canvas*  canvas2;
+
+  std::vector&lt;EditorMap&gt; editormaps;
+  std::vector&lt;CL_Color&gt;  color;
+
+  void draw(EditorMapComponent* parent, CL_GraphicContext* gc) 
+  {
+    // FIXME: We need to stop onion layer to draw onto itself
+    surface.set_blend_func(blend_one, blend_one_minus_src_alpha);
+    surface.set_scale(SCALE, SCALE);
+    surface.draw(0, 0);
+  }
+
+  bool has_bounding_rect() const
+  {
+    return false;
+  }
+};
+
+OnionSkinLayer::OnionSkinLayer(Layer layer)
+  : impl(dynamic_cast&lt;OnionSkinLayerImpl*&gt;(layer.impl.get())) // FIXME: WONT WORK WITH REAL SMARTPTR!!!
+{
+}
+
+OnionSkinLayer::OnionSkinLayer(int width, int height)
+  : impl(new OnionSkinLayerImpl())
+{
+  impl-&gt;surface  = CL_Surface(CL_PixelBuffer(width/SCALE, height/SCALE, width*4/SCALE, CL_PixelFormat::rgba8888));
+  impl-&gt;surface2 = CL_Surface(CL_PixelBuffer(width/SCALE, height/SCALE, width*4/SCALE, CL_PixelFormat::rgba8888));
+
+  try
+    {
+      impl-&gt;canvas = new CL_Canvas(impl-&gt;surface);
+      impl-&gt;canvas-&gt;get_gc()-&gt;clear(CL_Color(0, 0, 0, 0));
+      impl-&gt;canvas-&gt;get_gc()-&gt;flush();
+      impl-&gt;canvas-&gt;sync_surface();
+
+      impl-&gt;canvas2 = new CL_Canvas(impl-&gt;surface2);
+      impl-&gt;canvas2-&gt;get_gc()-&gt;clear(CL_Color(0, 0, 0, 0));
+      impl-&gt;canvas2-&gt;get_gc()-&gt;flush();
+      impl-&gt;canvas2-&gt;sync_surface();
+    }
+  catch(CL_Error&amp; err) 
+    {
+      std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
+      throw err;
+    }
+}
+
+void
+OnionSkinLayer::clear()
+{
+  impl-&gt;canvas-&gt;get_gc()-&gt;clear(CL_Color(0, 0, 0, 0));
+  impl-&gt;canvas-&gt;sync_surface();
+}
+
+void
+OnionSkinLayer::add_map(EditorMap editor_map, const CL_Color&amp; color)
+{
+  impl-&gt;editormaps.push_back(editor_map);
+  impl-&gt;color.push_back(color);
+}
+
+void
+OnionSkinLayer::update()
+{
+  impl-&gt;canvas-&gt;get_gc()-&gt;clear(CL_Color(0, 0, 0, 0));
+  for (std::vector&lt;EditorMap&gt;::size_type i = 0; i &lt; impl-&gt;editormaps.size(); ++i)
+    {
+      impl-&gt;canvas2-&gt;get_gc()-&gt;clear(CL_Color(0, 0, 0, 0));
+      impl-&gt;canvas2-&gt;get_gc()-&gt;push_modelview();
+      impl-&gt;canvas2-&gt;get_gc()-&gt;add_scale(1.0f/SCALE, 1.0f/SCALE);
+
+      impl-&gt;editormaps[i].draw(EditorMapComponent::current(), impl-&gt;canvas2-&gt;get_gc());
+
+      impl-&gt;canvas2-&gt;get_gc()-&gt;pop_modelview();
+
+      impl-&gt;canvas2-&gt;sync_surface();
+
+      impl-&gt;surface2.set_color(impl-&gt;color[i]);
+      impl-&gt;surface2.draw(0, 0, impl-&gt;canvas-&gt;get_gc());
+      impl-&gt;canvas-&gt;sync_surface();
+    }
+}
+
+Layer
+OnionSkinLayer::to_layer()
+{
+  return Layer(impl);
+}
+
+/* EOF */
+

Deleted: trunk/flexlay/lib/onion_skin_layer.cxx
===================================================================
--- trunk/flexlay/lib/onion_skin_layer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/onion_skin_layer.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,131 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &lt;vector&gt;
-#include &lt;ClanLib/Core/System/error.h&gt;
-#include &lt;ClanLib/Display/pixel_buffer.h&gt;
-#include &lt;ClanLib/Display/pixel_format.h&gt;
-#include &lt;ClanLib/Display/surface.h&gt;
-#include &lt;ClanLib/Display/canvas.h&gt;
-#include &quot;editor_map_component.hxx&quot;
-#include &quot;layer_impl.hxx&quot;
-#include &quot;onion_skin_layer.hxx&quot;
-
-#define SCALE 4
-
-class OnionSkinLayerImpl : public LayerImpl
-{
-public:
-  CL_Surface  surface;
-  CL_Canvas*  canvas;
-
-  CL_Surface  surface2;
-  CL_Canvas*  canvas2;
-
-  std::vector&lt;EditorMap&gt; editormaps;
-  std::vector&lt;CL_Color&gt;  color;
-
-  void draw(EditorMapComponent* parent, CL_GraphicContext* gc) 
-  {
-    // FIXME: We need to stop onion layer to draw onto itself
-    surface.set_blend_func(blend_one, blend_one_minus_src_alpha);
-    surface.set_scale(SCALE, SCALE);
-    surface.draw(0, 0);
-  }
-
-  bool has_bounding_rect() const
-  {
-    return false;
-  }
-};
-
-OnionSkinLayer::OnionSkinLayer(Layer layer)
-  : impl(dynamic_cast&lt;OnionSkinLayerImpl*&gt;(layer.impl.get())) // FIXME: WONT WORK WITH REAL SMARTPTR!!!
-{
-}
-
-OnionSkinLayer::OnionSkinLayer(int width, int height)
-  : impl(new OnionSkinLayerImpl())
-{
-  impl-&gt;surface  = CL_Surface(CL_PixelBuffer(width/SCALE, height/SCALE, width*4/SCALE, CL_PixelFormat::rgba8888));
-  impl-&gt;surface2 = CL_Surface(CL_PixelBuffer(width/SCALE, height/SCALE, width*4/SCALE, CL_PixelFormat::rgba8888));
-
-  try
-    {
-      impl-&gt;canvas = new CL_Canvas(impl-&gt;surface);
-      impl-&gt;canvas-&gt;get_gc()-&gt;clear(CL_Color(0, 0, 0, 0));
-      impl-&gt;canvas-&gt;get_gc()-&gt;flush();
-      impl-&gt;canvas-&gt;sync_surface();
-
-      impl-&gt;canvas2 = new CL_Canvas(impl-&gt;surface2);
-      impl-&gt;canvas2-&gt;get_gc()-&gt;clear(CL_Color(0, 0, 0, 0));
-      impl-&gt;canvas2-&gt;get_gc()-&gt;flush();
-      impl-&gt;canvas2-&gt;sync_surface();
-    }
-  catch(CL_Error&amp; err) 
-    {
-      std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
-      throw err;
-    }
-}
-
-void
-OnionSkinLayer::clear()
-{
-  impl-&gt;canvas-&gt;get_gc()-&gt;clear(CL_Color(0, 0, 0, 0));
-  impl-&gt;canvas-&gt;sync_surface();
-}
-
-void
-OnionSkinLayer::add_map(EditorMap editor_map, const CL_Color&amp; color)
-{
-  impl-&gt;editormaps.push_back(editor_map);
-  impl-&gt;color.push_back(color);
-}
-
-void
-OnionSkinLayer::update()
-{
-  impl-&gt;canvas-&gt;get_gc()-&gt;clear(CL_Color(0, 0, 0, 0));
-  for (std::vector&lt;EditorMap&gt;::size_type i = 0; i &lt; impl-&gt;editormaps.size(); ++i)
-    {
-      impl-&gt;canvas2-&gt;get_gc()-&gt;clear(CL_Color(0, 0, 0, 0));
-      impl-&gt;canvas2-&gt;get_gc()-&gt;push_modelview();
-      impl-&gt;canvas2-&gt;get_gc()-&gt;add_scale(1.0f/SCALE, 1.0f/SCALE);
-
-      impl-&gt;editormaps[i].draw(EditorMapComponent::current(), impl-&gt;canvas2-&gt;get_gc());
-
-      impl-&gt;canvas2-&gt;get_gc()-&gt;pop_modelview();
-
-      impl-&gt;canvas2-&gt;sync_surface();
-
-      impl-&gt;surface2.set_color(impl-&gt;color[i]);
-      impl-&gt;surface2.draw(0, 0, impl-&gt;canvas-&gt;get_gc());
-      impl-&gt;canvas-&gt;sync_surface();
-    }
-}
-
-Layer
-OnionSkinLayer::to_layer()
-{
-  return Layer(impl);
-}
-
-/* EOF */
-

Copied: trunk/flexlay/lib/onion_skin_layer.hpp (from rev 712, trunk/flexlay/lib/onion_skin_layer.hxx)
===================================================================
--- trunk/flexlay/lib/onion_skin_layer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/onion_skin_layer.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,56 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_ONION_SKIN_LAYER_HXX
+#define HEADER_ONION_SKIN_LAYER_HXX
+
+#include &quot;editor_map.hpp&quot;
+
+class OnionSkinLayerImpl;
+
+/** The OnionSkinLayer is used to render one or multiple EditorMap
+    renderings in a transparent fashion onto another EditorMap. This
+    is usefull for animation programms and the like where one might
+    need to see the previous or next frames together with the current
+    frame. Might also be usefull for games which have shadow worlds,
+    which reassamble the normal world in a darker fashion. */
+class OnionSkinLayer
+{
+public:
+  /** FIXME: Should probally be CL_Rect instead of just
+      width/height */
+  OnionSkinLayer(int width, int height);
+  OnionSkinLayer(Layer layer);
+  
+  /** Adds an EditorMap to the OnionSkin */
+  void add_map(EditorMap editor_map, const CL_Color&amp; color);
+
+  void clear();
+
+  /** Refreshes the content of the OnionSkin */
+  void update();
+  
+  bool is_null() const { return !impl.get(); }
+  Layer to_layer();
+private:
+  SharedPtr&lt;OnionSkinLayerImpl&gt; impl;  
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/onion_skin_layer.hxx
===================================================================
--- trunk/flexlay/lib/onion_skin_layer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/onion_skin_layer.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,56 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_ONION_SKIN_LAYER_HXX
-#define HEADER_ONION_SKIN_LAYER_HXX
-
-#include &quot;editor_map.hxx&quot;
-
-class OnionSkinLayerImpl;
-
-/** The OnionSkinLayer is used to render one or multiple EditorMap
-    renderings in a transparent fashion onto another EditorMap. This
-    is usefull for animation programms and the like where one might
-    need to see the previous or next frames together with the current
-    frame. Might also be usefull for games which have shadow worlds,
-    which reassamble the normal world in a darker fashion. */
-class OnionSkinLayer
-{
-public:
-  /** FIXME: Should probally be CL_Rect instead of just
-      width/height */
-  OnionSkinLayer(int width, int height);
-  OnionSkinLayer(Layer layer);
-  
-  /** Adds an EditorMap to the OnionSkin */
-  void add_map(EditorMap editor_map, const CL_Color&amp; color);
-
-  void clear();
-
-  /** Refreshes the content of the OnionSkin */
-  void update();
-  
-  bool is_null() const { return !impl.get(); }
-  Layer to_layer();
-private:
-  SharedPtr&lt;OnionSkinLayerImpl&gt; impl;  
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/paint_command.cpp (from rev 712, trunk/flexlay/lib/paint_command.cxx)
===================================================================
--- trunk/flexlay/lib/paint_command.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/paint_command.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,149 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;assert.h&gt;
+#include &lt;iostream&gt;
+#include &lt;sstream&gt;
+#include &lt;vector&gt;
+#include &lt;ClanLib/Core/core_iostream.h&gt;
+#include &lt;ClanLib/Core/Math/rect.h&gt;
+#include &quot;field.hpp&quot;
+#include &quot;tilemap_layer.hpp&quot;
+#include &quot;paint_command.hpp&quot;
+
+class PaintCommandImpl : public CommandImpl
+{
+public:
+  typedef std::vector&lt;CL_Point&gt; Points;
+  Points points;
+  
+  TilemapLayer tilemap;
+  TileBrush    brush;
+
+  /** Copy of the field used to generate undo informations */
+  Field&lt;int&gt;   undo_field;
+
+  CL_Point     pos;
+  TileBrush*   redo_brush;
+  TileBrush*   undo_brush;
+
+  PaintCommandImpl() {}
+  virtual ~PaintCommandImpl() {}
+
+  void execute();
+  
+  void redo();
+  void undo();
+
+  std::string serialize();
+};
+
+PaintCommand::PaintCommand(TilemapLayer t, const TileBrush&amp; b)
+  : impl(new PaintCommandImpl())
+{  
+  impl-&gt;tilemap = t;
+  impl-&gt;brush   = b;
+
+  impl-&gt;undo_field = *(impl-&gt;tilemap.get_field());
+
+  impl-&gt;redo_brush = 0;
+  impl-&gt;undo_brush = 0;
+}
+
+PaintCommand::~PaintCommand()
+{
+  delete impl-&gt;redo_brush;
+  delete impl-&gt;undo_brush;
+}
+
+void
+PaintCommand::add_point(const CL_Point&amp; pos)
+{
+  // FIXME: undo_field is unneeded, should just record the overwritten color
+  impl-&gt;points.push_back(pos);
+  impl-&gt;tilemap.draw_tile(impl-&gt;brush, pos);
+}
+
+void
+PaintCommandImpl::execute()
+{
+  assert(!points.empty());
+  
+  // Calc bounding rect
+  CL_Rect rect(points.front().x, 
+               points.front().y, 
+               points.front().x + brush.get_width(),
+               points.front().y + brush.get_height());
+
+  for(PaintCommandImpl::Points::iterator i = points.begin(); i != points.end(); ++i)
+    {
+      rect.left   = std::min(rect.left,   (*i).x);
+      rect.top    = std::min(rect.top,    (*i).y);
+      rect.right  = std::max(rect.right,  (*i).x + brush.get_width());
+      rect.bottom = std::max(rect.bottom, (*i).y + brush.get_height());
+    }
+  
+  pos.x = rect.left;
+  pos.y = rect.top;
+
+  redo_brush = new TileBrush(*(tilemap.get_field()), rect.get_width(), rect.get_height(),
+                             -pos.x, -pos.y);
+  // FIXME: undo_field is unneeded, should just record the overwritten color
+  undo_brush = new TileBrush(undo_field, rect.get_width(), rect.get_height(), 
+                             -pos.x, -pos.y);
+  
+  redo_brush-&gt;set_opaque();
+  undo_brush-&gt;set_opaque();
+
+  undo_field.clear();
+}
+
+void
+PaintCommandImpl::redo()
+{
+  TilemapLayer::draw_tiles(tilemap.get_field(), *redo_brush, pos);
+}
+
+void
+PaintCommandImpl::undo()
+{
+  TilemapLayer::draw_tiles(tilemap.get_field(), *undo_brush, pos);
+}
+
+std::string
+PaintCommandImpl::serialize()
+{
+  std::stringstream s;
+
+  s &lt;&lt; &quot;_ = PaintCommand(&quot; &lt;&lt; &amp;tilemap &lt;&lt; &quot;, &quot; &lt;&lt; &amp;brush &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
+  for(PaintCommandImpl::Points::iterator i = points.begin(); i != points.end(); ++i)
+    {
+      s &lt;&lt; &quot;_.add_paint(&quot; &lt;&lt; i-&gt;x &lt;&lt; &quot;, &quot; &lt;&lt; i-&gt;y &lt;&lt; &quot;)&quot;  &lt;&lt; std::endl;
+    }
+  s &lt;&lt; &quot;_ = None&quot; &lt;&lt; std::endl;
+
+  return s.str();
+}
+
+Command
+PaintCommand::to_command()
+{
+  return Command(impl);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/paint_command.cxx
===================================================================
--- trunk/flexlay/lib/paint_command.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/paint_command.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,149 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;assert.h&gt;
-#include &lt;iostream&gt;
-#include &lt;sstream&gt;
-#include &lt;vector&gt;
-#include &lt;ClanLib/Core/core_iostream.h&gt;
-#include &lt;ClanLib/Core/Math/rect.h&gt;
-#include &quot;field.hxx&quot;
-#include &quot;tilemap_layer.hxx&quot;
-#include &quot;paint_command.hxx&quot;
-
-class PaintCommandImpl : public CommandImpl
-{
-public:
-  typedef std::vector&lt;CL_Point&gt; Points;
-  Points points;
-  
-  TilemapLayer tilemap;
-  TileBrush    brush;
-
-  /** Copy of the field used to generate undo informations */
-  Field&lt;int&gt;   undo_field;
-
-  CL_Point     pos;
-  TileBrush*   redo_brush;
-  TileBrush*   undo_brush;
-
-  PaintCommandImpl() {}
-  virtual ~PaintCommandImpl() {}
-
-  void execute();
-  
-  void redo();
-  void undo();
-
-  std::string serialize();
-};
-
-PaintCommand::PaintCommand(TilemapLayer t, const TileBrush&amp; b)
-  : impl(new PaintCommandImpl())
-{  
-  impl-&gt;tilemap = t;
-  impl-&gt;brush   = b;
-
-  impl-&gt;undo_field = *(impl-&gt;tilemap.get_field());
-
-  impl-&gt;redo_brush = 0;
-  impl-&gt;undo_brush = 0;
-}
-
-PaintCommand::~PaintCommand()
-{
-  delete impl-&gt;redo_brush;
-  delete impl-&gt;undo_brush;
-}
-
-void
-PaintCommand::add_point(const CL_Point&amp; pos)
-{
-  // FIXME: undo_field is unneeded, should just record the overwritten color
-  impl-&gt;points.push_back(pos);
-  impl-&gt;tilemap.draw_tile(impl-&gt;brush, pos);
-}
-
-void
-PaintCommandImpl::execute()
-{
-  assert(!points.empty());
-  
-  // Calc bounding rect
-  CL_Rect rect(points.front().x, 
-               points.front().y, 
-               points.front().x + brush.get_width(),
-               points.front().y + brush.get_height());
-
-  for(PaintCommandImpl::Points::iterator i = points.begin(); i != points.end(); ++i)
-    {
-      rect.left   = std::min(rect.left,   (*i).x);
-      rect.top    = std::min(rect.top,    (*i).y);
-      rect.right  = std::max(rect.right,  (*i).x + brush.get_width());
-      rect.bottom = std::max(rect.bottom, (*i).y + brush.get_height());
-    }
-  
-  pos.x = rect.left;
-  pos.y = rect.top;
-
-  redo_brush = new TileBrush(*(tilemap.get_field()), rect.get_width(), rect.get_height(),
-                             -pos.x, -pos.y);
-  // FIXME: undo_field is unneeded, should just record the overwritten color
-  undo_brush = new TileBrush(undo_field, rect.get_width(), rect.get_height(), 
-                             -pos.x, -pos.y);
-  
-  redo_brush-&gt;set_opaque();
-  undo_brush-&gt;set_opaque();
-
-  undo_field.clear();
-}
-
-void
-PaintCommandImpl::redo()
-{
-  TilemapLayer::draw_tiles(tilemap.get_field(), *redo_brush, pos);
-}
-
-void
-PaintCommandImpl::undo()
-{
-  TilemapLayer::draw_tiles(tilemap.get_field(), *undo_brush, pos);
-}
-
-std::string
-PaintCommandImpl::serialize()
-{
-  std::stringstream s;
-
-  s &lt;&lt; &quot;_ = PaintCommand(&quot; &lt;&lt; &amp;tilemap &lt;&lt; &quot;, &quot; &lt;&lt; &amp;brush &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
-  for(PaintCommandImpl::Points::iterator i = points.begin(); i != points.end(); ++i)
-    {
-      s &lt;&lt; &quot;_.add_paint(&quot; &lt;&lt; i-&gt;x &lt;&lt; &quot;, &quot; &lt;&lt; i-&gt;y &lt;&lt; &quot;)&quot;  &lt;&lt; std::endl;
-    }
-  s &lt;&lt; &quot;_ = None&quot; &lt;&lt; std::endl;
-
-  return s.str();
-}
-
-Command
-PaintCommand::to_command()
-{
-  return Command(impl);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/paint_command.hpp (from rev 712, trunk/flexlay/lib/paint_command.hxx)
===================================================================
--- trunk/flexlay/lib/paint_command.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/paint_command.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,49 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_PAINT_COMMAND_HXX
+#define HEADER_PAINT_COMMAND_HXX
+
+#include &lt;ClanLib/Core/Math/point.h&gt;
+#include &quot;tile_brush.hpp&quot;
+#include &quot;shared_ptr.hpp&quot;
+#include &quot;tilemap_layer.hpp&quot;
+#include &quot;command.hpp&quot;
+
+class PaintCommandImpl;
+
+/** The PaintCommand provides functionality to draw onto an TileMap.
+    The user needs to supply a brush and a map to draw to and the
+    points to which should be drawn, undo, redo and the internals of
+    drawing are handled by the PaintCommand itself. */
+class PaintCommand
+{
+public:
+  PaintCommand(TilemapLayer t, const TileBrush&amp; b);
+  ~PaintCommand();
+  
+  void add_point(const CL_Point&amp; pos);
+
+  Command to_command();
+private:
+  SharedPtr&lt;PaintCommandImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/paint_command.hxx
===================================================================
--- trunk/flexlay/lib/paint_command.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/paint_command.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,49 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_PAINT_COMMAND_HXX
-#define HEADER_PAINT_COMMAND_HXX
-
-#include &lt;ClanLib/Core/Math/point.h&gt;
-#include &quot;tile_brush.hxx&quot;
-#include &quot;shared_ptr.hxx&quot;
-#include &quot;tilemap_layer.hxx&quot;
-#include &quot;command.hxx&quot;
-
-class PaintCommandImpl;
-
-/** The PaintCommand provides functionality to draw onto an TileMap.
-    The user needs to supply a brush and a map to draw to and the
-    points to which should be drawn, undo, redo and the internals of
-    drawing are handled by the PaintCommand itself. */
-class PaintCommand
-{
-public:
-  PaintCommand(TilemapLayer t, const TileBrush&amp; b);
-  ~PaintCommand();
-  
-  void add_point(const CL_Point&amp; pos);
-
-  Command to_command();
-private:
-  SharedPtr&lt;PaintCommandImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/paned.cpp (from rev 712, trunk/flexlay/lib/paned.cxx)
===================================================================
--- trunk/flexlay/lib/paned.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/paned.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,47 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &quot;paned.hpp&quot;
+
+class PanedImpl
+{
+public:
+  CL_Component* first;
+  CL_Component* second;
+};
+
+Paned::Paned(CL_Component* parent)
+  : impl(new PanedImpl())
+{
+  impl-&gt;first  = 0;
+  impl-&gt;second = 0;
+}
+
+void
+Paned::set_first(CL_Component* first)
+{
+  impl-&gt;first = first;
+}
+
+void
+Paned::set_second(CL_Component* second)
+{
+  impl-&gt;second = second;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/paned.cxx
===================================================================
--- trunk/flexlay/lib/paned.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/paned.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,47 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &quot;paned.hxx&quot;
-
-class PanedImpl
-{
-public:
-  CL_Component* first;
-  CL_Component* second;
-};
-
-Paned::Paned(CL_Component* parent)
-  : impl(new PanedImpl())
-{
-  impl-&gt;first  = 0;
-  impl-&gt;second = 0;
-}
-
-void
-Paned::set_first(CL_Component* first)
-{
-  impl-&gt;first = first;
-}
-
-void
-Paned::set_second(CL_Component* second)
-{
-  impl-&gt;second = second;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/paned.hpp (from rev 712, trunk/flexlay/lib/paned.hxx)

Deleted: trunk/flexlay/lib/paned.hxx
===================================================================
--- trunk/flexlay/lib/paned.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/paned.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,38 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_PANED_HXX
-#define HEADER_PANED_HXX
-
-/** */
-class Paned : public CL_Component
-{
-protected:
-  virtual Paned() {}
-public:
-  Paned(CL_Component* parent);
-  
-  void set_first(CL_Component* );
-  void set_second(CL_Component* );
-private:
-  SharedPtr&lt;PanedImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/panel.cpp (from rev 712, trunk/flexlay/lib/panel.cxx)
===================================================================
--- trunk/flexlay/lib/panel.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/panel.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,50 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;vector&gt;
+#include &lt;ClanLib/Signals/slot.h&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &quot;box.hpp&quot;
+#include &quot;panel.hpp&quot;
+
+class PanelImpl
+{
+public:
+  std::vector&lt;CL_Slot&gt; slots;
+  CL_Component* parent;
+
+  void draw();
+};
+
+Panel::Panel(const CL_Rect&amp; rect, CL_Component* parent)
+  : CL_Component(rect, parent), impl(new PanelImpl())
+{
+  impl-&gt;parent = this;
+  impl-&gt;slots.push_back(sig_paint().connect(impl.get(), &amp;PanelImpl::draw));
+}
+
+void
+PanelImpl::draw()
+{
+  CL_Display::push_translate(parent-&gt;get_screen_x(), parent-&gt;get_screen_y());
+  CL_Rect rect = parent-&gt;get_position();
+  Box::draw_panel(CL_Rect(CL_Point(0, 0), CL_Size(rect.get_width()-1, rect.get_height()-1)));
+  CL_Display::pop_modelview();
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/panel.cxx
===================================================================
--- trunk/flexlay/lib/panel.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/panel.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,50 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;vector&gt;
-#include &lt;ClanLib/Signals/slot.h&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-#include &quot;box.hxx&quot;
-#include &quot;panel.hxx&quot;
-
-class PanelImpl
-{
-public:
-  std::vector&lt;CL_Slot&gt; slots;
-  CL_Component* parent;
-
-  void draw();
-};
-
-Panel::Panel(const CL_Rect&amp; rect, CL_Component* parent)
-  : CL_Component(rect, parent), impl(new PanelImpl())
-{
-  impl-&gt;parent = this;
-  impl-&gt;slots.push_back(sig_paint().connect(impl.get(), &amp;PanelImpl::draw));
-}
-
-void
-PanelImpl::draw()
-{
-  CL_Display::push_translate(parent-&gt;get_screen_x(), parent-&gt;get_screen_y());
-  CL_Rect rect = parent-&gt;get_position();
-  Box::draw_panel(CL_Rect(CL_Point(0, 0), CL_Size(rect.get_width()-1, rect.get_height()-1)));
-  CL_Display::pop_modelview();
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/panel.hpp (from rev 712, trunk/flexlay/lib/panel.hxx)
===================================================================
--- trunk/flexlay/lib/panel.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/panel.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,39 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_PANEL_HXX
+#define HEADER_PANEL_HXX
+
+#include &lt;ClanLib/GUI/component.h&gt;
+#include &lt;ClanLib/Core/Math/rect.h&gt;
+#include &quot;shared_ptr.hpp&quot;
+
+class PanelImpl;
+
+/** */
+class Panel : public CL_Component
+{
+public:
+  Panel(const CL_Rect&amp; rect, CL_Component* parent);
+private:
+  SharedPtr&lt;PanelImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/panel.hxx
===================================================================
--- trunk/flexlay/lib/panel.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/panel.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,39 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_PANEL_HXX
-#define HEADER_PANEL_HXX
-
-#include &lt;ClanLib/GUI/component.h&gt;
-#include &lt;ClanLib/Core/Math/rect.h&gt;
-#include &quot;shared_ptr.hxx&quot;
-
-class PanelImpl;
-
-/** */
-class Panel : public CL_Component
-{
-public:
-  Panel(const CL_Rect&amp; rect, CL_Component* parent);
-private:
-  SharedPtr&lt;PanelImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/popup_menu.cpp (from rev 712, trunk/flexlay/lib/popup_menu.cxx)
===================================================================
--- trunk/flexlay/lib/popup_menu.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/popup_menu.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,55 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &lt;ClanLib/Display/mouse.h&gt;
+#include &quot;popup_menu.hpp&quot;
+
+PopupMenu::PopupMenu(const CL_Point&amp; pos,  CL_Component* parent)
+{
+  menu = new CL_Menu(CL_Point(pos.x, pos.y), parent, NULL, true);
+  
+  menu-&gt;open();
+  
+  slots.push_back(CL_Mouse::sig_key_down().connect(this, &amp;PopupMenu::on_mouse_up));
+}
+
+PopupMenu::~PopupMenu()
+{
+  //menu-&gt;release_mouse();
+  delete menu;
+}
+
+void
+PopupMenu::on_mouse_up(const CL_InputEvent&amp; event)
+{
+  if (!menu-&gt;has_mouse_over() &amp;&amp; !menu-&gt;has_mouse_in_submenus())
+    {
+      menu-&gt;collapse();
+      // FIXME: *yuck*
+      delete this;
+    }
+  else
+    {
+      // FIXME: this should be in the constructor, but doesn't work
+      // there since the menu collapses then instantly
+      menu-&gt;set_root_collapsing(true); 
+    }
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/popup_menu.cxx
===================================================================
--- trunk/flexlay/lib/popup_menu.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/popup_menu.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,55 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &lt;ClanLib/Display/mouse.h&gt;
-#include &quot;popup_menu.hxx&quot;
-
-PopupMenu::PopupMenu(const CL_Point&amp; pos,  CL_Component* parent)
-{
-  menu = new CL_Menu(CL_Point(pos.x, pos.y), parent, NULL, true);
-  
-  menu-&gt;open();
-  
-  slots.push_back(CL_Mouse::sig_key_down().connect(this, &amp;PopupMenu::on_mouse_up));
-}
-
-PopupMenu::~PopupMenu()
-{
-  //menu-&gt;release_mouse();
-  delete menu;
-}
-
-void
-PopupMenu::on_mouse_up(const CL_InputEvent&amp; event)
-{
-  if (!menu-&gt;has_mouse_over() &amp;&amp; !menu-&gt;has_mouse_in_submenus())
-    {
-      menu-&gt;collapse();
-      // FIXME: *yuck*
-      delete this;
-    }
-  else
-    {
-      // FIXME: this should be in the constructor, but doesn't work
-      // there since the menu collapses then instantly
-      menu-&gt;set_root_collapsing(true); 
-    }
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/popup_menu.hpp (from rev 712, trunk/flexlay/lib/popup_menu.hxx)

Deleted: trunk/flexlay/lib/popup_menu.hxx
===================================================================
--- trunk/flexlay/lib/popup_menu.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/popup_menu.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,47 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_POPUP_MENU_HXX
-#define HEADER_POPUP_MENU_HXX
-
-#include &lt;vector&gt;
-#include &lt;ClanLib/Signals/slot.h&gt;
-#include &lt;ClanLib/GUI/component.h&gt;
-#include &lt;ClanLib/GUI/menu.h&gt;
-
-/** */
-class PopupMenu
-{
-private:
-  std::vector&lt;CL_Slot&gt; slots;
-  CL_Menu* menu;
-public:
-  PopupMenu(const CL_Point&amp; pos, CL_Component* parent);
-  ~PopupMenu();
-
-  CL_Menu* get_menu() { return menu; }
-
-  void on_mouse_up(const CL_InputEvent&amp; event);
-private:
-  PopupMenu (const PopupMenu&amp;);
-  PopupMenu&amp; operator= (const PopupMenu&amp;);
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/scrollbar.cpp (from rev 712, trunk/flexlay/lib/scrollbar.cxx)
===================================================================
--- trunk/flexlay/lib/scrollbar.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/scrollbar.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,180 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;ClanLib/Display/display.h&gt;
+#include &lt;ClanLib/Display/keys.h&gt;
+#include &quot;scrollbar.hpp&quot;
+
+class ScrollbarImpl
+{
+public:
+  std::vector&lt;CL_Slot&gt; slots;
+
+  ScrollbarImpl(Scrollbar* parent_) : parent(parent_) {}
+
+  Scrollbar* parent;
+  float min;
+  float max;
+  float pagesize;
+  float pos;
+  Scrollbar::Orientation orientation;
+
+  CL_Signal_v1&lt;float&gt; on_scrollbar_move;
+
+  float old_pos;
+  
+  bool pressed;
+  CL_Point click_pos;
+  
+  void draw();
+  void on_mouse_up(const CL_InputEvent&amp; event);
+  void on_mouse_down(const CL_InputEvent&amp; event);
+  void on_mouse_move(const CL_InputEvent&amp; event);
+};
+
+Scrollbar::Scrollbar(const CL_Rect&amp; rect, Orientation orientation, CL_Component* parent)
+  : CL_Component(rect, parent),
+    impl(new ScrollbarImpl(this))
+{
+  impl-&gt;min = 0;
+  impl-&gt;max = 100;
+  impl-&gt;pagesize = 10;
+  impl-&gt;pos  = 0;
+  impl-&gt;pressed = false;
+  impl-&gt;orientation = orientation;
+
+  impl-&gt;slots.push_back(sig_paint().connect(impl.get(), &amp;ScrollbarImpl::draw));
+
+  impl-&gt;slots.push_back(sig_mouse_down().connect(impl.get(), &amp;ScrollbarImpl::on_mouse_down));
+  impl-&gt;slots.push_back(sig_mouse_up().connect(impl.get(), &amp;ScrollbarImpl::on_mouse_up));
+  impl-&gt;slots.push_back(sig_mouse_move().connect(impl.get(), &amp;ScrollbarImpl::on_mouse_move));
+}
+  
+void
+Scrollbar::set_range(float min, float max)
+{
+  impl-&gt;min = min;
+  impl-&gt;max = max;
+}
+
+void
+Scrollbar::set_pagesize(float size)
+{
+  impl-&gt;pagesize = size;  
+}
+
+void
+Scrollbar::set_pos(float pos)
+{
+  impl-&gt;pos = pos;
+}
+
+void 
+ScrollbarImpl::draw()
+{
+  CL_Display::push_cliprect(parent-&gt;get_screen_rect());
+  CL_Display::push_translate(parent-&gt;get_screen_x(), parent-&gt;get_screen_y());
+
+  CL_Rect rect = CL_Rect(CL_Point(0, 0), 
+                         CL_Size(parent-&gt;get_width()-1,
+                                 parent-&gt;get_height()-1));
+  CL_Display::fill_rect(rect,
+                        CL_Color(255, 255, 255));
+
+  if (orientation == Scrollbar::HORIZONTAL)
+    {
+      float scale = parent-&gt;get_width()/(max - min);
+      CL_Display::fill_rect(CL_Rect(CL_Point(int((pos-min-(pagesize/2)) * scale), 2), 
+                                    CL_Size(int(pagesize*scale), 
+                                            parent-&gt;get_height()-5)),
+                            CL_Color(0, 0, 0));
+    }
+  else if (orientation == Scrollbar::VERTICAL)
+    {
+      float scale = parent-&gt;get_height()/(max - min);
+      CL_Display::fill_rect(CL_Rect(CL_Point(2, int((pos-min-(pagesize/2)) * scale)), 
+                                    CL_Size(parent-&gt;get_width()-5,
+                                            int(pagesize*scale))),
+                            CL_Color(0, 0, 0));     
+    }
+
+  CL_Display::draw_rect(rect,
+                        CL_Color(155, 155, 155));
+
+  CL_Display::pop_modelview();
+  CL_Display::pop_cliprect();
+}
+
+void
+ScrollbarImpl::on_mouse_up(const CL_InputEvent&amp; event)
+{
+  if (event.id == CL_MOUSE_LEFT)
+    {
+      pressed = false;
+      parent-&gt;release_mouse();
+    }
+}
+
+void
+ScrollbarImpl::on_mouse_down(const CL_InputEvent&amp; event)
+{
+  if (event.id == CL_MOUSE_LEFT)
+    {
+      pressed   = true;
+      click_pos = event.mouse_pos;
+      
+      parent-&gt;capture_mouse();
+
+      float scale = ((orientation == Scrollbar::VERTICAL)
+                     ? parent-&gt;get_height() : parent-&gt;get_width())/(max - min);
+      old_pos = pos * scale;
+
+      click_pos.x += parent-&gt;get_position().left;
+      click_pos.y += parent-&gt;get_position().top;
+    }
+}
+
+void
+ScrollbarImpl::on_mouse_move(const CL_InputEvent&amp; event)
+{
+  if(pressed)
+    {
+      CL_Rect rect = parent-&gt;get_position();
+      
+      float scale = ((orientation == Scrollbar::VERTICAL)
+                     ? parent-&gt;get_height() : parent-&gt;get_width())/(max - min);
+      
+      if (orientation == Scrollbar::VERTICAL)
+        {
+          pos = (old_pos - (click_pos.y - (rect.top + event.mouse_pos.y)))/scale;
+        }
+      else if (orientation == Scrollbar::HORIZONTAL)
+        {
+          pos = (old_pos - (click_pos.x - (rect.left + event.mouse_pos.x)))/scale;
+        }
+      on_scrollbar_move(pos);
+    }
+}
+
+CL_Signal_v1&lt;float&gt;&amp;
+Scrollbar::sig_scrollbar_move()
+{
+  return impl-&gt;on_scrollbar_move;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/scrollbar.cxx
===================================================================
--- trunk/flexlay/lib/scrollbar.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/scrollbar.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,180 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;ClanLib/Display/display.h&gt;
-#include &lt;ClanLib/Display/keys.h&gt;
-#include &quot;scrollbar.hxx&quot;
-
-class ScrollbarImpl
-{
-public:
-  std::vector&lt;CL_Slot&gt; slots;
-
-  ScrollbarImpl(Scrollbar* parent_) : parent(parent_) {}
-
-  Scrollbar* parent;
-  float min;
-  float max;
-  float pagesize;
-  float pos;
-  Scrollbar::Orientation orientation;
-
-  CL_Signal_v1&lt;float&gt; on_scrollbar_move;
-
-  float old_pos;
-  
-  bool pressed;
-  CL_Point click_pos;
-  
-  void draw();
-  void on_mouse_up(const CL_InputEvent&amp; event);
-  void on_mouse_down(const CL_InputEvent&amp; event);
-  void on_mouse_move(const CL_InputEvent&amp; event);
-};
-
-Scrollbar::Scrollbar(const CL_Rect&amp; rect, Orientation orientation, CL_Component* parent)
-  : CL_Component(rect, parent),
-    impl(new ScrollbarImpl(this))
-{
-  impl-&gt;min = 0;
-  impl-&gt;max = 100;
-  impl-&gt;pagesize = 10;
-  impl-&gt;pos  = 0;
-  impl-&gt;pressed = false;
-  impl-&gt;orientation = orientation;
-
-  impl-&gt;slots.push_back(sig_paint().connect(impl.get(), &amp;ScrollbarImpl::draw));
-
-  impl-&gt;slots.push_back(sig_mouse_down().connect(impl.get(), &amp;ScrollbarImpl::on_mouse_down));
-  impl-&gt;slots.push_back(sig_mouse_up().connect(impl.get(), &amp;ScrollbarImpl::on_mouse_up));
-  impl-&gt;slots.push_back(sig_mouse_move().connect(impl.get(), &amp;ScrollbarImpl::on_mouse_move));
-}
-  
-void
-Scrollbar::set_range(float min, float max)
-{
-  impl-&gt;min = min;
-  impl-&gt;max = max;
-}
-
-void
-Scrollbar::set_pagesize(float size)
-{
-  impl-&gt;pagesize = size;  
-}
-
-void
-Scrollbar::set_pos(float pos)
-{
-  impl-&gt;pos = pos;
-}
-
-void 
-ScrollbarImpl::draw()
-{
-  CL_Display::push_cliprect(parent-&gt;get_screen_rect());
-  CL_Display::push_translate(parent-&gt;get_screen_x(), parent-&gt;get_screen_y());
-
-  CL_Rect rect = CL_Rect(CL_Point(0, 0), 
-                         CL_Size(parent-&gt;get_width()-1,
-                                 parent-&gt;get_height()-1));
-  CL_Display::fill_rect(rect,
-                        CL_Color(255, 255, 255));
-
-  if (orientation == Scrollbar::HORIZONTAL)
-    {
-      float scale = parent-&gt;get_width()/(max - min);
-      CL_Display::fill_rect(CL_Rect(CL_Point(int((pos-min-(pagesize/2)) * scale), 2), 
-                                    CL_Size(int(pagesize*scale), 
-                                            parent-&gt;get_height()-5)),
-                            CL_Color(0, 0, 0));
-    }
-  else if (orientation == Scrollbar::VERTICAL)
-    {
-      float scale = parent-&gt;get_height()/(max - min);
-      CL_Display::fill_rect(CL_Rect(CL_Point(2, int((pos-min-(pagesize/2)) * scale)), 
-                                    CL_Size(parent-&gt;get_width()-5,
-                                            int(pagesize*scale))),
-                            CL_Color(0, 0, 0));     
-    }
-
-  CL_Display::draw_rect(rect,
-                        CL_Color(155, 155, 155));
-
-  CL_Display::pop_modelview();
-  CL_Display::pop_cliprect();
-}
-
-void
-ScrollbarImpl::on_mouse_up(const CL_InputEvent&amp; event)
-{
-  if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed = false;
-      parent-&gt;release_mouse();
-    }
-}
-
-void
-ScrollbarImpl::on_mouse_down(const CL_InputEvent&amp; event)
-{
-  if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed   = true;
-      click_pos = event.mouse_pos;
-      
-      parent-&gt;capture_mouse();
-
-      float scale = ((orientation == Scrollbar::VERTICAL)
-                     ? parent-&gt;get_height() : parent-&gt;get_width())/(max - min);
-      old_pos = pos * scale;
-
-      click_pos.x += parent-&gt;get_position().left;
-      click_pos.y += parent-&gt;get_position().top;
-    }
-}
-
-void
-ScrollbarImpl::on_mouse_move(const CL_InputEvent&amp; event)
-{
-  if(pressed)
-    {
-      CL_Rect rect = parent-&gt;get_position();
-      
-      float scale = ((orientation == Scrollbar::VERTICAL)
-                     ? parent-&gt;get_height() : parent-&gt;get_width())/(max - min);
-      
-      if (orientation == Scrollbar::VERTICAL)
-        {
-          pos = (old_pos - (click_pos.y - (rect.top + event.mouse_pos.y)))/scale;
-        }
-      else if (orientation == Scrollbar::HORIZONTAL)
-        {
-          pos = (old_pos - (click_pos.x - (rect.left + event.mouse_pos.x)))/scale;
-        }
-      on_scrollbar_move(pos);
-    }
-}
-
-CL_Signal_v1&lt;float&gt;&amp;
-Scrollbar::sig_scrollbar_move()
-{
-  return impl-&gt;on_scrollbar_move;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/scrollbar.hpp (from rev 712, trunk/flexlay/lib/scrollbar.hxx)
===================================================================
--- trunk/flexlay/lib/scrollbar.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/scrollbar.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,49 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_SCROLLBAR_HXX
+#define HEADER_SCROLLBAR_HXX
+
+#include &lt;ClanLib/GUI/component.h&gt;
+#include &lt;ClanLib/Core/Math/rect.h&gt;
+#include &quot;shared_ptr.hpp&quot;
+
+class ScrollbarImpl;
+
+/** */
+class Scrollbar : public CL_Component
+{
+protected:
+  virtual ~Scrollbar() {}
+public:
+  enum Orientation { HORIZONTAL, VERTICAL };
+
+  Scrollbar(const CL_Rect&amp; rect, Orientation orientation, CL_Component* parent);
+  
+  void set_range(float min, float max);
+  void set_pagesize(float size);
+  void set_pos(float pos);
+  
+  CL_Signal_v1&lt;float&gt;&amp; sig_scrollbar_move();
+private:
+  SharedPtr&lt;ScrollbarImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/scrollbar.hxx
===================================================================
--- trunk/flexlay/lib/scrollbar.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/scrollbar.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,49 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_SCROLLBAR_HXX
-#define HEADER_SCROLLBAR_HXX
-
-#include &lt;ClanLib/GUI/component.h&gt;
-#include &lt;ClanLib/Core/Math/rect.h&gt;
-#include &quot;shared_ptr.hxx&quot;
-
-class ScrollbarImpl;
-
-/** */
-class Scrollbar : public CL_Component
-{
-protected:
-  virtual ~Scrollbar() {}
-public:
-  enum Orientation { HORIZONTAL, VERTICAL };
-
-  Scrollbar(const CL_Rect&amp; rect, Orientation orientation, CL_Component* parent);
-  
-  void set_range(float min, float max);
-  void set_pagesize(float size);
-  void set_pos(float pos);
-  
-  CL_Signal_v1&lt;float&gt;&amp; sig_scrollbar_move();
-private:
-  SharedPtr&lt;ScrollbarImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/serializer.cpp (from rev 712, trunk/flexlay/lib/serializer.cxx)
===================================================================
--- trunk/flexlay/lib/serializer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/serializer.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,41 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &quot;serializer.hpp&quot;
+
+Serializer
+Serializer::register_group (const char* name)
+{
+}
+
+void
+Serializer::register_float (const char* name, float&amp; value)
+{
+}
+
+void
+Serializer::register_int   (const char* name, int&amp; value)
+{
+}
+
+void
+Serializer::register_string(const char* name, std::string&amp; value)
+{
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/serializer.cxx
===================================================================
--- trunk/flexlay/lib/serializer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/serializer.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,41 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &quot;serializer.hxx&quot;
-
-Serializer
-Serializer::register_group (const char* name)
-{
-}
-
-void
-Serializer::register_float (const char* name, float&amp; value)
-{
-}
-
-void
-Serializer::register_int   (const char* name, int&amp; value)
-{
-}
-
-void
-Serializer::register_string(const char* name, std::string&amp; value)
-{
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/serializer.hpp (from rev 712, trunk/flexlay/lib/serializer.hxx)

Deleted: trunk/flexlay/lib/serializer.hxx
===================================================================
--- trunk/flexlay/lib/serializer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/serializer.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,43 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_SERIALIZER_HXX
-#define HEADER_SERIALIZER_HXX
-
-/** */
-class Serializer
-{
-private:
-public:
-  Serializer() {}
-  
-  voi  register_group_start (const char* name) =0;
-  voi  register_group_end   () =0;
-
-  void register_float (const char* name, float&amp; value) =0;
-  void register_int   (const char* name, int&amp; value)   =0;
-  void register_string(const char* name, std::string&amp; value) =0;
-
-private:
-  Serializer (const Serializer&amp;);
-  Serializer&amp; operator= (const Serializer&amp;);
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/sexpr_serializer.cpp (from rev 712, trunk/flexlay/lib/sexpr_serializer.cxx)
===================================================================
--- trunk/flexlay/lib/sexpr_serializer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sexpr_serializer.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,52 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &quot;sexpr_serializer.hpp&quot;
+
+SexprSerializer::SexprSerializer() 
+{
+}
+  
+void
+SexprSerializer::register_group_start (const char* name)
+{
+  
+}
+
+void
+SexprSerializer::register_group_end   ()
+{
+}
+
+void
+SexprSerializer::register_float (const char* name, float&amp; value)
+{
+  
+}
+
+void
+SexprSerializer::register_int   (const char* name, int&amp; value)
+{
+}
+
+void
+SexprSerializer::register_string(const char* name, std::string&amp; value)
+{
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/sexpr_serializer.cxx
===================================================================
--- trunk/flexlay/lib/sexpr_serializer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sexpr_serializer.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,52 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &quot;sexpr_serializer.hxx&quot;
-
-SexprSerializer::SexprSerializer() 
-{
-}
-  
-void
-SexprSerializer::register_group_start (const char* name)
-{
-  
-}
-
-void
-SexprSerializer::register_group_end   ()
-{
-}
-
-void
-SexprSerializer::register_float (const char* name, float&amp; value)
-{
-  
-}
-
-void
-SexprSerializer::register_int   (const char* name, int&amp; value)
-{
-}
-
-void
-SexprSerializer::register_string(const char* name, std::string&amp; value)
-{
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/sexpr_serializer.hpp (from rev 712, trunk/flexlay/lib/sexpr_serializer.hxx)

Deleted: trunk/flexlay/lib/sexpr_serializer.hxx
===================================================================
--- trunk/flexlay/lib/sexpr_serializer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sexpr_serializer.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,43 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_SEXPR_SERIALIZER_HXX
-#define HEADER_SEXPR_SERIALIZER_HXX
-
-/** */
-class SexprSerializer
-{
-private:
-  
-public:
-  SexprSerializer() {}
-  
-  voi  register_group_start (const char* name);
-  voi  register_group_end   ();
-
-  void register_float (const char* name, float&amp; value);
-  void register_int   (const char* name, int&amp; value);
-  void register_string(const char* name, std::string&amp; value);
-
-  /** Return a string representing the serialized objects */
-  std::string get_string();
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/shared_ptr.hpp (from rev 712, trunk/flexlay/lib/shared_ptr.hxx)

Deleted: trunk/flexlay/lib/shared_ptr.hxx
===================================================================
--- trunk/flexlay/lib/shared_ptr.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/shared_ptr.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,50 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_SHARED_PTR_HXX
-#define HEADER_SHARED_PTR_HXX
-
-#include &lt;assert.h&gt;
-
-/** */
-template&lt;typename T&gt;
-class SharedPtr
-{
-private:
-  T* ptr;
-public:
-  template&lt;typename Parent&gt; friend class SharedPtr;
-
-  SharedPtr() : ptr(0) {}
-  SharedPtr(T* p) : ptr(p) {}
-  
-  template &lt;typename Parent&gt;
-  SharedPtr(const SharedPtr&lt;Parent&gt;&amp; p) : ptr(p.ptr) {}
-
-  T&amp; operator*() { assert(ptr); return *ptr; }
-  T const&amp; operator*() const { assert(ptr); return *ptr; }
-
-  T* operator-&gt;() { assert(ptr); return ptr; }
-  T const* operator-&gt;() const { assert(ptr); return ptr; }
-
-  T* get() const { return ptr; }
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/shared_ptr_comp.hpp (from rev 712, trunk/flexlay/lib/shared_ptr_comp.hxx)

Deleted: trunk/flexlay/lib/shared_ptr_comp.hxx
===================================================================
--- trunk/flexlay/lib/shared_ptr_comp.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/shared_ptr_comp.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,260 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_SHARED_PTR_HXX
-#define HEADER_SHARED_PTR_HXX
-
-#include &lt;iostream&gt;
-#include &lt;typeinfo&gt;
-
-template&lt;class T&gt;
-class SharedPtrDeleter
-{
-public:
-  T* ptr; 
-
-  SharedPtrDeleter(T* p) : ptr(p) {}
-  virtual ~SharedPtrDeleter() {}
-  
-  virtual void del() =0;
-};
-
-template&lt;class T&gt;
-class SharedPtrDeleterImpl : public SharedPtrDeleter&lt;T&gt;
-{
-public:
-  SharedPtrDeleterImpl(T* p)
-    : SharedPtrDeleter&lt;T&gt;(p) {}
-
-  ~SharedPtrDeleterImpl()
-  {
-  }  
-
-  void del() {
-    //if (ptr)
-    //  delete ptr;
-    ptr = 0;
-  }
-};
-
-template&lt;class T&gt;
-class SharedPtr
-{
-private:
-  SharedPtrDeleter&lt;T&gt;* deleter;
-  int* ref_count;
-
-  void inc() {
-#ifdef DEBUG
-    std::cout &lt;&lt; &quot;SharedPtr: inc: &quot; &lt;&lt; (ref_count ? *ref_count : -45) &lt;&lt; std::endl;
-#endif
-    if (ref_count)
-      {
-        *ref_count += 1;
-      }
-  }
-  
-  void dec() {
-#ifdef DEBUG
-    std::cout &lt;&lt; &quot;SharedPtr: dec: &quot; &lt;&lt; (ref_count ? *ref_count : -45) &lt;&lt; std::endl;
-#endif
-    if (ref_count)
-      {
-        *ref_count -= 1;
-        if (*ref_count == 0) {
-#ifdef DEBUG
-          std::cout &lt;&lt; &quot;SharedPtr: deleting: type: &quot;
-                    &lt;&lt; typeid(deleter-&gt;ptr).name()
-                    &lt;&lt; &quot; ptr: &quot; &lt;&lt; deleter-&gt;ptr
-                    &lt;&lt; std::endl;
-#endif
-          deleter-&gt;del();
-          
-          delete ref_count; ref_count = 0;
-          delete deleter;   deleter   = 0;
-        }
-      }
-    else
-      {
-#ifdef DEBUG
-        std::cout &lt;&lt; &quot;SharedPtr: null delete&quot; &lt;&lt; std::endl;
-#endif
-      }
-  }
-public:
-  template&lt;class Base&gt; friend class SharedPtr;
-
-  // Constructors
-  SharedPtr()
-    : deleter(0),
-      ref_count(0)
-  {
-#ifdef DEBUG
-    std::cout &lt;&lt; &quot;SharedPtr: ctor null&quot; &lt;&lt; std::endl;
-#endif
-  }
-
-  template&lt;typename D&gt;
-  SharedPtr(D* p)
-    : deleter(new SharedPtrDeleterImpl&lt;T&gt;(p)), 
-      ref_count(new int(1))
-  {
-#ifdef DEBUG
-    std::cout &lt;&lt; &quot;SharedPtr: ctor: type: &quot;
-              &lt;&lt; typeid(deleter-&gt;ptr).name()
-              &lt;&lt; &quot; ptr: &quot; &lt;&lt; deleter-&gt;ptr
-              &lt;&lt; std::endl;
-#endif
-  }
-  
-  template&lt;class Base&gt;
-  SharedPtr(const SharedPtr&lt;Base&gt;&amp; copy)
-    : deleter(0), ref_count(0)
-  {
-    if (copy.deleter)
-      {
-        deleter   = new SharedPtrDeleterImpl&lt;T&gt;(copy.deleter-&gt;ptr);
-        ref_count = copy.ref_count;
-        inc();
-      }
-
-#ifdef DEBUG
-    if (deleter)
-      {
-        std::cout &lt;&lt; &quot;SharedPtr: copy-ctor template: type: &quot;
-                  &lt;&lt; typeid(deleter-&gt;ptr).name()
-                  &lt;&lt; &quot; ptr: &quot; &lt;&lt; deleter-&gt;ptr
-                  &lt;&lt; std::endl;
-      }
-    else
-      {
-        std::cout &lt;&lt; &quot;SharedPtr: copy-ctor template null&quot; &lt;&lt; std::endl;
-      }
-#endif
-  }
-
-  // Assign
-  template&lt;class Base&gt;
-  SharedPtr&lt;T&gt;&amp; operator= (const SharedPtr&lt;Base&gt;&amp; copy) 
-  {
-#ifdef DEBUG
-    std::cout &lt;&lt; &quot;SharedPtr&lt;T&gt;&amp; operator= (const SharedPtr&lt;Base&gt;&amp; copy)&quot; &lt;&lt; std::endl;
-#endif
-    if (ref_count != copy.ref_count)
-      {
-        dec();
-
-        if (copy.deleter)
-          {
-            deleter   = new SharedPtrDeleterImpl&lt;T&gt;(copy.deleter-&gt;ptr);
-            ref_count = copy.ref_count;
-            inc();
-          }
-
-#ifdef DEBUG
-        if (deleter)
-          {
-            std::cout &lt;&lt; &quot;SharedPtr: assign template: type: &quot;
-                      &lt;&lt; typeid(deleter-&gt;ptr).name()
-                      &lt;&lt; &quot; ptr: &quot; &lt;&lt; deleter-&gt;ptr
-                      &lt;&lt; std::endl;
-          }
-        else
-          {
-            std::cout &lt;&lt; &quot;SharedPtr: assign template: null: &quot; &lt;&lt; std::endl;
-          }
-#endif
-      }
-
-    return *this;
-  }
-
-  SharedPtr&lt;T&gt;&amp; operator= (const SharedPtr&lt;T&gt;&amp; copy) 
-  {
-    if (this != &amp;copy)
-      {
-        dec();
-
-        if (copy.deleter)
-          {
-            deleter   = new SharedPtrDeleterImpl&lt;T&gt;(copy.deleter-&gt;ptr);
-            ref_count = copy.ref_count;
-            inc();
-          }
-
-#ifdef DEBUG
-        if (deleter)
-          {
-            std::cout &lt;&lt; &quot;SharedPtr: assign normal: type: &quot;
-                      &lt;&lt; typeid(deleter-&gt;ptr).name()
-                      &lt;&lt; &quot; ptr: &quot; &lt;&lt; deleter-&gt;ptr
-                      &lt;&lt; std::endl;
-          }
-        else
-          {
-            std::cout &lt;&lt; &quot;SharedPtr: assign normal null&quot; &lt;&lt; std::endl;
-          }
-#endif
-      }
-    else
-      {
-#ifdef DEBUG
-        if (deleter)
-          {
-            std::cout &lt;&lt; &quot;SharedPtr: self assin: type: &quot;
-                      &lt;&lt; typeid(deleter-&gt;ptr).name()
-                      &lt;&lt; &quot; ptr: &quot; &lt;&lt; deleter-&gt;ptr
-                      &lt;&lt; std::endl;
-          }
-        else
-          {
-            std::cout &lt;&lt; &quot;SharedPtr: assign normal null&quot; &lt;&lt; std::endl;
-          }
-#endif
-      }
-
-    return *this;
-  }
-  
-  ~SharedPtr()
-  {
-    dec();
-  }
-
-  //: Dereferencing operator.
-  T&amp; operator*() { return *deleter-&gt;ptr; }
-
-  T const&amp; operator*() const { return *deleter-&gt;ptr; }
-	
-  //: Indirect member access operator.
-  T* operator-&gt;() { return deleter-&gt;ptr; }
-
-  T const* operator-&gt;() const { return deleter-&gt;ptr; }
-
-  T* get() const 
-  {
-    if (deleter) 
-      return deleter-&gt;ptr;
-    else
-      return 0; 
-  }
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/sharedptrtest.cpp (from rev 712, trunk/flexlay/lib/sharedptrtest.cxx)
===================================================================
--- trunk/flexlay/lib/sharedptrtest.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sharedptrtest.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,92 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &lt;ClanLib/Core/System/sharedptr.h&gt;
+#include &lt;boost/shared_ptr.hpp&gt;
+#include &quot;sharedptrtest.hpp&quot;
+
+#define SharedPtr boost::shared_ptr
+
+class B
+{
+public:
+  B() { std::cout &lt;&lt; &quot;B(&quot; &lt;&lt; this &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; }
+  virtual ~B() { std::cout &lt;&lt; &quot;~B(&quot; &lt;&lt; this &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; }
+
+  virtual void do_something()
+  {
+    std::cout &lt;&lt; &quot;B: do_something&quot; &lt;&lt; std::endl;
+  }
+};
+
+class A : public B
+{
+public:
+  A() { std::cout &lt;&lt; &quot;A(&quot; &lt;&lt; this &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; }
+  virtual ~A() { std::cout &lt;&lt; &quot;~A(&quot; &lt;&lt; this &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; }
+  
+  void do_something()
+  {
+    std::cout &lt;&lt; &quot;A: do_something&quot; &lt;&lt; std::endl;
+  }
+};
+
+class C;
+
+int main()
+{
+  SharedPtr&lt;A&gt; p0_;
+  SharedPtr&lt;A&gt; p1_;
+  SharedPtr&lt;B&gt; p2_(p0_);
+  SharedPtr&lt;B&gt; p3_(p1_);
+
+  SharedPtr&lt;B&gt; p0(new B());
+  {
+    SharedPtr&lt;B&gt; ptr0(new A());
+  }
+  {
+    SharedPtr&lt;A&gt; aptr0(new A());
+    {
+      p0_ = p1_;
+      SharedPtr&lt;B&gt; ptr1(new B());
+      {
+        SharedPtr&lt;B&gt; ptr2 = ptr1;
+        SharedPtr&lt;B&gt; ptr1 = ptr2;
+        ptr1 = aptr0;
+        p0   = aptr0;
+      }
+    }
+  }
+
+  std::cout &lt;&lt; &quot;\nInteresting part: &quot; &lt;&lt; std::endl;
+  {
+    std::cout &lt;&lt; &quot;### SharedPtr&lt;A&gt; p1;&quot; &lt;&lt; std::endl;
+    SharedPtr&lt;A&gt; p1;
+    {
+      std::cout &lt;&lt; &quot;### SharedPtr&lt;A&gt; p(new A());&quot; &lt;&lt; std::endl;
+      SharedPtr&lt;A&gt; p(new A());
+      std::cout &lt;&lt; &quot;### p1 = p;&quot; &lt;&lt; std::endl;
+      p1 = p;
+    }
+    std::cout &lt;&lt; &quot;### p1-&gt;do_something()&quot; &lt;&lt; std::endl;
+    p1-&gt;do_something();
+  }
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/sharedptrtest.cxx
===================================================================
--- trunk/flexlay/lib/sharedptrtest.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sharedptrtest.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,92 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &lt;ClanLib/Core/System/sharedptr.h&gt;
-#include &lt;boost/shared_ptr.hpp&gt;
-#include &quot;sharedptrtest.hxx&quot;
-
-#define SharedPtr boost::shared_ptr
-
-class B
-{
-public:
-  B() { std::cout &lt;&lt; &quot;B(&quot; &lt;&lt; this &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; }
-  virtual ~B() { std::cout &lt;&lt; &quot;~B(&quot; &lt;&lt; this &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; }
-
-  virtual void do_something()
-  {
-    std::cout &lt;&lt; &quot;B: do_something&quot; &lt;&lt; std::endl;
-  }
-};
-
-class A : public B
-{
-public:
-  A() { std::cout &lt;&lt; &quot;A(&quot; &lt;&lt; this &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; }
-  virtual ~A() { std::cout &lt;&lt; &quot;~A(&quot; &lt;&lt; this &lt;&lt; &quot;)&quot; &lt;&lt; std::endl; }
-  
-  void do_something()
-  {
-    std::cout &lt;&lt; &quot;A: do_something&quot; &lt;&lt; std::endl;
-  }
-};
-
-class C;
-
-int main()
-{
-  SharedPtr&lt;A&gt; p0_;
-  SharedPtr&lt;A&gt; p1_;
-  SharedPtr&lt;B&gt; p2_(p0_);
-  SharedPtr&lt;B&gt; p3_(p1_);
-
-  SharedPtr&lt;B&gt; p0(new B());
-  {
-    SharedPtr&lt;B&gt; ptr0(new A());
-  }
-  {
-    SharedPtr&lt;A&gt; aptr0(new A());
-    {
-      p0_ = p1_;
-      SharedPtr&lt;B&gt; ptr1(new B());
-      {
-        SharedPtr&lt;B&gt; ptr2 = ptr1;
-        SharedPtr&lt;B&gt; ptr1 = ptr2;
-        ptr1 = aptr0;
-        p0   = aptr0;
-      }
-    }
-  }
-
-  std::cout &lt;&lt; &quot;\nInteresting part: &quot; &lt;&lt; std::endl;
-  {
-    std::cout &lt;&lt; &quot;### SharedPtr&lt;A&gt; p1;&quot; &lt;&lt; std::endl;
-    SharedPtr&lt;A&gt; p1;
-    {
-      std::cout &lt;&lt; &quot;### SharedPtr&lt;A&gt; p(new A());&quot; &lt;&lt; std::endl;
-      SharedPtr&lt;A&gt; p(new A());
-      std::cout &lt;&lt; &quot;### p1 = p;&quot; &lt;&lt; std::endl;
-      p1 = p;
-    }
-    std::cout &lt;&lt; &quot;### p1-&gt;do_something()&quot; &lt;&lt; std::endl;
-    p1-&gt;do_something();
-  }
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/sharedptrtest.hpp (from rev 712, trunk/flexlay/lib/sharedptrtest.hxx)

Deleted: trunk/flexlay/lib/sharedptrtest.hxx
===================================================================
--- trunk/flexlay/lib/sharedptrtest.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sharedptrtest.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,25 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_SHAREDPTRTEST_HXX
-#define HEADER_SHAREDPTRTEST_HXX
-
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/simpleed.cpp (from rev 712, trunk/flexlay/lib/simpleed.cxx)
===================================================================
--- trunk/flexlay/lib/simpleed.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/simpleed.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,67 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &lt;string&gt;
+#include &lt;ClanLib/core.h&gt;
+#include &lt;ClanLib/gui.h&gt;
+#include &quot;workspace.hpp&quot;
+#include &quot;tileset.hpp&quot;
+#include &quot;editor_map_component.hpp&quot;
+#include &quot;gui_manager.hpp&quot;
+#include &quot;layer.hpp&quot;
+#include &quot;tilemap_layer.hpp&quot;
+#include &quot;flexlay.hpp&quot;
+#include &quot;editor_map.hpp&quot;
+
+int main()
+{
+  Flexlay flexlay;
+  flexlay.init();
+
+  Editor editor;
+
+  GUIManager* gui = editor.get_gui_manager();
+
+  new CL_Button(CL_Rect(CL_Point(50, 50), 
+                        CL_Size(100, 25)),
+                &quot;Hello World&quot;, gui-&gt;get_component());
+
+  EditorMap m;
+  Tileset tileset(32);
+  TilemapLayer tilemap(tileset, 20, 10);
+  
+  m.add_layer(tilemap.to_layer());
+
+  TilemapLayer::set_current(tilemap);
+
+  EditorMapComponent editor_map(CL_Rect(0, 0, 799, 599), gui-&gt;get_component());
+  Workspace workspace(799, 599);
+  editor_map.set_workspace(workspace);
+  workspace.set_map(m);
+ 
+  new CL_Button(CL_Rect(CL_Point(50, 150), 
+                        CL_Size(100, 25)),
+                &quot;Quit&quot;, gui-&gt;get_component());
+
+  gui-&gt;run();
+ 
+  flexlay.deinit();
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/simpleed.cxx
===================================================================
--- trunk/flexlay/lib/simpleed.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/simpleed.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,67 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &lt;string&gt;
-#include &lt;ClanLib/core.h&gt;
-#include &lt;ClanLib/gui.h&gt;
-#include &quot;workspace.hxx&quot;
-#include &quot;tileset.hxx&quot;
-#include &quot;editor_map_component.hxx&quot;
-#include &quot;gui_manager.hxx&quot;
-#include &quot;layer.hxx&quot;
-#include &quot;tilemap_layer.hxx&quot;
-#include &quot;flexlay.hxx&quot;
-#include &quot;editor_map.hxx&quot;
-
-int main()
-{
-  Flexlay flexlay;
-  flexlay.init();
-
-  Editor editor;
-
-  GUIManager* gui = editor.get_gui_manager();
-
-  new CL_Button(CL_Rect(CL_Point(50, 50), 
-                        CL_Size(100, 25)),
-                &quot;Hello World&quot;, gui-&gt;get_component());
-
-  EditorMap m;
-  Tileset tileset(32);
-  TilemapLayer tilemap(tileset, 20, 10);
-  
-  m.add_layer(tilemap.to_layer());
-
-  TilemapLayer::set_current(tilemap);
-
-  EditorMapComponent editor_map(CL_Rect(0, 0, 799, 599), gui-&gt;get_component());
-  Workspace workspace(799, 599);
-  editor_map.set_workspace(workspace);
-  workspace.set_map(m);
- 
-  new CL_Button(CL_Rect(CL_Point(50, 150), 
-                        CL_Size(100, 25)),
-                &quot;Quit&quot;, gui-&gt;get_component());
-
-  gui-&gt;run();
- 
-  flexlay.deinit();
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/simpleed.hpp (from rev 712, trunk/flexlay/lib/simpleed.hxx)

Deleted: trunk/flexlay/lib/simpleed.hxx
===================================================================
--- trunk/flexlay/lib/simpleed.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/simpleed.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,26 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_SIMPLEED_HXX
-#define HEADER_SIMPLEED_HXX
-
-
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/sketch_layer.cpp (from rev 712, trunk/flexlay/lib/sketch_layer.cxx)
===================================================================
--- trunk/flexlay/lib/sketch_layer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sketch_layer.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,179 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &lt;ClanLib/gl.h&gt;
+#include &lt;ClanLib/Core/core_iostream.h&gt;
+#include &lt;ClanLib/Core/System/error.h&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &lt;ClanLib/Display/sprite.h&gt;
+#include &lt;ClanLib/Display/pixel_buffer.h&gt;
+#include &lt;ClanLib/Display/canvas.h&gt;
+#include &lt;ClanLib/Display/blend_func.h&gt;
+#include &lt;ClanLib/Display/graphic_context.h&gt;
+#include &lt;ClanLib/Display/display_window.h&gt;
+#include &quot;flexlay.hpp&quot;
+#include &quot;editor_map_component.hpp&quot;
+#include &quot;layer_impl.hpp&quot;
+#include &quot;sketch_layer.hpp&quot;
+#include &quot;math.hpp&quot;
+
+SketchLayer* SketchLayer::current_ = 0;
+
+class SketchLayerImpl : public LayerImpl
+{
+public:
+  typedef std::vector&lt;Stroke&gt; Strokes;
+  Strokes strokes;
+
+  /** Used to cache drawings */
+  CL_Surface  surface;
+  CL_Canvas*  canvas;
+  float       last_zoom;
+  float       last_rot;
+  CL_Pointf   last_pos;
+  
+  SketchLayerImpl() 
+    : surface(CL_PixelBuffer(CL_Display::get_width(), CL_Display::get_height(), 
+                             CL_Display::get_width()*4, CL_PixelFormat::rgba8888)),
+      canvas(0),
+      last_zoom(0.0f),
+      last_rot(0)
+  {
+    try {
+      canvas = new CL_Canvas(surface);
+    } catch(CL_Error&amp; err) {
+      std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
+    }
+  }
+
+  ~SketchLayerImpl() {
+    delete canvas;
+  }
+
+  void add_stroke(const Stroke&amp; stroke)
+  {
+    strokes.push_back(stroke);
+
+    if (canvas)
+      {
+        EditorMapComponent* parent = EditorMapComponent::current();
+        parent-&gt;get_gc_state().push(canvas-&gt;get_gc());
+        stroke.draw(canvas-&gt;get_gc());
+        parent-&gt;get_gc_state().pop(canvas-&gt;get_gc());
+        canvas-&gt;sync_surface();
+      }
+  }
+  
+  void draw(EditorMapComponent* parent, CL_GraphicContext* gc) 
+  {
+    // Nothing to draw, so we go byebye
+    if (strokes.empty()) 
+      return;
+
+    if (canvas)
+      {
+        // Draw to canvas
+        if (last_zoom != parent-&gt;get_gc_state().get_zoom() ||
+            last_pos  != parent-&gt;get_gc_state().get_pos()  ||
+            last_rot  != parent-&gt;get_gc_state().get_rotation())
+          {
+            // Rerender the image
+            last_zoom   = parent-&gt;get_gc_state().get_zoom();
+            last_pos    = parent-&gt;get_gc_state().get_pos();
+            last_rot    = parent-&gt;get_gc_state().get_rotation();
+
+            parent-&gt;get_gc_state().push(canvas-&gt;get_gc());
+            canvas-&gt;get_gc()-&gt;clear(CL_Color(0, 0, 0, 0));
+            //canvas-&gt;get_gc()-&gt;clear(CL_Color::white);
+
+            CL_Rectf visible_area = parent-&gt;get_clip_rect();
+
+            for(Strokes::iterator i = strokes.begin(); i != strokes.end(); ++i)
+              {
+                // canvas-&gt;get_gc()-&gt;draw_rect(i-&gt;get_bounding_rect(), CL_Color(0, 255, 0));
+                // canvas-&gt;get_gc()-&gt;flush();
+
+                if (visible_area.is_overlapped(i-&gt;get_bounding_rect()))
+                  {
+                    i-&gt;draw(canvas-&gt;get_gc());
+                  }
+              }
+            parent-&gt;get_gc_state().pop(canvas-&gt;get_gc());
+
+            canvas-&gt;sync_surface();
+          }
+        
+        surface.set_blend_func(blend_one, blend_one_minus_src_alpha);
+
+        CL_Matrix4x4 matrix = CL_Display::get_modelview();
+        CL_Display::pop_modelview();
+        surface.draw();
+        CL_Display::set_modelview(matrix);
+        // FIXME: I think we need the line below, however with it it
+        //doesn't work, without it, it does, ClanLib bug or just
+        //consfusing function names?
+        //CL_Display::push_modelview();
+      }
+    else
+      { 
+        // Direct Drawing, slow
+        for(Strokes::iterator i = strokes.begin(); i != strokes.end(); ++i)
+          {
+            i-&gt;draw(0);
+          }
+      }
+  }
+
+  bool has_bounding_rect() const { 
+    return false;
+  }
+};
+
+SketchLayer::SketchLayer()
+  : impl(new SketchLayerImpl())
+{
+  current_ = this;
+}
+
+void
+SketchLayer::add_stroke(const Stroke&amp; stroke)
+{
+  if (stroke.get_dab_count() &gt; 0)
+    impl-&gt;add_stroke(stroke);
+}
+
+Layer
+SketchLayer::to_layer()
+{
+   return Layer(impl);
+}
+
+std::vector&lt;Stroke&gt;
+SketchLayer::get_strokes()
+{
+  return impl-&gt;strokes;
+}
+
+CL_Surface
+SketchLayer::get_background_surface()
+{
+  return impl-&gt;surface;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/sketch_layer.cxx
===================================================================
--- trunk/flexlay/lib/sketch_layer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sketch_layer.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,179 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &lt;ClanLib/gl.h&gt;
-#include &lt;ClanLib/Core/core_iostream.h&gt;
-#include &lt;ClanLib/Core/System/error.h&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-#include &lt;ClanLib/Display/sprite.h&gt;
-#include &lt;ClanLib/Display/pixel_buffer.h&gt;
-#include &lt;ClanLib/Display/canvas.h&gt;
-#include &lt;ClanLib/Display/blend_func.h&gt;
-#include &lt;ClanLib/Display/graphic_context.h&gt;
-#include &lt;ClanLib/Display/display_window.h&gt;
-#include &quot;flexlay.hxx&quot;
-#include &quot;editor_map_component.hxx&quot;
-#include &quot;layer_impl.hxx&quot;
-#include &quot;sketch_layer.hxx&quot;
-#include &quot;math.hxx&quot;
-
-SketchLayer* SketchLayer::current_ = 0;
-
-class SketchLayerImpl : public LayerImpl
-{
-public:
-  typedef std::vector&lt;Stroke&gt; Strokes;
-  Strokes strokes;
-
-  /** Used to cache drawings */
-  CL_Surface  surface;
-  CL_Canvas*  canvas;
-  float       last_zoom;
-  float       last_rot;
-  CL_Pointf   last_pos;
-  
-  SketchLayerImpl() 
-    : surface(CL_PixelBuffer(CL_Display::get_width(), CL_Display::get_height(), 
-                             CL_Display::get_width()*4, CL_PixelFormat::rgba8888)),
-      canvas(0),
-      last_zoom(0.0f),
-      last_rot(0)
-  {
-    try {
-      canvas = new CL_Canvas(surface);
-    } catch(CL_Error&amp; err) {
-      std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
-    }
-  }
-
-  ~SketchLayerImpl() {
-    delete canvas;
-  }
-
-  void add_stroke(const Stroke&amp; stroke)
-  {
-    strokes.push_back(stroke);
-
-    if (canvas)
-      {
-        EditorMapComponent* parent = EditorMapComponent::current();
-        parent-&gt;get_gc_state().push(canvas-&gt;get_gc());
-        stroke.draw(canvas-&gt;get_gc());
-        parent-&gt;get_gc_state().pop(canvas-&gt;get_gc());
-        canvas-&gt;sync_surface();
-      }
-  }
-  
-  void draw(EditorMapComponent* parent, CL_GraphicContext* gc) 
-  {
-    // Nothing to draw, so we go byebye
-    if (strokes.empty()) 
-      return;
-
-    if (canvas)
-      {
-        // Draw to canvas
-        if (last_zoom != parent-&gt;get_gc_state().get_zoom() ||
-            last_pos  != parent-&gt;get_gc_state().get_pos()  ||
-            last_rot  != parent-&gt;get_gc_state().get_rotation())
-          {
-            // Rerender the image
-            last_zoom   = parent-&gt;get_gc_state().get_zoom();
-            last_pos    = parent-&gt;get_gc_state().get_pos();
-            last_rot    = parent-&gt;get_gc_state().get_rotation();
-
-            parent-&gt;get_gc_state().push(canvas-&gt;get_gc());
-            canvas-&gt;get_gc()-&gt;clear(CL_Color(0, 0, 0, 0));
-            //canvas-&gt;get_gc()-&gt;clear(CL_Color::white);
-
-            CL_Rectf visible_area = parent-&gt;get_clip_rect();
-
-            for(Strokes::iterator i = strokes.begin(); i != strokes.end(); ++i)
-              {
-                // canvas-&gt;get_gc()-&gt;draw_rect(i-&gt;get_bounding_rect(), CL_Color(0, 255, 0));
-                // canvas-&gt;get_gc()-&gt;flush();
-
-                if (visible_area.is_overlapped(i-&gt;get_bounding_rect()))
-                  {
-                    i-&gt;draw(canvas-&gt;get_gc());
-                  }
-              }
-            parent-&gt;get_gc_state().pop(canvas-&gt;get_gc());
-
-            canvas-&gt;sync_surface();
-          }
-        
-        surface.set_blend_func(blend_one, blend_one_minus_src_alpha);
-
-        CL_Matrix4x4 matrix = CL_Display::get_modelview();
-        CL_Display::pop_modelview();
-        surface.draw();
-        CL_Display::set_modelview(matrix);
-        // FIXME: I think we need the line below, however with it it
-        //doesn't work, without it, it does, ClanLib bug or just
-        //consfusing function names?
-        //CL_Display::push_modelview();
-      }
-    else
-      { 
-        // Direct Drawing, slow
-        for(Strokes::iterator i = strokes.begin(); i != strokes.end(); ++i)
-          {
-            i-&gt;draw(0);
-          }
-      }
-  }
-
-  bool has_bounding_rect() const { 
-    return false;
-  }
-};
-
-SketchLayer::SketchLayer()
-  : impl(new SketchLayerImpl())
-{
-  current_ = this;
-}
-
-void
-SketchLayer::add_stroke(const Stroke&amp; stroke)
-{
-  if (stroke.get_dab_count() &gt; 0)
-    impl-&gt;add_stroke(stroke);
-}
-
-Layer
-SketchLayer::to_layer()
-{
-   return Layer(impl);
-}
-
-std::vector&lt;Stroke&gt;
-SketchLayer::get_strokes()
-{
-  return impl-&gt;strokes;
-}
-
-CL_Surface
-SketchLayer::get_background_surface()
-{
-  return impl-&gt;surface;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/sketch_layer.hpp (from rev 712, trunk/flexlay/lib/sketch_layer.hxx)
===================================================================
--- trunk/flexlay/lib/sketch_layer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sketch_layer.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,58 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_SKETCH_LAYER_HXX
+#define HEADER_SKETCH_LAYER_HXX
+
+#include &lt;vector&gt;
+#include &lt;ClanLib/Core/Math/point.h&gt;
+#include &lt;ClanLib/Display/color.h&gt;
+#include &quot;layer.hpp&quot;
+#include &quot;stroke.hpp&quot;
+
+class SketchLayerImpl;
+
+/** A drawing layer that holds strokes and renders them more or less
+    efficently to the screen, for larger number of strokes this has
+    serious performance impact, use BitmapLayer instead */
+class SketchLayer
+{
+private:
+  static SketchLayer* current_;
+public:
+  static SketchLayer* current() { return current_; }
+  static void set_current(SketchLayer* c) { current_ = c; }
+
+  SketchLayer();
+  
+  void add_stroke(const Stroke&amp;);
+
+  std::vector&lt;Stroke&gt; get_strokes();
+
+  CL_Surface get_background_surface();
+
+  bool is_null() const { return !impl.get(); }
+  Layer to_layer();
+
+private:
+  SharedPtr&lt;SketchLayerImpl&gt; impl;  
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/sketch_layer.hxx
===================================================================
--- trunk/flexlay/lib/sketch_layer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sketch_layer.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,58 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_SKETCH_LAYER_HXX
-#define HEADER_SKETCH_LAYER_HXX
-
-#include &lt;vector&gt;
-#include &lt;ClanLib/Core/Math/point.h&gt;
-#include &lt;ClanLib/Display/color.h&gt;
-#include &quot;layer.hxx&quot;
-#include &quot;stroke.hxx&quot;
-
-class SketchLayerImpl;
-
-/** A drawing layer that holds strokes and renders them more or less
-    efficently to the screen, for larger number of strokes this has
-    serious performance impact, use BitmapLayer instead */
-class SketchLayer
-{
-private:
-  static SketchLayer* current_;
-public:
-  static SketchLayer* current() { return current_; }
-  static void set_current(SketchLayer* c) { current_ = c; }
-
-  SketchLayer();
-  
-  void add_stroke(const Stroke&amp;);
-
-  std::vector&lt;Stroke&gt; get_strokes();
-
-  CL_Surface get_background_surface();
-
-  bool is_null() const { return !impl.get(); }
-  Layer to_layer();
-
-private:
-  SharedPtr&lt;SketchLayerImpl&gt; impl;  
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/slider.cpp (from rev 712, trunk/flexlay/lib/slider.cxx)
===================================================================
--- trunk/flexlay/lib/slider.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/slider.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,116 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;ClanLib/Display/display.h&gt;
+#include &lt;ClanLib/Display/keys.h&gt;
+#include &quot;math.hpp&quot;
+#include &quot;slider.hpp&quot;
+
+Slider::Slider(const CL_Rect&amp; rect, CL_Component* parent)
+  : CL_Component(rect, parent)
+{
+  start = 0.0f;
+  end   = 100.0f;
+  value = 50.0f;
+  pressed = false;
+
+  slots.push_back(sig_mouse_down().connect(this, &amp;Slider::on_mouse_down));
+  slots.push_back(sig_mouse_up().connect(this, &amp;Slider::on_mouse_up));
+  slots.push_back(sig_mouse_move().connect(this, &amp;Slider::on_mouse_move));
+  slots.push_back(sig_paint().connect(this, &amp;Slider::draw));
+}
+
+Slider::~Slider()
+{
+}
+
+void
+Slider::draw()
+{
+  CL_Display::push_modelview();
+  CL_Display::add_translate(get_screen_x(), get_screen_y());
+    
+  CL_Display::fill_rect(CL_Rect(CL_Point(0, get_height()/2 - 2),
+                                CL_Size(get_width(), 5)),
+                        CL_Color(255, 255, 255, 255));
+
+  CL_Display::fill_rect(CL_Rect(CL_Point(int(-2 + (value/(end-start)) * get_width()), 0),
+                                CL_Size(5, get_height())),
+                        CL_Color(0, 0, 0, 255));
+
+  CL_Display::pop_modelview();    
+}
+
+void
+Slider::set_range(float start_, float end_)
+{
+  start = start_;
+  end   = end_;
+}
+
+CL_Signal_v1&lt;float&gt;&amp;
+Slider::sig_on_change()
+{
+  return on_change;
+}
+
+void
+Slider::set_value(float value_)
+{
+  value = value_;
+  on_change(value);
+}
+
+void
+Slider::update_mouse(const CL_InputEvent&amp; event)
+{
+  set_value(Math::mid(start, (float(event.mouse_pos.x) / get_width()) * (end - start), end));
+}
+
+void
+Slider::on_mouse_down(const CL_InputEvent&amp; event)
+{
+  if (event.id == CL_MOUSE_LEFT)
+    {
+      pressed = true;
+      capture_mouse();
+      update_mouse(event);
+    }
+}
+
+void
+Slider::on_mouse_up  (const CL_InputEvent&amp; event)
+{
+  if (event.id == CL_MOUSE_LEFT)
+    {
+      pressed = false;
+      release_mouse();
+      update_mouse(event);
+    }
+}
+
+void
+Slider::on_mouse_move(const CL_InputEvent&amp; event)
+{
+  if (pressed)
+    {
+      update_mouse(event);
+    }
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/slider.cxx
===================================================================
--- trunk/flexlay/lib/slider.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/slider.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,116 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;ClanLib/Display/display.h&gt;
-#include &lt;ClanLib/Display/keys.h&gt;
-#include &quot;math.hxx&quot;
-#include &quot;slider.hxx&quot;
-
-Slider::Slider(const CL_Rect&amp; rect, CL_Component* parent)
-  : CL_Component(rect, parent)
-{
-  start = 0.0f;
-  end   = 100.0f;
-  value = 50.0f;
-  pressed = false;
-
-  slots.push_back(sig_mouse_down().connect(this, &amp;Slider::on_mouse_down));
-  slots.push_back(sig_mouse_up().connect(this, &amp;Slider::on_mouse_up));
-  slots.push_back(sig_mouse_move().connect(this, &amp;Slider::on_mouse_move));
-  slots.push_back(sig_paint().connect(this, &amp;Slider::draw));
-}
-
-Slider::~Slider()
-{
-}
-
-void
-Slider::draw()
-{
-  CL_Display::push_modelview();
-  CL_Display::add_translate(get_screen_x(), get_screen_y());
-    
-  CL_Display::fill_rect(CL_Rect(CL_Point(0, get_height()/2 - 2),
-                                CL_Size(get_width(), 5)),
-                        CL_Color(255, 255, 255, 255));
-
-  CL_Display::fill_rect(CL_Rect(CL_Point(int(-2 + (value/(end-start)) * get_width()), 0),
-                                CL_Size(5, get_height())),
-                        CL_Color(0, 0, 0, 255));
-
-  CL_Display::pop_modelview();    
-}
-
-void
-Slider::set_range(float start_, float end_)
-{
-  start = start_;
-  end   = end_;
-}
-
-CL_Signal_v1&lt;float&gt;&amp;
-Slider::sig_on_change()
-{
-  return on_change;
-}
-
-void
-Slider::set_value(float value_)
-{
-  value = value_;
-  on_change(value);
-}
-
-void
-Slider::update_mouse(const CL_InputEvent&amp; event)
-{
-  set_value(Math::mid(start, (float(event.mouse_pos.x) / get_width()) * (end - start), end));
-}
-
-void
-Slider::on_mouse_down(const CL_InputEvent&amp; event)
-{
-  if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed = true;
-      capture_mouse();
-      update_mouse(event);
-    }
-}
-
-void
-Slider::on_mouse_up  (const CL_InputEvent&amp; event)
-{
-  if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed = false;
-      release_mouse();
-      update_mouse(event);
-    }
-}
-
-void
-Slider::on_mouse_move(const CL_InputEvent&amp; event)
-{
-  if (pressed)
-    {
-      update_mouse(event);
-    }
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/slider.hpp (from rev 712, trunk/flexlay/lib/slider.hxx)

Deleted: trunk/flexlay/lib/slider.hxx
===================================================================
--- trunk/flexlay/lib/slider.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/slider.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,58 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_SLIDER_HXX
-#define HEADER_SLIDER_HXX
-
-#include &lt;vector&gt;
-#include &lt;ClanLib/GUI/component.h&gt;
-#include &lt;ClanLib/Core/Math/rect.h&gt;
-
-/** Little Slider GUI component */
-class Slider : public CL_Component
-{
-protected:
-  virtual ~Slider();
-private:
-  std::vector&lt;CL_Slot&gt; slots;
-  float start;
-  float end;
-  float value;
-  bool pressed;
-
-  CL_Signal_v1&lt;float&gt; on_change;
-  
-  void update_mouse(const CL_InputEvent&amp; event);
-public:
-  Slider(const CL_Rect&amp; rect, CL_Component* parent);
-
-  CL_Signal_v1&lt;float&gt;&amp; sig_on_change();
-
-  void set_range(float start, float end);
-  void set_value(float value);
-
-  void draw();
-  
-  void on_mouse_down(const CL_InputEvent&amp; event);
-  void on_mouse_up  (const CL_InputEvent&amp; event);
-  void on_mouse_move(const CL_InputEvent&amp; event);
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/sprite_brush.cpp (from rev 712, trunk/flexlay/lib/sprite_brush.cxx)
===================================================================
--- trunk/flexlay/lib/sprite_brush.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sprite_brush.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,59 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &quot;brush_impl.hpp&quot;
+#include &quot;sprite_brush.hpp&quot;
+
+class SpriteBrushImpl : public BrushImpl
+{
+public:
+  CL_Sprite sprite;
+  
+  SpriteBrushImpl(const CL_Sprite&amp; sprite_)
+    : sprite(sprite_)
+  {
+    sprite.set_alignment (origin_center, 0, 0);
+  }
+
+  virtual ~SpriteBrushImpl()
+  {
+  }
+
+  CL_Sprite get_sprite() 
+  {
+    return sprite;
+  }
+
+  BrushImpl* clone() const 
+  {
+    return new SpriteBrushImpl(sprite);
+  }
+};
+
+SpriteBrush::SpriteBrush(const CL_Sprite&amp; sprite_)
+  : impl(new SpriteBrushImpl(sprite_))
+{
+}
+
+Brush
+SpriteBrush::to_brush()
+{
+  return Brush(impl);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/sprite_brush.cxx
===================================================================
--- trunk/flexlay/lib/sprite_brush.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sprite_brush.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,59 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &quot;brush_impl.hxx&quot;
-#include &quot;sprite_brush.hxx&quot;
-
-class SpriteBrushImpl : public BrushImpl
-{
-public:
-  CL_Sprite sprite;
-  
-  SpriteBrushImpl(const CL_Sprite&amp; sprite_)
-    : sprite(sprite_)
-  {
-    sprite.set_alignment (origin_center, 0, 0);
-  }
-
-  virtual ~SpriteBrushImpl()
-  {
-  }
-
-  CL_Sprite get_sprite() 
-  {
-    return sprite;
-  }
-
-  BrushImpl* clone() const 
-  {
-    return new SpriteBrushImpl(sprite);
-  }
-};
-
-SpriteBrush::SpriteBrush(const CL_Sprite&amp; sprite_)
-  : impl(new SpriteBrushImpl(sprite_))
-{
-}
-
-Brush
-SpriteBrush::to_brush()
-{
-  return Brush(impl);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/sprite_brush.hpp (from rev 712, trunk/flexlay/lib/sprite_brush.hxx)
===================================================================
--- trunk/flexlay/lib/sprite_brush.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sprite_brush.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,41 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_SPRITE_BRUSH_HXX
+#define HEADER_SPRITE_BRUSH_HXX
+
+#include &lt;ClanLib/Display/sprite.h&gt;
+#include &quot;brush.hpp&quot;
+#include &quot;shared_ptr.hpp&quot;
+
+class SpriteBrushImpl;
+
+class SpriteBrush
+{
+public:
+  SpriteBrush(const CL_Sprite&amp; sprite_);
+
+  Brush to_brush();
+private:
+  SharedPtr&lt;SpriteBrushImpl&gt; impl;
+};
+
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/sprite_brush.hxx
===================================================================
--- trunk/flexlay/lib/sprite_brush.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sprite_brush.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,41 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_SPRITE_BRUSH_HXX
-#define HEADER_SPRITE_BRUSH_HXX
-
-#include &lt;ClanLib/Display/sprite.h&gt;
-#include &quot;brush.hxx&quot;
-#include &quot;shared_ptr.hxx&quot;
-
-class SpriteBrushImpl;
-
-class SpriteBrush
-{
-public:
-  SpriteBrush(const CL_Sprite&amp; sprite_);
-
-  Brush to_brush();
-private:
-  SharedPtr&lt;SpriteBrushImpl&gt; impl;
-};
-
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/sprite_stroke_drawer.cpp (from rev 712, trunk/flexlay/lib/sprite_stroke_drawer.cxx)
===================================================================
--- trunk/flexlay/lib/sprite_stroke_drawer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sprite_stroke_drawer.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,287 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &lt;assert.h&gt;
+#include &lt;ClanLib/Display/blend_func.h&gt;
+#include &lt;ClanLib/Display/canvas.h&gt;
+#include &lt;ClanLib/gl.h&gt;
+#include &lt;ClanLib/GL/opengl_wrap.h&gt;
+#include &quot;stroke.hpp&quot;
+#include &quot;flexlay.hpp&quot;
+#include &quot;stroke_drawer_impl.hpp&quot;
+#include &quot;sprite_stroke_drawer.hpp&quot;
+#include &quot;drawer_properties.hpp&quot;
+#include &quot;bitmap_layer.hpp&quot;
+#include &quot;sketch_layer.hpp&quot;
+
+CL_ProgramObject* program = 0;
+
+class SpriteStrokeDrawerImpl : public StrokeDrawerImpl
+{
+public:
+  SpriteStrokeDrawer::DrawMode mode;
+  
+  SpriteStrokeDrawerImpl() {}
+
+  void draw(const Stroke&amp; stroke, CL_GraphicContext* gc);
+
+  StrokeDrawerImpl* clone() const;
+};
+
+SpriteStrokeDrawer::SpriteStrokeDrawer(StrokeDrawer drawer)
+{
+  // FIXME: THIS WON'T WORK WITH A REAL SMARTPTR!!!!
+  impl = dynamic_cast&lt;SpriteStrokeDrawerImpl*&gt;(drawer.impl.get());
+  assert(impl.get());
+}
+
+SpriteStrokeDrawer::SpriteStrokeDrawer()
+  : impl(new SpriteStrokeDrawerImpl())
+{
+  impl-&gt;mode      = SpriteStrokeDrawer::DM_NORMAL;
+}
+
+void
+SpriteStrokeDrawerImpl::draw(const Stroke&amp; stroke, CL_GraphicContext* gc)
+{
+  if (DrawerProperties::current()-&gt;get_brush().is_null() || stroke.get_dab_count() == 0)
+    return;
+  
+  Stroke::Dabs dabs = stroke.get_interpolated_dabs(DrawerProperties::current()-&gt;get_spacing()
+                                                   * DrawerProperties::current()-&gt;get_size(),
+                                                   DrawerProperties::current()-&gt;get_spacing()
+                                                   * DrawerProperties::current()-&gt;get_size());
+
+  for(Stroke::Dabs::iterator i = dabs.begin(); i != dabs.end(); ++i)
+    {
+      Dab&amp; dab = *i;
+
+      CL_Sprite sprite = DrawerProperties::current()-&gt;get_brush().get_sprite();
+
+      CL_Color color = DrawerProperties::current()-&gt;get_color();
+      sprite.set_color(color);
+      sprite.set_alpha((color.get_alpha()/255.0f) * dab.pressure);
+      sprite.set_scale(DrawerProperties::current()-&gt;get_size() * dab.pressure,
+                       DrawerProperties::current()-&gt;get_size() * dab.pressure);
+
+      if (gc != 0)
+        {
+          /* Correct function:
+             1: dest
+             2: src
+             
+             R = R1 A1 (1 - A2) + R2 A2
+             G = G1 A1 (1 - A2) + G2 A2
+             B = B1 A1 (1 - A2) + B2 A2
+             A = A1 (1 - A2) + A2
+
+             // This is currently used, leads to premultiplied alpha
+             Aout  = Afgd + (1 - Afgd) * Abkg 
+             Cout' = Cfgd' + (1 - Afgd) * Cbkg' 
+             where
+             Cfgd' = Cfgd * Afgd
+             Cbkg' = Cbkg * Abkg
+             Cout' = Cout * Aout
+
+             Aout = (1 - (1 - Afgd) * (1 - Abkg)) 
+             Cout = (Cfgd * Afgd) + (1 - Afgd * Cbkg * Abkg) / Aout 
+             where
+             Cfgd = red, green, blue of foreground
+             Cbkg = red, green, blue of background
+             Afgd = alpha of foreground
+             Abkg = alpha of background
+          */
+
+          // DO Multipass:
+          // 1: GL_ZERO, GL_DST_ALPHA
+          // 2: GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA
+          /*brush.set_blend_func_separate(blend_zero, blend_dst_alpha,
+            blend_zero, blend_one);
+            brush.draw(dab.pos.x, dab.pos.y, gc);*/
+          
+          switch (mode)
+            {
+            case SpriteStrokeDrawer::DM_NORMAL:
+              sprite.set_blend_func_separate(blend_src_alpha, blend_one_minus_src_alpha,
+                                             blend_one, blend_one_minus_src_alpha);
+              sprite.draw(dab.pos.x, dab.pos.y, gc);
+              break;
+
+            case SpriteStrokeDrawer::DM_ADDITION:
+              sprite.set_blend_func_separate(blend_src_alpha, blend_one,
+                                             blend_zero, blend_one);
+              //blend_one, blend_one_minus_src_alpha);
+              sprite.draw(dab.pos.x, dab.pos.y, gc);
+              break;
+              
+            case SpriteStrokeDrawer::DM_ERASE:
+              sprite.set_blend_func(blend_zero, blend_one_minus_src_alpha);
+              sprite.draw(dab.pos.x, dab.pos.y, gc);
+              break;
+          
+            case SpriteStrokeDrawer::DM_SMUDGE:
+              {
+                if (i != dabs.begin())
+                  {
+                    CL_Canvas* canvas = BitmapLayer::current()-&gt;get_canvas();
+                    CL_PixelBuffer buffer = canvas-&gt;get_pixeldata(CL_Rect(CL_Point(static_cast&lt;int&gt;((i-1)-&gt;pos.x) - sprite.get_width()/2,
+                                                                                   static_cast&lt;int&gt;((i-1)-&gt;pos.y) - sprite.get_height()/2),
+                                                                          CL_Size(sprite.get_width(), sprite.get_height())));
+                    CL_Surface surface(buffer);
+                    //surface.set_blend_func_separate(blend_src_alpha, blend_one_minus_src_alpha,
+                    //                                blend_one, blend_zero);
+                    surface.set_alignment(origin_center);
+                    surface.set_alpha(0.5);
+                    //surface.set_scale(DrawerProperties::current()-&gt;get_size(),
+                    //                 DrawerProperties::current()-&gt;get_size());
+                    surface.draw(dab.pos.x, dab.pos.y, gc);
+                  }
+              }
+              break;
+
+            case SpriteStrokeDrawer::DM_SHADER:
+              {
+#if 0 
+                CL_OpenGLState state(gc);
+                state.set_active();
+                state.setup_2d();
+
+                if (program == 0)
+                  {
+                    program = new CL_ProgramObject();
+                
+                    CL_ShaderObject shader(&quot;shader&quot;, &amp;(Flexlay::current()-&gt;resources));
+                    std::cout &lt;&lt; &quot;Shader status: &quot; &lt;&lt; (shader.get_compile_status() ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; std::endl;
+                    std::cout &lt;&lt; &quot;Shader log: &quot; &lt;&lt; shader.get_info_log() &lt;&lt; std::endl;
+                    std::cout &lt;&lt; &quot;Shader handle: &quot; &lt;&lt; shader.get_handle() &lt;&lt; std::endl;
+
+                    program-&gt;attach(shader);
+                    program-&gt;link();
+                    std::cout &lt;&lt; &quot;Program status: &quot; &lt;&lt; (program-&gt;get_link_status() ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; std::endl;
+                    std::cout &lt;&lt; &quot;Program log: &quot; &lt;&lt; program-&gt;get_info_log() &lt;&lt; std::endl;
+                    std::cout &lt;&lt; &quot;Program handle: &quot; &lt;&lt; program-&gt;get_handle() &lt;&lt; std::endl;
+
+                    clUseProgram(program-&gt;get_handle());
+                  }
+                else
+                  {
+                    clUseProgram(program-&gt;get_handle());
+                  }
+            
+                CL_OpenGLSurface glsurface(sprite.get_frame_surface(0));
+                glActiveTexture(GL_TEXTURE0);
+                glsurface.bind();
+                glEnable(GL_TEXTURE_2D);
+
+                /*CL_OpenGLSurface glsurface2(SketchLayer::current()-&gt;get_background_surface());
+                  glActiveTexture(GL_TEXTURE1);
+                  glsurface2.bind();
+                  glEnable(GL_TEXTURE_2D);*/
+            
+                clUniform1i(program-&gt;get_attribute_location(&quot;mytex&quot;), 0);
+                //clUniform1i(program-&gt;get_attribute_location(&quot;background&quot;), 1);
+                //program-&gt;validate();
+                //std::cout &lt;&lt; &quot;Program validate status: &quot; &lt;&lt; (program-&gt;get_validate_status() ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; std::endl;
+                //std::cout &lt;&lt; &quot;Program log: &quot; &lt;&lt; program-&gt;get_info_log() &lt;&lt; std::endl;
+
+                clBegin(CL_QUADS);
+                clColor4b(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
+                float size = base_size * dab.pressure;
+                clVertex2f((dab.pos.x - sprite.get_width()/2) * size, (dab.pos.y - sprite.get_height()/2) * size);
+                clTexCoord2d(0.0, 0.0);
+                clVertex2f((dab.pos.x + sprite.get_width()/2) * size, (dab.pos.y - sprite.get_height()/2) * size);
+                clTexCoord2d(1.0, 0.0);
+                clVertex2f((dab.pos.x + sprite.get_width()/2) * size, (dab.pos.y + sprite.get_height()/2) * size);
+                clTexCoord2d(1.0, 1.0);
+                clVertex2f((dab.pos.x - sprite.get_width()/2) * size, (dab.pos.y + sprite.get_height()/2) * size);
+                clTexCoord2d(0.0, 1.0);
+                clEnd();
+            
+                state.set_active();
+                clUseProgram(0);
+#endif
+              }
+              break;
+              
+            default:
+              std::cout &lt;&lt; &quot;Error: SpriteStrokeDrawer: Unknown draw mode: &quot; &lt;&lt; mode &lt;&lt; std::endl;
+              break;
+            }
+        }
+      else
+        {
+          switch (mode)
+            {
+            case SpriteStrokeDrawer::DM_NORMAL:  
+              sprite.set_blend_func(blend_src_alpha, blend_one_minus_src_alpha);
+              sprite.draw(dab.pos.x, dab.pos.y, gc);
+              break;
+              
+            case SpriteStrokeDrawer::DM_ADDITION:
+              sprite.set_blend_func(blend_src_alpha, blend_one);
+              sprite.draw(dab.pos.x, dab.pos.y, gc); 
+              break;
+            
+            case SpriteStrokeDrawer::DM_ERASE:
+              sprite.set_blend_func(blend_zero, blend_one_minus_src_alpha);
+              sprite.draw(dab.pos.x, dab.pos.y, gc);
+              break; 
+          
+            case SpriteStrokeDrawer::DM_SMUDGE:
+              sprite.set_blend_func(blend_src_alpha, blend_one_minus_src_alpha);
+              sprite.draw(dab.pos.x, dab.pos.y, gc);          
+              break;
+
+            default:
+              std::cout &lt;&lt; &quot;Error: SpriteStrokeDrawer: Unknown draw mode: &quot; &lt;&lt; mode &lt;&lt; std::endl;
+              break;
+            }
+        }
+    }
+}
+
+void
+SpriteStrokeDrawer::set_mode(DrawMode mode)
+{
+  impl-&gt;mode = mode;
+}
+
+SpriteStrokeDrawer::DrawMode
+SpriteStrokeDrawer::get_mode()
+{
+  return impl-&gt;mode;
+}
+
+StrokeDrawerImpl*
+SpriteStrokeDrawerImpl::clone() const
+{
+  SpriteStrokeDrawerImpl* drawer = new SpriteStrokeDrawerImpl();
+  
+  *drawer = *this;
+    
+  return drawer;
+}
+
+StrokeDrawer
+SpriteStrokeDrawer::to_drawer()
+{
+  return StrokeDrawer(impl);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/sprite_stroke_drawer.cxx
===================================================================
--- trunk/flexlay/lib/sprite_stroke_drawer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sprite_stroke_drawer.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,287 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &lt;assert.h&gt;
-#include &lt;ClanLib/Display/blend_func.h&gt;
-#include &lt;ClanLib/Display/canvas.h&gt;
-#include &lt;ClanLib/gl.h&gt;
-#include &lt;ClanLib/GL/opengl_wrap.h&gt;
-#include &quot;stroke.hxx&quot;
-#include &quot;flexlay.hxx&quot;
-#include &quot;stroke_drawer_impl.hxx&quot;
-#include &quot;sprite_stroke_drawer.hxx&quot;
-#include &quot;drawer_properties.hxx&quot;
-#include &quot;bitmap_layer.hxx&quot;
-#include &quot;sketch_layer.hxx&quot;
-
-CL_ProgramObject* program = 0;
-
-class SpriteStrokeDrawerImpl : public StrokeDrawerImpl
-{
-public:
-  SpriteStrokeDrawer::DrawMode mode;
-  
-  SpriteStrokeDrawerImpl() {}
-
-  void draw(const Stroke&amp; stroke, CL_GraphicContext* gc);
-
-  StrokeDrawerImpl* clone() const;
-};
-
-SpriteStrokeDrawer::SpriteStrokeDrawer(StrokeDrawer drawer)
-{
-  // FIXME: THIS WON'T WORK WITH A REAL SMARTPTR!!!!
-  impl = dynamic_cast&lt;SpriteStrokeDrawerImpl*&gt;(drawer.impl.get());
-  assert(impl.get());
-}
-
-SpriteStrokeDrawer::SpriteStrokeDrawer()
-  : impl(new SpriteStrokeDrawerImpl())
-{
-  impl-&gt;mode      = SpriteStrokeDrawer::DM_NORMAL;
-}
-
-void
-SpriteStrokeDrawerImpl::draw(const Stroke&amp; stroke, CL_GraphicContext* gc)
-{
-  if (DrawerProperties::current()-&gt;get_brush().is_null() || stroke.get_dab_count() == 0)
-    return;
-  
-  Stroke::Dabs dabs = stroke.get_interpolated_dabs(DrawerProperties::current()-&gt;get_spacing()
-                                                   * DrawerProperties::current()-&gt;get_size(),
-                                                   DrawerProperties::current()-&gt;get_spacing()
-                                                   * DrawerProperties::current()-&gt;get_size());
-
-  for(Stroke::Dabs::iterator i = dabs.begin(); i != dabs.end(); ++i)
-    {
-      Dab&amp; dab = *i;
-
-      CL_Sprite sprite = DrawerProperties::current()-&gt;get_brush().get_sprite();
-
-      CL_Color color = DrawerProperties::current()-&gt;get_color();
-      sprite.set_color(color);
-      sprite.set_alpha((color.get_alpha()/255.0f) * dab.pressure);
-      sprite.set_scale(DrawerProperties::current()-&gt;get_size() * dab.pressure,
-                       DrawerProperties::current()-&gt;get_size() * dab.pressure);
-
-      if (gc != 0)
-        {
-          /* Correct function:
-             1: dest
-             2: src
-             
-             R = R1 A1 (1 - A2) + R2 A2
-             G = G1 A1 (1 - A2) + G2 A2
-             B = B1 A1 (1 - A2) + B2 A2
-             A = A1 (1 - A2) + A2
-
-             // This is currently used, leads to premultiplied alpha
-             Aout  = Afgd + (1 - Afgd) * Abkg 
-             Cout' = Cfgd' + (1 - Afgd) * Cbkg' 
-             where
-             Cfgd' = Cfgd * Afgd
-             Cbkg' = Cbkg * Abkg
-             Cout' = Cout * Aout
-
-             Aout = (1 - (1 - Afgd) * (1 - Abkg)) 
-             Cout = (Cfgd * Afgd) + (1 - Afgd * Cbkg * Abkg) / Aout 
-             where
-             Cfgd = red, green, blue of foreground
-             Cbkg = red, green, blue of background
-             Afgd = alpha of foreground
-             Abkg = alpha of background
-          */
-
-          // DO Multipass:
-          // 1: GL_ZERO, GL_DST_ALPHA
-          // 2: GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA
-          /*brush.set_blend_func_separate(blend_zero, blend_dst_alpha,
-            blend_zero, blend_one);
-            brush.draw(dab.pos.x, dab.pos.y, gc);*/
-          
-          switch (mode)
-            {
-            case SpriteStrokeDrawer::DM_NORMAL:
-              sprite.set_blend_func_separate(blend_src_alpha, blend_one_minus_src_alpha,
-                                             blend_one, blend_one_minus_src_alpha);
-              sprite.draw(dab.pos.x, dab.pos.y, gc);
-              break;
-
-            case SpriteStrokeDrawer::DM_ADDITION:
-              sprite.set_blend_func_separate(blend_src_alpha, blend_one,
-                                             blend_zero, blend_one);
-              //blend_one, blend_one_minus_src_alpha);
-              sprite.draw(dab.pos.x, dab.pos.y, gc);
-              break;
-              
-            case SpriteStrokeDrawer::DM_ERASE:
-              sprite.set_blend_func(blend_zero, blend_one_minus_src_alpha);
-              sprite.draw(dab.pos.x, dab.pos.y, gc);
-              break;
-          
-            case SpriteStrokeDrawer::DM_SMUDGE:
-              {
-                if (i != dabs.begin())
-                  {
-                    CL_Canvas* canvas = BitmapLayer::current()-&gt;get_canvas();
-                    CL_PixelBuffer buffer = canvas-&gt;get_pixeldata(CL_Rect(CL_Point(static_cast&lt;int&gt;((i-1)-&gt;pos.x) - sprite.get_width()/2,
-                                                                                   static_cast&lt;int&gt;((i-1)-&gt;pos.y) - sprite.get_height()/2),
-                                                                          CL_Size(sprite.get_width(), sprite.get_height())));
-                    CL_Surface surface(buffer);
-                    //surface.set_blend_func_separate(blend_src_alpha, blend_one_minus_src_alpha,
-                    //                                blend_one, blend_zero);
-                    surface.set_alignment(origin_center);
-                    surface.set_alpha(0.5);
-                    //surface.set_scale(DrawerProperties::current()-&gt;get_size(),
-                    //                 DrawerProperties::current()-&gt;get_size());
-                    surface.draw(dab.pos.x, dab.pos.y, gc);
-                  }
-              }
-              break;
-
-            case SpriteStrokeDrawer::DM_SHADER:
-              {
-#if 0 
-                CL_OpenGLState state(gc);
-                state.set_active();
-                state.setup_2d();
-
-                if (program == 0)
-                  {
-                    program = new CL_ProgramObject();
-                
-                    CL_ShaderObject shader(&quot;shader&quot;, &amp;(Flexlay::current()-&gt;resources));
-                    std::cout &lt;&lt; &quot;Shader status: &quot; &lt;&lt; (shader.get_compile_status() ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; std::endl;
-                    std::cout &lt;&lt; &quot;Shader log: &quot; &lt;&lt; shader.get_info_log() &lt;&lt; std::endl;
-                    std::cout &lt;&lt; &quot;Shader handle: &quot; &lt;&lt; shader.get_handle() &lt;&lt; std::endl;
-
-                    program-&gt;attach(shader);
-                    program-&gt;link();
-                    std::cout &lt;&lt; &quot;Program status: &quot; &lt;&lt; (program-&gt;get_link_status() ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; std::endl;
-                    std::cout &lt;&lt; &quot;Program log: &quot; &lt;&lt; program-&gt;get_info_log() &lt;&lt; std::endl;
-                    std::cout &lt;&lt; &quot;Program handle: &quot; &lt;&lt; program-&gt;get_handle() &lt;&lt; std::endl;
-
-                    clUseProgram(program-&gt;get_handle());
-                  }
-                else
-                  {
-                    clUseProgram(program-&gt;get_handle());
-                  }
-            
-                CL_OpenGLSurface glsurface(sprite.get_frame_surface(0));
-                glActiveTexture(GL_TEXTURE0);
-                glsurface.bind();
-                glEnable(GL_TEXTURE_2D);
-
-                /*CL_OpenGLSurface glsurface2(SketchLayer::current()-&gt;get_background_surface());
-                  glActiveTexture(GL_TEXTURE1);
-                  glsurface2.bind();
-                  glEnable(GL_TEXTURE_2D);*/
-            
-                clUniform1i(program-&gt;get_attribute_location(&quot;mytex&quot;), 0);
-                //clUniform1i(program-&gt;get_attribute_location(&quot;background&quot;), 1);
-                //program-&gt;validate();
-                //std::cout &lt;&lt; &quot;Program validate status: &quot; &lt;&lt; (program-&gt;get_validate_status() ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; std::endl;
-                //std::cout &lt;&lt; &quot;Program log: &quot; &lt;&lt; program-&gt;get_info_log() &lt;&lt; std::endl;
-
-                clBegin(CL_QUADS);
-                clColor4b(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
-                float size = base_size * dab.pressure;
-                clVertex2f((dab.pos.x - sprite.get_width()/2) * size, (dab.pos.y - sprite.get_height()/2) * size);
-                clTexCoord2d(0.0, 0.0);
-                clVertex2f((dab.pos.x + sprite.get_width()/2) * size, (dab.pos.y - sprite.get_height()/2) * size);
-                clTexCoord2d(1.0, 0.0);
-                clVertex2f((dab.pos.x + sprite.get_width()/2) * size, (dab.pos.y + sprite.get_height()/2) * size);
-                clTexCoord2d(1.0, 1.0);
-                clVertex2f((dab.pos.x - sprite.get_width()/2) * size, (dab.pos.y + sprite.get_height()/2) * size);
-                clTexCoord2d(0.0, 1.0);
-                clEnd();
-            
-                state.set_active();
-                clUseProgram(0);
-#endif
-              }
-              break;
-              
-            default:
-              std::cout &lt;&lt; &quot;Error: SpriteStrokeDrawer: Unknown draw mode: &quot; &lt;&lt; mode &lt;&lt; std::endl;
-              break;
-            }
-        }
-      else
-        {
-          switch (mode)
-            {
-            case SpriteStrokeDrawer::DM_NORMAL:  
-              sprite.set_blend_func(blend_src_alpha, blend_one_minus_src_alpha);
-              sprite.draw(dab.pos.x, dab.pos.y, gc);
-              break;
-              
-            case SpriteStrokeDrawer::DM_ADDITION:
-              sprite.set_blend_func(blend_src_alpha, blend_one);
-              sprite.draw(dab.pos.x, dab.pos.y, gc); 
-              break;
-            
-            case SpriteStrokeDrawer::DM_ERASE:
-              sprite.set_blend_func(blend_zero, blend_one_minus_src_alpha);
-              sprite.draw(dab.pos.x, dab.pos.y, gc);
-              break; 
-          
-            case SpriteStrokeDrawer::DM_SMUDGE:
-              sprite.set_blend_func(blend_src_alpha, blend_one_minus_src_alpha);
-              sprite.draw(dab.pos.x, dab.pos.y, gc);          
-              break;
-
-            default:
-              std::cout &lt;&lt; &quot;Error: SpriteStrokeDrawer: Unknown draw mode: &quot; &lt;&lt; mode &lt;&lt; std::endl;
-              break;
-            }
-        }
-    }
-}
-
-void
-SpriteStrokeDrawer::set_mode(DrawMode mode)
-{
-  impl-&gt;mode = mode;
-}
-
-SpriteStrokeDrawer::DrawMode
-SpriteStrokeDrawer::get_mode()
-{
-  return impl-&gt;mode;
-}
-
-StrokeDrawerImpl*
-SpriteStrokeDrawerImpl::clone() const
-{
-  SpriteStrokeDrawerImpl* drawer = new SpriteStrokeDrawerImpl();
-  
-  *drawer = *this;
-    
-  return drawer;
-}
-
-StrokeDrawer
-SpriteStrokeDrawer::to_drawer()
-{
-  return StrokeDrawer(impl);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/sprite_stroke_drawer.hpp (from rev 712, trunk/flexlay/lib/sprite_stroke_drawer.hxx)
===================================================================
--- trunk/flexlay/lib/sprite_stroke_drawer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sprite_stroke_drawer.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,50 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_SPRITE_STROKE_DRAWER_HXX
+#define HEADER_SPRITE_STROKE_DRAWER_HXX
+
+#include &lt;ClanLib/Display/color.h&gt;
+#include &lt;ClanLib/Display/sprite.h&gt;
+#include &quot;stroke_drawer.hpp&quot;
+#include &quot;brush.hpp&quot;
+
+class Stroke;
+class SpriteStrokeDrawerImpl;
+
+/** */
+class SpriteStrokeDrawer
+{
+public:
+  enum DrawMode { DM_NORMAL, DM_ERASE, DM_ADDITION, DM_SHADER, DM_SMUDGE  };
+
+  SpriteStrokeDrawer(StrokeDrawer drawer);
+  SpriteStrokeDrawer();
+
+  /** The modus in which the drawing affects the image (normal, erase, addition, color, etc.) */
+  void set_mode(DrawMode mode);
+  DrawMode get_mode();
+
+  StrokeDrawer to_drawer();
+private:
+  SharedPtr&lt;SpriteStrokeDrawerImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/sprite_stroke_drawer.hxx
===================================================================
--- trunk/flexlay/lib/sprite_stroke_drawer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sprite_stroke_drawer.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,50 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_SPRITE_STROKE_DRAWER_HXX
-#define HEADER_SPRITE_STROKE_DRAWER_HXX
-
-#include &lt;ClanLib/Display/color.h&gt;
-#include &lt;ClanLib/Display/sprite.h&gt;
-#include &quot;stroke_drawer.hxx&quot;
-#include &quot;brush.hxx&quot;
-
-class Stroke;
-class SpriteStrokeDrawerImpl;
-
-/** */
-class SpriteStrokeDrawer
-{
-public:
-  enum DrawMode { DM_NORMAL, DM_ERASE, DM_ADDITION, DM_SHADER, DM_SMUDGE  };
-
-  SpriteStrokeDrawer(StrokeDrawer drawer);
-  SpriteStrokeDrawer();
-
-  /** The modus in which the drawing affects the image (normal, erase, addition, color, etc.) */
-  void set_mode(DrawMode mode);
-  DrawMode get_mode();
-
-  StrokeDrawer to_drawer();
-private:
-  SharedPtr&lt;SpriteStrokeDrawerImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/string_converter.hpp (from rev 712, trunk/flexlay/lib/string_converter.hxx)
===================================================================
--- trunk/flexlay/lib/string_converter.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/string_converter.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,61 @@
+//  $Id: string_converter.hpp,v 1.3 2003/11/04 22:48:51 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2000 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef STRINGCONVERTER_HXX
+#define STRINGCONVERTER_HXX
+
+#include &lt;stdexcept&gt;
+#include &lt;sstream&gt;
+#include &quot;config.h&quot;
+
+template &lt;class T&gt;
+std::string to_string(const T&amp; any)
+{
+  std::ostringstream oss;
+  oss &lt;&lt; any;
+  return oss.str();
+}
+
+template &lt;class T&gt;
+bool from_string(const std::string&amp; rep, T&amp; x)
+{
+  // this is necessary so that if &quot;x&quot; is not modified if the conversion fails
+  T temp;
+  std::istringstream iss(rep);
+
+  iss &gt;&gt; temp;
+
+  if (iss.fail()) {
+    return false;
+  } else {
+    x = temp;
+    return true;
+  }
+}
+
+inline bool has_suffix(const std::string&amp; data, const std::string&amp; suffix)
+{
+  if (data.length() &gt;= suffix.length())
+    return data.compare(data.length() - suffix.length(), suffix.length(), suffix) == 0;
+  else
+    return false;
+}
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/string_converter.hxx
===================================================================
--- trunk/flexlay/lib/string_converter.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/string_converter.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,61 +0,0 @@
-//  $Id: string_converter.hxx,v 1.3 2003/11/04 22:48:51 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2000 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef STRINGCONVERTER_HXX
-#define STRINGCONVERTER_HXX
-
-#include &lt;stdexcept&gt;
-#include &lt;sstream&gt;
-#include &quot;config.h&quot;
-
-template &lt;class T&gt;
-std::string to_string(const T&amp; any)
-{
-  std::ostringstream oss;
-  oss &lt;&lt; any;
-  return oss.str();
-}
-
-template &lt;class T&gt;
-bool from_string(const std::string&amp; rep, T&amp; x)
-{
-  // this is necessary so that if &quot;x&quot; is not modified if the conversion fails
-  T temp;
-  std::istringstream iss(rep);
-
-  iss &gt;&gt; temp;
-
-  if (iss.fail()) {
-    return false;
-  } else {
-    x = temp;
-    return true;
-  }
-}
-
-inline bool has_suffix(const std::string&amp; data, const std::string&amp; suffix)
-{
-  if (data.length() &gt;= suffix.length())
-    return data.compare(data.length() - suffix.length(), suffix.length(), suffix) == 0;
-  else
-    return false;
-}
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/stroke.cpp (from rev 712, trunk/flexlay/lib/stroke.cxx)
===================================================================
--- trunk/flexlay/lib/stroke.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/stroke.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,235 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &quot;stroke.hpp&quot;
+#include &quot;stroke_drawer.hpp&quot;
+
+class StrokeImpl
+{
+public:
+  Stroke::Dabs dabs;
+  StrokeDrawer drawer;
+
+  // Additional data which should be moved to the StrokeDrawer, since
+  // its for caching only and can be generated
+  //typedef std::vector&lt;CL_Pointf&gt; Normals;
+  //Normals normals;
+
+  mutable bool bounding_rect_needs_recalc;
+  mutable CL_Rectf bounding_rect;
+
+  CL_Rectf calc_bounding_rect() const
+  {
+    CL_Rectf rect;
+
+    // FIXME: Keep the drawer into account (ie. brushsize)
+    if (dabs.size() &gt; 0)
+      {
+        rect.left = rect.right  = dabs.front().pos.x;
+        rect.top  = rect.bottom = dabs.front().pos.y;
+
+        for(Stroke::Dabs::const_iterator i = dabs.begin()+1; i != dabs.end(); ++i)
+          {
+            rect.left = std::min(i-&gt;pos.x, rect.left);
+            rect.top  = std::min(i-&gt;pos.y, rect.top);
+
+            rect.right  = std::max(i-&gt;pos.x, rect.right);
+            rect.bottom = std::max(i-&gt;pos.y, rect.bottom);
+          }
+      }
+    
+    return rect;
+  }
+
+  StrokeImpl() 
+    : bounding_rect_needs_recalc(true)
+  {
+  }
+};
+
+Stroke::Stroke() 
+  : impl(new StrokeImpl())
+{
+}
+
+void
+Stroke::set_drawer(const StrokeDrawer&amp; drawer_)
+{
+  impl-&gt;drawer = drawer_;
+}
+
+StrokeDrawer
+Stroke::get_drawer()
+{
+  return impl-&gt;drawer;
+}
+
+Stroke::Dabs
+Stroke::get_interpolated_dabs(float x_spacing, float y_spacing) const
+{
+  if (impl-&gt;dabs.size() &gt; 0)
+    {
+      Dabs interpolated_dabs;
+
+      interpolated_dabs.push_back(impl-&gt;dabs.front());
+
+      // The following code basically takes all the event dabs as recieved
+      // by from the InputDevice and interpolates new dabs inbetween to
+      // give them an equal spacing (ie. every dab is only 'spacing' away
+      // from the next)
+      float overspace = 0.0f;
+      const Stroke::Dabs&amp; dabs = impl-&gt;dabs;
+      for(unsigned int j = 0; j &lt; dabs.size()-1; ++j)
+        {
+          CL_Pointf dist = dabs[j+1].pos - dabs[j].pos;
+          float length = sqrt(dist.x * dist.x + dist.y * dist.y);
+          int n = 1;
+    
+          // Spacing is keep relative to the brush size
+          // FIXME: This is specific to a Sprite based drawer, might not work for others
+          // FIXME: y_spacing isn't taken into account either
+          float local_spacing = x_spacing * dabs[j].pressure;
+
+          while (length + overspace &gt; (local_spacing * n))
+            {
+              float factor = (local_spacing/length) * n - (overspace/length);
+          
+              // FIXME: Interpolate tilting, pressure, etc. along the line
+              interpolated_dabs.push_back(Dab(dabs[j].pos.x + dist.x * factor,
+                                              dabs[j].pos.y + dist.y * factor,
+                                              dabs[j].pressure));
+              n += 1;
+            }
+
+          // calculate the space that wasn't used in the last iteration
+          overspace = (length + overspace) - (local_spacing * (n-1));
+        }
+      return interpolated_dabs;
+    }
+  else
+    {
+      // No dabs available, so nothing to interpolate
+      return impl-&gt;dabs;
+    }
+}
+
+Stroke::Dabs
+Stroke::get_dabs() const
+{
+  return impl-&gt;dabs; 
+}
+
+int
+Stroke::get_dab_count() const
+{
+  return impl-&gt;dabs.size();
+}
+
+void 
+Stroke::draw(CL_GraphicContext* gc) const
+{
+  if (!impl-&gt;drawer.is_null())
+    {
+      const_cast&lt;StrokeDrawer&amp;&gt;(impl-&gt;drawer).draw(*this, gc);
+    }
+  else
+    {
+      std::cout &lt;&lt; &quot;No drawer set!&quot; &lt;&lt; std::endl;
+    }
+}
+
+void
+Stroke::add_dab(const Dab&amp; dab) 
+{
+  impl-&gt;dabs.push_back(dab);
+}
+
+/* // calc normals
+  assert(normals.size() == 0);
+
+  if (points.size() == 1)
+    {
+      normals.push_back(CL_Pointf(1.0f, 1.0f));
+    }
+  else if (points.size() == 2)
+    {
+      normals.push_back(CL_Pointf(1.0f, 1.0f));
+      normals.push_back(CL_Pointf(1.0f, 1.0f));
+    }
+  else if (points.size() &gt;= 3)
+    {
+      for(Points::size_type i = 0; i &lt; int(points.size())-1; ++i)
+        {
+          CL_Pointf normal((points[i].y - points[i+1].y),
+                           -(points[i].x - points[i+1].x));
+
+          float length = sqrt(normal.x * normal.x + normal.y * normal.y);
+
+          normal.x /= length;
+          normal.y /= length;
+          
+          normals.push_back(normal);
+        }
+      
+      normals.push_back(CL_Pointf(1.0f, 1.0f));
+    }
+
+  //std::cout &lt;&lt; normals.size() &lt;&lt; &quot; == &quot; &lt;&lt;  points.size() &lt;&lt; std::endl;
+  assert(normals.size() == points.size());
+
+ */
+
+/*
+  // Calc bounding rect
+  if (points.size() &gt;= 1)
+    {
+      bounding_rect.left = bounding_rect.right  = points.front().x;
+      bounding_rect.top  = bounding_rect.bottom = points.front().y;
+
+      for(Points::iterator i = points.begin()+1; i != points.end(); ++i)
+        {
+          bounding_rect.left   = Math::min(bounding_rect.left,   i-&gt;x);
+          bounding_rect.right  = Math::max(bounding_rect.right,  i-&gt;x);;
+          bounding_rect.top    = Math::min(bounding_rect.top,    i-&gt;y);
+          bounding_rect.bottom = Math::min(bounding_rect.bottom, i-&gt;y);
+        }
+
+      // FIXME: Need to take brush size into account
+    }
+*/
+
+CL_Rectf
+Stroke::get_bounding_rect() const
+{
+  if (impl-&gt;bounding_rect_needs_recalc)
+    {
+      impl-&gt;bounding_rect = impl-&gt;calc_bounding_rect();
+      impl-&gt;bounding_rect_needs_recalc = false;
+    }
+  
+  return impl-&gt;bounding_rect;
+}
+
+bool
+Stroke::empty() const
+{
+  return (impl-&gt;dabs.size() == 0);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/stroke.cxx
===================================================================
--- trunk/flexlay/lib/stroke.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/stroke.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,235 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &quot;stroke.hxx&quot;
-#include &quot;stroke_drawer.hxx&quot;
-
-class StrokeImpl
-{
-public:
-  Stroke::Dabs dabs;
-  StrokeDrawer drawer;
-
-  // Additional data which should be moved to the StrokeDrawer, since
-  // its for caching only and can be generated
-  //typedef std::vector&lt;CL_Pointf&gt; Normals;
-  //Normals normals;
-
-  mutable bool bounding_rect_needs_recalc;
-  mutable CL_Rectf bounding_rect;
-
-  CL_Rectf calc_bounding_rect() const
-  {
-    CL_Rectf rect;
-
-    // FIXME: Keep the drawer into account (ie. brushsize)
-    if (dabs.size() &gt; 0)
-      {
-        rect.left = rect.right  = dabs.front().pos.x;
-        rect.top  = rect.bottom = dabs.front().pos.y;
-
-        for(Stroke::Dabs::const_iterator i = dabs.begin()+1; i != dabs.end(); ++i)
-          {
-            rect.left = std::min(i-&gt;pos.x, rect.left);
-            rect.top  = std::min(i-&gt;pos.y, rect.top);
-
-            rect.right  = std::max(i-&gt;pos.x, rect.right);
-            rect.bottom = std::max(i-&gt;pos.y, rect.bottom);
-          }
-      }
-    
-    return rect;
-  }
-
-  StrokeImpl() 
-    : bounding_rect_needs_recalc(true)
-  {
-  }
-};
-
-Stroke::Stroke() 
-  : impl(new StrokeImpl())
-{
-}
-
-void
-Stroke::set_drawer(const StrokeDrawer&amp; drawer_)
-{
-  impl-&gt;drawer = drawer_;
-}
-
-StrokeDrawer
-Stroke::get_drawer()
-{
-  return impl-&gt;drawer;
-}
-
-Stroke::Dabs
-Stroke::get_interpolated_dabs(float x_spacing, float y_spacing) const
-{
-  if (impl-&gt;dabs.size() &gt; 0)
-    {
-      Dabs interpolated_dabs;
-
-      interpolated_dabs.push_back(impl-&gt;dabs.front());
-
-      // The following code basically takes all the event dabs as recieved
-      // by from the InputDevice and interpolates new dabs inbetween to
-      // give them an equal spacing (ie. every dab is only 'spacing' away
-      // from the next)
-      float overspace = 0.0f;
-      const Stroke::Dabs&amp; dabs = impl-&gt;dabs;
-      for(unsigned int j = 0; j &lt; dabs.size()-1; ++j)
-        {
-          CL_Pointf dist = dabs[j+1].pos - dabs[j].pos;
-          float length = sqrt(dist.x * dist.x + dist.y * dist.y);
-          int n = 1;
-    
-          // Spacing is keep relative to the brush size
-          // FIXME: This is specific to a Sprite based drawer, might not work for others
-          // FIXME: y_spacing isn't taken into account either
-          float local_spacing = x_spacing * dabs[j].pressure;
-
-          while (length + overspace &gt; (local_spacing * n))
-            {
-              float factor = (local_spacing/length) * n - (overspace/length);
-          
-              // FIXME: Interpolate tilting, pressure, etc. along the line
-              interpolated_dabs.push_back(Dab(dabs[j].pos.x + dist.x * factor,
-                                              dabs[j].pos.y + dist.y * factor,
-                                              dabs[j].pressure));
-              n += 1;
-            }
-
-          // calculate the space that wasn't used in the last iteration
-          overspace = (length + overspace) - (local_spacing * (n-1));
-        }
-      return interpolated_dabs;
-    }
-  else
-    {
-      // No dabs available, so nothing to interpolate
-      return impl-&gt;dabs;
-    }
-}
-
-Stroke::Dabs
-Stroke::get_dabs() const
-{
-  return impl-&gt;dabs; 
-}
-
-int
-Stroke::get_dab_count() const
-{
-  return impl-&gt;dabs.size();
-}
-
-void 
-Stroke::draw(CL_GraphicContext* gc) const
-{
-  if (!impl-&gt;drawer.is_null())
-    {
-      const_cast&lt;StrokeDrawer&amp;&gt;(impl-&gt;drawer).draw(*this, gc);
-    }
-  else
-    {
-      std::cout &lt;&lt; &quot;No drawer set!&quot; &lt;&lt; std::endl;
-    }
-}
-
-void
-Stroke::add_dab(const Dab&amp; dab) 
-{
-  impl-&gt;dabs.push_back(dab);
-}
-
-/* // calc normals
-  assert(normals.size() == 0);
-
-  if (points.size() == 1)
-    {
-      normals.push_back(CL_Pointf(1.0f, 1.0f));
-    }
-  else if (points.size() == 2)
-    {
-      normals.push_back(CL_Pointf(1.0f, 1.0f));
-      normals.push_back(CL_Pointf(1.0f, 1.0f));
-    }
-  else if (points.size() &gt;= 3)
-    {
-      for(Points::size_type i = 0; i &lt; int(points.size())-1; ++i)
-        {
-          CL_Pointf normal((points[i].y - points[i+1].y),
-                           -(points[i].x - points[i+1].x));
-
-          float length = sqrt(normal.x * normal.x + normal.y * normal.y);
-
-          normal.x /= length;
-          normal.y /= length;
-          
-          normals.push_back(normal);
-        }
-      
-      normals.push_back(CL_Pointf(1.0f, 1.0f));
-    }
-
-  //std::cout &lt;&lt; normals.size() &lt;&lt; &quot; == &quot; &lt;&lt;  points.size() &lt;&lt; std::endl;
-  assert(normals.size() == points.size());
-
- */
-
-/*
-  // Calc bounding rect
-  if (points.size() &gt;= 1)
-    {
-      bounding_rect.left = bounding_rect.right  = points.front().x;
-      bounding_rect.top  = bounding_rect.bottom = points.front().y;
-
-      for(Points::iterator i = points.begin()+1; i != points.end(); ++i)
-        {
-          bounding_rect.left   = Math::min(bounding_rect.left,   i-&gt;x);
-          bounding_rect.right  = Math::max(bounding_rect.right,  i-&gt;x);;
-          bounding_rect.top    = Math::min(bounding_rect.top,    i-&gt;y);
-          bounding_rect.bottom = Math::min(bounding_rect.bottom, i-&gt;y);
-        }
-
-      // FIXME: Need to take brush size into account
-    }
-*/
-
-CL_Rectf
-Stroke::get_bounding_rect() const
-{
-  if (impl-&gt;bounding_rect_needs_recalc)
-    {
-      impl-&gt;bounding_rect = impl-&gt;calc_bounding_rect();
-      impl-&gt;bounding_rect_needs_recalc = false;
-    }
-  
-  return impl-&gt;bounding_rect;
-}
-
-bool
-Stroke::empty() const
-{
-  return (impl-&gt;dabs.size() == 0);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/stroke.hpp (from rev 712, trunk/flexlay/lib/stroke.hxx)
===================================================================
--- trunk/flexlay/lib/stroke.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/stroke.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,99 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_STROKE_HXX
+#define HEADER_STROKE_HXX
+
+#include &lt;vector&gt;
+#include &lt;ClanLib/Core/Math/point.h&gt;
+#include &lt;ClanLib/Core/Math/rect.h&gt;
+#include &lt;ClanLib/Core/System/system.h&gt;
+#include &quot;shared_ptr.hpp&quot;
+
+class StrokeImpl;
+class StrokeDrawer;
+class CL_GraphicContext;
+
+/** A dab is basically an event send from the mouse to the drawing
+    canvas, it consists of time, position, tilt, pressure and possible
+    additional information that is needed */
+class Dab
+{
+public:
+  /** Time at which the dot was placed */
+  unsigned int time;
+
+  /** Position at which the dot is placed */
+  CL_Pointf pos;
+
+  /** The pressure with which the dot was drawn (can be interpreted as
+      size, opacity or similar things by the StrokeDrawer */
+  float pressure;
+
+  /** Tilting of the pen while painting the dot */
+  CL_Pointf tilt;
+
+  Dab()
+    : time(CL_System::get_time()), pos(0, 0), pressure(1.0f), tilt(0, 0)
+  {}
+
+  Dab(float x, float y) 
+    : time(CL_System::get_time()), pos(x, y), pressure(1.0f), tilt(0.0f, 0.0f)
+  {}
+
+  Dab(float x_, float y_, float pressure_)
+    : time(CL_System::get_time()), pos(x_, y_), pressure(pressure_), tilt(0.0f, 0.0f)
+  {}
+};
+
+/** A Stroke is a series of Dabs */
+class Stroke
+{
+public:
+  typedef std::vector&lt;Dab&gt; Dabs;
+  
+  Stroke();
+
+  /** Return true if the Stroke doesn't contain any dabs */
+  bool empty() const;
+
+  void draw(CL_GraphicContext* gc) const;
+
+  void  set_drawer(const StrokeDrawer&amp; drawer_);
+  StrokeDrawer get_drawer();
+  void  add_dab(const Dab&amp; dab);
+  
+  /** Returns the real dabs as recieved by the InputDevice */
+  Dabs  get_dabs()  const;
+
+  /** Returns interpolated dabs, meaning the holes in get_dabs() are
+      closed with interpolated dabs so that all dabs are equally
+      spread (ie. every dab is 'spacing' away from the next) */
+  Dabs  get_interpolated_dabs(float x_spacing, float y_spacing) const;
+
+  int get_dab_count() const;
+
+  CL_Rectf get_bounding_rect() const;
+private:
+  SharedPtr&lt;StrokeImpl&gt; impl;
+};
+
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/stroke.hxx
===================================================================
--- trunk/flexlay/lib/stroke.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/stroke.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,99 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_STROKE_HXX
-#define HEADER_STROKE_HXX
-
-#include &lt;vector&gt;
-#include &lt;ClanLib/Core/Math/point.h&gt;
-#include &lt;ClanLib/Core/Math/rect.h&gt;
-#include &lt;ClanLib/Core/System/system.h&gt;
-#include &quot;shared_ptr.hxx&quot;
-
-class StrokeImpl;
-class StrokeDrawer;
-class CL_GraphicContext;
-
-/** A dab is basically an event send from the mouse to the drawing
-    canvas, it consists of time, position, tilt, pressure and possible
-    additional information that is needed */
-class Dab
-{
-public:
-  /** Time at which the dot was placed */
-  unsigned int time;
-
-  /** Position at which the dot is placed */
-  CL_Pointf pos;
-
-  /** The pressure with which the dot was drawn (can be interpreted as
-      size, opacity or similar things by the StrokeDrawer */
-  float pressure;
-
-  /** Tilting of the pen while painting the dot */
-  CL_Pointf tilt;
-
-  Dab()
-    : time(CL_System::get_time()), pos(0, 0), pressure(1.0f), tilt(0, 0)
-  {}
-
-  Dab(float x, float y) 
-    : time(CL_System::get_time()), pos(x, y), pressure(1.0f), tilt(0.0f, 0.0f)
-  {}
-
-  Dab(float x_, float y_, float pressure_)
-    : time(CL_System::get_time()), pos(x_, y_), pressure(pressure_), tilt(0.0f, 0.0f)
-  {}
-};
-
-/** A Stroke is a series of Dabs */
-class Stroke
-{
-public:
-  typedef std::vector&lt;Dab&gt; Dabs;
-  
-  Stroke();
-
-  /** Return true if the Stroke doesn't contain any dabs */
-  bool empty() const;
-
-  void draw(CL_GraphicContext* gc) const;
-
-  void  set_drawer(const StrokeDrawer&amp; drawer_);
-  StrokeDrawer get_drawer();
-  void  add_dab(const Dab&amp; dab);
-  
-  /** Returns the real dabs as recieved by the InputDevice */
-  Dabs  get_dabs()  const;
-
-  /** Returns interpolated dabs, meaning the holes in get_dabs() are
-      closed with interpolated dabs so that all dabs are equally
-      spread (ie. every dab is 'spacing' away from the next) */
-  Dabs  get_interpolated_dabs(float x_spacing, float y_spacing) const;
-
-  int get_dab_count() const;
-
-  CL_Rectf get_bounding_rect() const;
-private:
-  SharedPtr&lt;StrokeImpl&gt; impl;
-};
-
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/stroke_drawer.cpp (from rev 712, trunk/flexlay/lib/stroke_drawer.cxx)
===================================================================
--- trunk/flexlay/lib/stroke_drawer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/stroke_drawer.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,46 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &quot;stroke.hpp&quot;
+#include &quot;stroke_drawer_impl.hpp&quot;
+#include &quot;stroke_drawer.hpp&quot;
+
+StrokeDrawer::StrokeDrawer()
+{
+}
+
+StrokeDrawer::StrokeDrawer(SharedPtr&lt;StrokeDrawerImpl&gt; impl_)
+  :impl(impl_)
+{
+  
+}
+
+void
+StrokeDrawer::draw(const Stroke&amp; stroke, CL_GraphicContext* gc)
+{
+  if (impl.get() != 0)
+    impl-&gt;draw(stroke, gc);
+}
+
+StrokeDrawer
+StrokeDrawer::clone() const
+{
+  return StrokeDrawer(impl-&gt;clone());
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/stroke_drawer.cxx
===================================================================
--- trunk/flexlay/lib/stroke_drawer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/stroke_drawer.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,46 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &quot;stroke.hxx&quot;
-#include &quot;stroke_drawer_impl.hxx&quot;
-#include &quot;stroke_drawer.hxx&quot;
-
-StrokeDrawer::StrokeDrawer()
-{
-}
-
-StrokeDrawer::StrokeDrawer(SharedPtr&lt;StrokeDrawerImpl&gt; impl_)
-  :impl(impl_)
-{
-  
-}
-
-void
-StrokeDrawer::draw(const Stroke&amp; stroke, CL_GraphicContext* gc)
-{
-  if (impl.get() != 0)
-    impl-&gt;draw(stroke, gc);
-}
-
-StrokeDrawer
-StrokeDrawer::clone() const
-{
-  return StrokeDrawer(impl-&gt;clone());
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/stroke_drawer.hpp (from rev 712, trunk/flexlay/lib/stroke_drawer.hxx)
===================================================================
--- trunk/flexlay/lib/stroke_drawer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/stroke_drawer.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,47 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_STROKE_DRAWER_HXX
+#define HEADER_STROKE_DRAWER_HXX
+
+#include &quot;shared_ptr.hpp&quot;
+
+class Stroke;
+class StrokeDrawerImpl;
+class CL_GraphicContext;
+
+/** Abstract class which handles the drawing of a Stroke
+ */
+class StrokeDrawer
+{
+private:
+public:
+  StrokeDrawer();
+  StrokeDrawer(SharedPtr&lt;StrokeDrawerImpl&gt; impl);
+  
+  void draw(const Stroke&amp; stroke, CL_GraphicContext* gc);
+
+  bool is_null() const { return !impl.get(); }
+  StrokeDrawer clone() const;
+public:
+  SharedPtr&lt;StrokeDrawerImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/stroke_drawer.hxx
===================================================================
--- trunk/flexlay/lib/stroke_drawer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/stroke_drawer.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,47 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_STROKE_DRAWER_HXX
-#define HEADER_STROKE_DRAWER_HXX
-
-#include &quot;shared_ptr.hxx&quot;
-
-class Stroke;
-class StrokeDrawerImpl;
-class CL_GraphicContext;
-
-/** Abstract class which handles the drawing of a Stroke
- */
-class StrokeDrawer
-{
-private:
-public:
-  StrokeDrawer();
-  StrokeDrawer(SharedPtr&lt;StrokeDrawerImpl&gt; impl);
-  
-  void draw(const Stroke&amp; stroke, CL_GraphicContext* gc);
-
-  bool is_null() const { return !impl.get(); }
-  StrokeDrawer clone() const;
-public:
-  SharedPtr&lt;StrokeDrawerImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/stroke_drawer_impl.hpp (from rev 712, trunk/flexlay/lib/stroke_drawer_impl.hxx)

Deleted: trunk/flexlay/lib/stroke_drawer_impl.hxx
===================================================================
--- trunk/flexlay/lib/stroke_drawer_impl.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/stroke_drawer_impl.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,39 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_STROKE_DRAWER_IMPL_HXX
-#define HEADER_STROKE_DRAWER_IMPL_HXX
-
-class CL_GraphicContext;
-class Stroke;
-
-/** Abstract class which handles the drawing of a Stroke
- */
-class StrokeDrawerImpl
-{
-private:
-public:
-  virtual ~StrokeDrawerImpl() {}
-
-  virtual void draw(const Stroke&amp; stroke, CL_GraphicContext* gc) =0;
-  virtual StrokeDrawerImpl* clone() const =0;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tile.cpp (from rev 712, trunk/flexlay/lib/tile.cxx)
===================================================================
--- trunk/flexlay/lib/tile.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,257 @@
+//  $Id: tile.cxx,v 1.4 2003/09/22 18:37:05 grumbel Exp $
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;ClanLib/Core/System/error.h&gt;
+#include &lt;ClanLib/Display/sprite_description.h&gt;
+#include &lt;ClanLib/Display/pixel_buffer.h&gt;
+#include &lt;ClanLib/Display/pixel_format.h&gt;
+#include &lt;ClanLib/Display/palette.h&gt;
+#include &lt;ClanLib/Display/Providers/provider_factory.h&gt;
+#include &lt;iostream&gt;
+#include &quot;string_converter.hpp&quot;
+#include &quot;tile_provider.hpp&quot;
+#include &quot;tile.hpp&quot;
+
+class TileImpl
+{
+public:
+  TileProvider   provider;
+
+  CL_Sprite      sprite;
+  CL_PixelBuffer pixelbuffer;
+
+  bool transparent;
+  bool has_color;
+
+  /** Color used for the minimap to represent this tile */
+  CL_Color  color;
+
+  /** Color used on 'Show Attributes', ie. to represent walkable areas
+      and such */
+  CL_Color  attribute_color;
+
+  // FIXME: old windstille stuff
+  unsigned char colmap[8];
+
+  std::string filename;
+};
+
+Tile::Tile(const TileProvider&amp; provider)
+  : impl(new TileImpl())
+{
+  impl-&gt;provider  = provider;
+  impl-&gt;has_color = false; 
+}
+
+Tile::Tile(const CL_PixelBuffer&amp; pixelbuffer,
+           const CL_Sprite&amp; sprite)
+  : impl(new TileImpl())
+{
+  impl-&gt;pixelbuffer = pixelbuffer;
+  impl-&gt;sprite      = sprite;
+  impl-&gt;has_color   = false;
+}
+
+Tile::Tile(const CL_PixelBuffer&amp; pixelbuffer)
+  : impl(new TileImpl())
+{
+  impl-&gt;pixelbuffer = pixelbuffer;
+  impl-&gt;has_color   = false;
+}
+
+Tile::Tile(const std::string&amp; filename_, 
+           const CL_Color&amp; attribute_color_)
+  : impl(new TileImpl())
+{
+  impl-&gt;has_color = false;
+  impl-&gt;attribute_color = attribute_color_;
+  impl-&gt;filename = filename_;
+}
+
+Tile::~Tile()
+{
+}
+
+CL_Color
+Tile::get_color()
+{
+  if (impl-&gt;has_color)
+    {
+      return impl-&gt;color;
+    }
+  else
+    {
+      impl-&gt;color = calc_color();
+      impl-&gt;has_color = true;
+      return impl-&gt;color;
+    }
+}
+
+CL_Color
+Tile::get_attribute_color()
+{
+  return impl-&gt;attribute_color;
+}
+
+CL_Sprite&amp;
+Tile::get_sprite()
+{
+  if (impl-&gt;sprite)
+    {
+      return impl-&gt;sprite;
+    }
+  else
+    {
+      if (impl-&gt;provider)
+        {
+          impl-&gt;sprite = impl-&gt;provider.get_sprite();
+        }
+      else
+        {
+          CL_SpriteDescription desc;
+          desc.add_frame(CL_PixelBuffer(get_pixelbuffer()));
+          impl-&gt;sprite = CL_Sprite(desc);
+        }
+
+      return impl-&gt;sprite;
+    }
+}
+
+CL_PixelBuffer
+Tile::get_pixelbuffer()
+{
+  if (impl-&gt;pixelbuffer)
+    {
+      return impl-&gt;pixelbuffer;
+    }
+  else 
+    {
+      if (impl-&gt;provider)
+        {
+          impl-&gt;pixelbuffer = impl-&gt;provider.get_pixelbuffer();
+          return impl-&gt;pixelbuffer;
+        }
+      else
+        {
+          // FIXME: Move all this into a special provider
+
+          try {
+            if (has_suffix(impl-&gt;filename, &quot;.png&quot;) || has_suffix(impl-&gt;filename, &quot;.jpg&quot;))
+              {
+                impl-&gt;pixelbuffer = CL_PixelBuffer(CL_ProviderFactory::load(impl-&gt;filename));
+              }
+            else
+              {
+                //CL_SpriteDescription descr(impl-&gt;filename, resources);
+                //impl-&gt;pixelbuffer = CL_PixelBuffer(*(descr.get_frames().begin()-&gt;first));
+                std::cout &lt;&lt; &quot;Error: not a png or jpg file: &quot; &lt;&lt; impl-&gt;filename &lt;&lt; std::endl;
+                assert(0);
+              }
+            return impl-&gt;pixelbuffer;
+          
+          } catch(CL_Error&amp; err) {
+            std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
+            std::cout &lt;&lt; &quot;          filename = &quot; &lt;&lt; impl-&gt;filename &lt;&lt; std::endl;
+            return CL_PixelBuffer();
+          }
+        }
+    }
+}
+
+CL_Color
+Tile::calc_color()
+{
+  CL_PixelBuffer buffer = get_pixelbuffer();
+  buffer.lock();
+  unsigned char* buf = static_cast&lt;unsigned char*&gt;(buffer.get_data());
+  int len = buffer.get_height() * buffer.get_width();
+
+  int red   = 0;
+  int green = 0;
+  int blue  = 0;
+  int alpha = 0;
+  
+  switch (buffer.get_format().get_depth())
+    {
+    case 8:
+      {
+        CL_Palette palette = buffer.get_palette();
+        for(int i = 0; i &lt; len; ++i)
+          {
+            red   += palette.colors[buf[i]].get_red();
+            green += palette.colors[buf[i]].get_green();
+            blue  += palette.colors[buf[i]].get_blue();
+            alpha += 255;
+          }
+      }
+      break;
+    case 24:
+      for(int i = 0; i &lt; len; ++i)
+        {
+          red   += buf[3*i + 0];
+          green += buf[3*i + 1];
+          blue  += buf[3*i + 2];
+          alpha += 255;
+        }
+      break;
+    case 32:
+      for(int i = 0; i &lt; len; ++i)
+        {
+          int a = buf[4*i + 0];
+          alpha += a;
+          red   += buf[4*i + 3]*a/255;;
+          green += buf[4*i + 2]*a/255;;
+          blue  += buf[4*i + 1]*a/255;;
+        }
+      break;
+    }
+
+  buffer.unlock();
+
+  return CL_Color(static_cast&lt;int&gt;(red   / len),
+                  static_cast&lt;int&gt;(green / len),
+                  static_cast&lt;int&gt;(blue  / len),
+                  static_cast&lt;int&gt;(alpha / len));
+}
+
+bool
+Tile::get_col(unsigned char x, unsigned char  y)
+{
+  assert(x &lt; 8);
+  assert(y &lt; 8);
+  return (impl-&gt;colmap[y] &amp; (1 &lt;&lt; (7-x)));
+}
+
+void
+Tile::set_col(unsigned char x, unsigned char  y, bool val)
+{
+  assert(x &lt; 8);
+  assert(y &lt; 8);
+  if (val)
+    impl-&gt;colmap[y] |= (1 &lt;&lt; (7-x));
+  else
+    impl-&gt;colmap[y] &amp;= ~(1 &lt;&lt; (7-x));
+}
+
+std::string
+Tile::get_filename() const
+{
+  return impl-&gt;filename; 
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tile.cxx
===================================================================
--- trunk/flexlay/lib/tile.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,257 +0,0 @@
-//  $Id: tile.cxx,v 1.4 2003/09/22 18:37:05 grumbel Exp $
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;ClanLib/Core/System/error.h&gt;
-#include &lt;ClanLib/Display/sprite_description.h&gt;
-#include &lt;ClanLib/Display/pixel_buffer.h&gt;
-#include &lt;ClanLib/Display/pixel_format.h&gt;
-#include &lt;ClanLib/Display/palette.h&gt;
-#include &lt;ClanLib/Display/Providers/provider_factory.h&gt;
-#include &lt;iostream&gt;
-#include &quot;string_converter.hxx&quot;
-#include &quot;tile_provider.hxx&quot;
-#include &quot;tile.hxx&quot;
-
-class TileImpl
-{
-public:
-  TileProvider   provider;
-
-  CL_Sprite      sprite;
-  CL_PixelBuffer pixelbuffer;
-
-  bool transparent;
-  bool has_color;
-
-  /** Color used for the minimap to represent this tile */
-  CL_Color  color;
-
-  /** Color used on 'Show Attributes', ie. to represent walkable areas
-      and such */
-  CL_Color  attribute_color;
-
-  // FIXME: old windstille stuff
-  unsigned char colmap[8];
-
-  std::string filename;
-};
-
-Tile::Tile(const TileProvider&amp; provider)
-  : impl(new TileImpl())
-{
-  impl-&gt;provider  = provider;
-  impl-&gt;has_color = false; 
-}
-
-Tile::Tile(const CL_PixelBuffer&amp; pixelbuffer,
-           const CL_Sprite&amp; sprite)
-  : impl(new TileImpl())
-{
-  impl-&gt;pixelbuffer = pixelbuffer;
-  impl-&gt;sprite      = sprite;
-  impl-&gt;has_color   = false;
-}
-
-Tile::Tile(const CL_PixelBuffer&amp; pixelbuffer)
-  : impl(new TileImpl())
-{
-  impl-&gt;pixelbuffer = pixelbuffer;
-  impl-&gt;has_color   = false;
-}
-
-Tile::Tile(const std::string&amp; filename_, 
-           const CL_Color&amp; attribute_color_)
-  : impl(new TileImpl())
-{
-  impl-&gt;has_color = false;
-  impl-&gt;attribute_color = attribute_color_;
-  impl-&gt;filename = filename_;
-}
-
-Tile::~Tile()
-{
-}
-
-CL_Color
-Tile::get_color()
-{
-  if (impl-&gt;has_color)
-    {
-      return impl-&gt;color;
-    }
-  else
-    {
-      impl-&gt;color = calc_color();
-      impl-&gt;has_color = true;
-      return impl-&gt;color;
-    }
-}
-
-CL_Color
-Tile::get_attribute_color()
-{
-  return impl-&gt;attribute_color;
-}
-
-CL_Sprite&amp;
-Tile::get_sprite()
-{
-  if (impl-&gt;sprite)
-    {
-      return impl-&gt;sprite;
-    }
-  else
-    {
-      if (impl-&gt;provider)
-        {
-          impl-&gt;sprite = impl-&gt;provider.get_sprite();
-        }
-      else
-        {
-          CL_SpriteDescription desc;
-          desc.add_frame(CL_PixelBuffer(get_pixelbuffer()));
-          impl-&gt;sprite = CL_Sprite(desc);
-        }
-
-      return impl-&gt;sprite;
-    }
-}
-
-CL_PixelBuffer
-Tile::get_pixelbuffer()
-{
-  if (impl-&gt;pixelbuffer)
-    {
-      return impl-&gt;pixelbuffer;
-    }
-  else 
-    {
-      if (impl-&gt;provider)
-        {
-          impl-&gt;pixelbuffer = impl-&gt;provider.get_pixelbuffer();
-          return impl-&gt;pixelbuffer;
-        }
-      else
-        {
-          // FIXME: Move all this into a special provider
-
-          try {
-            if (has_suffix(impl-&gt;filename, &quot;.png&quot;) || has_suffix(impl-&gt;filename, &quot;.jpg&quot;))
-              {
-                impl-&gt;pixelbuffer = CL_PixelBuffer(CL_ProviderFactory::load(impl-&gt;filename));
-              }
-            else
-              {
-                //CL_SpriteDescription descr(impl-&gt;filename, resources);
-                //impl-&gt;pixelbuffer = CL_PixelBuffer(*(descr.get_frames().begin()-&gt;first));
-                std::cout &lt;&lt; &quot;Error: not a png or jpg file: &quot; &lt;&lt; impl-&gt;filename &lt;&lt; std::endl;
-                assert(0);
-              }
-            return impl-&gt;pixelbuffer;
-          
-          } catch(CL_Error&amp; err) {
-            std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
-            std::cout &lt;&lt; &quot;          filename = &quot; &lt;&lt; impl-&gt;filename &lt;&lt; std::endl;
-            return CL_PixelBuffer();
-          }
-        }
-    }
-}
-
-CL_Color
-Tile::calc_color()
-{
-  CL_PixelBuffer buffer = get_pixelbuffer();
-  buffer.lock();
-  unsigned char* buf = static_cast&lt;unsigned char*&gt;(buffer.get_data());
-  int len = buffer.get_height() * buffer.get_width();
-
-  int red   = 0;
-  int green = 0;
-  int blue  = 0;
-  int alpha = 0;
-  
-  switch (buffer.get_format().get_depth())
-    {
-    case 8:
-      {
-        CL_Palette palette = buffer.get_palette();
-        for(int i = 0; i &lt; len; ++i)
-          {
-            red   += palette.colors[buf[i]].get_red();
-            green += palette.colors[buf[i]].get_green();
-            blue  += palette.colors[buf[i]].get_blue();
-            alpha += 255;
-          }
-      }
-      break;
-    case 24:
-      for(int i = 0; i &lt; len; ++i)
-        {
-          red   += buf[3*i + 0];
-          green += buf[3*i + 1];
-          blue  += buf[3*i + 2];
-          alpha += 255;
-        }
-      break;
-    case 32:
-      for(int i = 0; i &lt; len; ++i)
-        {
-          int a = buf[4*i + 0];
-          alpha += a;
-          red   += buf[4*i + 3]*a/255;;
-          green += buf[4*i + 2]*a/255;;
-          blue  += buf[4*i + 1]*a/255;;
-        }
-      break;
-    }
-
-  buffer.unlock();
-
-  return CL_Color(static_cast&lt;int&gt;(red   / len),
-                  static_cast&lt;int&gt;(green / len),
-                  static_cast&lt;int&gt;(blue  / len),
-                  static_cast&lt;int&gt;(alpha / len));
-}
-
-bool
-Tile::get_col(unsigned char x, unsigned char  y)
-{
-  assert(x &lt; 8);
-  assert(y &lt; 8);
-  return (impl-&gt;colmap[y] &amp; (1 &lt;&lt; (7-x)));
-}
-
-void
-Tile::set_col(unsigned char x, unsigned char  y, bool val)
-{
-  assert(x &lt; 8);
-  assert(y &lt; 8);
-  if (val)
-    impl-&gt;colmap[y] |= (1 &lt;&lt; (7-x));
-  else
-    impl-&gt;colmap[y] &amp;= ~(1 &lt;&lt; (7-x));
-}
-
-std::string
-Tile::get_filename() const
-{
-  return impl-&gt;filename; 
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tile.hpp (from rev 712, trunk/flexlay/lib/tile.hxx)
===================================================================
--- trunk/flexlay/lib/tile.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,71 @@
+//  $Id: tile.hpp,v 1.6 2003/09/22 18:37:05 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_TILE_HXX
+#define HEADER_TILE_HXX
+
+#include &lt;assert.h&gt;
+#include &lt;ClanLib/Display/sprite.h&gt;
+#include &lt;ClanLib/Display/pixel_buffer.h&gt;
+#include &quot;shared_ptr.hpp&quot;
+
+class TileImpl;
+class TileProvider;
+
+/** A Tile is a surface or sprite together with meta information for
+    collision (aka colmap), walkability or such. */
+class Tile
+{
+public:
+  Tile(const TileProvider&amp; provider);
+  
+  Tile(const CL_PixelBuffer&amp; pixelbuffer);
+
+  Tile(const CL_PixelBuffer&amp; pixelbuffer,
+       const CL_Sprite&amp; sprite);
+
+  /** @param filename Surface to use 
+   *  @param arg_colmap a 8 char long array */
+  Tile(const std::string&amp; filename, 
+       const CL_Color&amp; attribute_color);
+  ~Tile();
+
+  CL_Sprite&amp; get_sprite();
+
+  /** Return a pixelbuffer associated with this tile, caller must not
+      delete the pixelbuffer, the Tile will take care of that */
+  CL_PixelBuffer get_pixelbuffer();
+
+  // FIXME: Document all those functions
+  CL_Color   get_color();
+  CL_Color   get_attribute_color();
+
+  std::string get_filename() const;
+
+  bool get_col(unsigned char x, unsigned char  y);
+  void set_col(unsigned char x, unsigned char  y, bool val);
+
+  CL_Color calc_color();
+
+private:
+  SharedPtr&lt;TileImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tile.hxx
===================================================================
--- trunk/flexlay/lib/tile.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,71 +0,0 @@
-//  $Id: tile.hxx,v 1.6 2003/09/22 18:37:05 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_TILE_HXX
-#define HEADER_TILE_HXX
-
-#include &lt;assert.h&gt;
-#include &lt;ClanLib/Display/sprite.h&gt;
-#include &lt;ClanLib/Display/pixel_buffer.h&gt;
-#include &quot;shared_ptr.hxx&quot;
-
-class TileImpl;
-class TileProvider;
-
-/** A Tile is a surface or sprite together with meta information for
-    collision (aka colmap), walkability or such. */
-class Tile
-{
-public:
-  Tile(const TileProvider&amp; provider);
-  
-  Tile(const CL_PixelBuffer&amp; pixelbuffer);
-
-  Tile(const CL_PixelBuffer&amp; pixelbuffer,
-       const CL_Sprite&amp; sprite);
-
-  /** @param filename Surface to use 
-   *  @param arg_colmap a 8 char long array */
-  Tile(const std::string&amp; filename, 
-       const CL_Color&amp; attribute_color);
-  ~Tile();
-
-  CL_Sprite&amp; get_sprite();
-
-  /** Return a pixelbuffer associated with this tile, caller must not
-      delete the pixelbuffer, the Tile will take care of that */
-  CL_PixelBuffer get_pixelbuffer();
-
-  // FIXME: Document all those functions
-  CL_Color   get_color();
-  CL_Color   get_attribute_color();
-
-  std::string get_filename() const;
-
-  bool get_col(unsigned char x, unsigned char  y);
-  void set_col(unsigned char x, unsigned char  y, bool val);
-
-  CL_Color calc_color();
-
-private:
-  SharedPtr&lt;TileImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tile_brush.cpp (from rev 712, trunk/flexlay/lib/tile_brush.cxx)
===================================================================
--- trunk/flexlay/lib/tile_brush.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_brush.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,105 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;ClanLib/Core/Math/rect.h&gt;
+#include &lt;iostream&gt;
+#include &lt;ClanLib/Core/core_iostream.h&gt;
+#include &quot;tile_brush.hpp&quot;
+
+TileBrush::TileBrush()
+{
+  opaque = false;
+}
+
+TileBrush::TileBrush(const Field&lt;int&gt;&amp; f, int w, int h, int pos_x, int pos_y)
+  : data(f, w, h, pos_x, pos_y)
+{
+  opaque = false;
+}
+
+TileBrush::TileBrush(int w, int h)
+  : data(w, h)
+{
+  opaque = false;
+}
+
+void
+TileBrush::auto_crop()
+{
+  CL_Rect rect(CL_Point(0, 0), CL_Size(0, 0));
+
+  for(int y = 0; y &lt; get_height(); ++y)
+    for(int x = 0; x &lt; get_width(); ++x)
+      if (at(x, y) != 0)
+        {
+          rect.top = y;
+          goto bottom;
+        }
+
+ bottom:
+  for(int y = get_height()-1; y &gt;= 0; --y)
+    for(int x = 0; x &lt; get_width(); ++x)
+      if (at(x, y) != 0)
+        {
+          rect.bottom = y + 1;
+          goto left;
+        }
+
+ left:
+  for(int x = 0; x &lt; get_width(); ++x)
+    for(int y = 0; y &lt; get_height(); ++y)
+      if (at(x, y) != 0)
+        {
+          rect.left = x;
+          goto right;
+        }
+
+ right:
+  for(int x = get_width() - 1; x &gt;= 0; --x)
+    for(int y = 0; y &lt; get_height(); ++y)
+      if (at(x, y) != 0)
+        {
+          rect.right = x + 1;
+          goto end;
+        }
+
+ end:
+  if (rect.get_width() != 0)
+    resize(rect.get_width(), rect.get_height(), 
+           -rect.left, -rect.top);
+  else
+    {
+      (*this) = TileBrush(1, 1);
+      at(0, 0) = 0;
+      set_opaque();
+    }
+}
+
+void
+TileBrush::set_data(const std::vector&lt;int&gt;&amp; data_)
+{
+  return data.set_data(data_);
+}
+
+std::vector&lt;int&gt;
+TileBrush::get_data()
+{
+  return data.get_data();
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tile_brush.cxx
===================================================================
--- trunk/flexlay/lib/tile_brush.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_brush.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,105 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;ClanLib/Core/Math/rect.h&gt;
-#include &lt;iostream&gt;
-#include &lt;ClanLib/Core/core_iostream.h&gt;
-#include &quot;tile_brush.hxx&quot;
-
-TileBrush::TileBrush()
-{
-  opaque = false;
-}
-
-TileBrush::TileBrush(const Field&lt;int&gt;&amp; f, int w, int h, int pos_x, int pos_y)
-  : data(f, w, h, pos_x, pos_y)
-{
-  opaque = false;
-}
-
-TileBrush::TileBrush(int w, int h)
-  : data(w, h)
-{
-  opaque = false;
-}
-
-void
-TileBrush::auto_crop()
-{
-  CL_Rect rect(CL_Point(0, 0), CL_Size(0, 0));
-
-  for(int y = 0; y &lt; get_height(); ++y)
-    for(int x = 0; x &lt; get_width(); ++x)
-      if (at(x, y) != 0)
-        {
-          rect.top = y;
-          goto bottom;
-        }
-
- bottom:
-  for(int y = get_height()-1; y &gt;= 0; --y)
-    for(int x = 0; x &lt; get_width(); ++x)
-      if (at(x, y) != 0)
-        {
-          rect.bottom = y + 1;
-          goto left;
-        }
-
- left:
-  for(int x = 0; x &lt; get_width(); ++x)
-    for(int y = 0; y &lt; get_height(); ++y)
-      if (at(x, y) != 0)
-        {
-          rect.left = x;
-          goto right;
-        }
-
- right:
-  for(int x = get_width() - 1; x &gt;= 0; --x)
-    for(int y = 0; y &lt; get_height(); ++y)
-      if (at(x, y) != 0)
-        {
-          rect.right = x + 1;
-          goto end;
-        }
-
- end:
-  if (rect.get_width() != 0)
-    resize(rect.get_width(), rect.get_height(), 
-           -rect.left, -rect.top);
-  else
-    {
-      (*this) = TileBrush(1, 1);
-      at(0, 0) = 0;
-      set_opaque();
-    }
-}
-
-void
-TileBrush::set_data(const std::vector&lt;int&gt;&amp; data_)
-{
-  return data.set_data(data_);
-}
-
-std::vector&lt;int&gt;
-TileBrush::get_data()
-{
-  return data.get_data();
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tile_brush.hpp (from rev 712, trunk/flexlay/lib/tile_brush.hxx)
===================================================================
--- trunk/flexlay/lib/tile_brush.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_brush.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,63 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_EDITOR_TILE_BRUSH_HXX
+#define HEADER_EDITOR_TILE_BRUSH_HXX
+
+#include &quot;field.hpp&quot;
+
+/** */
+class TileBrush
+{
+private:
+  Field&lt;int&gt; data;
+
+  /** if true transparent tiles are drawn the same as opaque tiles, ie
+      erasing tiles formaly on the map and replacing them. If false
+      transparent tiles are not drawn at all, thus letting the old
+      tiles stay in place */
+  bool opaque;
+
+public:
+  TileBrush();
+  TileBrush(int w, int h);
+  TileBrush(const Field&lt;int&gt;&amp; f, int w, int h, int pos_x, int pos_y);
+
+  int get_width() const  { return data.get_width(); }
+  int get_height() const { return data.get_height(); }
+
+  void set_data(const std::vector&lt;int&gt;&amp; data);
+  std::vector&lt;int&gt; get_data();
+
+  const int&amp; at(int x, int y) const { return data.at(x, y); }
+  int&amp; at(int x, int y) { return data.at(x, y); }
+
+  void resize(int w, int h, int pos_x = 0, int pos_y = 0) { data.resize(w, h, pos_x, pos_y); }
+
+  void set_opaque() { opaque = true; }
+  void set_transparent() { opaque = false; }
+
+  bool is_opaque() const { return opaque; }
+  
+  /** Removes unneeded transparent bordering */
+  void auto_crop();
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tile_brush.hxx
===================================================================
--- trunk/flexlay/lib/tile_brush.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_brush.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,63 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_EDITOR_TILE_BRUSH_HXX
-#define HEADER_EDITOR_TILE_BRUSH_HXX
-
-#include &quot;field.hxx&quot;
-
-/** */
-class TileBrush
-{
-private:
-  Field&lt;int&gt; data;
-
-  /** if true transparent tiles are drawn the same as opaque tiles, ie
-      erasing tiles formaly on the map and replacing them. If false
-      transparent tiles are not drawn at all, thus letting the old
-      tiles stay in place */
-  bool opaque;
-
-public:
-  TileBrush();
-  TileBrush(int w, int h);
-  TileBrush(const Field&lt;int&gt;&amp; f, int w, int h, int pos_x, int pos_y);
-
-  int get_width() const  { return data.get_width(); }
-  int get_height() const { return data.get_height(); }
-
-  void set_data(const std::vector&lt;int&gt;&amp; data);
-  std::vector&lt;int&gt; get_data();
-
-  const int&amp; at(int x, int y) const { return data.at(x, y); }
-  int&amp; at(int x, int y) { return data.at(x, y); }
-
-  void resize(int w, int h, int pos_x = 0, int pos_y = 0) { data.resize(w, h, pos_x, pos_y); }
-
-  void set_opaque() { opaque = true; }
-  void set_transparent() { opaque = false; }
-
-  bool is_opaque() const { return opaque; }
-  
-  /** Removes unneeded transparent bordering */
-  void auto_crop();
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tile_editor.cpp (from rev 712, trunk/flexlay/lib/tile_editor.cxx)
===================================================================
--- trunk/flexlay/lib/tile_editor.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_editor.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,139 @@
+//  $Id: tile_editor.cxx,v 1.1 2003/09/22 18:37:05 grumbel Exp $
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &lt;ClanLib/gui.h&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &lt;ClanLib/Display/keys.h&gt;
+#include &lt;ClanLib/Display/mouse.h&gt;
+#include &quot;tile.hpp&quot;
+#include &quot;globals.hpp&quot;
+#include &quot;tile_editor.hpp&quot;
+
+TileEditor::TileEditor(int x, int y, int w, int h, CL_Component* parent)
+  : CL_Component(CL_Rect(CL_Rect(CL_Point(x, y), 
+                                 CL_Size(w, h))), // FIXME: make this editable via script
+                 parent)
+{
+  tile = 0;
+  slots.connect(sig_paint(),      this, &amp;TileEditor::draw);
+  slots.connect(sig_mouse_move(), this, &amp;TileEditor::mouse_move);
+  slots.connect(sig_mouse_down(), this, &amp;TileEditor::mouse_down);
+  slots.connect(sig_mouse_up  (), this, &amp;TileEditor::mouse_up);
+}
+
+TileEditor::~TileEditor()
+{
+}
+  
+void
+TileEditor::draw()
+{
+  CL_Display::push_translate(get_screen_x(), get_screen_x());
+
+  //no_tile.draw(0, 0);
+  CL_Display::fill_rect(CL_Rect(0, 0, 32, 32), CL_Color(155, 0, 155));
+
+  if (tile)
+    {
+      tile-&gt;get_sprite().draw(0, 0);
+      CL_Display::flush();
+      for(int tile_y = 0; tile_y &lt; 8; ++tile_y)
+        for(int tile_x = 0; tile_x &lt; 8; ++tile_x)
+          {
+            if (tile-&gt;get_col(tile_x, tile_y))
+              {
+                CL_Display::fill_rect(CL_Rect(tile_x*16, tile_y*16,
+                                              tile_x*16 + 16, tile_y*16 + 16),
+                                      CL_Color(255, 0, 0, 128));
+              }
+          }
+      CL_Display::flush();
+      if (has_mouse_over())
+        {
+          CL_Display::fill_rect(CL_Rect(CL_Point(int(mouse_pos.x)/16 * 16, 
+                                                 int(mouse_pos.y)/16 * 16),
+                                        CL_Size(16, 16)),
+                                CL_Color(255, 255, 255, 128));
+        }
+    }
+  else
+    {
+    }
+
+  CL_Display::pop_modelview();
+}
+
+void
+TileEditor::mouse_move(const CL_InputEvent&amp; event)
+{
+  mouse_pos = event.mouse_pos;
+  
+  if (CL_Mouse::get_keycode(CL_MOUSE_LEFT))
+    paint(event.mouse_pos, true);
+  else if (CL_Mouse::get_keycode(CL_MOUSE_RIGHT))
+    paint(event.mouse_pos, false);
+}
+
+void
+TileEditor::mouse_down(const CL_InputEvent&amp; event)
+{
+  if (tile)
+    {
+      switch (event.id)
+        {
+        case CL_MOUSE_LEFT:
+          paint(event.mouse_pos, true);
+          break;
+              
+        case CL_MOUSE_RIGHT:
+          paint(event.mouse_pos, false);
+          break;
+        
+        }
+    }
+}
+
+void
+TileEditor::paint(CL_Point pos, bool val)
+{
+  if (tile)
+    {
+      int x = int(pos.x) / 16;
+      int y = int(pos.y) / 16;
+
+      if (x &gt;= 0 &amp;&amp; y &gt;= 0
+          &amp;&amp; x &lt; 8 &amp;&amp; y &lt; 8)
+        {
+          tile-&gt;set_col(x, y, val);
+        }
+    }
+}
+
+void
+TileEditor::mouse_up(const CL_InputEvent&amp; event)
+{
+}
+
+void
+TileEditor::set_tile(Tile* t)
+{
+  tile = t;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tile_editor.cxx
===================================================================
--- trunk/flexlay/lib/tile_editor.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_editor.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,139 +0,0 @@
-//  $Id: tile_editor.cxx,v 1.1 2003/09/22 18:37:05 grumbel Exp $
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &lt;ClanLib/gui.h&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-#include &lt;ClanLib/Display/keys.h&gt;
-#include &lt;ClanLib/Display/mouse.h&gt;
-#include &quot;tile.hxx&quot;
-#include &quot;globals.hxx&quot;
-#include &quot;tile_editor.hxx&quot;
-
-TileEditor::TileEditor(int x, int y, int w, int h, CL_Component* parent)
-  : CL_Component(CL_Rect(CL_Rect(CL_Point(x, y), 
-                                 CL_Size(w, h))), // FIXME: make this editable via script
-                 parent)
-{
-  tile = 0;
-  slots.connect(sig_paint(),      this, &amp;TileEditor::draw);
-  slots.connect(sig_mouse_move(), this, &amp;TileEditor::mouse_move);
-  slots.connect(sig_mouse_down(), this, &amp;TileEditor::mouse_down);
-  slots.connect(sig_mouse_up  (), this, &amp;TileEditor::mouse_up);
-}
-
-TileEditor::~TileEditor()
-{
-}
-  
-void
-TileEditor::draw()
-{
-  CL_Display::push_translate(get_screen_x(), get_screen_x());
-
-  //no_tile.draw(0, 0);
-  CL_Display::fill_rect(CL_Rect(0, 0, 32, 32), CL_Color(155, 0, 155));
-
-  if (tile)
-    {
-      tile-&gt;get_sprite().draw(0, 0);
-      CL_Display::flush();
-      for(int tile_y = 0; tile_y &lt; 8; ++tile_y)
-        for(int tile_x = 0; tile_x &lt; 8; ++tile_x)
-          {
-            if (tile-&gt;get_col(tile_x, tile_y))
-              {
-                CL_Display::fill_rect(CL_Rect(tile_x*16, tile_y*16,
-                                              tile_x*16 + 16, tile_y*16 + 16),
-                                      CL_Color(255, 0, 0, 128));
-              }
-          }
-      CL_Display::flush();
-      if (has_mouse_over())
-        {
-          CL_Display::fill_rect(CL_Rect(CL_Point(int(mouse_pos.x)/16 * 16, 
-                                                 int(mouse_pos.y)/16 * 16),
-                                        CL_Size(16, 16)),
-                                CL_Color(255, 255, 255, 128));
-        }
-    }
-  else
-    {
-    }
-
-  CL_Display::pop_modelview();
-}
-
-void
-TileEditor::mouse_move(const CL_InputEvent&amp; event)
-{
-  mouse_pos = event.mouse_pos;
-  
-  if (CL_Mouse::get_keycode(CL_MOUSE_LEFT))
-    paint(event.mouse_pos, true);
-  else if (CL_Mouse::get_keycode(CL_MOUSE_RIGHT))
-    paint(event.mouse_pos, false);
-}
-
-void
-TileEditor::mouse_down(const CL_InputEvent&amp; event)
-{
-  if (tile)
-    {
-      switch (event.id)
-        {
-        case CL_MOUSE_LEFT:
-          paint(event.mouse_pos, true);
-          break;
-              
-        case CL_MOUSE_RIGHT:
-          paint(event.mouse_pos, false);
-          break;
-        
-        }
-    }
-}
-
-void
-TileEditor::paint(CL_Point pos, bool val)
-{
-  if (tile)
-    {
-      int x = int(pos.x) / 16;
-      int y = int(pos.y) / 16;
-
-      if (x &gt;= 0 &amp;&amp; y &gt;= 0
-          &amp;&amp; x &lt; 8 &amp;&amp; y &lt; 8)
-        {
-          tile-&gt;set_col(x, y, val);
-        }
-    }
-}
-
-void
-TileEditor::mouse_up(const CL_InputEvent&amp; event)
-{
-}
-
-void
-TileEditor::set_tile(Tile* t)
-{
-  tile = t;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tile_editor.hpp (from rev 712, trunk/flexlay/lib/tile_editor.hxx)
===================================================================
--- trunk/flexlay/lib/tile_editor.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_editor.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,55 @@
+//  $Id: tile_editor.hpp,v 1.1 2003/09/22 18:37:05 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_TILE_EDITOR_HXX
+#define HEADER_TILE_EDITOR_HXX
+
+#include &lt;ClanLib/GUI/component.h&gt;
+#include &lt;ClanLib/Signals/slot_container.h&gt;
+#include &lt;ClanLib/Core/Math/point.h&gt;
+
+class Tile;
+
+/** */
+class TileEditor : public CL_Component
+{
+private:
+  Tile* tile;
+  CL_SlotContainer slots;
+  CL_Point mouse_pos;
+protected:
+  virtual ~TileEditor();
+public:
+  TileEditor(int x, int y, int w, int h, CL_Component* parent);
+  
+  void draw();
+  void mouse_move(const CL_InputEvent&amp; event);
+  void mouse_down(const CL_InputEvent&amp; event);
+  void mouse_up  (const CL_InputEvent&amp; event);
+
+  void set_tile(Tile* tile);
+private:
+  void paint(CL_Point pos, bool val);
+
+  TileEditor (const TileEditor&amp;);
+  TileEditor&amp; operator= (const TileEditor&amp;);
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tile_editor.hxx
===================================================================
--- trunk/flexlay/lib/tile_editor.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_editor.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,55 +0,0 @@
-//  $Id: tile_editor.hxx,v 1.1 2003/09/22 18:37:05 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_TILE_EDITOR_HXX
-#define HEADER_TILE_EDITOR_HXX
-
-#include &lt;ClanLib/GUI/component.h&gt;
-#include &lt;ClanLib/Signals/slot_container.h&gt;
-#include &lt;ClanLib/Core/Math/point.h&gt;
-
-class Tile;
-
-/** */
-class TileEditor : public CL_Component
-{
-private:
-  Tile* tile;
-  CL_SlotContainer slots;
-  CL_Point mouse_pos;
-protected:
-  virtual ~TileEditor();
-public:
-  TileEditor(int x, int y, int w, int h, CL_Component* parent);
-  
-  void draw();
-  void mouse_move(const CL_InputEvent&amp; event);
-  void mouse_down(const CL_InputEvent&amp; event);
-  void mouse_up  (const CL_InputEvent&amp; event);
-
-  void set_tile(Tile* tile);
-private:
-  void paint(CL_Point pos, bool val);
-
-  TileEditor (const TileEditor&amp;);
-  TileEditor&amp; operator= (const TileEditor&amp;);
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tile_provider.cpp (from rev 712, trunk/flexlay/lib/tile_provider.cxx)
===================================================================
--- trunk/flexlay/lib/tile_provider.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_provider.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,39 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &quot;tile_provider_impl.hpp&quot;
+#include &quot;tile_provider.hpp&quot;
+
+TileProvider::TileProvider(TileProviderImpl* impl_)
+  : impl(impl_)
+{
+}
+
+CL_Sprite
+TileProvider::get_sprite() const
+{
+  return impl-&gt;get_sprite();
+}
+
+CL_PixelBuffer
+TileProvider::get_pixelbuffer() const
+{
+  return impl-&gt;get_pixelbuffer();
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tile_provider.cxx
===================================================================
--- trunk/flexlay/lib/tile_provider.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_provider.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,39 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &quot;tile_provider_impl.hxx&quot;
-#include &quot;tile_provider.hxx&quot;
-
-TileProvider::TileProvider(TileProviderImpl* impl_)
-  : impl(impl_)
-{
-}
-
-CL_Sprite
-TileProvider::get_sprite() const
-{
-  return impl-&gt;get_sprite();
-}
-
-CL_PixelBuffer
-TileProvider::get_pixelbuffer() const
-{
-  return impl-&gt;get_pixelbuffer();
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tile_provider.hpp (from rev 712, trunk/flexlay/lib/tile_provider.hxx)
===================================================================
--- trunk/flexlay/lib/tile_provider.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_provider.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,45 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_TILE_PROVIDER_HXX
+#define HEADER_TILE_PROVIDER_HXX
+
+#include &lt;ClanLib/Display/sprite.h&gt;
+#include &lt;ClanLib/Display/pixel_buffer.h&gt;
+#include &quot;shared_ptr.hpp&quot;
+
+class TileProviderImpl;
+
+/** TileProvider provides a flexible way to perform load-on-demand for Tiles */
+class TileProvider
+{
+public:
+  TileProvider() {}
+  TileProvider(TileProviderImpl* impl);
+
+  CL_Sprite      get_sprite() const;
+  CL_PixelBuffer get_pixelbuffer() const;
+
+  operator bool() const { return impl.get(); }
+private:
+  SharedPtr&lt;TileProviderImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tile_provider.hxx
===================================================================
--- trunk/flexlay/lib/tile_provider.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_provider.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,45 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_TILE_PROVIDER_HXX
-#define HEADER_TILE_PROVIDER_HXX
-
-#include &lt;ClanLib/Display/sprite.h&gt;
-#include &lt;ClanLib/Display/pixel_buffer.h&gt;
-#include &quot;shared_ptr.hxx&quot;
-
-class TileProviderImpl;
-
-/** TileProvider provides a flexible way to perform load-on-demand for Tiles */
-class TileProvider
-{
-public:
-  TileProvider() {}
-  TileProvider(TileProviderImpl* impl);
-
-  CL_Sprite      get_sprite() const;
-  CL_PixelBuffer get_pixelbuffer() const;
-
-  operator bool() const { return impl.get(); }
-private:
-  SharedPtr&lt;TileProviderImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tile_provider_impl.hpp (from rev 712, trunk/flexlay/lib/tile_provider_impl.hxx)

Deleted: trunk/flexlay/lib/tile_provider_impl.hxx
===================================================================
--- trunk/flexlay/lib/tile_provider_impl.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_provider_impl.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,38 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_TILE_PROVIDER_IMPL_HXX
-#define HEADER_TILE_PROVIDER_IMPL_HXX
-
-#include &lt;ClanLib/Display/sprite.h&gt;
-#include &lt;ClanLib/Display/pixel_buffer.h&gt;
-
-class TileProviderImpl
-{
-public:
-  TileProviderImpl() {}
-  virtual ~TileProviderImpl()
-  { }
-
-  virtual CL_Sprite      get_sprite()      const =0;
-  virtual CL_PixelBuffer get_pixelbuffer() const =0;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tile_selection.cpp (from rev 712, trunk/flexlay/lib/tile_selection.cxx)
===================================================================
--- trunk/flexlay/lib/tile_selection.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_selection.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,138 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;ClanLib/Display/display.h&gt;
+#include &lt;iostream&gt;
+#include &lt;ClanLib/Core/core_iostream.h&gt;
+#include &quot;math.hpp&quot;
+#include &quot;tilemap_layer.hpp&quot;
+#include &quot;tileset.hpp&quot;
+#include &quot;tile_selection.hpp&quot;
+
+class TileSelectionImpl
+{
+public:
+  TilemapLayer tilemap;
+  CL_Point start_pos;
+  CL_Rect  selection;
+  bool active;
+};
+
+TileSelection::TileSelection()
+  : impl(new TileSelectionImpl())
+{
+  impl-&gt;active = false;
+}
+
+TileSelection::~TileSelection()
+{
+}
+
+void
+TileSelection::start(TilemapLayer tilemap_, const CL_Point&amp; pos)
+{
+  impl-&gt;tilemap = tilemap_;
+  impl-&gt;active = true;
+  impl-&gt;start_pos = pos;
+  update(impl-&gt;start_pos);
+}
+
+void
+TileSelection::update(const CL_Point&amp; pos)
+{
+  impl-&gt;selection = CL_Rect(std::min(impl-&gt;start_pos.x, pos.x),
+                            std::min(impl-&gt;start_pos.y, pos.y),
+                            std::max(impl-&gt;start_pos.x, pos.x) + 1,
+                            std::max(impl-&gt;start_pos.y, pos.y) + 1);
+}
+
+bool
+TileSelection::is_active()
+{
+  return impl-&gt;active;
+}
+
+void
+TileSelection::clear()
+{
+  impl-&gt;selection = CL_Rect();
+  impl-&gt;active = false;
+}
+
+void
+TileSelection::draw(const CL_Color&amp; color)
+{
+  int tile_size = impl-&gt;tilemap.get_tileset().get_tile_size();
+
+  CL_Display::fill_rect(CL_Rect(impl-&gt;selection.left   * tile_size, 
+                                impl-&gt;selection.top    * tile_size,
+                                impl-&gt;selection.right  * tile_size, 
+                                impl-&gt;selection.bottom * tile_size),
+                        color);
+}
+
+TileBrush
+TileSelection::get_brush(const Field&lt;int&gt;&amp; field) const
+{
+  CL_Rect sel = impl-&gt;selection;
+
+  sel.normalize();
+
+  if (sel.left     &gt; field.get_width() - 1
+      || sel.top   &gt; field.get_height() - 1
+      || sel.right  &lt;= 0
+      || sel.bottom &lt;= 0)
+    { // Selection is empty
+      std::cout &lt;&lt; &quot;Error: Invalid selection&quot; &lt;&lt; std::endl;
+      TileBrush brush(1, 1);
+      brush.at(0, 0) = 0;
+      brush.set_opaque();
+      return brush;
+    }
+  else
+    { // Selection is valid
+      // Cut the selection to the field size
+      sel.left = Math::max(0, sel.left);
+      sel.top  = Math::max(0, sel.top);
+
+      sel.right  = Math::min(sel.right,  field.get_width()); 
+      sel.bottom = Math::min(sel.bottom, field.get_height()); 
+
+      TileBrush brush(sel.get_width(), 
+                      sel.get_height());
+
+      for(int y = sel.top; y &lt; sel.bottom; ++y)
+        for(int x = sel.left; x &lt; sel.right; ++x)
+          {
+            brush.at(x - sel.left, 
+                     y - sel.top) = field.at(x, y);
+          }
+
+      return brush;
+    }
+}
+
+CL_Rect
+TileSelection::get_rect() const
+{
+  CL_Rect sel = impl-&gt;selection;
+  sel.normalize();
+  return sel;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tile_selection.cxx
===================================================================
--- trunk/flexlay/lib/tile_selection.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_selection.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,138 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;ClanLib/Display/display.h&gt;
-#include &lt;iostream&gt;
-#include &lt;ClanLib/Core/core_iostream.h&gt;
-#include &quot;math.hxx&quot;
-#include &quot;tilemap_layer.hxx&quot;
-#include &quot;tileset.hxx&quot;
-#include &quot;tile_selection.hxx&quot;
-
-class TileSelectionImpl
-{
-public:
-  TilemapLayer tilemap;
-  CL_Point start_pos;
-  CL_Rect  selection;
-  bool active;
-};
-
-TileSelection::TileSelection()
-  : impl(new TileSelectionImpl())
-{
-  impl-&gt;active = false;
-}
-
-TileSelection::~TileSelection()
-{
-}
-
-void
-TileSelection::start(TilemapLayer tilemap_, const CL_Point&amp; pos)
-{
-  impl-&gt;tilemap = tilemap_;
-  impl-&gt;active = true;
-  impl-&gt;start_pos = pos;
-  update(impl-&gt;start_pos);
-}
-
-void
-TileSelection::update(const CL_Point&amp; pos)
-{
-  impl-&gt;selection = CL_Rect(std::min(impl-&gt;start_pos.x, pos.x),
-                            std::min(impl-&gt;start_pos.y, pos.y),
-                            std::max(impl-&gt;start_pos.x, pos.x) + 1,
-                            std::max(impl-&gt;start_pos.y, pos.y) + 1);
-}
-
-bool
-TileSelection::is_active()
-{
-  return impl-&gt;active;
-}
-
-void
-TileSelection::clear()
-{
-  impl-&gt;selection = CL_Rect();
-  impl-&gt;active = false;
-}
-
-void
-TileSelection::draw(const CL_Color&amp; color)
-{
-  int tile_size = impl-&gt;tilemap.get_tileset().get_tile_size();
-
-  CL_Display::fill_rect(CL_Rect(impl-&gt;selection.left   * tile_size, 
-                                impl-&gt;selection.top    * tile_size,
-                                impl-&gt;selection.right  * tile_size, 
-                                impl-&gt;selection.bottom * tile_size),
-                        color);
-}
-
-TileBrush
-TileSelection::get_brush(const Field&lt;int&gt;&amp; field) const
-{
-  CL_Rect sel = impl-&gt;selection;
-
-  sel.normalize();
-
-  if (sel.left     &gt; field.get_width() - 1
-      || sel.top   &gt; field.get_height() - 1
-      || sel.right  &lt;= 0
-      || sel.bottom &lt;= 0)
-    { // Selection is empty
-      std::cout &lt;&lt; &quot;Error: Invalid selection&quot; &lt;&lt; std::endl;
-      TileBrush brush(1, 1);
-      brush.at(0, 0) = 0;
-      brush.set_opaque();
-      return brush;
-    }
-  else
-    { // Selection is valid
-      // Cut the selection to the field size
-      sel.left = Math::max(0, sel.left);
-      sel.top  = Math::max(0, sel.top);
-
-      sel.right  = Math::min(sel.right,  field.get_width()); 
-      sel.bottom = Math::min(sel.bottom, field.get_height()); 
-
-      TileBrush brush(sel.get_width(), 
-                      sel.get_height());
-
-      for(int y = sel.top; y &lt; sel.bottom; ++y)
-        for(int x = sel.left; x &lt; sel.right; ++x)
-          {
-            brush.at(x - sel.left, 
-                     y - sel.top) = field.at(x, y);
-          }
-
-      return brush;
-    }
-}
-
-CL_Rect
-TileSelection::get_rect() const
-{
-  CL_Rect sel = impl-&gt;selection;
-  sel.normalize();
-  return sel;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tile_selection.hpp (from rev 712, trunk/flexlay/lib/tile_selection.hxx)
===================================================================
--- trunk/flexlay/lib/tile_selection.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_selection.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,57 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_TILE_SELECTION_HXX
+#define HEADER_TILE_SELECTION_HXX
+
+#include &lt;ClanLib/Core/Math/rect.h&gt;
+#include &lt;ClanLib/Display/color.h&gt;
+#include &lt;ClanLib/Core/Math/point.h&gt;
+#include &quot;tile_brush.hpp&quot;
+#include &quot;tilemap_layer.hpp&quot;
+
+class TileSelectionImpl;
+
+/** The TileSelection is a little helper class to manage rectangular
+    selections of tiles and provides a way to convert this selection
+    to a Brush which then can be used for either serialisation or be
+    used for painting on the map itself */
+class TileSelection
+{
+public:
+  TileSelection();
+  ~TileSelection();
+
+  void start (TilemapLayer tilemap, const CL_Point&amp; pos);
+  void update(const CL_Point&amp; pos);
+
+  void clear();
+  bool is_active();
+
+  CL_Rect get_rect() const;
+
+  void draw(const CL_Color&amp; color = CL_Color(255, 255, 255, 100));
+
+  TileBrush get_brush(const Field&lt;int&gt;&amp; field) const;
+private:
+  SharedPtr&lt;TileSelectionImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tile_selection.hxx
===================================================================
--- trunk/flexlay/lib/tile_selection.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_selection.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,57 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_TILE_SELECTION_HXX
-#define HEADER_TILE_SELECTION_HXX
-
-#include &lt;ClanLib/Core/Math/rect.h&gt;
-#include &lt;ClanLib/Display/color.h&gt;
-#include &lt;ClanLib/Core/Math/point.h&gt;
-#include &quot;tile_brush.hxx&quot;
-#include &quot;tilemap_layer.hxx&quot;
-
-class TileSelectionImpl;
-
-/** The TileSelection is a little helper class to manage rectangular
-    selections of tiles and provides a way to convert this selection
-    to a Brush which then can be used for either serialisation or be
-    used for painting on the map itself */
-class TileSelection
-{
-public:
-  TileSelection();
-  ~TileSelection();
-
-  void start (TilemapLayer tilemap, const CL_Point&amp; pos);
-  void update(const CL_Point&amp; pos);
-
-  void clear();
-  bool is_active();
-
-  CL_Rect get_rect() const;
-
-  void draw(const CL_Color&amp; color = CL_Color(255, 255, 255, 100));
-
-  TileBrush get_brush(const Field&lt;int&gt;&amp; field) const;
-private:
-  SharedPtr&lt;TileSelectionImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tile_selector.cpp (from rev 712, trunk/flexlay/lib/tile_selector.cxx)
===================================================================
--- trunk/flexlay/lib/tile_selector.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_selector.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,261 @@
+//  $Id: tile_selector.cxx,v 1.7 2003/09/23 19:10:05 grumbel Exp $
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &lt;ClanLib/display.h&gt;
+#include &lt;ClanLib/core.h&gt;
+#include &quot;math.hpp&quot;
+#include &quot;tileset.hpp&quot;
+#include &quot;tile.hpp&quot;
+#include &quot;tile_selector.hpp&quot;
+#include &quot;tools/tilemap_paint_tool.hpp&quot;
+
+TileSelector::TileSelector(const CL_Rect&amp; rect, CL_Component* parent)
+  : CL_Component(rect, parent),
+    width(1)
+{
+  index = 0;
+
+  slots.connect(sig_paint(),      this, &amp;TileSelector::draw);
+  slots.connect(sig_mouse_move(), this, &amp;TileSelector::mouse_move);
+  slots.connect(sig_mouse_down(), this, &amp;TileSelector::mouse_down);
+  slots.connect(sig_mouse_up  (), this, &amp;TileSelector::mouse_up);
+ 
+  scale = 1.0f;
+  mouse_over_tile = -1;
+  scrolling = false;
+  region_select = false;
+  offset = 0;
+}
+
+TileSelector::~TileSelector()
+{
+  std::cout &lt;&lt; &quot;~TileSelector()&quot; &lt;&lt; std::endl;
+}
+
+CL_Rect 
+TileSelector::get_selection()
+{
+  CL_Rect selection(current_pos.x, current_pos.y, 
+                    region_select_start.x, region_select_start.y);
+
+  selection.normalize();
+  selection.right  += 1;
+  selection.bottom += 1;
+
+  selection.left  = Math::mid(0, selection.left, width);
+  selection.right = Math::mid(0, selection.right, width);
+
+  selection.top    = Math::max(0, selection.top);
+  
+  return selection;
+}
+
+void
+TileSelector::mouse_up(const CL_InputEvent&amp; event)
+{
+  if (event.id == CL_MOUSE_MIDDLE)
+    {
+      scrolling = false;
+      release_mouse();
+    }
+  else if (event.id == CL_MOUSE_RIGHT)
+    {
+      release_mouse();
+      region_select = false;
+
+      CL_Rect selection = get_selection();
+      //selection.bottom = Math::mid(0, selection.right, width);
+
+      TileBrush brush(selection.get_width(), selection.get_height());
+      brush.set_transparent();
+
+      for(int y = 0; y &lt; selection.get_height(); ++y)
+        for(int x = 0; x &lt; selection.get_width(); ++x)
+          {
+            int tile = (selection.top + y) * width + (selection.left + x);
+
+            if (tile &gt;= 0 &amp;&amp; tile &lt; int(tiles.size()))
+              brush.at(x, y) = tiles[tile];
+            else
+              brush.at(x, y) = 0;
+          }
+
+      TileMapPaintTool::current().set_brush(brush);
+    }
+}
+
+void
+TileSelector::mouse_down(const CL_InputEvent&amp; event)
+{
+  if (event.id == CL_MOUSE_LEFT)
+    {
+      TileBrush brush(1, 1);
+
+      brush.set_opaque();
+      if (mouse_over_tile &gt;= 0 &amp;&amp; mouse_over_tile &lt; int(tiles.size()))
+        brush.at(0, 0) = tiles[mouse_over_tile];
+      else
+        brush.at(0, 0) = 0;
+
+      TileMapPaintTool::current().set_brush(brush);
+    }
+  else if (event.id == CL_MOUSE_RIGHT) 
+    {
+      region_select = true;
+      region_select_start = current_pos;
+      capture_mouse();
+    }
+  else if (event.id == CL_MOUSE_MIDDLE)
+    {
+      scrolling = true;
+      mouse_pos = event.mouse_pos;
+      old_offset = offset;
+      capture_mouse();
+    }
+  else if (event.id == CL_MOUSE_WHEEL_UP)
+    {
+      offset -= static_cast&lt;int&gt;(tileset.get_tile_size()*scale);
+      if (offset &lt; 0)
+        offset = 0;
+    }
+  else if (event.id == CL_MOUSE_WHEEL_DOWN)
+    {
+      offset += static_cast&lt;int&gt;(tileset.get_tile_size()*scale);
+    }
+}
+
+CL_Point
+TileSelector::get_mouse_tile_pos(const CL_InputEvent&amp; event)
+{
+  return CL_Point(event.mouse_pos.x/static_cast&lt;int&gt;(tileset.get_tile_size()*scale),
+                  (event.mouse_pos.y+offset)/static_cast&lt;int&gt;(tileset.get_tile_size()*scale));
+}
+
+void
+TileSelector::mouse_move(const CL_InputEvent&amp; event)
+{
+  CL_Point pos = get_mouse_tile_pos(event);
+  current_pos = pos;
+  mouse_over_tile = pos.y * width + pos.x;
+
+  if (scrolling)
+    {
+      offset = old_offset + (mouse_pos.y - event.mouse_pos.y);
+      if (offset &lt; 0)
+        offset = 0;
+    }
+}
+
+void 
+TileSelector::draw()
+{
+  CL_Display::push_cliprect(get_screen_rect());
+  CL_Display::push_modelview();
+  CL_Display::add_translate(get_screen_x(), get_screen_y());
+  CL_Display::add_translate(0, -offset);
+
+  const TileBrush&amp; brush = TileMapPaintTool::current().get_brush();
+
+  int start_row = offset / int(tileset.get_tile_size() * scale);
+  int end_row   = start_row + (get_screen_rect().get_height() / int(tileset.get_tile_size() * scale));
+  int end_index = std::min(end_row*width, int(tiles.size())); 
+  
+  // Draw tiles
+  for(int i = (start_row*width); i &lt; end_index; ++i)
+    {
+      int x = i % width;
+      int y = i / width;
+
+      Tile* tile = tileset.create(tiles[i]);
+
+      CL_Rect rect(CL_Point(static_cast&lt;int&gt;(x * tileset.get_tile_size()*scale),
+                            static_cast&lt;int&gt;(y * tileset.get_tile_size()*scale)),
+                   CL_Size(static_cast&lt;int&gt;(tileset.get_tile_size()*scale),
+                           static_cast&lt;int&gt;(tileset.get_tile_size()*scale)));
+
+      if (tile)
+        {
+          CL_Sprite sprite = tile-&gt;get_sprite();
+
+          sprite.set_scale(scale, scale);
+
+          sprite.draw(static_cast&lt;int&gt;(x * tileset.get_tile_size()*scale), 
+                      static_cast&lt;int&gt;(y * tileset.get_tile_size()*scale));
+
+          // Use grid in the tileselector
+          //CL_Display::draw_rect(rect, CL_Color(0,0,0,128));
+        }
+
+      if (brush.get_width() == 1 &amp;&amp; brush.get_height() == 1
+          &amp;&amp; brush.at(0, 0) == tiles[i])
+        {
+          CL_Display::fill_rect(rect,
+                                CL_Color(0,0,255, 100));
+        }
+      else if (mouse_over_tile == int(i) &amp;&amp; has_mouse_over())
+        {
+          CL_Display::fill_rect(rect, CL_Color(0,0,255, 20));
+        }
+    }
+
+  if (region_select)
+    {
+      CL_Rect rect = get_selection();
+
+      rect.top    *= static_cast&lt;int&gt;(tileset.get_tile_size()*scale);
+      rect.bottom *= static_cast&lt;int&gt;(tileset.get_tile_size()*scale);
+      rect.left   *= static_cast&lt;int&gt;(tileset.get_tile_size()*scale);
+      rect.right  *= static_cast&lt;int&gt;(tileset.get_tile_size()*scale);
+
+      CL_Display::fill_rect(rect, CL_Color(0,0,255, 100));
+    }
+  
+  CL_Display::pop_modelview();
+  CL_Display::pop_cliprect();
+}
+
+void
+TileSelector::set_scale(float s)
+{
+  scale = s;
+  width  = static_cast&lt;int&gt;(get_width()/(tileset.get_tile_size() * scale));
+}
+
+TileSelector::Tiles
+TileSelector::get_tiles() const
+{
+  return tiles;
+}
+
+void
+TileSelector::set_tileset(Tileset t)
+{
+  tileset = t;
+  // Recalc the number of tiles in a row
+  width  = static_cast&lt;int&gt;(get_width()/(tileset.get_tile_size() * scale));
+}
+
+void
+TileSelector::set_tiles(const Tiles&amp; t)
+{
+  tiles = t;
+  offset = 0;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tile_selector.cxx
===================================================================
--- trunk/flexlay/lib/tile_selector.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_selector.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,261 +0,0 @@
-//  $Id: tile_selector.cxx,v 1.7 2003/09/23 19:10:05 grumbel Exp $
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &lt;ClanLib/display.h&gt;
-#include &lt;ClanLib/core.h&gt;
-#include &quot;math.hxx&quot;
-#include &quot;tileset.hxx&quot;
-#include &quot;tile.hxx&quot;
-#include &quot;tile_selector.hxx&quot;
-#include &quot;tools/tilemap_paint_tool.hxx&quot;
-
-TileSelector::TileSelector(const CL_Rect&amp; rect, CL_Component* parent)
-  : CL_Component(rect, parent),
-    width(1)
-{
-  index = 0;
-
-  slots.connect(sig_paint(),      this, &amp;TileSelector::draw);
-  slots.connect(sig_mouse_move(), this, &amp;TileSelector::mouse_move);
-  slots.connect(sig_mouse_down(), this, &amp;TileSelector::mouse_down);
-  slots.connect(sig_mouse_up  (), this, &amp;TileSelector::mouse_up);
- 
-  scale = 1.0f;
-  mouse_over_tile = -1;
-  scrolling = false;
-  region_select = false;
-  offset = 0;
-}
-
-TileSelector::~TileSelector()
-{
-  std::cout &lt;&lt; &quot;~TileSelector()&quot; &lt;&lt; std::endl;
-}
-
-CL_Rect 
-TileSelector::get_selection()
-{
-  CL_Rect selection(current_pos.x, current_pos.y, 
-                    region_select_start.x, region_select_start.y);
-
-  selection.normalize();
-  selection.right  += 1;
-  selection.bottom += 1;
-
-  selection.left  = Math::mid(0, selection.left, width);
-  selection.right = Math::mid(0, selection.right, width);
-
-  selection.top    = Math::max(0, selection.top);
-  
-  return selection;
-}
-
-void
-TileSelector::mouse_up(const CL_InputEvent&amp; event)
-{
-  if (event.id == CL_MOUSE_MIDDLE)
-    {
-      scrolling = false;
-      release_mouse();
-    }
-  else if (event.id == CL_MOUSE_RIGHT)
-    {
-      release_mouse();
-      region_select = false;
-
-      CL_Rect selection = get_selection();
-      //selection.bottom = Math::mid(0, selection.right, width);
-
-      TileBrush brush(selection.get_width(), selection.get_height());
-      brush.set_transparent();
-
-      for(int y = 0; y &lt; selection.get_height(); ++y)
-        for(int x = 0; x &lt; selection.get_width(); ++x)
-          {
-            int tile = (selection.top + y) * width + (selection.left + x);
-
-            if (tile &gt;= 0 &amp;&amp; tile &lt; int(tiles.size()))
-              brush.at(x, y) = tiles[tile];
-            else
-              brush.at(x, y) = 0;
-          }
-
-      TileMapPaintTool::current().set_brush(brush);
-    }
-}
-
-void
-TileSelector::mouse_down(const CL_InputEvent&amp; event)
-{
-  if (event.id == CL_MOUSE_LEFT)
-    {
-      TileBrush brush(1, 1);
-
-      brush.set_opaque();
-      if (mouse_over_tile &gt;= 0 &amp;&amp; mouse_over_tile &lt; int(tiles.size()))
-        brush.at(0, 0) = tiles[mouse_over_tile];
-      else
-        brush.at(0, 0) = 0;
-
-      TileMapPaintTool::current().set_brush(brush);
-    }
-  else if (event.id == CL_MOUSE_RIGHT) 
-    {
-      region_select = true;
-      region_select_start = current_pos;
-      capture_mouse();
-    }
-  else if (event.id == CL_MOUSE_MIDDLE)
-    {
-      scrolling = true;
-      mouse_pos = event.mouse_pos;
-      old_offset = offset;
-      capture_mouse();
-    }
-  else if (event.id == CL_MOUSE_WHEEL_UP)
-    {
-      offset -= static_cast&lt;int&gt;(tileset.get_tile_size()*scale);
-      if (offset &lt; 0)
-        offset = 0;
-    }
-  else if (event.id == CL_MOUSE_WHEEL_DOWN)
-    {
-      offset += static_cast&lt;int&gt;(tileset.get_tile_size()*scale);
-    }
-}
-
-CL_Point
-TileSelector::get_mouse_tile_pos(const CL_InputEvent&amp; event)
-{
-  return CL_Point(event.mouse_pos.x/static_cast&lt;int&gt;(tileset.get_tile_size()*scale),
-                  (event.mouse_pos.y+offset)/static_cast&lt;int&gt;(tileset.get_tile_size()*scale));
-}
-
-void
-TileSelector::mouse_move(const CL_InputEvent&amp; event)
-{
-  CL_Point pos = get_mouse_tile_pos(event);
-  current_pos = pos;
-  mouse_over_tile = pos.y * width + pos.x;
-
-  if (scrolling)
-    {
-      offset = old_offset + (mouse_pos.y - event.mouse_pos.y);
-      if (offset &lt; 0)
-        offset = 0;
-    }
-}
-
-void 
-TileSelector::draw()
-{
-  CL_Display::push_cliprect(get_screen_rect());
-  CL_Display::push_modelview();
-  CL_Display::add_translate(get_screen_x(), get_screen_y());
-  CL_Display::add_translate(0, -offset);
-
-  const TileBrush&amp; brush = TileMapPaintTool::current().get_brush();
-
-  int start_row = offset / int(tileset.get_tile_size() * scale);
-  int end_row   = start_row + (get_screen_rect().get_height() / int(tileset.get_tile_size() * scale));
-  int end_index = std::min(end_row*width, int(tiles.size())); 
-  
-  // Draw tiles
-  for(int i = (start_row*width); i &lt; end_index; ++i)
-    {
-      int x = i % width;
-      int y = i / width;
-
-      Tile* tile = tileset.create(tiles[i]);
-
-      CL_Rect rect(CL_Point(static_cast&lt;int&gt;(x * tileset.get_tile_size()*scale),
-                            static_cast&lt;int&gt;(y * tileset.get_tile_size()*scale)),
-                   CL_Size(static_cast&lt;int&gt;(tileset.get_tile_size()*scale),
-                           static_cast&lt;int&gt;(tileset.get_tile_size()*scale)));
-
-      if (tile)
-        {
-          CL_Sprite sprite = tile-&gt;get_sprite();
-
-          sprite.set_scale(scale, scale);
-
-          sprite.draw(static_cast&lt;int&gt;(x * tileset.get_tile_size()*scale), 
-                      static_cast&lt;int&gt;(y * tileset.get_tile_size()*scale));
-
-          // Use grid in the tileselector
-          //CL_Display::draw_rect(rect, CL_Color(0,0,0,128));
-        }
-
-      if (brush.get_width() == 1 &amp;&amp; brush.get_height() == 1
-          &amp;&amp; brush.at(0, 0) == tiles[i])
-        {
-          CL_Display::fill_rect(rect,
-                                CL_Color(0,0,255, 100));
-        }
-      else if (mouse_over_tile == int(i) &amp;&amp; has_mouse_over())
-        {
-          CL_Display::fill_rect(rect, CL_Color(0,0,255, 20));
-        }
-    }
-
-  if (region_select)
-    {
-      CL_Rect rect = get_selection();
-
-      rect.top    *= static_cast&lt;int&gt;(tileset.get_tile_size()*scale);
-      rect.bottom *= static_cast&lt;int&gt;(tileset.get_tile_size()*scale);
-      rect.left   *= static_cast&lt;int&gt;(tileset.get_tile_size()*scale);
-      rect.right  *= static_cast&lt;int&gt;(tileset.get_tile_size()*scale);
-
-      CL_Display::fill_rect(rect, CL_Color(0,0,255, 100));
-    }
-  
-  CL_Display::pop_modelview();
-  CL_Display::pop_cliprect();
-}
-
-void
-TileSelector::set_scale(float s)
-{
-  scale = s;
-  width  = static_cast&lt;int&gt;(get_width()/(tileset.get_tile_size() * scale));
-}
-
-TileSelector::Tiles
-TileSelector::get_tiles() const
-{
-  return tiles;
-}
-
-void
-TileSelector::set_tileset(Tileset t)
-{
-  tileset = t;
-  // Recalc the number of tiles in a row
-  width  = static_cast&lt;int&gt;(get_width()/(tileset.get_tile_size() * scale));
-}
-
-void
-TileSelector::set_tiles(const Tiles&amp; t)
-{
-  tiles = t;
-  offset = 0;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tile_selector.hpp (from rev 712, trunk/flexlay/lib/tile_selector.hxx)
===================================================================
--- trunk/flexlay/lib/tile_selector.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_selector.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,81 @@
+//  $Id: tile_selector.hpp,v 1.2 2003/09/10 13:53:11 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2000 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef TILESELECTOR_HXX
+#define TILESELECTOR_HXX
+
+#include &lt;ClanLib/gui.h&gt;
+#include &quot;tileset.hpp&quot;
+
+class Tileset;
+
+class TileSelector : public CL_Component
+{
+public:
+  typedef std::vector&lt;int&gt; Tiles;
+  
+private:
+  CL_SlotContainer slots;
+  int width;
+  int index;
+  
+  int offset;
+  int old_offset;
+  int mouse_over_tile;
+  bool scrolling;
+  bool region_select;
+  CL_Point current_pos;
+  CL_Point region_select_start;
+  CL_Point mouse_pos;
+  float scale;
+  
+  /** set of tiles that should be available in the TileSelector */
+  Tiles tiles;
+
+  Tileset tileset;
+
+protected:
+  virtual ~TileSelector();
+public:
+  /** width and height in number of tiles */
+  TileSelector(const CL_Rect&amp; rect, CL_Component* parent);
+  
+  void set_tileset(Tileset t);
+  void set_tiles(const Tiles&amp; t);
+  Tiles get_tiles() const;
+  
+  /** Set the factor by which tiles are scaled down in the selector
+      widged (ie. for better overview) */
+  void set_scale(float s);
+
+  void draw();
+
+  /** Return the position of the mouse in x/y in tilesize */
+  CL_Point get_mouse_tile_pos(const CL_InputEvent&amp; event);
+
+private:
+  CL_Rect get_selection();
+
+  void mouse_move(const CL_InputEvent&amp; event);
+  void mouse_down(const CL_InputEvent&amp; event);
+  void mouse_up  (const CL_InputEvent&amp; event);
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tile_selector.hxx
===================================================================
--- trunk/flexlay/lib/tile_selector.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_selector.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,81 +0,0 @@
-//  $Id: tile_selector.hxx,v 1.2 2003/09/10 13:53:11 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2000 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef TILESELECTOR_HXX
-#define TILESELECTOR_HXX
-
-#include &lt;ClanLib/gui.h&gt;
-#include &quot;tileset.hxx&quot;
-
-class Tileset;
-
-class TileSelector : public CL_Component
-{
-public:
-  typedef std::vector&lt;int&gt; Tiles;
-  
-private:
-  CL_SlotContainer slots;
-  int width;
-  int index;
-  
-  int offset;
-  int old_offset;
-  int mouse_over_tile;
-  bool scrolling;
-  bool region_select;
-  CL_Point current_pos;
-  CL_Point region_select_start;
-  CL_Point mouse_pos;
-  float scale;
-  
-  /** set of tiles that should be available in the TileSelector */
-  Tiles tiles;
-
-  Tileset tileset;
-
-protected:
-  virtual ~TileSelector();
-public:
-  /** width and height in number of tiles */
-  TileSelector(const CL_Rect&amp; rect, CL_Component* parent);
-  
-  void set_tileset(Tileset t);
-  void set_tiles(const Tiles&amp; t);
-  Tiles get_tiles() const;
-  
-  /** Set the factor by which tiles are scaled down in the selector
-      widged (ie. for better overview) */
-  void set_scale(float s);
-
-  void draw();
-
-  /** Return the position of the mouse in x/y in tilesize */
-  CL_Point get_mouse_tile_pos(const CL_InputEvent&amp; event);
-
-private:
-  CL_Rect get_selection();
-
-  void mouse_move(const CL_InputEvent&amp; event);
-  void mouse_down(const CL_InputEvent&amp; event);
-  void mouse_up  (const CL_InputEvent&amp; event);
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tilemap_layer.cpp (from rev 712, trunk/flexlay/lib/tilemap_layer.cxx)
===================================================================
--- trunk/flexlay/lib/tilemap_layer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tilemap_layer.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,423 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;math.h&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &lt;ClanLib/Display/pixel_buffer.h&gt;
+#include &lt;ClanLib/Display/pixel_format.h&gt;
+#include &lt;ClanLib/Display/palette.h&gt;
+#include &lt;ClanLib/gl.h&gt;
+#include &quot;tile.hpp&quot;
+#include &quot;tileset.hpp&quot;
+#include &quot;editor_map.hpp&quot;
+#include &quot;tile_brush.hpp&quot;
+#include &quot;editor_map_component.hpp&quot;
+#include &quot;editor_map_component.hpp&quot;
+#include &quot;blitter.hpp&quot;
+#include &quot;layer_impl.hpp&quot;
+#include &quot;editor_map_component.hpp&quot;
+#include &quot;tilemap_layer.hpp&quot;
+
+TilemapLayer TilemapLayer::current_;
+
+class TilemapLayerImpl : public LayerImpl
+{
+public:
+  Tileset tileset;
+  CL_Color background_color;
+  CL_Color foreground_color;
+  bool hex_mode;
+
+  Field&lt;int&gt; field;
+
+  bool draw_grid;
+  bool draw_attribute;
+
+  MetaData metadata;
+
+  TilemapLayerImpl() {}
+  virtual ~TilemapLayerImpl() {}
+
+  bool has_bounding_rect() const;
+  CL_Rect get_bounding_rect();
+  void draw(EditorMapComponent* parent, CL_GraphicContext* gc);
+};
+
+TilemapLayer::TilemapLayer()
+{
+}
+
+/*TilemapLayer::TilemapLayer(const SharedPtr&lt;TilemapLayerImpl&gt;&amp; i)
+  : impl(i)
+{
+}*/
+
+TilemapLayer::TilemapLayer(Tileset tileset_, int w,  int h)
+  : impl(new TilemapLayerImpl())
+{
+  impl-&gt;field = Field&lt;int&gt;(w, h);
+
+  // FIXME: Move this to the widget or to some more generic
+  // map-properties thingy
+  impl-&gt;draw_grid      = false;
+  impl-&gt;draw_attribute = false;
+  impl-&gt;hex_mode = false;
+
+  for (int y = 0; y &lt; impl-&gt;field.get_height(); ++y) 
+    for (int x = 0; x &lt; impl-&gt;field.get_width(); ++x)
+      impl-&gt;field.at(x, y) = 0;
+
+  impl-&gt;background_color = CL_Color(0, 0, 0, 0);
+  impl-&gt;foreground_color = CL_Color(255, 255, 255, 255);
+  
+  impl-&gt;tileset = tileset_;
+}
+
+TilemapLayer::~TilemapLayer()
+{
+}
+
+void
+TilemapLayer::draw(EditorMapComponent* parent, CL_GraphicContext* gc)
+{
+  impl-&gt;draw(parent, gc);
+}
+
+void
+TilemapLayerImpl::draw(EditorMapComponent* parent, CL_GraphicContext* gc)
+{
+  int tile_size = this-&gt;tileset.get_tile_size();
+
+  if (this-&gt;background_color.get_alpha() != 0)
+    CL_Display::fill_rect(CL_Rect(CL_Point(0,0),
+                                  CL_Size(this-&gt;field.get_width()  * tile_size,
+                                          this-&gt;field.get_height() * tile_size)),
+                          this-&gt;background_color);
+  CL_Display::flush();
+
+  CL_Rect rect(parent-&gt;get_clip_rect());
+
+  int start_x = std::max(0, rect.left / tile_size);
+  int start_y = std::max(0, rect.top  / tile_size);
+  int end_x   = std::min(this-&gt;field.get_width(),  rect.right  / tile_size + 1);
+  int end_y   = std::min(this-&gt;field.get_height(), rect.bottom / tile_size + 1);
+
+  if (foreground_color != CL_Color(255, 255, 255, 255))
+    {
+      for (int y = start_y; y &lt; end_y; ++y)
+        for (int x = start_x; x &lt; end_x; ++x)
+          {
+            int tile_id = this-&gt;field.at(x, y);
+            if (tile_id)
+              {
+                Tile* tile = tileset.create(tile_id);
+                if (tile) // skip transparent tile for faster draw
+                  {           
+                    CL_Sprite sprite = tile-&gt;get_sprite();
+                    sprite.set_color(foreground_color);
+                    sprite.draw(x * tile_size, y * tile_size, gc);
+      
+                    if (draw_attribute)
+                      CL_Display::fill_rect(CL_Rect(CL_Point(x, y), CL_Size(tileset.get_tile_size(),
+                                                                            tileset.get_tile_size())),
+                                            tile-&gt;get_attribute_color());
+                  }
+              }
+          }
+    }
+  else
+    {
+      for (int y = start_y; y &lt; end_y; ++y)
+        for (int x = start_x; x &lt; end_x; ++x)
+          {
+            int tile_id = this-&gt;field.at(x, y);
+            if (tile_id) // skip transparent tile for faster draw
+              {
+                Tile* tile = tileset.create(this-&gt;field.at(x, y));
+                if (tile)
+                  {           
+                    tile-&gt;get_sprite().draw(x * tile_size, y * tile_size, gc);
+      
+                    if (draw_attribute)
+                      CL_Display::fill_rect(CL_Rect(CL_Point(x, y), CL_Size(tileset.get_tile_size(),
+                                                                            tileset.get_tile_size())),
+                                            tile-&gt;get_attribute_color());
+                  }
+              }
+          }
+    }
+
+  if (this-&gt;draw_grid)
+    {
+      for (int y = start_y; y &lt;= end_y; ++y)
+        CL_Display::draw_line(start_x * tile_size,
+                              y       * tile_size,
+                              end_x   * tile_size,
+                              y       * tile_size, 
+                              y % 2 ? CL_Color(150, 150, 150) : CL_Color(255, 255, 255));
+  
+      for (int x = start_x; x &lt;= end_x; ++x)
+        CL_Display::draw_line(x       * tile_size,
+                              start_y * tile_size,
+                              x       * tile_size,
+                              end_y   * tile_size, 
+                              x % 2 ? CL_Color(150, 150, 150) : CL_Color(255, 255, 255));
+    }
+
+  CL_Display::flush();
+}
+
+int
+TilemapLayer::get_tile (int x, int y)
+{
+  if (x &gt;= 0 &amp;&amp; x &lt; (int)impl-&gt;field.get_width() &amp;&amp;
+      y &gt;= 0 &amp;&amp; y &lt; (int)impl-&gt;field.get_height())
+    return impl-&gt;field.at(x, y);
+  else
+    return 0;
+}
+
+void
+TilemapLayer::resize(const CL_Size&amp; size, const CL_Point&amp; point)
+{
+  impl-&gt;field.resize(size.width, size.height, point.x, point.y);
+}
+
+void
+TilemapLayer::draw_tile(int id, const CL_Point&amp; pos)
+{
+  if (pos.x &gt;= 0 &amp;&amp; pos.x &lt; impl-&gt;field.get_width()
+      &amp;&amp; pos.y &gt;= 0 &amp;&amp; pos.y &lt; impl-&gt;field.get_height())
+    {
+      impl-&gt;field.at(pos.x, pos.y) = id;
+    }
+}
+
+void
+TilemapLayer::draw_tile(const TileBrush&amp; brush, const CL_Point&amp; pos)
+{
+  draw_tiles(&amp;impl-&gt;field, brush, pos);
+}
+
+void
+TilemapLayer::draw_tiles(Field&lt;int&gt;* field, const TileBrush&amp; brush, const CL_Point&amp; pos)
+{
+  int start_x = std::max(0, -pos.x);
+  int start_y = std::max(0, -pos.y);
+
+  int end_x = std::min(brush.get_width(),  field-&gt;get_width()  - pos.x);
+  int end_y = std::min(brush.get_height(), field-&gt;get_height() - pos.y);
+
+  for (int y = start_y; y &lt; end_y; ++y)
+    for (int x = start_x; x &lt; end_x; ++x)
+      {
+        if (brush.is_opaque() || brush.at(x, y) != 0)
+          {
+            field-&gt;at(pos.x + x, pos.y + y) = brush.at(x, y);
+          }
+      }
+}
+
+void
+TilemapLayer::set_draw_attribute(bool t)
+{
+  impl-&gt;draw_attribute = t;
+}
+
+bool
+TilemapLayer::get_draw_attribute() const
+{
+  return impl-&gt;draw_attribute;
+}
+
+void
+TilemapLayer::set_draw_grid(bool t)
+{
+  impl-&gt;draw_grid = t;
+}
+
+bool
+TilemapLayer::get_draw_grid() const
+{
+  return impl-&gt;draw_grid;
+}
+
+CL_PixelBuffer
+TilemapLayer::create_pixelbuffer()
+{
+  int tile_size = impl-&gt;tileset.get_tile_size();
+
+  CL_PixelBuffer pixelbuffer(get_width()  * tile_size,
+                             get_height() * tile_size,
+                             get_width()  * tile_size * 4,
+                             CL_PixelFormat::rgba8888);
+
+  {
+    pixelbuffer.lock();
+    unsigned char* buf = static_cast&lt;unsigned char*&gt;(pixelbuffer.get_data());
+
+    int width  = pixelbuffer.get_width();
+    int height = pixelbuffer.get_height();
+
+    // Draw a nice gradient
+    for(int y = 0; y &lt; height; ++y)
+      {
+        for (int x = 0; x &lt; width; ++x)
+          {
+            buf[4*(y*width + x) + 0] = 255;
+            buf[4*(y*width + x) + 1] = 255;
+            buf[4*(y*width + x) + 2] = 255*y/height;
+            buf[4*(y*width + x) + 3] = 255*y/height;
+          }
+      }
+    pixelbuffer.unlock();
+  }
+
+  for (int y = 0; y &lt; get_height(); ++y)
+    for (int x = 0; x &lt; get_width(); ++x)
+      {
+        Tile* tile = impl-&gt;tileset.create(impl-&gt;field.at(x, y));
+
+        if (tile)
+          {
+            CL_PixelBuffer buf = tile-&gt;get_pixelbuffer();
+            if (buf)
+              {
+                blit(pixelbuffer, buf, x*tile_size, y*tile_size);
+              }
+          }
+      }
+
+  return pixelbuffer;
+}
+
+CL_Rect
+TilemapLayer::get_bounding_rect()
+{
+  return impl-&gt;get_bounding_rect();
+}
+
+CL_Rect
+TilemapLayerImpl::get_bounding_rect()
+{
+  return CL_Rect(CL_Point(0, 0),
+                 CL_Size(field.get_width()  * tileset.get_tile_size(), 
+                         field.get_height() * tileset.get_tile_size()));
+}
+
+CL_Point
+TilemapLayer::world2tile(const CL_Pointf&amp; pos) const
+{
+  int x = static_cast&lt;int&gt;(pos.x / impl-&gt;tileset.get_tile_size());
+  int y = static_cast&lt;int&gt;(pos.y / impl-&gt;tileset.get_tile_size());
+
+  return CL_Point(pos.x &lt; 0 ? x-1 : x,
+                  pos.y &lt; 0 ? y-1 : y);
+}
+
+Field&lt;int&gt;*
+TilemapLayer::get_field()
+{
+  return &amp;impl-&gt;field; 
+}
+
+TilemapLayer
+TilemapLayer::current()
+{
+  return current_; 
+}
+
+void
+TilemapLayer::set_current(TilemapLayer t) 
+{
+  current_ = t;
+}
+
+Tileset
+TilemapLayer::get_tileset()
+{
+  return impl-&gt;tileset;
+}
+
+const std::vector&lt;int&gt;&amp;
+TilemapLayer::get_data()
+{
+  return impl-&gt;field.get_data();
+}
+
+void
+TilemapLayer::set_data(std::vector&lt;int&gt; d)
+{
+  impl-&gt;field.set_data(d);
+}
+
+void 
+TilemapLayer::set_background_color(const CL_Color&amp; color)
+{
+  impl-&gt;background_color = color;
+}
+
+void 
+TilemapLayer::set_foreground_color(const CL_Color&amp; color)
+{
+  impl-&gt;foreground_color = color;
+}
+
+int
+TilemapLayer::get_width()  const
+{
+  return impl-&gt;field.get_width();
+}
+
+int
+TilemapLayer::get_height() const
+{
+  return impl-&gt;field.get_height();
+}
+
+bool
+TilemapLayer::has_bounding_rect() const
+{
+  return impl-&gt;has_bounding_rect();
+}
+
+bool
+TilemapLayerImpl::has_bounding_rect() const
+{
+  return true;
+}
+
+Layer
+TilemapLayer::to_layer()
+{
+   return Layer(impl);
+}
+
+void
+TilemapLayer::set_metadata(const MetaData&amp; metadata)
+{
+  impl-&gt;metadata = metadata;
+}
+
+MetaData
+TilemapLayer::get_metadata() const
+{
+  return impl-&gt;metadata;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tilemap_layer.cxx
===================================================================
--- trunk/flexlay/lib/tilemap_layer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tilemap_layer.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,423 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;math.h&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-#include &lt;ClanLib/Display/pixel_buffer.h&gt;
-#include &lt;ClanLib/Display/pixel_format.h&gt;
-#include &lt;ClanLib/Display/palette.h&gt;
-#include &lt;ClanLib/gl.h&gt;
-#include &quot;tile.hxx&quot;
-#include &quot;tileset.hxx&quot;
-#include &quot;editor_map.hxx&quot;
-#include &quot;tile_brush.hxx&quot;
-#include &quot;editor_map_component.hxx&quot;
-#include &quot;editor_map_component.hxx&quot;
-#include &quot;blitter.hxx&quot;
-#include &quot;layer_impl.hxx&quot;
-#include &quot;editor_map_component.hxx&quot;
-#include &quot;tilemap_layer.hxx&quot;
-
-TilemapLayer TilemapLayer::current_;
-
-class TilemapLayerImpl : public LayerImpl
-{
-public:
-  Tileset tileset;
-  CL_Color background_color;
-  CL_Color foreground_color;
-  bool hex_mode;
-
-  Field&lt;int&gt; field;
-
-  bool draw_grid;
-  bool draw_attribute;
-
-  MetaData metadata;
-
-  TilemapLayerImpl() {}
-  virtual ~TilemapLayerImpl() {}
-
-  bool has_bounding_rect() const;
-  CL_Rect get_bounding_rect();
-  void draw(EditorMapComponent* parent, CL_GraphicContext* gc);
-};
-
-TilemapLayer::TilemapLayer()
-{
-}
-
-/*TilemapLayer::TilemapLayer(const SharedPtr&lt;TilemapLayerImpl&gt;&amp; i)
-  : impl(i)
-{
-}*/
-
-TilemapLayer::TilemapLayer(Tileset tileset_, int w,  int h)
-  : impl(new TilemapLayerImpl())
-{
-  impl-&gt;field = Field&lt;int&gt;(w, h);
-
-  // FIXME: Move this to the widget or to some more generic
-  // map-properties thingy
-  impl-&gt;draw_grid      = false;
-  impl-&gt;draw_attribute = false;
-  impl-&gt;hex_mode = false;
-
-  for (int y = 0; y &lt; impl-&gt;field.get_height(); ++y) 
-    for (int x = 0; x &lt; impl-&gt;field.get_width(); ++x)
-      impl-&gt;field.at(x, y) = 0;
-
-  impl-&gt;background_color = CL_Color(0, 0, 0, 0);
-  impl-&gt;foreground_color = CL_Color(255, 255, 255, 255);
-  
-  impl-&gt;tileset = tileset_;
-}
-
-TilemapLayer::~TilemapLayer()
-{
-}
-
-void
-TilemapLayer::draw(EditorMapComponent* parent, CL_GraphicContext* gc)
-{
-  impl-&gt;draw(parent, gc);
-}
-
-void
-TilemapLayerImpl::draw(EditorMapComponent* parent, CL_GraphicContext* gc)
-{
-  int tile_size = this-&gt;tileset.get_tile_size();
-
-  if (this-&gt;background_color.get_alpha() != 0)
-    CL_Display::fill_rect(CL_Rect(CL_Point(0,0),
-                                  CL_Size(this-&gt;field.get_width()  * tile_size,
-                                          this-&gt;field.get_height() * tile_size)),
-                          this-&gt;background_color);
-  CL_Display::flush();
-
-  CL_Rect rect(parent-&gt;get_clip_rect());
-
-  int start_x = std::max(0, rect.left / tile_size);
-  int start_y = std::max(0, rect.top  / tile_size);
-  int end_x   = std::min(this-&gt;field.get_width(),  rect.right  / tile_size + 1);
-  int end_y   = std::min(this-&gt;field.get_height(), rect.bottom / tile_size + 1);
-
-  if (foreground_color != CL_Color(255, 255, 255, 255))
-    {
-      for (int y = start_y; y &lt; end_y; ++y)
-        for (int x = start_x; x &lt; end_x; ++x)
-          {
-            int tile_id = this-&gt;field.at(x, y);
-            if (tile_id)
-              {
-                Tile* tile = tileset.create(tile_id);
-                if (tile) // skip transparent tile for faster draw
-                  {           
-                    CL_Sprite sprite = tile-&gt;get_sprite();
-                    sprite.set_color(foreground_color);
-                    sprite.draw(x * tile_size, y * tile_size, gc);
-      
-                    if (draw_attribute)
-                      CL_Display::fill_rect(CL_Rect(CL_Point(x, y), CL_Size(tileset.get_tile_size(),
-                                                                            tileset.get_tile_size())),
-                                            tile-&gt;get_attribute_color());
-                  }
-              }
-          }
-    }
-  else
-    {
-      for (int y = start_y; y &lt; end_y; ++y)
-        for (int x = start_x; x &lt; end_x; ++x)
-          {
-            int tile_id = this-&gt;field.at(x, y);
-            if (tile_id) // skip transparent tile for faster draw
-              {
-                Tile* tile = tileset.create(this-&gt;field.at(x, y));
-                if (tile)
-                  {           
-                    tile-&gt;get_sprite().draw(x * tile_size, y * tile_size, gc);
-      
-                    if (draw_attribute)
-                      CL_Display::fill_rect(CL_Rect(CL_Point(x, y), CL_Size(tileset.get_tile_size(),
-                                                                            tileset.get_tile_size())),
-                                            tile-&gt;get_attribute_color());
-                  }
-              }
-          }
-    }
-
-  if (this-&gt;draw_grid)
-    {
-      for (int y = start_y; y &lt;= end_y; ++y)
-        CL_Display::draw_line(start_x * tile_size,
-                              y       * tile_size,
-                              end_x   * tile_size,
-                              y       * tile_size, 
-                              y % 2 ? CL_Color(150, 150, 150) : CL_Color(255, 255, 255));
-  
-      for (int x = start_x; x &lt;= end_x; ++x)
-        CL_Display::draw_line(x       * tile_size,
-                              start_y * tile_size,
-                              x       * tile_size,
-                              end_y   * tile_size, 
-                              x % 2 ? CL_Color(150, 150, 150) : CL_Color(255, 255, 255));
-    }
-
-  CL_Display::flush();
-}
-
-int
-TilemapLayer::get_tile (int x, int y)
-{
-  if (x &gt;= 0 &amp;&amp; x &lt; (int)impl-&gt;field.get_width() &amp;&amp;
-      y &gt;= 0 &amp;&amp; y &lt; (int)impl-&gt;field.get_height())
-    return impl-&gt;field.at(x, y);
-  else
-    return 0;
-}
-
-void
-TilemapLayer::resize(const CL_Size&amp; size, const CL_Point&amp; point)
-{
-  impl-&gt;field.resize(size.width, size.height, point.x, point.y);
-}
-
-void
-TilemapLayer::draw_tile(int id, const CL_Point&amp; pos)
-{
-  if (pos.x &gt;= 0 &amp;&amp; pos.x &lt; impl-&gt;field.get_width()
-      &amp;&amp; pos.y &gt;= 0 &amp;&amp; pos.y &lt; impl-&gt;field.get_height())
-    {
-      impl-&gt;field.at(pos.x, pos.y) = id;
-    }
-}
-
-void
-TilemapLayer::draw_tile(const TileBrush&amp; brush, const CL_Point&amp; pos)
-{
-  draw_tiles(&amp;impl-&gt;field, brush, pos);
-}
-
-void
-TilemapLayer::draw_tiles(Field&lt;int&gt;* field, const TileBrush&amp; brush, const CL_Point&amp; pos)
-{
-  int start_x = std::max(0, -pos.x);
-  int start_y = std::max(0, -pos.y);
-
-  int end_x = std::min(brush.get_width(),  field-&gt;get_width()  - pos.x);
-  int end_y = std::min(brush.get_height(), field-&gt;get_height() - pos.y);
-
-  for (int y = start_y; y &lt; end_y; ++y)
-    for (int x = start_x; x &lt; end_x; ++x)
-      {
-        if (brush.is_opaque() || brush.at(x, y) != 0)
-          {
-            field-&gt;at(pos.x + x, pos.y + y) = brush.at(x, y);
-          }
-      }
-}
-
-void
-TilemapLayer::set_draw_attribute(bool t)
-{
-  impl-&gt;draw_attribute = t;
-}
-
-bool
-TilemapLayer::get_draw_attribute() const
-{
-  return impl-&gt;draw_attribute;
-}
-
-void
-TilemapLayer::set_draw_grid(bool t)
-{
-  impl-&gt;draw_grid = t;
-}
-
-bool
-TilemapLayer::get_draw_grid() const
-{
-  return impl-&gt;draw_grid;
-}
-
-CL_PixelBuffer
-TilemapLayer::create_pixelbuffer()
-{
-  int tile_size = impl-&gt;tileset.get_tile_size();
-
-  CL_PixelBuffer pixelbuffer(get_width()  * tile_size,
-                             get_height() * tile_size,
-                             get_width()  * tile_size * 4,
-                             CL_PixelFormat::rgba8888);
-
-  {
-    pixelbuffer.lock();
-    unsigned char* buf = static_cast&lt;unsigned char*&gt;(pixelbuffer.get_data());
-
-    int width  = pixelbuffer.get_width();
-    int height = pixelbuffer.get_height();
-
-    // Draw a nice gradient
-    for(int y = 0; y &lt; height; ++y)
-      {
-        for (int x = 0; x &lt; width; ++x)
-          {
-            buf[4*(y*width + x) + 0] = 255;
-            buf[4*(y*width + x) + 1] = 255;
-            buf[4*(y*width + x) + 2] = 255*y/height;
-            buf[4*(y*width + x) + 3] = 255*y/height;
-          }
-      }
-    pixelbuffer.unlock();
-  }
-
-  for (int y = 0; y &lt; get_height(); ++y)
-    for (int x = 0; x &lt; get_width(); ++x)
-      {
-        Tile* tile = impl-&gt;tileset.create(impl-&gt;field.at(x, y));
-
-        if (tile)
-          {
-            CL_PixelBuffer buf = tile-&gt;get_pixelbuffer();
-            if (buf)
-              {
-                blit(pixelbuffer, buf, x*tile_size, y*tile_size);
-              }
-          }
-      }
-
-  return pixelbuffer;
-}
-
-CL_Rect
-TilemapLayer::get_bounding_rect()
-{
-  return impl-&gt;get_bounding_rect();
-}
-
-CL_Rect
-TilemapLayerImpl::get_bounding_rect()
-{
-  return CL_Rect(CL_Point(0, 0),
-                 CL_Size(field.get_width()  * tileset.get_tile_size(), 
-                         field.get_height() * tileset.get_tile_size()));
-}
-
-CL_Point
-TilemapLayer::world2tile(const CL_Pointf&amp; pos) const
-{
-  int x = static_cast&lt;int&gt;(pos.x / impl-&gt;tileset.get_tile_size());
-  int y = static_cast&lt;int&gt;(pos.y / impl-&gt;tileset.get_tile_size());
-
-  return CL_Point(pos.x &lt; 0 ? x-1 : x,
-                  pos.y &lt; 0 ? y-1 : y);
-}
-
-Field&lt;int&gt;*
-TilemapLayer::get_field()
-{
-  return &amp;impl-&gt;field; 
-}
-
-TilemapLayer
-TilemapLayer::current()
-{
-  return current_; 
-}
-
-void
-TilemapLayer::set_current(TilemapLayer t) 
-{
-  current_ = t;
-}
-
-Tileset
-TilemapLayer::get_tileset()
-{
-  return impl-&gt;tileset;
-}
-
-const std::vector&lt;int&gt;&amp;
-TilemapLayer::get_data()
-{
-  return impl-&gt;field.get_data();
-}
-
-void
-TilemapLayer::set_data(std::vector&lt;int&gt; d)
-{
-  impl-&gt;field.set_data(d);
-}
-
-void 
-TilemapLayer::set_background_color(const CL_Color&amp; color)
-{
-  impl-&gt;background_color = color;
-}
-
-void 
-TilemapLayer::set_foreground_color(const CL_Color&amp; color)
-{
-  impl-&gt;foreground_color = color;
-}
-
-int
-TilemapLayer::get_width()  const
-{
-  return impl-&gt;field.get_width();
-}
-
-int
-TilemapLayer::get_height() const
-{
-  return impl-&gt;field.get_height();
-}
-
-bool
-TilemapLayer::has_bounding_rect() const
-{
-  return impl-&gt;has_bounding_rect();
-}
-
-bool
-TilemapLayerImpl::has_bounding_rect() const
-{
-  return true;
-}
-
-Layer
-TilemapLayer::to_layer()
-{
-   return Layer(impl);
-}
-
-void
-TilemapLayer::set_metadata(const MetaData&amp; metadata)
-{
-  impl-&gt;metadata = metadata;
-}
-
-MetaData
-TilemapLayer::get_metadata() const
-{
-  return impl-&gt;metadata;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tilemap_layer.hpp (from rev 712, trunk/flexlay/lib/tilemap_layer.hxx)
===================================================================
--- trunk/flexlay/lib/tilemap_layer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tilemap_layer.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,103 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_TILEMAP_LAYER_HXX
+#define HEADER_TILEMAP_LAYER_HXX
+
+#include &lt;ClanLib/Display/pixel_buffer.h&gt;
+#include &quot;field.hpp&quot;
+#include &quot;meta_data.hpp&quot;
+#include &quot;shared_ptr.hpp&quot;
+#include &quot;layer.hpp&quot;
+
+class Tileset;
+class TileBrush;
+class TilemapLayerImpl;
+class EditorMapComponent;
+
+/** */
+class TilemapLayer
+{
+private:
+  static TilemapLayer current_;
+public:
+  static TilemapLayer current();
+  static void set_current(TilemapLayer t);
+
+  TilemapLayer(); 
+  TilemapLayer(Tileset tileset, int w,  int h);
+  ~TilemapLayer();
+
+  void draw(EditorMapComponent* parent, CL_GraphicContext* gc);
+
+  Tileset get_tileset();
+
+  int  get_tile (int, int);
+
+  Field&lt;int&gt;* get_field();
+
+  /** @param pos position of the old map in the new resized one
+      @param size height of the new map */
+ void resize(const CL_Size&amp; size, const CL_Point&amp; point);
+
+  const std::vector&lt;int&gt;&amp; get_data();
+  void set_data(std::vector&lt;int&gt; d);
+
+  void   set_metadata(const MetaData&amp; obj);
+  MetaData get_metadata() const;
+
+  /** Draw the gives brush to the map */
+  void draw_tile(const TileBrush&amp; brush, const CL_Point&amp; pos);
+
+  /** Draw the given single tile to the map */
+  void draw_tile(int id, const CL_Point&amp; pos);
+
+  int get_width()  const;
+  int get_height() const;
+
+  void set_background_color(const CL_Color&amp; color);
+  void set_foreground_color(const CL_Color&amp; color);
+
+  void set_draw_attribute(bool t);
+  bool get_draw_attribute() const;
+
+  void set_draw_grid(bool t);
+  bool get_draw_grid() const;
+
+  CL_PixelBuffer create_pixelbuffer();
+
+  static void draw_tiles(Field&lt;int&gt;* field, const TileBrush&amp; brush, const CL_Point&amp; pos);
+
+  bool has_bounding_rect() const;
+  CL_Rect get_bounding_rect();
+
+  /** Convert a coordinate given in world position into a tile
+      coordinate */
+  CL_Point world2tile(const CL_Pointf&amp; pos) const;
+
+  bool is_null() const { return !impl.get(); }
+
+  Layer to_layer();
+
+private:
+  SharedPtr&lt;TilemapLayerImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tilemap_layer.hxx
===================================================================
--- trunk/flexlay/lib/tilemap_layer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tilemap_layer.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,103 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_TILEMAP_LAYER_HXX
-#define HEADER_TILEMAP_LAYER_HXX
-
-#include &lt;ClanLib/Display/pixel_buffer.h&gt;
-#include &quot;field.hxx&quot;
-#include &quot;meta_data.hxx&quot;
-#include &quot;shared_ptr.hxx&quot;
-#include &quot;layer.hxx&quot;
-
-class Tileset;
-class TileBrush;
-class TilemapLayerImpl;
-class EditorMapComponent;
-
-/** */
-class TilemapLayer
-{
-private:
-  static TilemapLayer current_;
-public:
-  static TilemapLayer current();
-  static void set_current(TilemapLayer t);
-
-  TilemapLayer(); 
-  TilemapLayer(Tileset tileset, int w,  int h);
-  ~TilemapLayer();
-
-  void draw(EditorMapComponent* parent, CL_GraphicContext* gc);
-
-  Tileset get_tileset();
-
-  int  get_tile (int, int);
-
-  Field&lt;int&gt;* get_field();
-
-  /** @param pos position of the old map in the new resized one
-      @param size height of the new map */
- void resize(const CL_Size&amp; size, const CL_Point&amp; point);
-
-  const std::vector&lt;int&gt;&amp; get_data();
-  void set_data(std::vector&lt;int&gt; d);
-
-  void   set_metadata(const MetaData&amp; obj);
-  MetaData get_metadata() const;
-
-  /** Draw the gives brush to the map */
-  void draw_tile(const TileBrush&amp; brush, const CL_Point&amp; pos);
-
-  /** Draw the given single tile to the map */
-  void draw_tile(int id, const CL_Point&amp; pos);
-
-  int get_width()  const;
-  int get_height() const;
-
-  void set_background_color(const CL_Color&amp; color);
-  void set_foreground_color(const CL_Color&amp; color);
-
-  void set_draw_attribute(bool t);
-  bool get_draw_attribute() const;
-
-  void set_draw_grid(bool t);
-  bool get_draw_grid() const;
-
-  CL_PixelBuffer create_pixelbuffer();
-
-  static void draw_tiles(Field&lt;int&gt;* field, const TileBrush&amp; brush, const CL_Point&amp; pos);
-
-  bool has_bounding_rect() const;
-  CL_Rect get_bounding_rect();
-
-  /** Convert a coordinate given in world position into a tile
-      coordinate */
-  CL_Point world2tile(const CL_Pointf&amp; pos) const;
-
-  bool is_null() const { return !impl.get(); }
-
-  Layer to_layer();
-
-private:
-  SharedPtr&lt;TilemapLayerImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tilemap_minimap.hpp (from rev 712, trunk/flexlay/lib/tilemap_minimap.hxx)

Deleted: trunk/flexlay/lib/tilemap_minimap.hxx
===================================================================
--- trunk/flexlay/lib/tilemap_minimap.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tilemap_minimap.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,35 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_TILEMAP_MINIMAP_HXX
-#define HEADER_TILEMAP_MINIMAP_HXX
-
-/** */
-class TilemapMinimap
-{
-private:
-public:
-
-private:
-  TilemapMinimap (const TilemapMinimap&amp;);
-  TilemapMinimap&amp; operator= (const TilemapMinimap&amp;);
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tileset.cpp (from rev 712, trunk/flexlay/lib/tileset.cxx)
===================================================================
--- trunk/flexlay/lib/tileset.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tileset.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,105 @@
+//  $Id: tile_factory.cxx,v 1.10 2003/09/22 18:37:05 grumbel Exp $
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2000 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;string&gt;
+#include &lt;ClanLib/Core/System/system.h&gt;
+#include &lt;assert.h&gt;
+#include &lt;iostream&gt;
+#include &quot;globals.hpp&quot;
+#include &quot;string_converter.hpp&quot;
+#include &quot;tile.hpp&quot;
+#include &quot;tileset.hpp&quot;
+
+typedef std::vector&lt;Tile*&gt; Tiles;
+typedef std::vector&lt;int&gt; TileIds;
+typedef Tiles::iterator iterator;
+  
+class TilesetImpl 
+{
+public:
+  TilesetImpl()
+  {
+  }
+
+  ~TilesetImpl()
+  {
+    for(Tiles::iterator i = tiles.begin(); i != tiles.end(); ++i)
+      {
+        delete *i;
+      }
+  }
+
+  TileIds tile_ids;
+  Tiles tiles;
+  int tile_size;
+};
+
+Tileset::Tileset()
+  : impl(new TilesetImpl())
+{
+  impl-&gt;tile_size = 1;
+}
+
+Tileset::Tileset(int tile_size_)
+  : impl(new TilesetImpl())
+{
+  assert(tile_size_ &gt; 0);
+  impl-&gt;tile_size = tile_size_;
+}
+
+Tileset::~Tileset()
+{
+}
+
+void
+Tileset::add_tile(int id, Tile* tile)
+{
+  // FIXME: Check for tile-id dups
+  if (id &gt;= int(impl-&gt;tiles.size()))
+    impl-&gt;tiles.resize(id+1, 0);
+
+  if (tile)
+    impl-&gt;tiles[id] = new Tile(*tile);
+  else
+    impl-&gt;tiles[id] = 0;
+
+  impl-&gt;tile_ids.push_back(id);
+}
+
+Tile* 
+Tileset::create (int id)
+{
+  if (id &gt;= 0 &amp;&amp; id &lt; int(impl-&gt;tiles.size()))
+    return impl-&gt;tiles[id];
+  else
+    return 0;
+}
+
+int
+Tileset::get_tile_size() const 
+{
+  return impl-&gt;tile_size; 
+}
+
+std::vector&lt;int&gt; 
+Tileset::get_tiles() const
+{
+  return impl-&gt;tile_ids;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tileset.cxx
===================================================================
--- trunk/flexlay/lib/tileset.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tileset.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,105 +0,0 @@
-//  $Id: tile_factory.cxx,v 1.10 2003/09/22 18:37:05 grumbel Exp $
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2000 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;string&gt;
-#include &lt;ClanLib/Core/System/system.h&gt;
-#include &lt;assert.h&gt;
-#include &lt;iostream&gt;
-#include &quot;globals.hxx&quot;
-#include &quot;string_converter.hxx&quot;
-#include &quot;tile.hxx&quot;
-#include &quot;tileset.hxx&quot;
-
-typedef std::vector&lt;Tile*&gt; Tiles;
-typedef std::vector&lt;int&gt; TileIds;
-typedef Tiles::iterator iterator;
-  
-class TilesetImpl 
-{
-public:
-  TilesetImpl()
-  {
-  }
-
-  ~TilesetImpl()
-  {
-    for(Tiles::iterator i = tiles.begin(); i != tiles.end(); ++i)
-      {
-        delete *i;
-      }
-  }
-
-  TileIds tile_ids;
-  Tiles tiles;
-  int tile_size;
-};
-
-Tileset::Tileset()
-  : impl(new TilesetImpl())
-{
-  impl-&gt;tile_size = 1;
-}
-
-Tileset::Tileset(int tile_size_)
-  : impl(new TilesetImpl())
-{
-  assert(tile_size_ &gt; 0);
-  impl-&gt;tile_size = tile_size_;
-}
-
-Tileset::~Tileset()
-{
-}
-
-void
-Tileset::add_tile(int id, Tile* tile)
-{
-  // FIXME: Check for tile-id dups
-  if (id &gt;= int(impl-&gt;tiles.size()))
-    impl-&gt;tiles.resize(id+1, 0);
-
-  if (tile)
-    impl-&gt;tiles[id] = new Tile(*tile);
-  else
-    impl-&gt;tiles[id] = 0;
-
-  impl-&gt;tile_ids.push_back(id);
-}
-
-Tile* 
-Tileset::create (int id)
-{
-  if (id &gt;= 0 &amp;&amp; id &lt; int(impl-&gt;tiles.size()))
-    return impl-&gt;tiles[id];
-  else
-    return 0;
-}
-
-int
-Tileset::get_tile_size() const 
-{
-  return impl-&gt;tile_size; 
-}
-
-std::vector&lt;int&gt; 
-Tileset::get_tiles() const
-{
-  return impl-&gt;tile_ids;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tileset.hpp (from rev 712, trunk/flexlay/lib/tileset.hxx)
===================================================================
--- trunk/flexlay/lib/tileset.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tileset.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,64 @@
+//  $Id: tile_factory.hpp,v 1.8 2003/09/22 18:37:05 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2000 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef TILESET_HXX
+#define TILESET_HXX
+
+#include &lt;vector&gt;
+#include &lt;string&gt;
+#include &lt;ClanLib/Core/System/sharedptr.h&gt;
+
+class Tile;
+class TilesetImpl;
+
+/** A \a Tileset provides the mapping from an \a id to a \a Tile
+    structure. It also contains information of the tile_size and other
+    necesarry information that are needed to display a TileMap */
+class Tileset
+{
+public:
+  explicit Tileset();
+
+  /** Create an empty Tileset, so that the user can add stuff via
+      scripting to it */
+  explicit Tileset(int tile_size_);
+
+  ~Tileset();
+
+  /** Check if the tile is already loaded and return it. If it is not
+   *  already loaded, load it 
+   *
+   *  @param id The id of the tile to create as defined in the def. file
+   *
+   *  @return on success the tile is returned, on failure 0 */
+  Tile* create(int id);
+
+  int get_tile_size() const;
+  
+  void add_tile(int id, Tile* tile);
+
+  /** Return the tiles which are available in this tileset */
+  std::vector&lt;int&gt; get_tiles() const;
+
+private:
+  CL_SharedPtr&lt;TilesetImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tileset.hxx
===================================================================
--- trunk/flexlay/lib/tileset.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tileset.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,64 +0,0 @@
-//  $Id: tile_factory.hxx,v 1.8 2003/09/22 18:37:05 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2000 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef TILESET_HXX
-#define TILESET_HXX
-
-#include &lt;vector&gt;
-#include &lt;string&gt;
-#include &lt;ClanLib/Core/System/sharedptr.h&gt;
-
-class Tile;
-class TilesetImpl;
-
-/** A \a Tileset provides the mapping from an \a id to a \a Tile
-    structure. It also contains information of the tile_size and other
-    necesarry information that are needed to display a TileMap */
-class Tileset
-{
-public:
-  explicit Tileset();
-
-  /** Create an empty Tileset, so that the user can add stuff via
-      scripting to it */
-  explicit Tileset(int tile_size_);
-
-  ~Tileset();
-
-  /** Check if the tile is already loaded and return it. If it is not
-   *  already loaded, load it 
-   *
-   *  @param id The id of the tile to create as defined in the def. file
-   *
-   *  @return on success the tile is returned, on failure 0 */
-  Tile* create(int id);
-
-  int get_tile_size() const;
-  
-  void add_tile(int id, Tile* tile);
-
-  /** Return the tiles which are available in this tileset */
-  std::vector&lt;int&gt; get_tiles() const;
-
-private:
-  CL_SharedPtr&lt;TilesetImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/titlebar.cpp (from rev 712, trunk/flexlay/lib/titlebar.cxx)
===================================================================
--- trunk/flexlay/lib/titlebar.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/titlebar.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,125 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &lt;ClanLib/Display/keys.h&gt;
+#include &lt;ClanLib/Display/mouse.h&gt;
+#include &quot;fonts.hpp&quot;
+#include &quot;titlebar.hpp&quot;
+
+class TitlebarImpl
+{
+public:
+  CL_Component* window;
+  Titlebar* parent;
+  CL_Point click_pos;
+  CL_Rect old_pos;
+  std::string title;
+  std::vector&lt;CL_Slot&gt; slots;
+  bool pressed;
+
+  TitlebarImpl(Titlebar* parent_) : parent(parent_) {}
+
+  void on_mouse_move(const CL_InputEvent&amp; event);
+  void on_mouse_down(const CL_InputEvent&amp; event);
+  void on_mouse_up(const CL_InputEvent&amp; event);
+  void draw();
+};
+
+Titlebar::Titlebar(const CL_Rect&amp; rect, const std::string&amp; title, CL_Component* parent)
+  : CL_Component(rect, parent),
+    impl(new TitlebarImpl(this))
+{
+  impl-&gt;title = title;
+  impl-&gt;pressed = false;
+  impl-&gt;window = parent;
+
+  impl-&gt;slots.push_back(sig_mouse_down().connect(impl.get(), &amp;TitlebarImpl::on_mouse_down));
+  impl-&gt;slots.push_back(sig_mouse_move().connect(impl.get(), &amp;TitlebarImpl::on_mouse_move));
+  impl-&gt;slots.push_back(sig_mouse_up().connect(impl.get(), &amp;TitlebarImpl::on_mouse_up));
+  impl-&gt;slots.push_back(sig_paint().connect(impl.get(), &amp;TitlebarImpl::draw));
+}
+
+void
+TitlebarImpl::on_mouse_up(const CL_InputEvent&amp; event)
+{
+  if (event.id == CL_MOUSE_LEFT)
+    {
+      pressed = false;
+      parent-&gt;release_mouse();
+    }
+}
+
+void
+TitlebarImpl::on_mouse_down(const CL_InputEvent&amp; event)
+{
+  if (event.id == CL_MOUSE_LEFT)
+    {
+      pressed   = true;
+      click_pos = event.mouse_pos;
+      parent-&gt;capture_mouse();
+      window-&gt;raise();
+
+      old_pos = window-&gt;get_position();
+      click_pos.x += old_pos.left;
+      click_pos.y += old_pos.top;
+    } 
+}
+
+void
+TitlebarImpl::on_mouse_move(const CL_InputEvent&amp; event)
+{
+  if(pressed)
+    {
+      CL_Rect rect = window-&gt;get_position();
+
+      CL_Point move(old_pos.left - (click_pos.x - (rect.left + event.mouse_pos.x)), 
+                    old_pos.top  - (click_pos.y - (rect.top  + event.mouse_pos.y)));
+
+      window-&gt;set_position(move.x, move.y);
+    }
+}
+
+void
+TitlebarImpl::draw()
+{
+  CL_Display::push_translate(parent-&gt;get_screen_x(), parent-&gt;get_screen_y());
+
+  // FIXME: Hack should be done via has_mouse_over(), but that doesn't include child components
+  if (parent-&gt;get_parent()-&gt;get_position().is_inside(CL_Point(CL_Mouse::get_x(), 
+                                                              CL_Mouse::get_y())))
+      //parent-&gt;get_parent()-&gt;has_mouse_over())
+    {
+      CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
+                                    CL_Size(parent-&gt;get_width()-1, parent-&gt;get_height())), 
+                            CL_Color(250, 250, 250));
+    }
+  else
+    {
+      CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
+                                    CL_Size(parent-&gt;get_width()-1, parent-&gt;get_height())), 
+                            CL_Color(240, 240, 240));
+    }
+
+  Fonts::verdana11.draw(4, 0, title);
+
+  CL_Display::pop_modelview();
+}
+                  
+/* EOF */

Deleted: trunk/flexlay/lib/titlebar.cxx
===================================================================
--- trunk/flexlay/lib/titlebar.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/titlebar.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,125 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-#include &lt;ClanLib/Display/keys.h&gt;
-#include &lt;ClanLib/Display/mouse.h&gt;
-#include &quot;fonts.hxx&quot;
-#include &quot;titlebar.hxx&quot;
-
-class TitlebarImpl
-{
-public:
-  CL_Component* window;
-  Titlebar* parent;
-  CL_Point click_pos;
-  CL_Rect old_pos;
-  std::string title;
-  std::vector&lt;CL_Slot&gt; slots;
-  bool pressed;
-
-  TitlebarImpl(Titlebar* parent_) : parent(parent_) {}
-
-  void on_mouse_move(const CL_InputEvent&amp; event);
-  void on_mouse_down(const CL_InputEvent&amp; event);
-  void on_mouse_up(const CL_InputEvent&amp; event);
-  void draw();
-};
-
-Titlebar::Titlebar(const CL_Rect&amp; rect, const std::string&amp; title, CL_Component* parent)
-  : CL_Component(rect, parent),
-    impl(new TitlebarImpl(this))
-{
-  impl-&gt;title = title;
-  impl-&gt;pressed = false;
-  impl-&gt;window = parent;
-
-  impl-&gt;slots.push_back(sig_mouse_down().connect(impl.get(), &amp;TitlebarImpl::on_mouse_down));
-  impl-&gt;slots.push_back(sig_mouse_move().connect(impl.get(), &amp;TitlebarImpl::on_mouse_move));
-  impl-&gt;slots.push_back(sig_mouse_up().connect(impl.get(), &amp;TitlebarImpl::on_mouse_up));
-  impl-&gt;slots.push_back(sig_paint().connect(impl.get(), &amp;TitlebarImpl::draw));
-}
-
-void
-TitlebarImpl::on_mouse_up(const CL_InputEvent&amp; event)
-{
-  if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed = false;
-      parent-&gt;release_mouse();
-    }
-}
-
-void
-TitlebarImpl::on_mouse_down(const CL_InputEvent&amp; event)
-{
-  if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed   = true;
-      click_pos = event.mouse_pos;
-      parent-&gt;capture_mouse();
-      window-&gt;raise();
-
-      old_pos = window-&gt;get_position();
-      click_pos.x += old_pos.left;
-      click_pos.y += old_pos.top;
-    } 
-}
-
-void
-TitlebarImpl::on_mouse_move(const CL_InputEvent&amp; event)
-{
-  if(pressed)
-    {
-      CL_Rect rect = window-&gt;get_position();
-
-      CL_Point move(old_pos.left - (click_pos.x - (rect.left + event.mouse_pos.x)), 
-                    old_pos.top  - (click_pos.y - (rect.top  + event.mouse_pos.y)));
-
-      window-&gt;set_position(move.x, move.y);
-    }
-}
-
-void
-TitlebarImpl::draw()
-{
-  CL_Display::push_translate(parent-&gt;get_screen_x(), parent-&gt;get_screen_y());
-
-  // FIXME: Hack should be done via has_mouse_over(), but that doesn't include child components
-  if (parent-&gt;get_parent()-&gt;get_position().is_inside(CL_Point(CL_Mouse::get_x(), 
-                                                              CL_Mouse::get_y())))
-      //parent-&gt;get_parent()-&gt;has_mouse_over())
-    {
-      CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
-                                    CL_Size(parent-&gt;get_width()-1, parent-&gt;get_height())), 
-                            CL_Color(250, 250, 250));
-    }
-  else
-    {
-      CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
-                                    CL_Size(parent-&gt;get_width()-1, parent-&gt;get_height())), 
-                            CL_Color(240, 240, 240));
-    }
-
-  Fonts::verdana11.draw(4, 0, title);
-
-  CL_Display::pop_modelview();
-}
-                  
-/* EOF */

Copied: trunk/flexlay/lib/titlebar.hpp (from rev 712, trunk/flexlay/lib/titlebar.hxx)
===================================================================
--- trunk/flexlay/lib/titlebar.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/titlebar.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,42 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_TITLEBAR_HXX
+#define HEADER_TITLEBAR_HXX
+
+#include &lt;ClanLib/GUI/component.h&gt;
+#include &lt;ClanLib/Core/Math/rect.h&gt;
+#include &quot;shared_ptr.hpp&quot;
+
+class TitlebarImpl;
+
+/** */
+class Titlebar : public CL_Component
+{
+protected:
+  virtual ~Titlebar() {}
+public:
+  Titlebar(const CL_Rect&amp; rect, const std::string&amp; title, CL_Component* parent);
+
+private:
+  SharedPtr&lt;TitlebarImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/titlebar.hxx
===================================================================
--- trunk/flexlay/lib/titlebar.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/titlebar.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,42 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_TITLEBAR_HXX
-#define HEADER_TITLEBAR_HXX
-
-#include &lt;ClanLib/GUI/component.h&gt;
-#include &lt;ClanLib/Core/Math/rect.h&gt;
-#include &quot;shared_ptr.hxx&quot;
-
-class TitlebarImpl;
-
-/** */
-class Titlebar : public CL_Component
-{
-protected:
-  virtual ~Titlebar() {}
-public:
-  Titlebar(const CL_Rect&amp; rect, const std::string&amp; title, CL_Component* parent);
-
-private:
-  SharedPtr&lt;TitlebarImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/layer_move_tool.cpp (from rev 712, trunk/flexlay/lib/tools/layer_move_tool.cxx)
===================================================================
--- trunk/flexlay/lib/tools/layer_move_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/layer_move_tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,133 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2004 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#include &lt;ClanLib/Core/Math/point.h&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &quot;workspace.hpp&quot;
+#include &quot;tool_impl.hpp&quot;
+#include &quot;editor_map_component.hpp&quot;
+#include &quot;editor_map.hpp&quot;
+#include &quot;layer.hpp&quot;
+#include &quot;layer_move_tool.hpp&quot;
+
+class LayerMoveToolImpl : public ToolImpl
+{
+public:
+  bool scrolling;
+  CL_Pointf click_pos;
+
+  /** Position of the center */
+  CL_Pointf old_trans_offset;
+  Layer layer;
+  
+  Layer find_closed_layer(const CL_Pointf&amp; pos)
+  {
+    Layer layer; 
+
+    EditorMap parent = EditorMapComponent::current()-&gt;get_workspace().get_map();
+
+    for(int i = 0; i &lt; parent.get_layer_count(); ++i)
+      {
+        if (parent.get_layer(i).get_bounding_rect().is_inside(CL_Point(pos)))
+          layer = parent.get_layer(i);
+      }
+
+    return layer;
+  }
+
+  void draw() 
+  {
+    for(int i = 0; i &lt; EditorMapComponent::current()-&gt;get_workspace().get_map().get_layer_count(); ++i)
+      {
+        Layer layer = EditorMapComponent::current()-&gt;get_workspace().get_map().get_layer(i);
+        if (layer.has_bounding_rect())
+          {
+            CL_Rect rect = layer.get_bounding_rect();
+            CL_Display::draw_line(rect.left, rect.top, rect.right, rect.bottom,
+                                  CL_Color(0, 255, 255));
+            CL_Display::draw_line(rect.left, rect.bottom, rect.right, rect.top,
+                                  CL_Color(0, 255, 255));
+          }
+      }
+  }
+
+  void on_mouse_up  (const CL_InputEvent&amp; event) 
+  {
+    if (!layer.is_null())
+      {
+        scrolling = false;
+        update(event);
+        EditorMapComponent::current()-&gt;release_mouse();
+        layer = Layer();
+      }
+  }
+
+  void on_mouse_down(const CL_InputEvent&amp; event)
+  {
+    EditorMapComponent* parent = EditorMapComponent::current();
+    CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
+
+    layer = find_closed_layer(pos);
+    if (!layer.is_null())
+      {
+        scrolling = true;
+        old_trans_offset = layer.get_pos();
+        click_pos = pos;
+        EditorMapComponent::current()-&gt;capture_mouse();
+      }
+  }
+
+  void on_mouse_move(const CL_InputEvent&amp; event)
+  {
+    if (!layer.is_null())
+      {
+        if (scrolling)
+          {
+            update(event);
+          }
+      }    
+  }
+
+  void update(const CL_InputEvent&amp; event)
+  {
+    if (!layer.is_null())
+      {
+        EditorMapComponent* parent = EditorMapComponent::current();
+        CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
+        layer.set_pos(old_trans_offset + (pos - click_pos));
+      }
+  }
+};
+
+LayerMoveTool::LayerMoveTool()
+  : impl(new LayerMoveToolImpl())
+{
+  impl-&gt;scrolling = false;
+  impl-&gt;click_pos = CL_Point(0, 0);
+  impl-&gt;old_trans_offset = CL_Pointf(0,0);
+}
+
+Tool
+LayerMoveTool::to_tool()
+{
+  return Tool(impl);
+}
+
+/* EOF */
+

Deleted: trunk/flexlay/lib/tools/layer_move_tool.cxx
===================================================================
--- trunk/flexlay/lib/tools/layer_move_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/layer_move_tool.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,133 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2004 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#include &lt;ClanLib/Core/Math/point.h&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-#include &quot;workspace.hxx&quot;
-#include &quot;tool_impl.hxx&quot;
-#include &quot;editor_map_component.hxx&quot;
-#include &quot;editor_map.hxx&quot;
-#include &quot;layer.hxx&quot;
-#include &quot;layer_move_tool.hxx&quot;
-
-class LayerMoveToolImpl : public ToolImpl
-{
-public:
-  bool scrolling;
-  CL_Pointf click_pos;
-
-  /** Position of the center */
-  CL_Pointf old_trans_offset;
-  Layer layer;
-  
-  Layer find_closed_layer(const CL_Pointf&amp; pos)
-  {
-    Layer layer; 
-
-    EditorMap parent = EditorMapComponent::current()-&gt;get_workspace().get_map();
-
-    for(int i = 0; i &lt; parent.get_layer_count(); ++i)
-      {
-        if (parent.get_layer(i).get_bounding_rect().is_inside(CL_Point(pos)))
-          layer = parent.get_layer(i);
-      }
-
-    return layer;
-  }
-
-  void draw() 
-  {
-    for(int i = 0; i &lt; EditorMapComponent::current()-&gt;get_workspace().get_map().get_layer_count(); ++i)
-      {
-        Layer layer = EditorMapComponent::current()-&gt;get_workspace().get_map().get_layer(i);
-        if (layer.has_bounding_rect())
-          {
-            CL_Rect rect = layer.get_bounding_rect();
-            CL_Display::draw_line(rect.left, rect.top, rect.right, rect.bottom,
-                                  CL_Color(0, 255, 255));
-            CL_Display::draw_line(rect.left, rect.bottom, rect.right, rect.top,
-                                  CL_Color(0, 255, 255));
-          }
-      }
-  }
-
-  void on_mouse_up  (const CL_InputEvent&amp; event) 
-  {
-    if (!layer.is_null())
-      {
-        scrolling = false;
-        update(event);
-        EditorMapComponent::current()-&gt;release_mouse();
-        layer = Layer();
-      }
-  }
-
-  void on_mouse_down(const CL_InputEvent&amp; event)
-  {
-    EditorMapComponent* parent = EditorMapComponent::current();
-    CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
-
-    layer = find_closed_layer(pos);
-    if (!layer.is_null())
-      {
-        scrolling = true;
-        old_trans_offset = layer.get_pos();
-        click_pos = pos;
-        EditorMapComponent::current()-&gt;capture_mouse();
-      }
-  }
-
-  void on_mouse_move(const CL_InputEvent&amp; event)
-  {
-    if (!layer.is_null())
-      {
-        if (scrolling)
-          {
-            update(event);
-          }
-      }    
-  }
-
-  void update(const CL_InputEvent&amp; event)
-  {
-    if (!layer.is_null())
-      {
-        EditorMapComponent* parent = EditorMapComponent::current();
-        CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
-        layer.set_pos(old_trans_offset + (pos - click_pos));
-      }
-  }
-};
-
-LayerMoveTool::LayerMoveTool()
-  : impl(new LayerMoveToolImpl())
-{
-  impl-&gt;scrolling = false;
-  impl-&gt;click_pos = CL_Point(0, 0);
-  impl-&gt;old_trans_offset = CL_Pointf(0,0);
-}
-
-Tool
-LayerMoveTool::to_tool()
-{
-  return Tool(impl);
-}
-
-/* EOF */
-

Copied: trunk/flexlay/lib/tools/layer_move_tool.hpp (from rev 712, trunk/flexlay/lib/tools/layer_move_tool.hxx)
===================================================================
--- trunk/flexlay/lib/tools/layer_move_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/layer_move_tool.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,40 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2004 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#ifndef HEADER_LAYER_MOVE_TOOL_HXX
+#define HEADER_LAYER_MOVE_TOOL_HXX
+
+#include &quot;tool.hpp&quot;
+
+class LayerMoveToolImpl;
+
+/** */
+class LayerMoveTool : public Tool
+{
+public:
+  LayerMoveTool();
+
+  Tool to_tool();
+private:
+  SharedPtr&lt;LayerMoveToolImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/layer_move_tool.hxx
===================================================================
--- trunk/flexlay/lib/tools/layer_move_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/layer_move_tool.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,40 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2004 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#ifndef HEADER_LAYER_MOVE_TOOL_HXX
-#define HEADER_LAYER_MOVE_TOOL_HXX
-
-#include &quot;tool.hxx&quot;
-
-class LayerMoveToolImpl;
-
-/** */
-class LayerMoveTool : public Tool
-{
-public:
-  LayerMoveTool();
-
-  Tool to_tool();
-private:
-  SharedPtr&lt;LayerMoveToolImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/objmap_select_tool.cpp (from rev 712, trunk/flexlay/lib/tools/objmap_select_tool.cxx)
===================================================================
--- trunk/flexlay/lib/tools/objmap_select_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/objmap_select_tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,325 @@
+//  $Id: tilemap_object_tool.cxx,v 1.1 2003/09/23 22:10:40 grumbel Exp $
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#include &lt;algorithm&gt;
+#include &lt;ClanLib/Display/keys.h&gt;
+#include &lt;ClanLib/Display/keyboard.h&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &quot;editor_map_component.hpp&quot;
+#include &quot;editor_map.hpp&quot;
+#include &quot;editor_map_component.hpp&quot;
+#include &quot;gui_manager.hpp&quot;
+#include &quot;editor_names.hpp&quot;
+#include &quot;popup_menu.hpp&quot;
+#include &quot;objmap_object.hpp&quot;
+#include &quot;objmap_control_point.hpp&quot;
+#include &quot;object_move_command.hpp&quot;
+#include &quot;object_delete_command.hpp&quot;
+#include &quot;tool_impl.hpp&quot;
+#include &quot;objmap_select_tool.hpp&quot;
+
+class ObjMapSelectToolImpl : public ToolImpl
+{
+public:
+  CL_Signal_v1&lt;CL_Menu*&gt; on_popup_menu_display;
+  CL_Signal_v2&lt;int, int&gt; on_right_click;
+
+  enum { DRAG, SELECT, NONE } state;
+
+  /** the position on which the object was clicked, relative to the
+      object */
+  CL_Pointf offset;
+
+  CL_Pointf drag_start;
+  CL_Rectf selection_rect;
+
+  ObjMapControlPoint control_point;
+  ObjMapSelectTool::Selection selection;
+  ObjectMoveCommand*   move_command;
+  ObjectDeleteCommand* delete_command;
+
+  void draw();
+
+  void on_mouse_up  (const CL_InputEvent&amp; event);
+  void on_mouse_down(const CL_InputEvent&amp; event);
+  void on_mouse_move(const CL_InputEvent&amp; event);
+
+  void on_selection_change();
+};
+
+ObjMapSelectTool::ObjMapSelectTool()
+  : impl(new ObjMapSelectToolImpl())
+{
+  impl-&gt;state = ObjMapSelectToolImpl::NONE;
+  impl-&gt;offset = CL_Pointf(0, 0);
+  impl-&gt;move_command = 0;
+}
+
+ObjMapSelectTool::~ObjMapSelectTool()
+{
+}
+ 
+void
+ObjMapSelectTool::clear_selection()
+{
+  impl-&gt;selection.clear(); 
+  impl-&gt;on_selection_change();
+}
+
+ObjMapSelectTool::Selection
+ObjMapSelectTool::get_selection() const 
+{ 
+  return impl-&gt;selection;
+}
+
+void
+ObjMapSelectTool::set_selection(const Selection&amp; sel) 
+{ 
+  impl-&gt;selection = sel; 
+}
+
+CL_Signal_v1&lt;CL_Menu*&gt;&amp; 
+ObjMapSelectTool::sig_on_popup_menu_display()
+{
+  return impl-&gt;on_popup_menu_display; 
+}
+
+CL_Signal_v2&lt;int, int&gt;&amp;
+ObjMapSelectTool::sig_on_right_click()
+{
+  return impl-&gt;on_right_click;
+}
+
+void
+ObjMapSelectToolImpl::draw()
+{
+  for (ObjMapSelectTool::Selection::iterator i = selection.begin(); i != selection.end(); ++i)
+    {
+      //      (*i).draw();
+      CL_Display::draw_rect((*i).get_bound_rect(), CL_Color(255, 0, 0));
+    }
+
+  switch(state)
+    {
+    case DRAG:
+      break;
+    case SELECT:
+      CL_Display::draw_rect(selection_rect,
+                            CL_Color(255, 255, 255));
+      break;
+    default:
+      break;
+    }
+}
+
+void
+ObjMapSelectToolImpl::on_mouse_up(const CL_InputEvent&amp; event)
+{
+  ObjectLayer objmap = ObjectLayer::current();
+
+  EditorMapComponent* parent = EditorMapComponent::current();
+
+  CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
+
+  switch (event.id)
+    {
+    case CL_MOUSE_LEFT:
+      switch(state)
+        {
+        case DRAG:
+          if (move_command)
+            {
+              Workspace::current().get_map().execute(move_command-&gt;to_command());
+              move_command = 0;
+            }
+          state = NONE;
+          parent-&gt;release_mouse();
+          break;
+
+        case SELECT:
+          state = NONE;
+          
+          selection_rect.right  = pos.x;
+          selection_rect.bottom = pos.y;
+          selection_rect.normalize();
+
+          selection = objmap.get_selection(selection_rect);
+          on_selection_change();
+          parent-&gt;release_mouse();
+          break;
+
+        default:
+          break;
+        }
+      break;
+
+    case CL_MOUSE_RIGHT:
+      {
+        on_right_click(event.mouse_pos.x + parent-&gt;get_screen_rect().left,
+                       event.mouse_pos.y + parent-&gt;get_screen_rect().top);
+        /*
+        PopupMenu* menu = new PopupMenu(CL_Point(event.mouse_pos.x + parent-&gt;get_screen_rect().left,
+                                                 event.mouse_pos.y + parent-&gt;get_screen_rect().top), 
+                                        GUIManager::current()-&gt;get_component());
+
+                                        on_popup_menu_display(menu-&gt;get_menu());*/
+      }
+      break;
+    }
+}
+
+void
+ObjMapSelectToolImpl::on_mouse_down(const CL_InputEvent&amp; event)
+{
+  ObjectLayer objmap = ObjectLayer::current();
+
+  EditorMapComponent* parent = EditorMapComponent::current();
+  CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
+      
+  switch (event.id)
+    {
+    case CL_MOUSE_LEFT:
+      switch(state)
+        {
+        default:
+          control_point = objmap.find_control_point(pos);
+
+          if (!control_point.is_null())
+            {
+              state = DRAG;
+              parent-&gt;capture_mouse();
+              offset = pos - control_point.get_pos();
+              drag_start = pos;
+            }
+          else
+            {
+              ObjMapObject obj = objmap.find_object(pos);
+
+              if (!obj.is_null())
+                {
+                  if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT))
+                    {
+                      ObjMapSelectTool::Selection::iterator i
+                        = std::find(selection.begin(), selection.end(), obj);
+                      if (i == selection.end())
+                        selection.push_back(obj);
+                      else
+                        selection.erase(i);
+
+                      on_selection_change();
+                    }
+                  else
+                    {
+                      state = DRAG;
+                      parent-&gt;capture_mouse();
+                      offset = pos - obj.get_pos();
+                      drag_start = pos;
+
+                      if (std::find(selection.begin(), selection.end(), obj) == selection.end())
+                        { // Clicked object is not in the selection, so we add it
+                          selection.clear();
+                          objmap.delete_control_points();
+                          selection.push_back(obj);
+                          on_selection_change();
+                        }
+
+                      move_command = new ObjectMoveCommand(objmap);
+                      for (ObjMapSelectTool::Selection::iterator i = selection.begin();
+                           i != selection.end(); ++i)
+                        {
+                          move_command-&gt;add_obj(*i);
+                        }
+                    }
+                }
+              else
+                {
+                  state = SELECT;
+                  selection_rect = CL_Rectf(pos.x, pos.y, pos.x, pos.y);
+                  parent-&gt;capture_mouse();
+                }
+            }
+          break;
+        }
+      break;
+
+    case CL_MOUSE_RIGHT:
+      break;
+    }
+}
+
+void
+ObjMapSelectToolImpl::on_mouse_move(const CL_InputEvent&amp; event)
+{
+  EditorMapComponent* parent = EditorMapComponent::current();
+  CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
+
+  switch(state)
+    {
+    case DRAG:
+      if (!control_point.is_null())
+        {
+          control_point.set_pos(pos - offset);
+        }
+      else
+        {
+          move_command-&gt;move_by(pos - drag_start);
+          if (selection.size() == 1)
+            selection.front().update_control_points();
+        }
+      /*
+      for (ObjMapSelectTool::Selection::iterator i = selection.begin(); 
+           i != selection.end(); ++i)
+        {
+          (*i).set_pos((*i).get_pos() + (pos - drag_start));
+          // FIXME: Move this into ObjMapObject
+          (*i).sig_move()(*i);
+        }*/
+      //drag_start = pos;
+      break;
+
+    case SELECT:
+      selection_rect.right  = pos.x;
+      selection_rect.bottom = pos.y;
+      break;
+
+    default:
+      // FIXME: Add some kind of highlighting here if mouse is over an object
+      break;
+    }
+}
+
+Tool
+ObjMapSelectTool::to_tool()
+{
+  return Tool(impl); 
+}
+
+void
+ObjMapSelectToolImpl::on_selection_change()
+{
+  ObjectLayer objmap = ObjectLayer::current();
+  objmap.delete_control_points();
+
+  if (selection.size() == 1)
+    {
+      selection.front().add_control_points();
+    } 
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/objmap_select_tool.cxx
===================================================================
--- trunk/flexlay/lib/tools/objmap_select_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/objmap_select_tool.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,325 +0,0 @@
-//  $Id: tilemap_object_tool.cxx,v 1.1 2003/09/23 22:10:40 grumbel Exp $
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#include &lt;algorithm&gt;
-#include &lt;ClanLib/Display/keys.h&gt;
-#include &lt;ClanLib/Display/keyboard.h&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-#include &quot;editor_map_component.hxx&quot;
-#include &quot;editor_map.hxx&quot;
-#include &quot;editor_map_component.hxx&quot;
-#include &quot;gui_manager.hxx&quot;
-#include &quot;editor_names.hxx&quot;
-#include &quot;popup_menu.hxx&quot;
-#include &quot;objmap_object.hxx&quot;
-#include &quot;objmap_control_point.hxx&quot;
-#include &quot;object_move_command.hxx&quot;
-#include &quot;object_delete_command.hxx&quot;
-#include &quot;tool_impl.hxx&quot;
-#include &quot;objmap_select_tool.hxx&quot;
-
-class ObjMapSelectToolImpl : public ToolImpl
-{
-public:
-  CL_Signal_v1&lt;CL_Menu*&gt; on_popup_menu_display;
-  CL_Signal_v2&lt;int, int&gt; on_right_click;
-
-  enum { DRAG, SELECT, NONE } state;
-
-  /** the position on which the object was clicked, relative to the
-      object */
-  CL_Pointf offset;
-
-  CL_Pointf drag_start;
-  CL_Rectf selection_rect;
-
-  ObjMapControlPoint control_point;
-  ObjMapSelectTool::Selection selection;
-  ObjectMoveCommand*   move_command;
-  ObjectDeleteCommand* delete_command;
-
-  void draw();
-
-  void on_mouse_up  (const CL_InputEvent&amp; event);
-  void on_mouse_down(const CL_InputEvent&amp; event);
-  void on_mouse_move(const CL_InputEvent&amp; event);
-
-  void on_selection_change();
-};
-
-ObjMapSelectTool::ObjMapSelectTool()
-  : impl(new ObjMapSelectToolImpl())
-{
-  impl-&gt;state = ObjMapSelectToolImpl::NONE;
-  impl-&gt;offset = CL_Pointf(0, 0);
-  impl-&gt;move_command = 0;
-}
-
-ObjMapSelectTool::~ObjMapSelectTool()
-{
-}
- 
-void
-ObjMapSelectTool::clear_selection()
-{
-  impl-&gt;selection.clear(); 
-  impl-&gt;on_selection_change();
-}
-
-ObjMapSelectTool::Selection
-ObjMapSelectTool::get_selection() const 
-{ 
-  return impl-&gt;selection;
-}
-
-void
-ObjMapSelectTool::set_selection(const Selection&amp; sel) 
-{ 
-  impl-&gt;selection = sel; 
-}
-
-CL_Signal_v1&lt;CL_Menu*&gt;&amp; 
-ObjMapSelectTool::sig_on_popup_menu_display()
-{
-  return impl-&gt;on_popup_menu_display; 
-}
-
-CL_Signal_v2&lt;int, int&gt;&amp;
-ObjMapSelectTool::sig_on_right_click()
-{
-  return impl-&gt;on_right_click;
-}
-
-void
-ObjMapSelectToolImpl::draw()
-{
-  for (ObjMapSelectTool::Selection::iterator i = selection.begin(); i != selection.end(); ++i)
-    {
-      //      (*i).draw();
-      CL_Display::draw_rect((*i).get_bound_rect(), CL_Color(255, 0, 0));
-    }
-
-  switch(state)
-    {
-    case DRAG:
-      break;
-    case SELECT:
-      CL_Display::draw_rect(selection_rect,
-                            CL_Color(255, 255, 255));
-      break;
-    default:
-      break;
-    }
-}
-
-void
-ObjMapSelectToolImpl::on_mouse_up(const CL_InputEvent&amp; event)
-{
-  ObjectLayer objmap = ObjectLayer::current();
-
-  EditorMapComponent* parent = EditorMapComponent::current();
-
-  CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
-
-  switch (event.id)
-    {
-    case CL_MOUSE_LEFT:
-      switch(state)
-        {
-        case DRAG:
-          if (move_command)
-            {
-              Workspace::current().get_map().execute(move_command-&gt;to_command());
-              move_command = 0;
-            }
-          state = NONE;
-          parent-&gt;release_mouse();
-          break;
-
-        case SELECT:
-          state = NONE;
-          
-          selection_rect.right  = pos.x;
-          selection_rect.bottom = pos.y;
-          selection_rect.normalize();
-
-          selection = objmap.get_selection(selection_rect);
-          on_selection_change();
-          parent-&gt;release_mouse();
-          break;
-
-        default:
-          break;
-        }
-      break;
-
-    case CL_MOUSE_RIGHT:
-      {
-        on_right_click(event.mouse_pos.x + parent-&gt;get_screen_rect().left,
-                       event.mouse_pos.y + parent-&gt;get_screen_rect().top);
-        /*
-        PopupMenu* menu = new PopupMenu(CL_Point(event.mouse_pos.x + parent-&gt;get_screen_rect().left,
-                                                 event.mouse_pos.y + parent-&gt;get_screen_rect().top), 
-                                        GUIManager::current()-&gt;get_component());
-
-                                        on_popup_menu_display(menu-&gt;get_menu());*/
-      }
-      break;
-    }
-}
-
-void
-ObjMapSelectToolImpl::on_mouse_down(const CL_InputEvent&amp; event)
-{
-  ObjectLayer objmap = ObjectLayer::current();
-
-  EditorMapComponent* parent = EditorMapComponent::current();
-  CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
-      
-  switch (event.id)
-    {
-    case CL_MOUSE_LEFT:
-      switch(state)
-        {
-        default:
-          control_point = objmap.find_control_point(pos);
-
-          if (!control_point.is_null())
-            {
-              state = DRAG;
-              parent-&gt;capture_mouse();
-              offset = pos - control_point.get_pos();
-              drag_start = pos;
-            }
-          else
-            {
-              ObjMapObject obj = objmap.find_object(pos);
-
-              if (!obj.is_null())
-                {
-                  if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT))
-                    {
-                      ObjMapSelectTool::Selection::iterator i
-                        = std::find(selection.begin(), selection.end(), obj);
-                      if (i == selection.end())
-                        selection.push_back(obj);
-                      else
-                        selection.erase(i);
-
-                      on_selection_change();
-                    }
-                  else
-                    {
-                      state = DRAG;
-                      parent-&gt;capture_mouse();
-                      offset = pos - obj.get_pos();
-                      drag_start = pos;
-
-                      if (std::find(selection.begin(), selection.end(), obj) == selection.end())
-                        { // Clicked object is not in the selection, so we add it
-                          selection.clear();
-                          objmap.delete_control_points();
-                          selection.push_back(obj);
-                          on_selection_change();
-                        }
-
-                      move_command = new ObjectMoveCommand(objmap);
-                      for (ObjMapSelectTool::Selection::iterator i = selection.begin();
-                           i != selection.end(); ++i)
-                        {
-                          move_command-&gt;add_obj(*i);
-                        }
-                    }
-                }
-              else
-                {
-                  state = SELECT;
-                  selection_rect = CL_Rectf(pos.x, pos.y, pos.x, pos.y);
-                  parent-&gt;capture_mouse();
-                }
-            }
-          break;
-        }
-      break;
-
-    case CL_MOUSE_RIGHT:
-      break;
-    }
-}
-
-void
-ObjMapSelectToolImpl::on_mouse_move(const CL_InputEvent&amp; event)
-{
-  EditorMapComponent* parent = EditorMapComponent::current();
-  CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
-
-  switch(state)
-    {
-    case DRAG:
-      if (!control_point.is_null())
-        {
-          control_point.set_pos(pos - offset);
-        }
-      else
-        {
-          move_command-&gt;move_by(pos - drag_start);
-          if (selection.size() == 1)
-            selection.front().update_control_points();
-        }
-      /*
-      for (ObjMapSelectTool::Selection::iterator i = selection.begin(); 
-           i != selection.end(); ++i)
-        {
-          (*i).set_pos((*i).get_pos() + (pos - drag_start));
-          // FIXME: Move this into ObjMapObject
-          (*i).sig_move()(*i);
-        }*/
-      //drag_start = pos;
-      break;
-
-    case SELECT:
-      selection_rect.right  = pos.x;
-      selection_rect.bottom = pos.y;
-      break;
-
-    default:
-      // FIXME: Add some kind of highlighting here if mouse is over an object
-      break;
-    }
-}
-
-Tool
-ObjMapSelectTool::to_tool()
-{
-  return Tool(impl); 
-}
-
-void
-ObjMapSelectToolImpl::on_selection_change()
-{
-  ObjectLayer objmap = ObjectLayer::current();
-  objmap.delete_control_points();
-
-  if (selection.size() == 1)
-    {
-      selection.front().add_control_points();
-    } 
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/objmap_select_tool.hpp (from rev 712, trunk/flexlay/lib/tools/objmap_select_tool.hxx)
===================================================================
--- trunk/flexlay/lib/tools/objmap_select_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/objmap_select_tool.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,53 @@
+//  $Id: tilemap_object_tool.hpp,v 1.1 2003/09/23 22:10:40 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#ifndef HEADER_OBJMAP_SELECT_TOOL_HXX
+#define HEADER_OBJMAP_SELECT_TOOL_HXX
+
+#include &quot;object_layer.hpp&quot;
+#include &quot;object_brush.hpp&quot;
+#include &quot;tool.hpp&quot;
+
+class CL_Menu;
+class ObjMapSelectToolImpl;
+
+/** */
+class ObjMapSelectTool
+{
+public:
+  typedef std::vector&lt;ObjMapObject&gt; Selection; 
+
+  ObjMapSelectTool();
+  ~ObjMapSelectTool();
+
+  void clear_selection();
+  Selection get_selection() const;
+  void set_selection(const Selection&amp; sel);
+
+  CL_Signal_v2&lt;int, int&gt;&amp; sig_on_right_click();
+  CL_Signal_v1&lt;CL_Menu*&gt;&amp; sig_on_popup_menu_display();
+
+  Tool to_tool();
+private:
+  SharedPtr&lt;ObjMapSelectToolImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/objmap_select_tool.hxx
===================================================================
--- trunk/flexlay/lib/tools/objmap_select_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/objmap_select_tool.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,53 +0,0 @@
-//  $Id: tilemap_object_tool.hxx,v 1.1 2003/09/23 22:10:40 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#ifndef HEADER_OBJMAP_SELECT_TOOL_HXX
-#define HEADER_OBJMAP_SELECT_TOOL_HXX
-
-#include &quot;object_layer.hxx&quot;
-#include &quot;object_brush.hxx&quot;
-#include &quot;tool.hxx&quot;
-
-class CL_Menu;
-class ObjMapSelectToolImpl;
-
-/** */
-class ObjMapSelectTool
-{
-public:
-  typedef std::vector&lt;ObjMapObject&gt; Selection; 
-
-  ObjMapSelectTool();
-  ~ObjMapSelectTool();
-
-  void clear_selection();
-  Selection get_selection() const;
-  void set_selection(const Selection&amp; sel);
-
-  CL_Signal_v2&lt;int, int&gt;&amp; sig_on_right_click();
-  CL_Signal_v1&lt;CL_Menu*&gt;&amp; sig_on_popup_menu_display();
-
-  Tool to_tool();
-private:
-  SharedPtr&lt;ObjMapSelectToolImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/sketch_stroke_tool.cpp (from rev 712, trunk/flexlay/lib/tools/sketch_stroke_tool.cxx)
===================================================================
--- trunk/flexlay/lib/tools/sketch_stroke_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/sketch_stroke_tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,166 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#include &lt;iostream&gt;
+#include &lt;assert.h&gt;
+#include &lt;ClanLib/gl.h&gt;
+#include &lt;ClanLib/Display/input_event.h&gt;
+#include &lt;ClanLib/Display/keys.h&gt;
+#include &lt;ClanLib/Display/mouse.h&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &lt;ClanLib/Display/input_context.h&gt;
+#include &quot;editor_map_component.hpp&quot;
+#include &quot;tool.hpp&quot;
+#include &quot;bitmap_layer.hpp&quot;
+#include &quot;sketch_stroke_tool.hpp&quot;
+#include &quot;sprite_stroke_drawer.hpp&quot;
+#include &quot;marker_stroke_drawer.hpp&quot;
+#include &quot;stroke.hpp&quot;
+#include &quot;stroke_drawer.hpp&quot;
+#include &quot;drawer_properties.hpp&quot;
+#include &quot;flexlay.hpp&quot;
+
+class SketchStrokeToolImpl : public ToolImpl
+{
+public:
+  bool drawing;
+  Stroke   stroke;
+  StrokeDrawer   drawer;
+  
+  SketchStrokeToolImpl()
+    : drawing(false)
+  {
+    drawer = SpriteStrokeDrawer().to_drawer();
+    //drawer = MarkerStrokeDrawer().to_drawer();
+  }
+
+  void draw() 
+  {
+    if (drawing)
+      {
+        // FIXME: This translation is a bit ugly, layer position should be handled somewhat different
+        CL_Display::push_modelview();
+        CL_Display::add_translate(BitmapLayer::current()-&gt;to_object().get_pos().x,
+                                  BitmapLayer::current()-&gt;to_object().get_pos().y);
+        stroke.draw(0);
+        CL_Display::pop_modelview();
+      }
+    else
+      {
+        EditorMapComponent* parent = EditorMapComponent::current();
+        CL_Pointf p = parent-&gt;screen2world(CL_Point(CL_Mouse::get_x() - parent-&gt;get_screen_x(), 
+                                                    CL_Mouse::get_y() - parent-&gt;get_screen_y()));
+        CL_Sprite s = DrawerProperties::current()-&gt;get_brush().get_sprite();
+        s.set_color(DrawerProperties::current()-&gt;get_color());
+        // FIXME: when using mouse 1.0, when tablet .5f
+        s.set_scale(DrawerProperties::current()-&gt;get_size()*0.5f, DrawerProperties::current()-&gt;get_size()*0.5f);
+        s.set_alpha(0.5);
+        s.draw(p.x, p.y);
+      }
+  }
+
+  void on_mouse_up  (const CL_InputEvent&amp; event) 
+  {
+    if (event.id == CL_MOUSE_LEFT &amp;&amp; drawing)
+      {
+        drawing = false;
+        EditorMapComponent* parent = EditorMapComponent::current();
+        parent-&gt;release_mouse();
+        
+        add_dab(event);
+
+        BitmapLayer::current()-&gt;add_stroke(stroke);
+      }    
+  }
+
+  void on_mouse_down(const CL_InputEvent&amp; event) {
+    if (event.id == CL_MOUSE_LEFT)
+      {
+        drawing = true;
+        EditorMapComponent* parent = EditorMapComponent::current();
+        parent-&gt;capture_mouse();
+        stroke = Stroke();
+        stroke.set_drawer(drawer.clone());
+        add_dab(event);
+      }
+  }
+
+  void add_dab(const CL_InputEvent&amp; event)
+  {
+    EditorMapComponent* parent = EditorMapComponent::current();
+    CL_Pointf p = parent-&gt;screen2world(event.mouse_pos);    
+    
+    // FIXME: This is ugly, events relative to the layer should be handled somewhat differently
+    Dab dab(p.x - BitmapLayer::current()-&gt;to_object().get_pos().x,
+            p.y - BitmapLayer::current()-&gt;to_object().get_pos().y);
+
+    // FIXME: Make tablet configurable
+    if (CL_Display::get_current_window()-&gt;get_ic()-&gt;get_mouse_count() &gt;= 4)
+      {
+        CL_InputDevice tablet = CL_Display::get_current_window()-&gt;get_ic()-&gt;get_mouse(5);
+
+        if (0)
+          {
+            std::cout &lt;&lt; &quot;Mouse Count: &quot; &lt;&lt; CL_Display::get_current_window()-&gt;get_ic()-&gt;get_mouse_count() &lt;&lt; std::endl;
+            std::cout &lt;&lt; tablet.get_name() &lt;&lt; &quot;: &quot;;
+            for(int i = 0; i &lt; tablet.get_axis_count(); ++i)
+              std::cout &lt;&lt; tablet.get_axis(i) &lt;&lt; &quot; &quot;;
+            std::cout &lt;&lt; std::endl;
+          }
+
+        dab.pressure = tablet.get_axis(2);
+        dab.tilt.x   = tablet.get_axis(3);
+        dab.tilt.y   = tablet.get_axis(4);
+      }
+
+    //std::cout &lt;&lt; dab.pressure &lt;&lt; &quot; &quot; &lt;&lt; dab.tilt.x &lt;&lt; &quot; &quot; &lt;&lt; dab.tilt.y &lt;&lt; std::endl;
+
+    if (dab.pressure == 0) // most likly we are using the mouse
+      dab.pressure = 1.0f;
+
+    stroke.add_dab(dab);
+  }
+
+  void on_mouse_move(const CL_InputEvent&amp; event) 
+  {
+    if (drawing)
+      {
+        add_dab(event);
+      }
+  }
+};
+
+SketchStrokeTool::SketchStrokeTool()
+  : impl(new SketchStrokeToolImpl()) 
+{
+}
+
+Tool
+SketchStrokeTool::to_tool()
+{
+  return Tool(impl);
+}
+
+StrokeDrawer
+SketchStrokeTool::get_drawer()
+{
+  return impl-&gt;drawer;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/sketch_stroke_tool.cxx
===================================================================
--- trunk/flexlay/lib/tools/sketch_stroke_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/sketch_stroke_tool.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,166 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#include &lt;iostream&gt;
-#include &lt;assert.h&gt;
-#include &lt;ClanLib/gl.h&gt;
-#include &lt;ClanLib/Display/input_event.h&gt;
-#include &lt;ClanLib/Display/keys.h&gt;
-#include &lt;ClanLib/Display/mouse.h&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-#include &lt;ClanLib/Display/input_context.h&gt;
-#include &quot;editor_map_component.hxx&quot;
-#include &quot;tool.hxx&quot;
-#include &quot;bitmap_layer.hxx&quot;
-#include &quot;sketch_stroke_tool.hxx&quot;
-#include &quot;sprite_stroke_drawer.hxx&quot;
-#include &quot;marker_stroke_drawer.hxx&quot;
-#include &quot;stroke.hxx&quot;
-#include &quot;stroke_drawer.hxx&quot;
-#include &quot;drawer_properties.hxx&quot;
-#include &quot;flexlay.hxx&quot;
-
-class SketchStrokeToolImpl : public ToolImpl
-{
-public:
-  bool drawing;
-  Stroke   stroke;
-  StrokeDrawer   drawer;
-  
-  SketchStrokeToolImpl()
-    : drawing(false)
-  {
-    drawer = SpriteStrokeDrawer().to_drawer();
-    //drawer = MarkerStrokeDrawer().to_drawer();
-  }
-
-  void draw() 
-  {
-    if (drawing)
-      {
-        // FIXME: This translation is a bit ugly, layer position should be handled somewhat different
-        CL_Display::push_modelview();
-        CL_Display::add_translate(BitmapLayer::current()-&gt;to_object().get_pos().x,
-                                  BitmapLayer::current()-&gt;to_object().get_pos().y);
-        stroke.draw(0);
-        CL_Display::pop_modelview();
-      }
-    else
-      {
-        EditorMapComponent* parent = EditorMapComponent::current();
-        CL_Pointf p = parent-&gt;screen2world(CL_Point(CL_Mouse::get_x() - parent-&gt;get_screen_x(), 
-                                                    CL_Mouse::get_y() - parent-&gt;get_screen_y()));
-        CL_Sprite s = DrawerProperties::current()-&gt;get_brush().get_sprite();
-        s.set_color(DrawerProperties::current()-&gt;get_color());
-        // FIXME: when using mouse 1.0, when tablet .5f
-        s.set_scale(DrawerProperties::current()-&gt;get_size()*0.5f, DrawerProperties::current()-&gt;get_size()*0.5f);
-        s.set_alpha(0.5);
-        s.draw(p.x, p.y);
-      }
-  }
-
-  void on_mouse_up  (const CL_InputEvent&amp; event) 
-  {
-    if (event.id == CL_MOUSE_LEFT &amp;&amp; drawing)
-      {
-        drawing = false;
-        EditorMapComponent* parent = EditorMapComponent::current();
-        parent-&gt;release_mouse();
-        
-        add_dab(event);
-
-        BitmapLayer::current()-&gt;add_stroke(stroke);
-      }    
-  }
-
-  void on_mouse_down(const CL_InputEvent&amp; event) {
-    if (event.id == CL_MOUSE_LEFT)
-      {
-        drawing = true;
-        EditorMapComponent* parent = EditorMapComponent::current();
-        parent-&gt;capture_mouse();
-        stroke = Stroke();
-        stroke.set_drawer(drawer.clone());
-        add_dab(event);
-      }
-  }
-
-  void add_dab(const CL_InputEvent&amp; event)
-  {
-    EditorMapComponent* parent = EditorMapComponent::current();
-    CL_Pointf p = parent-&gt;screen2world(event.mouse_pos);    
-    
-    // FIXME: This is ugly, events relative to the layer should be handled somewhat differently
-    Dab dab(p.x - BitmapLayer::current()-&gt;to_object().get_pos().x,
-            p.y - BitmapLayer::current()-&gt;to_object().get_pos().y);
-
-    // FIXME: Make tablet configurable
-    if (CL_Display::get_current_window()-&gt;get_ic()-&gt;get_mouse_count() &gt;= 4)
-      {
-        CL_InputDevice tablet = CL_Display::get_current_window()-&gt;get_ic()-&gt;get_mouse(5);
-
-        if (0)
-          {
-            std::cout &lt;&lt; &quot;Mouse Count: &quot; &lt;&lt; CL_Display::get_current_window()-&gt;get_ic()-&gt;get_mouse_count() &lt;&lt; std::endl;
-            std::cout &lt;&lt; tablet.get_name() &lt;&lt; &quot;: &quot;;
-            for(int i = 0; i &lt; tablet.get_axis_count(); ++i)
-              std::cout &lt;&lt; tablet.get_axis(i) &lt;&lt; &quot; &quot;;
-            std::cout &lt;&lt; std::endl;
-          }
-
-        dab.pressure = tablet.get_axis(2);
-        dab.tilt.x   = tablet.get_axis(3);
-        dab.tilt.y   = tablet.get_axis(4);
-      }
-
-    //std::cout &lt;&lt; dab.pressure &lt;&lt; &quot; &quot; &lt;&lt; dab.tilt.x &lt;&lt; &quot; &quot; &lt;&lt; dab.tilt.y &lt;&lt; std::endl;
-
-    if (dab.pressure == 0) // most likly we are using the mouse
-      dab.pressure = 1.0f;
-
-    stroke.add_dab(dab);
-  }
-
-  void on_mouse_move(const CL_InputEvent&amp; event) 
-  {
-    if (drawing)
-      {
-        add_dab(event);
-      }
-  }
-};
-
-SketchStrokeTool::SketchStrokeTool()
-  : impl(new SketchStrokeToolImpl()) 
-{
-}
-
-Tool
-SketchStrokeTool::to_tool()
-{
-  return Tool(impl);
-}
-
-StrokeDrawer
-SketchStrokeTool::get_drawer()
-{
-  return impl-&gt;drawer;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/sketch_stroke_tool.hpp (from rev 712, trunk/flexlay/lib/tools/sketch_stroke_tool.hxx)
===================================================================
--- trunk/flexlay/lib/tools/sketch_stroke_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/sketch_stroke_tool.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,44 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#ifndef HEADER_SKETCH_STROKE_TOOL_HXX
+#define HEADER_SKETCH_STROKE_TOOL_HXX
+
+#include &quot;tool_impl.hpp&quot;
+#include &quot;stroke_drawer.hpp&quot;
+
+class SketchStrokeToolImpl;
+
+/** */
+class SketchStrokeTool
+{
+private:
+public:
+  SketchStrokeTool();
+
+  StrokeDrawer get_drawer();
+
+  Tool to_tool();
+private:
+  SharedPtr&lt;SketchStrokeToolImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/sketch_stroke_tool.hxx
===================================================================
--- trunk/flexlay/lib/tools/sketch_stroke_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/sketch_stroke_tool.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,44 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#ifndef HEADER_SKETCH_STROKE_TOOL_HXX
-#define HEADER_SKETCH_STROKE_TOOL_HXX
-
-#include &quot;tool_impl.hxx&quot;
-#include &quot;stroke_drawer.hxx&quot;
-
-class SketchStrokeToolImpl;
-
-/** */
-class SketchStrokeTool
-{
-private:
-public:
-  SketchStrokeTool();
-
-  StrokeDrawer get_drawer();
-
-  Tool to_tool();
-private:
-  SharedPtr&lt;SketchStrokeToolImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/tilemap_paint_tool.cpp (from rev 712, trunk/flexlay/lib/tools/tilemap_paint_tool.cxx)
===================================================================
--- trunk/flexlay/lib/tools/tilemap_paint_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tilemap_paint_tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,288 @@
+//  $Id: tilemap_paint_tool.cxx,v 1.2 2003/09/23 22:07:32 grumbel Exp $
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#include &lt;iostream&gt;
+#include &lt;ClanLib/Display/mouse.h&gt;
+#include &lt;ClanLib/Display/keyboard.h&gt;
+#include &lt;ClanLib/Display/keys.h&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+
+#include &quot;globals.hpp&quot;
+#include &quot;tilemap_layer.hpp&quot;
+#include &quot;tileset.hpp&quot;
+#include &quot;editor_map.hpp&quot;
+#include &quot;editor_map_component.hpp&quot;
+#include &quot;tile.hpp&quot;
+#include &quot;workspace.hpp&quot;
+#include &quot;paint_command.hpp&quot;
+#include &quot;editor_names.hpp&quot;
+#include &quot;tile_selection.hpp&quot;
+#include &quot;tool_impl.hpp&quot;
+#include &quot;tilemap_paint_tool.hpp&quot;
+
+TileMapPaintTool TileMapPaintTool::current_;
+
+class TileMapPaintToolImpl : public ToolImpl
+{
+public:
+  enum { PAINTING, SELECTING, NONE } mode;
+
+  TileSelection selection;
+  TileBrush brush;
+  CL_Point last_draw;
+  CL_Point current_tile;
+
+  PaintCommand* command;
+
+  void draw();
+
+  void on_mouse_down(const CL_InputEvent&amp; event);
+  void on_mouse_move(const CL_InputEvent&amp; event);
+  void on_mouse_up  (const CL_InputEvent&amp; event);
+};
+
+TileMapPaintTool::TileMapPaintTool()
+  : impl(new TileMapPaintToolImpl())
+{
+  impl-&gt;last_draw = CL_Point(-1, -1);
+
+  current_  = *this;
+  
+  impl-&gt;brush = TileBrush(1, 1);
+  impl-&gt;brush.at(0, 0) = 0;
+  impl-&gt;brush.set_opaque();
+  impl-&gt;current_tile = CL_Point(0,0);
+
+  impl-&gt;command = 0;
+
+  impl-&gt;mode = TileMapPaintToolImpl::NONE;
+}
+
+TileMapPaintTool::~TileMapPaintTool()
+{
+}
+
+void
+TileMapPaintToolImpl::draw()
+{
+  TilemapLayer tilemap = TilemapLayer::current();
+
+  if (tilemap.is_null())
+    return;
+
+  switch(mode)
+    {
+    case TileMapPaintToolImpl::SELECTING:
+      if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT))
+        selection.draw(CL_Color(255,  128, 128, 100));
+      else 
+        selection.draw();
+      break;
+      
+    default:
+      int tile_size = tilemap.get_tileset().get_tile_size();
+
+      // Draw the brush:
+      for(int y = 0; y &lt; brush.get_height(); ++y)
+        for(int x = 0; x &lt; brush.get_width(); ++x)
+          {
+            Tile* tile = tilemap.get_tileset().create(brush.at(x, y));
+                
+            if (tile)
+              {
+                CL_Sprite sprite = tile-&gt;get_sprite();
+                sprite.set_alpha(0.5f);
+                sprite.draw((current_tile.x + x) * tile_size, 
+                            (current_tile.y + y) * tile_size);
+
+                CL_Display::fill_rect(CL_Rect(CL_Point((current_tile.x + x) * tile_size, 
+                                                       (current_tile.y + y) * tile_size),
+                                              CL_Size(tile_size, tile_size)),
+                                      CL_Color(255, 255, 255, 100));
+              }
+            else if (brush.is_opaque())
+              {
+                CL_Display::fill_rect(CL_Rect(CL_Point((current_tile.x + x) * tile_size, 
+                                                       (current_tile.y + y) * tile_size),
+                                              CL_Size(tile_size, tile_size)),
+                                      CL_Color(255, 255, 255, 100));
+              }
+            else
+              {
+                CL_Display::fill_rect(CL_Rect(CL_Point((current_tile.x + x) * tile_size, 
+                                                       (current_tile.y + y) * tile_size),
+                                              CL_Size(tile_size, tile_size)),
+                                      CL_Color(255, 255, 255, 50));
+              }
+          }
+      break;
+    }
+}
+
+const TileBrush&amp; 
+TileMapPaintTool::get_brush() 
+{
+  return impl-&gt;brush; 
+}
+
+void
+TileMapPaintToolImpl::on_mouse_down(const CL_InputEvent&amp; event)
+{
+  TilemapLayer tilemap = TilemapLayer::current();
+
+  if (!tilemap.is_null())
+    {
+      EditorMapComponent* parent = EditorMapComponent::current();
+      CL_Point pos = tilemap.world2tile(parent-&gt;screen2world(event.mouse_pos));
+
+      switch (mode)
+        {
+        case TileMapPaintToolImpl::NONE:
+          switch (event.id)
+            {
+            case CL_MOUSE_LEFT:
+              mode = TileMapPaintToolImpl::PAINTING;
+              parent-&gt;capture_mouse();
+              command = new PaintCommand(tilemap, brush);
+              command-&gt;add_point(pos);
+              last_draw = pos;
+              break;
+    
+            case CL_MOUSE_RIGHT:
+              mode = TileMapPaintToolImpl::SELECTING;
+              parent-&gt;capture_mouse();
+
+              selection.start(tilemap, pos);
+              break;
+            }
+          break;
+
+        default:
+          break;
+        }
+    }
+}
+ 
+void
+TileMapPaintToolImpl::on_mouse_move(const CL_InputEvent&amp; event)
+{
+  TilemapLayer tilemap = TilemapLayer::current();
+
+  if (!tilemap.is_null())
+    {
+      EditorMapComponent* parent = EditorMapComponent::current();
+      current_tile = tilemap.world2tile(parent-&gt;screen2world(event.mouse_pos));
+
+      switch (mode)
+        {
+        case PAINTING:
+          if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT) ||
+              (current_tile.x % brush.get_width()) == (last_draw.x % brush.get_width()) &amp;&amp;
+              (current_tile.y % brush.get_height() == (last_draw.y % brush.get_height())))
+            {
+              command-&gt;add_point(current_tile);
+              last_draw = current_tile;
+            }
+          break;
+    
+        case SELECTING:
+          selection.update(current_tile);
+          break;
+      
+        default:
+          break;
+        }
+    }
+}
+
+void
+TileMapPaintToolImpl::on_mouse_up  (const CL_InputEvent&amp; event)
+{
+  TilemapLayer tilemap = TilemapLayer::current();
+
+  if (!tilemap.is_null())
+    {
+      EditorMapComponent::current()-&gt;get_workspace().get_map().modify();
+
+      EditorMapComponent* parent = EditorMapComponent::current();
+      current_tile = tilemap.world2tile(parent-&gt;screen2world(event.mouse_pos));
+
+      switch (event.id)
+        {
+        case CL_MOUSE_LEFT:
+          if (mode == PAINTING)
+            {
+              parent-&gt;release_mouse();
+              mode = NONE;
+
+              if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT) ||
+                  (current_tile.x % brush.get_width()) == (last_draw.x % brush.get_width()) &amp;&amp;
+                  (current_tile.y % brush.get_height() == (last_draw.y % brush.get_height())))
+                {
+                  command-&gt;add_point(current_tile);
+                }
+
+              Workspace::current().get_map().execute(command-&gt;to_command());
+              command = 0;
+
+              tilemap.draw_tile(brush, current_tile);
+              last_draw = CL_Point(-1, -1);
+            }
+          break;
+    
+        case CL_MOUSE_RIGHT:
+          if (mode == SELECTING)
+            {
+              parent-&gt;release_mouse();
+              mode = NONE;
+
+              selection.update(current_tile);
+              brush = selection.get_brush(*tilemap.get_field());
+
+              if ((brush.get_width() &gt; 1 || brush.get_height() &gt; 1)
+                  &amp;&amp; !CL_Keyboard::get_keycode(CL_KEY_LSHIFT))
+                {
+                  brush.set_transparent();
+                  brush.auto_crop();
+                }
+              else
+                {
+                  brush.set_opaque();
+                }
+
+              selection.clear();
+            }
+          break;
+        }
+    }
+}
+
+void
+TileMapPaintTool::set_brush(const TileBrush&amp; b)
+{
+  impl-&gt;brush = b;
+}
+
+Tool
+TileMapPaintTool::to_tool()
+{ 
+  return Tool(impl);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/tilemap_paint_tool.cxx
===================================================================
--- trunk/flexlay/lib/tools/tilemap_paint_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tilemap_paint_tool.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,288 +0,0 @@
-//  $Id: tilemap_paint_tool.cxx,v 1.2 2003/09/23 22:07:32 grumbel Exp $
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#include &lt;iostream&gt;
-#include &lt;ClanLib/Display/mouse.h&gt;
-#include &lt;ClanLib/Display/keyboard.h&gt;
-#include &lt;ClanLib/Display/keys.h&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-
-#include &quot;globals.hxx&quot;
-#include &quot;tilemap_layer.hxx&quot;
-#include &quot;tileset.hxx&quot;
-#include &quot;editor_map.hxx&quot;
-#include &quot;editor_map_component.hxx&quot;
-#include &quot;tile.hxx&quot;
-#include &quot;workspace.hxx&quot;
-#include &quot;paint_command.hxx&quot;
-#include &quot;editor_names.hxx&quot;
-#include &quot;tile_selection.hxx&quot;
-#include &quot;tool_impl.hxx&quot;
-#include &quot;tilemap_paint_tool.hxx&quot;
-
-TileMapPaintTool TileMapPaintTool::current_;
-
-class TileMapPaintToolImpl : public ToolImpl
-{
-public:
-  enum { PAINTING, SELECTING, NONE } mode;
-
-  TileSelection selection;
-  TileBrush brush;
-  CL_Point last_draw;
-  CL_Point current_tile;
-
-  PaintCommand* command;
-
-  void draw();
-
-  void on_mouse_down(const CL_InputEvent&amp; event);
-  void on_mouse_move(const CL_InputEvent&amp; event);
-  void on_mouse_up  (const CL_InputEvent&amp; event);
-};
-
-TileMapPaintTool::TileMapPaintTool()
-  : impl(new TileMapPaintToolImpl())
-{
-  impl-&gt;last_draw = CL_Point(-1, -1);
-
-  current_  = *this;
-  
-  impl-&gt;brush = TileBrush(1, 1);
-  impl-&gt;brush.at(0, 0) = 0;
-  impl-&gt;brush.set_opaque();
-  impl-&gt;current_tile = CL_Point(0,0);
-
-  impl-&gt;command = 0;
-
-  impl-&gt;mode = TileMapPaintToolImpl::NONE;
-}
-
-TileMapPaintTool::~TileMapPaintTool()
-{
-}
-
-void
-TileMapPaintToolImpl::draw()
-{
-  TilemapLayer tilemap = TilemapLayer::current();
-
-  if (tilemap.is_null())
-    return;
-
-  switch(mode)
-    {
-    case TileMapPaintToolImpl::SELECTING:
-      if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT))
-        selection.draw(CL_Color(255,  128, 128, 100));
-      else 
-        selection.draw();
-      break;
-      
-    default:
-      int tile_size = tilemap.get_tileset().get_tile_size();
-
-      // Draw the brush:
-      for(int y = 0; y &lt; brush.get_height(); ++y)
-        for(int x = 0; x &lt; brush.get_width(); ++x)
-          {
-            Tile* tile = tilemap.get_tileset().create(brush.at(x, y));
-                
-            if (tile)
-              {
-                CL_Sprite sprite = tile-&gt;get_sprite();
-                sprite.set_alpha(0.5f);
-                sprite.draw((current_tile.x + x) * tile_size, 
-                            (current_tile.y + y) * tile_size);
-
-                CL_Display::fill_rect(CL_Rect(CL_Point((current_tile.x + x) * tile_size, 
-                                                       (current_tile.y + y) * tile_size),
-                                              CL_Size(tile_size, tile_size)),
-                                      CL_Color(255, 255, 255, 100));
-              }
-            else if (brush.is_opaque())
-              {
-                CL_Display::fill_rect(CL_Rect(CL_Point((current_tile.x + x) * tile_size, 
-                                                       (current_tile.y + y) * tile_size),
-                                              CL_Size(tile_size, tile_size)),
-                                      CL_Color(255, 255, 255, 100));
-              }
-            else
-              {
-                CL_Display::fill_rect(CL_Rect(CL_Point((current_tile.x + x) * tile_size, 
-                                                       (current_tile.y + y) * tile_size),
-                                              CL_Size(tile_size, tile_size)),
-                                      CL_Color(255, 255, 255, 50));
-              }
-          }
-      break;
-    }
-}
-
-const TileBrush&amp; 
-TileMapPaintTool::get_brush() 
-{
-  return impl-&gt;brush; 
-}
-
-void
-TileMapPaintToolImpl::on_mouse_down(const CL_InputEvent&amp; event)
-{
-  TilemapLayer tilemap = TilemapLayer::current();
-
-  if (!tilemap.is_null())
-    {
-      EditorMapComponent* parent = EditorMapComponent::current();
-      CL_Point pos = tilemap.world2tile(parent-&gt;screen2world(event.mouse_pos));
-
-      switch (mode)
-        {
-        case TileMapPaintToolImpl::NONE:
-          switch (event.id)
-            {
-            case CL_MOUSE_LEFT:
-              mode = TileMapPaintToolImpl::PAINTING;
-              parent-&gt;capture_mouse();
-              command = new PaintCommand(tilemap, brush);
-              command-&gt;add_point(pos);
-              last_draw = pos;
-              break;
-    
-            case CL_MOUSE_RIGHT:
-              mode = TileMapPaintToolImpl::SELECTING;
-              parent-&gt;capture_mouse();
-
-              selection.start(tilemap, pos);
-              break;
-            }
-          break;
-
-        default:
-          break;
-        }
-    }
-}
- 
-void
-TileMapPaintToolImpl::on_mouse_move(const CL_InputEvent&amp; event)
-{
-  TilemapLayer tilemap = TilemapLayer::current();
-
-  if (!tilemap.is_null())
-    {
-      EditorMapComponent* parent = EditorMapComponent::current();
-      current_tile = tilemap.world2tile(parent-&gt;screen2world(event.mouse_pos));
-
-      switch (mode)
-        {
-        case PAINTING:
-          if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT) ||
-              (current_tile.x % brush.get_width()) == (last_draw.x % brush.get_width()) &amp;&amp;
-              (current_tile.y % brush.get_height() == (last_draw.y % brush.get_height())))
-            {
-              command-&gt;add_point(current_tile);
-              last_draw = current_tile;
-            }
-          break;
-    
-        case SELECTING:
-          selection.update(current_tile);
-          break;
-      
-        default:
-          break;
-        }
-    }
-}
-
-void
-TileMapPaintToolImpl::on_mouse_up  (const CL_InputEvent&amp; event)
-{
-  TilemapLayer tilemap = TilemapLayer::current();
-
-  if (!tilemap.is_null())
-    {
-      EditorMapComponent::current()-&gt;get_workspace().get_map().modify();
-
-      EditorMapComponent* parent = EditorMapComponent::current();
-      current_tile = tilemap.world2tile(parent-&gt;screen2world(event.mouse_pos));
-
-      switch (event.id)
-        {
-        case CL_MOUSE_LEFT:
-          if (mode == PAINTING)
-            {
-              parent-&gt;release_mouse();
-              mode = NONE;
-
-              if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT) ||
-                  (current_tile.x % brush.get_width()) == (last_draw.x % brush.get_width()) &amp;&amp;
-                  (current_tile.y % brush.get_height() == (last_draw.y % brush.get_height())))
-                {
-                  command-&gt;add_point(current_tile);
-                }
-
-              Workspace::current().get_map().execute(command-&gt;to_command());
-              command = 0;
-
-              tilemap.draw_tile(brush, current_tile);
-              last_draw = CL_Point(-1, -1);
-            }
-          break;
-    
-        case CL_MOUSE_RIGHT:
-          if (mode == SELECTING)
-            {
-              parent-&gt;release_mouse();
-              mode = NONE;
-
-              selection.update(current_tile);
-              brush = selection.get_brush(*tilemap.get_field());
-
-              if ((brush.get_width() &gt; 1 || brush.get_height() &gt; 1)
-                  &amp;&amp; !CL_Keyboard::get_keycode(CL_KEY_LSHIFT))
-                {
-                  brush.set_transparent();
-                  brush.auto_crop();
-                }
-              else
-                {
-                  brush.set_opaque();
-                }
-
-              selection.clear();
-            }
-          break;
-        }
-    }
-}
-
-void
-TileMapPaintTool::set_brush(const TileBrush&amp; b)
-{
-  impl-&gt;brush = b;
-}
-
-Tool
-TileMapPaintTool::to_tool()
-{ 
-  return Tool(impl);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/tilemap_paint_tool.hpp (from rev 712, trunk/flexlay/lib/tools/tilemap_paint_tool.hxx)
===================================================================
--- trunk/flexlay/lib/tools/tilemap_paint_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tilemap_paint_tool.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,50 @@
+//  $Id: tilemap_paint_tool.hpp,v 1.1 2003/09/23 19:10:05 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#ifndef HEADER_TILEMAP_PAINT_TOOL_HXX
+#define HEADER_TILEMAP_PAINT_TOOL_HXX
+
+#include &quot;tool.hpp&quot;
+#include &quot;tile_brush.hpp&quot;
+#include &quot;tilemap_layer.hpp&quot;
+
+class TileMapPaintToolImpl;
+
+/** */
+class TileMapPaintTool
+{
+private:
+  static TileMapPaintTool current_; 
+public:
+  static TileMapPaintTool current() { return current_; } 
+
+  TileMapPaintTool();
+  ~TileMapPaintTool();
+  
+  const TileBrush&amp; get_brush();
+  void set_brush(const TileBrush&amp; b);
+
+  Tool to_tool();
+private:
+  SharedPtr&lt;TileMapPaintToolImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/tilemap_paint_tool.hxx
===================================================================
--- trunk/flexlay/lib/tools/tilemap_paint_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tilemap_paint_tool.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,50 +0,0 @@
-//  $Id: tilemap_paint_tool.hxx,v 1.1 2003/09/23 19:10:05 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#ifndef HEADER_TILEMAP_PAINT_TOOL_HXX
-#define HEADER_TILEMAP_PAINT_TOOL_HXX
-
-#include &quot;tool.hxx&quot;
-#include &quot;tile_brush.hxx&quot;
-#include &quot;tilemap_layer.hxx&quot;
-
-class TileMapPaintToolImpl;
-
-/** */
-class TileMapPaintTool
-{
-private:
-  static TileMapPaintTool current_; 
-public:
-  static TileMapPaintTool current() { return current_; } 
-
-  TileMapPaintTool();
-  ~TileMapPaintTool();
-  
-  const TileBrush&amp; get_brush();
-  void set_brush(const TileBrush&amp; b);
-
-  Tool to_tool();
-private:
-  SharedPtr&lt;TileMapPaintToolImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/tilemap_select_tool.cpp (from rev 712, trunk/flexlay/lib/tools/tilemap_select_tool.cxx)
===================================================================
--- trunk/flexlay/lib/tools/tilemap_select_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tilemap_select_tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,133 @@
+//  $Id: tilemap_select_tool.cxx,v 1.1 2003/09/23 22:10:40 grumbel Exp $
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#include &lt;ClanLib/Display/display.h&gt;
+#include &lt;ClanLib/Display/keys.h&gt;
+#include &lt;ClanLib/Display/input_event.h&gt;
+#include &quot;globals.hpp&quot;
+#include &quot;tilemap_layer.hpp&quot;
+#include &quot;tool_impl.hpp&quot;
+#include &quot;editor_map.hpp&quot;
+#include &quot;editor_map_component.hpp&quot;
+#include &quot;tile_brush.hpp&quot;
+#include &quot;editor_names.hpp&quot;
+#include &quot;tilemap_select_tool.hpp&quot;
+
+class TileMapSelectToolImpl : public ToolImpl
+{
+public:
+  TileSelection  selection;
+  bool creating_selection;
+
+  void draw();
+  
+  void on_mouse_up  (const CL_InputEvent&amp; event);
+  void on_mouse_down(const CL_InputEvent&amp; event);
+  void on_mouse_move(const CL_InputEvent&amp; event);
+};
+
+TileMapSelectTool::TileMapSelectTool()
+  : impl(new TileMapSelectToolImpl())
+{
+  impl-&gt;creating_selection = false;
+}
+
+TileMapSelectTool::~TileMapSelectTool()
+{
+}
+
+void
+TileMapSelectToolImpl::draw()
+{
+  if (selection.is_active())
+    {
+      selection.draw();
+    }
+}
+
+void
+TileMapSelectToolImpl::on_mouse_up  (const CL_InputEvent&amp; event)
+{
+  EditorMapComponent* parent = EditorMapComponent::current();
+
+  switch (event.id)
+    {
+    case CL_MOUSE_LEFT:
+      creating_selection = false;
+      parent-&gt;release_mouse();
+
+      selection.update(TilemapLayer::current().world2tile(parent-&gt;screen2world(event.mouse_pos)));
+      break;
+    }
+}
+
+void
+TileMapSelectToolImpl::on_mouse_down(const CL_InputEvent&amp; event)
+{
+  EditorMapComponent* parent = EditorMapComponent::current();
+
+  switch (event.id)
+    {
+    case CL_MOUSE_LEFT:
+      {
+        creating_selection = true;
+        parent-&gt;capture_mouse();
+        TilemapLayer tilemap = TilemapLayer::current();
+        selection.start(tilemap, tilemap.world2tile(parent-&gt;screen2world(event.mouse_pos)));
+      }
+      break;
+      
+    case CL_MOUSE_RIGHT:
+      if (!creating_selection)
+        selection.clear();
+      break;
+    }
+}
+
+void
+TileMapSelectToolImpl::on_mouse_move(const CL_InputEvent&amp; event)
+{ 
+  EditorMapComponent* parent = EditorMapComponent::current();
+
+  if (creating_selection)
+    {
+      selection.update(TilemapLayer::current().world2tile(parent-&gt;screen2world(event.mouse_pos)));
+    }
+}
+
+TileBrush
+TileMapSelectTool::get_selection() const
+{
+  TilemapLayer tilemap = TilemapLayer::current();
+  return impl-&gt;selection.get_brush(*tilemap.get_field());
+}
+
+CL_Rect
+TileMapSelectTool::get_selection_rect() const
+{
+  return impl-&gt;selection.get_rect();
+}
+
+Tool
+TileMapSelectTool::to_tool()
+{
+  return Tool(impl); 
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/tilemap_select_tool.cxx
===================================================================
--- trunk/flexlay/lib/tools/tilemap_select_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tilemap_select_tool.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,133 +0,0 @@
-//  $Id: tilemap_select_tool.cxx,v 1.1 2003/09/23 22:10:40 grumbel Exp $
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#include &lt;ClanLib/Display/display.h&gt;
-#include &lt;ClanLib/Display/keys.h&gt;
-#include &lt;ClanLib/Display/input_event.h&gt;
-#include &quot;globals.hxx&quot;
-#include &quot;tilemap_layer.hxx&quot;
-#include &quot;tool_impl.hxx&quot;
-#include &quot;editor_map.hxx&quot;
-#include &quot;editor_map_component.hxx&quot;
-#include &quot;tile_brush.hxx&quot;
-#include &quot;editor_names.hxx&quot;
-#include &quot;tilemap_select_tool.hxx&quot;
-
-class TileMapSelectToolImpl : public ToolImpl
-{
-public:
-  TileSelection  selection;
-  bool creating_selection;
-
-  void draw();
-  
-  void on_mouse_up  (const CL_InputEvent&amp; event);
-  void on_mouse_down(const CL_InputEvent&amp; event);
-  void on_mouse_move(const CL_InputEvent&amp; event);
-};
-
-TileMapSelectTool::TileMapSelectTool()
-  : impl(new TileMapSelectToolImpl())
-{
-  impl-&gt;creating_selection = false;
-}
-
-TileMapSelectTool::~TileMapSelectTool()
-{
-}
-
-void
-TileMapSelectToolImpl::draw()
-{
-  if (selection.is_active())
-    {
-      selection.draw();
-    }
-}
-
-void
-TileMapSelectToolImpl::on_mouse_up  (const CL_InputEvent&amp; event)
-{
-  EditorMapComponent* parent = EditorMapComponent::current();
-
-  switch (event.id)
-    {
-    case CL_MOUSE_LEFT:
-      creating_selection = false;
-      parent-&gt;release_mouse();
-
-      selection.update(TilemapLayer::current().world2tile(parent-&gt;screen2world(event.mouse_pos)));
-      break;
-    }
-}
-
-void
-TileMapSelectToolImpl::on_mouse_down(const CL_InputEvent&amp; event)
-{
-  EditorMapComponent* parent = EditorMapComponent::current();
-
-  switch (event.id)
-    {
-    case CL_MOUSE_LEFT:
-      {
-        creating_selection = true;
-        parent-&gt;capture_mouse();
-        TilemapLayer tilemap = TilemapLayer::current();
-        selection.start(tilemap, tilemap.world2tile(parent-&gt;screen2world(event.mouse_pos)));
-      }
-      break;
-      
-    case CL_MOUSE_RIGHT:
-      if (!creating_selection)
-        selection.clear();
-      break;
-    }
-}
-
-void
-TileMapSelectToolImpl::on_mouse_move(const CL_InputEvent&amp; event)
-{ 
-  EditorMapComponent* parent = EditorMapComponent::current();
-
-  if (creating_selection)
-    {
-      selection.update(TilemapLayer::current().world2tile(parent-&gt;screen2world(event.mouse_pos)));
-    }
-}
-
-TileBrush
-TileMapSelectTool::get_selection() const
-{
-  TilemapLayer tilemap = TilemapLayer::current();
-  return impl-&gt;selection.get_brush(*tilemap.get_field());
-}
-
-CL_Rect
-TileMapSelectTool::get_selection_rect() const
-{
-  return impl-&gt;selection.get_rect();
-}
-
-Tool
-TileMapSelectTool::to_tool()
-{
-  return Tool(impl); 
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/tilemap_select_tool.hpp (from rev 712, trunk/flexlay/lib/tools/tilemap_select_tool.hxx)
===================================================================
--- trunk/flexlay/lib/tools/tilemap_select_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tilemap_select_tool.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,49 @@
+//  $Id: tilemap_select_tool.hpp,v 1.1 2003/09/23 22:10:40 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#ifndef HEADER_TILEMAP_SELECT_TOOL_HXX
+#define HEADER_TILEMAP_SELECT_TOOL_HXX
+
+#include &lt;ClanLib/Core/Math/rect.h&gt;
+#include &lt;ClanLib/Core/Math/point.h&gt;
+#include &quot;tool.hpp&quot;
+#include &quot;tile_selection.hpp&quot;
+
+class TileMapSelectToolImpl;
+
+/** */
+class TileMapSelectTool
+{
+public:
+  TileMapSelectTool();
+  ~TileMapSelectTool();
+
+  /** Convert the selection into a TileBrush */
+  TileBrush get_selection() const;
+
+  CL_Rect get_selection_rect() const;
+
+  Tool to_tool();
+private:
+  SharedPtr&lt;TileMapSelectToolImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/tilemap_select_tool.hxx
===================================================================
--- trunk/flexlay/lib/tools/tilemap_select_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tilemap_select_tool.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,49 +0,0 @@
-//  $Id: tilemap_select_tool.hxx,v 1.1 2003/09/23 22:10:40 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#ifndef HEADER_TILEMAP_SELECT_TOOL_HXX
-#define HEADER_TILEMAP_SELECT_TOOL_HXX
-
-#include &lt;ClanLib/Core/Math/rect.h&gt;
-#include &lt;ClanLib/Core/Math/point.h&gt;
-#include &quot;tool.hxx&quot;
-#include &quot;tile_selection.hxx&quot;
-
-class TileMapSelectToolImpl;
-
-/** */
-class TileMapSelectTool
-{
-public:
-  TileMapSelectTool();
-  ~TileMapSelectTool();
-
-  /** Convert the selection into a TileBrush */
-  TileBrush get_selection() const;
-
-  CL_Rect get_selection_rect() const;
-
-  Tool to_tool();
-private:
-  SharedPtr&lt;TileMapSelectToolImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/tool.cpp (from rev 712, trunk/flexlay/lib/tools/tool.cxx)
===================================================================
--- trunk/flexlay/lib/tools/tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,64 @@
+//  $Id: tilemap_tool.cxx,v 1.1 2003/09/23 19:10:05 grumbel Exp $
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#include &quot;tool_impl.hpp&quot;
+#include &quot;tool.hpp&quot;
+
+Tool::Tool()
+{
+}
+
+Tool::Tool(SharedPtr&lt;ToolImpl&gt; impl_)
+  : impl(impl_)
+{
+}
+
+Tool::~Tool() 
+{
+}
+
+void
+Tool::draw()
+{
+  if (impl.get())
+    impl-&gt;draw();
+}
+
+void
+Tool::on_mouse_up  (const CL_InputEvent&amp; event)
+{
+  if (impl.get())
+    impl-&gt;on_mouse_up(event);
+}
+
+void
+Tool::on_mouse_down(const CL_InputEvent&amp; event)
+{
+  if (impl.get())
+    impl-&gt;on_mouse_down(event);
+}
+
+void
+Tool::on_mouse_move(const CL_InputEvent&amp; event)
+{
+  if (impl.get())
+    impl-&gt;on_mouse_move(event);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/tool.cxx
===================================================================
--- trunk/flexlay/lib/tools/tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tool.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,64 +0,0 @@
-//  $Id: tilemap_tool.cxx,v 1.1 2003/09/23 19:10:05 grumbel Exp $
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#include &quot;tool_impl.hxx&quot;
-#include &quot;tool.hxx&quot;
-
-Tool::Tool()
-{
-}
-
-Tool::Tool(SharedPtr&lt;ToolImpl&gt; impl_)
-  : impl(impl_)
-{
-}
-
-Tool::~Tool() 
-{
-}
-
-void
-Tool::draw()
-{
-  if (impl.get())
-    impl-&gt;draw();
-}
-
-void
-Tool::on_mouse_up  (const CL_InputEvent&amp; event)
-{
-  if (impl.get())
-    impl-&gt;on_mouse_up(event);
-}
-
-void
-Tool::on_mouse_down(const CL_InputEvent&amp; event)
-{
-  if (impl.get())
-    impl-&gt;on_mouse_down(event);
-}
-
-void
-Tool::on_mouse_move(const CL_InputEvent&amp; event)
-{
-  if (impl.get())
-    impl-&gt;on_mouse_move(event);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/tool.hpp (from rev 712, trunk/flexlay/lib/tools/tool.hxx)
===================================================================
--- trunk/flexlay/lib/tools/tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tool.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,52 @@
+//  $Id: tilemap_tool.hpp,v 1.1 2003/09/23 19:10:05 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#ifndef HEADER_TILEMAP_TOOL_HXX
+#define HEADER_TILEMAP_TOOL_HXX
+
+class EditorMapComponent;
+class CL_InputEvent;
+
+#include &quot;shared_ptr.hpp&quot;
+
+class ToolImpl;
+
+/** */
+class Tool
+{
+protected:
+
+public:
+  Tool();
+  Tool(SharedPtr&lt;ToolImpl&gt; impl_);
+  ~Tool();
+
+  void draw();
+
+  void on_mouse_up  (const CL_InputEvent&amp; event);
+  void on_mouse_down(const CL_InputEvent&amp; event);
+  void on_mouse_move(const CL_InputEvent&amp; event);
+
+private:
+  SharedPtr&lt;ToolImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/tool.hxx
===================================================================
--- trunk/flexlay/lib/tools/tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tool.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,52 +0,0 @@
-//  $Id: tilemap_tool.hxx,v 1.1 2003/09/23 19:10:05 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#ifndef HEADER_TILEMAP_TOOL_HXX
-#define HEADER_TILEMAP_TOOL_HXX
-
-class EditorMapComponent;
-class CL_InputEvent;
-
-#include &quot;shared_ptr.hxx&quot;
-
-class ToolImpl;
-
-/** */
-class Tool
-{
-protected:
-
-public:
-  Tool();
-  Tool(SharedPtr&lt;ToolImpl&gt; impl_);
-  ~Tool();
-
-  void draw();
-
-  void on_mouse_up  (const CL_InputEvent&amp; event);
-  void on_mouse_down(const CL_InputEvent&amp; event);
-  void on_mouse_move(const CL_InputEvent&amp; event);
-
-private:
-  SharedPtr&lt;ToolImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/tool_impl.hpp (from rev 712, trunk/flexlay/lib/tools/tool_impl.hxx)
===================================================================
--- trunk/flexlay/lib/tools/tool_impl.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tool_impl.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,43 @@
+//  $Id: tilemap_tool.hpp,v 1.1 2003/09/23 19:10:05 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#ifndef HEADER_TOOL_IMPL_HXX
+#define HEADER_TOOL_IMPL_HXX
+
+class CL_InputEvent;
+
+/** */
+class ToolImpl
+{
+protected:
+
+public:
+  ToolImpl() {}
+  virtual ~ToolImpl() {}
+
+  virtual void draw() {}
+
+  virtual void on_mouse_up  (const CL_InputEvent&amp; event) {}
+  virtual void on_mouse_down(const CL_InputEvent&amp; event) {}
+  virtual void on_mouse_move(const CL_InputEvent&amp; event) {}
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/tool_impl.hxx
===================================================================
--- trunk/flexlay/lib/tools/tool_impl.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tool_impl.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,43 +0,0 @@
-//  $Id: tilemap_tool.hxx,v 1.1 2003/09/23 19:10:05 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#ifndef HEADER_TOOL_IMPL_HXX
-#define HEADER_TOOL_IMPL_HXX
-
-class CL_InputEvent;
-
-/** */
-class ToolImpl
-{
-protected:
-
-public:
-  ToolImpl() {}
-  virtual ~ToolImpl() {}
-
-  virtual void draw() {}
-
-  virtual void on_mouse_up  (const CL_InputEvent&amp; event) {}
-  virtual void on_mouse_down(const CL_InputEvent&amp; event) {}
-  virtual void on_mouse_move(const CL_InputEvent&amp; event) {}
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/workspace_move_tool.cpp (from rev 712, trunk/flexlay/lib/tools/workspace_move_tool.cxx)
===================================================================
--- trunk/flexlay/lib/tools/workspace_move_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/workspace_move_tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,102 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#include &lt;ClanLib/Core/Math/point.h&gt;
+#include &lt;ClanLib/Core/Math/rect.h&gt;
+#include &quot;tool_impl.hpp&quot;
+#include &quot;editor_map_component.hpp&quot;
+#include &quot;workspace.hpp&quot;
+#include &quot;workspace_move_tool.hpp&quot;
+
+class WorkspaceMoveToolImpl : public ToolImpl
+{
+public:
+  bool scrolling;
+  CL_Point click_pos;
+
+  /** Position of the center */
+  CL_Pointf old_trans_offset;
+  
+  virtual void draw() {}
+
+  void on_mouse_up  (const CL_InputEvent&amp; event);
+  void on_mouse_down(const CL_InputEvent&amp; event);
+  void on_mouse_move(const CL_InputEvent&amp; event);
+  void update(const CL_InputEvent&amp; event);
+};
+
+void
+WorkspaceMoveToolImpl::on_mouse_down(const CL_InputEvent&amp; event)
+{
+  scrolling = true;
+  old_trans_offset = EditorMapComponent::current()-&gt;get_gc_state().get_pos();
+  click_pos = event.mouse_pos;
+  EditorMapComponent::current()-&gt;capture_mouse();
+}
+
+void
+WorkspaceMoveToolImpl::on_mouse_up(const CL_InputEvent&amp; event)
+{
+  scrolling = false;
+  update(event);
+  old_trans_offset = EditorMapComponent::current()-&gt;get_gc_state().get_pos();
+  EditorMapComponent::current()-&gt;release_mouse();
+}
+
+void
+WorkspaceMoveToolImpl::on_mouse_move(const CL_InputEvent&amp; event)
+{
+  if (scrolling)
+    {
+      update(event);
+    } 
+}
+
+void
+WorkspaceMoveToolImpl::update(const CL_InputEvent&amp; event)
+{
+  GraphicContextState&amp; gc_state = EditorMapComponent::current()-&gt;get_gc_state();
+
+  float sa = sin(-gc_state.get_rotation()/180.0f*M_PI);
+  float ca = cos(-gc_state.get_rotation()/180.0f*M_PI);
+
+  float dx = ca * (click_pos.x - event.mouse_pos.x) - sa * (click_pos.y - event.mouse_pos.y);
+  float dy = sa * (click_pos.x - event.mouse_pos.x) + ca * (click_pos.y - event.mouse_pos.y);
+
+  gc_state.set_pos(CL_Pointf(old_trans_offset.x
+                             + dx / EditorMapComponent::current()-&gt;get_gc_state().get_zoom(),
+                             old_trans_offset.y
+                             + dy / EditorMapComponent::current()-&gt;get_gc_state().get_zoom()));
+}
+
+WorkspaceMoveTool::WorkspaceMoveTool()
+  : impl(new WorkspaceMoveToolImpl())
+{
+  impl-&gt;scrolling = false;
+  impl-&gt;click_pos = CL_Point(0, 0);
+  impl-&gt;old_trans_offset = CL_Pointf(0,0);
+}
+
+Tool
+WorkspaceMoveTool::to_tool()
+{
+  return Tool(impl);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/workspace_move_tool.cxx
===================================================================
--- trunk/flexlay/lib/tools/workspace_move_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/workspace_move_tool.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,102 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#include &lt;ClanLib/Core/Math/point.h&gt;
-#include &lt;ClanLib/Core/Math/rect.h&gt;
-#include &quot;tool_impl.hxx&quot;
-#include &quot;editor_map_component.hxx&quot;
-#include &quot;workspace.hxx&quot;
-#include &quot;workspace_move_tool.hxx&quot;
-
-class WorkspaceMoveToolImpl : public ToolImpl
-{
-public:
-  bool scrolling;
-  CL_Point click_pos;
-
-  /** Position of the center */
-  CL_Pointf old_trans_offset;
-  
-  virtual void draw() {}
-
-  void on_mouse_up  (const CL_InputEvent&amp; event);
-  void on_mouse_down(const CL_InputEvent&amp; event);
-  void on_mouse_move(const CL_InputEvent&amp; event);
-  void update(const CL_InputEvent&amp; event);
-};
-
-void
-WorkspaceMoveToolImpl::on_mouse_down(const CL_InputEvent&amp; event)
-{
-  scrolling = true;
-  old_trans_offset = EditorMapComponent::current()-&gt;get_gc_state().get_pos();
-  click_pos = event.mouse_pos;
-  EditorMapComponent::current()-&gt;capture_mouse();
-}
-
-void
-WorkspaceMoveToolImpl::on_mouse_up(const CL_InputEvent&amp; event)
-{
-  scrolling = false;
-  update(event);
-  old_trans_offset = EditorMapComponent::current()-&gt;get_gc_state().get_pos();
-  EditorMapComponent::current()-&gt;release_mouse();
-}
-
-void
-WorkspaceMoveToolImpl::on_mouse_move(const CL_InputEvent&amp; event)
-{
-  if (scrolling)
-    {
-      update(event);
-    } 
-}
-
-void
-WorkspaceMoveToolImpl::update(const CL_InputEvent&amp; event)
-{
-  GraphicContextState&amp; gc_state = EditorMapComponent::current()-&gt;get_gc_state();
-
-  float sa = sin(-gc_state.get_rotation()/180.0f*M_PI);
-  float ca = cos(-gc_state.get_rotation()/180.0f*M_PI);
-
-  float dx = ca * (click_pos.x - event.mouse_pos.x) - sa * (click_pos.y - event.mouse_pos.y);
-  float dy = sa * (click_pos.x - event.mouse_pos.x) + ca * (click_pos.y - event.mouse_pos.y);
-
-  gc_state.set_pos(CL_Pointf(old_trans_offset.x
-                             + dx / EditorMapComponent::current()-&gt;get_gc_state().get_zoom(),
-                             old_trans_offset.y
-                             + dy / EditorMapComponent::current()-&gt;get_gc_state().get_zoom()));
-}
-
-WorkspaceMoveTool::WorkspaceMoveTool()
-  : impl(new WorkspaceMoveToolImpl())
-{
-  impl-&gt;scrolling = false;
-  impl-&gt;click_pos = CL_Point(0, 0);
-  impl-&gt;old_trans_offset = CL_Pointf(0,0);
-}
-
-Tool
-WorkspaceMoveTool::to_tool()
-{
-  return Tool(impl);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/workspace_move_tool.hpp (from rev 712, trunk/flexlay/lib/tools/workspace_move_tool.hxx)
===================================================================
--- trunk/flexlay/lib/tools/workspace_move_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/workspace_move_tool.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,40 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#ifndef HEADER_WORKSPACE_MOVE_TOOL_HXX
+#define HEADER_WORKSPACE_MOVE_TOOL_HXX
+
+#include &quot;tool.hpp&quot;
+
+class WorkspaceMoveToolImpl;
+
+/** */
+class WorkspaceMoveTool
+{
+public:
+  WorkspaceMoveTool();
+
+  Tool to_tool();
+private:
+  SharedPtr&lt;WorkspaceMoveToolImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/workspace_move_tool.hxx
===================================================================
--- trunk/flexlay/lib/tools/workspace_move_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/workspace_move_tool.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,40 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#ifndef HEADER_WORKSPACE_MOVE_TOOL_HXX
-#define HEADER_WORKSPACE_MOVE_TOOL_HXX
-
-#include &quot;tool.hxx&quot;
-
-class WorkspaceMoveToolImpl;
-
-/** */
-class WorkspaceMoveTool
-{
-public:
-  WorkspaceMoveTool();
-
-  Tool to_tool();
-private:
-  SharedPtr&lt;WorkspaceMoveToolImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/zoom2_tool.cpp (from rev 712, trunk/flexlay/lib/tools/zoom2_tool.cxx)
===================================================================
--- trunk/flexlay/lib/tools/zoom2_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/zoom2_tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,96 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#include &lt;ClanLib/Display/keys.h&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &quot;editor_map_component.hpp&quot;
+#include &quot;tool_impl.hpp&quot;
+#include &quot;zoom2_tool.hpp&quot;
+
+class Zoom2ToolImpl : public ToolImpl
+{
+public:
+  bool active;
+  CL_Point click_pos;
+  float old_zoom;
+  void draw();
+  
+  void on_mouse_up  (const CL_InputEvent&amp; event);
+  void on_mouse_down(const CL_InputEvent&amp; event);
+  void on_mouse_move(const CL_InputEvent&amp; event);
+};
+
+Zoom2Tool::Zoom2Tool()
+  : impl(new Zoom2ToolImpl())
+{
+  impl-&gt;active = false;
+}
+
+Zoom2Tool::~Zoom2Tool()
+{
+}
+
+void
+Zoom2ToolImpl::draw()
+{
+}
+
+void
+Zoom2ToolImpl::on_mouse_up  (const CL_InputEvent&amp; event)
+{
+  active = false;
+}
+
+void
+Zoom2ToolImpl::on_mouse_down(const CL_InputEvent&amp; event)
+{
+  active = true;
+  click_pos = event.mouse_pos;
+
+  GraphicContextState&amp; gc = EditorMapComponent::current()-&gt;get_gc_state();
+  old_zoom = gc.get_zoom();
+}
+
+void
+Zoom2ToolImpl::on_mouse_move(const CL_InputEvent&amp; event)
+{
+  if (active)
+    {
+      GraphicContextState&amp; gc = EditorMapComponent::current()-&gt;get_gc_state();
+
+      CL_Point zoom_pos(gc.get_width()/2,
+                        gc.get_height()/2);
+      
+      float factor = (event.mouse_pos.y - click_pos.y) / 20.0f;
+      if (factor &gt; 0)
+        gc.set_zoom(zoom_pos, old_zoom * pow(1.25f, factor));
+      else if (factor &lt; 0)
+        gc.set_zoom(zoom_pos, old_zoom / pow(1.25f, -factor));
+      else
+        gc.set_zoom(zoom_pos, old_zoom);
+    }
+}
+
+Tool
+Zoom2Tool::to_tool()
+{
+  return Tool(impl); 
+}  
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/zoom2_tool.cxx
===================================================================
--- trunk/flexlay/lib/tools/zoom2_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/zoom2_tool.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,96 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#include &lt;ClanLib/Display/keys.h&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-#include &quot;editor_map_component.hxx&quot;
-#include &quot;tool_impl.hxx&quot;
-#include &quot;zoom2_tool.hxx&quot;
-
-class Zoom2ToolImpl : public ToolImpl
-{
-public:
-  bool active;
-  CL_Point click_pos;
-  float old_zoom;
-  void draw();
-  
-  void on_mouse_up  (const CL_InputEvent&amp; event);
-  void on_mouse_down(const CL_InputEvent&amp; event);
-  void on_mouse_move(const CL_InputEvent&amp; event);
-};
-
-Zoom2Tool::Zoom2Tool()
-  : impl(new Zoom2ToolImpl())
-{
-  impl-&gt;active = false;
-}
-
-Zoom2Tool::~Zoom2Tool()
-{
-}
-
-void
-Zoom2ToolImpl::draw()
-{
-}
-
-void
-Zoom2ToolImpl::on_mouse_up  (const CL_InputEvent&amp; event)
-{
-  active = false;
-}
-
-void
-Zoom2ToolImpl::on_mouse_down(const CL_InputEvent&amp; event)
-{
-  active = true;
-  click_pos = event.mouse_pos;
-
-  GraphicContextState&amp; gc = EditorMapComponent::current()-&gt;get_gc_state();
-  old_zoom = gc.get_zoom();
-}
-
-void
-Zoom2ToolImpl::on_mouse_move(const CL_InputEvent&amp; event)
-{
-  if (active)
-    {
-      GraphicContextState&amp; gc = EditorMapComponent::current()-&gt;get_gc_state();
-
-      CL_Point zoom_pos(gc.get_width()/2,
-                        gc.get_height()/2);
-      
-      float factor = (event.mouse_pos.y - click_pos.y) / 20.0f;
-      if (factor &gt; 0)
-        gc.set_zoom(zoom_pos, old_zoom * pow(1.25f, factor));
-      else if (factor &lt; 0)
-        gc.set_zoom(zoom_pos, old_zoom / pow(1.25f, -factor));
-      else
-        gc.set_zoom(zoom_pos, old_zoom);
-    }
-}
-
-Tool
-Zoom2Tool::to_tool()
-{
-  return Tool(impl); 
-}  
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/zoom2_tool.hpp (from rev 712, trunk/flexlay/lib/tools/zoom2_tool.hxx)
===================================================================
--- trunk/flexlay/lib/tools/zoom2_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/zoom2_tool.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,43 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#ifndef HEADER_ZOOM2_TOOL_HXX
+#define HEADER_ZOOM2_TOOL_HXX
+
+#include &lt;ClanLib/Core/Math/rect.h&gt;
+#include &lt;ClanLib/Display/input_event.h&gt;
+#include &quot;tool.hpp&quot;
+
+class Zoom2ToolImpl;
+
+/** */
+class Zoom2Tool
+{
+public:
+  Zoom2Tool();
+  ~Zoom2Tool();
+
+  Tool to_tool();
+private:
+  SharedPtr&lt;Zoom2ToolImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/zoom2_tool.hxx
===================================================================
--- trunk/flexlay/lib/tools/zoom2_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/zoom2_tool.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,43 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#ifndef HEADER_ZOOM2_TOOL_HXX
-#define HEADER_ZOOM2_TOOL_HXX
-
-#include &lt;ClanLib/Core/Math/rect.h&gt;
-#include &lt;ClanLib/Display/input_event.h&gt;
-#include &quot;tool.hxx&quot;
-
-class Zoom2ToolImpl;
-
-/** */
-class Zoom2Tool
-{
-public:
-  Zoom2Tool();
-  ~Zoom2Tool();
-
-  Tool to_tool();
-private:
-  SharedPtr&lt;Zoom2ToolImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/zoom_tool.cpp (from rev 712, trunk/flexlay/lib/tools/zoom_tool.cxx)
===================================================================
--- trunk/flexlay/lib/tools/zoom_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/zoom_tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,160 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#include &lt;ClanLib/Display/keys.h&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &quot;editor_map_component.hpp&quot;
+#include &quot;tool_impl.hpp&quot;
+#include &quot;zoom_tool.hpp&quot;
+
+class ZoomToolImpl : public ToolImpl
+{
+public:
+  enum { CREATE_ZOOM_RECT, NONE } state;
+
+  CL_Rectf zoom_rect;
+
+  void draw();
+  
+  void on_mouse_up  (const CL_InputEvent&amp; event);
+  void on_mouse_down(const CL_InputEvent&amp; event);
+  void on_mouse_move(const CL_InputEvent&amp; event);
+};
+
+ZoomTool::ZoomTool()
+  : impl(new ZoomToolImpl())
+{
+  impl-&gt;state = ZoomToolImpl::NONE;
+}
+
+ZoomTool::~ZoomTool()
+{
+}
+
+void
+ZoomToolImpl::draw()
+{
+  switch (state)
+    {
+    case CREATE_ZOOM_RECT:
+      {
+        CL_Rectf tmp(zoom_rect);
+        tmp.normalize();
+        CL_Display::fill_rect(tmp, CL_Color(255, 255, 0, 50));
+        CL_Display::draw_rect(tmp, CL_Color(255, 255, 0, 200));
+      }
+    case NONE:
+      break;
+    }
+}
+
+void
+ZoomToolImpl::on_mouse_up  (const CL_InputEvent&amp; event)
+{
+  EditorMapComponent* parent = EditorMapComponent::current();
+
+  if (event.id != CL_MOUSE_RIGHT)
+    {
+      switch (state)
+        {
+        case CREATE_ZOOM_RECT:
+          {
+            state = NONE;
+            parent-&gt;release_mouse();
+
+            CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
+            zoom_rect.right  = pos.x;
+            zoom_rect.bottom = pos.y;
+            zoom_rect.normalize();
+            if (zoom_rect.get_width() &gt; 10 &amp;&amp; zoom_rect.get_height() &gt; 10)
+              {
+                parent-&gt;zoom_to(zoom_rect);
+              }
+          }
+        }
+    }
+}
+
+void
+ZoomToolImpl::on_mouse_down(const CL_InputEvent&amp; event)
+{
+  EditorMapComponent* parent = EditorMapComponent::current();
+
+  switch(event.id)
+    {
+    case CL_MOUSE_RIGHT:
+      switch (state)
+        {
+        case NONE:
+          parent-&gt;zoom_out(event.mouse_pos);
+          parent-&gt;zoom_out(event.mouse_pos);
+          break;
+        default:
+          break;
+        }
+      break;
+
+    default:
+      switch (state)
+        {
+        case NONE:
+          {
+            state = CREATE_ZOOM_RECT;
+            parent-&gt;capture_mouse();
+
+            CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
+            zoom_rect.left   = pos.x;
+            zoom_rect.top    = pos.y;
+            zoom_rect.right  = pos.x;
+            zoom_rect.bottom = pos.y;
+          }
+          break;
+        default:
+          break;
+        }
+      break;
+    }
+}
+
+void
+ZoomToolImpl::on_mouse_move(const CL_InputEvent&amp; event)
+{
+  EditorMapComponent* parent = EditorMapComponent::current();
+
+  switch (state)
+    {
+    case CREATE_ZOOM_RECT:
+      {
+        CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
+        zoom_rect.right  = pos.x;
+        zoom_rect.bottom = pos.y;  
+      }
+      break;
+    default:
+      break;
+    }
+}
+
+Tool
+ZoomTool::to_tool()
+{
+  return Tool(impl); 
+}  
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/zoom_tool.cxx
===================================================================
--- trunk/flexlay/lib/tools/zoom_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/zoom_tool.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,160 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#include &lt;ClanLib/Display/keys.h&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-#include &quot;editor_map_component.hxx&quot;
-#include &quot;tool_impl.hxx&quot;
-#include &quot;zoom_tool.hxx&quot;
-
-class ZoomToolImpl : public ToolImpl
-{
-public:
-  enum { CREATE_ZOOM_RECT, NONE } state;
-
-  CL_Rectf zoom_rect;
-
-  void draw();
-  
-  void on_mouse_up  (const CL_InputEvent&amp; event);
-  void on_mouse_down(const CL_InputEvent&amp; event);
-  void on_mouse_move(const CL_InputEvent&amp; event);
-};
-
-ZoomTool::ZoomTool()
-  : impl(new ZoomToolImpl())
-{
-  impl-&gt;state = ZoomToolImpl::NONE;
-}
-
-ZoomTool::~ZoomTool()
-{
-}
-
-void
-ZoomToolImpl::draw()
-{
-  switch (state)
-    {
-    case CREATE_ZOOM_RECT:
-      {
-        CL_Rectf tmp(zoom_rect);
-        tmp.normalize();
-        CL_Display::fill_rect(tmp, CL_Color(255, 255, 0, 50));
-        CL_Display::draw_rect(tmp, CL_Color(255, 255, 0, 200));
-      }
-    case NONE:
-      break;
-    }
-}
-
-void
-ZoomToolImpl::on_mouse_up  (const CL_InputEvent&amp; event)
-{
-  EditorMapComponent* parent = EditorMapComponent::current();
-
-  if (event.id != CL_MOUSE_RIGHT)
-    {
-      switch (state)
-        {
-        case CREATE_ZOOM_RECT:
-          {
-            state = NONE;
-            parent-&gt;release_mouse();
-
-            CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
-            zoom_rect.right  = pos.x;
-            zoom_rect.bottom = pos.y;
-            zoom_rect.normalize();
-            if (zoom_rect.get_width() &gt; 10 &amp;&amp; zoom_rect.get_height() &gt; 10)
-              {
-                parent-&gt;zoom_to(zoom_rect);
-              }
-          }
-        }
-    }
-}
-
-void
-ZoomToolImpl::on_mouse_down(const CL_InputEvent&amp; event)
-{
-  EditorMapComponent* parent = EditorMapComponent::current();
-
-  switch(event.id)
-    {
-    case CL_MOUSE_RIGHT:
-      switch (state)
-        {
-        case NONE:
-          parent-&gt;zoom_out(event.mouse_pos);
-          parent-&gt;zoom_out(event.mouse_pos);
-          break;
-        default:
-          break;
-        }
-      break;
-
-    default:
-      switch (state)
-        {
-        case NONE:
-          {
-            state = CREATE_ZOOM_RECT;
-            parent-&gt;capture_mouse();
-
-            CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
-            zoom_rect.left   = pos.x;
-            zoom_rect.top    = pos.y;
-            zoom_rect.right  = pos.x;
-            zoom_rect.bottom = pos.y;
-          }
-          break;
-        default:
-          break;
-        }
-      break;
-    }
-}
-
-void
-ZoomToolImpl::on_mouse_move(const CL_InputEvent&amp; event)
-{
-  EditorMapComponent* parent = EditorMapComponent::current();
-
-  switch (state)
-    {
-    case CREATE_ZOOM_RECT:
-      {
-        CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
-        zoom_rect.right  = pos.x;
-        zoom_rect.bottom = pos.y;  
-      }
-      break;
-    default:
-      break;
-    }
-}
-
-Tool
-ZoomTool::to_tool()
-{
-  return Tool(impl); 
-}  
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/zoom_tool.hpp (from rev 712, trunk/flexlay/lib/tools/zoom_tool.hxx)
===================================================================
--- trunk/flexlay/lib/tools/zoom_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/zoom_tool.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,43 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#ifndef HEADER_ZOOM_TOOL_HXX
+#define HEADER_ZOOM_TOOL_HXX
+
+#include &lt;ClanLib/Core/Math/rect.h&gt;
+#include &lt;ClanLib/Display/input_event.h&gt;
+#include &quot;tool.hpp&quot;
+
+class ZoomToolImpl;
+
+/** */
+class ZoomTool
+{
+public:
+  ZoomTool();
+  ~ZoomTool();
+
+  Tool to_tool();
+private:
+  SharedPtr&lt;ZoomToolImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/zoom_tool.hxx
===================================================================
--- trunk/flexlay/lib/tools/zoom_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/zoom_tool.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,43 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#ifndef HEADER_ZOOM_TOOL_HXX
-#define HEADER_ZOOM_TOOL_HXX
-
-#include &lt;ClanLib/Core/Math/rect.h&gt;
-#include &lt;ClanLib/Display/input_event.h&gt;
-#include &quot;tool.hxx&quot;
-
-class ZoomToolImpl;
-
-/** */
-class ZoomTool
-{
-public:
-  ZoomTool();
-  ~ZoomTool();
-
-  Tool to_tool();
-private:
-  SharedPtr&lt;ZoomToolImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/viewport.cpp (from rev 712, trunk/flexlay/lib/viewport.cxx)
===================================================================
--- trunk/flexlay/lib/viewport.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/viewport.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,49 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &quot;graphic_context_state.hpp&quot;
+#include &quot;viewport.hpp&quot;
+
+class ViewportImpl
+{
+public:
+  CL_Component* child;
+  GraphicContextState gc_state;
+};
+
+Viewport::Viewport(CL_Component* child, const CL_Rect&amp; rect, CL_Component* parent)
+  : CL_Component(rect, parent),
+    impl(new ViewportImpl())
+{
+  impl-&gt;child = child;
+  impl-&gt;gc_state.set_size(rect.get_width(), rect.get_height());
+}
+
+void
+Viewport::set_pos(const CL_Pointf&amp; pos)
+{
+  impl-&gt;gc_state.set_pos(pos);
+}
+
+CL_Pointf
+Viewport::get_pos() const
+{
+  return impl-&gt;gc_state.get_pos();
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/viewport.cxx
===================================================================
--- trunk/flexlay/lib/viewport.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/viewport.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,49 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &quot;graphic_context_state.hxx&quot;
-#include &quot;viewport.hxx&quot;
-
-class ViewportImpl
-{
-public:
-  CL_Component* child;
-  GraphicContextState gc_state;
-};
-
-Viewport::Viewport(CL_Component* child, const CL_Rect&amp; rect, CL_Component* parent)
-  : CL_Component(rect, parent),
-    impl(new ViewportImpl())
-{
-  impl-&gt;child = child;
-  impl-&gt;gc_state.set_size(rect.get_width(), rect.get_height());
-}
-
-void
-Viewport::set_pos(const CL_Pointf&amp; pos)
-{
-  impl-&gt;gc_state.set_pos(pos);
-}
-
-CL_Pointf
-Viewport::get_pos() const
-{
-  return impl-&gt;gc_state.get_pos();
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/viewport.hpp (from rev 712, trunk/flexlay/lib/viewport.hxx)
===================================================================
--- trunk/flexlay/lib/viewport.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/viewport.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,44 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_VIEWPORT_HXX
+#define HEADER_VIEWPORT_HXX
+
+#include &lt;ClanLib/GUI/component.h&gt;
+#include &lt;ClanLib/Core/Math/rect.h&gt;
+#include &quot;shared_ptr.hpp&quot;
+
+class ViewportImpl;
+
+/** */
+class Viewport : public CL_Component
+{
+protected:
+  virtual ~Viewport() {}
+public:
+  Viewport(CL_Component* child, const CL_Rect&amp; rect, CL_Component* parent);
+  
+  void set_pos(const CL_Pointf&amp; pos);
+  CL_Pointf get_pos() const;
+private:
+  SharedPtr&lt;ViewportImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/viewport.hxx
===================================================================
--- trunk/flexlay/lib/viewport.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/viewport.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,44 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_VIEWPORT_HXX
-#define HEADER_VIEWPORT_HXX
-
-#include &lt;ClanLib/GUI/component.h&gt;
-#include &lt;ClanLib/Core/Math/rect.h&gt;
-#include &quot;shared_ptr.hxx&quot;
-
-class ViewportImpl;
-
-/** */
-class Viewport : public CL_Component
-{
-protected:
-  virtual ~Viewport() {}
-public:
-  Viewport(CL_Component* child, const CL_Rect&amp; rect, CL_Component* parent);
-  
-  void set_pos(const CL_Pointf&amp; pos);
-  CL_Pointf get_pos() const;
-private:
-  SharedPtr&lt;ViewportImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/window.cpp (from rev 712, trunk/flexlay/lib/window.cxx)
===================================================================
--- trunk/flexlay/lib/window.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/window.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,176 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &lt;ClanLib/Core/core_iostream.h&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &lt;ClanLib/Display/keys.h&gt;
+#include &lt;ClanLib/Display/sprite_description.h&gt;
+#include &lt;ClanLib/Display/Providers/provider_factory.h&gt;
+#include &lt;ClanLib/GUI/gui_manager.h&gt;
+#include &quot;box.hpp&quot;
+#include &quot;fonts.hpp&quot;
+#include &quot;icon.hpp&quot;
+#include &quot;helper.hpp&quot;
+#include &quot;titlebar.hpp&quot;
+#include &quot;window.hpp&quot;
+
+class WindowImpl
+{
+public:
+  CL_Component* client_area;
+  CL_Component* parent;
+
+  CL_Rect old_position;
+  bool is_maximized;
+
+  Titlebar* titlebar;
+  Icon* close;
+  Icon* minimize;
+  Icon* maximize;
+
+  std::vector&lt;CL_Slot&gt; slots;
+
+  void draw();
+  void do_maximize();
+  void do_close();
+  void on_resize(int, int);
+};
+
+Window::Window(const CL_Rect&amp; rect, const std::string&amp; title, CL_Component* parent)
+  : CL_Component(rect, parent), impl(new WindowImpl())
+{
+  impl-&gt;titlebar = new Titlebar(CL_Rect(CL_Point(3+16,3), 
+                                        CL_Size(get_width()-6-18-18-18, 12+3)), title,
+                                this);
+  //Fonts::verdana11.draw(8+15, 3, title);
+
+  impl-&gt;close = new Icon(CL_Rect(CL_Point(3, 3), CL_Size(18,18)), 
+                        make_sprite(&quot;../data/images/window/close.png&quot;),
+                        &quot;&quot;, this);
+  impl-&gt;minimize = new Icon(CL_Rect(CL_Point(get_width()-3-18-18, 3), CL_Size(18,18)), 
+                            make_sprite(&quot;../data/images/window/minimize.png&quot;),
+                            &quot;&quot;, this);
+  impl-&gt;maximize = new Icon(CL_Rect(CL_Point(get_width()-3-18, 3), CL_Size(18,18)), 
+                            make_sprite(&quot;../data/images/window/maximize.png&quot;),
+                            &quot;&quot;, this);
+
+  impl-&gt;client_area = new CL_Component(CL_Rect(CL_Point(4, 3+12+7), 
+                                               CL_Size(rect.get_width()-10,
+                                                       rect.get_height()-28)), this);
+  impl-&gt;parent  = this;
+  impl-&gt;is_maximized = false;
+
+  impl-&gt;slots.push_back(sig_resize().connect(impl.get(),      &amp;WindowImpl::on_resize));
+
+  impl-&gt;slots.push_back(sig_paint().connect(impl.get(),      &amp;WindowImpl::draw));
+  impl-&gt;slots.push_back(impl-&gt;maximize-&gt;sig_clicked().connect(impl.get(), &amp;WindowImpl::do_maximize));
+  impl-&gt;slots.push_back(impl-&gt;close-&gt;sig_clicked().connect(impl.get(), &amp;WindowImpl::do_close));
+}
+
+Window::~Window()
+{
+  std::cout &lt;&lt; &quot;deleting: Window&quot; &lt;&lt; std::endl;
+}
+
+void
+WindowImpl::on_resize(int, int)
+{
+  titlebar-&gt;set_position(CL_Rect(CL_Point(3+16,3), CL_Size(parent-&gt;get_width()-6-18-18-18, 12+3)));
+  close-&gt;set_position(3, 3);
+  minimize-&gt;set_position(parent-&gt;get_width()-3-18-18, 3);
+  maximize-&gt;set_position(parent-&gt;get_width()-3-18, 3);
+  CL_Rect rect = parent-&gt;get_position();
+  client_area-&gt;set_position(CL_Rect(CL_Point(4, 3+12+7), 
+                                   CL_Size(rect.get_width()-10,
+                                           rect.get_height()-28)));
+}
+
+void
+WindowImpl::draw()
+{
+  CL_Display::push_translate (parent-&gt;get_screen_x(), parent-&gt;get_screen_y());
+
+  CL_Color highlight(255, 255, 255);
+  CL_Color midtone(150, 150, 150);
+
+  CL_Rect rect = parent-&gt;get_position() ;
+
+  Box::draw_window(CL_Rect(CL_Point(0, 0), CL_Size(rect.get_width()-1, rect.get_height()-1)));
+  Box::draw_panel_down(client_area-&gt;get_position());
+
+  /*
+    CL_Display::fill_rect(CL_Rect(CL_Point(0, 0), rect.get_size()), CL_Color(220, 220, 220));
+    CL_Display::draw_rect(CL_Rect(CL_Point(0, 0), rect.get_size()), CL_Color(0, 0, 0));
+ 
+    CL_Display::draw_line(1, rect.get_height()-2,
+    rect.get_width()-2, rect.get_height()-2, midtone);
+    CL_Display::draw_line(rect.get_width()-2, 1,
+    rect.get_width()-2, rect.get_height()-2, midtone);
+
+    CL_Display::draw_line(1, 1,
+    rect.get_width()-2, 1, highlight);
+    CL_Display::draw_line(1, 1,
+    1, rect.get_height()-2, highlight);
+  */
+
+  CL_Display::pop_modelview();
+}
+
+void
+WindowImpl::do_close()
+{
+  parent-&gt;show(false);
+}
+
+void
+WindowImpl::do_maximize()
+{
+  // FIXME: Move this to scripting language
+  if (!is_maximized)
+    {
+      is_maximized = true;
+      old_position = parent-&gt;get_position();
+      parent-&gt;set_position(parent-&gt;get_parent()-&gt;get_position());
+    }
+  else
+    {
+      is_maximized = false;
+      parent-&gt;set_position(old_position);
+    }
+}
+
+CL_Component*
+Window::get_client_area()
+{
+  return impl-&gt;client_area;
+}
+
+void
+Window::hide()
+{
+  CL_Component::show(false);
+}
+
+void
+Window::show()
+{
+  CL_Component::show(true);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/window.cxx
===================================================================
--- trunk/flexlay/lib/window.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/window.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,176 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &lt;ClanLib/Core/core_iostream.h&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-#include &lt;ClanLib/Display/keys.h&gt;
-#include &lt;ClanLib/Display/sprite_description.h&gt;
-#include &lt;ClanLib/Display/Providers/provider_factory.h&gt;
-#include &lt;ClanLib/GUI/gui_manager.h&gt;
-#include &quot;box.hxx&quot;
-#include &quot;fonts.hxx&quot;
-#include &quot;icon.hxx&quot;
-#include &quot;helper.hxx&quot;
-#include &quot;titlebar.hxx&quot;
-#include &quot;window.hxx&quot;
-
-class WindowImpl
-{
-public:
-  CL_Component* client_area;
-  CL_Component* parent;
-
-  CL_Rect old_position;
-  bool is_maximized;
-
-  Titlebar* titlebar;
-  Icon* close;
-  Icon* minimize;
-  Icon* maximize;
-
-  std::vector&lt;CL_Slot&gt; slots;
-
-  void draw();
-  void do_maximize();
-  void do_close();
-  void on_resize(int, int);
-};
-
-Window::Window(const CL_Rect&amp; rect, const std::string&amp; title, CL_Component* parent)
-  : CL_Component(rect, parent), impl(new WindowImpl())
-{
-  impl-&gt;titlebar = new Titlebar(CL_Rect(CL_Point(3+16,3), 
-                                        CL_Size(get_width()-6-18-18-18, 12+3)), title,
-                                this);
-  //Fonts::verdana11.draw(8+15, 3, title);
-
-  impl-&gt;close = new Icon(CL_Rect(CL_Point(3, 3), CL_Size(18,18)), 
-                        make_sprite(&quot;../data/images/window/close.png&quot;),
-                        &quot;&quot;, this);
-  impl-&gt;minimize = new Icon(CL_Rect(CL_Point(get_width()-3-18-18, 3), CL_Size(18,18)), 
-                            make_sprite(&quot;../data/images/window/minimize.png&quot;),
-                            &quot;&quot;, this);
-  impl-&gt;maximize = new Icon(CL_Rect(CL_Point(get_width()-3-18, 3), CL_Size(18,18)), 
-                            make_sprite(&quot;../data/images/window/maximize.png&quot;),
-                            &quot;&quot;, this);
-
-  impl-&gt;client_area = new CL_Component(CL_Rect(CL_Point(4, 3+12+7), 
-                                               CL_Size(rect.get_width()-10,
-                                                       rect.get_height()-28)), this);
-  impl-&gt;parent  = this;
-  impl-&gt;is_maximized = false;
-
-  impl-&gt;slots.push_back(sig_resize().connect(impl.get(),      &amp;WindowImpl::on_resize));
-
-  impl-&gt;slots.push_back(sig_paint().connect(impl.get(),      &amp;WindowImpl::draw));
-  impl-&gt;slots.push_back(impl-&gt;maximize-&gt;sig_clicked().connect(impl.get(), &amp;WindowImpl::do_maximize));
-  impl-&gt;slots.push_back(impl-&gt;close-&gt;sig_clicked().connect(impl.get(), &amp;WindowImpl::do_close));
-}
-
-Window::~Window()
-{
-  std::cout &lt;&lt; &quot;deleting: Window&quot; &lt;&lt; std::endl;
-}
-
-void
-WindowImpl::on_resize(int, int)
-{
-  titlebar-&gt;set_position(CL_Rect(CL_Point(3+16,3), CL_Size(parent-&gt;get_width()-6-18-18-18, 12+3)));
-  close-&gt;set_position(3, 3);
-  minimize-&gt;set_position(parent-&gt;get_width()-3-18-18, 3);
-  maximize-&gt;set_position(parent-&gt;get_width()-3-18, 3);
-  CL_Rect rect = parent-&gt;get_position();
-  client_area-&gt;set_position(CL_Rect(CL_Point(4, 3+12+7), 
-                                   CL_Size(rect.get_width()-10,
-                                           rect.get_height()-28)));
-}
-
-void
-WindowImpl::draw()
-{
-  CL_Display::push_translate (parent-&gt;get_screen_x(), parent-&gt;get_screen_y());
-
-  CL_Color highlight(255, 255, 255);
-  CL_Color midtone(150, 150, 150);
-
-  CL_Rect rect = parent-&gt;get_position() ;
-
-  Box::draw_window(CL_Rect(CL_Point(0, 0), CL_Size(rect.get_width()-1, rect.get_height()-1)));
-  Box::draw_panel_down(client_area-&gt;get_position());
-
-  /*
-    CL_Display::fill_rect(CL_Rect(CL_Point(0, 0), rect.get_size()), CL_Color(220, 220, 220));
-    CL_Display::draw_rect(CL_Rect(CL_Point(0, 0), rect.get_size()), CL_Color(0, 0, 0));
- 
-    CL_Display::draw_line(1, rect.get_height()-2,
-    rect.get_width()-2, rect.get_height()-2, midtone);
-    CL_Display::draw_line(rect.get_width()-2, 1,
-    rect.get_width()-2, rect.get_height()-2, midtone);
-
-    CL_Display::draw_line(1, 1,
-    rect.get_width()-2, 1, highlight);
-    CL_Display::draw_line(1, 1,
-    1, rect.get_height()-2, highlight);
-  */
-
-  CL_Display::pop_modelview();
-}
-
-void
-WindowImpl::do_close()
-{
-  parent-&gt;show(false);
-}
-
-void
-WindowImpl::do_maximize()
-{
-  // FIXME: Move this to scripting language
-  if (!is_maximized)
-    {
-      is_maximized = true;
-      old_position = parent-&gt;get_position();
-      parent-&gt;set_position(parent-&gt;get_parent()-&gt;get_position());
-    }
-  else
-    {
-      is_maximized = false;
-      parent-&gt;set_position(old_position);
-    }
-}
-
-CL_Component*
-Window::get_client_area()
-{
-  return impl-&gt;client_area;
-}
-
-void
-Window::hide()
-{
-  CL_Component::show(false);
-}
-
-void
-Window::show()
-{
-  CL_Component::show(true);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/window.hpp (from rev 712, trunk/flexlay/lib/window.hxx)
===================================================================
--- trunk/flexlay/lib/window.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/window.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,49 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_WINDOW_HXX
+#define HEADER_WINDOW_HXX
+
+#include &lt;ClanLib/GUI/component.h&gt;
+#include &lt;ClanLib/Core/Math/rect.h&gt;
+#include &quot;shared_ptr.hpp&quot;
+
+class WindowImpl;
+
+/** */
+class Window : public CL_Component
+{
+protected:
+  virtual ~Window();
+public:
+  Window(const CL_Rect&amp; rect, const std::string&amp; title, CL_Component* parent);
+  
+  void hide();
+  void show();
+
+  CL_Component* get_client_area();
+private:
+  Window (const Window&amp;);
+  Window&amp; operator= (const Window&amp;);
+
+  SharedPtr&lt;WindowImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/window.hxx
===================================================================
--- trunk/flexlay/lib/window.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/window.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,49 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_WINDOW_HXX
-#define HEADER_WINDOW_HXX
-
-#include &lt;ClanLib/GUI/component.h&gt;
-#include &lt;ClanLib/Core/Math/rect.h&gt;
-#include &quot;shared_ptr.hxx&quot;
-
-class WindowImpl;
-
-/** */
-class Window : public CL_Component
-{
-protected:
-  virtual ~Window();
-public:
-  Window(const CL_Rect&amp; rect, const std::string&amp; title, CL_Component* parent);
-  
-  void hide();
-  void show();
-
-  CL_Component* get_client_area();
-private:
-  Window (const Window&amp;);
-  Window&amp; operator= (const Window&amp;);
-
-  SharedPtr&lt;WindowImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/workspace.cpp (from rev 712, trunk/flexlay/lib/workspace.cxx)
===================================================================
--- trunk/flexlay/lib/workspace.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/workspace.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,161 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &lt;map&gt;
+#include &lt;ClanLib/Display/display.h&gt;
+#include &lt;ClanLib/Display/display_window.h&gt;
+#include &lt;ClanLib/Display/keys.h&gt;
+#include &quot;editor_map.hpp&quot;
+#include &quot;editor_map_component.hpp&quot;
+#include &quot;editor_names.hpp&quot;
+#include &quot;tools/tool.hpp&quot;
+#include &quot;tileset.hpp&quot;
+#include &quot;workspace.hpp&quot;
+
+Workspace Workspace::current_(false);
+
+class WorkspaceImpl
+{
+public:
+  EditorMap editor_map;
+
+  typedef std::map&lt;int, Tool&gt; Tools;
+  Tools tools;
+};
+
+Workspace::Workspace(bool create)
+  : impl(0)
+{
+  if (create)
+    {
+      impl = new WorkspaceImpl();
+      current_ = *this;
+      std::cout &lt;&lt; &quot;Workspace()&quot; &lt;&lt; std::endl;
+    }
+}
+
+void
+Workspace::draw()
+{
+  assert(impl.get());
+
+  CL_Display::clear(CL_Color(100, 0, 100));
+
+  impl-&gt;editor_map.draw_gui(CL_Display::get_current_window()-&gt;get_gc());
+  impl-&gt;editor_map.draw(EditorMapComponent::current(), CL_Display::get_current_window()-&gt;get_gc());
+  
+  // FIXME: Only draw active tool?!
+  for(WorkspaceImpl::Tools::iterator it = impl-&gt;tools.begin();
+      it != impl-&gt;tools.end(); ++it)
+    it-&gt;second.draw();
+    
+  CL_Display::flush();
+}
+
+void
+Workspace::mouse_up(const CL_InputEvent&amp; event)
+{
+  assert(impl.get());
+
+  WorkspaceImpl::Tools::iterator it = impl-&gt;tools.find(event.id);
+  if (it != impl-&gt;tools.end())
+    it-&gt;second.on_mouse_up(event);
+}
+
+void
+Workspace::mouse_move(const CL_InputEvent&amp; event)
+{
+  assert(impl.get());
+
+  for(WorkspaceImpl::Tools::iterator it = impl-&gt;tools.begin();
+      it != impl-&gt;tools.end(); ++it)
+    {
+      it-&gt;second.on_mouse_move(event);
+    }
+}
+
+void
+Workspace::mouse_down(const CL_InputEvent&amp; event)
+{
+  assert(impl.get());
+
+  WorkspaceImpl::Tools::iterator it = impl-&gt;tools.find(event.id);
+  if (it != impl-&gt;tools.end())
+    it-&gt;second.on_mouse_down(event);
+
+  switch (event.id)
+    {
+    case CL_MOUSE_WHEEL_UP:
+      EditorMapComponent::current()-&gt;zoom_in(event.mouse_pos);
+      break;
+      
+    case CL_MOUSE_WHEEL_DOWN:
+      EditorMapComponent::current()-&gt;zoom_out(event.mouse_pos);
+      break;
+    }
+}
+
+void
+Workspace::key_up(const CL_InputEvent&amp; event)
+{
+  assert(impl.get());
+
+  WorkspaceImpl::Tools::iterator it = impl-&gt;tools.find(event.id);
+  if (it != impl-&gt;tools.end())
+    it-&gt;second.on_mouse_up(event);
+}
+
+void
+Workspace::key_down(const CL_InputEvent&amp; event)
+{
+  assert(impl.get());
+
+  WorkspaceImpl::Tools::iterator it = impl-&gt;tools.find(event.id);
+  if (it != impl-&gt;tools.end())
+    it-&gt;second.on_mouse_down(event);
+  else
+    std::cout &lt;&lt; &quot;Workspace: &quot; &lt;&lt; event.id &lt;&lt; std::endl;
+}
+
+EditorMap
+Workspace::get_map()
+{
+  assert(impl.get());
+
+  return impl-&gt;editor_map;
+}
+
+void
+Workspace::set_map(const EditorMap&amp; m)
+{
+  assert(impl.get());
+
+  impl-&gt;editor_map = m;
+  std::cout &lt;&lt; &quot;Workspace:set_map&quot; &lt;&lt; std::endl;
+}
+
+void
+Workspace::set_tool(int button, const Tool&amp; tool)
+{
+  assert(impl.get());
+
+  impl-&gt;tools[button] = tool;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/workspace.cxx
===================================================================
--- trunk/flexlay/lib/workspace.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/workspace.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,161 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &lt;map&gt;
-#include &lt;ClanLib/Display/display.h&gt;
-#include &lt;ClanLib/Display/display_window.h&gt;
-#include &lt;ClanLib/Display/keys.h&gt;
-#include &quot;editor_map.hxx&quot;
-#include &quot;editor_map_component.hxx&quot;
-#include &quot;editor_names.hxx&quot;
-#include &quot;tools/tool.hxx&quot;
-#include &quot;tileset.hxx&quot;
-#include &quot;workspace.hxx&quot;
-
-Workspace Workspace::current_(false);
-
-class WorkspaceImpl
-{
-public:
-  EditorMap editor_map;
-
-  typedef std::map&lt;int, Tool&gt; Tools;
-  Tools tools;
-};
-
-Workspace::Workspace(bool create)
-  : impl(0)
-{
-  if (create)
-    {
-      impl = new WorkspaceImpl();
-      current_ = *this;
-      std::cout &lt;&lt; &quot;Workspace()&quot; &lt;&lt; std::endl;
-    }
-}
-
-void
-Workspace::draw()
-{
-  assert(impl.get());
-
-  CL_Display::clear(CL_Color(100, 0, 100));
-
-  impl-&gt;editor_map.draw_gui(CL_Display::get_current_window()-&gt;get_gc());
-  impl-&gt;editor_map.draw(EditorMapComponent::current(), CL_Display::get_current_window()-&gt;get_gc());
-  
-  // FIXME: Only draw active tool?!
-  for(WorkspaceImpl::Tools::iterator it = impl-&gt;tools.begin();
-      it != impl-&gt;tools.end(); ++it)
-    it-&gt;second.draw();
-    
-  CL_Display::flush();
-}
-
-void
-Workspace::mouse_up(const CL_InputEvent&amp; event)
-{
-  assert(impl.get());
-
-  WorkspaceImpl::Tools::iterator it = impl-&gt;tools.find(event.id);
-  if (it != impl-&gt;tools.end())
-    it-&gt;second.on_mouse_up(event);
-}
-
-void
-Workspace::mouse_move(const CL_InputEvent&amp; event)
-{
-  assert(impl.get());
-
-  for(WorkspaceImpl::Tools::iterator it = impl-&gt;tools.begin();
-      it != impl-&gt;tools.end(); ++it)
-    {
-      it-&gt;second.on_mouse_move(event);
-    }
-}
-
-void
-Workspace::mouse_down(const CL_InputEvent&amp; event)
-{
-  assert(impl.get());
-
-  WorkspaceImpl::Tools::iterator it = impl-&gt;tools.find(event.id);
-  if (it != impl-&gt;tools.end())
-    it-&gt;second.on_mouse_down(event);
-
-  switch (event.id)
-    {
-    case CL_MOUSE_WHEEL_UP:
-      EditorMapComponent::current()-&gt;zoom_in(event.mouse_pos);
-      break;
-      
-    case CL_MOUSE_WHEEL_DOWN:
-      EditorMapComponent::current()-&gt;zoom_out(event.mouse_pos);
-      break;
-    }
-}
-
-void
-Workspace::key_up(const CL_InputEvent&amp; event)
-{
-  assert(impl.get());
-
-  WorkspaceImpl::Tools::iterator it = impl-&gt;tools.find(event.id);
-  if (it != impl-&gt;tools.end())
-    it-&gt;second.on_mouse_up(event);
-}
-
-void
-Workspace::key_down(const CL_InputEvent&amp; event)
-{
-  assert(impl.get());
-
-  WorkspaceImpl::Tools::iterator it = impl-&gt;tools.find(event.id);
-  if (it != impl-&gt;tools.end())
-    it-&gt;second.on_mouse_down(event);
-  else
-    std::cout &lt;&lt; &quot;Workspace: &quot; &lt;&lt; event.id &lt;&lt; std::endl;
-}
-
-EditorMap
-Workspace::get_map()
-{
-  assert(impl.get());
-
-  return impl-&gt;editor_map;
-}
-
-void
-Workspace::set_map(const EditorMap&amp; m)
-{
-  assert(impl.get());
-
-  impl-&gt;editor_map = m;
-  std::cout &lt;&lt; &quot;Workspace:set_map&quot; &lt;&lt; std::endl;
-}
-
-void
-Workspace::set_tool(int button, const Tool&amp; tool)
-{
-  assert(impl.get());
-
-  impl-&gt;tools[button] = tool;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/workspace.hpp (from rev 712, trunk/flexlay/lib/workspace.hxx)
===================================================================
--- trunk/flexlay/lib/workspace.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/workspace.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,63 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_WORKSPACE_HXX
+#define HEADER_WORKSPACE_HXX
+
+#include &lt;ClanLib/Core/System/sharedptr.h&gt;
+#include &lt;ClanLib/Display/input_event.h&gt;
+#include &quot;graphic_context_state.hpp&quot;
+
+class WorkspaceImpl;
+class EditorMap;
+class Tool;
+
+/** */
+class Workspace
+{
+private:
+  static Workspace current_;
+
+public:
+  static void set_current(Workspace w) { current_ = w; }
+  static Workspace current() { return current_; }
+
+  Workspace(bool create = false);
+
+  void draw();
+
+  void mouse_up  (const CL_InputEvent&amp; event);
+  void mouse_down(const CL_InputEvent&amp; event);
+  void mouse_move(const CL_InputEvent&amp; event);
+
+  void key_up(const CL_InputEvent&amp; event);
+  void key_down(const CL_InputEvent&amp; event);
+
+  EditorMap get_map();
+  void set_map(const EditorMap&amp; m);
+
+  void set_tool(int button, const Tool&amp; tool);
+
+  bool is_null() const { return !impl.get(); }
+private:
+  CL_SharedPtr&lt;WorkspaceImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/workspace.hxx
===================================================================
--- trunk/flexlay/lib/workspace.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/workspace.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,63 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_WORKSPACE_HXX
-#define HEADER_WORKSPACE_HXX
-
-#include &lt;ClanLib/Core/System/sharedptr.h&gt;
-#include &lt;ClanLib/Display/input_event.h&gt;
-#include &quot;graphic_context_state.hxx&quot;
-
-class WorkspaceImpl;
-class EditorMap;
-class Tool;
-
-/** */
-class Workspace
-{
-private:
-  static Workspace current_;
-
-public:
-  static void set_current(Workspace w) { current_ = w; }
-  static Workspace current() { return current_; }
-
-  Workspace(bool create = false);
-
-  void draw();
-
-  void mouse_up  (const CL_InputEvent&amp; event);
-  void mouse_down(const CL_InputEvent&amp; event);
-  void mouse_move(const CL_InputEvent&amp; event);
-
-  void key_up(const CL_InputEvent&amp; event);
-  void key_down(const CL_InputEvent&amp; event);
-
-  EditorMap get_map();
-  void set_map(const EditorMap&amp; m);
-
-  void set_tool(int button, const Tool&amp; tool);
-
-  bool is_null() const { return !impl.get(); }
-private:
-  CL_SharedPtr&lt;WorkspaceImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Modified: trunk/flexlay/netpanzer/SConscript
===================================================================
--- trunk/flexlay/netpanzer/SConscript	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/netpanzer/SConscript	2009-11-22 03:02:03 UTC (rev 713)
@@ -23,7 +23,7 @@
 
 Import('clanLib_env')
 
-opts = Options('custom.py')
+opts = Variables('custom.py')
 opts.Add('CXX', 'The C++ compiler.', 'g++')
 opts.Add('CXXFLAGS', 'The C++ compiler flags.', '-g -O2 -Wall -fPIC')
 opts.Add('CPPPATH', 'additional header path', '')
@@ -38,16 +38,16 @@
                   options=opts)
 Help(opts.GenerateHelpText(env))
 
-Depends('netpanzer.i', ['netpanzer.hxx'])
-env.Command('netpanzer_wrap.cxx', 'netpanzer.i',
+Depends('netpanzer.i', ['netpanzer.hpp'])
+env.Command('netpanzer_wrap.cpp', 'netpanzer.i',
             &quot;swig -c++ -ruby -o $TARGET $SOURCE&quot;)
 
 libflexlay_ruby_env = env.Clone()
 flexlay_ruby_lib = libflexlay_ruby_env.SharedLibrary(
     target = 'netpanzer_wrap.so',
     source = [
-    'netpanzer_wrap.cxx',
-    'netpanzer.cxx'
+    'netpanzer_wrap.cpp',
+    'netpanzer.cpp'
     ],
     CPPPATH=['$USER_CPPPATH','$RUBYDIR','../lib/'] + clanLib_env['CPPPATH'],
     LINKFLAGS = clanLib_env['LINKFLAGS'],

Copied: trunk/flexlay/netpanzer/averagecolor.cpp (from rev 712, trunk/flexlay/netpanzer/averagecolor.cxx)

Deleted: trunk/flexlay/netpanzer/averagecolor.cxx
===================================================================
--- trunk/flexlay/netpanzer/averagecolor.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/netpanzer/averagecolor.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,47 +0,0 @@
-#include &lt;ClanLib/display.h&gt;
-#include &lt;ClanLib/core.h&gt;
-
-CL_Color
-calc_average_color(const char* filename)
-{
-  // FIXME: Works only from indexed images
-  CL_PNGProvider buffer(filename);
-  int len = buffer.get_pitch() * buffer.get_height();
-  unsigned char* buf = static_cast&lt;unsigned char*&gt;(buffer.get_data());
-  CL_Palette palette = buffer.get_palette();
-  float red   = 0;
-  float green = 0;
-  float blue  = 0;
-
-  for(int i = 0; i &lt; len; ++i)
-    {
-      red   += palette.colors[buf[i]].get_red();
-      green += palette.colors[buf[i]].get_green();
-      blue  += palette.colors[buf[i]].get_blue();
-    }
-
-  return CL_Color(int(red/len),
-                  int(green/len),
-                  int(blue/len));
-}
-
-int main(int argc, char** argv)
-{
-  CL_SetupCore::init();
-  CL_SetupDisplay::init(true);
-
-  for(int i = 1; i &lt; argc; ++i)
-    {
-      CL_Color color = calc_average_color(argv[i]);
-      std::cout &lt;&lt; argv[i] 
-                &lt;&lt; &quot; &quot; &lt;&lt; color.get_red()
-                &lt;&lt; &quot; &quot; &lt;&lt; color.get_green()
-                &lt;&lt; &quot; &quot; &lt;&lt; color.get_blue()
-                &lt;&lt; std::endl;
-    }
-
-  CL_SetupDisplay::deinit();
-  CL_SetupCore::deinit();
-}
-
-/* EOF */

Copied: trunk/flexlay/netpanzer/netpanzer.cpp (from rev 712, trunk/flexlay/netpanzer/netpanzer.cxx)
===================================================================
--- trunk/flexlay/netpanzer/netpanzer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/netpanzer/netpanzer.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,553 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &lt;sstream&gt;
+#include &lt;fstream&gt;
+#include &lt;ClanLib/core.h&gt;
+#include &lt;ClanLib/Display/palette.h&gt;
+#include &lt;ClanLib/Display/sprite.h&gt;
+#include &lt;ClanLib/Display/pixel_format.h&gt;
+#include &lt;ClanLib/Display/pixel_format_type.h&gt;
+#include &lt;ClanLib/Display/sprite_description.h&gt;
+#include &lt;ClanLib/Display/Providers/provider_factory.h&gt;
+#include &quot;globals.hpp&quot;
+#include &quot;tile_provider.hpp&quot;
+#include &quot;tile_provider_impl.hpp&quot;
+#include &quot;tile.hpp&quot;
+#include &quot;tileset.hpp&quot;
+#include &quot;blitter.hpp&quot;
+#include &quot;tilemap_layer.hpp&quot;
+#include &quot;editor_map.hpp&quot;
+#include &quot;netpanzer.hpp&quot;
+
+NetPanzerData* NetPanzerData::instance_ = 0;
+
+class NetPanzerTileProviderImpl : public TileProviderImpl
+{
+private:
+  int id;
+  mutable CL_Sprite sprite;
+  mutable CL_PixelBuffer buffer;
+
+public:
+  NetPanzerTileProviderImpl(int id_)
+    : id(id_)
+  {    
+  }
+
+  virtual ~NetPanzerTileProviderImpl()
+  {
+  }
+
+  CL_Sprite get_sprite() const
+  {
+    if (sprite)
+      {
+        return sprite;
+      }
+    else
+      {
+        NetPanzerTileGroup&amp; tilegroup = NetPanzerData::instance()-&gt;find_tilegroup(id);
+        int dist = id - tilegroup.start;
+
+        CL_Rect rect(CL_Point((dist % tilegroup.width) * 32,
+                              (dist / tilegroup.width) * 32),
+                     CL_Size(32, 32));
+        sprite.add_frame(tilegroup.get_surface(), rect);
+        return sprite;
+      }
+  }
+
+  CL_PixelBuffer get_pixelbuffer() const
+  {
+    if (buffer)
+      {
+        return buffer;
+      }
+    else
+      {
+        // FIXME: ClanLibs indexed handling seems broken, so we do
+        // the conversion ourself
+        const CL_Palette&amp; palette = NetPanzerData::instance()-&gt;get_palette();
+        unsigned char* data = NetPanzerData::instance()-&gt;get_tiledata() + (32*32) * id;
+        buffer = CL_PixelBuffer(32, 32, 32*3, CL_PixelFormat::rgb888);
+
+        buffer.lock();
+        unsigned char* target = static_cast&lt;unsigned char*&gt;(buffer.get_data());
+
+        for(int i = 0; i &lt; 32*32; ++i)
+          {
+            target[3*i+0] = palette[data[i]].get_blue();
+            target[3*i+1] = palette[data[i]].get_green();
+            target[3*i+2] = palette[data[i]].get_red();
+          }
+        buffer.unlock();
+                
+        return buffer;
+      }
+  }
+};
+
+NetPanzerData::NetPanzerData() 
+{
+}
+
+void
+NetPanzerData::register_tilegroup(int start, int width, int height)
+{
+  NetPanzerTileGroup group;
+
+  group.start  = start;
+  group.width  = width;
+  group.height = height;
+
+  tilegroups.push_back(group);
+}
+
+void
+NetPanzerData::load_data(const std::string&amp; datadir_)
+{
+  datadir = datadir_;
+  std::cout &lt;&lt; &quot;NetPanzerData: Loading data from '&quot; &lt;&lt; datadir &lt;&lt; &quot;'&quot; &lt;&lt; std::endl;
+  palette = load_palette(datadir + &quot;/&quot; + &quot;wads/netp.act&quot;);
+  load_tileset(datadir + &quot;/&quot; + &quot;wads/summer12mb.tls&quot;);
+}
+
+CL_Surface
+NetPanzerTileGroup::get_surface()
+{
+  if (!surface)
+    {
+      CL_PixelBuffer buffer(width*32, height*32, width*32*4, CL_PixelFormat::rgba8888);
+
+      for(int y = 0; y &lt; height; ++y)
+        for(int x = 0; x &lt; width; ++x)
+          {
+            const CL_Palette&amp; palette = NetPanzerData::instance()-&gt;get_palette();
+            unsigned char* data = NetPanzerData::instance()-&gt;get_tiledata() + (32*32) * (start + width*y + x);
+
+            NetPanzerTileHeader header = NetPanzerData::instance()-&gt;get_tile_headers()[start + width*y + x]; 
+           
+            CL_PixelBuffer tile(32, 32, 32*3, CL_PixelFormat::rgb888);
+
+            tile.lock();
+            unsigned char* target = static_cast&lt;unsigned char*&gt;(tile.get_data());
+
+            float r = 1.0f;
+            float g = 1.0f;
+            float b = 1.0f;
+
+            switch (header.move_value)
+              {
+              case 0: // streets, allowing faster movement
+                r = 1.0f;
+                g = 1.0f;
+                b = 0.0f;
+                break;
+
+              case 1: // normal ground which allows to move
+                r = 1.0f;
+                g = 1.0f;
+                b = 1.0f;
+                break;
+
+              case 4: // unpassable terrain
+                r = 0.0f;
+                g = 1.0;
+                b = 0.0f;
+                break;
+
+              case 5: // water
+                r = 0.0f;
+                g = 0.0f;
+                b = 1.0f;
+                break;
+
+              default:
+                std::cout &lt;&lt; &quot;Unknown header value: &quot; &lt;&lt; int(header.move_value) &lt;&lt; std::endl;
+                break;
+              }
+
+            for(int i = 0; i &lt; 32*32; ++i)
+              {
+                target[3*i+0] = int(palette[data[i]].get_blue()  * b);
+                target[3*i+1] = int(palette[data[i]].get_green() * g);
+                target[3*i+2] = int(palette[data[i]].get_red()   * r);
+              }
+            tile.unlock();
+                
+            blit(buffer, tile, x * 32, y * 32);
+          }
+      
+      surface = CL_Surface(buffer);
+    }
+
+  return surface;
+}
+
+CL_Sprite
+NetPanzerData::get_tilegroup_sprite(int index)
+{
+  for(TileGroups::iterator i = tilegroups.begin(); i != tilegroups.end(); ++i)
+    {
+      if (index == i-&gt;start)
+        {
+          CL_Sprite sprite;
+          sprite.add_frame(i-&gt;get_surface(), CL_Rect(CL_Point(0, 0),
+                                                     CL_Size(i-&gt;get_surface().get_width(),
+                                                             i-&gt;get_surface().get_height())));
+          return sprite;
+        }
+    }
+
+  std::cout &lt;&lt; &quot;NetPanzerData: Couldn't get tilegroup_sprite for '&quot; &lt;&lt; index &lt;&lt; &quot;'&quot; &lt;&lt; std::endl;
+  return CL_Sprite();
+}
+
+NetPanzerTileGroup&amp;
+NetPanzerData::find_tilegroup(int index)
+{
+  for(TileGroups::iterator i = tilegroups.begin(); i != tilegroups.end(); ++i)
+    {
+      if (i-&gt;start &lt;= index &amp;&amp; index &lt; i-&gt;start + (i-&gt;width*i-&gt;height))
+        {
+          return *i;
+        }
+    }
+
+  std::cout &lt;&lt; &quot;NetPanzerData: Couldn't find tilegroup for '&quot; &lt;&lt; index &lt;&lt; &quot;'&quot; &lt;&lt; std::endl;
+  // return some junk just to keep it running
+  return tilegroups.front();
+}
+
+const Tileset&amp;
+NetPanzerData::get_tileset() const
+{
+  return tileset;
+}
+
+const CL_Palette&amp;
+NetPanzerData::get_palette() const
+{
+  return palette;
+}
+
+const std::vector&lt;NetPanzerTileHeader&gt;&amp;
+NetPanzerData::get_tile_headers() const
+{
+  return tile_headers;
+}
+
+unsigned char*
+NetPanzerData::get_tiledata() const
+{
+  return tiledata;
+}
+
+CL_Palette
+NetPanzerData::load_palette(const std::string&amp; filename)
+{
+  CL_Palette palette;
+  unsigned char color_array[256 * 3];
+  
+  std::ifstream in(filename.c_str());
+  
+  if (!in)
+    {
+      std::cout &lt;&lt; &quot;Couldn't load palette&quot; &lt;&lt; std::endl;
+      return palette;
+    }
+
+  in.read(reinterpret_cast&lt;char*&gt;(color_array), sizeof(color_array));
+
+  for(int i = 0; i &lt; 256; ++i)
+    {
+      palette.colors[i].set_red  (color_array[3*i + 0]);
+      palette.colors[i].set_green(color_array[3*i + 1]);
+      palette.colors[i].set_blue (color_array[3*i + 2]);
+    }
+
+  return palette;
+}
+
+void
+NetPanzerData::load_tileset(const std::string&amp; filename)
+{
+  unsigned char	netp_id_header[64];
+  unsigned short	version;
+  unsigned short	width;
+  unsigned short	height;
+  unsigned short	tile_count;
+  unsigned char	raw_palette[768];
+
+  std::ifstream file(filename.c_str());  
+
+  if (!file)
+    {
+      std::cout &lt;&lt; &quot;Couldn't load &quot; &lt;&lt; filename &lt;&lt; std::endl;
+    }
+  else
+    {
+      file.read(reinterpret_cast&lt;char*&gt;(netp_id_header), sizeof(netp_id_header));
+      file.read(reinterpret_cast&lt;char*&gt;(&amp;version), sizeof(version));
+      file.read(reinterpret_cast&lt;char*&gt;(&amp;width), sizeof(width));
+      file.read(reinterpret_cast&lt;char*&gt;(&amp;height), sizeof(height));
+      file.read(reinterpret_cast&lt;char*&gt;(&amp;tile_count), sizeof(tile_count));
+      file.read(reinterpret_cast&lt;char*&gt;(raw_palette), sizeof(raw_palette));
+
+      tile_headers.resize(tile_count);
+
+      file.read(reinterpret_cast&lt;char*&gt;(&amp;*tile_headers.begin()), 
+                sizeof(NetPanzerTileHeader)*tile_count);
+
+      cl_uint32 tilesize = width * height;
+      // FIXME: Delete this somewhere!
+      unsigned char* tiledata = new unsigned char[tilesize*tile_count];
+      file.read(reinterpret_cast&lt;char*&gt;(tiledata), tilesize*tile_count);
+      file.close();
+
+      // FIXME: The palette in the netpanzer 'summer12mb.tls' file
+      // is either broken or otherwise corrupt, so we ignore it
+      // and use the seperate palette file 'netp.act' which works
+      // fine.
+      
+      NetPanzerData::instance()-&gt;tiledata = tiledata;
+      
+      tileset = Tileset(width);
+
+      for(int i = 0; i &lt; tile_count; ++i)
+        {
+          Tile tile(TileProvider(new NetPanzerTileProviderImpl(i)));
+          tileset.add_tile(i, &amp;tile);
+        }
+    }
+}
+
+unsigned char find_nearest_color(const CL_Palette&amp; palette, const CL_Color&amp; rgb)
+{ // Copyright (C) 1998 Pyrosoft Inc. (www.pyrosoftgames.com), Matthew Bogue
+  float bestDist = 10000000.0f;
+  int   best     = 0;
+
+  float vPic = sqrt(rgb.get_red() * rgb.get_red() 
+                    + rgb.get_green() * rgb.get_green()
+                    + rgb.get_blue() * rgb.get_blue()) * 0.57735027;
+ 
+  for (int i = 0; i &lt; 256; i++) {
+    float vPal = sqrt(palette.colors[i].get_red()     * palette.colors[i].get_red()
+                      + palette.colors[i].get_green() * palette.colors[i].get_green()
+                      + palette.colors[i].get_blue()  * palette.colors[i].get_blue()) * 0.57735027;
+
+    float dr = palette.colors[i].get_red()   - rgb.get_red();
+    float dg = palette.colors[i].get_green() - rgb.get_green();
+    float db = palette.colors[i].get_blue()  - rgb.get_blue();
+    float dv = vPal-vPic;
+    float dist = dr * dr * 0.3 + dg * dg * 0.59 + db * db * 0.11 + dv * dv * 0.7;
+
+    if (dist &lt; bestDist) {
+      bestDist = dist;
+      best = i;
+    }
+  }
+
+  return best;
+}
+
+class NetPanzerFileStructImpl
+{
+public:
+  std::string id_header;
+  std::string name;
+  std::string description;
+  TilemapLayer tilemap; 
+  Tileset tileset;
+};
+
+std::string
+NetPanzerFileStruct::get_id_header()
+{
+  return impl-&gt;id_header;
+}
+
+std::string
+NetPanzerFileStruct::get_name()
+{
+  return impl-&gt;name;
+}
+
+std::string
+NetPanzerFileStruct::get_description()
+{
+  return impl-&gt;description;
+}
+
+TilemapLayer
+NetPanzerFileStruct::get_tilemap()
+{
+  return impl-&gt;tilemap;
+}
+
+void
+NetPanzerFileStruct::set_id_header(const std::string&amp; id)
+{
+  impl-&gt;id_header = id;
+}
+
+void
+NetPanzerFileStruct::set_name(const std::string&amp; name)
+{
+  impl-&gt;name = name;
+}
+
+void
+NetPanzerFileStruct::set_description(const std::string&amp; description)
+{
+  impl-&gt;description = description;
+}
+
+void
+NetPanzerFileStruct::set_tilemap(TilemapLayer l)
+{
+  impl-&gt;tilemap = l;
+}
+
+
+void
+NetPanzerFileStruct::save(const std::string&amp; filename)
+{
+  if (impl-&gt;tilemap.is_null())
+    return;
+    
+  unsigned char   netp_id_header[64];
+  strcpy(reinterpret_cast&lt;char*&gt;(netp_id_header), impl-&gt;id_header.c_str());
+  unsigned short  id       = 0; // ?
+  char   name[256];
+  strcpy(name, impl-&gt;name.c_str());
+  char   description[1024];
+  strcpy(description, impl-&gt;description.c_str());
+  unsigned short  x_size   = impl-&gt;tilemap.get_width();
+  unsigned short  y_size   = impl-&gt;tilemap.get_height();
+  char            tile_set[256] = &quot;summer12mb.tls&quot;;
+ 
+  unsigned short  thumbnail_x_pix = impl-&gt;tilemap.get_width();
+  unsigned short  thumbnail_y_pix = impl-&gt;tilemap.get_height();
+    
+  std::ofstream out(filename.c_str());
+
+  // FIXME: Not endian clean
+  out.write(reinterpret_cast&lt;char*&gt;(&amp;netp_id_header), sizeof(netp_id_header));
+  out.write(reinterpret_cast&lt;char*&gt;(&amp;id), sizeof(short));
+  out.write(reinterpret_cast&lt;char*&gt;(&amp;name), sizeof(name));
+  out.write(reinterpret_cast&lt;char*&gt;(&amp;description), sizeof(description));
+  out.write(reinterpret_cast&lt;char*&gt;(&amp;x_size), sizeof(short));
+  out.write(reinterpret_cast&lt;char*&gt;(&amp;y_size), sizeof(short));
+  out.write(reinterpret_cast&lt;char*&gt;(&amp;tile_set), sizeof(tile_set));
+  out.write(reinterpret_cast&lt;char*&gt;(&amp;thumbnail_x_pix), sizeof(short));
+  out.write(reinterpret_cast&lt;char*&gt;(&amp;thumbnail_y_pix), sizeof(short));
+
+  std::vector&lt;unsigned short&gt; vec(x_size * y_size);
+
+  int tile_count = impl-&gt;tilemap.get_tileset().get_tiles().size();
+  Field&lt;int&gt;* field = impl-&gt;tilemap.get_field();
+  for(int i = 0; i &lt; x_size * y_size; ++i)
+    {
+      // Fill everything that isn't a valid tile with grass
+      if ((*field)[i] &gt;= 0 &amp;&amp; (*field)[i] &lt; tile_count)
+        vec[i] = (*field)[i];
+      else
+        vec[i] = 8097 + rand()%16;
+    }
+  out.write(reinterpret_cast&lt;char*&gt;(&amp;(*vec.begin())), 
+            sizeof(unsigned short)*vec.size());
+
+  // Generate thumbnail
+  std::vector&lt;unsigned char&gt; thumbnail(x_size * y_size);
+  for(int i = 0; i &lt; int(thumbnail.size()); ++i)
+    {
+      Tile* tile = impl-&gt;tileset.create((*field)[i]);
+      if (tile)
+        thumbnail[i] = find_nearest_color(NetPanzerData::instance()-&gt;get_palette(), tile-&gt;get_color());
+    }
+
+  out.write(reinterpret_cast&lt;char*&gt;(&amp;(*thumbnail.begin())), 
+            sizeof(unsigned char)*thumbnail.size());
+}
+
+NetPanzerFileStruct::NetPanzerFileStruct(Tileset tileset, int w, int h)
+  : impl(new NetPanzerFileStructImpl())
+{
+  impl-&gt;tileset = tileset;
+  impl-&gt;id_header = &quot;&lt;Id Header&gt;&quot;;
+  impl-&gt;name = &quot;&lt;Name&gt;&quot;;
+  impl-&gt;description = &quot;&lt;Description&gt;&quot;;
+  impl-&gt;tilemap = TilemapLayer(tileset, w, h);
+}
+
+NetPanzerFileStruct::NetPanzerFileStruct(Tileset tileset, const std::string&amp; filename)
+  : impl(new NetPanzerFileStructImpl())
+{
+  impl-&gt;tileset = tileset;
+  
+  // FIXME: endian issues
+  unsigned char   netp_id_header[64]; // Copyright PyroSoft Inc.
+  unsigned short  id; // What is this?
+  char            name[256];
+  char            description[1024];
+  unsigned short  x_size; // width
+  unsigned short  y_size; // height
+  char            tile_set[256]; // name of the tileset: &quot;summer12mb.tls&quot;
+ 
+  unsigned short  thumbnail_x_pix;
+  unsigned short  thumbnail_y_pix;
+
+  std::ifstream file(filename.c_str());
+
+  if (!file)
+    {
+      std::cout &lt;&lt; &quot;NetPanzerFileStructImpl: Error: &quot; &lt;&lt; filename &lt;&lt; std::endl;
+    }
+
+  file.read(reinterpret_cast&lt;char*&gt;(&amp;netp_id_header), sizeof(netp_id_header));
+  file.read(reinterpret_cast&lt;char*&gt;(&amp;id), sizeof(short));
+  file.read(reinterpret_cast&lt;char*&gt;(&amp;name), sizeof(name));
+  file.read(reinterpret_cast&lt;char*&gt;(&amp;description), sizeof(description));
+  file.read(reinterpret_cast&lt;char*&gt;(&amp;x_size), sizeof(short));
+  file.read(reinterpret_cast&lt;char*&gt;(&amp;y_size), sizeof(short));
+  file.read(reinterpret_cast&lt;char*&gt;(&amp;tile_set), sizeof(tile_set));
+  file.read(reinterpret_cast&lt;char*&gt;(&amp;thumbnail_x_pix), sizeof(short));
+  file.read(reinterpret_cast&lt;char*&gt;(&amp;thumbnail_y_pix), sizeof(short));
+
+  TilemapLayer tilemap(tileset, x_size, y_size);
+  Field&lt;int&gt;* field      = tilemap.get_field();
+
+  std::vector&lt;unsigned short&gt; vec;
+  vec.resize(x_size * y_size);
+  file.read(reinterpret_cast&lt;char*&gt;(&amp;(*vec.begin())), sizeof(unsigned short)*vec.size());
+
+  for(int i = 0; i &lt; x_size*y_size; ++i)
+    (*field)[i] = vec[i];
+
+  std::cout &lt;&lt; &quot;Thumbnail: &quot; &lt;&lt; thumbnail_x_pix &lt;&lt; &quot; &quot; &lt;&lt; thumbnail_y_pix &lt;&lt; std::endl;
+
+  impl-&gt;tilemap     = tilemap;
+  impl-&gt;id_header   = reinterpret_cast&lt;char*&gt;(netp_id_header);
+  impl-&gt;name        = name;
+  impl-&gt;description = description;
+}
+
+/* EOF */

Deleted: trunk/flexlay/netpanzer/netpanzer.cxx
===================================================================
--- trunk/flexlay/netpanzer/netpanzer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/netpanzer/netpanzer.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,553 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &lt;sstream&gt;
-#include &lt;fstream&gt;
-#include &lt;ClanLib/core.h&gt;
-#include &lt;ClanLib/Display/palette.h&gt;
-#include &lt;ClanLib/Display/sprite.h&gt;
-#include &lt;ClanLib/Display/pixel_format.h&gt;
-#include &lt;ClanLib/Display/pixel_format_type.h&gt;
-#include &lt;ClanLib/Display/sprite_description.h&gt;
-#include &lt;ClanLib/Display/Providers/provider_factory.h&gt;
-#include &quot;globals.hxx&quot;
-#include &quot;tile_provider.hxx&quot;
-#include &quot;tile_provider_impl.hxx&quot;
-#include &quot;tile.hxx&quot;
-#include &quot;tileset.hxx&quot;
-#include &quot;blitter.hxx&quot;
-#include &quot;tilemap_layer.hxx&quot;
-#include &quot;editor_map.hxx&quot;
-#include &quot;netpanzer.hxx&quot;
-
-NetPanzerData* NetPanzerData::instance_ = 0;
-
-class NetPanzerTileProviderImpl : public TileProviderImpl
-{
-private:
-  int id;
-  mutable CL_Sprite sprite;
-  mutable CL_PixelBuffer buffer;
-
-public:
-  NetPanzerTileProviderImpl(int id_)
-    : id(id_)
-  {    
-  }
-
-  virtual ~NetPanzerTileProviderImpl()
-  {
-  }
-
-  CL_Sprite get_sprite() const
-  {
-    if (sprite)
-      {
-        return sprite;
-      }
-    else
-      {
-        NetPanzerTileGroup&amp; tilegroup = NetPanzerData::instance()-&gt;find_tilegroup(id);
-        int dist = id - tilegroup.start;
-
-        CL_Rect rect(CL_Point((dist % tilegroup.width) * 32,
-                              (dist / tilegroup.width) * 32),
-                     CL_Size(32, 32));
-        sprite.add_frame(tilegroup.get_surface(), rect);
-        return sprite;
-      }
-  }
-
-  CL_PixelBuffer get_pixelbuffer() const
-  {
-    if (buffer)
-      {
-        return buffer;
-      }
-    else
-      {
-        // FIXME: ClanLibs indexed handling seems broken, so we do
-        // the conversion ourself
-        const CL_Palette&amp; palette = NetPanzerData::instance()-&gt;get_palette();
-        unsigned char* data = NetPanzerData::instance()-&gt;get_tiledata() + (32*32) * id;
-        buffer = CL_PixelBuffer(32, 32, 32*3, CL_PixelFormat::rgb888);
-
-        buffer.lock();
-        unsigned char* target = static_cast&lt;unsigned char*&gt;(buffer.get_data());
-
-        for(int i = 0; i &lt; 32*32; ++i)
-          {
-            target[3*i+0] = palette[data[i]].get_blue();
-            target[3*i+1] = palette[data[i]].get_green();
-            target[3*i+2] = palette[data[i]].get_red();
-          }
-        buffer.unlock();
-                
-        return buffer;
-      }
-  }
-};
-
-NetPanzerData::NetPanzerData() 
-{
-}
-
-void
-NetPanzerData::register_tilegroup(int start, int width, int height)
-{
-  NetPanzerTileGroup group;
-
-  group.start  = start;
-  group.width  = width;
-  group.height = height;
-
-  tilegroups.push_back(group);
-}
-
-void
-NetPanzerData::load_data(const std::string&amp; datadir_)
-{
-  datadir = datadir_;
-  std::cout &lt;&lt; &quot;NetPanzerData: Loading data from '&quot; &lt;&lt; datadir &lt;&lt; &quot;'&quot; &lt;&lt; std::endl;
-  palette = load_palette(datadir + &quot;/&quot; + &quot;wads/netp.act&quot;);
-  load_tileset(datadir + &quot;/&quot; + &quot;wads/summer12mb.tls&quot;);
-}
-
-CL_Surface
-NetPanzerTileGroup::get_surface()
-{
-  if (!surface)
-    {
-      CL_PixelBuffer buffer(width*32, height*32, width*32*4, CL_PixelFormat::rgba8888);
-
-      for(int y = 0; y &lt; height; ++y)
-        for(int x = 0; x &lt; width; ++x)
-          {
-            const CL_Palette&amp; palette = NetPanzerData::instance()-&gt;get_palette();
-            unsigned char* data = NetPanzerData::instance()-&gt;get_tiledata() + (32*32) * (start + width*y + x);
-
-            NetPanzerTileHeader header = NetPanzerData::instance()-&gt;get_tile_headers()[start + width*y + x]; 
-           
-            CL_PixelBuffer tile(32, 32, 32*3, CL_PixelFormat::rgb888);
-
-            tile.lock();
-            unsigned char* target = static_cast&lt;unsigned char*&gt;(tile.get_data());
-
-            float r = 1.0f;
-            float g = 1.0f;
-            float b = 1.0f;
-
-            switch (header.move_value)
-              {
-              case 0: // streets, allowing faster movement
-                r = 1.0f;
-                g = 1.0f;
-                b = 0.0f;
-                break;
-
-              case 1: // normal ground which allows to move
-                r = 1.0f;
-                g = 1.0f;
-                b = 1.0f;
-                break;
-
-              case 4: // unpassable terrain
-                r = 0.0f;
-                g = 1.0;
-                b = 0.0f;
-                break;
-
-              case 5: // water
-                r = 0.0f;
-                g = 0.0f;
-                b = 1.0f;
-                break;
-
-              default:
-                std::cout &lt;&lt; &quot;Unknown header value: &quot; &lt;&lt; int(header.move_value) &lt;&lt; std::endl;
-                break;
-              }
-
-            for(int i = 0; i &lt; 32*32; ++i)
-              {
-                target[3*i+0] = int(palette[data[i]].get_blue()  * b);
-                target[3*i+1] = int(palette[data[i]].get_green() * g);
-                target[3*i+2] = int(palette[data[i]].get_red()   * r);
-              }
-            tile.unlock();
-                
-            blit(buffer, tile, x * 32, y * 32);
-          }
-      
-      surface = CL_Surface(buffer);
-    }
-
-  return surface;
-}
-
-CL_Sprite
-NetPanzerData::get_tilegroup_sprite(int index)
-{
-  for(TileGroups::iterator i = tilegroups.begin(); i != tilegroups.end(); ++i)
-    {
-      if (index == i-&gt;start)
-        {
-          CL_Sprite sprite;
-          sprite.add_frame(i-&gt;get_surface(), CL_Rect(CL_Point(0, 0),
-                                                     CL_Size(i-&gt;get_surface().get_width(),
-                                                             i-&gt;get_surface().get_height())));
-          return sprite;
-        }
-    }
-
-  std::cout &lt;&lt; &quot;NetPanzerData: Couldn't get tilegroup_sprite for '&quot; &lt;&lt; index &lt;&lt; &quot;'&quot; &lt;&lt; std::endl;
-  return CL_Sprite();
-}
-
-NetPanzerTileGroup&amp;
-NetPanzerData::find_tilegroup(int index)
-{
-  for(TileGroups::iterator i = tilegroups.begin(); i != tilegroups.end(); ++i)
-    {
-      if (i-&gt;start &lt;= index &amp;&amp; index &lt; i-&gt;start + (i-&gt;width*i-&gt;height))
-        {
-          return *i;
-        }
-    }
-
-  std::cout &lt;&lt; &quot;NetPanzerData: Couldn't find tilegroup for '&quot; &lt;&lt; index &lt;&lt; &quot;'&quot; &lt;&lt; std::endl;
-  // return some junk just to keep it running
-  return tilegroups.front();
-}
-
-const Tileset&amp;
-NetPanzerData::get_tileset() const
-{
-  return tileset;
-}
-
-const CL_Palette&amp;
-NetPanzerData::get_palette() const
-{
-  return palette;
-}
-
-const std::vector&lt;NetPanzerTileHeader&gt;&amp;
-NetPanzerData::get_tile_headers() const
-{
-  return tile_headers;
-}
-
-unsigned char*
-NetPanzerData::get_tiledata() const
-{
-  return tiledata;
-}
-
-CL_Palette
-NetPanzerData::load_palette(const std::string&amp; filename)
-{
-  CL_Palette palette;
-  unsigned char color_array[256 * 3];
-  
-  std::ifstream in(filename.c_str());
-  
-  if (!in)
-    {
-      std::cout &lt;&lt; &quot;Couldn't load palette&quot; &lt;&lt; std::endl;
-      return palette;
-    }
-
-  in.read(reinterpret_cast&lt;char*&gt;(color_array), sizeof(color_array));
-
-  for(int i = 0; i &lt; 256; ++i)
-    {
-      palette.colors[i].set_red  (color_array[3*i + 0]);
-      palette.colors[i].set_green(color_array[3*i + 1]);
-      palette.colors[i].set_blue (color_array[3*i + 2]);
-    }
-
-  return palette;
-}
-
-void
-NetPanzerData::load_tileset(const std::string&amp; filename)
-{
-  unsigned char	netp_id_header[64];
-  unsigned short	version;
-  unsigned short	width;
-  unsigned short	height;
-  unsigned short	tile_count;
-  unsigned char	raw_palette[768];
-
-  std::ifstream file(filename.c_str());  
-
-  if (!file)
-    {
-      std::cout &lt;&lt; &quot;Couldn't load &quot; &lt;&lt; filename &lt;&lt; std::endl;
-    }
-  else
-    {
-      file.read(reinterpret_cast&lt;char*&gt;(netp_id_header), sizeof(netp_id_header));
-      file.read(reinterpret_cast&lt;char*&gt;(&amp;version), sizeof(version));
-      file.read(reinterpret_cast&lt;char*&gt;(&amp;width), sizeof(width));
-      file.read(reinterpret_cast&lt;char*&gt;(&amp;height), sizeof(height));
-      file.read(reinterpret_cast&lt;char*&gt;(&amp;tile_count), sizeof(tile_count));
-      file.read(reinterpret_cast&lt;char*&gt;(raw_palette), sizeof(raw_palette));
-
-      tile_headers.resize(tile_count);
-
-      file.read(reinterpret_cast&lt;char*&gt;(&amp;*tile_headers.begin()), 
-                sizeof(NetPanzerTileHeader)*tile_count);
-
-      cl_uint32 tilesize = width * height;
-      // FIXME: Delete this somewhere!
-      unsigned char* tiledata = new unsigned char[tilesize*tile_count];
-      file.read(reinterpret_cast&lt;char*&gt;(tiledata), tilesize*tile_count);
-      file.close();
-
-      // FIXME: The palette in the netpanzer 'summer12mb.tls' file
-      // is either broken or otherwise corrupt, so we ignore it
-      // and use the seperate palette file 'netp.act' which works
-      // fine.
-      
-      NetPanzerData::instance()-&gt;tiledata = tiledata;
-      
-      tileset = Tileset(width);
-
-      for(int i = 0; i &lt; tile_count; ++i)
-        {
-          Tile tile(TileProvider(new NetPanzerTileProviderImpl(i)));
-          tileset.add_tile(i, &amp;tile);
-        }
-    }
-}
-
-unsigned char find_nearest_color(const CL_Palette&amp; palette, const CL_Color&amp; rgb)
-{ // Copyright (C) 1998 Pyrosoft Inc. (www.pyrosoftgames.com), Matthew Bogue
-  float bestDist = 10000000.0f;
-  int   best     = 0;
-
-  float vPic = sqrt(rgb.get_red() * rgb.get_red() 
-                    + rgb.get_green() * rgb.get_green()
-                    + rgb.get_blue() * rgb.get_blue()) * 0.57735027;
- 
-  for (int i = 0; i &lt; 256; i++) {
-    float vPal = sqrt(palette.colors[i].get_red()     * palette.colors[i].get_red()
-                      + palette.colors[i].get_green() * palette.colors[i].get_green()
-                      + palette.colors[i].get_blue()  * palette.colors[i].get_blue()) * 0.57735027;
-
-    float dr = palette.colors[i].get_red()   - rgb.get_red();
-    float dg = palette.colors[i].get_green() - rgb.get_green();
-    float db = palette.colors[i].get_blue()  - rgb.get_blue();
-    float dv = vPal-vPic;
-    float dist = dr * dr * 0.3 + dg * dg * 0.59 + db * db * 0.11 + dv * dv * 0.7;
-
-    if (dist &lt; bestDist) {
-      bestDist = dist;
-      best = i;
-    }
-  }
-
-  return best;
-}
-
-class NetPanzerFileStructImpl
-{
-public:
-  std::string id_header;
-  std::string name;
-  std::string description;
-  TilemapLayer tilemap; 
-  Tileset tileset;
-};
-
-std::string
-NetPanzerFileStruct::get_id_header()
-{
-  return impl-&gt;id_header;
-}
-
-std::string
-NetPanzerFileStruct::get_name()
-{
-  return impl-&gt;name;
-}
-
-std::string
-NetPanzerFileStruct::get_description()
-{
-  return impl-&gt;description;
-}
-
-TilemapLayer
-NetPanzerFileStruct::get_tilemap()
-{
-  return impl-&gt;tilemap;
-}
-
-void
-NetPanzerFileStruct::set_id_header(const std::string&amp; id)
-{
-  impl-&gt;id_header = id;
-}
-
-void
-NetPanzerFileStruct::set_name(const std::string&amp; name)
-{
-  impl-&gt;name = name;
-}
-
-void
-NetPanzerFileStruct::set_description(const std::string&amp; description)
-{
-  impl-&gt;description = description;
-}
-
-void
-NetPanzerFileStruct::set_tilemap(TilemapLayer l)
-{
-  impl-&gt;tilemap = l;
-}
-
-
-void
-NetPanzerFileStruct::save(const std::string&amp; filename)
-{
-  if (impl-&gt;tilemap.is_null())
-    return;
-    
-  unsigned char   netp_id_header[64];
-  strcpy(reinterpret_cast&lt;char*&gt;(netp_id_header), impl-&gt;id_header.c_str());
-  unsigned short  id       = 0; // ?
-  char   name[256];
-  strcpy(name, impl-&gt;name.c_str());
-  char   description[1024];
-  strcpy(description, impl-&gt;description.c_str());
-  unsigned short  x_size   = impl-&gt;tilemap.get_width();
-  unsigned short  y_size   = impl-&gt;tilemap.get_height();
-  char            tile_set[256] = &quot;summer12mb.tls&quot;;
- 
-  unsigned short  thumbnail_x_pix = impl-&gt;tilemap.get_width();
-  unsigned short  thumbnail_y_pix = impl-&gt;tilemap.get_height();
-    
-  std::ofstream out(filename.c_str());
-
-  // FIXME: Not endian clean
-  out.write(reinterpret_cast&lt;char*&gt;(&amp;netp_id_header), sizeof(netp_id_header));
-  out.write(reinterpret_cast&lt;char*&gt;(&amp;id), sizeof(short));
-  out.write(reinterpret_cast&lt;char*&gt;(&amp;name), sizeof(name));
-  out.write(reinterpret_cast&lt;char*&gt;(&amp;description), sizeof(description));
-  out.write(reinterpret_cast&lt;char*&gt;(&amp;x_size), sizeof(short));
-  out.write(reinterpret_cast&lt;char*&gt;(&amp;y_size), sizeof(short));
-  out.write(reinterpret_cast&lt;char*&gt;(&amp;tile_set), sizeof(tile_set));
-  out.write(reinterpret_cast&lt;char*&gt;(&amp;thumbnail_x_pix), sizeof(short));
-  out.write(reinterpret_cast&lt;char*&gt;(&amp;thumbnail_y_pix), sizeof(short));
-
-  std::vector&lt;unsigned short&gt; vec(x_size * y_size);
-
-  int tile_count = impl-&gt;tilemap.get_tileset().get_tiles().size();
-  Field&lt;int&gt;* field = impl-&gt;tilemap.get_field();
-  for(int i = 0; i &lt; x_size * y_size; ++i)
-    {
-      // Fill everything that isn't a valid tile with grass
-      if ((*field)[i] &gt;= 0 &amp;&amp; (*field)[i] &lt; tile_count)
-        vec[i] = (*field)[i];
-      else
-        vec[i] = 8097 + rand()%16;
-    }
-  out.write(reinterpret_cast&lt;char*&gt;(&amp;(*vec.begin())), 
-            sizeof(unsigned short)*vec.size());
-
-  // Generate thumbnail
-  std::vector&lt;unsigned char&gt; thumbnail(x_size * y_size);
-  for(int i = 0; i &lt; int(thumbnail.size()); ++i)
-    {
-      Tile* tile = impl-&gt;tileset.create((*field)[i]);
-      if (tile)
-        thumbnail[i] = find_nearest_color(NetPanzerData::instance()-&gt;get_palette(), tile-&gt;get_color());
-    }
-
-  out.write(reinterpret_cast&lt;char*&gt;(&amp;(*thumbnail.begin())), 
-            sizeof(unsigned char)*thumbnail.size());
-}
-
-NetPanzerFileStruct::NetPanzerFileStruct(Tileset tileset, int w, int h)
-  : impl(new NetPanzerFileStructImpl())
-{
-  impl-&gt;tileset = tileset;
-  impl-&gt;id_header = &quot;&lt;Id Header&gt;&quot;;
-  impl-&gt;name = &quot;&lt;Name&gt;&quot;;
-  impl-&gt;description = &quot;&lt;Description&gt;&quot;;
-  impl-&gt;tilemap = TilemapLayer(tileset, w, h);
-}
-
-NetPanzerFileStruct::NetPanzerFileStruct(Tileset tileset, const std::string&amp; filename)
-  : impl(new NetPanzerFileStructImpl())
-{
-  impl-&gt;tileset = tileset;
-  
-  // FIXME: endian issues
-  unsigned char   netp_id_header[64]; // Copyright PyroSoft Inc.
-  unsigned short  id; // What is this?
-  char            name[256];
-  char            description[1024];
-  unsigned short  x_size; // width
-  unsigned short  y_size; // height
-  char            tile_set[256]; // name of the tileset: &quot;summer12mb.tls&quot;
- 
-  unsigned short  thumbnail_x_pix;
-  unsigned short  thumbnail_y_pix;
-
-  std::ifstream file(filename.c_str());
-
-  if (!file)
-    {
-      std::cout &lt;&lt; &quot;NetPanzerFileStructImpl: Error: &quot; &lt;&lt; filename &lt;&lt; std::endl;
-    }
-
-  file.read(reinterpret_cast&lt;char*&gt;(&amp;netp_id_header), sizeof(netp_id_header));
-  file.read(reinterpret_cast&lt;char*&gt;(&amp;id), sizeof(short));
-  file.read(reinterpret_cast&lt;char*&gt;(&amp;name), sizeof(name));
-  file.read(reinterpret_cast&lt;char*&gt;(&amp;description), sizeof(description));
-  file.read(reinterpret_cast&lt;char*&gt;(&amp;x_size), sizeof(short));
-  file.read(reinterpret_cast&lt;char*&gt;(&amp;y_size), sizeof(short));
-  file.read(reinterpret_cast&lt;char*&gt;(&amp;tile_set), sizeof(tile_set));
-  file.read(reinterpret_cast&lt;char*&gt;(&amp;thumbnail_x_pix), sizeof(short));
-  file.read(reinterpret_cast&lt;char*&gt;(&amp;thumbnail_y_pix), sizeof(short));
-
-  TilemapLayer tilemap(tileset, x_size, y_size);
-  Field&lt;int&gt;* field      = tilemap.get_field();
-
-  std::vector&lt;unsigned short&gt; vec;
-  vec.resize(x_size * y_size);
-  file.read(reinterpret_cast&lt;char*&gt;(&amp;(*vec.begin())), sizeof(unsigned short)*vec.size());
-
-  for(int i = 0; i &lt; x_size*y_size; ++i)
-    (*field)[i] = vec[i];
-
-  std::cout &lt;&lt; &quot;Thumbnail: &quot; &lt;&lt; thumbnail_x_pix &lt;&lt; &quot; &quot; &lt;&lt; thumbnail_y_pix &lt;&lt; std::endl;
-
-  impl-&gt;tilemap     = tilemap;
-  impl-&gt;id_header   = reinterpret_cast&lt;char*&gt;(netp_id_header);
-  impl-&gt;name        = name;
-  impl-&gt;description = description;
-}
-
-/* EOF */

Copied: trunk/flexlay/netpanzer/netpanzer.hpp (from rev 712, trunk/flexlay/netpanzer/netpanzer.hxx)
===================================================================
--- trunk/flexlay/netpanzer/netpanzer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/netpanzer/netpanzer.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,128 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_SCRIPTING_NETPANZER_HXX
+#define HEADER_SCRIPTING_NETPANZER_HXX
+
+#include &lt;string&gt;
+#include &lt;ClanLib/Display/palette.h&gt;
+#include &lt;ClanLib/Display/surface.h&gt;
+#include &lt;ClanLib/Display/sprite.h&gt;
+#include &quot;../lib/tileset.hpp&quot;
+#include &quot;../lib/tilemap_layer.hpp&quot;
+#include &quot;../lib/shared_ptr.hpp&quot;
+
+void load_netpanzer_tileset(Tileset tileset, const char* filename);
+
+class NetPanzerFileStructImpl;
+
+struct NetPanzerTileHeader
+{
+public:
+  char	attrib;
+  char	move_value;
+  char	avg_color;
+};
+
+struct NetPanzerTileGroup
+{
+  int start;
+  int width;
+  int height;
+  
+  CL_Surface get_surface(); 
+
+private:
+  /** Surface holding the tilegroups image */
+  CL_Surface surface;
+};
+
+class NetPanzerData
+{
+private:
+  static NetPanzerData* instance_;
+public:
+  static NetPanzerData* instance() 
+  {
+    if (instance_)
+      return (instance_);
+    else
+      return (instance_ = new NetPanzerData());
+  }
+
+private:
+  std::string    datadir;
+  CL_Palette     palette;
+  Tileset        tileset;
+  unsigned char* tiledata;
+  typedef std::vector&lt;NetPanzerTileGroup&gt; TileGroups;
+  TileGroups tilegroups;
+  std::vector&lt;NetPanzerTileHeader&gt; tile_headers;
+public:
+  NetPanzerData();
+
+  /** Register a tilegroup, ie. a section of tiles that belong
+      together and form an building, lake, a section of trees, etc.
+
+      \param start the tile-id for the upper/left tile
+      \param width the width of tilegroup
+      \param height the height of the tilegroup
+  */
+  void register_tilegroup(int start, int width, int height);
+
+  void load_data(const std::string&amp; datadir_);
+  const CL_Palette&amp; get_palette() const;
+  const Tileset&amp;    get_tileset() const;
+  const std::vector&lt;NetPanzerTileHeader&gt;&amp; get_tile_headers() const;
+  unsigned char*    get_tiledata() const;
+
+  CL_Palette load_palette(const std::string&amp; filename);
+  CL_Sprite  get_tilegroup_sprite(int index);
+
+  /** Locate the tilegroup in which the tile with \a tileindex is
+      located */
+  NetPanzerTileGroup&amp; find_tilegroup(int tileindex);
+
+private:
+  void       load_tileset(const std::string&amp; filename);
+};
+
+class NetPanzerFileStruct
+{
+public:
+  NetPanzerFileStruct(Tileset tileset, int w, int h);
+  NetPanzerFileStruct(Tileset tileset, const std::string&amp; filename);
+
+  std::string get_id_header();
+  std::string get_name();
+  std::string get_description();
+  TilemapLayer get_tilemap(); 
+
+  void set_id_header(const std::string&amp; id);
+  void set_name(const std::string&amp; name);
+  void set_description(const std::string&amp; description);
+  void set_tilemap(TilemapLayer l); 
+
+  void save(const std::string&amp; filename);
+private:
+  SharedPtr&lt;NetPanzerFileStructImpl&gt; impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/netpanzer/netpanzer.hxx
===================================================================
--- trunk/flexlay/netpanzer/netpanzer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/netpanzer/netpanzer.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,128 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_SCRIPTING_NETPANZER_HXX
-#define HEADER_SCRIPTING_NETPANZER_HXX
-
-#include &lt;string&gt;
-#include &lt;ClanLib/Display/palette.h&gt;
-#include &lt;ClanLib/Display/surface.h&gt;
-#include &lt;ClanLib/Display/sprite.h&gt;
-#include &quot;../lib/tileset.hxx&quot;
-#include &quot;../lib/tilemap_layer.hxx&quot;
-#include &quot;../lib/shared_ptr.hxx&quot;
-
-void load_netpanzer_tileset(Tileset tileset, const char* filename);
-
-class NetPanzerFileStructImpl;
-
-struct NetPanzerTileHeader
-{
-public:
-  char	attrib;
-  char	move_value;
-  char	avg_color;
-};
-
-struct NetPanzerTileGroup
-{
-  int start;
-  int width;
-  int height;
-  
-  CL_Surface get_surface(); 
-
-private:
-  /** Surface holding the tilegroups image */
-  CL_Surface surface;
-};
-
-class NetPanzerData
-{
-private:
-  static NetPanzerData* instance_;
-public:
-  static NetPanzerData* instance() 
-  {
-    if (instance_)
-      return (instance_);
-    else
-      return (instance_ = new NetPanzerData());
-  }
-
-private:
-  std::string    datadir;
-  CL_Palette     palette;
-  Tileset        tileset;
-  unsigned char* tiledata;
-  typedef std::vector&lt;NetPanzerTileGroup&gt; TileGroups;
-  TileGroups tilegroups;
-  std::vector&lt;NetPanzerTileHeader&gt; tile_headers;
-public:
-  NetPanzerData();
-
-  /** Register a tilegroup, ie. a section of tiles that belong
-      together and form an building, lake, a section of trees, etc.
-
-      \param start the tile-id for the upper/left tile
-      \param width the width of tilegroup
-      \param height the height of the tilegroup
-  */
-  void register_tilegroup(int start, int width, int height);
-
-  void load_data(const std::string&amp; datadir_);
-  const CL_Palette&amp; get_palette() const;
-  const Tileset&amp;    get_tileset() const;
-  const std::vector&lt;NetPanzerTileHeader&gt;&amp; get_tile_headers() const;
-  unsigned char*    get_tiledata() const;
-
-  CL_Palette load_palette(const std::string&amp; filename);
-  CL_Sprite  get_tilegroup_sprite(int index);
-
-  /** Locate the tilegroup in which the tile with \a tileindex is
-      located */
-  NetPanzerTileGroup&amp; find_tilegroup(int tileindex);
-
-private:
-  void       load_tileset(const std::string&amp; filename);
-};
-
-class NetPanzerFileStruct
-{
-public:
-  NetPanzerFileStruct(Tileset tileset, int w, int h);
-  NetPanzerFileStruct(Tileset tileset, const std::string&amp; filename);
-
-  std::string get_id_header();
-  std::string get_name();
-  std::string get_description();
-  TilemapLayer get_tilemap(); 
-
-  void set_id_header(const std::string&amp; id);
-  void set_name(const std::string&amp; name);
-  void set_description(const std::string&amp; description);
-  void set_tilemap(TilemapLayer l); 
-
-  void save(const std::string&amp; filename);
-private:
-  SharedPtr&lt;NetPanzerFileStructImpl&gt; impl;
-};
-
-#endif
-
-/* EOF */

Modified: trunk/flexlay/netpanzer/netpanzer.i
===================================================================
--- trunk/flexlay/netpanzer/netpanzer.i	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/netpanzer/netpanzer.i	2009-11-22 03:02:03 UTC (rev 713)
@@ -5,11 +5,11 @@
 #include &lt;iostream&gt;
 #include &lt;ClanLib/Core/System/error.h&gt;
 #include &lt;ClanLib/Display/sprite.h&gt;
-#include &quot;netpanzer.hxx&quot;
+#include &quot;netpanzer.hpp&quot;
 %}
 
 %import  &quot;../lib/flexlay_wrap.i&quot;
-%include &quot;netpanzer.hxx&quot;
+%include &quot;netpanzer.hpp&quot;
 
 
 // EOF //

Modified: trunk/flexlay/ruby/SConscript
===================================================================
--- trunk/flexlay/ruby/SConscript	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/SConscript	2009-11-22 03:02:03 UTC (rev 713)
@@ -52,20 +52,20 @@
     return lst            
 
 #Depends('../lib/flexlay_wrap.i', gen_i_depends(Dir(&quot;../lib&quot;).abspath, File(&quot;../lib/flexlay_wrap.i&quot;).abspath))
-#env.Command('flexlay_ruby_wrap.cxx', '../lib/flexlay_wrap.i',
+#env.Command('flexlay_ruby_wrap.cpp', '../lib/flexlay_wrap.i',
 #            &quot;swig -c++ -ruby -o $TARGET $SOURCE&quot;)
 
 libflexlay_ruby_env = env.Clone()
 flexlay_ruby_lib = libflexlay_ruby_env.SharedLibrary(
     target = 'flexlay_wrap.so',
     source = [
-    env.CXXFile(target='flexlay_ruby_wrap.cxx', source='../lib/flexlay_wrap.i',
-      SWIGFLAGS=&quot;-ruby -c++&quot;, CXXFILESUFFIX=&quot;.cxx&quot;),
-    'ruby_functor.cxx',
-    'ruby_meta_data.cxx',
-    'ruby_sexpr_parser.cxx',
-    'ruby_object.cxx',
-    'ruby_converter.cxx'
+    env.CXXFile(target='flexlay_ruby_wrap.cpp', source='../lib/flexlay_wrap.i',
+      SWIGFLAGS=&quot;-ruby -c++&quot;, CXXFILESUFFIX=&quot;.cpp&quot;),
+    'ruby_functor.cpp',
+    'ruby_meta_data.cpp',
+    'ruby_sexpr_parser.cpp',
+    'ruby_object.cpp',
+    'ruby_converter.cpp'
     ],
     CPPPATH=[&quot;.&quot;,'$USER_CPPPATH','$RUBYDIR','../lib/'] + clanLib_env['CPPPATH'],
     LINKFLAGS = clanLib_env['LINKFLAGS'],

Copied: trunk/flexlay/ruby/flexlay_wrap.hpp (from rev 712, trunk/flexlay/ruby/flexlay_wrap.hxx)

Deleted: trunk/flexlay/ruby/flexlay_wrap.hxx
===================================================================
--- trunk/flexlay/ruby/flexlay_wrap.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/flexlay_wrap.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,49 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_FLEXLAY_WRAP_HXX
-#define HEADER_FLEXLAY_WRAP_HXX
-
-#include &lt;ClanLib/Display/color.h&gt;
-#include &lt;iostream&gt;
-#include &lt;typeinfo&gt;
-#include &quot;ruby.h&quot;
-
-class CL_Point;
-class CL_Pointf;
-class ObjectBrush;
-class ObjMapObject;
-
-template&lt;class C&gt;
-VALUE convert_to_ruby_value(const C&amp; c)
-{
-  std::cout &lt;&lt; &quot;Error: conversion for type '&quot; &lt;&lt; typeid(c).name() &lt;&lt; &quot;' missing&quot; &lt;&lt; std::endl;
-  return Qnil;
-}
-
-template&lt;&gt; VALUE convert_to_ruby_value&lt;ObjMapObject&gt;(const ObjMapObject&amp; arg);
-template&lt;&gt; VALUE convert_to_ruby_value&lt;ObjectBrush&gt;(const ObjectBrush&amp; arg);
-template&lt;&gt; VALUE convert_to_ruby_value&lt;CL_Color&gt;(const CL_Color&amp; arg);
-template&lt;&gt; VALUE convert_to_ruby_value&lt;CL_Point&gt;(const CL_Point&amp; arg);
-template&lt;&gt; VALUE convert_to_ruby_value&lt;CL_Pointf&gt;(const CL_Pointf&amp; arg);
-template&lt;&gt; VALUE convert_to_ruby_value&lt;int&gt;(const int&amp; arg);
-template&lt;&gt; VALUE convert_to_ruby_value&lt;float&gt;(const float&amp; arg);
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/ruby/ruby_converter.cpp (from rev 712, trunk/flexlay/ruby/ruby_converter.cxx)
===================================================================
--- trunk/flexlay/ruby/ruby_converter.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_converter.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,74 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_RUBY_CONVERTER_HXX
+#define HEADER_RUBY_CONVERTER_HXX
+
+#include &quot;flexlay_wrap.hpp&quot;
+
+// The following functions are defined in flexlay_wrap.i, a bit hacky but seems to work
+VALUE ObjMapObject2Value(const ObjMapObject&amp; arg);
+VALUE ObjectBrush2Value(const ObjectBrush&amp; arg);
+VALUE CL_Point2Value(const CL_Point&amp; arg);
+VALUE CL_Pointf2Value(const CL_Pointf&amp; arg);
+VALUE CL_Color2Value(const CL_Color&amp; arg);
+
+template&lt;&gt; VALUE convert_to_ruby_value&lt;float&gt;(const float&amp; arg)
+{
+  return rb_float_new(arg);
+}
+
+template&lt;&gt;
+VALUE convert_to_ruby_value&lt;ObjMapObject&gt;(const ObjMapObject&amp; arg)
+{
+  return ObjMapObject2Value(arg);
+}
+
+template&lt;&gt;
+VALUE convert_to_ruby_value&lt;ObjectBrush&gt;(const ObjectBrush&amp; arg)
+{
+  return ObjectBrush2Value(arg);
+}
+
+template&lt;&gt;
+VALUE convert_to_ruby_value&lt;CL_Color&gt;(const CL_Color&amp; arg)
+{
+  return CL_Color2Value(arg);
+}
+
+template&lt;&gt;
+VALUE convert_to_ruby_value&lt;CL_Point&gt;(const CL_Point&amp; arg)
+{
+  return CL_Point2Value(arg);
+}
+
+template&lt;&gt;
+VALUE convert_to_ruby_value&lt;CL_Pointf&gt;(const CL_Pointf&amp; arg)
+{
+  return CL_Pointf2Value(arg);
+}
+
+template&lt;&gt;
+VALUE convert_to_ruby_value&lt;int&gt;(const int&amp; arg)
+{
+  return INT2FIX(arg);
+}
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/ruby/ruby_converter.cxx
===================================================================
--- trunk/flexlay/ruby/ruby_converter.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_converter.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,74 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_RUBY_CONVERTER_HXX
-#define HEADER_RUBY_CONVERTER_HXX
-
-#include &quot;flexlay_wrap.hxx&quot;
-
-// The following functions are defined in flexlay_wrap.i, a bit hacky but seems to work
-VALUE ObjMapObject2Value(const ObjMapObject&amp; arg);
-VALUE ObjectBrush2Value(const ObjectBrush&amp; arg);
-VALUE CL_Point2Value(const CL_Point&amp; arg);
-VALUE CL_Pointf2Value(const CL_Pointf&amp; arg);
-VALUE CL_Color2Value(const CL_Color&amp; arg);
-
-template&lt;&gt; VALUE convert_to_ruby_value&lt;float&gt;(const float&amp; arg)
-{
-  return rb_float_new(arg);
-}
-
-template&lt;&gt;
-VALUE convert_to_ruby_value&lt;ObjMapObject&gt;(const ObjMapObject&amp; arg)
-{
-  return ObjMapObject2Value(arg);
-}
-
-template&lt;&gt;
-VALUE convert_to_ruby_value&lt;ObjectBrush&gt;(const ObjectBrush&amp; arg)
-{
-  return ObjectBrush2Value(arg);
-}
-
-template&lt;&gt;
-VALUE convert_to_ruby_value&lt;CL_Color&gt;(const CL_Color&amp; arg)
-{
-  return CL_Color2Value(arg);
-}
-
-template&lt;&gt;
-VALUE convert_to_ruby_value&lt;CL_Point&gt;(const CL_Point&amp; arg)
-{
-  return CL_Point2Value(arg);
-}
-
-template&lt;&gt;
-VALUE convert_to_ruby_value&lt;CL_Pointf&gt;(const CL_Pointf&amp; arg)
-{
-  return CL_Pointf2Value(arg);
-}
-
-template&lt;&gt;
-VALUE convert_to_ruby_value&lt;int&gt;(const int&amp; arg)
-{
-  return INT2FIX(arg);
-}
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/ruby/ruby_functor.cpp (from rev 712, trunk/flexlay/ruby/ruby_functor.cxx)
===================================================================
--- trunk/flexlay/ruby/ruby_functor.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_functor.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,110 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &quot;flexlay_wrap.hpp&quot;
+#include &quot;ruby_functor.hpp&quot;
+
+void
+RubyFunctor::print_error() 
+{
+  // FIXME: Potential memory leak
+  std::cout &lt;&lt; &quot;######################################################&quot; &lt;&lt; std::endl;
+  std::cout &lt;&lt; &quot;RubyException: &quot; 
+            &lt;&lt; rb_str2cstr(rb_inspect(ruby_errinfo), 0) 
+            &lt;&lt; std::endl;
+
+  VALUE trace = rb_funcall(ruby_errinfo, rb_intern(&quot;backtrace&quot;), 0);
+  for (int i = 0; i &lt; RARRAY(trace)-&gt;len; ++i)
+    std::cout &lt;&lt; rb_str2cstr(rb_ary_entry(trace, i), 0) &lt;&lt; std::endl;
+  std::cout &lt;&lt; &quot;######################################################&quot; &lt;&lt; std::endl;
+  ruby_errinfo = Qnil;
+}
+
+VALUE
+RubyFunctor::funcall_protect(VALUE self)
+{
+  return rb_funcall(reinterpret_cast&lt;RubyFunctor*&gt;(self)-&gt;val.ptr(), rb_intern(&quot;call&quot;), 0);
+}
+
+VALUE
+RubyFunctor::funcall_protect1(VALUE self)
+{
+  VALUE* args = reinterpret_cast&lt;VALUE*&gt;(self);
+  return rb_funcall(reinterpret_cast&lt;RubyFunctor*&gt;(args[0])-&gt;val.ptr(), rb_intern(&quot;call&quot;), 1,
+                    args[1]);
+}
+
+VALUE
+RubyFunctor::funcall_protect2(VALUE self)
+{
+  VALUE* args = reinterpret_cast&lt;VALUE*&gt;(self);
+  return rb_funcall(reinterpret_cast&lt;RubyFunctor*&gt;(args[0])-&gt;val.ptr(), rb_intern(&quot;call&quot;), 2,
+                    args[1], args[2]);
+}
+
+RubyFunctor::RubyFunctor(const RubyObject&amp; val_)
+  : val(val_)
+{
+}
+
+RubyFunctor::~RubyFunctor()
+{
+}
+
+void
+RubyFunctor::operator()()
+{
+  int state = 0;
+  rb_protect(&amp;RubyFunctor::funcall_protect, reinterpret_cast&lt;VALUE&gt;(this), &amp;state);
+  if (state)
+    print_error();
+}
+
+// FIXME: Protect the function calls with arguments too
+
+void
+RubyFunctor::operator()(int i)
+{
+  //rb_funcall(val.ptr(), rb_intern(&quot;call&quot;), 1, INT2FIX(i));
+  int state = 0;
+  VALUE args[2];
+  args[0] = reinterpret_cast&lt;VALUE&gt;(this);
+  args[1] = INT2FIX(i);
+  rb_protect(&amp;RubyFunctor::funcall_protect1, reinterpret_cast&lt;VALUE&gt;(args), &amp;state);
+
+  if (state)
+    print_error();
+}
+
+void
+RubyFunctor::operator()(int x, int y)
+{
+  //  rb_funcall(val.ptr(), rb_intern(&quot;call&quot;), 2, INT2FIX(x), INT2FIX(y));
+  int state = 0;
+  VALUE args[3];
+  args[0] = reinterpret_cast&lt;VALUE&gt;(this);
+  args[1] = INT2FIX(x);
+  args[2] = INT2FIX(y);
+  rb_protect(&amp;RubyFunctor::funcall_protect2, reinterpret_cast&lt;VALUE&gt;(args), &amp;state);
+
+  if (state)
+    print_error();
+}
+
+/* EOF */

Deleted: trunk/flexlay/ruby/ruby_functor.cxx
===================================================================
--- trunk/flexlay/ruby/ruby_functor.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_functor.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,110 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &quot;flexlay_wrap.hxx&quot;
-#include &quot;ruby_functor.hxx&quot;
-
-void
-RubyFunctor::print_error() 
-{
-  // FIXME: Potential memory leak
-  std::cout &lt;&lt; &quot;######################################################&quot; &lt;&lt; std::endl;
-  std::cout &lt;&lt; &quot;RubyException: &quot; 
-            &lt;&lt; rb_str2cstr(rb_inspect(ruby_errinfo), 0) 
-            &lt;&lt; std::endl;
-
-  VALUE trace = rb_funcall(ruby_errinfo, rb_intern(&quot;backtrace&quot;), 0);
-  for (int i = 0; i &lt; RARRAY(trace)-&gt;len; ++i)
-    std::cout &lt;&lt; rb_str2cstr(rb_ary_entry(trace, i), 0) &lt;&lt; std::endl;
-  std::cout &lt;&lt; &quot;######################################################&quot; &lt;&lt; std::endl;
-  ruby_errinfo = Qnil;
-}
-
-VALUE
-RubyFunctor::funcall_protect(VALUE self)
-{
-  return rb_funcall(reinterpret_cast&lt;RubyFunctor*&gt;(self)-&gt;val.ptr(), rb_intern(&quot;call&quot;), 0);
-}
-
-VALUE
-RubyFunctor::funcall_protect1(VALUE self)
-{
-  VALUE* args = reinterpret_cast&lt;VALUE*&gt;(self);
-  return rb_funcall(reinterpret_cast&lt;RubyFunctor*&gt;(args[0])-&gt;val.ptr(), rb_intern(&quot;call&quot;), 1,
-                    args[1]);
-}
-
-VALUE
-RubyFunctor::funcall_protect2(VALUE self)
-{
-  VALUE* args = reinterpret_cast&lt;VALUE*&gt;(self);
-  return rb_funcall(reinterpret_cast&lt;RubyFunctor*&gt;(args[0])-&gt;val.ptr(), rb_intern(&quot;call&quot;), 2,
-                    args[1], args[2]);
-}
-
-RubyFunctor::RubyFunctor(const RubyObject&amp; val_)
-  : val(val_)
-{
-}
-
-RubyFunctor::~RubyFunctor()
-{
-}
-
-void
-RubyFunctor::operator()()
-{
-  int state = 0;
-  rb_protect(&amp;RubyFunctor::funcall_protect, reinterpret_cast&lt;VALUE&gt;(this), &amp;state);
-  if (state)
-    print_error();
-}
-
-// FIXME: Protect the function calls with arguments too
-
-void
-RubyFunctor::operator()(int i)
-{
-  //rb_funcall(val.ptr(), rb_intern(&quot;call&quot;), 1, INT2FIX(i));
-  int state = 0;
-  VALUE args[2];
-  args[0] = reinterpret_cast&lt;VALUE&gt;(this);
-  args[1] = INT2FIX(i);
-  rb_protect(&amp;RubyFunctor::funcall_protect1, reinterpret_cast&lt;VALUE&gt;(args), &amp;state);
-
-  if (state)
-    print_error();
-}
-
-void
-RubyFunctor::operator()(int x, int y)
-{
-  //  rb_funcall(val.ptr(), rb_intern(&quot;call&quot;), 2, INT2FIX(x), INT2FIX(y));
-  int state = 0;
-  VALUE args[3];
-  args[0] = reinterpret_cast&lt;VALUE&gt;(this);
-  args[1] = INT2FIX(x);
-  args[2] = INT2FIX(y);
-  rb_protect(&amp;RubyFunctor::funcall_protect2, reinterpret_cast&lt;VALUE&gt;(args), &amp;state);
-
-  if (state)
-    print_error();
-}
-
-/* EOF */

Copied: trunk/flexlay/ruby/ruby_functor.hpp (from rev 712, trunk/flexlay/ruby/ruby_functor.hxx)
===================================================================
--- trunk/flexlay/ruby/ruby_functor.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_functor.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,89 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_RUBY_FUNCTOR_HXX
+#define HEADER_RUBY_FUNCTOR_HXX
+
+#include &lt;iostream&gt;
+#include &quot;ruby.h&quot;
+#include &quot;ruby_object.hpp&quot;
+#include &quot;flexlay_wrap.hpp&quot;
+
+/** */
+class RubyFunctor
+{
+private:
+  RubyObject val;
+
+public:
+  RubyFunctor(const RubyObject&amp; val_);  
+  ~RubyFunctor();
+
+  void operator()();
+  void operator()(int i);
+  void operator()(int x, int y);
+
+  /** Print backtrace in case of error */
+  static void print_error();
+
+  // FIXME: Protect these function calls somehow
+  template&lt;class C&gt; void operator()(const C&amp; c)
+  {
+    if (1) {
+      rb_funcall(val.ptr(), rb_intern(&quot;call&quot;), 1,
+                 convert_to_ruby_value(c));
+    } else {
+      //VALUE arg1 = convert_to_ruby_value(c);
+      //rb_funcall(val.ptr(), rb_intern(&quot;call&quot;), 1, arg1);
+      int state = 0;
+      VALUE args[2];
+      args[0] = reinterpret_cast&lt;VALUE&gt;(this);
+      args[1] = convert_to_ruby_value(c);
+      rb_protect(&amp;RubyFunctor::funcall_protect1, reinterpret_cast&lt;VALUE&gt;(args), &amp;state);
+      if (state)
+        print_error();
+    }
+  }
+
+  template&lt;class C, class D&gt; void operator()(const C&amp; c, const D&amp; d)
+  {
+    if (1) {
+      rb_funcall(val.ptr(), rb_intern(&quot;call&quot;), 2,
+                 convert_to_ruby_value(c),
+                 convert_to_ruby_value(d));
+    } else {
+      std::cout &lt;&lt; &quot;Calling operator() with two args&quot; &lt;&lt; std::endl;
+      int state = 0;
+      VALUE args[2];
+      args[0] = reinterpret_cast&lt;VALUE&gt;(this);
+      args[1] = convert_to_ruby_value(c);
+      args[2] = convert_to_ruby_value(d);
+      rb_protect(&amp;RubyFunctor::funcall_protect2, reinterpret_cast&lt;VALUE&gt;(args), &amp;state);
+      if (state)
+        print_error();
+    }
+  }
+  
+  static VALUE funcall_protect(VALUE self);
+  static VALUE funcall_protect1(VALUE self);
+  static VALUE funcall_protect2(VALUE self);
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/ruby/ruby_functor.hxx
===================================================================
--- trunk/flexlay/ruby/ruby_functor.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_functor.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,89 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_RUBY_FUNCTOR_HXX
-#define HEADER_RUBY_FUNCTOR_HXX
-
-#include &lt;iostream&gt;
-#include &quot;ruby.h&quot;
-#include &quot;ruby_object.hxx&quot;
-#include &quot;flexlay_wrap.hxx&quot;
-
-/** */
-class RubyFunctor
-{
-private:
-  RubyObject val;
-
-public:
-  RubyFunctor(const RubyObject&amp; val_);  
-  ~RubyFunctor();
-
-  void operator()();
-  void operator()(int i);
-  void operator()(int x, int y);
-
-  /** Print backtrace in case of error */
-  static void print_error();
-
-  // FIXME: Protect these function calls somehow
-  template&lt;class C&gt; void operator()(const C&amp; c)
-  {
-    if (1) {
-      rb_funcall(val.ptr(), rb_intern(&quot;call&quot;), 1,
-                 convert_to_ruby_value(c));
-    } else {
-      //VALUE arg1 = convert_to_ruby_value(c);
-      //rb_funcall(val.ptr(), rb_intern(&quot;call&quot;), 1, arg1);
-      int state = 0;
-      VALUE args[2];
-      args[0] = reinterpret_cast&lt;VALUE&gt;(this);
-      args[1] = convert_to_ruby_value(c);
-      rb_protect(&amp;RubyFunctor::funcall_protect1, reinterpret_cast&lt;VALUE&gt;(args), &amp;state);
-      if (state)
-        print_error();
-    }
-  }
-
-  template&lt;class C, class D&gt; void operator()(const C&amp; c, const D&amp; d)
-  {
-    if (1) {
-      rb_funcall(val.ptr(), rb_intern(&quot;call&quot;), 2,
-                 convert_to_ruby_value(c),
-                 convert_to_ruby_value(d));
-    } else {
-      std::cout &lt;&lt; &quot;Calling operator() with two args&quot; &lt;&lt; std::endl;
-      int state = 0;
-      VALUE args[2];
-      args[0] = reinterpret_cast&lt;VALUE&gt;(this);
-      args[1] = convert_to_ruby_value(c);
-      args[2] = convert_to_ruby_value(d);
-      rb_protect(&amp;RubyFunctor::funcall_protect2, reinterpret_cast&lt;VALUE&gt;(args), &amp;state);
-      if (state)
-        print_error();
-    }
-  }
-  
-  static VALUE funcall_protect(VALUE self);
-  static VALUE funcall_protect1(VALUE self);
-  static VALUE funcall_protect2(VALUE self);
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/ruby/ruby_meta_data.cpp (from rev 712, trunk/flexlay/ruby/ruby_meta_data.cxx)
===================================================================
--- trunk/flexlay/ruby/ruby_meta_data.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_meta_data.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,95 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &lt;iostream&gt;
+#include &lt;ClanLib/Signals/signal_v0.h&gt;
+#include &quot;ruby_object.hpp&quot;
+#include &quot;meta_data_impl.hpp&quot;
+#include &quot;ruby_functor.hpp&quot;
+#include &quot;ruby_meta_data.hpp&quot;
+
+typedef MetaDataGeneric&lt;RubyObject&gt; RubyMetaData;
+
+MetaData  make_metadata(VALUE obj)
+{
+  return MetaData(SharedPtr&lt;MetaDataImpl&gt;(new RubyMetaData(RubyObject(obj))));
+}
+
+VALUE get_ruby_object(const MetaData&amp; data_obj)
+{
+  MetaDataImpl* data = data_obj.get_impl().get();
+
+  if (data)
+    {
+      RubyMetaData* rbdata = dynamic_cast&lt;RubyMetaData*&gt;(data);
+      if (rbdata)
+        {
+          return rbdata-&gt;data.ptr();
+        }
+    }
+  return Qnil;
+}
+
+void connect(CL_Signal_v0&amp; sig, VALUE obj)
+{
+  sig = CL_Signal_v0();
+  new CL_Slot(sig.connect_functor(RubyFunctor(obj)));
+}
+
+void connect_v1_float(CL_Signal_v1&lt;float&gt;&amp; sig, VALUE obj)
+{
+  sig = CL_Signal_v1&lt;float&gt;();
+  new CL_Slot(sig.connect_functor(RubyFunctor(obj)));
+}
+
+void connect_v1(CL_Signal_v1&lt;int&gt;&amp; sig, VALUE obj)
+{
+  sig = CL_Signal_v1&lt;int&gt;();
+  new CL_Slot(sig.connect_functor(RubyFunctor(obj)));
+}
+
+void connect_v2(CL_Signal_v2&lt;int, int&gt;&amp; sig, VALUE obj)
+{
+  sig = CL_Signal_v2&lt;int, int&gt;();
+  new CL_Slot(sig.connect_functor(RubyFunctor(obj)));
+}
+
+void connect_v2_graceful(CL_Signal_v2&lt;int, int&gt;&amp; sig, VALUE obj)
+{
+  new CL_Slot(sig.connect_functor(RubyFunctor(obj)));
+}
+
+void connect_v1_Color(CL_Signal_v1&lt;CL_Color&gt;&amp; sig, VALUE func)
+{
+  sig = CL_Signal_v1&lt;CL_Color&gt;();
+  new CL_Slot(sig.connect_functor(RubyFunctor(func)));
+}
+
+void connect_v1_ObjMapObject(CL_Signal_v1&lt;ObjMapObject&gt;&amp; sig, VALUE func)
+{
+  sig = CL_Signal_v1&lt;ObjMapObject&gt;();
+  new CL_Slot(sig.connect_functor(RubyFunctor(func)));
+}
+
+void connect_v2_ObjectBrush_Point(CL_Signal_v2&lt;ObjectBrush, CL_Point&gt;&amp; sig, VALUE func)
+{
+  sig = CL_Signal_v2&lt;ObjectBrush, CL_Point&gt;();
+  new CL_Slot(sig.connect_functor(RubyFunctor(func)));
+}
+
+/* EOF */

Deleted: trunk/flexlay/ruby/ruby_meta_data.cxx
===================================================================
--- trunk/flexlay/ruby/ruby_meta_data.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_meta_data.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,95 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &lt;iostream&gt;
-#include &lt;ClanLib/Signals/signal_v0.h&gt;
-#include &quot;ruby_object.hxx&quot;
-#include &quot;meta_data_impl.hxx&quot;
-#include &quot;ruby_functor.hxx&quot;
-#include &quot;ruby_meta_data.hxx&quot;
-
-typedef MetaDataGeneric&lt;RubyObject&gt; RubyMetaData;
-
-MetaData  make_metadata(VALUE obj)
-{
-  return MetaData(SharedPtr&lt;MetaDataImpl&gt;(new RubyMetaData(RubyObject(obj))));
-}
-
-VALUE get_ruby_object(const MetaData&amp; data_obj)
-{
-  MetaDataImpl* data = data_obj.get_impl().get();
-
-  if (data)
-    {
-      RubyMetaData* rbdata = dynamic_cast&lt;RubyMetaData*&gt;(data);
-      if (rbdata)
-        {
-          return rbdata-&gt;data.ptr();
-        }
-    }
-  return Qnil;
-}
-
-void connect(CL_Signal_v0&amp; sig, VALUE obj)
-{
-  sig = CL_Signal_v0();
-  new CL_Slot(sig.connect_functor(RubyFunctor(obj)));
-}
-
-void connect_v1_float(CL_Signal_v1&lt;float&gt;&amp; sig, VALUE obj)
-{
-  sig = CL_Signal_v1&lt;float&gt;();
-  new CL_Slot(sig.connect_functor(RubyFunctor(obj)));
-}
-
-void connect_v1(CL_Signal_v1&lt;int&gt;&amp; sig, VALUE obj)
-{
-  sig = CL_Signal_v1&lt;int&gt;();
-  new CL_Slot(sig.connect_functor(RubyFunctor(obj)));
-}
-
-void connect_v2(CL_Signal_v2&lt;int, int&gt;&amp; sig, VALUE obj)
-{
-  sig = CL_Signal_v2&lt;int, int&gt;();
-  new CL_Slot(sig.connect_functor(RubyFunctor(obj)));
-}
-
-void connect_v2_graceful(CL_Signal_v2&lt;int, int&gt;&amp; sig, VALUE obj)
-{
-  new CL_Slot(sig.connect_functor(RubyFunctor(obj)));
-}
-
-void connect_v1_Color(CL_Signal_v1&lt;CL_Color&gt;&amp; sig, VALUE func)
-{
-  sig = CL_Signal_v1&lt;CL_Color&gt;();
-  new CL_Slot(sig.connect_functor(RubyFunctor(func)));
-}
-
-void connect_v1_ObjMapObject(CL_Signal_v1&lt;ObjMapObject&gt;&amp; sig, VALUE func)
-{
-  sig = CL_Signal_v1&lt;ObjMapObject&gt;();
-  new CL_Slot(sig.connect_functor(RubyFunctor(func)));
-}
-
-void connect_v2_ObjectBrush_Point(CL_Signal_v2&lt;ObjectBrush, CL_Point&gt;&amp; sig, VALUE func)
-{
-  sig = CL_Signal_v2&lt;ObjectBrush, CL_Point&gt;();
-  new CL_Slot(sig.connect_functor(RubyFunctor(func)));
-}
-
-/* EOF */

Copied: trunk/flexlay/ruby/ruby_meta_data.hpp (from rev 712, trunk/flexlay/ruby/ruby_meta_data.hxx)
===================================================================
--- trunk/flexlay/ruby/ruby_meta_data.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_meta_data.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,44 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#ifndef HEADER_RUBY_META_DATA_HXX
+#define HEADER_RUBY_META_DATA_HXX
+
+#include &lt;ClanLib/signals.h&gt;
+#include &lt;ClanLib/Display/color.h&gt;
+#include &quot;ruby.h&quot;
+#include &quot;meta_data.hpp&quot;
+#include &quot;objmap_object.hpp&quot;
+#include &quot;object_brush.hpp&quot;
+
+MetaData  make_metadata(VALUE obj);
+VALUE get_ruby_object(const MetaData&amp; data);
+
+void connect(CL_Signal_v0&amp; sig, VALUE obj);
+void connect_v1(CL_Signal_v1&lt;int&gt;&amp; sig, VALUE obj);
+void connect_v1_float(CL_Signal_v1&lt;float&gt;&amp; sig, VALUE obj);
+void connect_v2(CL_Signal_v2&lt;int, int&gt;&amp; sig, VALUE obj);
+void connect_v2_graceful(CL_Signal_v2&lt;int, int&gt;&amp; sig, VALUE obj);
+
+void connect_v1_Color(CL_Signal_v1&lt;CL_Color&gt;&amp; sig, VALUE func);
+void connect_v1_ObjMapObject(CL_Signal_v1&lt;ObjMapObject&gt;&amp; sig, VALUE func);
+void connect_v2_ObjectBrush_Point(CL_Signal_v2&lt;ObjectBrush, CL_Point&gt;&amp; sig, VALUE func);
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/ruby/ruby_meta_data.hxx
===================================================================
--- trunk/flexlay/ruby/ruby_meta_data.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_meta_data.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,44 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_RUBY_META_DATA_HXX
-#define HEADER_RUBY_META_DATA_HXX
-
-#include &lt;ClanLib/signals.h&gt;
-#include &lt;ClanLib/Display/color.h&gt;
-#include &quot;ruby.h&quot;
-#include &quot;meta_data.hxx&quot;
-#include &quot;objmap_object.hxx&quot;
-#include &quot;object_brush.hxx&quot;
-
-MetaData  make_metadata(VALUE obj);
-VALUE get_ruby_object(const MetaData&amp; data);
-
-void connect(CL_Signal_v0&amp; sig, VALUE obj);
-void connect_v1(CL_Signal_v1&lt;int&gt;&amp; sig, VALUE obj);
-void connect_v1_float(CL_Signal_v1&lt;float&gt;&amp; sig, VALUE obj);
-void connect_v2(CL_Signal_v2&lt;int, int&gt;&amp; sig, VALUE obj);
-void connect_v2_graceful(CL_Signal_v2&lt;int, int&gt;&amp; sig, VALUE obj);
-
-void connect_v1_Color(CL_Signal_v1&lt;CL_Color&gt;&amp; sig, VALUE func);
-void connect_v1_ObjMapObject(CL_Signal_v1&lt;ObjMapObject&gt;&amp; sig, VALUE func);
-void connect_v2_ObjectBrush_Point(CL_Signal_v2&lt;ObjectBrush, CL_Point&gt;&amp; sig, VALUE func);
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/ruby/ruby_object.cpp (from rev 712, trunk/flexlay/ruby/ruby_object.cxx)
===================================================================
--- trunk/flexlay/ruby/ruby_object.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_object.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,56 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &quot;ruby_object.hpp&quot;
+
+RubyObject::RubyObject(VALUE val_)
+  : val(val_)
+{
+  rb_gc_register_address(&amp;val);
+}
+
+RubyObject::RubyObject(const RubyObject&amp; copy)
+  : val(copy.val)
+{
+  rb_gc_register_address(&amp;val);
+}
+
+RubyObject&amp;
+RubyObject::operator= (const RubyObject&amp; copy)
+{
+  if (this != &amp;copy)
+    {
+      rb_gc_unregister_address(&amp;val);
+      val = copy.val;
+      rb_gc_register_address(&amp;val);
+    }
+  return *this;
+}
+
+RubyObject::~RubyObject()
+{
+  rb_gc_unregister_address(&amp;val);
+}
+
+VALUE
+RubyObject::ptr() 
+{
+  return val; 
+}
+
+/* EOF */

Deleted: trunk/flexlay/ruby/ruby_object.cxx
===================================================================
--- trunk/flexlay/ruby/ruby_object.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_object.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,56 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &quot;ruby_object.hxx&quot;
-
-RubyObject::RubyObject(VALUE val_)
-  : val(val_)
-{
-  rb_gc_register_address(&amp;val);
-}
-
-RubyObject::RubyObject(const RubyObject&amp; copy)
-  : val(copy.val)
-{
-  rb_gc_register_address(&amp;val);
-}
-
-RubyObject&amp;
-RubyObject::operator= (const RubyObject&amp; copy)
-{
-  if (this != &amp;copy)
-    {
-      rb_gc_unregister_address(&amp;val);
-      val = copy.val;
-      rb_gc_register_address(&amp;val);
-    }
-  return *this;
-}
-
-RubyObject::~RubyObject()
-{
-  rb_gc_unregister_address(&amp;val);
-}
-
-VALUE
-RubyObject::ptr() 
-{
-  return val; 
-}
-
-/* EOF */

Copied: trunk/flexlay/ruby/ruby_object.hpp (from rev 712, trunk/flexlay/ruby/ruby_object.hxx)

Deleted: trunk/flexlay/ruby/ruby_object.hxx
===================================================================
--- trunk/flexlay/ruby/ruby_object.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_object.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,41 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_RUBY_OBJECT_HXX
-#define HEADER_RUBY_OBJECT_HXX
-
-#include &quot;ruby.h&quot;
-
-/** */
-class RubyObject
-{
-private:
-  VALUE val;
-
-public:
-  RubyObject(VALUE val_);
-  RubyObject(const RubyObject&amp;);
-  RubyObject&amp; operator= (const RubyObject&amp;);
-  ~RubyObject();
-  
-  VALUE ptr();
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/ruby/ruby_sexpr_parser.cpp (from rev 712, trunk/flexlay/ruby/ruby_sexpr_parser.cxx)
===================================================================
--- trunk/flexlay/ruby/ruby_sexpr_parser.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_sexpr_parser.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,82 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+#include &quot;lispreader.hpp&quot;
+#include &quot;ruby_sexpr_parser.hpp&quot;
+
+VALUE
+build_py_sexpr(lisp_object_t* cur)
+{
+  if (lisp_cons_p(cur))
+    {
+      VALUE lst = rb_ary_new();
+  
+      while (cur)
+        {
+          rb_ary_push(lst, build_py_sexpr(lisp_car(cur)));
+          cur = lisp_cdr(cur);
+        }
+      
+      return lst;
+    }
+  else if (lisp_string_p(cur))
+    {
+      return rb_str_new2(lisp_string(cur));
+    }
+  else if (lisp_symbol_p(cur))
+    {
+      return ID2SYM(rb_intern(lisp_symbol(cur)));
+    }
+  else if (lisp_integer_p(cur))
+    {
+      return INT2NUM(lisp_integer(cur));
+    }
+  else if (lisp_real_p(cur))
+    {
+      return rb_float_new(lisp_real(cur));
+    }
+  else if (lisp_boolean_p(cur))
+    {
+      if (lisp_boolean(cur))
+        return Qtrue;
+      else
+        return Qfalse;
+    }
+  else
+    {
+      return Qnil;
+    }
+}
+
+VALUE sexpr_read_from_file(const char* filename)
+{
+  lisp_object_t* cur = lisp_read_from_file(filename);
+
+  if (cur)
+    {
+      VALUE obj = build_py_sexpr(cur);
+      lisp_free(cur);
+      return obj;
+    }
+  else
+    {
+      return Qnil;
+    }
+}
+
+/* EOF */

Deleted: trunk/flexlay/ruby/ruby_sexpr_parser.cxx
===================================================================
--- trunk/flexlay/ruby/ruby_sexpr_parser.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_sexpr_parser.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,82 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#include &quot;lispreader.hxx&quot;
-#include &quot;ruby_sexpr_parser.hxx&quot;
-
-VALUE
-build_py_sexpr(lisp_object_t* cur)
-{
-  if (lisp_cons_p(cur))
-    {
-      VALUE lst = rb_ary_new();
-  
-      while (cur)
-        {
-          rb_ary_push(lst, build_py_sexpr(lisp_car(cur)));
-          cur = lisp_cdr(cur);
-        }
-      
-      return lst;
-    }
-  else if (lisp_string_p(cur))
-    {
-      return rb_str_new2(lisp_string(cur));
-    }
-  else if (lisp_symbol_p(cur))
-    {
-      return ID2SYM(rb_intern(lisp_symbol(cur)));
-    }
-  else if (lisp_integer_p(cur))
-    {
-      return INT2NUM(lisp_integer(cur));
-    }
-  else if (lisp_real_p(cur))
-    {
-      return rb_float_new(lisp_real(cur));
-    }
-  else if (lisp_boolean_p(cur))
-    {
-      if (lisp_boolean(cur))
-        return Qtrue;
-      else
-        return Qfalse;
-    }
-  else
-    {
-      return Qnil;
-    }
-}
-
-VALUE sexpr_read_from_file(const char* filename)
-{
-  lisp_object_t* cur = lisp_read_from_file(filename);
-
-  if (cur)
-    {
-      VALUE obj = build_py_sexpr(cur);
-      lisp_free(cur);
-      return obj;
-    }
-  else
-    {
-      return Qnil;
-    }
-}
-
-/* EOF */

Copied: trunk/flexlay/ruby/ruby_sexpr_parser.hpp (from rev 712, trunk/flexlay/ruby/ruby_sexpr_parser.hxx)

Deleted: trunk/flexlay/ruby/ruby_sexpr_parser.hxx
===================================================================
--- trunk/flexlay/ruby/ruby_sexpr_parser.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_sexpr_parser.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,28 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-
-#ifndef HEADER_RUBY_SEXPR_PARSER_HXX
-#define HEADER_RUBY_SEXPR_PARSER_HXX
-
-#include &quot;ruby.h&quot;
-
-VALUE sexpr_read_from_file(const char* filename);
-
-#endif
-
-/* EOF */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000206.html">[Flexlay-commit] r714 - in trunk/flexlay/lib: . tools
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#220">[ date ]</a>
              <a href="thread.html#220">[ thread ]</a>
              <a href="subject.html#220">[ subject ]</a>
              <a href="author.html#220">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/flexlay-commit">More information about the Flexlay-commit
mailing list</a><br>
</body></html>
