<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Flexlay-commit] r715 - in trunk/flexlay/lib: . tools
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/flexlay-commit/2009-November/index.html" >
   <LINK REL="made" HREF="mailto:flexlay-commit%40lists.berlios.de?Subject=Re%3A%20%5BFlexlay-commit%5D%20r715%20-%20in%20trunk/flexlay/lib%3A%20.%20tools&In-Reply-To=%3C200911220308.nAM382BL021385%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000206.html">
   <LINK REL="Next"  HREF="000208.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Flexlay-commit] r715 - in trunk/flexlay/lib: . tools</H1>
    <B>grumbel at BerliOS</B> 
    <A HREF="mailto:flexlay-commit%40lists.berlios.de?Subject=Re%3A%20%5BFlexlay-commit%5D%20r715%20-%20in%20trunk/flexlay/lib%3A%20.%20tools&In-Reply-To=%3C200911220308.nAM382BL021385%40sheep.berlios.de%3E"
       TITLE="[Flexlay-commit] r715 - in trunk/flexlay/lib: . tools">grumbel at mail.berlios.de
       </A><BR>
    <I>Sun Nov 22 04:08:02 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000206.html">[Flexlay-commit] r714 - in trunk/flexlay/lib: . tools
</A></li>
        <LI>Next message: <A HREF="000208.html">[Flexlay-commit] r716 - in trunk/flexlay: . external	external/clanlib/GL external/clanlib/GL/GLX lib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#207">[ date ]</a>
              <a href="thread.html#207">[ thread ]</a>
              <a href="subject.html#207">[ subject ]</a>
              <a href="author.html#207">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: grumbel
Date: 2009-11-22 04:07:59 +0100 (Sun, 22 Nov 2009)
New Revision: 715

Modified:
   trunk/flexlay/lib/bitmap_layer.cpp
   trunk/flexlay/lib/blitter.cpp
   trunk/flexlay/lib/brushmask.cpp
   trunk/flexlay/lib/colorpicker.cpp
   trunk/flexlay/lib/console.cpp
   trunk/flexlay/lib/directory_view.cpp
   trunk/flexlay/lib/editor_map.cpp
   trunk/flexlay/lib/editor_map_component.cpp
   trunk/flexlay/lib/field.hpp
   trunk/flexlay/lib/flexlay.cpp
   trunk/flexlay/lib/flexlay.hpp
   trunk/flexlay/lib/generated_brush.cpp
   trunk/flexlay/lib/graphic_context_state.cpp
   trunk/flexlay/lib/helper.cpp
   trunk/flexlay/lib/icon.cpp
   trunk/flexlay/lib/layer.cpp
   trunk/flexlay/lib/lispreader.cpp
   trunk/flexlay/lib/lispreader.hpp
   trunk/flexlay/lib/marker_stroke_drawer.cpp
   trunk/flexlay/lib/menu.cpp
   trunk/flexlay/lib/minimap.cpp
   trunk/flexlay/lib/object_add_command.cpp
   trunk/flexlay/lib/object_delete_command.cpp
   trunk/flexlay/lib/object_layer.cpp
   trunk/flexlay/lib/object_move_command.cpp
   trunk/flexlay/lib/object_selector.cpp
   trunk/flexlay/lib/objmap_object.cpp
   trunk/flexlay/lib/objmap_path_node.cpp
   trunk/flexlay/lib/objmap_rect_object.cpp
   trunk/flexlay/lib/objmap_sprite_object.cpp
   trunk/flexlay/lib/onion_skin_layer.cpp
   trunk/flexlay/lib/paint_command.cpp
   trunk/flexlay/lib/popup_menu.cpp
   trunk/flexlay/lib/scrollbar.cpp
   trunk/flexlay/lib/shared_ptr_comp.hpp
   trunk/flexlay/lib/sketch_layer.cpp
   trunk/flexlay/lib/slider.cpp
   trunk/flexlay/lib/sprite_stroke_drawer.cpp
   trunk/flexlay/lib/stroke.cpp
   trunk/flexlay/lib/tile.cpp
   trunk/flexlay/lib/tile_brush.cpp
   trunk/flexlay/lib/tile_editor.cpp
   trunk/flexlay/lib/tile_selection.cpp
   trunk/flexlay/lib/tile_selector.cpp
   trunk/flexlay/lib/tilemap_layer.cpp
   trunk/flexlay/lib/tilemap_layer.hpp
   trunk/flexlay/lib/tileset.cpp
   trunk/flexlay/lib/titlebar.cpp
   trunk/flexlay/lib/tools/layer_move_tool.cpp
   trunk/flexlay/lib/tools/objmap_select_tool.cpp
   trunk/flexlay/lib/tools/sketch_stroke_tool.cpp
   trunk/flexlay/lib/tools/tilemap_paint_tool.cpp
   trunk/flexlay/lib/tools/tilemap_select_tool.cpp
   trunk/flexlay/lib/tools/workspace_move_tool.cpp
   trunk/flexlay/lib/tools/zoom2_tool.cpp
   trunk/flexlay/lib/tools/zoom_tool.cpp
   trunk/flexlay/lib/window.cpp
   trunk/flexlay/lib/workspace.cpp
Log:
Switched indention style

Modified: trunk/flexlay/lib/bitmap_layer.cpp
===================================================================
--- trunk/flexlay/lib/bitmap_layer.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/bitmap_layer.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -145,13 +145,13 @@
 BitmapLayer::add_stroke(const Stroke&amp; stroke)
 {
   if (stroke.get_dab_count() &gt; 0)
-    {
-      impl-&gt;strokes.push_back(stroke);
-      stroke.draw(impl-&gt;canvas-&gt;get_gc());
-      // FIXME: doesn't sync when manually manipulating the canvas
-      impl-&gt;canvas-&gt;get_gc()-&gt;flush();
-      impl-&gt;canvas-&gt;sync_surface();
-    }
+  {
+    impl-&gt;strokes.push_back(stroke);
+    stroke.draw(impl-&gt;canvas-&gt;get_gc());
+    // FIXME: doesn't sync when manually manipulating the canvas
+    impl-&gt;canvas-&gt;get_gc()-&gt;flush();
+    impl-&gt;canvas-&gt;sync_surface();
+  }
 }
 
 std::vector&lt;Stroke&gt;

Modified: trunk/flexlay/lib/blitter.cpp
===================================================================
--- trunk/flexlay/lib/blitter.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/blitter.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -40,59 +40,59 @@
   int brush_pitch  = brush.get_pitch();
 
   if (brush.get_format().get_type() == pixelformat_rgba)
+  {
+    if (brush.get_format().get_depth() == 32)
     {
-      if (brush.get_format().get_depth() == 32)
+      for (int y = start_y; y &lt; end_y; ++y)
+        for (int x = start_x; x &lt; end_x; ++x)
         {
-          for (int y = start_y; y &lt; end_y; ++y)
-            for (int x = start_x; x &lt; end_x; ++x)
-              {
-                int target_pos = (y + y_pos) * target_pitch + 4*(x + x_pos);
-                int brush_pos  = y * brush_pitch + x*4;
+          int target_pos = (y + y_pos) * target_pitch + 4*(x + x_pos);
+          int brush_pos  = y * brush_pitch + x*4;
 
-                target_buf[target_pos + 0] = brush_buf[brush_pos + 0];
-                target_buf[target_pos + 1] = brush_buf[brush_pos + 1];
-                target_buf[target_pos + 2] = brush_buf[brush_pos + 2];
-                target_buf[target_pos + 3] = brush_buf[brush_pos + 3];
-              } 
-        }
-      else if (brush.get_format().get_depth() == 24)
+          target_buf[target_pos + 0] = brush_buf[brush_pos + 0];
+          target_buf[target_pos + 1] = brush_buf[brush_pos + 1];
+          target_buf[target_pos + 2] = brush_buf[brush_pos + 2];
+          target_buf[target_pos + 3] = brush_buf[brush_pos + 3];
+        } 
+    }
+    else if (brush.get_format().get_depth() == 24)
+    {
+      for (int y = start_y; y &lt; end_y; ++y)
+        for (int x = start_x; x &lt; end_x; ++x)
         {
-          for (int y = start_y; y &lt; end_y; ++y)
-            for (int x = start_x; x &lt; end_x; ++x)
-              {
-                int target_pos = (y + y_pos) * target_pitch + 3*(x + x_pos);
-                int brush_pos  = y * brush_pitch + 3*x;
+          int target_pos = (y + y_pos) * target_pitch + 3*(x + x_pos);
+          int brush_pos  = y * brush_pitch + 3*x;
 
-                target_buf[target_pos + 0] = 255;
-                target_buf[target_pos + 1] = brush_buf[brush_pos + 0];
-                target_buf[target_pos + 2] = brush_buf[brush_pos + 1];
-                target_buf[target_pos + 3] = brush_buf[brush_pos + 2];
-              }
+          target_buf[target_pos + 0] = 255;
+          target_buf[target_pos + 1] = brush_buf[brush_pos + 0];
+          target_buf[target_pos + 2] = brush_buf[brush_pos + 1];
+          target_buf[target_pos + 3] = brush_buf[brush_pos + 2];
         }
-      else
-        {
-          std::cout &lt;&lt; &quot;Unsupported bpp: &quot; &lt;&lt; brush.get_format().get_depth() &lt;&lt; std::endl;
-        }
     }
+    else
+    {
+      std::cout &lt;&lt; &quot;Unsupported bpp: &quot; &lt;&lt; brush.get_format().get_depth() &lt;&lt; std::endl;
+    }
+  }
   else if (brush.get_format().get_type() == pixelformat_index)
-    {
-      CL_Palette palette = brush.get_palette();
-      for (int y = start_y; y &lt; end_y; ++y)
-        for (int x = start_x; x &lt; end_x; ++x)
-          {
-            int target_pos = (y + y_pos) * target_pitch + 4*(x + x_pos);
-            int brush_pos  = y * brush_pitch + x;
+  {
+    CL_Palette palette = brush.get_palette();
+    for (int y = start_y; y &lt; end_y; ++y)
+      for (int x = start_x; x &lt; end_x; ++x)
+      {
+        int target_pos = (y + y_pos) * target_pitch + 4*(x + x_pos);
+        int brush_pos  = y * brush_pitch + x;
             
-            target_buf[target_pos + 0] = 255;
-            target_buf[target_pos + 1] = palette.colors[brush_buf[brush_pos]].get_blue();
-            target_buf[target_pos + 2] = palette.colors[brush_buf[brush_pos]].get_green();
-            target_buf[target_pos + 3] = palette.colors[brush_buf[brush_pos]].get_red();
-          }
-    }
+        target_buf[target_pos + 0] = 255;
+        target_buf[target_pos + 1] = palette.colors[brush_buf[brush_pos]].get_blue();
+        target_buf[target_pos + 2] = palette.colors[brush_buf[brush_pos]].get_green();
+        target_buf[target_pos + 3] = palette.colors[brush_buf[brush_pos]].get_red();
+      }
+  }
   else
-    {
-      assert(!&quot;Unknown pixelformat type&quot;);
-    }
+  {
+    assert(!&quot;Unknown pixelformat type&quot;);
+  }
     
 
 
@@ -120,71 +120,71 @@
   int brush_width  = brush.get_width();
 
   if (brush.get_format().get_type() == pixelformat_rgba)
+  {
+    if (brush.get_format().get_depth() == 32)
     {
-      if (brush.get_format().get_depth() == 32)
+      for (int y = start_y; y &lt; end_y; ++y)
+        for (int x = start_x; x &lt; end_x; ++x)
         {
-          for (int y = start_y; y &lt; end_y; ++y)
-            for (int x = start_x; x &lt; end_x; ++x)
-              {
-                int target_pos = (y + y_pos) * target_width + x + x_pos;
-                int brush_pos  = y * brush_width + x;
+          int target_pos = (y + y_pos) * target_width + x + x_pos;
+          int brush_pos  = y * brush_width + x;
 
-                unsigned char a  = brush_buf[4*brush_pos + 0];
-                unsigned char r  = brush_buf[4*brush_pos + 1];
-                unsigned char g  = brush_buf[4*brush_pos + 2];
-                unsigned char b  = brush_buf[4*brush_pos + 3];
+          unsigned char a  = brush_buf[4*brush_pos + 0];
+          unsigned char r  = brush_buf[4*brush_pos + 1];
+          unsigned char g  = brush_buf[4*brush_pos + 2];
+          unsigned char b  = brush_buf[4*brush_pos + 3];
 
-                unsigned char ta = target_buf[4*target_pos + 0];
-                unsigned char tr = target_buf[4*target_pos + 1];
-                unsigned char tg = target_buf[4*target_pos + 2];
-                unsigned char tb = target_buf[4*target_pos + 3];
+          unsigned char ta = target_buf[4*target_pos + 0];
+          unsigned char tr = target_buf[4*target_pos + 1];
+          unsigned char tg = target_buf[4*target_pos + 2];
+          unsigned char tb = target_buf[4*target_pos + 3];
 
-                float alpha  = a/255.0f;
+          float alpha  = a/255.0f;
         
-                target_buf[4*target_pos + 0] = std::min(255, ta + a);
-                target_buf[4*target_pos + 1] = std::min(255, int((1-alpha)*tr + alpha*r));
-                target_buf[4*target_pos + 2] = std::min(255, int((1-alpha)*tg + alpha*g));
-                target_buf[4*target_pos + 3] = std::min(255, int((1-alpha)*tb + alpha*b));
-              }
+          target_buf[4*target_pos + 0] = std::min(255, ta + a);
+          target_buf[4*target_pos + 1] = std::min(255, int((1-alpha)*tr + alpha*r));
+          target_buf[4*target_pos + 2] = std::min(255, int((1-alpha)*tg + alpha*g));
+          target_buf[4*target_pos + 3] = std::min(255, int((1-alpha)*tb + alpha*b));
         }
-      else if (brush.get_format().get_depth() == 24)
+    }
+    else if (brush.get_format().get_depth() == 24)
+    {
+      for (int y = start_y; y &lt; end_y; ++y)
+        for (int x = start_x; x &lt; end_x; ++x)
         {
-          for (int y = start_y; y &lt; end_y; ++y)
-            for (int x = start_x; x &lt; end_x; ++x)
-              {
-                int target_pos = (y + y_pos) * target_width + x + x_pos;
-                int brush_pos  = y * brush_width + x;
+          int target_pos = (y + y_pos) * target_width + x + x_pos;
+          int brush_pos  = y * brush_width + x;
 
-                target_buf[4*target_pos + 0] = 255;
-                target_buf[4*target_pos + 1] = brush_buf[3*brush_pos + 0];
-                target_buf[4*target_pos + 2] = brush_buf[3*brush_pos + 1];
-                target_buf[4*target_pos + 3] = brush_buf[3*brush_pos + 2];
-              }
+          target_buf[4*target_pos + 0] = 255;
+          target_buf[4*target_pos + 1] = brush_buf[3*brush_pos + 0];
+          target_buf[4*target_pos + 2] = brush_buf[3*brush_pos + 1];
+          target_buf[4*target_pos + 3] = brush_buf[3*brush_pos + 2];
         }
-      else
-        {
-          std::cout &lt;&lt; &quot;Unsupported bpp: &quot; &lt;&lt; brush.get_format().get_depth() &lt;&lt; std::endl;
-        }
     }
+    else
+    {
+      std::cout &lt;&lt; &quot;Unsupported bpp: &quot; &lt;&lt; brush.get_format().get_depth() &lt;&lt; std::endl;
+    }
+  }
   else if (brush.get_format().get_type() == pixelformat_index)
-    {
-      CL_Palette palette = brush.get_palette();
-      for (int y = start_y; y &lt; end_y; ++y)
-        for (int x = start_x; x &lt; end_x; ++x)
-          {
-            int target_pos = (y + y_pos) * target_width + x + x_pos;
-            int brush_pos  = y * brush_width + x;
+  {
+    CL_Palette palette = brush.get_palette();
+    for (int y = start_y; y &lt; end_y; ++y)
+      for (int x = start_x; x &lt; end_x; ++x)
+      {
+        int target_pos = (y + y_pos) * target_width + x + x_pos;
+        int brush_pos  = y * brush_width + x;
             
-            target_buf[4*target_pos + 0] = 255;
-            target_buf[4*target_pos + 1] = palette.colors[brush_buf[brush_pos]].get_blue();
-            target_buf[4*target_pos + 2] = palette.colors[brush_buf[brush_pos]].get_green();
-            target_buf[4*target_pos + 3] = palette.colors[brush_buf[brush_pos]].get_red();
-          }
-    }
+        target_buf[4*target_pos + 0] = 255;
+        target_buf[4*target_pos + 1] = palette.colors[brush_buf[brush_pos]].get_blue();
+        target_buf[4*target_pos + 2] = palette.colors[brush_buf[brush_pos]].get_green();
+        target_buf[4*target_pos + 3] = palette.colors[brush_buf[brush_pos]].get_red();
+      }
+  }
   else
-    {
-      assert(!&quot;Unknown pixelformat type&quot;);
-    }
+  {
+    assert(!&quot;Unknown pixelformat type&quot;);
+  }
     
 
 

Modified: trunk/flexlay/lib/brushmask.cpp
===================================================================
--- trunk/flexlay/lib/brushmask.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/brushmask.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -18,7 +18,7 @@
 
 /* Most of the code below is taken from Gimp2.2:
    gimp_brush_generated module Copyright 1998 Jay Cox &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">jaycox at earthlink.net</A>&gt; 
- */
+*/
 
 #include &lt;iostream&gt;
 #include &lt;math.h&gt;
@@ -54,11 +54,11 @@
 
 TempBuf *
 temp_buf_new (gint    width,
-	      gint    height,
-	      gint    bytes,
-	      gint    x,
-	      gint    y,
-	      guchar *col)
+              gint    height,
+              gint    bytes,
+              gint    x,
+              gint    y,
+              guchar *col)
 {
   TempBuf* buf = new TempBuf;
 
@@ -79,10 +79,10 @@
 {
   /* this aint' a real gauss function */
   if (f &lt; -0.5)
-    {
-      f = -1.0 - f;
-      return (2.0 * f*f);
-    }
+  {
+    f = -1.0 - f;
+    return (2.0 * f*f);
+  }
 
   if (f &lt; 0.5)
     return (1.0 - 2.0 * f*f);
@@ -143,7 +143,7 @@
   brush-&gt;y_axis.y =        c * short_radius;
 
   switch (brush-&gt;shape)
-    {
+  {
     case BRUSH_SHAPE_CIRCLE:
       width  = static_cast&lt;int&gt;(ceil (sqrt (brush-&gt;x_axis.x * brush-&gt;x_axis.x +
                                             brush-&gt;y_axis.x * brush-&gt;y_axis.x)));
@@ -163,16 +163,16 @@
 
     default:
       return;
-    }
+  }
 
   if (brush-&gt;spikes &gt; 2)
-    {
-      /* could be optimized by respecting the angle */
-      width = height = static_cast&lt;int&gt;(ceil (sqrt (brush-&gt;radius * brush-&gt;radius +
-                                                    short_radius * short_radius)));
-      brush-&gt;y_axis.x =        s * brush-&gt;radius;
-      brush-&gt;y_axis.y =        c * brush-&gt;radius;
-    }
+  {
+    /* could be optimized by respecting the angle */
+    width = height = static_cast&lt;int&gt;(ceil (sqrt (brush-&gt;radius * brush-&gt;radius +
+                                                  short_radius * short_radius)));
+    brush-&gt;y_axis.x =        s * brush-&gt;radius;
+    brush-&gt;y_axis.y =        c * brush-&gt;radius;
+  }
 
   brush-&gt;mask = temp_buf_new (width  * 2 + 1,
                               height * 2 + 1,
@@ -194,88 +194,88 @@
   sum = 0.0;
 
   for (x = 0; x &lt; OVERSAMPLING; x++)
-    {
-      d = fabs ((x + 0.5) / OVERSAMPLING - 0.5);
+  {
+    d = fabs ((x + 0.5) / OVERSAMPLING - 0.5);
 
-      if (d &gt; brush-&gt;radius)
-        buffer[x] = 0.0;
-      else
-        buffer[x] = gauss (pow (d / brush-&gt;radius, exponent));
+    if (d &gt; brush-&gt;radius)
+      buffer[x] = 0.0;
+    else
+      buffer[x] = gauss (pow (d / brush-&gt;radius, exponent));
 
-      sum += buffer[x];
-    }
+    sum += buffer[x];
+  }
 
   for (x = 0; d &lt; brush-&gt;radius || sum &gt; 0.00001; d += 1.0 / OVERSAMPLING)
-    {
-      sum -= buffer[x % OVERSAMPLING];
+  {
+    sum -= buffer[x % OVERSAMPLING];
 
-      if (d &gt; brush-&gt;radius)
-        buffer[x % OVERSAMPLING] = 0.0;
-      else
-        buffer[x % OVERSAMPLING] = gauss (pow (d / brush-&gt;radius, exponent));
+    if (d &gt; brush-&gt;radius)
+      buffer[x % OVERSAMPLING] = 0.0;
+    else
+      buffer[x % OVERSAMPLING] = gauss (pow (d / brush-&gt;radius, exponent));
 
-      sum += buffer[x % OVERSAMPLING];
-      lookup[x++] = static_cast&lt;int&gt;(rint(sum * (255.0 / OVERSAMPLING)));
-    }
+    sum += buffer[x % OVERSAMPLING];
+    lookup[x++] = static_cast&lt;int&gt;(rint(sum * (255.0 / OVERSAMPLING)));
+  }
 
   while (x &lt; length)
-    {
-      lookup[x++] = 0;
-    }
+  {
+    lookup[x++] = 0;
+  }
 
   cs = cos (- 2 * M_PI / brush-&gt;spikes);
   ss = sin (- 2 * M_PI / brush-&gt;spikes);
 
   /* for an even number of spikes compute one half and mirror it */
   for (y = (brush-&gt;spikes % 2 ? -height : 0); y &lt;= height; y++)
+  {
+    for (x = -width; x &lt;= width; x++)
     {
-      for (x = -width; x &lt;= width; x++)
-        {
-          double tx, ty, angle;
+      double tx, ty, angle;
 
-          tx = c*x - s*y;
-          ty = fabs (s*x + c*y);
+      tx = c*x - s*y;
+      ty = fabs (s*x + c*y);
 
-          if (brush-&gt;spikes &gt; 2)
-            {
-              angle = atan2 (ty, tx);
+      if (brush-&gt;spikes &gt; 2)
+      {
+        angle = atan2 (ty, tx);
 
-              while (angle &gt; M_PI / brush-&gt;spikes)
-                {
-                  double sx = tx, sy = ty;
+        while (angle &gt; M_PI / brush-&gt;spikes)
+        {
+          double sx = tx, sy = ty;
 
-                  tx = cs * sx - ss * sy;
-                  ty = ss * sx + cs * sy;
+          tx = cs * sx - ss * sy;
+          ty = ss * sx + cs * sy;
 
-                  angle -= 2 * M_PI / brush-&gt;spikes;
-                }
-            }
+          angle -= 2 * M_PI / brush-&gt;spikes;
+        }
+      }
 
-          ty *= brush-&gt;aspect_ratio;
-          switch (brush-&gt;shape)
-            {
-            case BRUSH_SHAPE_CIRCLE:
-              d = sqrt (tx*tx + ty*ty);
-              break;
-            case BRUSH_SHAPE_SQUARE:
-              d = std::max (fabs (tx), fabs (ty));
-              break;
-            case BRUSH_SHAPE_DIAMOND:
-              d = fabs (tx) + fabs (ty);
-              break;
-            }
+      ty *= brush-&gt;aspect_ratio;
+      switch (brush-&gt;shape)
+      {
+        case BRUSH_SHAPE_CIRCLE:
+          d = sqrt (tx*tx + ty*ty);
+          break;
+        case BRUSH_SHAPE_SQUARE:
+          d = std::max (fabs (tx), fabs (ty));
+          break;
+        case BRUSH_SHAPE_DIAMOND:
+          d = fabs (tx) + fabs (ty);
+          break;
+      }
 
-          if (d &lt; brush-&gt;radius + 1)
-            a = lookup[(gint) rint (d * OVERSAMPLING)];
-          else
-            a = 0;
+      if (d &lt; brush-&gt;radius + 1)
+        a = lookup[(gint) rint (d * OVERSAMPLING)];
+      else
+        a = 0;
 
-          centerp[ y * brush-&gt;mask-&gt;width + x] = a;
+      centerp[ y * brush-&gt;mask-&gt;width + x] = a;
 
-          if (brush-&gt;spikes % 2 == 0)
-            centerp[-1 * y * brush-&gt;mask-&gt;width - x] = a;
-        }
+      if (brush-&gt;spikes % 2 == 0)
+        centerp[-1 * y * brush-&gt;mask-&gt;width - x] = a;
     }
+  }
 
   delete lookup;
 }
@@ -308,12 +308,12 @@
   // FIXME: Leaving out the right/bottom border, since thats full of
   // random spots... more a workaround than a fix really
   for (int i = 0; i &lt; brush.mask-&gt;height * brush.mask-&gt;width; ++i)
-    {
-      buf[i*4+0] = brush.mask-&gt;data[i];
-      buf[i*4+1] = 255;
-      buf[i*4+2] = 255;
-      buf[i*4+3] = 255;
-    }
+  {
+    buf[i*4+0] = brush.mask-&gt;data[i];
+    buf[i*4+1] = 255;
+    buf[i*4+2] = 255;
+    buf[i*4+3] = 255;
+  }
   buffer.unlock();
 
   return buffer;

Modified: trunk/flexlay/lib/colorpicker.cpp
===================================================================
--- trunk/flexlay/lib/colorpicker.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/colorpicker.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -61,68 +61,68 @@
     CL_Color new_color; 
 
     if (event.mouse_pos.y &gt;= get_height() || event.mouse_pos.y &lt; 0)
-      {
-        new_color = colors[0];
-      }
+    {
+      new_color = colors[0];
+    }
     else
-      {
-        float factor  = (float(event.mouse_pos.y) / get_height()) * (colors.size()-1);
-        int   prevcol = int(factor);
-        int   nextcol = prevcol+1;
+    {
+      float factor  = (float(event.mouse_pos.y) / get_height()) * (colors.size()-1);
+      int   prevcol = int(factor);
+      int   nextcol = prevcol+1;
 
-        float val  = factor - prevcol;
-        float ival = 1.0f - val;
+      float val  = factor - prevcol;
+      float ival = 1.0f - val;
 
 
-        if (val &gt;= 0 &amp;&amp; val &lt; 1.0f)
-          {
-            new_color = CL_Color(int(val * colors[nextcol].get_red()   + ival * colors[prevcol].get_red()),
-                                 int(val * colors[nextcol].get_green() + ival * colors[prevcol].get_green()),
-                                 int(val * colors[nextcol].get_blue()  + ival * colors[prevcol].get_blue()),
-                                 int(val * colors[nextcol].get_alpha() + ival * colors[prevcol].get_alpha()));
-          }
-        else
-          {
-            std::cout &lt;&lt; &quot;Out of range&quot; &lt;&lt; std::endl;
-            new_color = colors[0];
-          }
+      if (val &gt;= 0 &amp;&amp; val &lt; 1.0f)
+      {
+        new_color = CL_Color(int(val * colors[nextcol].get_red()   + ival * colors[prevcol].get_red()),
+                             int(val * colors[nextcol].get_green() + ival * colors[prevcol].get_green()),
+                             int(val * colors[nextcol].get_blue()  + ival * colors[prevcol].get_blue()),
+                             int(val * colors[nextcol].get_alpha() + ival * colors[prevcol].get_alpha()));
       }
+      else
+      {
+        std::cout &lt;&lt; &quot;Out of range&quot; &lt;&lt; std::endl;
+        new_color = colors[0];
+      }
+    }
     on_color_change(new_color);
 
     /*
-    std::cout &lt;&lt; new_color.get_red() &lt;&lt; &quot;, &quot;
-              &lt;&lt; new_color.get_green() &lt;&lt; &quot;, &quot;
-              &lt;&lt; new_color.get_blue() &lt;&lt; &quot;, &quot;
-              &lt;&lt; new_color.get_alpha()
-              &lt;&lt; std::endl;*/
+      std::cout &lt;&lt; new_color.get_red() &lt;&lt; &quot;, &quot;
+      &lt;&lt; new_color.get_green() &lt;&lt; &quot;, &quot;
+      &lt;&lt; new_color.get_blue() &lt;&lt; &quot;, &quot;
+      &lt;&lt; new_color.get_alpha()
+      &lt;&lt; std::endl;*/
   }
   
   void on_mouse_up(const CL_InputEvent&amp; event)
   {
     if (event.id == CL_MOUSE_LEFT)
-      {
-        pressed = false;
-        release_mouse();
-        update_pointer(event);
-      }
+    {
+      pressed = false;
+      release_mouse();
+      update_pointer(event);
+    }
   }
 
   void on_mouse_down(const CL_InputEvent&amp; event)
   {
     if (event.id == CL_MOUSE_LEFT)
-      {
-        pressed = true;
-        capture_mouse();
-        update_pointer(event);
-      }  
+    {
+      pressed = true;
+      capture_mouse();
+      update_pointer(event);
+    }  
   }
   
   void on_mouse_move(const CL_InputEvent&amp; event)
   {
     if (pressed)
-      {
-        update_pointer(event);
-      }
+    {
+      update_pointer(event);
+    }
   }
 
   void draw()
@@ -133,14 +133,14 @@
     int psize = get_height()/6;
     
     for(Colors::size_type i = 0; i &lt; colors.size()-1; ++i)
-      {
-        CL_Display::fill_rect(CL_Rect(CL_Point(0, i*psize),
-                                      CL_Size(get_width(), psize)),
-                              CL_Gradient(colors[i],
-                                          colors[i],
-                                          colors[i+1],
-                                          colors[i+1]));
-      }
+    {
+      CL_Display::fill_rect(CL_Rect(CL_Point(0, i*psize),
+                                    CL_Size(get_width(), psize)),
+                            CL_Gradient(colors[i],
+                                        colors[i],
+                                        colors[i+1],
+                                        colors[i+1]));
+    }
 
     CL_Display::pop_modelview();    
   }
@@ -196,29 +196,29 @@
   void on_mouse_up(const CL_InputEvent&amp; event)
   {
     if (event.id == CL_MOUSE_LEFT)
-      {
-        pressed = false;
-        release_mouse();
-        update_pointer(event);
-      }
+    {
+      pressed = false;
+      release_mouse();
+      update_pointer(event);
+    }
   }
 
   void on_mouse_down(const CL_InputEvent&amp; event)
   {
     if (event.id == CL_MOUSE_LEFT)
-      {
-        pressed = true;
-        capture_mouse();
-        update_pointer(event);
-      }
+    {
+      pressed = true;
+      capture_mouse();
+      update_pointer(event);
+    }
   }
 
   void on_mouse_move(const CL_InputEvent&amp; event)
   {
     if (pressed)
-      {
-        update_pointer(event);    
-      }
+    {
+      update_pointer(event);    
+    }
   }
 };
 
@@ -285,11 +285,11 @@
                        color.get_alpha());
     on_color_change(new_color);
     /*
-    std::cout &lt;&lt; new_color.get_red() &lt;&lt; &quot;, &quot;
-              &lt;&lt; new_color.get_green() &lt;&lt; &quot;, &quot;
-              &lt;&lt; new_color.get_blue() &lt;&lt; &quot;, &quot;
-              &lt;&lt; new_color.get_alpha()
-              &lt;&lt; std::endl;
+      std::cout &lt;&lt; new_color.get_red() &lt;&lt; &quot;, &quot;
+      &lt;&lt; new_color.get_green() &lt;&lt; &quot;, &quot;
+      &lt;&lt; new_color.get_blue() &lt;&lt; &quot;, &quot;
+      &lt;&lt; new_color.get_alpha()
+      &lt;&lt; std::endl;
     */
   }
 
@@ -304,29 +304,29 @@
   void on_mouse_up(const CL_InputEvent&amp; event)
   {
     if (event.id == CL_MOUSE_LEFT)
-      {
-        pressed = false;
-        release_mouse();
-        update_pointer(event);
-      }    
+    {
+      pressed = false;
+      release_mouse();
+      update_pointer(event);
+    }    
   }
 
   void on_mouse_down(const CL_InputEvent&amp; event)
   {
     if (event.id == CL_MOUSE_LEFT)
-      {
-        pressed = true;
-        capture_mouse();
-        update_pointer(event);
-      }
+    {
+      pressed = true;
+      capture_mouse();
+      update_pointer(event);
+    }
   }
 
   void on_mouse_move(const CL_InputEvent&amp; event)
   {
     if (pressed)
-      {
-        update_pointer(event);
-      }
+    {
+      update_pointer(event);
+    }
   }
 };
 

Modified: trunk/flexlay/lib/console.cpp
===================================================================
--- trunk/flexlay/lib/console.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/console.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -59,9 +59,9 @@
 
   for(int y = 0; y &lt; size.height; ++y)
     for(int x = 0; x &lt; size.width; ++x)
-      {
-        font.draw_character(x * font_w, y * font_h, screen.at(x, y));
-      }
+    {
+      font.draw_character(x * font_w, y * font_h, screen.at(x, y));
+    }
 }
 
 Console::Console(/*const CL_Font&amp; font,*/ const CL_Rect&amp; rect, CL_Component* parent)
@@ -91,19 +91,19 @@
   full_buffer += c; 
 
   if (c == '\n')
-    {
-      cursor_pos.x = 0;
-      cursor_pos.y += 1;
-    }
+  {
+    cursor_pos.x = 0;
+    cursor_pos.y += 1;
+  }
   else
-    {
-      screen.at(cursor_pos.x, cursor_pos.y) = c;
+  {
+    screen.at(cursor_pos.x, cursor_pos.y) = c;
 
-      cursor_pos.x += 1;
+    cursor_pos.x += 1;
 
-      if (cursor_pos.x &gt;= size.width)
-        cursor_pos.x = 0;
-    }
+    if (cursor_pos.x &gt;= size.width)
+      cursor_pos.x = 0;
+  }
 
   // Move all content one line up
   if (cursor_pos.y &gt;= size.height)
@@ -116,10 +116,10 @@
   std::cout &lt;&lt; str &lt;&lt; std::flush;
 
   for(std::string::const_iterator i = str.begin(); i != str.end(); ++i)
-    {
-      if (*i != 0)
-        impl-&gt;putchar(*i);
-    }
+  {
+    if (*i != 0)
+      impl-&gt;putchar(*i);
+  }
 }
 
 /* EOF */

Modified: trunk/flexlay/lib/directory_view.cpp
===================================================================
--- trunk/flexlay/lib/directory_view.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/directory_view.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -110,39 +110,39 @@
 
   int j = 0;
   for(Items::iterator i = items.begin(); i != items.begin()+50 &amp;&amp; i != items.end(); ++i)
+  {
+    if (current_item &amp;&amp; current_item &lt; int(items.size()) &amp;&amp; j == current_item)
     {
-      if (current_item &amp;&amp; current_item &lt; int(items.size()) &amp;&amp; j == current_item)
-        {
-          CL_Rect rect = font.bounding_rect(x_pos * (column_width + horizontal_spacing) + 1, 
-                                            y_pos * (font.get_height() + vertical_spacing) + 1,
-                                            i-&gt;name);
-          CL_Display::fill_rect(CL_Rect(rect.left-5, rect.top-3,
-                                        rect.left+5+column_width, rect.bottom+3),
-                                CL_Color(250, 200, 0));
-        }
+      CL_Rect rect = font.bounding_rect(x_pos * (column_width + horizontal_spacing) + 1, 
+                                        y_pos * (font.get_height() + vertical_spacing) + 1,
+                                        i-&gt;name);
+      CL_Display::fill_rect(CL_Rect(rect.left-5, rect.top-3,
+                                    rect.left+5+column_width, rect.bottom+3),
+                            CL_Color(250, 200, 0));
+    }
 
-      // draw item
-      if (!i-&gt;directory)
-        {
-          font.draw(x_pos * (column_width + horizontal_spacing), 
-                    y_pos * (font.get_height() + vertical_spacing),
-                    i-&gt;name);
-        }
-      else
-        {
-          font.draw(x_pos * (column_width + horizontal_spacing), 
-                    y_pos * (font.get_height() + vertical_spacing),
-                    &quot;[&quot; + i-&gt;name + &quot;]&quot;);
-        }
+    // draw item
+    if (!i-&gt;directory)
+    {
+      font.draw(x_pos * (column_width + horizontal_spacing), 
+                y_pos * (font.get_height() + vertical_spacing),
+                i-&gt;name);
+    }
+    else
+    {
+      font.draw(x_pos * (column_width + horizontal_spacing), 
+                y_pos * (font.get_height() + vertical_spacing),
+                &quot;[&quot; + i-&gt;name + &quot;]&quot;);
+    }
 
-      x_pos += 1;
-      if (x_pos &gt;= num_columns)
-        {
-          x_pos = 0;
-          y_pos += 1;
-        }
-      ++j;
+    x_pos += 1;
+    if (x_pos &gt;= num_columns)
+    {
+      x_pos = 0;
+      y_pos += 1;
     }
+    ++j;
+  }
 }
 
 int
@@ -162,10 +162,10 @@
 {
   current_item = get_item(event.mouse_pos);
   if (current_item &gt;= 0 &amp;&amp; current_item &lt; int(items.size()))
-    {
-      if (items[current_item].directory)
+  {
+    if (items[current_item].directory)
       parent-&gt;set_directory(path + &quot;/&quot; + items[current_item].name);
-    }
+  }
 }
 
 void 
@@ -182,13 +182,13 @@
 
   scanner.scan(path);
   while(scanner.next())
-    {
-      DirectoryViewEntry entry;
-      entry.name = scanner.get_name();
-      entry.hidden = (scanner.get_name()[0] == '.');
-      entry.directory = scanner.is_directory();
-      items.push_back(entry);
-    }
+  {
+    DirectoryViewEntry entry;
+    entry.name = scanner.get_name();
+    entry.hidden = (scanner.get_name()[0] == '.');
+    entry.directory = scanner.is_directory();
+    items.push_back(entry);
+  }
 
   std::sort(items.begin(), items.end(), DirectoryViewSorter());
 
@@ -196,10 +196,10 @@
 
   column_width = 60; // min_colum_width
   for(Items::iterator i = items.begin(); i != items.end(); ++i)
-    {
-      CL_Rect rect = font.bounding_rect(0, 0, i-&gt;name + &quot;[]&quot;);
-      column_width = std::max(column_width, rect.get_width());
-    }
+  {
+    CL_Rect rect = font.bounding_rect(0, 0, i-&gt;name + &quot;[]&quot;);
+    column_width = std::max(column_width, rect.get_width());
+  }
 
   num_columns = parent-&gt;get_width()/column_width;
 }

Modified: trunk/flexlay/lib/editor_map.cpp
===================================================================
--- trunk/flexlay/lib/editor_map.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/editor_map.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -58,15 +58,15 @@
   : impl(0)
 {
   if (create)
-    {
-      impl = new EditorMapImpl();
-      impl-&gt;background_color = CL_Color(100, 80, 100);
-      impl-&gt;foreground_color = CL_Color(255, 80, 255);
-      impl-&gt;modified = false;
-      impl-&gt;serial = 0;
-      impl-&gt;has_bounding_rect = false;
-      impl-&gt;bounding_rect = CL_Rect(0,0,0,0);
-    }
+  {
+    impl = new EditorMapImpl();
+    impl-&gt;background_color = CL_Color(100, 80, 100);
+    impl-&gt;foreground_color = CL_Color(255, 80, 255);
+    impl-&gt;modified = false;
+    impl-&gt;serial = 0;
+    impl-&gt;has_bounding_rect = false;
+    impl-&gt;bounding_rect = CL_Rect(0,0,0,0);
+  }
 }
 
 void
@@ -90,14 +90,14 @@
   CL_Rect rect = get_bounding_rect();
 
   if (rect != CL_Rect(0,0,0,0))
-    {
-      gc-&gt;fill_rect(rect, impl-&gt;background_color);
-      gc-&gt;draw_rect(rect, impl-&gt;foreground_color);
-    }
+  {
+    gc-&gt;fill_rect(rect, impl-&gt;background_color);
+    gc-&gt;draw_rect(rect, impl-&gt;foreground_color);
+  }
   else
-    {
-      gc-&gt;clear(impl-&gt;background_color);
-    }
+  {
+    gc-&gt;clear(impl-&gt;background_color);
+  }
 }
 
 void
@@ -171,50 +171,50 @@
 EditorMap::set_bounding_rect(const CL_Rect&amp; rect)
 {
   if (rect != CL_Rect(0,0,0,0))
-    {
-      impl-&gt;has_bounding_rect = true;
-      impl-&gt;bounding_rect     = rect;
-    }
+  {
+    impl-&gt;has_bounding_rect = true;
+    impl-&gt;bounding_rect     = rect;
+  }
   else
-    {
-      impl-&gt;has_bounding_rect = false;
-      impl-&gt;bounding_rect     = rect;
-    }
+  {
+    impl-&gt;has_bounding_rect = false;
+    impl-&gt;bounding_rect     = rect;
+  }
 }
 
 CL_Rect
 EditorMap::get_bounding_rect()
 {
   if (impl-&gt;has_bounding_rect)
-    {
-      return impl-&gt;bounding_rect;
-    }
+  {
+    return impl-&gt;bounding_rect;
+  }
   else
+  {
+    bool init = false;
+    CL_Rect rect(0,0,0,0);
+
+    for(EditorMapImpl::Layers::iterator i = impl-&gt;layers.begin(); i != impl-&gt;layers.end(); ++i)
     {
-      bool init = false;
-      CL_Rect rect(0,0,0,0);
-
-      for(EditorMapImpl::Layers::iterator i = impl-&gt;layers.begin(); i != impl-&gt;layers.end(); ++i)
+      if (i-&gt;has_bounding_rect())
+      {
+        if (!init)
         {
-          if (i-&gt;has_bounding_rect())
-            {
-              if (!init)
-                {
-                  rect = i-&gt;get_bounding_rect();
-                  init = true;
-                }
-              else
-                {
-                  CL_Rect other = i-&gt;get_bounding_rect();
-                  rect.top    = std::min(rect.top,    other.top);
-                  rect.bottom = std::max(rect.bottom, other.bottom);
-                  rect.left   = std::min(rect.left,   other.left);
-                  rect.right  = std::max(rect.right,  other.right);              
-                }
-            }
+          rect = i-&gt;get_bounding_rect();
+          init = true;
         }
-      return rect;
+        else
+        {
+          CL_Rect other = i-&gt;get_bounding_rect();
+          rect.top    = std::min(rect.top,    other.top);
+          rect.bottom = std::max(rect.bottom, other.bottom);
+          rect.left   = std::min(rect.left,   other.left);
+          rect.right  = std::max(rect.right,  other.right);              
+        }
+      }
     }
+    return rect;
+  }
 }
 
 void
@@ -236,26 +236,26 @@
 EditorMap::undo()
 {
   if (!impl-&gt;undo_stack.empty())
-    {
-      Command command = impl-&gt;undo_stack.back();
-      impl-&gt;undo_stack.pop_back();
-      command.undo();
-      impl-&gt;redo_stack.push_back(command);
-      impl-&gt;on_change();
-    }
+  {
+    Command command = impl-&gt;undo_stack.back();
+    impl-&gt;undo_stack.pop_back();
+    command.undo();
+    impl-&gt;redo_stack.push_back(command);
+    impl-&gt;on_change();
+  }
 }
 
 void
 EditorMap::redo()
 {
   if (!impl-&gt;redo_stack.empty())
-    {
-      Command command = impl-&gt;redo_stack.back();
-      impl-&gt;redo_stack.pop_back();
-      command.redo();
-      impl-&gt;undo_stack.push_back(command);
-      impl-&gt;on_change();
-    }
+  {
+    Command command = impl-&gt;redo_stack.back();
+    impl-&gt;redo_stack.pop_back();
+    command.redo();
+    impl-&gt;undo_stack.push_back(command);
+    impl-&gt;on_change();
+  }
 }
 
 int

Modified: trunk/flexlay/lib/editor_map_component.cpp
===================================================================
--- trunk/flexlay/lib/editor_map_component.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/editor_map_component.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -106,20 +106,20 @@
 EditorMapComponentImpl::on_key_down(const CL_InputEvent&amp; event)
 {
   if (event.id &gt;= 0 &amp;&amp; event.id &lt; 256)
-    { 
-      CL_Rect rect = parent-&gt;get_position();
-      key_bindings[event.id](CL_Mouse::get_x() - rect.left,
-                             CL_Mouse::get_y() - rect.top);
-    }
+  { 
+    CL_Rect rect = parent-&gt;get_position();
+    key_bindings[event.id](CL_Mouse::get_x() - rect.left,
+                           CL_Mouse::get_y() - rect.top);
+  }
 
   if (event.repeat_count == 0)
-    {
-      CL_Rect rect = parent-&gt;get_position();
-      CL_InputEvent ev2 = event;
-      ev2.mouse_pos = CL_Point(CL_Mouse::get_x() - rect.left,
-                               CL_Mouse::get_y() - rect.top);
-      workspace.key_down(ev2);
-    }
+  {
+    CL_Rect rect = parent-&gt;get_position();
+    CL_InputEvent ev2 = event;
+    ev2.mouse_pos = CL_Point(CL_Mouse::get_x() - rect.left,
+                             CL_Mouse::get_y() - rect.top);
+    workspace.key_down(ev2);
+  }
 }
 
 void
@@ -254,14 +254,14 @@
   //std::cout &lt;&lt; str &lt;&lt; &quot; =&gt; &quot; &lt;&lt; id &lt;&lt; std::endl;
 
   if (id &gt; 0 &amp;&amp; id &lt; 256)
-    {
-      return impl-&gt;key_bindings[id];
-    }
+  {
+    return impl-&gt;key_bindings[id];
+  }
   else
-    {
-      std::cout &lt;&lt; &quot;EditorMapComponent::sig_on_key: invalid key id: &quot; &lt;&lt; id &lt;&lt; std::endl;
-      return impl-&gt;key_bindings[0];
-    }
+  {
+    std::cout &lt;&lt; &quot;EditorMapComponent::sig_on_key: invalid key id: &quot; &lt;&lt; id &lt;&lt; std::endl;
+    return impl-&gt;key_bindings[0];
+  }
 }
 
 GraphicContextState&amp;

Modified: trunk/flexlay/lib/field.hpp
===================================================================
--- trunk/flexlay/lib/field.hpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/field.hpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -68,11 +68,11 @@
   Field&lt;T&gt;&amp; operator=(const Field&lt;T&gt;&amp; copy)
   {
     if (this != &amp;copy)
-      {
-        width  = copy.width;
-        height = copy.height;
-        vec    = copy.vec;
-      }
+    {
+      width  = copy.width;
+      height = copy.height;
+      vec    = copy.vec;
+    }
     return *this;
   }
 

Modified: trunk/flexlay/lib/flexlay.cpp
===================================================================
--- trunk/flexlay/lib/flexlay.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/flexlay.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -53,9 +53,9 @@
 
   std::cout &lt;&lt; &quot;Flexlay::init()&quot; &lt;&lt; std::endl;
   try {
-    #ifdef WIN32
+#ifdef WIN32
     CL_SetupCore::set_instance(GetModuleHandle(&quot;flexlay_wrap.dll&quot;));
-    #endif
+#endif
     CL_SetupCore::init();
 #ifdef HAVE_LIBSDL
     if (use_opengl)

Modified: trunk/flexlay/lib/flexlay.hpp
===================================================================
--- trunk/flexlay/lib/flexlay.hpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/flexlay.hpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -24,49 +24,49 @@
 
 /*! \mainpage Flexlay - A Flexible Layered 2D Editor
   
-\section intro Introduction
+  \section intro Introduction
 
-Flexlay is a rather flexible layered editor mainly meant for editing
-game data such as levels, tilemaps, enemy placement and such. It
-provides a basic framework which makes it easy to add new
-functionality, special dialog windows and such needed to customize it
-for a specific game. Flexlay itself is actually a Python module and
-not an editor in itself, however due to reasonably simple Python
-scripts one can already have a fully working editor.
+  Flexlay is a rather flexible layered editor mainly meant for editing
+  game data such as levels, tilemaps, enemy placement and such. It
+  provides a basic framework which makes it easy to add new
+  functionality, special dialog windows and such needed to customize it
+  for a specific game. Flexlay itself is actually a Python module and
+  not an editor in itself, however due to reasonably simple Python
+  scripts one can already have a fully working editor.
 
-\section structure Structure
+  \section structure Structure
 
-Flexlay provides the following basic classes on which everything else
-is build:
+  Flexlay provides the following basic classes on which everything else
+  is build:
 
-Command: each operation on data is encapsuled in a Command object
-which provides undo/redo capability, together with a way to easily
-record macros and write scripts with it.
+  Command: each operation on data is encapsuled in a Command object
+  which provides undo/redo capability, together with a way to easily
+  record macros and write scripts with it.
 
-EditorMapLayer: a map layer is the class that holds the data, special
-layers such as object or tilemap layers derive from this class to
-provide the capabilites needed to use them
+  EditorMapLayer: a map layer is the class that holds the data, special
+  layers such as object or tilemap layers derive from this class to
+  provide the capabilites needed to use them
 
-Tool: A tool manages and dispatches mouse input to Commands, thus
-giving the user an interactive way to manipulate map data.
+  Tool: A tool manages and dispatches mouse input to Commands, thus
+  giving the user an interactive way to manipulate map data.
 
-GUI: Flexlay provides a simple GUI framework that can be used from
-Python to create dialogboxes, add buttons to the main window and such.
+  GUI: Flexlay provides a simple GUI framework that can be used from
+  Python to create dialogboxes, add buttons to the main window and such.
 
-\section games Games
+  \section games Games
 
-Currently Flexlay supports the following games with different levels
-of completeness:
+  Currently Flexlay supports the following games with different levels
+  of completeness:
 
-netPanzer: fully working load/save and map editing capabilites
+  netPanzer: fully working load/save and map editing capabilites
 
-SuperTux: fully working load/save and map editing capabilites, however
-a bit limited when it comes to object properties
+  SuperTux: fully working load/save and map editing capabilites, however
+  a bit limited when it comes to object properties
 
-Windstille: fully working load/save support, however due to the game
-itself not being ready this is not so usefull
+  Windstille: fully working load/save support, however due to the game
+  itself not being ready this is not so usefull
 
-Pingus: just very basic load support
+  Pingus: just very basic load support
 
 */
 

Modified: trunk/flexlay/lib/generated_brush.cpp
===================================================================
--- trunk/flexlay/lib/generated_brush.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/generated_brush.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -40,7 +40,7 @@
 };
 
 GeneratedBrush::GeneratedBrush(const Brush&amp; brush)
-: impl(dynamic_cast&lt;GeneratedBrushImpl*&gt;(brush.impl.get())) // FIXME: WANT WORK WITH REAL SMARTPTR!!!
+  : impl(dynamic_cast&lt;GeneratedBrushImpl*&gt;(brush.impl.get())) // FIXME: WANT WORK WITH REAL SMARTPTR!!!
 {
 }
 
@@ -65,18 +65,18 @@
 GeneratedBrushImpl::update()
 {
   if (dirty)
-    {
-      CL_SpriteDescription desc;
-      desc.add_frame(generate_brushmask(shape,
-                                        radius, 
-                                        spikes,
-                                        hardness, 
-                                        aspect_ratio, 
-                                        angle));
-      sprite = CL_Sprite(desc);
-      sprite.set_alignment(origin_center);
-      dirty = false;
-    }
+  {
+    CL_SpriteDescription desc;
+    desc.add_frame(generate_brushmask(shape,
+                                      radius, 
+                                      spikes,
+                                      hardness, 
+                                      aspect_ratio, 
+                                      angle));
+    sprite = CL_Sprite(desc);
+    sprite.set_alignment(origin_center);
+    dirty = false;
+  }
 }
 
 void

Modified: trunk/flexlay/lib/graphic_context_state.cpp
===================================================================
--- trunk/flexlay/lib/graphic_context_state.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/graphic_context_state.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -141,13 +141,13 @@
   
   //std::cout &lt;&lt; &quot;Screen: &quot; &lt;&lt; screen_relation &lt;&lt; &quot; Zoom: &quot; &lt;&lt; rect_relation &lt;&lt; std::endl;
   if (rect_relation &lt; screen_relation) // take width, ignore height
-    {
-      impl-&gt;zoom = get_width()/width; 
-    }
+  {
+    impl-&gt;zoom = get_width()/width; 
+  }
   else // take height, ignore width
-    {
-      impl-&gt;zoom = get_height()/height;
-    }
+  {
+    impl-&gt;zoom = get_height()/height;
+  }
 
   impl-&gt;offset.x = (get_width()  / (2*impl-&gt;zoom)) - center_x;
   impl-&gt;offset.y = (get_height() / (2*impl-&gt;zoom)) - center_y;

Modified: trunk/flexlay/lib/helper.cpp
===================================================================
--- trunk/flexlay/lib/helper.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/helper.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -150,12 +150,12 @@
   
   for(int y = 0; y &lt; height; ++y)
     for(int x = 0; x &lt; width; ++x)
-      {
-        target_buf[target_pitch*y + 4*x + 0] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 0];
-        target_buf[target_pitch*y + 4*x + 1] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 1];
-        target_buf[target_pitch*y + 4*x + 2] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 2];
-        target_buf[target_pitch*y + 4*x + 3] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 3];
-      }
+    {
+      target_buf[target_pitch*y + 4*x + 0] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 0];
+      target_buf[target_pitch*y + 4*x + 1] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 1];
+      target_buf[target_pitch*y + 4*x + 2] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 2];
+      target_buf[target_pitch*y + 4*x + 3] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 3];
+    }
 
   buffer.unlock();
   target.unlock();

Modified: trunk/flexlay/lib/icon.cpp
===================================================================
--- trunk/flexlay/lib/icon.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/icon.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -80,30 +80,30 @@
   sprite.set_alignment(origin_center);
 
   if (is_enabled)
+  {
+    if (is_down)
     {
-      if (is_down)
-        {
+      Box::draw_button_down(rect);
+    }
+    else
+    {
+      if (parent-&gt;has_mouse_over())
+      {
+        if (down)
           Box::draw_button_down(rect);
-        }
+        else
+          Box::draw_button_up(rect);
+      }
       else
-        {
-          if (parent-&gt;has_mouse_over())
-            {
-              if (down)
-                Box::draw_button_down(rect);
-              else
-                Box::draw_button_up(rect);
-            }
-          else
-            Box::draw_button_neutral(rect);
-        }
-      sprite.set_alpha(1.0f);
+        Box::draw_button_neutral(rect);
     }
+    sprite.set_alpha(1.0f);
+  }
   else
-    {
-      Box::draw_button_neutral(rect);
-      sprite.set_alpha(0.3f);
-    }
+  {
+    Box::draw_button_neutral(rect);
+    sprite.set_alpha(0.3f);
+  }
   sprite.draw((rect.get_width()+1)/2, (rect.get_height()+1)/2);
   CL_Display::pop_modelview();
 }
@@ -112,25 +112,25 @@
 IconImpl::mouse_up  (const CL_InputEvent&amp; event)
 {
   if (is_enabled)
+  {
+    down         = false;
+    parent-&gt;release_mouse();  
+
+    if (parent-&gt;has_mouse_over())
     {
-      down         = false;
-      parent-&gt;release_mouse();  
-
-      if (parent-&gt;has_mouse_over())
-        {
-          sig_on_click();
-        }
+      sig_on_click();
     }
+  }
 }
 
 void
 IconImpl::mouse_down(const CL_InputEvent&amp; event)
 {
   if (is_enabled)
-    {
-      down         = true;
-      parent-&gt;capture_mouse();
-    }
+  {
+    down         = true;
+    parent-&gt;capture_mouse();
+  }
 }
 
 void 

Modified: trunk/flexlay/lib/layer.cpp
===================================================================
--- trunk/flexlay/lib/layer.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/layer.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -37,19 +37,19 @@
 Layer::draw(EditorMapComponent* parent, CL_GraphicContext* gc) 
 { 
   if (impl.get())
+  {
+    if (impl-&gt;pos.x != 0 || impl-&gt;pos.y != 0)
     {
-      if (impl-&gt;pos.x != 0 || impl-&gt;pos.y != 0)
-        {
-          gc-&gt;push_modelview();
-          gc-&gt;add_translate(impl-&gt;pos.x, impl-&gt;pos.y);
-          impl-&gt;draw(parent, gc);
-          gc-&gt;pop_modelview();
-        }
-      else
-        {
-          impl-&gt;draw(parent, gc);
-        }
+      gc-&gt;push_modelview();
+      gc-&gt;add_translate(impl-&gt;pos.x, impl-&gt;pos.y);
+      impl-&gt;draw(parent, gc);
+      gc-&gt;pop_modelview();
     }
+    else
+    {
+      impl-&gt;draw(parent, gc);
+    }
+  }
 }
   
 bool
@@ -67,13 +67,13 @@
   CL_Rect rect;
   
   if (impl.get())
-    {
-      rect = impl-&gt;get_bounding_rect();
-      rect.left   += static_cast&lt;int&gt;(impl-&gt;pos.x);
-      rect.top    += static_cast&lt;int&gt;(impl-&gt;pos.y);
-      rect.right  += static_cast&lt;int&gt;(impl-&gt;pos.x);
-      rect.bottom += static_cast&lt;int&gt;(impl-&gt;pos.y);
-    }
+  {
+    rect = impl-&gt;get_bounding_rect();
+    rect.left   += static_cast&lt;int&gt;(impl-&gt;pos.x);
+    rect.top    += static_cast&lt;int&gt;(impl-&gt;pos.y);
+    rect.right  += static_cast&lt;int&gt;(impl-&gt;pos.x);
+    rect.bottom += static_cast&lt;int&gt;(impl-&gt;pos.y);
+  }
   
   return rect;
 }

Modified: trunk/flexlay/lib/lispreader.cpp
===================================================================
--- trunk/flexlay/lib/lispreader.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/lispreader.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -73,25 +73,25 @@
 _next_char (lisp_stream_t *stream)
 {
   switch (stream-&gt;type)
-    {
+  {
     case LISP_STREAM_FILE :
       return getc(stream-&gt;v.file);
 
     case LISP_STREAM_STRING :
-      {
-        char c = stream-&gt;v.string.buf[stream-&gt;v.string.pos];
+    {
+      char c = stream-&gt;v.string.buf[stream-&gt;v.string.pos];
 
-        if (c == 0)
-          return EOF;
+      if (c == 0)
+        return EOF;
 
-        ++stream-&gt;v.string.pos;
+      ++stream-&gt;v.string.pos;
 
-        return c;
-      }
+      return c;
+    }
 
     case LISP_STREAM_ANY:
       return stream-&gt;v.any.next_char(stream-&gt;v.any.data);
-    }
+  }
 
   throw LispReaderException(&quot;_next_char()&quot;, __FILE__, __LINE__);
   return EOF;
@@ -101,7 +101,7 @@
 _unget_char (char c, lisp_stream_t *stream)
 {
   switch (stream-&gt;type)
-    {
+  {
     case LISP_STREAM_FILE :
       ungetc(c, stream-&gt;v.file);
       break;
@@ -116,7 +116,7 @@
 
     default :
       throw LispReaderException(&quot;_unget_char()&quot;, __FILE__, __LINE__);
-    }
+  }
 }
 
 static int
@@ -129,24 +129,24 @@
   _token_clear();
 
   do
-    {
-      c = _next_char(stream);
-      if (c == EOF)
-        return TOKEN_EOF;
-      else if (c == ';')     	 /* comment start */
-        while (1)
-          {
-            c = _next_char(stream);
-            if (c == EOF)
-              return TOKEN_EOF;
-            else if (c == '\n')
-              break;
-          }
-    }
+  {
+    c = _next_char(stream);
+    if (c == EOF)
+      return TOKEN_EOF;
+    else if (c == ';')           /* comment start */
+      while (1)
+      {
+        c = _next_char(stream);
+        if (c == EOF)
+          return TOKEN_EOF;
+        else if (c == '\n')
+          break;
+      }
+  }
   while (isspace(c));
 
   switch (c)
-    {
+  {
     case '(' :
       return TOKEN_OPEN_PAREN;
 
@@ -155,33 +155,33 @@
 
     case '&quot;' :
       while (1)
+      {
+        c = _next_char(stream);
+        if (c == EOF)
+          return TOKEN_ERROR;
+        if (c == '&quot;')
+          break;
+        if (c == '\\')
         {
           c = _next_char(stream);
-          if (c == EOF)
-            return TOKEN_ERROR;
-          if (c == '&quot;')
-            break;
-          if (c == '\\')
-            {
-              c = _next_char(stream);
 
-              switch (c)
-                {
-                case EOF :
-                  return TOKEN_ERROR;
+          switch (c)
+          {
+            case EOF :
+              return TOKEN_ERROR;
 
-                case 'n' :
-                  c = '\n';
-                  break;
+            case 'n' :
+              c = '\n';
+              break;
 
-                case 't' :
-                  c = '\t';
-                  break;
-                }
-            }
+            case 't' :
+              c = '\t';
+              break;
+          }
+        }
 
-          _token_append(c);
-        }
+        _token_append(c);
+      }
       return TOKEN_STRING;
 
     case '#' :
@@ -190,7 +190,7 @@
         return TOKEN_ERROR;
 
       switch (c)
-        {
+      {
         case 't' :
           return TOKEN_TRUE;
 
@@ -206,67 +206,67 @@
             return TOKEN_PATTERN_OPEN_PAREN;
           else
             return TOKEN_ERROR;
-        }
+      }
       return TOKEN_ERROR;
 
     default :
       if (isdigit(c) || c == '-')
+      {
+        int have_nondigits = 0;
+        int have_digits = 0;
+        int have_floating_point = 0;
+
+        do
         {
-          int have_nondigits = 0;
-          int have_digits = 0;
-          int have_floating_point = 0;
+          if (isdigit(c))
+            have_digits = 1;
+          else if (c == '.')
+            have_floating_point++;
+          _token_append(c);
 
-          do
-            {
-              if (isdigit(c))
-                have_digits = 1;
-              else if (c == '.')
-                have_floating_point++;
-              _token_append(c);
+          c = _next_char(stream);
 
-              c = _next_char(stream);
+          if (c != EOF &amp;&amp; !isdigit(c) &amp;&amp; !isspace(c) &amp;&amp; c != '.' &amp;&amp; !strchr(delims, c))
+            have_nondigits = 1;
+        }
+        while (c != EOF &amp;&amp; !isspace(c) &amp;&amp; !strchr(delims, c));
 
-              if (c != EOF &amp;&amp; !isdigit(c) &amp;&amp; !isspace(c) &amp;&amp; c != '.' &amp;&amp; !strchr(delims, c))
-                have_nondigits = 1;
-            }
-          while (c != EOF &amp;&amp; !isspace(c) &amp;&amp; !strchr(delims, c));
+        if (c != EOF)
+          _unget_char(c, stream);
 
-          if (c != EOF)
-            _unget_char(c, stream);
-
-          if (have_nondigits || !have_digits || have_floating_point &gt; 1)
-            return TOKEN_SYMBOL;
-          else if (have_floating_point == 1)
-            return TOKEN_REAL;
-          else
-            return TOKEN_INTEGER;
-        }
+        if (have_nondigits || !have_digits || have_floating_point &gt; 1)
+          return TOKEN_SYMBOL;
+        else if (have_floating_point == 1)
+          return TOKEN_REAL;
+        else
+          return TOKEN_INTEGER;
+      }
       else
+      {
+        if (c == '.')
         {
-          if (c == '.')
-            {
-              c = _next_char(stream);
-              if (c != EOF &amp;&amp; !isspace(c) &amp;&amp; !strchr(delims, c))
-                _token_append('.');
-              else
-                {
-                  _unget_char(c, stream);
-                  return TOKEN_DOT;
-                }
-            }
-          do
-            {
-              _token_append(c);
-              c = _next_char(stream);
-            }
-          while (c != EOF &amp;&amp; !isspace(c) &amp;&amp; !strchr(delims, c));
-          if (c != EOF)
+          c = _next_char(stream);
+          if (c != EOF &amp;&amp; !isspace(c) &amp;&amp; !strchr(delims, c))
+            _token_append('.');
+          else
+          {
             _unget_char(c, stream);
-
-          return TOKEN_SYMBOL;
+            return TOKEN_DOT;
+          }
         }
-    }
+        do
+        {
+          _token_append(c);
+          c = _next_char(stream);
+        }
+        while (c != EOF &amp;&amp; !isspace(c) &amp;&amp; !strchr(delims, c));
+        if (c != EOF)
+          _unget_char(c, stream);
 
+        return TOKEN_SYMBOL;
+      }
+  }
+
   throw LispReaderException(&quot;_scan()&quot;, __FILE__, __LINE__);
   return TOKEN_ERROR;
 }
@@ -410,7 +410,7 @@
     return &amp;end_marker;
 
   switch (token)
-    {
+  {
     case TOKEN_ERROR :
       return &amp;error_object;
 
@@ -419,55 +419,55 @@
 
     case TOKEN_OPEN_PAREN :
     case TOKEN_PATTERN_OPEN_PAREN :
+    {
+      lisp_object_t *last = lisp_nil(), *car;
+
+      do
       {
-        lisp_object_t *last = lisp_nil(), *car;
+        car = lisp_read(in);
+        if (car == &amp;error_object || car == &amp;end_marker)
+        {
+          lisp_free(obj);
+          return &amp;error_object;
+        }
+        else if (car == &amp;dot_marker)
+        {
+          if (lisp_nil_p(last))
+          {
+            lisp_free(obj);
+            return &amp;error_object;
+          }
 
-        do
+          car = lisp_read(in);
+          if (car == &amp;error_object || car == &amp;end_marker)
           {
-            car = lisp_read(in);
-            if (car == &amp;error_object || car == &amp;end_marker)
-              {
-                lisp_free(obj);
-                return &amp;error_object;
-              }
-            else if (car == &amp;dot_marker)
-              {
-                if (lisp_nil_p(last))
-                  {
-                    lisp_free(obj);
-                    return &amp;error_object;
-                  }
+            lisp_free(obj);
+            return car;
+          }
+          else
+          {
+            last-&gt;v.cons.cdr = car;
 
-                car = lisp_read(in);
-                if (car == &amp;error_object || car == &amp;end_marker)
-                  {
-                    lisp_free(obj);
-                    return car;
-                  }
-                else
-                  {
-                    last-&gt;v.cons.cdr = car;
+            if (_scan(in) != TOKEN_CLOSE_PAREN)
+            {
+              lisp_free(obj);
+              return &amp;error_object;
+            }
 
-                    if (_scan(in) != TOKEN_CLOSE_PAREN)
-                      {
-                        lisp_free(obj);
-                        return &amp;error_object;
-                      }
-
-                    car = &amp;close_paren_marker;
-                  }
-              }
-            else if (car != &amp;close_paren_marker)
-              {
-                if (lisp_nil_p(last))
-                  obj = last = (token == TOKEN_OPEN_PAREN ? lisp_make_cons(car, lisp_nil()) : lisp_make_pattern_cons(car, lisp_nil()));
-                else
-                  last = last-&gt;v.cons.cdr = lisp_make_cons(car, lisp_nil());
-              }
+            car = &amp;close_paren_marker;
           }
-        while (car != &amp;close_paren_marker);
+        }
+        else if (car != &amp;close_paren_marker)
+        {
+          if (lisp_nil_p(last))
+            obj = last = (token == TOKEN_OPEN_PAREN ? lisp_make_cons(car, lisp_nil()) : lisp_make_pattern_cons(car, lisp_nil()));
+          else
+            last = last-&gt;v.cons.cdr = lisp_make_cons(car, lisp_nil());
+        }
       }
-      return obj;
+      while (car != &amp;close_paren_marker);
+    }
+    return obj;
 
     case TOKEN_CLOSE_PAREN :
       return &amp;close_paren_marker;
@@ -492,7 +492,7 @@
 
     case TOKEN_FALSE :
       return lisp_make_boolean(0);
-    }
+  }
 
   throw LispReaderException(&quot;lisp_read()&quot;, __FILE__, __LINE__);
   return &amp;error_object;
@@ -505,7 +505,7 @@
     return;
 
   switch (obj-&gt;type)
-    {
+  {
     case LISP_TYPE_INTERNAL :
     case LISP_TYPE_PARSE_ERROR :
     case LISP_TYPE_EOF :
@@ -525,7 +525,7 @@
     case LISP_TYPE_PATTERN_VAR :
       lisp_free(obj-&gt;v.pattern.sub);
       break;
-    }
+  }
 
   free(obj);
 }
@@ -546,73 +546,73 @@
     return 1;
 
   switch (lisp_type(*obj))
+  {
+    case LISP_TYPE_PATTERN_CONS :
     {
-    case LISP_TYPE_PATTERN_CONS :
+      struct
       {
-        struct
-          {
-            char *name;
-            int type;
-          }
-        types[] =
-          {
-            { &quot;any&quot;, LISP_PATTERN_ANY },
-            { &quot;symbol&quot;, LISP_PATTERN_SYMBOL },
-            { &quot;string&quot;, LISP_PATTERN_STRING },
-            { &quot;integer&quot;, LISP_PATTERN_INTEGER },
-            { &quot;real&quot;, LISP_PATTERN_REAL },
-            { &quot;boolean&quot;, LISP_PATTERN_BOOLEAN },
-            { &quot;list&quot;, LISP_PATTERN_LIST },
-            { &quot;or&quot;, LISP_PATTERN_OR },
-            { 0, 0 }
-          };
-        char *type_name;
+        char *name;
         int type;
-        int i;
-        lisp_object_t *pattern;
-        type = -1;
-	
-        if (lisp_type(lisp_car(*obj)) != LISP_TYPE_SYMBOL)
-          return 0;
+      }
+      types[] =
+        {
+          { &quot;any&quot;, LISP_PATTERN_ANY },
+          { &quot;symbol&quot;, LISP_PATTERN_SYMBOL },
+          { &quot;string&quot;, LISP_PATTERN_STRING },
+          { &quot;integer&quot;, LISP_PATTERN_INTEGER },
+          { &quot;real&quot;, LISP_PATTERN_REAL },
+          { &quot;boolean&quot;, LISP_PATTERN_BOOLEAN },
+          { &quot;list&quot;, LISP_PATTERN_LIST },
+          { &quot;or&quot;, LISP_PATTERN_OR },
+          { 0, 0 }
+        };
+      char *type_name;
+      int type;
+      int i;
+      lisp_object_t *pattern;
+      type = -1;
+        
+      if (lisp_type(lisp_car(*obj)) != LISP_TYPE_SYMBOL)
+        return 0;
 
-        type_name = lisp_symbol(lisp_car(*obj));
-        for (i = 0; types[i].name != 0; ++i)
-          {
-            if (strcmp(types[i].name, type_name) == 0)
-              {
-                type = types[i].type;
-                break;
-              }
-          }
+      type_name = lisp_symbol(lisp_car(*obj));
+      for (i = 0; types[i].name != 0; ++i)
+      {
+        if (strcmp(types[i].name, type_name) == 0)
+        {
+          type = types[i].type;
+          break;
+        }
+      }
 
-        if (types[i].name == 0)
-          return 0;
+      if (types[i].name == 0)
+        return 0;
 
-        if (type != LISP_PATTERN_OR &amp;&amp; lisp_cdr(*obj) != 0)
-          return 0;
+      if (type != LISP_PATTERN_OR &amp;&amp; lisp_cdr(*obj) != 0)
+        return 0;
 
-        pattern = lisp_make_pattern_var(type, (*index)++, lisp_nil());
+      pattern = lisp_make_pattern_var(type, (*index)++, lisp_nil());
 
-        if (type == LISP_PATTERN_OR)
-          {
-            lisp_object_t *cdr = lisp_cdr(*obj);
+      if (type == LISP_PATTERN_OR)
+      {
+        lisp_object_t *cdr = lisp_cdr(*obj);
 
-            if (!_compile_pattern(&amp;cdr, index))
-              {
-                lisp_free(pattern);
-                return 0;
-              }
+        if (!_compile_pattern(&amp;cdr, index))
+        {
+          lisp_free(pattern);
+          return 0;
+        }
 
-            pattern-&gt;v.pattern.sub = cdr;
+        pattern-&gt;v.pattern.sub = cdr;
 
-            (*obj)-&gt;v.cons.cdr = lisp_nil();
-          }
+        (*obj)-&gt;v.cons.cdr = lisp_nil();
+      }
 
-        lisp_free(*obj);
+      lisp_free(*obj);
 
-        *obj = pattern;
-      }
-      break;
+      *obj = pattern;
+    }
+    break;
 
     case LISP_TYPE_CONS :
       if (!_compile_pattern(&amp;(*obj)-&gt;v.cons.car, index))
@@ -620,7 +620,7 @@
       if (!_compile_pattern(&amp;(*obj)-&gt;v.cons.cdr, index))
         return 0;
       break;
-    }
+  }
 
   return 1;
 }
@@ -648,7 +648,7 @@
     throw LispReaderException(&quot;_match_pattern_var&quot;, __FILE__, __LINE__);
 
   switch (pattern-&gt;v.pattern.type)
-    {
+  {
     case LISP_PATTERN_ANY :
       break;
 
@@ -683,27 +683,27 @@
       break;
 
     case LISP_PATTERN_OR :
+    {
+      lisp_object_t *sub;
+      int matched = 0;
+
+      for (sub = pattern-&gt;v.pattern.sub; sub != 0; sub = lisp_cdr(sub))
       {
-        lisp_object_t *sub;
-        int matched = 0;
+        if (lisp_type(sub) != LISP_TYPE_CONS)
+          throw LispReaderException(&quot;_match_pattern_var()&quot;, __FILE__, __LINE__);
 
-        for (sub = pattern-&gt;v.pattern.sub; sub != 0; sub = lisp_cdr(sub))
-          {
-            if (lisp_type(sub) != LISP_TYPE_CONS)
-              throw LispReaderException(&quot;_match_pattern_var()&quot;, __FILE__, __LINE__);
+        if (_match_pattern(lisp_car(sub), obj, vars))
+          matched = 1;
+      }
 
-            if (_match_pattern(lisp_car(sub), obj, vars))
-              matched = 1;
-          }
+      if (!matched)
+        return 0;
+    }
+    break;
 
-        if (!matched)
-          return 0;
-      }
-      break;
-
     default :
       throw LispReaderException(&quot;_match_pattern_var()&quot;, __FILE__, __LINE__);
-    }
+  }
 
   if (vars != 0)
     vars[pattern-&gt;v.pattern.index] = obj;
@@ -727,7 +727,7 @@
     return 0;
 
   switch (lisp_type(pattern))
-    {
+  {
     case LISP_TYPE_SYMBOL :
       return strcmp(lisp_symbol(pattern), lisp_symbol(obj)) == 0;
 
@@ -741,19 +741,19 @@
       return lisp_real(pattern) == lisp_real(obj);
 
     case LISP_TYPE_CONS :
-      {
-        int result1, result2;
+    {
+      int result1, result2;
 
-        result1 = _match_pattern(lisp_car(pattern), lisp_car(obj), vars);
-        result2 = _match_pattern(lisp_cdr(pattern), lisp_cdr(obj), vars);
+      result1 = _match_pattern(lisp_car(pattern), lisp_car(obj), vars);
+      result2 = _match_pattern(lisp_cdr(pattern), lisp_cdr(obj), vars);
 
-        return result1 &amp;&amp; result2;
-      }
-      break;
+      return result1 &amp;&amp; result2;
+    }
+    break;
 
     default :
       throw LispReaderException(&quot;_match_pattern()&quot;, __FILE__, __LINE__);
-    }
+  }
 
   return 0;
 }
@@ -784,10 +784,10 @@
     return 0;
 
   if (!lisp_compile_pattern(&amp;pattern, &amp;num_subs))
-    {
-      lisp_free(pattern);
-      return 0;
-    }
+  {
+    lisp_free(pattern);
+    return 0;
+  }
 
   result = lisp_match_pattern(pattern, obj, vars, num_subs);
 
@@ -891,13 +891,13 @@
   int length = 0;
 
   while (obj != 0)
-    {
-      if (obj-&gt;type != LISP_TYPE_CONS &amp;&amp; obj-&gt;type != LISP_TYPE_PATTERN_CONS)
-        throw LispReaderException(&quot;lisp_list_length()&quot;, __FILE__, __LINE__);
+  {
+    if (obj-&gt;type != LISP_TYPE_CONS &amp;&amp; obj-&gt;type != LISP_TYPE_PATTERN_CONS)
+      throw LispReaderException(&quot;lisp_list_length()&quot;, __FILE__, __LINE__);
 
-      ++length;
-      obj = obj-&gt;v.cons.cdr;
-    }
+    ++length;
+    obj = obj-&gt;v.cons.cdr;
+  }
 
   return length;
 }
@@ -906,15 +906,15 @@
 lisp_list_nth_cdr (lisp_object_t *obj, int index)
 {
   while (index &gt; 0)
-    {
-      if (obj == 0)
-        throw LispReaderException(&quot;lisp_list_nth_cdr()&quot;, __FILE__, __LINE__);
-      if (obj-&gt;type != LISP_TYPE_CONS &amp;&amp; obj-&gt;type != LISP_TYPE_PATTERN_CONS)
-        throw LispReaderException(&quot;lisp_list_nth_cdr()&quot;, __FILE__, __LINE__);
+  {
+    if (obj == 0)
+      throw LispReaderException(&quot;lisp_list_nth_cdr()&quot;, __FILE__, __LINE__);
+    if (obj-&gt;type != LISP_TYPE_CONS &amp;&amp; obj-&gt;type != LISP_TYPE_PATTERN_CONS)
+      throw LispReaderException(&quot;lisp_list_nth_cdr()&quot;, __FILE__, __LINE__);
 
-      --index;
-      obj = obj-&gt;v.cons.cdr;
-    }
+    --index;
+    obj = obj-&gt;v.cons.cdr;
+  }
 
   return obj;
 }
@@ -934,13 +934,13 @@
 lisp_dump (lisp_object_t *obj, FILE *out)
 {
   if (obj == 0)
-    {
-      fprintf(out, &quot;()&quot;);
-      return;
-    }
+  {
+    fprintf(out, &quot;()&quot;);
+    return;
+  }
 
   switch (lisp_type(obj))
-    {
+  {
     case LISP_TYPE_EOF :
       fputs(&quot;#&lt;eof&gt;&quot;, out);
       break;
@@ -962,40 +962,40 @@
       break;
 
     case LISP_TYPE_STRING :
+    {
+      char *p;
+
+      fputc('&quot;', out);
+      for (p = lisp_string(obj); *p != 0; ++p)
       {
-        char *p;
-
-        fputc('&quot;', out);
-        for (p = lisp_string(obj); *p != 0; ++p)
-          {
-            if (*p == '&quot;' || *p == '\\')
-              fputc('\\', out);
-            fputc(*p, out);
-          }
-        fputc('&quot;', out);
+        if (*p == '&quot;' || *p == '\\')
+          fputc('\\', out);
+        fputc(*p, out);
       }
-      break;
+      fputc('&quot;', out);
+    }
+    break;
 
     case LISP_TYPE_CONS :
     case LISP_TYPE_PATTERN_CONS :
       fputs(lisp_type(obj) == LISP_TYPE_CONS ? &quot;(&quot; : &quot;#?(&quot;, out);
       while (obj != 0)
+      {
+        lisp_dump(lisp_car(obj), out);
+        obj = lisp_cdr(obj);
+        if (obj != 0)
         {
-          lisp_dump(lisp_car(obj), out);
-          obj = lisp_cdr(obj);
-          if (obj != 0)
-            {
-              if (lisp_type(obj) != LISP_TYPE_CONS
-                  &amp;&amp; lisp_type(obj) != LISP_TYPE_PATTERN_CONS)
-                {
-                  fputs(&quot; . &quot;, out);
-                  lisp_dump(obj, out);
-                  break;
-                }
-              else
-                fputc(' ', out);
-            }
+          if (lisp_type(obj) != LISP_TYPE_CONS
+              &amp;&amp; lisp_type(obj) != LISP_TYPE_PATTERN_CONS)
+          {
+            fputs(&quot; . &quot;, out);
+            lisp_dump(obj, out);
+            break;
+          }
+          else
+            fputc(' ', out);
         }
+      }
       fputc(')', out);
       break;
 
@@ -1008,13 +1008,13 @@
 
     default :
       throw LispReaderException(&quot;lisp_dump()&quot;, __FILE__, __LINE__);
-    }
+  }
 }
 
 using namespace std;
 
 LispReader::LispReader (lisp_object_t* l)
-    : lst (l)
+  : lst (l)
 {
   //std::cout &lt;&lt; &quot;LispReader: &quot; &lt;&lt; std::flush;
   //lisp_dump(lst, stdout);
@@ -1028,25 +1028,25 @@
   lisp_object_t* cursor = lst;
 
   while(!lisp_nil_p(cursor))
+  {
+    lisp_object_t* cur = lisp_car(cursor);
+
+    if (!lisp_cons_p(cur) || !lisp_symbol_p (lisp_car(cur)))
     {
-      lisp_object_t* cur = lisp_car(cursor);
+      lisp_dump(cur, stdout);
+      //throw ConstruoError (std::string(&quot;LispReader: Read error in search_for &quot;) + name);
+      printf(&quot;LispReader: Read error in search\n&quot;);
+    }
+    else
+    {
+      if (strcmp(lisp_symbol(lisp_car(cur)), name) == 0)
+      {
+        return lisp_cdr(cur);
+      }
+    }
 
-      if (!lisp_cons_p(cur) || !lisp_symbol_p (lisp_car(cur)))
-        {
-          lisp_dump(cur, stdout);
-          //throw ConstruoError (std::string(&quot;LispReader: Read error in search_for &quot;) + name);
-	  printf(&quot;LispReader: Read error in search\n&quot;);
-        }
-      else
-        {
-          if (strcmp(lisp_symbol(lisp_car(cur)), name) == 0)
-            {
-              return lisp_cdr(cur);
-            }
-        }
-
-      cursor = lisp_cdr (cursor);
-    }
+    cursor = lisp_cdr (cursor);
+  }
   return 0;
 }
 
@@ -1055,15 +1055,15 @@
 {
   lisp_object_t* obj = search_for (name);
   if (obj)
+  {
+    if (!lisp_integer_p(lisp_car(obj)))
     {
-      if (!lisp_integer_p(lisp_car(obj)))
-      {
-        //st_abort(&quot;LispReader expected type integer at token: &quot;, name); /* Instead of giving up, we return with false now. */
-	return false;
-	}
-      *i = lisp_integer(lisp_car(obj));
-      return true;
+      //st_abort(&quot;LispReader expected type integer at token: &quot;, name); /* Instead of giving up, we return with false now. */
+      return false;
     }
+    *i = lisp_integer(lisp_car(obj));
+    return true;
+  }
   return false;
 }
 
@@ -1072,10 +1072,10 @@
 {
   lisp_object_t* obj = search_for (name);
   if (obj)
-    {
-      *b = obj;
-      return true;
-    }
+  {
+    *b = obj;
+    return true;
+  }
   else
     return false;
 }
@@ -1085,13 +1085,13 @@
 {
   lisp_object_t* obj = search_for (name);
   if (obj)
-    {
-      if (!lisp_real_p(lisp_car(obj)) &amp;&amp; !lisp_integer_p(lisp_car(obj)))
-        throw LispReaderException(&quot;LispReader expected type real at token: &quot;,
-                                  __FILE__, __LINE__);
-      *f = lisp_real(lisp_car(obj));
-      return true;
-    }
+  {
+    if (!lisp_real_p(lisp_car(obj)) &amp;&amp; !lisp_integer_p(lisp_car(obj)))
+      throw LispReaderException(&quot;LispReader expected type real at token: &quot;,
+                                __FILE__, __LINE__);
+    *f = lisp_real(lisp_car(obj));
+    return true;
+  }
   return false;
 }
 
@@ -1100,16 +1100,16 @@
 {
   lisp_object_t* obj = search_for (name);
   if (obj)
+  {
+    while(!lisp_nil_p(obj))
     {
-      while(!lisp_nil_p(obj))
-        {
-          if (!lisp_string_p(lisp_car(obj)))
-            throw LispReaderException(&quot;LispReader expected type string at token: &quot;, name);
-          vec-&gt;push_back(lisp_string(lisp_car(obj)));
-          obj = lisp_cdr(obj);
-        }
-      return true;
+      if (!lisp_string_p(lisp_car(obj)))
+        throw LispReaderException(&quot;LispReader expected type string at token: &quot;, name);
+      vec-&gt;push_back(lisp_string(lisp_car(obj)));
+      obj = lisp_cdr(obj);
     }
+    return true;
+  }
   return false;    
 }
 
@@ -1118,16 +1118,16 @@
 {
   lisp_object_t* obj = search_for (name);
   if (obj)
+  {
+    while(!lisp_nil_p(obj))
     {
-      while(!lisp_nil_p(obj))
-        {
-          if (!lisp_integer_p(lisp_car(obj)))
-            throw LispReaderException(&quot;LispReader expected type integer at token: &quot;, name);
-          vec-&gt;push_back(lisp_integer(lisp_car(obj)));
-          obj = lisp_cdr(obj);
-        }
-      return true;
+      if (!lisp_integer_p(lisp_car(obj)))
+        throw LispReaderException(&quot;LispReader expected type integer at token: &quot;, name);
+      vec-&gt;push_back(lisp_integer(lisp_car(obj)));
+      obj = lisp_cdr(obj);
     }
+    return true;
+  }
   return false;    
 }
 
@@ -1136,14 +1136,14 @@
 {
   lisp_object_t* obj = search_for (name);
   if (obj)
+  {
+    while(!lisp_nil_p(obj))
     {
-      while(!lisp_nil_p(obj))
-        {
-          vec-&gt;push_back(*lisp_string(lisp_car(obj)));
-          obj = lisp_cdr(obj);
-        }
-      return true;
+      vec-&gt;push_back(*lisp_string(lisp_car(obj)));
+      obj = lisp_cdr(obj);
     }
+    return true;
+  }
   return false;    
 }
 
@@ -1152,12 +1152,12 @@
 {
   lisp_object_t* obj = search_for (name);
   if (obj)
-    {
-      if (!lisp_string_p(lisp_car(obj)))
-        throw LispReaderException(&quot;LispReader expected type string at token: &quot;, name);
-     *str = lisp_string(lisp_car(obj));
-      return true;
-    }
+  {
+    if (!lisp_string_p(lisp_car(obj)))
+      throw LispReaderException(&quot;LispReader expected type string at token: &quot;, name);
+    *str = lisp_string(lisp_car(obj));
+    return true;
+  }
   return false;  
 }
 
@@ -1166,12 +1166,12 @@
 {
   lisp_object_t* obj = search_for (name);
   if (obj)
-    {
-      if (!lisp_boolean_p(lisp_car(obj)))
-        throw LispReaderException(&quot;LispReader expected type bool at token: &quot;);
-      *b = lisp_boolean(lisp_car(obj));
-      return true;
-    }
+  {
+    if (!lisp_boolean_p(lisp_car(obj)))
+      throw LispReaderException(&quot;LispReader expected type bool at token: &quot;);
+    *b = lisp_boolean(lisp_car(obj));
+    return true;
+  }
   return false;
 }
 
@@ -1247,9 +1247,9 @@
 
   for(std::vector&lt;lisp_object_t*&gt;::reverse_iterator i = lisp_objs.rbegin ();
       i != lisp_objs.rend (); ++i)
-    {
-      lisp_obj = lisp_make_cons (*i, lisp_obj);
-    }
+  {
+    lisp_obj = lisp_make_cons (*i, lisp_obj);
+  }
   lisp_objs.clear();
 
   return lisp_obj;
@@ -1281,28 +1281,28 @@
   gzFile in = gzopen(filename, &quot;r&quot;);
 
   while (!done)
+  {
+    int ret = gzread(in, buf + buf_pos, chunk_size);
+    if (ret == -1)
     {
-      int ret = gzread(in, buf + buf_pos, chunk_size);
-      if (ret == -1)
-        {
-          free (buf);
-          throw LispReaderException(&quot;Error while reading from file&quot;, __FILE__, __LINE__);
-        }
-      else if (ret == chunk_size) // buffer got full, eof not yet there so resize
-        {
-          buf_pos = chunk_size * try_number;
-          try_number += 1;
-          buf = static_cast&lt;char*&gt;(realloc(buf, chunk_size * try_number));
+      free (buf);
+      throw LispReaderException(&quot;Error while reading from file&quot;, __FILE__, __LINE__);
+    }
+    else if (ret == chunk_size) // buffer got full, eof not yet there so resize
+    {
+      buf_pos = chunk_size * try_number;
+      try_number += 1;
+      buf = static_cast&lt;char*&gt;(realloc(buf, chunk_size * try_number));
 
-          if (!buf)
-            throw LispReaderException(&quot;lisp_read_from_gzfile()&quot;, __FILE__, __LINE__);
-        }
-      else 
-        {
-          // everything fine, encountered EOF 
-          done = true;
-        }
+      if (!buf)
+        throw LispReaderException(&quot;lisp_read_from_gzfile()&quot;, __FILE__, __LINE__);
     }
+    else 
+    {
+      // everything fine, encountered EOF 
+      done = true;
+    }
+  }
       
   lisp_stream_t stream;
   lisp_stream_init_string (&amp;stream, buf);
@@ -1322,13 +1322,13 @@
   const char* data_suffix = (data + data_len - suffix_len);
 
   if (data_suffix &gt;= data)
-    {
-      return (strcmp(data_suffix, suffix) == 0);
-    }
+  {
+    return (strcmp(data_suffix, suffix) == 0);
+  }
   else
-    {
-      return false;
-    }
+  {
+    return false;
+  }
 }
 
 lisp_object_t* lisp_read_from_file(const std::string&amp; filename)
@@ -1336,23 +1336,23 @@
   lisp_stream_t stream;
 
   if (has_suffix(filename.c_str(), &quot;.gz&quot;))
+  {
+    return lisp_read_from_gzfile(filename.c_str());
+  }
+  else
+  {
+    lisp_object_t* obj = 0;
+    FILE* in = fopen(filename.c_str(), &quot;r&quot;);
+
+    if (in)
     {
-      return lisp_read_from_gzfile(filename.c_str());
+      lisp_stream_init_file(&amp;stream, in);
+      obj = lisp_read(&amp;stream);
+      fclose(in);
     }
-  else
-    {
-      lisp_object_t* obj = 0;
-      FILE* in = fopen(filename.c_str(), &quot;r&quot;);
 
-      if (in)
-        {
-          lisp_stream_init_file(&amp;stream, in);
-          obj = lisp_read(&amp;stream);
-          fclose(in);
-        }
-
-      return obj;
-    }
+    return obj;
+  }
 }
 
 // EOF //

Modified: trunk/flexlay/lib/lispreader.hpp
===================================================================
--- trunk/flexlay/lib/lispreader.hpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/lispreader.hpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -58,19 +58,19 @@
 
 class LispReaderException : public std::exception
 {
-  public:
-    LispReaderException(const char* _message, const char* _file = &quot;&quot;, const unsigned int _line = 0)
-      : message(_message), file(_file), line(_line) { };
-    virtual ~LispReaderException() throw() { };
+public:
+  LispReaderException(const char* _message, const char* _file = &quot;&quot;, const unsigned int _line = 0)
+    : message(_message), file(_file), line(_line) { };
+  virtual ~LispReaderException() throw() { };
 
-    const char* what() const throw() { return message; };
-    const char* what_file() const throw() { return file; };
-    const unsigned int what_line() const throw() { return line; };
+  const char* what() const throw() { return message; };
+  const char* what_file() const throw() { return file; };
+  const unsigned int what_line() const throw() { return line; };
     
-  private:
-    const char* message;
-    const char* file;
-    const unsigned int line;
+private:
+  const char* message;
+  const char* file;
+  const unsigned int line;
 };
 
 typedef struct
@@ -85,17 +85,17 @@
       char *buf;
       int pos;
     }
-    string;
+      string;
     struct
     {
       void *data;
       int (*next_char) (void *data);
       void (*unget_char) (char c, void *data);
     }
-    any;
+      any;
   } v;
 }
-lisp_stream_t;
+  lisp_stream_t;
 
 typedef struct _lisp_object_t lisp_object_t;
 struct _lisp_object_t
@@ -109,7 +109,7 @@
       struct _lisp_object_t *car;
       struct _lisp_object_t *cdr;
     }
-    cons;
+      cons;
 
     char *string;
     int integer;
@@ -121,7 +121,7 @@
       int index;
       struct _lisp_object_t *sub;
     }
-    pattern;
+      pattern;
   } v;
 };
 

Modified: trunk/flexlay/lib/marker_stroke_drawer.cpp
===================================================================
--- trunk/flexlay/lib/marker_stroke_drawer.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/marker_stroke_drawer.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -38,75 +38,75 @@
                                                             DrawerProperties::current()-&gt;get_spacing());
 
     if (dabs.size() &gt;= 2)
+    {
+      std::vector&lt;CL_Pointf&gt; normals;
+        
+      if (stroke.get_dab_count() == 2)
       {
-        std::vector&lt;CL_Pointf&gt; normals;
-        
-        if (stroke.get_dab_count() == 2)
-          {
-            normals.push_back(CL_Pointf(1.0f, 1.0f));
-            normals.push_back(CL_Pointf(1.0f, 1.0f));
-          }
-        else if (stroke.get_dab_count() &gt;= 3)
-          {
-            for(Stroke::Dabs::size_type i = 0; i &lt; dabs.size()-1; ++i)
-              {
-                CL_Pointf normal((dabs[i].pos.y - dabs[i+1].pos.y),
-                                 -(dabs[i].pos.x - dabs[i+1].pos.x));
+        normals.push_back(CL_Pointf(1.0f, 1.0f));
+        normals.push_back(CL_Pointf(1.0f, 1.0f));
+      }
+      else if (stroke.get_dab_count() &gt;= 3)
+      {
+        for(Stroke::Dabs::size_type i = 0; i &lt; dabs.size()-1; ++i)
+        {
+          CL_Pointf normal((dabs[i].pos.y - dabs[i+1].pos.y),
+                           -(dabs[i].pos.x - dabs[i+1].pos.x));
 
-                float length = sqrt(normal.x * normal.x + normal.y * normal.y);
+          float length = sqrt(normal.x * normal.x + normal.y * normal.y);
 
-                normal.x /= length;
-                normal.y /= length;
+          normal.x /= length;
+          normal.y /= length;
           
-                normals.push_back(normal);
-              }
+          normals.push_back(normal);
+        }
       
-            normals.push_back(CL_Pointf(1.0f, 1.0f));
-          }
+        normals.push_back(CL_Pointf(1.0f, 1.0f));
+      }
 
-        float len  = DrawerProperties::current()-&gt;get_size() * 8.0f;
-        float len2 = DrawerProperties::current()-&gt;get_size() * 16.0f;
+      float len  = DrawerProperties::current()-&gt;get_size() * 8.0f;
+      float len2 = DrawerProperties::current()-&gt;get_size() * 16.0f;
             
-        glEnable(GL_BLEND);
-        glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );
+      glEnable(GL_BLEND);
+      glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );
 
-        glBegin(GL_QUAD_STRIP);
-        for(unsigned int j = 0; j &lt; dabs.size()-2; ++j)
-          {
-            glColor4ub(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
-            glVertex2f(dabs[j].pos.x + normals[j].x * len,
-                       dabs[j].pos.y + normals[j].y * len);
+      glBegin(GL_QUAD_STRIP);
+      for(unsigned int j = 0; j &lt; dabs.size()-2; ++j)
+      {
+        glColor4ub(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
+        glVertex2f(dabs[j].pos.x + normals[j].x * len,
+                   dabs[j].pos.y + normals[j].y * len);
 
-            glColor4ub(color.get_red(), color.get_green(), color.get_blue(), 0);
-            glVertex2f(dabs[j].pos.x + normals[j].x * len2,
-                       dabs[j].pos.y + normals[j].y * len2);
-          }
-        glEnd();
+        glColor4ub(color.get_red(), color.get_green(), color.get_blue(), 0);
+        glVertex2f(dabs[j].pos.x + normals[j].x * len2,
+                   dabs[j].pos.y + normals[j].y * len2);
+      }
+      glEnd();
 
-        glBegin(GL_QUAD_STRIP);
-        for(unsigned int j = 0; j &lt; dabs.size()-2; ++j)
-          {
-            glColor4ub(color.get_red(), color.get_green(), color.get_blue(), 0);
-            glVertex2f(dabs[j].pos.x - normals[j].x * len2,
-                       dabs[j].pos.y - normals[j].y * len2);
+      glBegin(GL_QUAD_STRIP);
+      for(unsigned int j = 0; j &lt; dabs.size()-2; ++j)
+      {
+        glColor4ub(color.get_red(), color.get_green(), color.get_blue(), 0);
+        glVertex2f(dabs[j].pos.x - normals[j].x * len2,
+                   dabs[j].pos.y - normals[j].y * len2);
 
-            glColor4ub(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
-            glVertex2f(dabs[j].pos.x - normals[j].x * len,
-                       dabs[j].pos.y - normals[j].y * len);
-          }
-        glEnd();
-
-        glBegin(GL_QUAD_STRIP);
         glColor4ub(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
-        for(unsigned int j = 0; j &lt; dabs.size()-2; ++j)
-          {
-            glVertex2f(dabs[j].pos.x + normals[j].x * len,
-                       dabs[j].pos.y + normals[j].y * len);
-            glVertex2f(dabs[j].pos.x - normals[j].x * len,
-                       dabs[j].pos.y - normals[j].y * len);
-          }
-        glEnd();
+        glVertex2f(dabs[j].pos.x - normals[j].x * len,
+                   dabs[j].pos.y - normals[j].y * len);
       }
+      glEnd();
+
+      glBegin(GL_QUAD_STRIP);
+      glColor4ub(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
+      for(unsigned int j = 0; j &lt; dabs.size()-2; ++j)
+      {
+        glVertex2f(dabs[j].pos.x + normals[j].x * len,
+                   dabs[j].pos.y + normals[j].y * len);
+        glVertex2f(dabs[j].pos.x - normals[j].x * len,
+                   dabs[j].pos.y - normals[j].y * len);
+      }
+      glEnd();
+    }
   }
 
   StrokeDrawerImpl* clone() const 

Modified: trunk/flexlay/lib/menu.cpp
===================================================================
--- trunk/flexlay/lib/menu.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/menu.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -113,9 +113,9 @@
       CL_Display::fill_rect(CL_Rect(CL_Point(x, y-2), CL_Size(parent-&gt;get_width() - 7, 18)), 
                             CL_Color(255, 255, 255));
     if (sprite)
-      {
-        sprite.draw(x+10, y+7);
-      }
+    {
+      sprite.draw(x+10, y+7);
+    }
     Fonts::verdana11.draw(x+24, y, text);
   }
   int get_width()  { return Fonts::verdana11.bounding_rect(0, 0, text).get_width() + 16; }
@@ -212,13 +212,13 @@
   int y_pos = 6;
 
   for(int i = 0; i &lt; int(items.size()); ++i)
-    {
-      if (i == current_item)
-        items[i]-&gt;draw(x_pos, y_pos, true);
-      else
-        items[i]-&gt;draw(x_pos, y_pos, false);
-      y_pos += items[i]-&gt;get_height() + 6;
-    }
+  {
+    if (i == current_item)
+      items[i]-&gt;draw(x_pos, y_pos, true);
+    else
+      items[i]-&gt;draw(x_pos, y_pos, false);
+    y_pos += items[i]-&gt;get_height() + 6;
+  }
   CL_Display::pop_modelview();
 }
 
@@ -238,9 +238,9 @@
 MenuImpl::on_mouse_down(const CL_InputEvent&amp; event)
 {
   if (current_item != -1)
-    {
-      items[current_item]-&gt;sig_clicked()();
-    }
+  {
+    items[current_item]-&gt;sig_clicked()();
+  }
   parent-&gt;release_mouse();
   parent-&gt;show(false);
 }
@@ -249,24 +249,24 @@
 MenuImpl::on_mouse_move(const CL_InputEvent&amp; event)
 {
   if (parent-&gt;has_mouse_over())
+  {
+    int y_pos = 6;
+
+    for(int i = 0; i &lt; int(items.size()); ++i)
     {
-      int y_pos = 6;
-
-      for(int i = 0; i &lt; int(items.size()); ++i)
-        {
-          y_pos += items[i]-&gt;get_height() + 6;      
-          if (y_pos &gt; event.mouse_pos.y)
-            {
-              current_item = i;
-              return;
-            }
-        }
-      current_item = -1;
+      y_pos += items[i]-&gt;get_height() + 6;      
+      if (y_pos &gt; event.mouse_pos.y)
+      {
+        current_item = i;
+        return;
+      }
     }
+    current_item = -1;
+  }
   else
-    {
-      current_item = -1;
-    }
+  {
+    current_item = -1;
+  }
 }
 
 CL_Signal_v0&amp;
@@ -280,11 +280,11 @@
 {
   // FIXME: Make menu act sane on == 0 items
   if (impl-&gt;items.size() &gt; 0)
-    {
-      show(true);
-      capture_mouse();
-      raise();
-    }
+  {
+    show(true);
+    capture_mouse();
+    raise();
+  }
 }
 
 /* EOF */

Modified: trunk/flexlay/lib/minimap.cpp
===================================================================
--- trunk/flexlay/lib/minimap.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/minimap.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -73,65 +73,65 @@
   // FIXME: Do this only on map changes
   if (impl-&gt;last_serial != impl-&gt;parent-&gt;get_workspace().get_map().get_serial())
     //      || editor_map != parent-&gt;get_workspace().get_map())
-    {
-      impl-&gt;update_minimap_surface();
-      impl-&gt;last_serial = impl-&gt;parent-&gt;get_workspace().get_map().get_serial();
-      impl-&gt;editor_map  = impl-&gt;parent-&gt;get_workspace().get_map();
-    }
+  {
+    impl-&gt;update_minimap_surface();
+    impl-&gt;last_serial = impl-&gt;parent-&gt;get_workspace().get_map().get_serial();
+    impl-&gt;editor_map  = impl-&gt;parent-&gt;get_workspace().get_map();
+  }
 
   if (1)
-    { // Draw background color
-      CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
-                                    CL_Size(get_width(),
-                                            get_height())),
-                            CL_Color(200, 200, 200, 225));
-    }
+  { // Draw background color
+    CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
+                                  CL_Size(get_width(),
+                                          get_height())),
+                          CL_Color(200, 200, 200, 225));
+  }
 
   // FIXME: This doesn't work all that well
   TilemapLayer tilemap = TilemapLayer::current();
 
   if (!tilemap.is_null() &amp;&amp; tilemap.get_height() != 0 &amp;&amp; tilemap.get_width() != 0)
-    {
-      int tile_size = tilemap.get_tileset().get_tile_size();
+  {
+    int tile_size = tilemap.get_tileset().get_tile_size();
 
-      int map_width  = tilemap.get_width()  * tile_size;
-      int map_height = tilemap.get_height() * tile_size;
+    int map_width  = tilemap.get_width()  * tile_size;
+    int map_height = tilemap.get_height() * tile_size;
 
-      CL_Size small_tile(tile_size * get_width() / map_width + 1,
-                         tile_size * get_height() / map_height + 1);
+    CL_Size small_tile(tile_size * get_width() / map_width + 1,
+                       tile_size * get_height() / map_height + 1);
 
-      Field&lt;int&gt;* field = tilemap.get_field();
+    Field&lt;int&gt;* field = tilemap.get_field();
 
-      // FIXME: No current tileset
-      if (0)
+    // FIXME: No current tileset
+    if (0)
+    {
+      for(int y = 0; y &lt; field-&gt;get_height(); ++y)
+        for(int x = 0; x &lt; field-&gt;get_width(); ++x)
         {
-          for(int y = 0; y &lt; field-&gt;get_height(); ++y)
-            for(int x = 0; x &lt; field-&gt;get_width(); ++x)
-              {
-                Tile* tile = tilemap.get_tileset().create(field-&gt;at(x, y));
-                if (tile)
-                  CL_Display::fill_rect(CL_Rect(CL_Point((x * tile_size) * get_width() / map_width,
-                                                         (y * tile_size) * get_height() / map_height),
-                                                small_tile),
-                                        tile-&gt;get_color());
-                CL_Display::flush();
-              }
+          Tile* tile = tilemap.get_tileset().create(field-&gt;at(x, y));
+          if (tile)
+            CL_Display::fill_rect(CL_Rect(CL_Point((x * tile_size) * get_width() / map_width,
+                                                   (y * tile_size) * get_height() / map_height),
+                                          small_tile),
+                                  tile-&gt;get_color());
+          CL_Display::flush();
         }
-      impl-&gt;minimap_surface.draw(CL_Rect(CL_Point(0, 0),
-                                   CL_Size(get_width(), get_height())));
-
-      // Draw cursor
-      CL_Rect rect(impl-&gt;parent-&gt;get_clip_rect());
-      CL_Rect screen_rect(CL_Point(rect.left  * get_width()  / map_width,
-                                   rect.top   * get_height() / map_height),
-                          CL_Size(rect.get_width() * get_width() /map_width,
-                                  rect.get_height()* get_height()/map_height));
-      CL_Display::fill_rect(screen_rect,
-                            CL_Color(255, 255, 0, 50));
-      CL_Display::draw_rect(screen_rect,
-                            CL_Color(0, 0, 0));
     }
+    impl-&gt;minimap_surface.draw(CL_Rect(CL_Point(0, 0),
+                                       CL_Size(get_width(), get_height())));
 
+    // Draw cursor
+    CL_Rect rect(impl-&gt;parent-&gt;get_clip_rect());
+    CL_Rect screen_rect(CL_Point(rect.left  * get_width()  / map_width,
+                                 rect.top   * get_height() / map_height),
+                        CL_Size(rect.get_width() * get_width() /map_width,
+                                rect.get_height()* get_height()/map_height));
+    CL_Display::fill_rect(screen_rect,
+                          CL_Color(255, 255, 0, 50));
+    CL_Display::draw_rect(screen_rect,
+                          CL_Color(0, 0, 0));
+  }
+
   CL_Display::pop_modelview();
   CL_Display::pop_cliprect();
 }
@@ -143,39 +143,39 @@
   TilemapLayer tilemap = TilemapLayer::current();
   
   if (!tilemap.is_null())
-    {
-      Field&lt;int&gt;* field = tilemap.get_field();
+  {
+    Field&lt;int&gt;* field = tilemap.get_field();
 
-      CL_PixelBuffer buffer(tilemap.get_width(), tilemap.get_height(), 
-                            tilemap.get_width()*4, CL_PixelFormat::rgba8888);
+    CL_PixelBuffer buffer(tilemap.get_width(), tilemap.get_height(), 
+                          tilemap.get_width()*4, CL_PixelFormat::rgba8888);
   
-      int map_width  = tilemap.get_width();
-      int map_height = tilemap.get_height();
+    int map_width  = tilemap.get_width();
+    int map_height = tilemap.get_height();
 
-      // FIXME: No Tileset::current()
-      unsigned char* buf = static_cast&lt;unsigned char*&gt;(buffer.get_data());
-      for(int y = 0; y &lt; map_height; ++y)
-        for(int x = 0; x &lt; map_width; ++x)
-          {
-            Tile* tile = tilemap.get_tileset().create(field-&gt;at(x, y));
-            if (tile)
-              {
-                buf[4*(x + y * map_width) + 3] = tile-&gt;get_color().get_red();
-                buf[4*(x + y * map_width) + 2] = tile-&gt;get_color().get_green();
-                buf[4*(x + y * map_width) + 1] = tile-&gt;get_color().get_blue();
-                buf[4*(x + y * map_width) + 0] = tile-&gt;get_color().get_alpha();
-              } 
-            else
-              {
-                buf[4*(x + y * map_width) + 0] = 0;
-                buf[4*(x + y * map_width) + 1] = 0;
-                buf[4*(x + y * map_width) + 2] = 0;
-                buf[4*(x + y * map_width) + 3] = 0;
-              }
-          }
+    // FIXME: No Tileset::current()
+    unsigned char* buf = static_cast&lt;unsigned char*&gt;(buffer.get_data());
+    for(int y = 0; y &lt; map_height; ++y)
+      for(int x = 0; x &lt; map_width; ++x)
+      {
+        Tile* tile = tilemap.get_tileset().create(field-&gt;at(x, y));
+        if (tile)
+        {
+          buf[4*(x + y * map_width) + 3] = tile-&gt;get_color().get_red();
+          buf[4*(x + y * map_width) + 2] = tile-&gt;get_color().get_green();
+          buf[4*(x + y * map_width) + 1] = tile-&gt;get_color().get_blue();
+          buf[4*(x + y * map_width) + 0] = tile-&gt;get_color().get_alpha();
+        } 
+        else
+        {
+          buf[4*(x + y * map_width) + 0] = 0;
+          buf[4*(x + y * map_width) + 1] = 0;
+          buf[4*(x + y * map_width) + 2] = 0;
+          buf[4*(x + y * map_width) + 3] = 0;
+        }
+      }
 
-      minimap_surface = CL_Surface(buffer);
-    }
+    minimap_surface = CL_Surface(buffer);
+  }
 }
 
 void
@@ -184,15 +184,15 @@
   // FIXME: This doesn't work all that well
   TilemapLayer tilemap = TilemapLayer::current();
   if (!tilemap.is_null())
-    {
-      int tile_size  = tilemap.get_tileset().get_tile_size();
-      int map_width  = tilemap.get_width()  * tile_size;
-      int map_height = tilemap.get_height() * tile_size;
+  {
+    int tile_size  = tilemap.get_tileset().get_tile_size();
+    int map_width  = tilemap.get_width()  * tile_size;
+    int map_height = tilemap.get_height() * tile_size;
 
-      if (impl-&gt;drag_active)
-        impl-&gt;parent-&gt;move_to(event.mouse_pos.x * map_width / get_width(),
-                              event.mouse_pos.y * map_height / get_height());
-    }
+    if (impl-&gt;drag_active)
+      impl-&gt;parent-&gt;move_to(event.mouse_pos.x * map_width / get_width(),
+                            event.mouse_pos.y * map_height / get_height());
+  }
 }
 
 void
@@ -201,16 +201,16 @@
   // FIXME: This doesn't work all that well
   TilemapLayer tilemap = TilemapLayer::current();
   if (!tilemap.is_null())
-    {
-      int tile_size  = tilemap.get_tileset().get_tile_size();
-      int map_width  = tilemap.get_width()  * tile_size;
-      int map_height = tilemap.get_height() * tile_size;
+  {
+    int tile_size  = tilemap.get_tileset().get_tile_size();
+    int map_width  = tilemap.get_width()  * tile_size;
+    int map_height = tilemap.get_height() * tile_size;
 
-      impl-&gt;parent-&gt;move_to(event.mouse_pos.x * map_width / get_width(),
-                            event.mouse_pos.y * map_height / get_height());
-      impl-&gt;drag_active = true;
-      capture_mouse();
-    }
+    impl-&gt;parent-&gt;move_to(event.mouse_pos.x * map_width / get_width(),
+                          event.mouse_pos.y * map_height / get_height());
+    impl-&gt;drag_active = true;
+    capture_mouse();
+  }
 }
 
 void
@@ -218,10 +218,10 @@
 {
   TilemapLayer tilemap = TilemapLayer::current();
   if (!tilemap.is_null())
-    {
-      impl-&gt;drag_active = false;
-      release_mouse();
-    }
+  {
+    impl-&gt;drag_active = false;
+    release_mouse();
+  }
 }
 
 void

Modified: trunk/flexlay/lib/object_add_command.cpp
===================================================================
--- trunk/flexlay/lib/object_add_command.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/object_add_command.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -45,10 +45,10 @@
 }
 
 /*int
-ObjectAddCommand::get_handle() const
-{ 
+  ObjectAddCommand::get_handle() const
+  { 
   return impl-&gt;obj-&gt;get_handle(); 
-}*/
+  }*/
 
 void
 ObjectAddCommand::add_object(const ObjMapObject&amp; obj)

Modified: trunk/flexlay/lib/object_delete_command.cpp
===================================================================
--- trunk/flexlay/lib/object_delete_command.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/object_delete_command.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -52,9 +52,9 @@
 ObjectDeleteCommandImpl::execute()
 {
   for(Objects::iterator i = objects.begin(); i != objects.end(); ++i)
-    {
-      object_layer.delete_object(*i);
-    }
+  {
+    object_layer.delete_object(*i);
+  }
 }
 
 void
@@ -67,9 +67,9 @@
 ObjectDeleteCommandImpl::undo()
 {
   for(Objects::iterator i = objects.begin(); i != objects.end(); ++i)
-    {
-      object_layer.add_object(*i);
-    }
+  {
+    object_layer.add_object(*i);
+  }
 }
 
 Command

Modified: trunk/flexlay/lib/object_layer.cpp
===================================================================
--- trunk/flexlay/lib/object_layer.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/object_layer.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -54,16 +54,16 @@
 ObjectLayerImpl::draw(EditorMapComponent* parent, CL_GraphicContext* gc)
 {
   for(ObjectLayer::Objects::iterator i = objects.begin(); i != objects.end(); ++i)
-    {
-      // FIXME: Add clipping here
-      if (parent-&gt;get_clip_rect().is_overlapped((*i).get_bound_rect()))
-        (*i).draw(gc);
-    }
+  {
+    // FIXME: Add clipping here
+    if (parent-&gt;get_clip_rect().is_overlapped((*i).get_bound_rect()))
+      (*i).draw(gc);
+  }
 
   for(ObjectLayer::ControlPoints::iterator i = control_points.begin(); i != control_points.end(); ++i)
-    {
-      (*i).draw(gc);
-    }
+  {
+    (*i).draw(gc);
+  }
 }
 
 ObjMapControlPoint
@@ -72,12 +72,12 @@
   for(ControlPoints::reverse_iterator i = impl-&gt;control_points.rbegin(); 
       i != impl-&gt;control_points.rend(); 
       ++i)
-    {
-      CL_Rect rect = (*i).get_bound_rect();
+  {
+    CL_Rect rect = (*i).get_bound_rect();
      
-      if (rect.is_inside(CL_Point(click_pos)))
-        return *i;
-    }
+    if (rect.is_inside(CL_Point(click_pos)))
+      return *i;
+  }
   return ObjMapControlPoint(); 
 }
 
@@ -85,12 +85,12 @@
 ObjectLayer::find_object(const CL_Pointf&amp; click_pos)
 {
   for(Objects::reverse_iterator i = impl-&gt;objects.rbegin(); i != impl-&gt;objects.rend(); ++i)
-    {
-      CL_Rectf rect = (*i).get_bound_rect();
+  {
+    CL_Rectf rect = (*i).get_bound_rect();
      
-      if (rect.is_inside(CL_Point(click_pos)))
-        return *i;
-    }
+    if (rect.is_inside(CL_Point(click_pos)))
+      return *i;
+  }
   return ObjMapObject();
 }
 
@@ -98,13 +98,13 @@
 ObjectLayer::delete_object(const ObjMapObject&amp; obj)
 {
   for(Objects::iterator i = impl-&gt;objects.begin(); i != impl-&gt;objects.end(); ++i)
+  {
+    if (obj == (*i))
     {
-      if (obj == (*i))
-        {
-          impl-&gt;objects.erase(i);
-          break;
-        }
+      impl-&gt;objects.erase(i);
+      break;
     }
+  }
 }
 
 ObjectLayer::Objects
@@ -113,13 +113,13 @@
   Objects selection;
 
   for(Objects::iterator i = impl-&gt;objects.begin(); i != impl-&gt;objects.end(); ++i)
+  {
+    // FIXME:
+    if (rect.is_inside((*i).get_pos()))
     {
-      // FIXME:
-      if (rect.is_inside((*i).get_pos()))
-        {
-          selection.push_back(*i);
-        }
+      selection.push_back(*i);
     }
+  }
   
   return selection;
 }
@@ -159,12 +159,12 @@
 {
   Objects::size_type i;
   for(i = 0; i &lt; impl-&gt;objects.size(); ++i)
+  {
+    if (impl-&gt;objects[i] == obj)
     {
-      if (impl-&gt;objects[i] == obj)
-        {
-          return i;
-        }
+      return i;
     }
+  }
   return -1;
 }
 
@@ -179,9 +179,9 @@
 {
   int i = get_object_index(obj);
   if (i != -1 &amp;&amp; impl-&gt;objects.size() &gt; 1 &amp;&amp; i &lt; int(impl-&gt;objects.size())-1)
-    {
-      std::swap(impl-&gt;objects[i], impl-&gt;objects[i+1]);
-    }
+  {
+    std::swap(impl-&gt;objects[i], impl-&gt;objects[i+1]);
+  }
 }
 
 void
@@ -189,9 +189,9 @@
 {
   int i = get_object_index(obj);
   if (i != -1 &amp;&amp; i &gt; 0)
-    {
-      std::swap(impl-&gt;objects[i], impl-&gt;objects[i-1]);
-    }
+  {
+    std::swap(impl-&gt;objects[i], impl-&gt;objects[i-1]);
+  }
 }
 
 /* EOF */

Modified: trunk/flexlay/lib/object_move_command.cpp
===================================================================
--- trunk/flexlay/lib/object_move_command.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/object_move_command.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -72,11 +72,11 @@
   for(ObjectMoveCommandImpl::Objects::iterator i = impl-&gt;objects.begin(); 
       i != impl-&gt;objects.end();
       ++i)
-    {
-      i-&gt;new_pos = i-&gt;old_pos + delta;
-      i-&gt;obj.set_pos(i-&gt;new_pos);
-      i-&gt;obj.sig_move()(i-&gt;obj);
-    }
+  {
+    i-&gt;new_pos = i-&gt;old_pos + delta;
+    i-&gt;obj.set_pos(i-&gt;new_pos);
+    i-&gt;obj.sig_move()(i-&gt;obj);
+  }
 }
 
 void
@@ -85,9 +85,9 @@
   for(ObjectMoveCommandImpl::Objects::iterator i = objects.begin(); 
       i != objects.end();
       ++i)
-    {
-      i-&gt;obj.set_pos(i-&gt;new_pos);
-    }  
+  {
+    i-&gt;obj.set_pos(i-&gt;new_pos);
+  }  
 }
 
 void
@@ -96,9 +96,9 @@
   for(ObjectMoveCommandImpl::Objects::iterator i = objects.begin(); 
       i != objects.end();
       ++i)
-    {
-      i-&gt;obj.set_pos(i-&gt;old_pos);
-    }
+  {
+    i-&gt;obj.set_pos(i-&gt;old_pos);
+  }
 }
 
 std::string

Modified: trunk/flexlay/lib/object_selector.cpp
===================================================================
--- trunk/flexlay/lib/object_selector.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/object_selector.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -51,38 +51,38 @@
 ObjectSelector::mouse_up(const CL_InputEvent&amp; event)
 {
   switch(event.id)
+  {
+    case CL_MOUSE_LEFT:
     {
-    case CL_MOUSE_LEFT:
+      if (drag_obj != -1)
       {
-        if (drag_obj != -1)
-          {
-            release_mouse();
+        release_mouse();
       
-            if (!has_mouse_over())
-              {
-                CL_Point screen(event.mouse_pos.x + get_screen_rect().left,
-                                event.mouse_pos.y + get_screen_rect().top);
+        if (!has_mouse_over())
+        {
+          CL_Point screen(event.mouse_pos.x + get_screen_rect().left,
+                          event.mouse_pos.y + get_screen_rect().top);
 
-                CL_Point target(screen.x - EditorMapComponent::current()-&gt;get_screen_rect().left,
-                                screen.y - EditorMapComponent::current()-&gt;get_screen_rect().top);
+          CL_Point target(screen.x - EditorMapComponent::current()-&gt;get_screen_rect().left,
+                          screen.y - EditorMapComponent::current()-&gt;get_screen_rect().top);
       
-                // FIXME: Move this to the scripting layer
-                //ObjectAddCommand command(ObjectLayer::current());
+          // FIXME: Move this to the scripting layer
+          //ObjectAddCommand command(ObjectLayer::current());
 
-                //ObjMapObject obj = brushes[drag_obj].to_sprite_object
-                //(EditorMapComponent::current()-&gt;screen2world(target)).to_object();
+          //ObjMapObject obj = brushes[drag_obj].to_sprite_object
+          //(EditorMapComponent::current()-&gt;screen2world(target)).to_object();
 
-                //command.add_object(obj);
-                //Workspace::current().get_map().execute(command.to_command());
+          //command.add_object(obj);
+          //Workspace::current().get_map().execute(command.to_command());
                 
-                //std::cout &lt;&lt; &quot;C++: Calling on_drop&quot; &lt;&lt; std::endl;
-                on_drop(brushes[drag_obj], target);
-                //std::cout &lt;&lt; &quot;C++: Calling on_drop: done&quot; &lt;&lt; std::endl;
-              }
-            drag_obj = -1;
-          }
+          //std::cout &lt;&lt; &quot;C++: Calling on_drop&quot; &lt;&lt; std::endl;
+          on_drop(brushes[drag_obj], target);
+          //std::cout &lt;&lt; &quot;C++: Calling on_drop: done&quot; &lt;&lt; std::endl;
+        }
+        drag_obj = -1;
       }
-      break;
+    }
+    break;
 
     case CL_MOUSE_MIDDLE:
       scrolling = false;
@@ -91,23 +91,23 @@
 
     default:
       break;
-    }
+  }
 }
 
 void
 ObjectSelector::mouse_down(const CL_InputEvent&amp; event)
 {
   switch(event.id)
+  {
+    case CL_MOUSE_LEFT:
     {
-    case CL_MOUSE_LEFT:
+      if (mouse_over_tile != -1)
       {
-        if (mouse_over_tile != -1)
-          {
-            drag_obj = mouse_over_tile;
-            capture_mouse();
-          }
+        drag_obj = mouse_over_tile;
+        capture_mouse();
       }
-      break;
+    }
+    break;
       
     case CL_MOUSE_MIDDLE:
       scrolling = true;
@@ -123,16 +123,16 @@
     case CL_MOUSE_WHEEL_DOWN:
       offset += static_cast&lt;int&gt;(obj_height*scale); 
       break;
-    }
+  }
 }
 
 void
 ObjectSelector::mouse_move(const CL_InputEvent&amp; event)
 {
   if (scrolling)
-    {
-      offset = old_offset + (click_pos.y - event.mouse_pos.y);
-    }
+  {
+    offset = old_offset + (click_pos.y - event.mouse_pos.y);
+  }
 
   mouse_pos = event.mouse_pos;
 
@@ -159,43 +159,43 @@
   CL_Display::add_translate(get_screen_x(), get_screen_y());
     
   for(int i = 0; i &lt; (int)brushes.size(); ++i)
-    {
-      int x = i%width;
-      int y = i/width;
+  {
+    int x = i%width;
+    int y = i/width;
 
-      CL_Rectf rect(CL_Pointf(x * obj_width, y * obj_height),
-                    CL_Sizef(obj_width, obj_height));
+    CL_Rectf rect(CL_Pointf(x * obj_width, y * obj_height),
+                  CL_Sizef(obj_width, obj_height));
 
-      CL_Sprite sprite = brushes[i].get_sprite();
-      sprite.set_alignment(origin_center, 0, 0);
-      sprite.set_scale(std::min(1.0f, (float)obj_width/(float)sprite.get_width()),
-                       std::min(1.0f, (float)obj_height/(float)sprite.get_height()));
+    CL_Sprite sprite = brushes[i].get_sprite();
+    sprite.set_alignment(origin_center, 0, 0);
+    sprite.set_scale(std::min(1.0f, (float)obj_width/(float)sprite.get_width()),
+                     std::min(1.0f, (float)obj_height/(float)sprite.get_height()));
         
-      sprite.draw(x * obj_width + obj_width/2, 
-                  y * obj_height + obj_height/2);
+    sprite.draw(x * obj_width + obj_width/2, 
+                y * obj_height + obj_height/2);
         
-      //CL_Display::draw_rect(rect, CL_Color(0,0,0,128));
+    //CL_Display::draw_rect(rect, CL_Color(0,0,0,128));
         
-      if (mouse_over_tile == i &amp;&amp; has_mouse_over())
-        {
-          CL_Display::fill_rect(rect, CL_Color(0,0,255, 20));
-        }
+    if (mouse_over_tile == i &amp;&amp; has_mouse_over())
+    {
+      CL_Display::fill_rect(rect, CL_Color(0,0,255, 20));
     }
+  }
 
   CL_Display::pop_modelview();
   CL_Display::pop_cliprect();
  
   // Draw drag sprite
   if (drag_obj != -1)
-    {
-      CL_Display::set_cliprect(CL_Rect(CL_Point(0, 0), 
-                                       CL_Size(CL_Display::get_width(),
-                                               CL_Display::get_height())));
+  {
+    CL_Display::set_cliprect(CL_Rect(CL_Point(0, 0), 
+                                     CL_Size(CL_Display::get_width(),
+                                             CL_Display::get_height())));
 
-      CL_Sprite sprite = brushes[drag_obj].get_sprite();
-      sprite.set_alpha(0.5f);
-      sprite.draw(mouse_pos.x + get_screen_x(), mouse_pos.y + get_screen_y());
-    }
+    CL_Sprite sprite = brushes[drag_obj].get_sprite();
+    sprite.set_alpha(0.5f);
+    sprite.draw(mouse_pos.x + get_screen_x(), mouse_pos.y + get_screen_y());
+  }
 }
 
 void

Modified: trunk/flexlay/lib/objmap_object.cpp
===================================================================
--- trunk/flexlay/lib/objmap_object.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/objmap_object.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -39,9 +39,9 @@
 ObjMapObject::set_pos(const CL_Pointf&amp; p) 
 {
   if (impl.get())
-    {
-      impl-&gt;pos = p; 
-    }
+  {
+    impl-&gt;pos = p; 
+  }
 }
 
 MetaData

Modified: trunk/flexlay/lib/objmap_path_node.cpp
===================================================================
--- trunk/flexlay/lib/objmap_path_node.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/objmap_path_node.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -42,18 +42,18 @@
   gc-&gt;fill_rect(CL_Rect(CL_Point(pos) - CL_Point(16,16), CL_Size(32, 32)), 
                 CL_Color(200, 255, 200));
   if (next)
-    {
-      gc-&gt;draw_line(static_cast&lt;int&gt;(pos.x), static_cast&lt;int&gt;(pos.y),
-                    static_cast&lt;int&gt;((pos.x + next-&gt;pos.x)/2),
-                    static_cast&lt;int&gt;((pos.y+next-&gt;pos.y)/2),
-                    CL_Color(255, 255, 0));
+  {
+    gc-&gt;draw_line(static_cast&lt;int&gt;(pos.x), static_cast&lt;int&gt;(pos.y),
+                  static_cast&lt;int&gt;((pos.x + next-&gt;pos.x)/2),
+                  static_cast&lt;int&gt;((pos.y+next-&gt;pos.y)/2),
+                  CL_Color(255, 255, 0));
 
-      gc-&gt;draw_line(static_cast&lt;int&gt;((pos.x + next-&gt;pos.x)/2), 
-                    static_cast&lt;int&gt;((pos.y+next-&gt;pos.y)/2),
-                    static_cast&lt;int&gt;(next-&gt;pos.x),
-                    static_cast&lt;int&gt;(next-&gt;pos.y), 
-                    CL_Color(255, 0, 0));
-    }
+    gc-&gt;draw_line(static_cast&lt;int&gt;((pos.x + next-&gt;pos.x)/2), 
+                  static_cast&lt;int&gt;((pos.y+next-&gt;pos.y)/2),
+                  static_cast&lt;int&gt;(next-&gt;pos.x),
+                  static_cast&lt;int&gt;(next-&gt;pos.y), 
+                  CL_Color(255, 0, 0));
+  }
 }
 
 CL_Rectf
@@ -84,16 +84,16 @@
 ObjMapPathNode::connect(ObjMapPathNode next)
 {
   if (next.impl-&gt;next != impl.get()) // avoid circular link between two nodes
+  {
+    if (next.impl-&gt;prev) // ensure that each node links exactly to one prev and one next node 
     {
-      if (next.impl-&gt;prev) // ensure that each node links exactly to one prev and one next node 
-        {
-          next.impl-&gt;prev-&gt;next = 0;
-          next.impl-&gt;prev = 0;
-        }
+      next.impl-&gt;prev-&gt;next = 0;
+      next.impl-&gt;prev = 0;
+    }
 
-      impl-&gt;next = next.impl.get();
-      next.impl-&gt;prev = impl.get();
-    }
+    impl-&gt;next = next.impl.get();
+    next.impl-&gt;prev = impl.get();
+  }
 }
 
 ObjMapObject

Modified: trunk/flexlay/lib/objmap_rect_object.cpp
===================================================================
--- trunk/flexlay/lib/objmap_rect_object.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/objmap_rect_object.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -177,12 +177,12 @@
                                              MetaData());
  
   impl-&gt;cp_top_right = ObjMapControlPoint(CL_Sprite(&quot;resize2&quot;, &amp;(Flexlay::current()-&gt;resources)), 
-                                             CL_Pointf(),
+                                          CL_Pointf(),
                                           MetaData());
   
   impl-&gt;cp_bottom_left = ObjMapControlPoint(CL_Sprite(&quot;resize2&quot;, &amp;(Flexlay::current()-&gt;resources)), 
-                                                   CL_Pointf(),
-                                                   MetaData());
+                                            CL_Pointf(),
+                                            MetaData());
   
   impl-&gt;cp_middle_left = ObjMapControlPoint(CL_Sprite(&quot;resize_horz&quot;, &amp;(Flexlay::current()-&gt;resources)), 
                                             CL_Pointf(),

Modified: trunk/flexlay/lib/objmap_sprite_object.cpp
===================================================================
--- trunk/flexlay/lib/objmap_sprite_object.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/objmap_sprite_object.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -74,7 +74,7 @@
   //  if (scale_x &gt; 1.0f &amp;&amp; scale_y &gt; 1.0f)
   //    return CL_Rectf(pos - origin - align,
   //                   CL_Sizef(sprite.get_width() * scale_x, sprite.get_height() * scale_y));
-//  else
+  //  else
   return CL_Rectf(pos - origin - align,
                   CL_Sizef(sprite.get_width(), sprite.get_height()));  
 }

Modified: trunk/flexlay/lib/onion_skin_layer.cpp
===================================================================
--- trunk/flexlay/lib/onion_skin_layer.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/onion_skin_layer.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -67,22 +67,22 @@
   impl-&gt;surface2 = CL_Surface(CL_PixelBuffer(width/SCALE, height/SCALE, width*4/SCALE, CL_PixelFormat::rgba8888));
 
   try
-    {
-      impl-&gt;canvas = new CL_Canvas(impl-&gt;surface);
-      impl-&gt;canvas-&gt;get_gc()-&gt;clear(CL_Color(0, 0, 0, 0));
-      impl-&gt;canvas-&gt;get_gc()-&gt;flush();
-      impl-&gt;canvas-&gt;sync_surface();
+  {
+    impl-&gt;canvas = new CL_Canvas(impl-&gt;surface);
+    impl-&gt;canvas-&gt;get_gc()-&gt;clear(CL_Color(0, 0, 0, 0));
+    impl-&gt;canvas-&gt;get_gc()-&gt;flush();
+    impl-&gt;canvas-&gt;sync_surface();
 
-      impl-&gt;canvas2 = new CL_Canvas(impl-&gt;surface2);
-      impl-&gt;canvas2-&gt;get_gc()-&gt;clear(CL_Color(0, 0, 0, 0));
-      impl-&gt;canvas2-&gt;get_gc()-&gt;flush();
-      impl-&gt;canvas2-&gt;sync_surface();
-    }
+    impl-&gt;canvas2 = new CL_Canvas(impl-&gt;surface2);
+    impl-&gt;canvas2-&gt;get_gc()-&gt;clear(CL_Color(0, 0, 0, 0));
+    impl-&gt;canvas2-&gt;get_gc()-&gt;flush();
+    impl-&gt;canvas2-&gt;sync_surface();
+  }
   catch(CL_Error&amp; err) 
-    {
-      std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
-      throw err;
-    }
+  {
+    std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
+    throw err;
+  }
 }
 
 void
@@ -104,21 +104,21 @@
 {
   impl-&gt;canvas-&gt;get_gc()-&gt;clear(CL_Color(0, 0, 0, 0));
   for (std::vector&lt;EditorMap&gt;::size_type i = 0; i &lt; impl-&gt;editormaps.size(); ++i)
-    {
-      impl-&gt;canvas2-&gt;get_gc()-&gt;clear(CL_Color(0, 0, 0, 0));
-      impl-&gt;canvas2-&gt;get_gc()-&gt;push_modelview();
-      impl-&gt;canvas2-&gt;get_gc()-&gt;add_scale(1.0f/SCALE, 1.0f/SCALE);
+  {
+    impl-&gt;canvas2-&gt;get_gc()-&gt;clear(CL_Color(0, 0, 0, 0));
+    impl-&gt;canvas2-&gt;get_gc()-&gt;push_modelview();
+    impl-&gt;canvas2-&gt;get_gc()-&gt;add_scale(1.0f/SCALE, 1.0f/SCALE);
 
-      impl-&gt;editormaps[i].draw(EditorMapComponent::current(), impl-&gt;canvas2-&gt;get_gc());
+    impl-&gt;editormaps[i].draw(EditorMapComponent::current(), impl-&gt;canvas2-&gt;get_gc());
 
-      impl-&gt;canvas2-&gt;get_gc()-&gt;pop_modelview();
+    impl-&gt;canvas2-&gt;get_gc()-&gt;pop_modelview();
 
-      impl-&gt;canvas2-&gt;sync_surface();
+    impl-&gt;canvas2-&gt;sync_surface();
 
-      impl-&gt;surface2.set_color(impl-&gt;color[i]);
-      impl-&gt;surface2.draw(0, 0, impl-&gt;canvas-&gt;get_gc());
-      impl-&gt;canvas-&gt;sync_surface();
-    }
+    impl-&gt;surface2.set_color(impl-&gt;color[i]);
+    impl-&gt;surface2.draw(0, 0, impl-&gt;canvas-&gt;get_gc());
+    impl-&gt;canvas-&gt;sync_surface();
+  }
 }
 
 Layer

Modified: trunk/flexlay/lib/paint_command.cpp
===================================================================
--- trunk/flexlay/lib/paint_command.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/paint_command.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -89,12 +89,12 @@
                points.front().y + brush.get_height());
 
   for(PaintCommandImpl::Points::iterator i = points.begin(); i != points.end(); ++i)
-    {
-      rect.left   = std::min(rect.left,   (*i).x);
-      rect.top    = std::min(rect.top,    (*i).y);
-      rect.right  = std::max(rect.right,  (*i).x + brush.get_width());
-      rect.bottom = std::max(rect.bottom, (*i).y + brush.get_height());
-    }
+  {
+    rect.left   = std::min(rect.left,   (*i).x);
+    rect.top    = std::min(rect.top,    (*i).y);
+    rect.right  = std::max(rect.right,  (*i).x + brush.get_width());
+    rect.bottom = std::max(rect.bottom, (*i).y + brush.get_height());
+  }
   
   pos.x = rect.left;
   pos.y = rect.top;
@@ -130,9 +130,9 @@
 
   s &lt;&lt; &quot;_ = PaintCommand(&quot; &lt;&lt; &amp;tilemap &lt;&lt; &quot;, &quot; &lt;&lt; &amp;brush &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
   for(PaintCommandImpl::Points::iterator i = points.begin(); i != points.end(); ++i)
-    {
-      s &lt;&lt; &quot;_.add_paint(&quot; &lt;&lt; i-&gt;x &lt;&lt; &quot;, &quot; &lt;&lt; i-&gt;y &lt;&lt; &quot;)&quot;  &lt;&lt; std::endl;
-    }
+  {
+    s &lt;&lt; &quot;_.add_paint(&quot; &lt;&lt; i-&gt;x &lt;&lt; &quot;, &quot; &lt;&lt; i-&gt;y &lt;&lt; &quot;)&quot;  &lt;&lt; std::endl;
+  }
   s &lt;&lt; &quot;_ = None&quot; &lt;&lt; std::endl;
 
   return s.str();

Modified: trunk/flexlay/lib/popup_menu.cpp
===================================================================
--- trunk/flexlay/lib/popup_menu.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/popup_menu.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -37,17 +37,17 @@
 PopupMenu::on_mouse_up(const CL_InputEvent&amp; event)
 {
   if (!menu-&gt;has_mouse_over() &amp;&amp; !menu-&gt;has_mouse_in_submenus())
-    {
-      menu-&gt;collapse();
-      // FIXME: *yuck*
-      delete this;
-    }
+  {
+    menu-&gt;collapse();
+    // FIXME: *yuck*
+    delete this;
+  }
   else
-    {
-      // FIXME: this should be in the constructor, but doesn't work
-      // there since the menu collapses then instantly
-      menu-&gt;set_root_collapsing(true); 
-    }
+  {
+    // FIXME: this should be in the constructor, but doesn't work
+    // there since the menu collapses then instantly
+    menu-&gt;set_root_collapsing(true); 
+  }
 }
 
 /* EOF */

Modified: trunk/flexlay/lib/scrollbar.cpp
===================================================================
--- trunk/flexlay/lib/scrollbar.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/scrollbar.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -95,21 +95,21 @@
                         CL_Color(255, 255, 255));
 
   if (orientation == Scrollbar::HORIZONTAL)
-    {
-      float scale = parent-&gt;get_width()/(max - min);
-      CL_Display::fill_rect(CL_Rect(CL_Point(int((pos-min-(pagesize/2)) * scale), 2), 
-                                    CL_Size(int(pagesize*scale), 
-                                            parent-&gt;get_height()-5)),
-                            CL_Color(0, 0, 0));
-    }
+  {
+    float scale = parent-&gt;get_width()/(max - min);
+    CL_Display::fill_rect(CL_Rect(CL_Point(int((pos-min-(pagesize/2)) * scale), 2), 
+                                  CL_Size(int(pagesize*scale), 
+                                          parent-&gt;get_height()-5)),
+                          CL_Color(0, 0, 0));
+  }
   else if (orientation == Scrollbar::VERTICAL)
-    {
-      float scale = parent-&gt;get_height()/(max - min);
-      CL_Display::fill_rect(CL_Rect(CL_Point(2, int((pos-min-(pagesize/2)) * scale)), 
-                                    CL_Size(parent-&gt;get_width()-5,
-                                            int(pagesize*scale))),
-                            CL_Color(0, 0, 0));     
-    }
+  {
+    float scale = parent-&gt;get_height()/(max - min);
+    CL_Display::fill_rect(CL_Rect(CL_Point(2, int((pos-min-(pagesize/2)) * scale)), 
+                                  CL_Size(parent-&gt;get_width()-5,
+                                          int(pagesize*scale))),
+                          CL_Color(0, 0, 0));     
+  }
 
   CL_Display::draw_rect(rect,
                         CL_Color(155, 155, 155));
@@ -122,51 +122,51 @@
 ScrollbarImpl::on_mouse_up(const CL_InputEvent&amp; event)
 {
   if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed = false;
-      parent-&gt;release_mouse();
-    }
+  {
+    pressed = false;
+    parent-&gt;release_mouse();
+  }
 }
 
 void
 ScrollbarImpl::on_mouse_down(const CL_InputEvent&amp; event)
 {
   if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed   = true;
-      click_pos = event.mouse_pos;
+  {
+    pressed   = true;
+    click_pos = event.mouse_pos;
       
-      parent-&gt;capture_mouse();
+    parent-&gt;capture_mouse();
 
-      float scale = ((orientation == Scrollbar::VERTICAL)
-                     ? parent-&gt;get_height() : parent-&gt;get_width())/(max - min);
-      old_pos = pos * scale;
+    float scale = ((orientation == Scrollbar::VERTICAL)
+                   ? parent-&gt;get_height() : parent-&gt;get_width())/(max - min);
+    old_pos = pos * scale;
 
-      click_pos.x += parent-&gt;get_position().left;
-      click_pos.y += parent-&gt;get_position().top;
-    }
+    click_pos.x += parent-&gt;get_position().left;
+    click_pos.y += parent-&gt;get_position().top;
+  }
 }
 
 void
 ScrollbarImpl::on_mouse_move(const CL_InputEvent&amp; event)
 {
   if(pressed)
-    {
-      CL_Rect rect = parent-&gt;get_position();
+  {
+    CL_Rect rect = parent-&gt;get_position();
       
-      float scale = ((orientation == Scrollbar::VERTICAL)
-                     ? parent-&gt;get_height() : parent-&gt;get_width())/(max - min);
+    float scale = ((orientation == Scrollbar::VERTICAL)
+                   ? parent-&gt;get_height() : parent-&gt;get_width())/(max - min);
       
-      if (orientation == Scrollbar::VERTICAL)
-        {
-          pos = (old_pos - (click_pos.y - (rect.top + event.mouse_pos.y)))/scale;
-        }
-      else if (orientation == Scrollbar::HORIZONTAL)
-        {
-          pos = (old_pos - (click_pos.x - (rect.left + event.mouse_pos.x)))/scale;
-        }
-      on_scrollbar_move(pos);
+    if (orientation == Scrollbar::VERTICAL)
+    {
+      pos = (old_pos - (click_pos.y - (rect.top + event.mouse_pos.y)))/scale;
     }
+    else if (orientation == Scrollbar::HORIZONTAL)
+    {
+      pos = (old_pos - (click_pos.x - (rect.left + event.mouse_pos.x)))/scale;
+    }
+    on_scrollbar_move(pos);
+  }
 }
 
 CL_Signal_v1&lt;float&gt;&amp;

Modified: trunk/flexlay/lib/shared_ptr_comp.hpp
===================================================================
--- trunk/flexlay/lib/shared_ptr_comp.hpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/shared_ptr_comp.hpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -64,9 +64,9 @@
     std::cout &lt;&lt; &quot;SharedPtr: inc: &quot; &lt;&lt; (ref_count ? *ref_count : -45) &lt;&lt; std::endl;
 #endif
     if (ref_count)
-      {
-        *ref_count += 1;
-      }
+    {
+      *ref_count += 1;
+    }
   }
   
   void dec() {
@@ -74,27 +74,27 @@
     std::cout &lt;&lt; &quot;SharedPtr: dec: &quot; &lt;&lt; (ref_count ? *ref_count : -45) &lt;&lt; std::endl;
 #endif
     if (ref_count)
-      {
-        *ref_count -= 1;
-        if (*ref_count == 0) {
+    {
+      *ref_count -= 1;
+      if (*ref_count == 0) {
 #ifdef DEBUG
-          std::cout &lt;&lt; &quot;SharedPtr: deleting: type: &quot;
-                    &lt;&lt; typeid(deleter-&gt;ptr).name()
-                    &lt;&lt; &quot; ptr: &quot; &lt;&lt; deleter-&gt;ptr
-                    &lt;&lt; std::endl;
+        std::cout &lt;&lt; &quot;SharedPtr: deleting: type: &quot;
+                  &lt;&lt; typeid(deleter-&gt;ptr).name()
+                  &lt;&lt; &quot; ptr: &quot; &lt;&lt; deleter-&gt;ptr
+                  &lt;&lt; std::endl;
 #endif
-          deleter-&gt;del();
+        deleter-&gt;del();
           
-          delete ref_count; ref_count = 0;
-          delete deleter;   deleter   = 0;
-        }
+        delete ref_count; ref_count = 0;
+        delete deleter;   deleter   = 0;
       }
+    }
     else
-      {
+    {
 #ifdef DEBUG
-        std::cout &lt;&lt; &quot;SharedPtr: null delete&quot; &lt;&lt; std::endl;
+      std::cout &lt;&lt; &quot;SharedPtr: null delete&quot; &lt;&lt; std::endl;
 #endif
-      }
+    }
   }
 public:
   template&lt;class Base&gt; friend class SharedPtr;
@@ -127,24 +127,24 @@
     : deleter(0), ref_count(0)
   {
     if (copy.deleter)
-      {
-        deleter   = new SharedPtrDeleterImpl&lt;T&gt;(copy.deleter-&gt;ptr);
-        ref_count = copy.ref_count;
-        inc();
-      }
+    {
+      deleter   = new SharedPtrDeleterImpl&lt;T&gt;(copy.deleter-&gt;ptr);
+      ref_count = copy.ref_count;
+      inc();
+    }
 
 #ifdef DEBUG
     if (deleter)
-      {
-        std::cout &lt;&lt; &quot;SharedPtr: copy-ctor template: type: &quot;
-                  &lt;&lt; typeid(deleter-&gt;ptr).name()
-                  &lt;&lt; &quot; ptr: &quot; &lt;&lt; deleter-&gt;ptr
-                  &lt;&lt; std::endl;
-      }
+    {
+      std::cout &lt;&lt; &quot;SharedPtr: copy-ctor template: type: &quot;
+                &lt;&lt; typeid(deleter-&gt;ptr).name()
+                &lt;&lt; &quot; ptr: &quot; &lt;&lt; deleter-&gt;ptr
+                &lt;&lt; std::endl;
+    }
     else
-      {
-        std::cout &lt;&lt; &quot;SharedPtr: copy-ctor template null&quot; &lt;&lt; std::endl;
-      }
+    {
+      std::cout &lt;&lt; &quot;SharedPtr: copy-ctor template null&quot; &lt;&lt; std::endl;
+    }
 #endif
   }
 
@@ -156,30 +156,30 @@
     std::cout &lt;&lt; &quot;SharedPtr&lt;T&gt;&amp; operator= (const SharedPtr&lt;Base&gt;&amp; copy)&quot; &lt;&lt; std::endl;
 #endif
     if (ref_count != copy.ref_count)
+    {
+      dec();
+
+      if (copy.deleter)
       {
-        dec();
+        deleter   = new SharedPtrDeleterImpl&lt;T&gt;(copy.deleter-&gt;ptr);
+        ref_count = copy.ref_count;
+        inc();
+      }
 
-        if (copy.deleter)
-          {
-            deleter   = new SharedPtrDeleterImpl&lt;T&gt;(copy.deleter-&gt;ptr);
-            ref_count = copy.ref_count;
-            inc();
-          }
-
 #ifdef DEBUG
-        if (deleter)
-          {
-            std::cout &lt;&lt; &quot;SharedPtr: assign template: type: &quot;
-                      &lt;&lt; typeid(deleter-&gt;ptr).name()
-                      &lt;&lt; &quot; ptr: &quot; &lt;&lt; deleter-&gt;ptr
-                      &lt;&lt; std::endl;
-          }
-        else
-          {
-            std::cout &lt;&lt; &quot;SharedPtr: assign template: null: &quot; &lt;&lt; std::endl;
-          }
+      if (deleter)
+      {
+        std::cout &lt;&lt; &quot;SharedPtr: assign template: type: &quot;
+                  &lt;&lt; typeid(deleter-&gt;ptr).name()
+                  &lt;&lt; &quot; ptr: &quot; &lt;&lt; deleter-&gt;ptr
+                  &lt;&lt; std::endl;
+      }
+      else
+      {
+        std::cout &lt;&lt; &quot;SharedPtr: assign template: null: &quot; &lt;&lt; std::endl;
+      }
 #endif
-      }
+    }
 
     return *this;
   }
@@ -187,46 +187,46 @@
   SharedPtr&lt;T&gt;&amp; operator= (const SharedPtr&lt;T&gt;&amp; copy) 
   {
     if (this != &amp;copy)
+    {
+      dec();
+
+      if (copy.deleter)
       {
-        dec();
+        deleter   = new SharedPtrDeleterImpl&lt;T&gt;(copy.deleter-&gt;ptr);
+        ref_count = copy.ref_count;
+        inc();
+      }
 
-        if (copy.deleter)
-          {
-            deleter   = new SharedPtrDeleterImpl&lt;T&gt;(copy.deleter-&gt;ptr);
-            ref_count = copy.ref_count;
-            inc();
-          }
-
 #ifdef DEBUG
-        if (deleter)
-          {
-            std::cout &lt;&lt; &quot;SharedPtr: assign normal: type: &quot;
-                      &lt;&lt; typeid(deleter-&gt;ptr).name()
-                      &lt;&lt; &quot; ptr: &quot; &lt;&lt; deleter-&gt;ptr
-                      &lt;&lt; std::endl;
-          }
-        else
-          {
-            std::cout &lt;&lt; &quot;SharedPtr: assign normal null&quot; &lt;&lt; std::endl;
-          }
+      if (deleter)
+      {
+        std::cout &lt;&lt; &quot;SharedPtr: assign normal: type: &quot;
+                  &lt;&lt; typeid(deleter-&gt;ptr).name()
+                  &lt;&lt; &quot; ptr: &quot; &lt;&lt; deleter-&gt;ptr
+                  &lt;&lt; std::endl;
+      }
+      else
+      {
+        std::cout &lt;&lt; &quot;SharedPtr: assign normal null&quot; &lt;&lt; std::endl;
+      }
 #endif
-      }
+    }
     else
+    {
+#ifdef DEBUG
+      if (deleter)
       {
-#ifdef DEBUG
-        if (deleter)
-          {
-            std::cout &lt;&lt; &quot;SharedPtr: self assin: type: &quot;
-                      &lt;&lt; typeid(deleter-&gt;ptr).name()
-                      &lt;&lt; &quot; ptr: &quot; &lt;&lt; deleter-&gt;ptr
-                      &lt;&lt; std::endl;
-          }
-        else
-          {
-            std::cout &lt;&lt; &quot;SharedPtr: assign normal null&quot; &lt;&lt; std::endl;
-          }
+        std::cout &lt;&lt; &quot;SharedPtr: self assin: type: &quot;
+                  &lt;&lt; typeid(deleter-&gt;ptr).name()
+                  &lt;&lt; &quot; ptr: &quot; &lt;&lt; deleter-&gt;ptr
+                  &lt;&lt; std::endl;
+      }
+      else
+      {
+        std::cout &lt;&lt; &quot;SharedPtr: assign normal null&quot; &lt;&lt; std::endl;
+      }
 #endif
-      }
+    }
 
     return *this;
   }
@@ -240,7 +240,7 @@
   T&amp; operator*() { return *deleter-&gt;ptr; }
 
   T const&amp; operator*() const { return *deleter-&gt;ptr; }
-	
+        
   //: Indirect member access operator.
   T* operator-&gt;() { return deleter-&gt;ptr; }
 

Modified: trunk/flexlay/lib/sketch_layer.cpp
===================================================================
--- trunk/flexlay/lib/sketch_layer.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/sketch_layer.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -69,13 +69,13 @@
     strokes.push_back(stroke);
 
     if (canvas)
-      {
-        EditorMapComponent* parent = EditorMapComponent::current();
-        parent-&gt;get_gc_state().push(canvas-&gt;get_gc());
-        stroke.draw(canvas-&gt;get_gc());
-        parent-&gt;get_gc_state().pop(canvas-&gt;get_gc());
-        canvas-&gt;sync_surface();
-      }
+    {
+      EditorMapComponent* parent = EditorMapComponent::current();
+      parent-&gt;get_gc_state().push(canvas-&gt;get_gc());
+      stroke.draw(canvas-&gt;get_gc());
+      parent-&gt;get_gc_state().pop(canvas-&gt;get_gc());
+      canvas-&gt;sync_surface();
+    }
   }
   
   void draw(EditorMapComponent* parent, CL_GraphicContext* gc) 
@@ -85,57 +85,57 @@
       return;
 
     if (canvas)
+    {
+      // Draw to canvas
+      if (last_zoom != parent-&gt;get_gc_state().get_zoom() ||
+          last_pos  != parent-&gt;get_gc_state().get_pos()  ||
+          last_rot  != parent-&gt;get_gc_state().get_rotation())
       {
-        // Draw to canvas
-        if (last_zoom != parent-&gt;get_gc_state().get_zoom() ||
-            last_pos  != parent-&gt;get_gc_state().get_pos()  ||
-            last_rot  != parent-&gt;get_gc_state().get_rotation())
-          {
-            // Rerender the image
-            last_zoom   = parent-&gt;get_gc_state().get_zoom();
-            last_pos    = parent-&gt;get_gc_state().get_pos();
-            last_rot    = parent-&gt;get_gc_state().get_rotation();
+        // Rerender the image
+        last_zoom   = parent-&gt;get_gc_state().get_zoom();
+        last_pos    = parent-&gt;get_gc_state().get_pos();
+        last_rot    = parent-&gt;get_gc_state().get_rotation();
 
-            parent-&gt;get_gc_state().push(canvas-&gt;get_gc());
-            canvas-&gt;get_gc()-&gt;clear(CL_Color(0, 0, 0, 0));
-            //canvas-&gt;get_gc()-&gt;clear(CL_Color::white);
+        parent-&gt;get_gc_state().push(canvas-&gt;get_gc());
+        canvas-&gt;get_gc()-&gt;clear(CL_Color(0, 0, 0, 0));
+        //canvas-&gt;get_gc()-&gt;clear(CL_Color::white);
 
-            CL_Rectf visible_area = parent-&gt;get_clip_rect();
+        CL_Rectf visible_area = parent-&gt;get_clip_rect();
 
-            for(Strokes::iterator i = strokes.begin(); i != strokes.end(); ++i)
-              {
-                // canvas-&gt;get_gc()-&gt;draw_rect(i-&gt;get_bounding_rect(), CL_Color(0, 255, 0));
-                // canvas-&gt;get_gc()-&gt;flush();
+        for(Strokes::iterator i = strokes.begin(); i != strokes.end(); ++i)
+        {
+          // canvas-&gt;get_gc()-&gt;draw_rect(i-&gt;get_bounding_rect(), CL_Color(0, 255, 0));
+          // canvas-&gt;get_gc()-&gt;flush();
 
-                if (visible_area.is_overlapped(i-&gt;get_bounding_rect()))
-                  {
-                    i-&gt;draw(canvas-&gt;get_gc());
-                  }
-              }
-            parent-&gt;get_gc_state().pop(canvas-&gt;get_gc());
+          if (visible_area.is_overlapped(i-&gt;get_bounding_rect()))
+          {
+            i-&gt;draw(canvas-&gt;get_gc());
+          }
+        }
+        parent-&gt;get_gc_state().pop(canvas-&gt;get_gc());
 
-            canvas-&gt;sync_surface();
-          }
+        canvas-&gt;sync_surface();
+      }
         
-        surface.set_blend_func(blend_one, blend_one_minus_src_alpha);
+      surface.set_blend_func(blend_one, blend_one_minus_src_alpha);
 
-        CL_Matrix4x4 matrix = CL_Display::get_modelview();
-        CL_Display::pop_modelview();
-        surface.draw();
-        CL_Display::set_modelview(matrix);
-        // FIXME: I think we need the line below, however with it it
-        //doesn't work, without it, it does, ClanLib bug or just
-        //consfusing function names?
-        //CL_Display::push_modelview();
-      }
+      CL_Matrix4x4 matrix = CL_Display::get_modelview();
+      CL_Display::pop_modelview();
+      surface.draw();
+      CL_Display::set_modelview(matrix);
+      // FIXME: I think we need the line below, however with it it
+      //doesn't work, without it, it does, ClanLib bug or just
+      //consfusing function names?
+      //CL_Display::push_modelview();
+    }
     else
-      { 
-        // Direct Drawing, slow
-        for(Strokes::iterator i = strokes.begin(); i != strokes.end(); ++i)
-          {
-            i-&gt;draw(0);
-          }
+    { 
+      // Direct Drawing, slow
+      for(Strokes::iterator i = strokes.begin(); i != strokes.end(); ++i)
+      {
+        i-&gt;draw(0);
       }
+    }
   }
 
   bool has_bounding_rect() const { 
@@ -159,7 +159,7 @@
 Layer
 SketchLayer::to_layer()
 {
-   return Layer(impl);
+  return Layer(impl);
 }
 
 std::vector&lt;Stroke&gt;

Modified: trunk/flexlay/lib/slider.cpp
===================================================================
--- trunk/flexlay/lib/slider.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/slider.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -84,31 +84,31 @@
 Slider::on_mouse_down(const CL_InputEvent&amp; event)
 {
   if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed = true;
-      capture_mouse();
-      update_mouse(event);
-    }
+  {
+    pressed = true;
+    capture_mouse();
+    update_mouse(event);
+  }
 }
 
 void
 Slider::on_mouse_up  (const CL_InputEvent&amp; event)
 {
   if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed = false;
-      release_mouse();
-      update_mouse(event);
-    }
+  {
+    pressed = false;
+    release_mouse();
+    update_mouse(event);
+  }
 }
 
 void
 Slider::on_mouse_move(const CL_InputEvent&amp; event)
 {
   if (pressed)
-    {
-      update_mouse(event);
-    }
+  {
+    update_mouse(event);
+  }
 }
 
 /* EOF */

Modified: trunk/flexlay/lib/sprite_stroke_drawer.cpp
===================================================================
--- trunk/flexlay/lib/sprite_stroke_drawer.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/sprite_stroke_drawer.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -67,191 +67,191 @@
                                                    * DrawerProperties::current()-&gt;get_size());
 
   for(Stroke::Dabs::iterator i = dabs.begin(); i != dabs.end(); ++i)
-    {
-      Dab&amp; dab = *i;
+  {
+    Dab&amp; dab = *i;
 
-      CL_Sprite sprite = DrawerProperties::current()-&gt;get_brush().get_sprite();
+    CL_Sprite sprite = DrawerProperties::current()-&gt;get_brush().get_sprite();
 
-      CL_Color color = DrawerProperties::current()-&gt;get_color();
-      sprite.set_color(color);
-      sprite.set_alpha((color.get_alpha()/255.0f) * dab.pressure);
-      sprite.set_scale(DrawerProperties::current()-&gt;get_size() * dab.pressure,
-                       DrawerProperties::current()-&gt;get_size() * dab.pressure);
+    CL_Color color = DrawerProperties::current()-&gt;get_color();
+    sprite.set_color(color);
+    sprite.set_alpha((color.get_alpha()/255.0f) * dab.pressure);
+    sprite.set_scale(DrawerProperties::current()-&gt;get_size() * dab.pressure,
+                     DrawerProperties::current()-&gt;get_size() * dab.pressure);
 
-      if (gc != 0)
-        {
-          /* Correct function:
-             1: dest
-             2: src
+    if (gc != 0)
+    {
+      /* Correct function:
+         1: dest
+         2: src
              
-             R = R1 A1 (1 - A2) + R2 A2
-             G = G1 A1 (1 - A2) + G2 A2
-             B = B1 A1 (1 - A2) + B2 A2
-             A = A1 (1 - A2) + A2
+         R = R1 A1 (1 - A2) + R2 A2
+         G = G1 A1 (1 - A2) + G2 A2
+         B = B1 A1 (1 - A2) + B2 A2
+         A = A1 (1 - A2) + A2
 
-             // This is currently used, leads to premultiplied alpha
-             Aout  = Afgd + (1 - Afgd) * Abkg 
-             Cout' = Cfgd' + (1 - Afgd) * Cbkg' 
-             where
-             Cfgd' = Cfgd * Afgd
-             Cbkg' = Cbkg * Abkg
-             Cout' = Cout * Aout
+         // This is currently used, leads to premultiplied alpha
+         Aout  = Afgd + (1 - Afgd) * Abkg 
+         Cout' = Cfgd' + (1 - Afgd) * Cbkg' 
+         where
+         Cfgd' = Cfgd * Afgd
+         Cbkg' = Cbkg * Abkg
+         Cout' = Cout * Aout
 
-             Aout = (1 - (1 - Afgd) * (1 - Abkg)) 
-             Cout = (Cfgd * Afgd) + (1 - Afgd * Cbkg * Abkg) / Aout 
-             where
-             Cfgd = red, green, blue of foreground
-             Cbkg = red, green, blue of background
-             Afgd = alpha of foreground
-             Abkg = alpha of background
-          */
+         Aout = (1 - (1 - Afgd) * (1 - Abkg)) 
+         Cout = (Cfgd * Afgd) + (1 - Afgd * Cbkg * Abkg) / Aout 
+         where
+         Cfgd = red, green, blue of foreground
+         Cbkg = red, green, blue of background
+         Afgd = alpha of foreground
+         Abkg = alpha of background
+      */
 
-          // DO Multipass:
-          // 1: GL_ZERO, GL_DST_ALPHA
-          // 2: GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA
-          /*brush.set_blend_func_separate(blend_zero, blend_dst_alpha,
-            blend_zero, blend_one);
-            brush.draw(dab.pos.x, dab.pos.y, gc);*/
+      // DO Multipass:
+      // 1: GL_ZERO, GL_DST_ALPHA
+      // 2: GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA
+      /*brush.set_blend_func_separate(blend_zero, blend_dst_alpha,
+        blend_zero, blend_one);
+        brush.draw(dab.pos.x, dab.pos.y, gc);*/
           
-          switch (mode)
-            {
-            case SpriteStrokeDrawer::DM_NORMAL:
-              sprite.set_blend_func_separate(blend_src_alpha, blend_one_minus_src_alpha,
-                                             blend_one, blend_one_minus_src_alpha);
-              sprite.draw(dab.pos.x, dab.pos.y, gc);
-              break;
+      switch (mode)
+      {
+        case SpriteStrokeDrawer::DM_NORMAL:
+          sprite.set_blend_func_separate(blend_src_alpha, blend_one_minus_src_alpha,
+                                         blend_one, blend_one_minus_src_alpha);
+          sprite.draw(dab.pos.x, dab.pos.y, gc);
+          break;
 
-            case SpriteStrokeDrawer::DM_ADDITION:
-              sprite.set_blend_func_separate(blend_src_alpha, blend_one,
-                                             blend_zero, blend_one);
-              //blend_one, blend_one_minus_src_alpha);
-              sprite.draw(dab.pos.x, dab.pos.y, gc);
-              break;
+        case SpriteStrokeDrawer::DM_ADDITION:
+          sprite.set_blend_func_separate(blend_src_alpha, blend_one,
+                                         blend_zero, blend_one);
+          //blend_one, blend_one_minus_src_alpha);
+          sprite.draw(dab.pos.x, dab.pos.y, gc);
+          break;
               
-            case SpriteStrokeDrawer::DM_ERASE:
-              sprite.set_blend_func(blend_zero, blend_one_minus_src_alpha);
-              sprite.draw(dab.pos.x, dab.pos.y, gc);
-              break;
+        case SpriteStrokeDrawer::DM_ERASE:
+          sprite.set_blend_func(blend_zero, blend_one_minus_src_alpha);
+          sprite.draw(dab.pos.x, dab.pos.y, gc);
+          break;
           
-            case SpriteStrokeDrawer::DM_SMUDGE:
-              {
-                if (i != dabs.begin())
-                  {
-                    CL_Canvas* canvas = BitmapLayer::current()-&gt;get_canvas();
-                    CL_PixelBuffer buffer = canvas-&gt;get_pixeldata(CL_Rect(CL_Point(static_cast&lt;int&gt;((i-1)-&gt;pos.x) - sprite.get_width()/2,
-                                                                                   static_cast&lt;int&gt;((i-1)-&gt;pos.y) - sprite.get_height()/2),
-                                                                          CL_Size(sprite.get_width(), sprite.get_height())));
-                    CL_Surface surface(buffer);
-                    //surface.set_blend_func_separate(blend_src_alpha, blend_one_minus_src_alpha,
-                    //                                blend_one, blend_zero);
-                    surface.set_alignment(origin_center);
-                    surface.set_alpha(0.5);
-                    //surface.set_scale(DrawerProperties::current()-&gt;get_size(),
-                    //                 DrawerProperties::current()-&gt;get_size());
-                    surface.draw(dab.pos.x, dab.pos.y, gc);
-                  }
-              }
-              break;
+        case SpriteStrokeDrawer::DM_SMUDGE:
+        {
+          if (i != dabs.begin())
+          {
+            CL_Canvas* canvas = BitmapLayer::current()-&gt;get_canvas();
+            CL_PixelBuffer buffer = canvas-&gt;get_pixeldata(CL_Rect(CL_Point(static_cast&lt;int&gt;((i-1)-&gt;pos.x) - sprite.get_width()/2,
+                                                                           static_cast&lt;int&gt;((i-1)-&gt;pos.y) - sprite.get_height()/2),
+                                                                  CL_Size(sprite.get_width(), sprite.get_height())));
+            CL_Surface surface(buffer);
+            //surface.set_blend_func_separate(blend_src_alpha, blend_one_minus_src_alpha,
+            //                                blend_one, blend_zero);
+            surface.set_alignment(origin_center);
+            surface.set_alpha(0.5);
+            //surface.set_scale(DrawerProperties::current()-&gt;get_size(),
+            //                 DrawerProperties::current()-&gt;get_size());
+            surface.draw(dab.pos.x, dab.pos.y, gc);
+          }
+        }
+        break;
 
-            case SpriteStrokeDrawer::DM_SHADER:
-              {
+        case SpriteStrokeDrawer::DM_SHADER:
+        {
 #if 0 
-                CL_OpenGLState state(gc);
-                state.set_active();
-                state.setup_2d();
+          CL_OpenGLState state(gc);
+          state.set_active();
+          state.setup_2d();
 
-                if (program == 0)
-                  {
-                    program = new CL_ProgramObject();
+          if (program == 0)
+          {
+            program = new CL_ProgramObject();
                 
-                    CL_ShaderObject shader(&quot;shader&quot;, &amp;(Flexlay::current()-&gt;resources));
-                    std::cout &lt;&lt; &quot;Shader status: &quot; &lt;&lt; (shader.get_compile_status() ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; std::endl;
-                    std::cout &lt;&lt; &quot;Shader log: &quot; &lt;&lt; shader.get_info_log() &lt;&lt; std::endl;
-                    std::cout &lt;&lt; &quot;Shader handle: &quot; &lt;&lt; shader.get_handle() &lt;&lt; std::endl;
+            CL_ShaderObject shader(&quot;shader&quot;, &amp;(Flexlay::current()-&gt;resources));
+            std::cout &lt;&lt; &quot;Shader status: &quot; &lt;&lt; (shader.get_compile_status() ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; std::endl;
+            std::cout &lt;&lt; &quot;Shader log: &quot; &lt;&lt; shader.get_info_log() &lt;&lt; std::endl;
+            std::cout &lt;&lt; &quot;Shader handle: &quot; &lt;&lt; shader.get_handle() &lt;&lt; std::endl;
 
-                    program-&gt;attach(shader);
-                    program-&gt;link();
-                    std::cout &lt;&lt; &quot;Program status: &quot; &lt;&lt; (program-&gt;get_link_status() ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; std::endl;
-                    std::cout &lt;&lt; &quot;Program log: &quot; &lt;&lt; program-&gt;get_info_log() &lt;&lt; std::endl;
-                    std::cout &lt;&lt; &quot;Program handle: &quot; &lt;&lt; program-&gt;get_handle() &lt;&lt; std::endl;
+            program-&gt;attach(shader);
+            program-&gt;link();
+            std::cout &lt;&lt; &quot;Program status: &quot; &lt;&lt; (program-&gt;get_link_status() ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; std::endl;
+            std::cout &lt;&lt; &quot;Program log: &quot; &lt;&lt; program-&gt;get_info_log() &lt;&lt; std::endl;
+            std::cout &lt;&lt; &quot;Program handle: &quot; &lt;&lt; program-&gt;get_handle() &lt;&lt; std::endl;
 
-                    clUseProgram(program-&gt;get_handle());
-                  }
-                else
-                  {
-                    clUseProgram(program-&gt;get_handle());
-                  }
+            clUseProgram(program-&gt;get_handle());
+          }
+          else
+          {
+            clUseProgram(program-&gt;get_handle());
+          }
             
-                CL_OpenGLSurface glsurface(sprite.get_frame_surface(0));
-                glActiveTexture(GL_TEXTURE0);
-                glsurface.bind();
-                glEnable(GL_TEXTURE_2D);
+          CL_OpenGLSurface glsurface(sprite.get_frame_surface(0));
+          glActiveTexture(GL_TEXTURE0);
+          glsurface.bind();
+          glEnable(GL_TEXTURE_2D);
 
-                /*CL_OpenGLSurface glsurface2(SketchLayer::current()-&gt;get_background_surface());
-                  glActiveTexture(GL_TEXTURE1);
-                  glsurface2.bind();
-                  glEnable(GL_TEXTURE_2D);*/
+          /*CL_OpenGLSurface glsurface2(SketchLayer::current()-&gt;get_background_surface());
+            glActiveTexture(GL_TEXTURE1);
+            glsurface2.bind();
+            glEnable(GL_TEXTURE_2D);*/
             
-                clUniform1i(program-&gt;get_attribute_location(&quot;mytex&quot;), 0);
-                //clUniform1i(program-&gt;get_attribute_location(&quot;background&quot;), 1);
-                //program-&gt;validate();
-                //std::cout &lt;&lt; &quot;Program validate status: &quot; &lt;&lt; (program-&gt;get_validate_status() ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; std::endl;
-                //std::cout &lt;&lt; &quot;Program log: &quot; &lt;&lt; program-&gt;get_info_log() &lt;&lt; std::endl;
+          clUniform1i(program-&gt;get_attribute_location(&quot;mytex&quot;), 0);
+          //clUniform1i(program-&gt;get_attribute_location(&quot;background&quot;), 1);
+          //program-&gt;validate();
+          //std::cout &lt;&lt; &quot;Program validate status: &quot; &lt;&lt; (program-&gt;get_validate_status() ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; std::endl;
+          //std::cout &lt;&lt; &quot;Program log: &quot; &lt;&lt; program-&gt;get_info_log() &lt;&lt; std::endl;
 
-                clBegin(CL_QUADS);
-                clColor4b(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
-                float size = base_size * dab.pressure;
-                clVertex2f((dab.pos.x - sprite.get_width()/2) * size, (dab.pos.y - sprite.get_height()/2) * size);
-                clTexCoord2d(0.0, 0.0);
-                clVertex2f((dab.pos.x + sprite.get_width()/2) * size, (dab.pos.y - sprite.get_height()/2) * size);
-                clTexCoord2d(1.0, 0.0);
-                clVertex2f((dab.pos.x + sprite.get_width()/2) * size, (dab.pos.y + sprite.get_height()/2) * size);
-                clTexCoord2d(1.0, 1.0);
-                clVertex2f((dab.pos.x - sprite.get_width()/2) * size, (dab.pos.y + sprite.get_height()/2) * size);
-                clTexCoord2d(0.0, 1.0);
-                clEnd();
+          clBegin(CL_QUADS);
+          clColor4b(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
+          float size = base_size * dab.pressure;
+          clVertex2f((dab.pos.x - sprite.get_width()/2) * size, (dab.pos.y - sprite.get_height()/2) * size);
+          clTexCoord2d(0.0, 0.0);
+          clVertex2f((dab.pos.x + sprite.get_width()/2) * size, (dab.pos.y - sprite.get_height()/2) * size);
+          clTexCoord2d(1.0, 0.0);
+          clVertex2f((dab.pos.x + sprite.get_width()/2) * size, (dab.pos.y + sprite.get_height()/2) * size);
+          clTexCoord2d(1.0, 1.0);
+          clVertex2f((dab.pos.x - sprite.get_width()/2) * size, (dab.pos.y + sprite.get_height()/2) * size);
+          clTexCoord2d(0.0, 1.0);
+          clEnd();
             
-                state.set_active();
-                clUseProgram(0);
+          state.set_active();
+          clUseProgram(0);
 #endif
-              }
-              break;
-              
-            default:
-              std::cout &lt;&lt; &quot;Error: SpriteStrokeDrawer: Unknown draw mode: &quot; &lt;&lt; mode &lt;&lt; std::endl;
-              break;
-            }
         }
-      else
-        {
-          switch (mode)
-            {
-            case SpriteStrokeDrawer::DM_NORMAL:  
-              sprite.set_blend_func(blend_src_alpha, blend_one_minus_src_alpha);
-              sprite.draw(dab.pos.x, dab.pos.y, gc);
-              break;
+        break;
               
-            case SpriteStrokeDrawer::DM_ADDITION:
-              sprite.set_blend_func(blend_src_alpha, blend_one);
-              sprite.draw(dab.pos.x, dab.pos.y, gc); 
-              break;
+        default:
+          std::cout &lt;&lt; &quot;Error: SpriteStrokeDrawer: Unknown draw mode: &quot; &lt;&lt; mode &lt;&lt; std::endl;
+          break;
+      }
+    }
+    else
+    {
+      switch (mode)
+      {
+        case SpriteStrokeDrawer::DM_NORMAL:  
+          sprite.set_blend_func(blend_src_alpha, blend_one_minus_src_alpha);
+          sprite.draw(dab.pos.x, dab.pos.y, gc);
+          break;
+              
+        case SpriteStrokeDrawer::DM_ADDITION:
+          sprite.set_blend_func(blend_src_alpha, blend_one);
+          sprite.draw(dab.pos.x, dab.pos.y, gc); 
+          break;
             
-            case SpriteStrokeDrawer::DM_ERASE:
-              sprite.set_blend_func(blend_zero, blend_one_minus_src_alpha);
-              sprite.draw(dab.pos.x, dab.pos.y, gc);
-              break; 
+        case SpriteStrokeDrawer::DM_ERASE:
+          sprite.set_blend_func(blend_zero, blend_one_minus_src_alpha);
+          sprite.draw(dab.pos.x, dab.pos.y, gc);
+          break; 
           
-            case SpriteStrokeDrawer::DM_SMUDGE:
-              sprite.set_blend_func(blend_src_alpha, blend_one_minus_src_alpha);
-              sprite.draw(dab.pos.x, dab.pos.y, gc);          
-              break;
+        case SpriteStrokeDrawer::DM_SMUDGE:
+          sprite.set_blend_func(blend_src_alpha, blend_one_minus_src_alpha);
+          sprite.draw(dab.pos.x, dab.pos.y, gc);          
+          break;
 
-            default:
-              std::cout &lt;&lt; &quot;Error: SpriteStrokeDrawer: Unknown draw mode: &quot; &lt;&lt; mode &lt;&lt; std::endl;
-              break;
-            }
-        }
+        default:
+          std::cout &lt;&lt; &quot;Error: SpriteStrokeDrawer: Unknown draw mode: &quot; &lt;&lt; mode &lt;&lt; std::endl;
+          break;
+      }
     }
+  }
 }
 
 void

Modified: trunk/flexlay/lib/stroke.cpp
===================================================================
--- trunk/flexlay/lib/stroke.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/stroke.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -38,19 +38,19 @@
 
     // FIXME: Keep the drawer into account (ie. brushsize)
     if (dabs.size() &gt; 0)
+    {
+      rect.left = rect.right  = dabs.front().pos.x;
+      rect.top  = rect.bottom = dabs.front().pos.y;
+
+      for(Stroke::Dabs::const_iterator i = dabs.begin()+1; i != dabs.end(); ++i)
       {
-        rect.left = rect.right  = dabs.front().pos.x;
-        rect.top  = rect.bottom = dabs.front().pos.y;
+        rect.left = std::min(i-&gt;pos.x, rect.left);
+        rect.top  = std::min(i-&gt;pos.y, rect.top);
 
-        for(Stroke::Dabs::const_iterator i = dabs.begin()+1; i != dabs.end(); ++i)
-          {
-            rect.left = std::min(i-&gt;pos.x, rect.left);
-            rect.top  = std::min(i-&gt;pos.y, rect.top);
-
-            rect.right  = std::max(i-&gt;pos.x, rect.right);
-            rect.bottom = std::max(i-&gt;pos.y, rect.bottom);
-          }
+        rect.right  = std::max(i-&gt;pos.x, rect.right);
+        rect.bottom = std::max(i-&gt;pos.y, rect.bottom);
       }
+    }
     
     return rect;
   }
@@ -82,49 +82,49 @@
 Stroke::get_interpolated_dabs(float x_spacing, float y_spacing) const
 {
   if (impl-&gt;dabs.size() &gt; 0)
-    {
-      Dabs interpolated_dabs;
+  {
+    Dabs interpolated_dabs;
 
-      interpolated_dabs.push_back(impl-&gt;dabs.front());
+    interpolated_dabs.push_back(impl-&gt;dabs.front());
 
-      // The following code basically takes all the event dabs as recieved
-      // by from the InputDevice and interpolates new dabs inbetween to
-      // give them an equal spacing (ie. every dab is only 'spacing' away
-      // from the next)
-      float overspace = 0.0f;
-      const Stroke::Dabs&amp; dabs = impl-&gt;dabs;
-      for(unsigned int j = 0; j &lt; dabs.size()-1; ++j)
-        {
-          CL_Pointf dist = dabs[j+1].pos - dabs[j].pos;
-          float length = sqrt(dist.x * dist.x + dist.y * dist.y);
-          int n = 1;
+    // The following code basically takes all the event dabs as recieved
+    // by from the InputDevice and interpolates new dabs inbetween to
+    // give them an equal spacing (ie. every dab is only 'spacing' away
+    // from the next)
+    float overspace = 0.0f;
+    const Stroke::Dabs&amp; dabs = impl-&gt;dabs;
+    for(unsigned int j = 0; j &lt; dabs.size()-1; ++j)
+    {
+      CL_Pointf dist = dabs[j+1].pos - dabs[j].pos;
+      float length = sqrt(dist.x * dist.x + dist.y * dist.y);
+      int n = 1;
     
-          // Spacing is keep relative to the brush size
-          // FIXME: This is specific to a Sprite based drawer, might not work for others
-          // FIXME: y_spacing isn't taken into account either
-          float local_spacing = x_spacing * dabs[j].pressure;
+      // Spacing is keep relative to the brush size
+      // FIXME: This is specific to a Sprite based drawer, might not work for others
+      // FIXME: y_spacing isn't taken into account either
+      float local_spacing = x_spacing * dabs[j].pressure;
 
-          while (length + overspace &gt; (local_spacing * n))
-            {
-              float factor = (local_spacing/length) * n - (overspace/length);
+      while (length + overspace &gt; (local_spacing * n))
+      {
+        float factor = (local_spacing/length) * n - (overspace/length);
           
-              // FIXME: Interpolate tilting, pressure, etc. along the line
-              interpolated_dabs.push_back(Dab(dabs[j].pos.x + dist.x * factor,
-                                              dabs[j].pos.y + dist.y * factor,
-                                              dabs[j].pressure));
-              n += 1;
-            }
+        // FIXME: Interpolate tilting, pressure, etc. along the line
+        interpolated_dabs.push_back(Dab(dabs[j].pos.x + dist.x * factor,
+                                        dabs[j].pos.y + dist.y * factor,
+                                        dabs[j].pressure));
+        n += 1;
+      }
 
-          // calculate the space that wasn't used in the last iteration
-          overspace = (length + overspace) - (local_spacing * (n-1));
-        }
-      return interpolated_dabs;
+      // calculate the space that wasn't used in the last iteration
+      overspace = (length + overspace) - (local_spacing * (n-1));
     }
+    return interpolated_dabs;
+  }
   else
-    {
-      // No dabs available, so nothing to interpolate
-      return impl-&gt;dabs;
-    }
+  {
+    // No dabs available, so nothing to interpolate
+    return impl-&gt;dabs;
+  }
 }
 
 Stroke::Dabs
@@ -143,13 +143,13 @@
 Stroke::draw(CL_GraphicContext* gc) const
 {
   if (!impl-&gt;drawer.is_null())
-    {
-      const_cast&lt;StrokeDrawer&amp;&gt;(impl-&gt;drawer).draw(*this, gc);
-    }
+  {
+    const_cast&lt;StrokeDrawer&amp;&gt;(impl-&gt;drawer).draw(*this, gc);
+  }
   else
-    {
-      std::cout &lt;&lt; &quot;No drawer set!&quot; &lt;&lt; std::endl;
-    }
+  {
+    std::cout &lt;&lt; &quot;No drawer set!&quot; &lt;&lt; std::endl;
+  }
 }
 
 void
@@ -159,67 +159,67 @@
 }
 
 /* // calc normals
-  assert(normals.size() == 0);
+   assert(normals.size() == 0);
 
-  if (points.size() == 1)
-    {
-      normals.push_back(CL_Pointf(1.0f, 1.0f));
-    }
-  else if (points.size() == 2)
-    {
-      normals.push_back(CL_Pointf(1.0f, 1.0f));
-      normals.push_back(CL_Pointf(1.0f, 1.0f));
-    }
-  else if (points.size() &gt;= 3)
-    {
-      for(Points::size_type i = 0; i &lt; int(points.size())-1; ++i)
-        {
-          CL_Pointf normal((points[i].y - points[i+1].y),
-                           -(points[i].x - points[i+1].x));
+   if (points.size() == 1)
+   {
+   normals.push_back(CL_Pointf(1.0f, 1.0f));
+   }
+   else if (points.size() == 2)
+   {
+   normals.push_back(CL_Pointf(1.0f, 1.0f));
+   normals.push_back(CL_Pointf(1.0f, 1.0f));
+   }
+   else if (points.size() &gt;= 3)
+   {
+   for(Points::size_type i = 0; i &lt; int(points.size())-1; ++i)
+   {
+   CL_Pointf normal((points[i].y - points[i+1].y),
+   -(points[i].x - points[i+1].x));
 
-          float length = sqrt(normal.x * normal.x + normal.y * normal.y);
+   float length = sqrt(normal.x * normal.x + normal.y * normal.y);
 
-          normal.x /= length;
-          normal.y /= length;
+   normal.x /= length;
+   normal.y /= length;
           
-          normals.push_back(normal);
-        }
+   normals.push_back(normal);
+   }
       
-      normals.push_back(CL_Pointf(1.0f, 1.0f));
-    }
+   normals.push_back(CL_Pointf(1.0f, 1.0f));
+   }
 
-  //std::cout &lt;&lt; normals.size() &lt;&lt; &quot; == &quot; &lt;&lt;  points.size() &lt;&lt; std::endl;
-  assert(normals.size() == points.size());
+   //std::cout &lt;&lt; normals.size() &lt;&lt; &quot; == &quot; &lt;&lt;  points.size() &lt;&lt; std::endl;
+   assert(normals.size() == points.size());
 
- */
+*/
 
 /*
-  // Calc bounding rect
-  if (points.size() &gt;= 1)
-    {
-      bounding_rect.left = bounding_rect.right  = points.front().x;
-      bounding_rect.top  = bounding_rect.bottom = points.front().y;
+// Calc bounding rect
+if (points.size() &gt;= 1)
+{
+bounding_rect.left = bounding_rect.right  = points.front().x;
+bounding_rect.top  = bounding_rect.bottom = points.front().y;
 
-      for(Points::iterator i = points.begin()+1; i != points.end(); ++i)
-        {
-          bounding_rect.left   = Math::min(bounding_rect.left,   i-&gt;x);
-          bounding_rect.right  = Math::max(bounding_rect.right,  i-&gt;x);;
-          bounding_rect.top    = Math::min(bounding_rect.top,    i-&gt;y);
-          bounding_rect.bottom = Math::min(bounding_rect.bottom, i-&gt;y);
-        }
+for(Points::iterator i = points.begin()+1; i != points.end(); ++i)
+{
+bounding_rect.left   = Math::min(bounding_rect.left,   i-&gt;x);
+bounding_rect.right  = Math::max(bounding_rect.right,  i-&gt;x);;
+bounding_rect.top    = Math::min(bounding_rect.top,    i-&gt;y);
+bounding_rect.bottom = Math::min(bounding_rect.bottom, i-&gt;y);
+}
 
-      // FIXME: Need to take brush size into account
-    }
+// FIXME: Need to take brush size into account
+}
 */
 
 CL_Rectf
 Stroke::get_bounding_rect() const
 {
   if (impl-&gt;bounding_rect_needs_recalc)
-    {
-      impl-&gt;bounding_rect = impl-&gt;calc_bounding_rect();
-      impl-&gt;bounding_rect_needs_recalc = false;
-    }
+  {
+    impl-&gt;bounding_rect = impl-&gt;calc_bounding_rect();
+    impl-&gt;bounding_rect_needs_recalc = false;
+  }
   
   return impl-&gt;bounding_rect;
 }

Modified: trunk/flexlay/lib/tile.cpp
===================================================================
--- trunk/flexlay/lib/tile.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tile.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -89,15 +89,15 @@
 Tile::get_color()
 {
   if (impl-&gt;has_color)
-    {
-      return impl-&gt;color;
-    }
+  {
+    return impl-&gt;color;
+  }
   else
-    {
-      impl-&gt;color = calc_color();
-      impl-&gt;has_color = true;
-      return impl-&gt;color;
-    }
+  {
+    impl-&gt;color = calc_color();
+    impl-&gt;has_color = true;
+    return impl-&gt;color;
+  }
 }
 
 CL_Color
@@ -110,65 +110,65 @@
 Tile::get_sprite()
 {
   if (impl-&gt;sprite)
+  {
+    return impl-&gt;sprite;
+  }
+  else
+  {
+    if (impl-&gt;provider)
     {
-      return impl-&gt;sprite;
+      impl-&gt;sprite = impl-&gt;provider.get_sprite();
     }
-  else
+    else
     {
-      if (impl-&gt;provider)
-        {
-          impl-&gt;sprite = impl-&gt;provider.get_sprite();
-        }
-      else
-        {
-          CL_SpriteDescription desc;
-          desc.add_frame(CL_PixelBuffer(get_pixelbuffer()));
-          impl-&gt;sprite = CL_Sprite(desc);
-        }
+      CL_SpriteDescription desc;
+      desc.add_frame(CL_PixelBuffer(get_pixelbuffer()));
+      impl-&gt;sprite = CL_Sprite(desc);
+    }
 
-      return impl-&gt;sprite;
-    }
+    return impl-&gt;sprite;
+  }
 }
 
 CL_PixelBuffer
 Tile::get_pixelbuffer()
 {
   if (impl-&gt;pixelbuffer)
+  {
+    return impl-&gt;pixelbuffer;
+  }
+  else 
+  {
+    if (impl-&gt;provider)
     {
+      impl-&gt;pixelbuffer = impl-&gt;provider.get_pixelbuffer();
       return impl-&gt;pixelbuffer;
     }
-  else 
+    else
     {
-      if (impl-&gt;provider)
+      // FIXME: Move all this into a special provider
+
+      try {
+        if (has_suffix(impl-&gt;filename, &quot;.png&quot;) || has_suffix(impl-&gt;filename, &quot;.jpg&quot;))
         {
-          impl-&gt;pixelbuffer = impl-&gt;provider.get_pixelbuffer();
-          return impl-&gt;pixelbuffer;
+          impl-&gt;pixelbuffer = CL_PixelBuffer(CL_ProviderFactory::load(impl-&gt;filename));
         }
-      else
+        else
         {
-          // FIXME: Move all this into a special provider
-
-          try {
-            if (has_suffix(impl-&gt;filename, &quot;.png&quot;) || has_suffix(impl-&gt;filename, &quot;.jpg&quot;))
-              {
-                impl-&gt;pixelbuffer = CL_PixelBuffer(CL_ProviderFactory::load(impl-&gt;filename));
-              }
-            else
-              {
-                //CL_SpriteDescription descr(impl-&gt;filename, resources);
-                //impl-&gt;pixelbuffer = CL_PixelBuffer(*(descr.get_frames().begin()-&gt;first));
-                std::cout &lt;&lt; &quot;Error: not a png or jpg file: &quot; &lt;&lt; impl-&gt;filename &lt;&lt; std::endl;
-                assert(0);
-              }
-            return impl-&gt;pixelbuffer;
+          //CL_SpriteDescription descr(impl-&gt;filename, resources);
+          //impl-&gt;pixelbuffer = CL_PixelBuffer(*(descr.get_frames().begin()-&gt;first));
+          std::cout &lt;&lt; &quot;Error: not a png or jpg file: &quot; &lt;&lt; impl-&gt;filename &lt;&lt; std::endl;
+          assert(0);
+        }
+        return impl-&gt;pixelbuffer;
           
-          } catch(CL_Error&amp; err) {
-            std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
-            std::cout &lt;&lt; &quot;          filename = &quot; &lt;&lt; impl-&gt;filename &lt;&lt; std::endl;
-            return CL_PixelBuffer();
-          }
-        }
+      } catch(CL_Error&amp; err) {
+        std::cout &lt;&lt; &quot;CL_Error: &quot; &lt;&lt; err.message &lt;&lt; std::endl;
+        std::cout &lt;&lt; &quot;          filename = &quot; &lt;&lt; impl-&gt;filename &lt;&lt; std::endl;
+        return CL_PixelBuffer();
+      }
     }
+  }
 }
 
 CL_Color
@@ -185,39 +185,39 @@
   int alpha = 0;
   
   switch (buffer.get_format().get_depth())
+  {
+    case 8:
     {
-    case 8:
+      CL_Palette palette = buffer.get_palette();
+      for(int i = 0; i &lt; len; ++i)
       {
-        CL_Palette palette = buffer.get_palette();
-        for(int i = 0; i &lt; len; ++i)
-          {
-            red   += palette.colors[buf[i]].get_red();
-            green += palette.colors[buf[i]].get_green();
-            blue  += palette.colors[buf[i]].get_blue();
-            alpha += 255;
-          }
+        red   += palette.colors[buf[i]].get_red();
+        green += palette.colors[buf[i]].get_green();
+        blue  += palette.colors[buf[i]].get_blue();
+        alpha += 255;
       }
-      break;
+    }
+    break;
     case 24:
       for(int i = 0; i &lt; len; ++i)
-        {
-          red   += buf[3*i + 0];
-          green += buf[3*i + 1];
-          blue  += buf[3*i + 2];
-          alpha += 255;
-        }
+      {
+        red   += buf[3*i + 0];
+        green += buf[3*i + 1];
+        blue  += buf[3*i + 2];
+        alpha += 255;
+      }
       break;
     case 32:
       for(int i = 0; i &lt; len; ++i)
-        {
-          int a = buf[4*i + 0];
-          alpha += a;
-          red   += buf[4*i + 3]*a/255;;
-          green += buf[4*i + 2]*a/255;;
-          blue  += buf[4*i + 1]*a/255;;
-        }
+      {
+        int a = buf[4*i + 0];
+        alpha += a;
+        red   += buf[4*i + 3]*a/255;;
+        green += buf[4*i + 2]*a/255;;
+        blue  += buf[4*i + 1]*a/255;;
+      }
       break;
-    }
+  }
 
   buffer.unlock();
 

Modified: trunk/flexlay/lib/tile_brush.cpp
===================================================================
--- trunk/flexlay/lib/tile_brush.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tile_brush.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -44,48 +44,48 @@
   for(int y = 0; y &lt; get_height(); ++y)
     for(int x = 0; x &lt; get_width(); ++x)
       if (at(x, y) != 0)
-        {
-          rect.top = y;
-          goto bottom;
-        }
+      {
+        rect.top = y;
+        goto bottom;
+      }
 
- bottom:
+bottom:
   for(int y = get_height()-1; y &gt;= 0; --y)
     for(int x = 0; x &lt; get_width(); ++x)
       if (at(x, y) != 0)
-        {
-          rect.bottom = y + 1;
-          goto left;
-        }
+      {
+        rect.bottom = y + 1;
+        goto left;
+      }
 
- left:
+left:
   for(int x = 0; x &lt; get_width(); ++x)
     for(int y = 0; y &lt; get_height(); ++y)
       if (at(x, y) != 0)
-        {
-          rect.left = x;
-          goto right;
-        }
+      {
+        rect.left = x;
+        goto right;
+      }
 
- right:
+right:
   for(int x = get_width() - 1; x &gt;= 0; --x)
     for(int y = 0; y &lt; get_height(); ++y)
       if (at(x, y) != 0)
-        {
-          rect.right = x + 1;
-          goto end;
-        }
+      {
+        rect.right = x + 1;
+        goto end;
+      }
 
- end:
+end:
   if (rect.get_width() != 0)
     resize(rect.get_width(), rect.get_height(), 
            -rect.left, -rect.top);
   else
-    {
-      (*this) = TileBrush(1, 1);
-      at(0, 0) = 0;
-      set_opaque();
-    }
+  {
+    (*this) = TileBrush(1, 1);
+    at(0, 0) = 0;
+    set_opaque();
+  }
 }
 
 void

Modified: trunk/flexlay/lib/tile_editor.cpp
===================================================================
--- trunk/flexlay/lib/tile_editor.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tile_editor.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -48,31 +48,31 @@
   CL_Display::fill_rect(CL_Rect(0, 0, 32, 32), CL_Color(155, 0, 155));
 
   if (tile)
-    {
-      tile-&gt;get_sprite().draw(0, 0);
-      CL_Display::flush();
-      for(int tile_y = 0; tile_y &lt; 8; ++tile_y)
-        for(int tile_x = 0; tile_x &lt; 8; ++tile_x)
-          {
-            if (tile-&gt;get_col(tile_x, tile_y))
-              {
-                CL_Display::fill_rect(CL_Rect(tile_x*16, tile_y*16,
-                                              tile_x*16 + 16, tile_y*16 + 16),
-                                      CL_Color(255, 0, 0, 128));
-              }
-          }
-      CL_Display::flush();
-      if (has_mouse_over())
+  {
+    tile-&gt;get_sprite().draw(0, 0);
+    CL_Display::flush();
+    for(int tile_y = 0; tile_y &lt; 8; ++tile_y)
+      for(int tile_x = 0; tile_x &lt; 8; ++tile_x)
+      {
+        if (tile-&gt;get_col(tile_x, tile_y))
         {
-          CL_Display::fill_rect(CL_Rect(CL_Point(int(mouse_pos.x)/16 * 16, 
-                                                 int(mouse_pos.y)/16 * 16),
-                                        CL_Size(16, 16)),
-                                CL_Color(255, 255, 255, 128));
+          CL_Display::fill_rect(CL_Rect(tile_x*16, tile_y*16,
+                                        tile_x*16 + 16, tile_y*16 + 16),
+                                CL_Color(255, 0, 0, 128));
         }
+      }
+    CL_Display::flush();
+    if (has_mouse_over())
+    {
+      CL_Display::fill_rect(CL_Rect(CL_Point(int(mouse_pos.x)/16 * 16, 
+                                             int(mouse_pos.y)/16 * 16),
+                                    CL_Size(16, 16)),
+                            CL_Color(255, 255, 255, 128));
     }
+  }
   else
-    {
-    }
+  {
+  }
 
   CL_Display::pop_modelview();
 }
@@ -92,35 +92,35 @@
 TileEditor::mouse_down(const CL_InputEvent&amp; event)
 {
   if (tile)
+  {
+    switch (event.id)
     {
-      switch (event.id)
-        {
-        case CL_MOUSE_LEFT:
-          paint(event.mouse_pos, true);
-          break;
+      case CL_MOUSE_LEFT:
+        paint(event.mouse_pos, true);
+        break;
               
-        case CL_MOUSE_RIGHT:
-          paint(event.mouse_pos, false);
-          break;
+      case CL_MOUSE_RIGHT:
+        paint(event.mouse_pos, false);
+        break;
         
-        }
     }
+  }
 }
 
 void
 TileEditor::paint(CL_Point pos, bool val)
 {
   if (tile)
+  {
+    int x = int(pos.x) / 16;
+    int y = int(pos.y) / 16;
+
+    if (x &gt;= 0 &amp;&amp; y &gt;= 0
+        &amp;&amp; x &lt; 8 &amp;&amp; y &lt; 8)
     {
-      int x = int(pos.x) / 16;
-      int y = int(pos.y) / 16;
-
-      if (x &gt;= 0 &amp;&amp; y &gt;= 0
-          &amp;&amp; x &lt; 8 &amp;&amp; y &lt; 8)
-        {
-          tile-&gt;set_col(x, y, val);
-        }
+      tile-&gt;set_col(x, y, val);
     }
+  }
 }
 
 void

Modified: trunk/flexlay/lib/tile_selection.cpp
===================================================================
--- trunk/flexlay/lib/tile_selection.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tile_selection.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -95,34 +95,34 @@
       || sel.top   &gt; field.get_height() - 1
       || sel.right  &lt;= 0
       || sel.bottom &lt;= 0)
-    { // Selection is empty
-      std::cout &lt;&lt; &quot;Error: Invalid selection&quot; &lt;&lt; std::endl;
-      TileBrush brush(1, 1);
-      brush.at(0, 0) = 0;
-      brush.set_opaque();
-      return brush;
-    }
+  { // Selection is empty
+    std::cout &lt;&lt; &quot;Error: Invalid selection&quot; &lt;&lt; std::endl;
+    TileBrush brush(1, 1);
+    brush.at(0, 0) = 0;
+    brush.set_opaque();
+    return brush;
+  }
   else
-    { // Selection is valid
-      // Cut the selection to the field size
-      sel.left = Math::max(0, sel.left);
-      sel.top  = Math::max(0, sel.top);
+  { // Selection is valid
+    // Cut the selection to the field size
+    sel.left = Math::max(0, sel.left);
+    sel.top  = Math::max(0, sel.top);
 
-      sel.right  = Math::min(sel.right,  field.get_width()); 
-      sel.bottom = Math::min(sel.bottom, field.get_height()); 
+    sel.right  = Math::min(sel.right,  field.get_width()); 
+    sel.bottom = Math::min(sel.bottom, field.get_height()); 
 
-      TileBrush brush(sel.get_width(), 
-                      sel.get_height());
+    TileBrush brush(sel.get_width(), 
+                    sel.get_height());
 
-      for(int y = sel.top; y &lt; sel.bottom; ++y)
-        for(int x = sel.left; x &lt; sel.right; ++x)
-          {
-            brush.at(x - sel.left, 
-                     y - sel.top) = field.at(x, y);
-          }
+    for(int y = sel.top; y &lt; sel.bottom; ++y)
+      for(int x = sel.left; x &lt; sel.right; ++x)
+      {
+        brush.at(x - sel.left, 
+                 y - sel.top) = field.at(x, y);
+      }
 
-      return brush;
-    }
+    return brush;
+  }
 }
 
 CL_Rect

Modified: trunk/flexlay/lib/tile_selector.cpp
===================================================================
--- trunk/flexlay/lib/tile_selector.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tile_selector.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -68,74 +68,74 @@
 TileSelector::mouse_up(const CL_InputEvent&amp; event)
 {
   if (event.id == CL_MOUSE_MIDDLE)
-    {
-      scrolling = false;
-      release_mouse();
-    }
+  {
+    scrolling = false;
+    release_mouse();
+  }
   else if (event.id == CL_MOUSE_RIGHT)
-    {
-      release_mouse();
-      region_select = false;
+  {
+    release_mouse();
+    region_select = false;
 
-      CL_Rect selection = get_selection();
-      //selection.bottom = Math::mid(0, selection.right, width);
+    CL_Rect selection = get_selection();
+    //selection.bottom = Math::mid(0, selection.right, width);
 
-      TileBrush brush(selection.get_width(), selection.get_height());
-      brush.set_transparent();
+    TileBrush brush(selection.get_width(), selection.get_height());
+    brush.set_transparent();
 
-      for(int y = 0; y &lt; selection.get_height(); ++y)
-        for(int x = 0; x &lt; selection.get_width(); ++x)
-          {
-            int tile = (selection.top + y) * width + (selection.left + x);
+    for(int y = 0; y &lt; selection.get_height(); ++y)
+      for(int x = 0; x &lt; selection.get_width(); ++x)
+      {
+        int tile = (selection.top + y) * width + (selection.left + x);
 
-            if (tile &gt;= 0 &amp;&amp; tile &lt; int(tiles.size()))
-              brush.at(x, y) = tiles[tile];
-            else
-              brush.at(x, y) = 0;
-          }
+        if (tile &gt;= 0 &amp;&amp; tile &lt; int(tiles.size()))
+          brush.at(x, y) = tiles[tile];
+        else
+          brush.at(x, y) = 0;
+      }
 
-      TileMapPaintTool::current().set_brush(brush);
-    }
+    TileMapPaintTool::current().set_brush(brush);
+  }
 }
 
 void
 TileSelector::mouse_down(const CL_InputEvent&amp; event)
 {
   if (event.id == CL_MOUSE_LEFT)
-    {
-      TileBrush brush(1, 1);
+  {
+    TileBrush brush(1, 1);
 
-      brush.set_opaque();
-      if (mouse_over_tile &gt;= 0 &amp;&amp; mouse_over_tile &lt; int(tiles.size()))
-        brush.at(0, 0) = tiles[mouse_over_tile];
-      else
-        brush.at(0, 0) = 0;
+    brush.set_opaque();
+    if (mouse_over_tile &gt;= 0 &amp;&amp; mouse_over_tile &lt; int(tiles.size()))
+      brush.at(0, 0) = tiles[mouse_over_tile];
+    else
+      brush.at(0, 0) = 0;
 
-      TileMapPaintTool::current().set_brush(brush);
-    }
+    TileMapPaintTool::current().set_brush(brush);
+  }
   else if (event.id == CL_MOUSE_RIGHT) 
-    {
-      region_select = true;
-      region_select_start = current_pos;
-      capture_mouse();
-    }
+  {
+    region_select = true;
+    region_select_start = current_pos;
+    capture_mouse();
+  }
   else if (event.id == CL_MOUSE_MIDDLE)
-    {
-      scrolling = true;
-      mouse_pos = event.mouse_pos;
-      old_offset = offset;
-      capture_mouse();
-    }
+  {
+    scrolling = true;
+    mouse_pos = event.mouse_pos;
+    old_offset = offset;
+    capture_mouse();
+  }
   else if (event.id == CL_MOUSE_WHEEL_UP)
-    {
-      offset -= static_cast&lt;int&gt;(tileset.get_tile_size()*scale);
-      if (offset &lt; 0)
-        offset = 0;
-    }
+  {
+    offset -= static_cast&lt;int&gt;(tileset.get_tile_size()*scale);
+    if (offset &lt; 0)
+      offset = 0;
+  }
   else if (event.id == CL_MOUSE_WHEEL_DOWN)
-    {
-      offset += static_cast&lt;int&gt;(tileset.get_tile_size()*scale);
-    }
+  {
+    offset += static_cast&lt;int&gt;(tileset.get_tile_size()*scale);
+  }
 }
 
 CL_Point
@@ -153,11 +153,11 @@
   mouse_over_tile = pos.y * width + pos.x;
 
   if (scrolling)
-    {
-      offset = old_offset + (mouse_pos.y - event.mouse_pos.y);
-      if (offset &lt; 0)
-        offset = 0;
-    }
+  {
+    offset = old_offset + (mouse_pos.y - event.mouse_pos.y);
+    if (offset &lt; 0)
+      offset = 0;
+  }
 }
 
 void 
@@ -176,53 +176,53 @@
   
   // Draw tiles
   for(int i = (start_row*width); i &lt; end_index; ++i)
-    {
-      int x = i % width;
-      int y = i / width;
+  {
+    int x = i % width;
+    int y = i / width;
 
-      Tile* tile = tileset.create(tiles[i]);
+    Tile* tile = tileset.create(tiles[i]);
 
-      CL_Rect rect(CL_Point(static_cast&lt;int&gt;(x * tileset.get_tile_size()*scale),
-                            static_cast&lt;int&gt;(y * tileset.get_tile_size()*scale)),
-                   CL_Size(static_cast&lt;int&gt;(tileset.get_tile_size()*scale),
-                           static_cast&lt;int&gt;(tileset.get_tile_size()*scale)));
+    CL_Rect rect(CL_Point(static_cast&lt;int&gt;(x * tileset.get_tile_size()*scale),
+                          static_cast&lt;int&gt;(y * tileset.get_tile_size()*scale)),
+                 CL_Size(static_cast&lt;int&gt;(tileset.get_tile_size()*scale),
+                         static_cast&lt;int&gt;(tileset.get_tile_size()*scale)));
 
-      if (tile)
-        {
-          CL_Sprite sprite = tile-&gt;get_sprite();
+    if (tile)
+    {
+      CL_Sprite sprite = tile-&gt;get_sprite();
 
-          sprite.set_scale(scale, scale);
+      sprite.set_scale(scale, scale);
 
-          sprite.draw(static_cast&lt;int&gt;(x * tileset.get_tile_size()*scale), 
-                      static_cast&lt;int&gt;(y * tileset.get_tile_size()*scale));
+      sprite.draw(static_cast&lt;int&gt;(x * tileset.get_tile_size()*scale), 
+                  static_cast&lt;int&gt;(y * tileset.get_tile_size()*scale));
 
-          // Use grid in the tileselector
-          //CL_Display::draw_rect(rect, CL_Color(0,0,0,128));
-        }
+      // Use grid in the tileselector
+      //CL_Display::draw_rect(rect, CL_Color(0,0,0,128));
+    }
 
-      if (brush.get_width() == 1 &amp;&amp; brush.get_height() == 1
-          &amp;&amp; brush.at(0, 0) == tiles[i])
-        {
-          CL_Display::fill_rect(rect,
-                                CL_Color(0,0,255, 100));
-        }
-      else if (mouse_over_tile == int(i) &amp;&amp; has_mouse_over())
-        {
-          CL_Display::fill_rect(rect, CL_Color(0,0,255, 20));
-        }
+    if (brush.get_width() == 1 &amp;&amp; brush.get_height() == 1
+        &amp;&amp; brush.at(0, 0) == tiles[i])
+    {
+      CL_Display::fill_rect(rect,
+                            CL_Color(0,0,255, 100));
     }
+    else if (mouse_over_tile == int(i) &amp;&amp; has_mouse_over())
+    {
+      CL_Display::fill_rect(rect, CL_Color(0,0,255, 20));
+    }
+  }
 
   if (region_select)
-    {
-      CL_Rect rect = get_selection();
+  {
+    CL_Rect rect = get_selection();
 
-      rect.top    *= static_cast&lt;int&gt;(tileset.get_tile_size()*scale);
-      rect.bottom *= static_cast&lt;int&gt;(tileset.get_tile_size()*scale);
-      rect.left   *= static_cast&lt;int&gt;(tileset.get_tile_size()*scale);
-      rect.right  *= static_cast&lt;int&gt;(tileset.get_tile_size()*scale);
+    rect.top    *= static_cast&lt;int&gt;(tileset.get_tile_size()*scale);
+    rect.bottom *= static_cast&lt;int&gt;(tileset.get_tile_size()*scale);
+    rect.left   *= static_cast&lt;int&gt;(tileset.get_tile_size()*scale);
+    rect.right  *= static_cast&lt;int&gt;(tileset.get_tile_size()*scale);
 
-      CL_Display::fill_rect(rect, CL_Color(0,0,255, 100));
-    }
+    CL_Display::fill_rect(rect, CL_Color(0,0,255, 100));
+  }
   
   CL_Display::pop_modelview();
   CL_Display::pop_cliprect();

Modified: trunk/flexlay/lib/tilemap_layer.cpp
===================================================================
--- trunk/flexlay/lib/tilemap_layer.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tilemap_layer.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -62,8 +62,8 @@
 
 /*TilemapLayer::TilemapLayer(const SharedPtr&lt;TilemapLayerImpl&gt;&amp; i)
   : impl(i)
-{
-}*/
+  {
+  }*/
 
 TilemapLayer::TilemapLayer(Tileset tileset_, int w,  int h)
   : impl(new TilemapLayerImpl())
@@ -116,66 +116,66 @@
   int end_y   = std::min(this-&gt;field.get_height(), rect.bottom / tile_size + 1);
 
   if (foreground_color != CL_Color(255, 255, 255, 255))
-    {
-      for (int y = start_y; y &lt; end_y; ++y)
-        for (int x = start_x; x &lt; end_x; ++x)
-          {
-            int tile_id = this-&gt;field.at(x, y);
-            if (tile_id)
-              {
-                Tile* tile = tileset.create(tile_id);
-                if (tile) // skip transparent tile for faster draw
-                  {           
-                    CL_Sprite sprite = tile-&gt;get_sprite();
-                    sprite.set_color(foreground_color);
-                    sprite.draw(x * tile_size, y * tile_size, gc);
+  {
+    for (int y = start_y; y &lt; end_y; ++y)
+      for (int x = start_x; x &lt; end_x; ++x)
+      {
+        int tile_id = this-&gt;field.at(x, y);
+        if (tile_id)
+        {
+          Tile* tile = tileset.create(tile_id);
+          if (tile) // skip transparent tile for faster draw
+          {           
+            CL_Sprite sprite = tile-&gt;get_sprite();
+            sprite.set_color(foreground_color);
+            sprite.draw(x * tile_size, y * tile_size, gc);
       
-                    if (draw_attribute)
-                      CL_Display::fill_rect(CL_Rect(CL_Point(x, y), CL_Size(tileset.get_tile_size(),
-                                                                            tileset.get_tile_size())),
-                                            tile-&gt;get_attribute_color());
-                  }
-              }
+            if (draw_attribute)
+              CL_Display::fill_rect(CL_Rect(CL_Point(x, y), CL_Size(tileset.get_tile_size(),
+                                                                    tileset.get_tile_size())),
+                                    tile-&gt;get_attribute_color());
           }
-    }
+        }
+      }
+  }
   else
-    {
-      for (int y = start_y; y &lt; end_y; ++y)
-        for (int x = start_x; x &lt; end_x; ++x)
-          {
-            int tile_id = this-&gt;field.at(x, y);
-            if (tile_id) // skip transparent tile for faster draw
-              {
-                Tile* tile = tileset.create(this-&gt;field.at(x, y));
-                if (tile)
-                  {           
-                    tile-&gt;get_sprite().draw(x * tile_size, y * tile_size, gc);
+  {
+    for (int y = start_y; y &lt; end_y; ++y)
+      for (int x = start_x; x &lt; end_x; ++x)
+      {
+        int tile_id = this-&gt;field.at(x, y);
+        if (tile_id) // skip transparent tile for faster draw
+        {
+          Tile* tile = tileset.create(this-&gt;field.at(x, y));
+          if (tile)
+          {           
+            tile-&gt;get_sprite().draw(x * tile_size, y * tile_size, gc);
       
-                    if (draw_attribute)
-                      CL_Display::fill_rect(CL_Rect(CL_Point(x, y), CL_Size(tileset.get_tile_size(),
-                                                                            tileset.get_tile_size())),
-                                            tile-&gt;get_attribute_color());
-                  }
-              }
+            if (draw_attribute)
+              CL_Display::fill_rect(CL_Rect(CL_Point(x, y), CL_Size(tileset.get_tile_size(),
+                                                                    tileset.get_tile_size())),
+                                    tile-&gt;get_attribute_color());
           }
-    }
+        }
+      }
+  }
 
   if (this-&gt;draw_grid)
-    {
-      for (int y = start_y; y &lt;= end_y; ++y)
-        CL_Display::draw_line(start_x * tile_size,
-                              y       * tile_size,
-                              end_x   * tile_size,
-                              y       * tile_size, 
-                              y % 2 ? CL_Color(150, 150, 150) : CL_Color(255, 255, 255));
+  {
+    for (int y = start_y; y &lt;= end_y; ++y)
+      CL_Display::draw_line(start_x * tile_size,
+                            y       * tile_size,
+                            end_x   * tile_size,
+                            y       * tile_size, 
+                            y % 2 ? CL_Color(150, 150, 150) : CL_Color(255, 255, 255));
   
-      for (int x = start_x; x &lt;= end_x; ++x)
-        CL_Display::draw_line(x       * tile_size,
-                              start_y * tile_size,
-                              x       * tile_size,
-                              end_y   * tile_size, 
-                              x % 2 ? CL_Color(150, 150, 150) : CL_Color(255, 255, 255));
-    }
+    for (int x = start_x; x &lt;= end_x; ++x)
+      CL_Display::draw_line(x       * tile_size,
+                            start_y * tile_size,
+                            x       * tile_size,
+                            end_y   * tile_size, 
+                            x % 2 ? CL_Color(150, 150, 150) : CL_Color(255, 255, 255));
+  }
 
   CL_Display::flush();
 }
@@ -201,9 +201,9 @@
 {
   if (pos.x &gt;= 0 &amp;&amp; pos.x &lt; impl-&gt;field.get_width()
       &amp;&amp; pos.y &gt;= 0 &amp;&amp; pos.y &lt; impl-&gt;field.get_height())
-    {
-      impl-&gt;field.at(pos.x, pos.y) = id;
-    }
+  {
+    impl-&gt;field.at(pos.x, pos.y) = id;
+  }
 }
 
 void
@@ -223,12 +223,12 @@
 
   for (int y = start_y; y &lt; end_y; ++y)
     for (int x = start_x; x &lt; end_x; ++x)
+    {
+      if (brush.is_opaque() || brush.at(x, y) != 0)
       {
-        if (brush.is_opaque() || brush.at(x, y) != 0)
-          {
-            field-&gt;at(pos.x + x, pos.y + y) = brush.at(x, y);
-          }
+        field-&gt;at(pos.x + x, pos.y + y) = brush.at(x, y);
       }
+    }
 }
 
 void
@@ -274,32 +274,32 @@
 
     // Draw a nice gradient
     for(int y = 0; y &lt; height; ++y)
+    {
+      for (int x = 0; x &lt; width; ++x)
       {
-        for (int x = 0; x &lt; width; ++x)
-          {
-            buf[4*(y*width + x) + 0] = 255;
-            buf[4*(y*width + x) + 1] = 255;
-            buf[4*(y*width + x) + 2] = 255*y/height;
-            buf[4*(y*width + x) + 3] = 255*y/height;
-          }
+        buf[4*(y*width + x) + 0] = 255;
+        buf[4*(y*width + x) + 1] = 255;
+        buf[4*(y*width + x) + 2] = 255*y/height;
+        buf[4*(y*width + x) + 3] = 255*y/height;
       }
+    }
     pixelbuffer.unlock();
   }
 
   for (int y = 0; y &lt; get_height(); ++y)
     for (int x = 0; x &lt; get_width(); ++x)
+    {
+      Tile* tile = impl-&gt;tileset.create(impl-&gt;field.at(x, y));
+
+      if (tile)
       {
-        Tile* tile = impl-&gt;tileset.create(impl-&gt;field.at(x, y));
-
-        if (tile)
-          {
-            CL_PixelBuffer buf = tile-&gt;get_pixelbuffer();
-            if (buf)
-              {
-                blit(pixelbuffer, buf, x*tile_size, y*tile_size);
-              }
-          }
+        CL_PixelBuffer buf = tile-&gt;get_pixelbuffer();
+        if (buf)
+        {
+          blit(pixelbuffer, buf, x*tile_size, y*tile_size);
+        }
       }
+    }
 
   return pixelbuffer;
 }
@@ -403,7 +403,7 @@
 Layer
 TilemapLayer::to_layer()
 {
-   return Layer(impl);
+  return Layer(impl);
 }
 
 void

Modified: trunk/flexlay/lib/tilemap_layer.hpp
===================================================================
--- trunk/flexlay/lib/tilemap_layer.hpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tilemap_layer.hpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -53,7 +53,7 @@
 
   /** @param pos position of the old map in the new resized one
       @param size height of the new map */
- void resize(const CL_Size&amp; size, const CL_Point&amp; point);
+  void resize(const CL_Size&amp; size, const CL_Point&amp; point);
 
   const std::vector&lt;int&gt;&amp; get_data();
   void set_data(std::vector&lt;int&gt; d);

Modified: trunk/flexlay/lib/tileset.cpp
===================================================================
--- trunk/flexlay/lib/tileset.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tileset.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -37,9 +37,9 @@
   ~TilesetImpl()
   {
     for(Tiles::iterator i = tiles.begin(); i != tiles.end(); ++i)
-      {
-        delete *i;
-      }
+    {
+      delete *i;
+    }
   }
 
   TileIds tile_ids;

Modified: trunk/flexlay/lib/titlebar.cpp
===================================================================
--- trunk/flexlay/lib/titlebar.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/titlebar.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -58,40 +58,40 @@
 TitlebarImpl::on_mouse_up(const CL_InputEvent&amp; event)
 {
   if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed = false;
-      parent-&gt;release_mouse();
-    }
+  {
+    pressed = false;
+    parent-&gt;release_mouse();
+  }
 }
 
 void
 TitlebarImpl::on_mouse_down(const CL_InputEvent&amp; event)
 {
   if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed   = true;
-      click_pos = event.mouse_pos;
-      parent-&gt;capture_mouse();
-      window-&gt;raise();
+  {
+    pressed   = true;
+    click_pos = event.mouse_pos;
+    parent-&gt;capture_mouse();
+    window-&gt;raise();
 
-      old_pos = window-&gt;get_position();
-      click_pos.x += old_pos.left;
-      click_pos.y += old_pos.top;
-    } 
+    old_pos = window-&gt;get_position();
+    click_pos.x += old_pos.left;
+    click_pos.y += old_pos.top;
+  } 
 }
 
 void
 TitlebarImpl::on_mouse_move(const CL_InputEvent&amp; event)
 {
   if(pressed)
-    {
-      CL_Rect rect = window-&gt;get_position();
+  {
+    CL_Rect rect = window-&gt;get_position();
 
-      CL_Point move(old_pos.left - (click_pos.x - (rect.left + event.mouse_pos.x)), 
-                    old_pos.top  - (click_pos.y - (rect.top  + event.mouse_pos.y)));
+    CL_Point move(old_pos.left - (click_pos.x - (rect.left + event.mouse_pos.x)), 
+                  old_pos.top  - (click_pos.y - (rect.top  + event.mouse_pos.y)));
 
-      window-&gt;set_position(move.x, move.y);
-    }
+    window-&gt;set_position(move.x, move.y);
+  }
 }
 
 void
@@ -102,18 +102,18 @@
   // FIXME: Hack should be done via has_mouse_over(), but that doesn't include child components
   if (parent-&gt;get_parent()-&gt;get_position().is_inside(CL_Point(CL_Mouse::get_x(), 
                                                               CL_Mouse::get_y())))
-      //parent-&gt;get_parent()-&gt;has_mouse_over())
-    {
-      CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
-                                    CL_Size(parent-&gt;get_width()-1, parent-&gt;get_height())), 
-                            CL_Color(250, 250, 250));
-    }
+    //parent-&gt;get_parent()-&gt;has_mouse_over())
+  {
+    CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
+                                  CL_Size(parent-&gt;get_width()-1, parent-&gt;get_height())), 
+                          CL_Color(250, 250, 250));
+  }
   else
-    {
-      CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
-                                    CL_Size(parent-&gt;get_width()-1, parent-&gt;get_height())), 
-                            CL_Color(240, 240, 240));
-    }
+  {
+    CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
+                                  CL_Size(parent-&gt;get_width()-1, parent-&gt;get_height())), 
+                          CL_Color(240, 240, 240));
+  }
 
   Fonts::verdana11.draw(4, 0, title);
 

Modified: trunk/flexlay/lib/tools/layer_move_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/layer_move_tool.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tools/layer_move_tool.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -43,10 +43,10 @@
     EditorMap parent = EditorMapComponent::current()-&gt;get_workspace().get_map();
 
     for(int i = 0; i &lt; parent.get_layer_count(); ++i)
-      {
-        if (parent.get_layer(i).get_bounding_rect().is_inside(CL_Point(pos)))
-          layer = parent.get_layer(i);
-      }
+    {
+      if (parent.get_layer(i).get_bounding_rect().is_inside(CL_Point(pos)))
+        layer = parent.get_layer(i);
+    }
 
     return layer;
   }
@@ -54,28 +54,28 @@
   void draw() 
   {
     for(int i = 0; i &lt; EditorMapComponent::current()-&gt;get_workspace().get_map().get_layer_count(); ++i)
+    {
+      Layer layer = EditorMapComponent::current()-&gt;get_workspace().get_map().get_layer(i);
+      if (layer.has_bounding_rect())
       {
-        Layer layer = EditorMapComponent::current()-&gt;get_workspace().get_map().get_layer(i);
-        if (layer.has_bounding_rect())
-          {
-            CL_Rect rect = layer.get_bounding_rect();
-            CL_Display::draw_line(rect.left, rect.top, rect.right, rect.bottom,
-                                  CL_Color(0, 255, 255));
-            CL_Display::draw_line(rect.left, rect.bottom, rect.right, rect.top,
-                                  CL_Color(0, 255, 255));
-          }
+        CL_Rect rect = layer.get_bounding_rect();
+        CL_Display::draw_line(rect.left, rect.top, rect.right, rect.bottom,
+                              CL_Color(0, 255, 255));
+        CL_Display::draw_line(rect.left, rect.bottom, rect.right, rect.top,
+                              CL_Color(0, 255, 255));
       }
+    }
   }
 
   void on_mouse_up  (const CL_InputEvent&amp; event) 
   {
     if (!layer.is_null())
-      {
-        scrolling = false;
-        update(event);
-        EditorMapComponent::current()-&gt;release_mouse();
-        layer = Layer();
-      }
+    {
+      scrolling = false;
+      update(event);
+      EditorMapComponent::current()-&gt;release_mouse();
+      layer = Layer();
+    }
   }
 
   void on_mouse_down(const CL_InputEvent&amp; event)
@@ -85,33 +85,33 @@
 
     layer = find_closed_layer(pos);
     if (!layer.is_null())
-      {
-        scrolling = true;
-        old_trans_offset = layer.get_pos();
-        click_pos = pos;
-        EditorMapComponent::current()-&gt;capture_mouse();
-      }
+    {
+      scrolling = true;
+      old_trans_offset = layer.get_pos();
+      click_pos = pos;
+      EditorMapComponent::current()-&gt;capture_mouse();
+    }
   }
 
   void on_mouse_move(const CL_InputEvent&amp; event)
   {
     if (!layer.is_null())
+    {
+      if (scrolling)
       {
-        if (scrolling)
-          {
-            update(event);
-          }
-      }    
+        update(event);
+      }
+    }    
   }
 
   void update(const CL_InputEvent&amp; event)
   {
     if (!layer.is_null())
-      {
-        EditorMapComponent* parent = EditorMapComponent::current();
-        CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
-        layer.set_pos(old_trans_offset + (pos - click_pos));
-      }
+    {
+      EditorMapComponent* parent = EditorMapComponent::current();
+      CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
+      layer.set_pos(old_trans_offset + (pos - click_pos));
+    }
   }
 };
 

Modified: trunk/flexlay/lib/tools/objmap_select_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/objmap_select_tool.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tools/objmap_select_tool.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -108,13 +108,13 @@
 ObjMapSelectToolImpl::draw()
 {
   for (ObjMapSelectTool::Selection::iterator i = selection.begin(); i != selection.end(); ++i)
-    {
-      //      (*i).draw();
-      CL_Display::draw_rect((*i).get_bound_rect(), CL_Color(255, 0, 0));
-    }
+  {
+    //      (*i).draw();
+    CL_Display::draw_rect((*i).get_bound_rect(), CL_Color(255, 0, 0));
+  }
 
   switch(state)
-    {
+  {
     case DRAG:
       break;
     case SELECT:
@@ -123,7 +123,7 @@
       break;
     default:
       break;
-    }
+  }
 }
 
 void
@@ -136,16 +136,16 @@
   CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
 
   switch (event.id)
-    {
+  {
     case CL_MOUSE_LEFT:
       switch(state)
-        {
+      {
         case DRAG:
           if (move_command)
-            {
-              Workspace::current().get_map().execute(move_command-&gt;to_command());
-              move_command = 0;
-            }
+          {
+            Workspace::current().get_map().execute(move_command-&gt;to_command());
+            move_command = 0;
+          }
           state = NONE;
           parent-&gt;release_mouse();
           break;
@@ -164,22 +164,22 @@
 
         default:
           break;
-        }
+      }
       break;
 
     case CL_MOUSE_RIGHT:
-      {
-        on_right_click(event.mouse_pos.x + parent-&gt;get_screen_rect().left,
-                       event.mouse_pos.y + parent-&gt;get_screen_rect().top);
-        /*
+    {
+      on_right_click(event.mouse_pos.x + parent-&gt;get_screen_rect().left,
+                     event.mouse_pos.y + parent-&gt;get_screen_rect().top);
+      /*
         PopupMenu* menu = new PopupMenu(CL_Point(event.mouse_pos.x + parent-&gt;get_screen_rect().left,
-                                                 event.mouse_pos.y + parent-&gt;get_screen_rect().top), 
-                                        GUIManager::current()-&gt;get_component());
+        event.mouse_pos.y + parent-&gt;get_screen_rect().top), 
+        GUIManager::current()-&gt;get_component());
 
-                                        on_popup_menu_display(menu-&gt;get_menu());*/
-      }
-      break;
+        on_popup_menu_display(menu-&gt;get_menu());*/
     }
+    break;
+  }
 }
 
 void
@@ -191,74 +191,74 @@
   CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
       
   switch (event.id)
-    {
+  {
     case CL_MOUSE_LEFT:
       switch(state)
-        {
+      {
         default:
           control_point = objmap.find_control_point(pos);
 
           if (!control_point.is_null())
-            {
-              state = DRAG;
-              parent-&gt;capture_mouse();
-              offset = pos - control_point.get_pos();
-              drag_start = pos;
-            }
+          {
+            state = DRAG;
+            parent-&gt;capture_mouse();
+            offset = pos - control_point.get_pos();
+            drag_start = pos;
+          }
           else
+          {
+            ObjMapObject obj = objmap.find_object(pos);
+
+            if (!obj.is_null())
             {
-              ObjMapObject obj = objmap.find_object(pos);
+              if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT))
+              {
+                ObjMapSelectTool::Selection::iterator i
+                  = std::find(selection.begin(), selection.end(), obj);
+                if (i == selection.end())
+                  selection.push_back(obj);
+                else
+                  selection.erase(i);
 
-              if (!obj.is_null())
-                {
-                  if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT))
-                    {
-                      ObjMapSelectTool::Selection::iterator i
-                        = std::find(selection.begin(), selection.end(), obj);
-                      if (i == selection.end())
-                        selection.push_back(obj);
-                      else
-                        selection.erase(i);
+                on_selection_change();
+              }
+              else
+              {
+                state = DRAG;
+                parent-&gt;capture_mouse();
+                offset = pos - obj.get_pos();
+                drag_start = pos;
 
-                      on_selection_change();
-                    }
-                  else
-                    {
-                      state = DRAG;
-                      parent-&gt;capture_mouse();
-                      offset = pos - obj.get_pos();
-                      drag_start = pos;
+                if (std::find(selection.begin(), selection.end(), obj) == selection.end())
+                { // Clicked object is not in the selection, so we add it
+                  selection.clear();
+                  objmap.delete_control_points();
+                  selection.push_back(obj);
+                  on_selection_change();
+                }
 
-                      if (std::find(selection.begin(), selection.end(), obj) == selection.end())
-                        { // Clicked object is not in the selection, so we add it
-                          selection.clear();
-                          objmap.delete_control_points();
-                          selection.push_back(obj);
-                          on_selection_change();
-                        }
-
-                      move_command = new ObjectMoveCommand(objmap);
-                      for (ObjMapSelectTool::Selection::iterator i = selection.begin();
-                           i != selection.end(); ++i)
-                        {
-                          move_command-&gt;add_obj(*i);
-                        }
-                    }
-                }
-              else
+                move_command = new ObjectMoveCommand(objmap);
+                for (ObjMapSelectTool::Selection::iterator i = selection.begin();
+                     i != selection.end(); ++i)
                 {
-                  state = SELECT;
-                  selection_rect = CL_Rectf(pos.x, pos.y, pos.x, pos.y);
-                  parent-&gt;capture_mouse();
+                  move_command-&gt;add_obj(*i);
                 }
+              }
             }
+            else
+            {
+              state = SELECT;
+              selection_rect = CL_Rectf(pos.x, pos.y, pos.x, pos.y);
+              parent-&gt;capture_mouse();
+            }
+          }
           break;
-        }
+      }
       break;
 
     case CL_MOUSE_RIGHT:
       break;
-    }
+  }
 }
 
 void
@@ -268,25 +268,25 @@
   CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
 
   switch(state)
-    {
+  {
     case DRAG:
       if (!control_point.is_null())
-        {
-          control_point.set_pos(pos - offset);
-        }
+      {
+        control_point.set_pos(pos - offset);
+      }
       else
-        {
-          move_command-&gt;move_by(pos - drag_start);
-          if (selection.size() == 1)
-            selection.front().update_control_points();
-        }
+      {
+        move_command-&gt;move_by(pos - drag_start);
+        if (selection.size() == 1)
+          selection.front().update_control_points();
+      }
       /*
-      for (ObjMapSelectTool::Selection::iterator i = selection.begin(); 
-           i != selection.end(); ++i)
+        for (ObjMapSelectTool::Selection::iterator i = selection.begin(); 
+        i != selection.end(); ++i)
         {
-          (*i).set_pos((*i).get_pos() + (pos - drag_start));
-          // FIXME: Move this into ObjMapObject
-          (*i).sig_move()(*i);
+        (*i).set_pos((*i).get_pos() + (pos - drag_start));
+        // FIXME: Move this into ObjMapObject
+        (*i).sig_move()(*i);
         }*/
       //drag_start = pos;
       break;
@@ -299,7 +299,7 @@
     default:
       // FIXME: Add some kind of highlighting here if mouse is over an object
       break;
-    }
+  }
 }
 
 Tool
@@ -315,9 +315,9 @@
   objmap.delete_control_points();
 
   if (selection.size() == 1)
-    {
-      selection.front().add_control_points();
-    } 
+  {
+    selection.front().add_control_points();
+  } 
 }
 
 /* EOF */

Modified: trunk/flexlay/lib/tools/sketch_stroke_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/sketch_stroke_tool.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tools/sketch_stroke_tool.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -51,52 +51,52 @@
   void draw() 
   {
     if (drawing)
-      {
-        // FIXME: This translation is a bit ugly, layer position should be handled somewhat different
-        CL_Display::push_modelview();
-        CL_Display::add_translate(BitmapLayer::current()-&gt;to_object().get_pos().x,
-                                  BitmapLayer::current()-&gt;to_object().get_pos().y);
-        stroke.draw(0);
-        CL_Display::pop_modelview();
-      }
+    {
+      // FIXME: This translation is a bit ugly, layer position should be handled somewhat different
+      CL_Display::push_modelview();
+      CL_Display::add_translate(BitmapLayer::current()-&gt;to_object().get_pos().x,
+                                BitmapLayer::current()-&gt;to_object().get_pos().y);
+      stroke.draw(0);
+      CL_Display::pop_modelview();
+    }
     else
-      {
-        EditorMapComponent* parent = EditorMapComponent::current();
-        CL_Pointf p = parent-&gt;screen2world(CL_Point(CL_Mouse::get_x() - parent-&gt;get_screen_x(), 
-                                                    CL_Mouse::get_y() - parent-&gt;get_screen_y()));
-        CL_Sprite s = DrawerProperties::current()-&gt;get_brush().get_sprite();
-        s.set_color(DrawerProperties::current()-&gt;get_color());
-        // FIXME: when using mouse 1.0, when tablet .5f
-        s.set_scale(DrawerProperties::current()-&gt;get_size()*0.5f, DrawerProperties::current()-&gt;get_size()*0.5f);
-        s.set_alpha(0.5);
-        s.draw(p.x, p.y);
-      }
+    {
+      EditorMapComponent* parent = EditorMapComponent::current();
+      CL_Pointf p = parent-&gt;screen2world(CL_Point(CL_Mouse::get_x() - parent-&gt;get_screen_x(), 
+                                                  CL_Mouse::get_y() - parent-&gt;get_screen_y()));
+      CL_Sprite s = DrawerProperties::current()-&gt;get_brush().get_sprite();
+      s.set_color(DrawerProperties::current()-&gt;get_color());
+      // FIXME: when using mouse 1.0, when tablet .5f
+      s.set_scale(DrawerProperties::current()-&gt;get_size()*0.5f, DrawerProperties::current()-&gt;get_size()*0.5f);
+      s.set_alpha(0.5);
+      s.draw(p.x, p.y);
+    }
   }
 
   void on_mouse_up  (const CL_InputEvent&amp; event) 
   {
     if (event.id == CL_MOUSE_LEFT &amp;&amp; drawing)
-      {
-        drawing = false;
-        EditorMapComponent* parent = EditorMapComponent::current();
-        parent-&gt;release_mouse();
+    {
+      drawing = false;
+      EditorMapComponent* parent = EditorMapComponent::current();
+      parent-&gt;release_mouse();
         
-        add_dab(event);
+      add_dab(event);
 
-        BitmapLayer::current()-&gt;add_stroke(stroke);
-      }    
+      BitmapLayer::current()-&gt;add_stroke(stroke);
+    }    
   }
 
   void on_mouse_down(const CL_InputEvent&amp; event) {
     if (event.id == CL_MOUSE_LEFT)
-      {
-        drawing = true;
-        EditorMapComponent* parent = EditorMapComponent::current();
-        parent-&gt;capture_mouse();
-        stroke = Stroke();
-        stroke.set_drawer(drawer.clone());
-        add_dab(event);
-      }
+    {
+      drawing = true;
+      EditorMapComponent* parent = EditorMapComponent::current();
+      parent-&gt;capture_mouse();
+      stroke = Stroke();
+      stroke.set_drawer(drawer.clone());
+      add_dab(event);
+    }
   }
 
   void add_dab(const CL_InputEvent&amp; event)
@@ -110,23 +110,23 @@
 
     // FIXME: Make tablet configurable
     if (CL_Display::get_current_window()-&gt;get_ic()-&gt;get_mouse_count() &gt;= 4)
+    {
+      CL_InputDevice tablet = CL_Display::get_current_window()-&gt;get_ic()-&gt;get_mouse(5);
+
+      if (0)
       {
-        CL_InputDevice tablet = CL_Display::get_current_window()-&gt;get_ic()-&gt;get_mouse(5);
+        std::cout &lt;&lt; &quot;Mouse Count: &quot; &lt;&lt; CL_Display::get_current_window()-&gt;get_ic()-&gt;get_mouse_count() &lt;&lt; std::endl;
+        std::cout &lt;&lt; tablet.get_name() &lt;&lt; &quot;: &quot;;
+        for(int i = 0; i &lt; tablet.get_axis_count(); ++i)
+          std::cout &lt;&lt; tablet.get_axis(i) &lt;&lt; &quot; &quot;;
+        std::cout &lt;&lt; std::endl;
+      }
 
-        if (0)
-          {
-            std::cout &lt;&lt; &quot;Mouse Count: &quot; &lt;&lt; CL_Display::get_current_window()-&gt;get_ic()-&gt;get_mouse_count() &lt;&lt; std::endl;
-            std::cout &lt;&lt; tablet.get_name() &lt;&lt; &quot;: &quot;;
-            for(int i = 0; i &lt; tablet.get_axis_count(); ++i)
-              std::cout &lt;&lt; tablet.get_axis(i) &lt;&lt; &quot; &quot;;
-            std::cout &lt;&lt; std::endl;
-          }
+      dab.pressure = tablet.get_axis(2);
+      dab.tilt.x   = tablet.get_axis(3);
+      dab.tilt.y   = tablet.get_axis(4);
+    }
 
-        dab.pressure = tablet.get_axis(2);
-        dab.tilt.x   = tablet.get_axis(3);
-        dab.tilt.y   = tablet.get_axis(4);
-      }
-
     //std::cout &lt;&lt; dab.pressure &lt;&lt; &quot; &quot; &lt;&lt; dab.tilt.x &lt;&lt; &quot; &quot; &lt;&lt; dab.tilt.y &lt;&lt; std::endl;
 
     if (dab.pressure == 0) // most likly we are using the mouse
@@ -138,9 +138,9 @@
   void on_mouse_move(const CL_InputEvent&amp; event) 
   {
     if (drawing)
-      {
-        add_dab(event);
-      }
+    {
+      add_dab(event);
+    }
   }
 };
 

Modified: trunk/flexlay/lib/tools/tilemap_paint_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/tilemap_paint_tool.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tools/tilemap_paint_tool.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -85,7 +85,7 @@
     return;
 
   switch(mode)
-    {
+  {
     case TileMapPaintToolImpl::SELECTING:
       if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT))
         selection.draw(CL_Color(255,  128, 128, 100));
@@ -99,38 +99,38 @@
       // Draw the brush:
       for(int y = 0; y &lt; brush.get_height(); ++y)
         for(int x = 0; x &lt; brush.get_width(); ++x)
+        {
+          Tile* tile = tilemap.get_tileset().create(brush.at(x, y));
+                
+          if (tile)
           {
-            Tile* tile = tilemap.get_tileset().create(brush.at(x, y));
-                
-            if (tile)
-              {
-                CL_Sprite sprite = tile-&gt;get_sprite();
-                sprite.set_alpha(0.5f);
-                sprite.draw((current_tile.x + x) * tile_size, 
-                            (current_tile.y + y) * tile_size);
+            CL_Sprite sprite = tile-&gt;get_sprite();
+            sprite.set_alpha(0.5f);
+            sprite.draw((current_tile.x + x) * tile_size, 
+                        (current_tile.y + y) * tile_size);
 
-                CL_Display::fill_rect(CL_Rect(CL_Point((current_tile.x + x) * tile_size, 
-                                                       (current_tile.y + y) * tile_size),
-                                              CL_Size(tile_size, tile_size)),
-                                      CL_Color(255, 255, 255, 100));
-              }
-            else if (brush.is_opaque())
-              {
-                CL_Display::fill_rect(CL_Rect(CL_Point((current_tile.x + x) * tile_size, 
-                                                       (current_tile.y + y) * tile_size),
-                                              CL_Size(tile_size, tile_size)),
-                                      CL_Color(255, 255, 255, 100));
-              }
-            else
-              {
-                CL_Display::fill_rect(CL_Rect(CL_Point((current_tile.x + x) * tile_size, 
-                                                       (current_tile.y + y) * tile_size),
-                                              CL_Size(tile_size, tile_size)),
-                                      CL_Color(255, 255, 255, 50));
-              }
+            CL_Display::fill_rect(CL_Rect(CL_Point((current_tile.x + x) * tile_size, 
+                                                   (current_tile.y + y) * tile_size),
+                                          CL_Size(tile_size, tile_size)),
+                                  CL_Color(255, 255, 255, 100));
           }
+          else if (brush.is_opaque())
+          {
+            CL_Display::fill_rect(CL_Rect(CL_Point((current_tile.x + x) * tile_size, 
+                                                   (current_tile.y + y) * tile_size),
+                                          CL_Size(tile_size, tile_size)),
+                                  CL_Color(255, 255, 255, 100));
+          }
+          else
+          {
+            CL_Display::fill_rect(CL_Rect(CL_Point((current_tile.x + x) * tile_size, 
+                                                   (current_tile.y + y) * tile_size),
+                                          CL_Size(tile_size, tile_size)),
+                                  CL_Color(255, 255, 255, 50));
+          }
+        }
       break;
-    }
+  }
 }
 
 const TileBrush&amp; 
@@ -145,36 +145,36 @@
   TilemapLayer tilemap = TilemapLayer::current();
 
   if (!tilemap.is_null())
+  {
+    EditorMapComponent* parent = EditorMapComponent::current();
+    CL_Point pos = tilemap.world2tile(parent-&gt;screen2world(event.mouse_pos));
+
+    switch (mode)
     {
-      EditorMapComponent* parent = EditorMapComponent::current();
-      CL_Point pos = tilemap.world2tile(parent-&gt;screen2world(event.mouse_pos));
-
-      switch (mode)
+      case TileMapPaintToolImpl::NONE:
+        switch (event.id)
         {
-        case TileMapPaintToolImpl::NONE:
-          switch (event.id)
-            {
-            case CL_MOUSE_LEFT:
-              mode = TileMapPaintToolImpl::PAINTING;
-              parent-&gt;capture_mouse();
-              command = new PaintCommand(tilemap, brush);
-              command-&gt;add_point(pos);
-              last_draw = pos;
-              break;
+          case CL_MOUSE_LEFT:
+            mode = TileMapPaintToolImpl::PAINTING;
+            parent-&gt;capture_mouse();
+            command = new PaintCommand(tilemap, brush);
+            command-&gt;add_point(pos);
+            last_draw = pos;
+            break;
     
-            case CL_MOUSE_RIGHT:
-              mode = TileMapPaintToolImpl::SELECTING;
-              parent-&gt;capture_mouse();
+          case CL_MOUSE_RIGHT:
+            mode = TileMapPaintToolImpl::SELECTING;
+            parent-&gt;capture_mouse();
 
-              selection.start(tilemap, pos);
-              break;
-            }
-          break;
+            selection.start(tilemap, pos);
+            break;
+        }
+        break;
 
-        default:
-          break;
-        }
+      default:
+        break;
     }
+  }
 }
  
 void
@@ -183,30 +183,30 @@
   TilemapLayer tilemap = TilemapLayer::current();
 
   if (!tilemap.is_null())
+  {
+    EditorMapComponent* parent = EditorMapComponent::current();
+    current_tile = tilemap.world2tile(parent-&gt;screen2world(event.mouse_pos));
+
+    switch (mode)
     {
-      EditorMapComponent* parent = EditorMapComponent::current();
-      current_tile = tilemap.world2tile(parent-&gt;screen2world(event.mouse_pos));
-
-      switch (mode)
+      case PAINTING:
+        if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT) ||
+            (current_tile.x % brush.get_width())  == (last_draw.x % brush.get_width()) &amp;&amp;
+            (current_tile.y % brush.get_height() == (last_draw.y % brush.get_height())))
         {
-        case PAINTING:
-          if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT) ||
-              (current_tile.x % brush.get_width())  == (last_draw.x % brush.get_width()) &amp;&amp;
-              (current_tile.y % brush.get_height() == (last_draw.y % brush.get_height())))
-            {
-              command-&gt;add_point(current_tile);
-              last_draw = current_tile;
-            }
-          break;
+          command-&gt;add_point(current_tile);
+          last_draw = current_tile;
+        }
+        break;
     
-        case SELECTING:
-          selection.update(current_tile);
-          break;
+      case SELECTING:
+        selection.update(current_tile);
+        break;
       
-        default:
-          break;
-        }
+      default:
+        break;
     }
+  }
 }
 
 void
@@ -215,60 +215,60 @@
   TilemapLayer tilemap = TilemapLayer::current();
 
   if (!tilemap.is_null())
-    {
-      EditorMapComponent::current()-&gt;get_workspace().get_map().modify();
+  {
+    EditorMapComponent::current()-&gt;get_workspace().get_map().modify();
 
-      EditorMapComponent* parent = EditorMapComponent::current();
-      current_tile = tilemap.world2tile(parent-&gt;screen2world(event.mouse_pos));
+    EditorMapComponent* parent = EditorMapComponent::current();
+    current_tile = tilemap.world2tile(parent-&gt;screen2world(event.mouse_pos));
 
-      switch (event.id)
+    switch (event.id)
+    {
+      case CL_MOUSE_LEFT:
+        if (mode == PAINTING)
         {
-        case CL_MOUSE_LEFT:
-          if (mode == PAINTING)
-            {
-              parent-&gt;release_mouse();
-              mode = NONE;
+          parent-&gt;release_mouse();
+          mode = NONE;
 
-              if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT) ||
-                  (current_tile.x % brush.get_width()) == (last_draw.x % brush.get_width()) &amp;&amp;
-                  (current_tile.y % brush.get_height() == (last_draw.y % brush.get_height())))
-                {
-                  command-&gt;add_point(current_tile);
-                }
+          if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT) ||
+              (current_tile.x % brush.get_width()) == (last_draw.x % brush.get_width()) &amp;&amp;
+              (current_tile.y % brush.get_height() == (last_draw.y % brush.get_height())))
+          {
+            command-&gt;add_point(current_tile);
+          }
 
-              Workspace::current().get_map().execute(command-&gt;to_command());
-              command = 0;
+          Workspace::current().get_map().execute(command-&gt;to_command());
+          command = 0;
 
-              tilemap.draw_tile(brush, current_tile);
-              last_draw = CL_Point(-1, -1);
-            }
-          break;
+          tilemap.draw_tile(brush, current_tile);
+          last_draw = CL_Point(-1, -1);
+        }
+        break;
     
-        case CL_MOUSE_RIGHT:
-          if (mode == SELECTING)
-            {
-              parent-&gt;release_mouse();
-              mode = NONE;
+      case CL_MOUSE_RIGHT:
+        if (mode == SELECTING)
+        {
+          parent-&gt;release_mouse();
+          mode = NONE;
 
-              selection.update(current_tile);
-              brush = selection.get_brush(*tilemap.get_field());
+          selection.update(current_tile);
+          brush = selection.get_brush(*tilemap.get_field());
 
-              if ((brush.get_width() &gt; 1 || brush.get_height() &gt; 1)
-                  &amp;&amp; !CL_Keyboard::get_keycode(CL_KEY_LSHIFT))
-                {
-                  brush.set_transparent();
-                  brush.auto_crop();
-                }
-              else
-                {
-                  brush.set_opaque();
-                }
+          if ((brush.get_width() &gt; 1 || brush.get_height() &gt; 1)
+              &amp;&amp; !CL_Keyboard::get_keycode(CL_KEY_LSHIFT))
+          {
+            brush.set_transparent();
+            brush.auto_crop();
+          }
+          else
+          {
+            brush.set_opaque();
+          }
 
-              selection.clear();
-            }
-          break;
+          selection.clear();
         }
+        break;
     }
+  }
 }
 
 void

Modified: trunk/flexlay/lib/tools/tilemap_select_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/tilemap_select_tool.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tools/tilemap_select_tool.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -54,9 +54,9 @@
 TileMapSelectToolImpl::draw()
 {
   if (selection.is_active())
-    {
-      selection.draw();
-    }
+  {
+    selection.draw();
+  }
 }
 
 void
@@ -65,14 +65,14 @@
   EditorMapComponent* parent = EditorMapComponent::current();
 
   switch (event.id)
-    {
+  {
     case CL_MOUSE_LEFT:
       creating_selection = false;
       parent-&gt;release_mouse();
 
       selection.update(TilemapLayer::current().world2tile(parent-&gt;screen2world(event.mouse_pos)));
       break;
-    }
+  }
 }
 
 void
@@ -81,21 +81,21 @@
   EditorMapComponent* parent = EditorMapComponent::current();
 
   switch (event.id)
+  {
+    case CL_MOUSE_LEFT:
     {
-    case CL_MOUSE_LEFT:
-      {
-        creating_selection = true;
-        parent-&gt;capture_mouse();
-        TilemapLayer tilemap = TilemapLayer::current();
-        selection.start(tilemap, tilemap.world2tile(parent-&gt;screen2world(event.mouse_pos)));
-      }
-      break;
+      creating_selection = true;
+      parent-&gt;capture_mouse();
+      TilemapLayer tilemap = TilemapLayer::current();
+      selection.start(tilemap, tilemap.world2tile(parent-&gt;screen2world(event.mouse_pos)));
+    }
+    break;
       
     case CL_MOUSE_RIGHT:
       if (!creating_selection)
         selection.clear();
       break;
-    }
+  }
 }
 
 void
@@ -104,9 +104,9 @@
   EditorMapComponent* parent = EditorMapComponent::current();
 
   if (creating_selection)
-    {
-      selection.update(TilemapLayer::current().world2tile(parent-&gt;screen2world(event.mouse_pos)));
-    }
+  {
+    selection.update(TilemapLayer::current().world2tile(parent-&gt;screen2world(event.mouse_pos)));
+  }
 }
 
 TileBrush

Modified: trunk/flexlay/lib/tools/workspace_move_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/workspace_move_tool.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tools/workspace_move_tool.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -61,9 +61,9 @@
 WorkspaceMoveToolImpl::on_mouse_move(const CL_InputEvent&amp; event)
 {
   if (scrolling)
-    {
-      update(event);
-    } 
+  {
+    update(event);
+  } 
 }
 
 void

Modified: trunk/flexlay/lib/tools/zoom2_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/zoom2_tool.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tools/zoom2_tool.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -69,20 +69,20 @@
 Zoom2ToolImpl::on_mouse_move(const CL_InputEvent&amp; event)
 {
   if (active)
-    {
-      GraphicContextState&amp; gc = EditorMapComponent::current()-&gt;get_gc_state();
+  {
+    GraphicContextState&amp; gc = EditorMapComponent::current()-&gt;get_gc_state();
 
-      CL_Point zoom_pos(gc.get_width()/2,
-                        gc.get_height()/2);
+    CL_Point zoom_pos(gc.get_width()/2,
+                      gc.get_height()/2);
       
-      float factor = (event.mouse_pos.y - click_pos.y) / 20.0f;
-      if (factor &gt; 0)
-        gc.set_zoom(zoom_pos, old_zoom * pow(1.25f, factor));
-      else if (factor &lt; 0)
-        gc.set_zoom(zoom_pos, old_zoom / pow(1.25f, -factor));
-      else
-        gc.set_zoom(zoom_pos, old_zoom);
-    }
+    float factor = (event.mouse_pos.y - click_pos.y) / 20.0f;
+    if (factor &gt; 0)
+      gc.set_zoom(zoom_pos, old_zoom * pow(1.25f, factor));
+    else if (factor &lt; 0)
+      gc.set_zoom(zoom_pos, old_zoom / pow(1.25f, -factor));
+    else
+      gc.set_zoom(zoom_pos, old_zoom);
+  }
 }
 
 Tool

Modified: trunk/flexlay/lib/tools/zoom_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/zoom_tool.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tools/zoom_tool.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -49,17 +49,17 @@
 ZoomToolImpl::draw()
 {
   switch (state)
+  {
+    case CREATE_ZOOM_RECT:
     {
-    case CREATE_ZOOM_RECT:
-      {
-        CL_Rectf tmp(zoom_rect);
-        tmp.normalize();
-        CL_Display::fill_rect(tmp, CL_Color(255, 255, 0, 50));
-        CL_Display::draw_rect(tmp, CL_Color(255, 255, 0, 200));
-      }
+      CL_Rectf tmp(zoom_rect);
+      tmp.normalize();
+      CL_Display::fill_rect(tmp, CL_Color(255, 255, 0, 50));
+      CL_Display::draw_rect(tmp, CL_Color(255, 255, 0, 200));
+    }
     case NONE:
       break;
-    }
+  }
 }
 
 void
@@ -68,25 +68,25 @@
   EditorMapComponent* parent = EditorMapComponent::current();
 
   if (event.id != CL_MOUSE_RIGHT)
+  {
+    switch (state)
     {
-      switch (state)
+      case CREATE_ZOOM_RECT:
+      {
+        state = NONE;
+        parent-&gt;release_mouse();
+
+        CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
+        zoom_rect.right  = pos.x;
+        zoom_rect.bottom = pos.y;
+        zoom_rect.normalize();
+        if (zoom_rect.get_width() &gt; 10 &amp;&amp; zoom_rect.get_height() &gt; 10)
         {
-        case CREATE_ZOOM_RECT:
-          {
-            state = NONE;
-            parent-&gt;release_mouse();
-
-            CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
-            zoom_rect.right  = pos.x;
-            zoom_rect.bottom = pos.y;
-            zoom_rect.normalize();
-            if (zoom_rect.get_width() &gt; 10 &amp;&amp; zoom_rect.get_height() &gt; 10)
-              {
-                parent-&gt;zoom_to(zoom_rect);
-              }
-          }
+          parent-&gt;zoom_to(zoom_rect);
         }
+      }
     }
+  }
 }
 
 void
@@ -95,39 +95,39 @@
   EditorMapComponent* parent = EditorMapComponent::current();
 
   switch(event.id)
-    {
+  {
     case CL_MOUSE_RIGHT:
       switch (state)
-        {
+      {
         case NONE:
           parent-&gt;zoom_out(event.mouse_pos);
           parent-&gt;zoom_out(event.mouse_pos);
           break;
         default:
           break;
-        }
+      }
       break;
 
     default:
       switch (state)
+      {
+        case NONE:
         {
-        case NONE:
-          {
-            state = CREATE_ZOOM_RECT;
-            parent-&gt;capture_mouse();
+          state = CREATE_ZOOM_RECT;
+          parent-&gt;capture_mouse();
 
-            CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
-            zoom_rect.left   = pos.x;
-            zoom_rect.top    = pos.y;
-            zoom_rect.right  = pos.x;
-            zoom_rect.bottom = pos.y;
-          }
-          break;
+          CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
+          zoom_rect.left   = pos.x;
+          zoom_rect.top    = pos.y;
+          zoom_rect.right  = pos.x;
+          zoom_rect.bottom = pos.y;
+        }
+        break;
         default:
           break;
-        }
+      }
       break;
-    }
+  }
 }
 
 void
@@ -136,17 +136,17 @@
   EditorMapComponent* parent = EditorMapComponent::current();
 
   switch (state)
+  {
+    case CREATE_ZOOM_RECT:
     {
-    case CREATE_ZOOM_RECT:
-      {
-        CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
-        zoom_rect.right  = pos.x;
-        zoom_rect.bottom = pos.y;  
-      }
-      break;
+      CL_Pointf pos = parent-&gt;screen2world(event.mouse_pos);
+      zoom_rect.right  = pos.x;
+      zoom_rect.bottom = pos.y;  
+    }
+    break;
     default:
       break;
-    }
+  }
 }
 
 Tool

Modified: trunk/flexlay/lib/window.cpp
===================================================================
--- trunk/flexlay/lib/window.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/window.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -59,8 +59,8 @@
   //Fonts::verdana11.draw(8+15, 3, title);
 
   impl-&gt;close = new Icon(CL_Rect(CL_Point(3, 3), CL_Size(18,18)), 
-                        make_sprite(&quot;../data/images/window/close.png&quot;),
-                        &quot;&quot;, this);
+                         make_sprite(&quot;../data/images/window/close.png&quot;),
+                         &quot;&quot;, this);
   impl-&gt;minimize = new Icon(CL_Rect(CL_Point(get_width()-3-18-18, 3), CL_Size(18,18)), 
                             make_sprite(&quot;../data/images/window/minimize.png&quot;),
                             &quot;&quot;, this);
@@ -95,8 +95,8 @@
   maximize-&gt;set_position(parent-&gt;get_width()-3-18, 3);
   CL_Rect rect = parent-&gt;get_position();
   client_area-&gt;set_position(CL_Rect(CL_Point(4, 3+12+7), 
-                                   CL_Size(rect.get_width()-10,
-                                           rect.get_height()-28)));
+                                    CL_Size(rect.get_width()-10,
+                                            rect.get_height()-28)));
 }
 
 void
@@ -141,16 +141,16 @@
 {
   // FIXME: Move this to scripting language
   if (!is_maximized)
-    {
-      is_maximized = true;
-      old_position = parent-&gt;get_position();
-      parent-&gt;set_position(parent-&gt;get_parent()-&gt;get_position());
-    }
+  {
+    is_maximized = true;
+    old_position = parent-&gt;get_position();
+    parent-&gt;set_position(parent-&gt;get_parent()-&gt;get_position());
+  }
   else
-    {
-      is_maximized = false;
-      parent-&gt;set_position(old_position);
-    }
+  {
+    is_maximized = false;
+    parent-&gt;set_position(old_position);
+  }
 }
 
 CL_Component*

Modified: trunk/flexlay/lib/workspace.cpp
===================================================================
--- trunk/flexlay/lib/workspace.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/workspace.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -41,11 +41,11 @@
   : impl(0)
 {
   if (create)
-    {
-      impl = new WorkspaceImpl();
-      current_ = *this;
-      std::cout &lt;&lt; &quot;Workspace()&quot; &lt;&lt; std::endl;
-    }
+  {
+    impl = new WorkspaceImpl();
+    current_ = *this;
+    std::cout &lt;&lt; &quot;Workspace()&quot; &lt;&lt; std::endl;
+  }
 }
 
 void
@@ -83,9 +83,9 @@
 
   for(WorkspaceImpl::Tools::iterator it = impl-&gt;tools.begin();
       it != impl-&gt;tools.end(); ++it)
-    {
-      it-&gt;second.on_mouse_move(event);
-    }
+  {
+    it-&gt;second.on_mouse_move(event);
+  }
 }
 
 void
@@ -98,7 +98,7 @@
     it-&gt;second.on_mouse_down(event);
 
   switch (event.id)
-    {
+  {
     case CL_MOUSE_WHEEL_UP:
       EditorMapComponent::current()-&gt;zoom_in(event.mouse_pos);
       break;
@@ -106,7 +106,7 @@
     case CL_MOUSE_WHEEL_DOWN:
       EditorMapComponent::current()-&gt;zoom_out(event.mouse_pos);
       break;
-    }
+  }
 }
 
 void


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000206.html">[Flexlay-commit] r714 - in trunk/flexlay/lib: . tools
</A></li>
	<LI>Next message: <A HREF="000208.html">[Flexlay-commit] r716 - in trunk/flexlay: . external	external/clanlib/GL external/clanlib/GL/GLX lib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#207">[ date ]</a>
              <a href="thread.html#207">[ thread ]</a>
              <a href="subject.html#207">[ subject ]</a>
              <a href="author.html#207">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/flexlay-commit">More information about the Flexlay-commit
mailing list</a><br>
</body></html>
