From grumbel at mail.berlios.de  Sun Nov 22 04:06:29 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 22 Nov 2009 04:06:29 +0100
Subject: [Flexlay-commit] r714 - in trunk/flexlay/lib: . tools
Message-ID: <200911220306.nAM36T6B021286@sheep.berlios.de>

Author: grumbel
Date: 2009-11-22 04:06:27 +0100 (Sun, 22 Nov 2009)
New Revision: 714

Modified:
   trunk/flexlay/lib/bitmap_layer.cpp
   trunk/flexlay/lib/blitter.cpp
   trunk/flexlay/lib/box.cpp
   trunk/flexlay/lib/brush.cpp
   trunk/flexlay/lib/command.cpp
   trunk/flexlay/lib/command_group.cpp
   trunk/flexlay/lib/console.cpp
   trunk/flexlay/lib/directory_view.cpp
   trunk/flexlay/lib/drawer_properties.cpp
   trunk/flexlay/lib/editor_map.cpp
   trunk/flexlay/lib/editor_map_component.cpp
   trunk/flexlay/lib/flexlay.cpp
   trunk/flexlay/lib/fonts.cpp
   trunk/flexlay/lib/generated_brush.cpp
   trunk/flexlay/lib/globals.cpp
   trunk/flexlay/lib/graphic_context_state.cpp
   trunk/flexlay/lib/gui_manager.cpp
   trunk/flexlay/lib/helper.cpp
   trunk/flexlay/lib/icon.cpp
   trunk/flexlay/lib/layer.cpp
   trunk/flexlay/lib/marker_stroke_drawer.cpp
   trunk/flexlay/lib/menu.cpp
   trunk/flexlay/lib/menubar.cpp
   trunk/flexlay/lib/meta_data.cpp
   trunk/flexlay/lib/minimap.cpp
   trunk/flexlay/lib/object_add_command.cpp
   trunk/flexlay/lib/object_brush.cpp
   trunk/flexlay/lib/object_delete_command.cpp
   trunk/flexlay/lib/object_layer.cpp
   trunk/flexlay/lib/object_move_command.cpp
   trunk/flexlay/lib/object_selector.cpp
   trunk/flexlay/lib/object_transform_command.cpp
   trunk/flexlay/lib/objmap_object.cpp
   trunk/flexlay/lib/objmap_object_impl.cpp
   trunk/flexlay/lib/objmap_path_node.cpp
   trunk/flexlay/lib/objmap_sprite_object.cpp
   trunk/flexlay/lib/paint_command.cpp
   trunk/flexlay/lib/paned.cpp
   trunk/flexlay/lib/panel.cpp
   trunk/flexlay/lib/popup_menu.cpp
   trunk/flexlay/lib/scrollbar.cpp
   trunk/flexlay/lib/serializer.cpp
   trunk/flexlay/lib/sexpr_serializer.cpp
   trunk/flexlay/lib/sharedptrtest.cpp
   trunk/flexlay/lib/simpleed.cpp
   trunk/flexlay/lib/sketch_layer.cpp
   trunk/flexlay/lib/slider.cpp
   trunk/flexlay/lib/sprite_stroke_drawer.cpp
   trunk/flexlay/lib/stroke.cpp
   trunk/flexlay/lib/stroke_drawer.cpp
   trunk/flexlay/lib/tile.cpp
   trunk/flexlay/lib/tile_brush.cpp
   trunk/flexlay/lib/tile_editor.cpp
   trunk/flexlay/lib/tile_provider.cpp
   trunk/flexlay/lib/tile_selection.cpp
   trunk/flexlay/lib/tile_selector.cpp
   trunk/flexlay/lib/tilemap_layer.cpp
   trunk/flexlay/lib/tileset.cpp
   trunk/flexlay/lib/titlebar.cpp
   trunk/flexlay/lib/tools/objmap_select_tool.cpp
   trunk/flexlay/lib/tools/sketch_stroke_tool.cpp
   trunk/flexlay/lib/tools/tilemap_paint_tool.cpp
   trunk/flexlay/lib/tools/tilemap_select_tool.cpp
   trunk/flexlay/lib/tools/tool.cpp
   trunk/flexlay/lib/tools/workspace_move_tool.cpp
   trunk/flexlay/lib/tools/zoom2_tool.cpp
   trunk/flexlay/lib/tools/zoom_tool.cpp
   trunk/flexlay/lib/viewport.cpp
   trunk/flexlay/lib/window.cpp
   trunk/flexlay/lib/workspace.cpp
Log:
Removed $Id$ keywords

Modified: trunk/flexlay/lib/bitmap_layer.cpp
===================================================================
--- trunk/flexlay/lib/bitmap_layer.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/bitmap_layer.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/blitter.cpp
===================================================================
--- trunk/flexlay/lib/blitter.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/blitter.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/box.cpp
===================================================================
--- trunk/flexlay/lib/box.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/box.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/brush.cpp
===================================================================
--- trunk/flexlay/lib/brush.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/brush.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/command.cpp
===================================================================
--- trunk/flexlay/lib/command.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/command.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/command_group.cpp
===================================================================
--- trunk/flexlay/lib/command_group.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/command_group.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/console.cpp
===================================================================
--- trunk/flexlay/lib/console.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/console.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/directory_view.cpp
===================================================================
--- trunk/flexlay/lib/directory_view.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/directory_view.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/drawer_properties.cpp
===================================================================
--- trunk/flexlay/lib/drawer_properties.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/drawer_properties.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/editor_map.cpp
===================================================================
--- trunk/flexlay/lib/editor_map.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/editor_map.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/editor_map_component.cpp
===================================================================
--- trunk/flexlay/lib/editor_map_component.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/editor_map_component.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/flexlay.cpp
===================================================================
--- trunk/flexlay/lib/flexlay.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/flexlay.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/fonts.cpp
===================================================================
--- trunk/flexlay/lib/fonts.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/fonts.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/generated_brush.cpp
===================================================================
--- trunk/flexlay/lib/generated_brush.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/generated_brush.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/globals.cpp
===================================================================
--- trunk/flexlay/lib/globals.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/globals.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id: globals.cxx,v 1.6 2003/11/07 22:41:18 grumbel Exp $
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/graphic_context_state.cpp
===================================================================
--- trunk/flexlay/lib/graphic_context_state.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/graphic_context_state.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/gui_manager.cpp
===================================================================
--- trunk/flexlay/lib/gui_manager.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/gui_manager.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id: gui_manager.cxx,v 1.3 2003/11/05 12:41:37 grumbel Exp $
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/helper.cpp
===================================================================
--- trunk/flexlay/lib/helper.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/helper.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/icon.cpp
===================================================================
--- trunk/flexlay/lib/icon.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/icon.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/layer.cpp
===================================================================
--- trunk/flexlay/lib/layer.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/layer.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/marker_stroke_drawer.cpp
===================================================================
--- trunk/flexlay/lib/marker_stroke_drawer.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/marker_stroke_drawer.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/menu.cpp
===================================================================
--- trunk/flexlay/lib/menu.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/menu.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/menubar.cpp
===================================================================
--- trunk/flexlay/lib/menubar.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/menubar.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/meta_data.cpp
===================================================================
--- trunk/flexlay/lib/meta_data.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/meta_data.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/minimap.cpp
===================================================================
--- trunk/flexlay/lib/minimap.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/minimap.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/object_add_command.cpp
===================================================================
--- trunk/flexlay/lib/object_add_command.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/object_add_command.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/object_brush.cpp
===================================================================
--- trunk/flexlay/lib/object_brush.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/object_brush.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/object_delete_command.cpp
===================================================================
--- trunk/flexlay/lib/object_delete_command.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/object_delete_command.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/object_layer.cpp
===================================================================
--- trunk/flexlay/lib/object_layer.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/object_layer.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/object_move_command.cpp
===================================================================
--- trunk/flexlay/lib/object_move_command.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/object_move_command.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/object_selector.cpp
===================================================================
--- trunk/flexlay/lib/object_selector.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/object_selector.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/object_transform_command.cpp
===================================================================
--- trunk/flexlay/lib/object_transform_command.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/object_transform_command.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/objmap_object.cpp
===================================================================
--- trunk/flexlay/lib/objmap_object.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/objmap_object.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/objmap_object_impl.cpp
===================================================================
--- trunk/flexlay/lib/objmap_object_impl.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/objmap_object_impl.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/objmap_path_node.cpp
===================================================================
--- trunk/flexlay/lib/objmap_path_node.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/objmap_path_node.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/objmap_sprite_object.cpp
===================================================================
--- trunk/flexlay/lib/objmap_sprite_object.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/objmap_sprite_object.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/paint_command.cpp
===================================================================
--- trunk/flexlay/lib/paint_command.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/paint_command.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/paned.cpp
===================================================================
--- trunk/flexlay/lib/paned.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/paned.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/panel.cpp
===================================================================
--- trunk/flexlay/lib/panel.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/panel.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/popup_menu.cpp
===================================================================
--- trunk/flexlay/lib/popup_menu.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/popup_menu.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/scrollbar.cpp
===================================================================
--- trunk/flexlay/lib/scrollbar.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/scrollbar.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/serializer.cpp
===================================================================
--- trunk/flexlay/lib/serializer.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/serializer.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/sexpr_serializer.cpp
===================================================================
--- trunk/flexlay/lib/sexpr_serializer.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/sexpr_serializer.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/sharedptrtest.cpp
===================================================================
--- trunk/flexlay/lib/sharedptrtest.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/sharedptrtest.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/simpleed.cpp
===================================================================
--- trunk/flexlay/lib/simpleed.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/simpleed.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/sketch_layer.cpp
===================================================================
--- trunk/flexlay/lib/sketch_layer.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/sketch_layer.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/slider.cpp
===================================================================
--- trunk/flexlay/lib/slider.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/slider.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/sprite_stroke_drawer.cpp
===================================================================
--- trunk/flexlay/lib/sprite_stroke_drawer.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/sprite_stroke_drawer.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/stroke.cpp
===================================================================
--- trunk/flexlay/lib/stroke.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/stroke.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/stroke_drawer.cpp
===================================================================
--- trunk/flexlay/lib/stroke_drawer.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/stroke_drawer.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/tile.cpp
===================================================================
--- trunk/flexlay/lib/tile.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/tile.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id: tile.cxx,v 1.4 2003/09/22 18:37:05 grumbel Exp $
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/tile_brush.cpp
===================================================================
--- trunk/flexlay/lib/tile_brush.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/tile_brush.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/tile_editor.cpp
===================================================================
--- trunk/flexlay/lib/tile_editor.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/tile_editor.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id: tile_editor.cxx,v 1.1 2003/09/22 18:37:05 grumbel Exp $
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/tile_provider.cpp
===================================================================
--- trunk/flexlay/lib/tile_provider.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/tile_provider.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/tile_selection.cpp
===================================================================
--- trunk/flexlay/lib/tile_selection.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/tile_selection.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/tile_selector.cpp
===================================================================
--- trunk/flexlay/lib/tile_selector.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/tile_selector.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id: tile_selector.cxx,v 1.7 2003/09/23 19:10:05 grumbel Exp $
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/tilemap_layer.cpp
===================================================================
--- trunk/flexlay/lib/tilemap_layer.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/tilemap_layer.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/tileset.cpp
===================================================================
--- trunk/flexlay/lib/tileset.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/tileset.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id: tile_factory.cxx,v 1.10 2003/09/22 18:37:05 grumbel Exp $
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2000 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/titlebar.cpp
===================================================================
--- trunk/flexlay/lib/titlebar.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/titlebar.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/tools/objmap_select_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/objmap_select_tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/tools/objmap_select_tool.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id: tilemap_object_tool.cxx,v 1.1 2003/09/23 22:10:40 grumbel Exp $
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/tools/sketch_stroke_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/sketch_stroke_tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/tools/sketch_stroke_tool.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/tools/tilemap_paint_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/tilemap_paint_tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/tools/tilemap_paint_tool.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id: tilemap_paint_tool.cxx,v 1.2 2003/09/23 22:07:32 grumbel Exp $
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -193,7 +191,7 @@
         {
         case PAINTING:
           if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT) ||
-              (current_tile.x % brush.get_width()) == (last_draw.x % brush.get_width()) &&
+              (current_tile.x % brush.get_width())  == (last_draw.x % brush.get_width()) &&
               (current_tile.y % brush.get_height() == (last_draw.y % brush.get_height())))
             {
               command->add_point(current_tile);

Modified: trunk/flexlay/lib/tools/tilemap_select_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/tilemap_select_tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/tools/tilemap_select_tool.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id: tilemap_select_tool.cxx,v 1.1 2003/09/23 22:10:40 grumbel Exp $
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/tools/tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/tools/tool.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id: tilemap_tool.cxx,v 1.1 2003/09/23 19:10:05 grumbel Exp $
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/tools/workspace_move_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/workspace_move_tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/tools/workspace_move_tool.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/tools/zoom2_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/zoom2_tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/tools/zoom2_tool.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/tools/zoom_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/zoom_tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/tools/zoom_tool.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/viewport.cpp
===================================================================
--- trunk/flexlay/lib/viewport.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/viewport.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/window.cpp
===================================================================
--- trunk/flexlay/lib/window.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/window.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/workspace.cpp
===================================================================
--- trunk/flexlay/lib/workspace.cpp	2009-11-22 03:02:03 UTC (rev 713)
+++ trunk/flexlay/lib/workspace.cpp	2009-11-22 03:06:27 UTC (rev 714)
@@ -1,5 +1,3 @@
-//  $Id$
-//
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //



From grumbel at mail.berlios.de  Sun Nov 22 04:08:02 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 22 Nov 2009 04:08:02 +0100
Subject: [Flexlay-commit] r715 - in trunk/flexlay/lib: . tools
Message-ID: <200911220308.nAM382BL021385@sheep.berlios.de>

Author: grumbel
Date: 2009-11-22 04:07:59 +0100 (Sun, 22 Nov 2009)
New Revision: 715

Modified:
   trunk/flexlay/lib/bitmap_layer.cpp
   trunk/flexlay/lib/blitter.cpp
   trunk/flexlay/lib/brushmask.cpp
   trunk/flexlay/lib/colorpicker.cpp
   trunk/flexlay/lib/console.cpp
   trunk/flexlay/lib/directory_view.cpp
   trunk/flexlay/lib/editor_map.cpp
   trunk/flexlay/lib/editor_map_component.cpp
   trunk/flexlay/lib/field.hpp
   trunk/flexlay/lib/flexlay.cpp
   trunk/flexlay/lib/flexlay.hpp
   trunk/flexlay/lib/generated_brush.cpp
   trunk/flexlay/lib/graphic_context_state.cpp
   trunk/flexlay/lib/helper.cpp
   trunk/flexlay/lib/icon.cpp
   trunk/flexlay/lib/layer.cpp
   trunk/flexlay/lib/lispreader.cpp
   trunk/flexlay/lib/lispreader.hpp
   trunk/flexlay/lib/marker_stroke_drawer.cpp
   trunk/flexlay/lib/menu.cpp
   trunk/flexlay/lib/minimap.cpp
   trunk/flexlay/lib/object_add_command.cpp
   trunk/flexlay/lib/object_delete_command.cpp
   trunk/flexlay/lib/object_layer.cpp
   trunk/flexlay/lib/object_move_command.cpp
   trunk/flexlay/lib/object_selector.cpp
   trunk/flexlay/lib/objmap_object.cpp
   trunk/flexlay/lib/objmap_path_node.cpp
   trunk/flexlay/lib/objmap_rect_object.cpp
   trunk/flexlay/lib/objmap_sprite_object.cpp
   trunk/flexlay/lib/onion_skin_layer.cpp
   trunk/flexlay/lib/paint_command.cpp
   trunk/flexlay/lib/popup_menu.cpp
   trunk/flexlay/lib/scrollbar.cpp
   trunk/flexlay/lib/shared_ptr_comp.hpp
   trunk/flexlay/lib/sketch_layer.cpp
   trunk/flexlay/lib/slider.cpp
   trunk/flexlay/lib/sprite_stroke_drawer.cpp
   trunk/flexlay/lib/stroke.cpp
   trunk/flexlay/lib/tile.cpp
   trunk/flexlay/lib/tile_brush.cpp
   trunk/flexlay/lib/tile_editor.cpp
   trunk/flexlay/lib/tile_selection.cpp
   trunk/flexlay/lib/tile_selector.cpp
   trunk/flexlay/lib/tilemap_layer.cpp
   trunk/flexlay/lib/tilemap_layer.hpp
   trunk/flexlay/lib/tileset.cpp
   trunk/flexlay/lib/titlebar.cpp
   trunk/flexlay/lib/tools/layer_move_tool.cpp
   trunk/flexlay/lib/tools/objmap_select_tool.cpp
   trunk/flexlay/lib/tools/sketch_stroke_tool.cpp
   trunk/flexlay/lib/tools/tilemap_paint_tool.cpp
   trunk/flexlay/lib/tools/tilemap_select_tool.cpp
   trunk/flexlay/lib/tools/workspace_move_tool.cpp
   trunk/flexlay/lib/tools/zoom2_tool.cpp
   trunk/flexlay/lib/tools/zoom_tool.cpp
   trunk/flexlay/lib/window.cpp
   trunk/flexlay/lib/workspace.cpp
Log:
Switched indention style

Modified: trunk/flexlay/lib/bitmap_layer.cpp
===================================================================
--- trunk/flexlay/lib/bitmap_layer.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/bitmap_layer.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -145,13 +145,13 @@
 BitmapLayer::add_stroke(const Stroke& stroke)
 {
   if (stroke.get_dab_count() > 0)
-    {
-      impl->strokes.push_back(stroke);
-      stroke.draw(impl->canvas->get_gc());
-      // FIXME: doesn't sync when manually manipulating the canvas
-      impl->canvas->get_gc()->flush();
-      impl->canvas->sync_surface();
-    }
+  {
+    impl->strokes.push_back(stroke);
+    stroke.draw(impl->canvas->get_gc());
+    // FIXME: doesn't sync when manually manipulating the canvas
+    impl->canvas->get_gc()->flush();
+    impl->canvas->sync_surface();
+  }
 }
 
 std::vector<Stroke>

Modified: trunk/flexlay/lib/blitter.cpp
===================================================================
--- trunk/flexlay/lib/blitter.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/blitter.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -40,59 +40,59 @@
   int brush_pitch  = brush.get_pitch();
 
   if (brush.get_format().get_type() == pixelformat_rgba)
+  {
+    if (brush.get_format().get_depth() == 32)
     {
-      if (brush.get_format().get_depth() == 32)
+      for (int y = start_y; y < end_y; ++y)
+        for (int x = start_x; x < end_x; ++x)
         {
-          for (int y = start_y; y < end_y; ++y)
-            for (int x = start_x; x < end_x; ++x)
-              {
-                int target_pos = (y + y_pos) * target_pitch + 4*(x + x_pos);
-                int brush_pos  = y * brush_pitch + x*4;
+          int target_pos = (y + y_pos) * target_pitch + 4*(x + x_pos);
+          int brush_pos  = y * brush_pitch + x*4;
 
-                target_buf[target_pos + 0] = brush_buf[brush_pos + 0];
-                target_buf[target_pos + 1] = brush_buf[brush_pos + 1];
-                target_buf[target_pos + 2] = brush_buf[brush_pos + 2];
-                target_buf[target_pos + 3] = brush_buf[brush_pos + 3];
-              } 
-        }
-      else if (brush.get_format().get_depth() == 24)
+          target_buf[target_pos + 0] = brush_buf[brush_pos + 0];
+          target_buf[target_pos + 1] = brush_buf[brush_pos + 1];
+          target_buf[target_pos + 2] = brush_buf[brush_pos + 2];
+          target_buf[target_pos + 3] = brush_buf[brush_pos + 3];
+        } 
+    }
+    else if (brush.get_format().get_depth() == 24)
+    {
+      for (int y = start_y; y < end_y; ++y)
+        for (int x = start_x; x < end_x; ++x)
         {
-          for (int y = start_y; y < end_y; ++y)
-            for (int x = start_x; x < end_x; ++x)
-              {
-                int target_pos = (y + y_pos) * target_pitch + 3*(x + x_pos);
-                int brush_pos  = y * brush_pitch + 3*x;
+          int target_pos = (y + y_pos) * target_pitch + 3*(x + x_pos);
+          int brush_pos  = y * brush_pitch + 3*x;
 
-                target_buf[target_pos + 0] = 255;
-                target_buf[target_pos + 1] = brush_buf[brush_pos + 0];
-                target_buf[target_pos + 2] = brush_buf[brush_pos + 1];
-                target_buf[target_pos + 3] = brush_buf[brush_pos + 2];
-              }
+          target_buf[target_pos + 0] = 255;
+          target_buf[target_pos + 1] = brush_buf[brush_pos + 0];
+          target_buf[target_pos + 2] = brush_buf[brush_pos + 1];
+          target_buf[target_pos + 3] = brush_buf[brush_pos + 2];
         }
-      else
-        {
-          std::cout << "Unsupported bpp: " << brush.get_format().get_depth() << std::endl;
-        }
     }
+    else
+    {
+      std::cout << "Unsupported bpp: " << brush.get_format().get_depth() << std::endl;
+    }
+  }
   else if (brush.get_format().get_type() == pixelformat_index)
-    {
-      CL_Palette palette = brush.get_palette();
-      for (int y = start_y; y < end_y; ++y)
-        for (int x = start_x; x < end_x; ++x)
-          {
-            int target_pos = (y + y_pos) * target_pitch + 4*(x + x_pos);
-            int brush_pos  = y * brush_pitch + x;
+  {
+    CL_Palette palette = brush.get_palette();
+    for (int y = start_y; y < end_y; ++y)
+      for (int x = start_x; x < end_x; ++x)
+      {
+        int target_pos = (y + y_pos) * target_pitch + 4*(x + x_pos);
+        int brush_pos  = y * brush_pitch + x;
             
-            target_buf[target_pos + 0] = 255;
-            target_buf[target_pos + 1] = palette.colors[brush_buf[brush_pos]].get_blue();
-            target_buf[target_pos + 2] = palette.colors[brush_buf[brush_pos]].get_green();
-            target_buf[target_pos + 3] = palette.colors[brush_buf[brush_pos]].get_red();
-          }
-    }
+        target_buf[target_pos + 0] = 255;
+        target_buf[target_pos + 1] = palette.colors[brush_buf[brush_pos]].get_blue();
+        target_buf[target_pos + 2] = palette.colors[brush_buf[brush_pos]].get_green();
+        target_buf[target_pos + 3] = palette.colors[brush_buf[brush_pos]].get_red();
+      }
+  }
   else
-    {
-      assert(!"Unknown pixelformat type");
-    }
+  {
+    assert(!"Unknown pixelformat type");
+  }
     
 
 
@@ -120,71 +120,71 @@
   int brush_width  = brush.get_width();
 
   if (brush.get_format().get_type() == pixelformat_rgba)
+  {
+    if (brush.get_format().get_depth() == 32)
     {
-      if (brush.get_format().get_depth() == 32)
+      for (int y = start_y; y < end_y; ++y)
+        for (int x = start_x; x < end_x; ++x)
         {
-          for (int y = start_y; y < end_y; ++y)
-            for (int x = start_x; x < end_x; ++x)
-              {
-                int target_pos = (y + y_pos) * target_width + x + x_pos;
-                int brush_pos  = y * brush_width + x;
+          int target_pos = (y + y_pos) * target_width + x + x_pos;
+          int brush_pos  = y * brush_width + x;
 
-                unsigned char a  = brush_buf[4*brush_pos + 0];
-                unsigned char r  = brush_buf[4*brush_pos + 1];
-                unsigned char g  = brush_buf[4*brush_pos + 2];
-                unsigned char b  = brush_buf[4*brush_pos + 3];
+          unsigned char a  = brush_buf[4*brush_pos + 0];
+          unsigned char r  = brush_buf[4*brush_pos + 1];
+          unsigned char g  = brush_buf[4*brush_pos + 2];
+          unsigned char b  = brush_buf[4*brush_pos + 3];
 
-                unsigned char ta = target_buf[4*target_pos + 0];
-                unsigned char tr = target_buf[4*target_pos + 1];
-                unsigned char tg = target_buf[4*target_pos + 2];
-                unsigned char tb = target_buf[4*target_pos + 3];
+          unsigned char ta = target_buf[4*target_pos + 0];
+          unsigned char tr = target_buf[4*target_pos + 1];
+          unsigned char tg = target_buf[4*target_pos + 2];
+          unsigned char tb = target_buf[4*target_pos + 3];
 
-                float alpha  = a/255.0f;
+          float alpha  = a/255.0f;
         
-                target_buf[4*target_pos + 0] = std::min(255, ta + a);
-                target_buf[4*target_pos + 1] = std::min(255, int((1-alpha)*tr + alpha*r));
-                target_buf[4*target_pos + 2] = std::min(255, int((1-alpha)*tg + alpha*g));
-                target_buf[4*target_pos + 3] = std::min(255, int((1-alpha)*tb + alpha*b));
-              }
+          target_buf[4*target_pos + 0] = std::min(255, ta + a);
+          target_buf[4*target_pos + 1] = std::min(255, int((1-alpha)*tr + alpha*r));
+          target_buf[4*target_pos + 2] = std::min(255, int((1-alpha)*tg + alpha*g));
+          target_buf[4*target_pos + 3] = std::min(255, int((1-alpha)*tb + alpha*b));
         }
-      else if (brush.get_format().get_depth() == 24)
+    }
+    else if (brush.get_format().get_depth() == 24)
+    {
+      for (int y = start_y; y < end_y; ++y)
+        for (int x = start_x; x < end_x; ++x)
         {
-          for (int y = start_y; y < end_y; ++y)
-            for (int x = start_x; x < end_x; ++x)
-              {
-                int target_pos = (y + y_pos) * target_width + x + x_pos;
-                int brush_pos  = y * brush_width + x;
+          int target_pos = (y + y_pos) * target_width + x + x_pos;
+          int brush_pos  = y * brush_width + x;
 
-                target_buf[4*target_pos + 0] = 255;
-                target_buf[4*target_pos + 1] = brush_buf[3*brush_pos + 0];
-                target_buf[4*target_pos + 2] = brush_buf[3*brush_pos + 1];
-                target_buf[4*target_pos + 3] = brush_buf[3*brush_pos + 2];
-              }
+          target_buf[4*target_pos + 0] = 255;
+          target_buf[4*target_pos + 1] = brush_buf[3*brush_pos + 0];
+          target_buf[4*target_pos + 2] = brush_buf[3*brush_pos + 1];
+          target_buf[4*target_pos + 3] = brush_buf[3*brush_pos + 2];
         }
-      else
-        {
-          std::cout << "Unsupported bpp: " << brush.get_format().get_depth() << std::endl;
-        }
     }
+    else
+    {
+      std::cout << "Unsupported bpp: " << brush.get_format().get_depth() << std::endl;
+    }
+  }
   else if (brush.get_format().get_type() == pixelformat_index)
-    {
-      CL_Palette palette = brush.get_palette();
-      for (int y = start_y; y < end_y; ++y)
-        for (int x = start_x; x < end_x; ++x)
-          {
-            int target_pos = (y + y_pos) * target_width + x + x_pos;
-            int brush_pos  = y * brush_width + x;
+  {
+    CL_Palette palette = brush.get_palette();
+    for (int y = start_y; y < end_y; ++y)
+      for (int x = start_x; x < end_x; ++x)
+      {
+        int target_pos = (y + y_pos) * target_width + x + x_pos;
+        int brush_pos  = y * brush_width + x;
             
-            target_buf[4*target_pos + 0] = 255;
-            target_buf[4*target_pos + 1] = palette.colors[brush_buf[brush_pos]].get_blue();
-            target_buf[4*target_pos + 2] = palette.colors[brush_buf[brush_pos]].get_green();
-            target_buf[4*target_pos + 3] = palette.colors[brush_buf[brush_pos]].get_red();
-          }
-    }
+        target_buf[4*target_pos + 0] = 255;
+        target_buf[4*target_pos + 1] = palette.colors[brush_buf[brush_pos]].get_blue();
+        target_buf[4*target_pos + 2] = palette.colors[brush_buf[brush_pos]].get_green();
+        target_buf[4*target_pos + 3] = palette.colors[brush_buf[brush_pos]].get_red();
+      }
+  }
   else
-    {
-      assert(!"Unknown pixelformat type");
-    }
+  {
+    assert(!"Unknown pixelformat type");
+  }
     
 
 

Modified: trunk/flexlay/lib/brushmask.cpp
===================================================================
--- trunk/flexlay/lib/brushmask.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/brushmask.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -18,7 +18,7 @@
 
 /* Most of the code below is taken from Gimp2.2:
    gimp_brush_generated module Copyright 1998 Jay Cox <jaycox at earthlink.net> 
- */
+*/
 
 #include <iostream>
 #include <math.h>
@@ -54,11 +54,11 @@
 
 TempBuf *
 temp_buf_new (gint    width,
-	      gint    height,
-	      gint    bytes,
-	      gint    x,
-	      gint    y,
-	      guchar *col)
+              gint    height,
+              gint    bytes,
+              gint    x,
+              gint    y,
+              guchar *col)
 {
   TempBuf* buf = new TempBuf;
 
@@ -79,10 +79,10 @@
 {
   /* this aint' a real gauss function */
   if (f < -0.5)
-    {
-      f = -1.0 - f;
-      return (2.0 * f*f);
-    }
+  {
+    f = -1.0 - f;
+    return (2.0 * f*f);
+  }
 
   if (f < 0.5)
     return (1.0 - 2.0 * f*f);
@@ -143,7 +143,7 @@
   brush->y_axis.y =        c * short_radius;
 
   switch (brush->shape)
-    {
+  {
     case BRUSH_SHAPE_CIRCLE:
       width  = static_cast<int>(ceil (sqrt (brush->x_axis.x * brush->x_axis.x +
                                             brush->y_axis.x * brush->y_axis.x)));
@@ -163,16 +163,16 @@
 
     default:
       return;
-    }
+  }
 
   if (brush->spikes > 2)
-    {
-      /* could be optimized by respecting the angle */
-      width = height = static_cast<int>(ceil (sqrt (brush->radius * brush->radius +
-                                                    short_radius * short_radius)));
-      brush->y_axis.x =        s * brush->radius;
-      brush->y_axis.y =        c * brush->radius;
-    }
+  {
+    /* could be optimized by respecting the angle */
+    width = height = static_cast<int>(ceil (sqrt (brush->radius * brush->radius +
+                                                  short_radius * short_radius)));
+    brush->y_axis.x =        s * brush->radius;
+    brush->y_axis.y =        c * brush->radius;
+  }
 
   brush->mask = temp_buf_new (width  * 2 + 1,
                               height * 2 + 1,
@@ -194,88 +194,88 @@
   sum = 0.0;
 
   for (x = 0; x < OVERSAMPLING; x++)
-    {
-      d = fabs ((x + 0.5) / OVERSAMPLING - 0.5);
+  {
+    d = fabs ((x + 0.5) / OVERSAMPLING - 0.5);
 
-      if (d > brush->radius)
-        buffer[x] = 0.0;
-      else
-        buffer[x] = gauss (pow (d / brush->radius, exponent));
+    if (d > brush->radius)
+      buffer[x] = 0.0;
+    else
+      buffer[x] = gauss (pow (d / brush->radius, exponent));
 
-      sum += buffer[x];
-    }
+    sum += buffer[x];
+  }
 
   for (x = 0; d < brush->radius || sum > 0.00001; d += 1.0 / OVERSAMPLING)
-    {
-      sum -= buffer[x % OVERSAMPLING];
+  {
+    sum -= buffer[x % OVERSAMPLING];
 
-      if (d > brush->radius)
-        buffer[x % OVERSAMPLING] = 0.0;
-      else
-        buffer[x % OVERSAMPLING] = gauss (pow (d / brush->radius, exponent));
+    if (d > brush->radius)
+      buffer[x % OVERSAMPLING] = 0.0;
+    else
+      buffer[x % OVERSAMPLING] = gauss (pow (d / brush->radius, exponent));
 
-      sum += buffer[x % OVERSAMPLING];
-      lookup[x++] = static_cast<int>(rint(sum * (255.0 / OVERSAMPLING)));
-    }
+    sum += buffer[x % OVERSAMPLING];
+    lookup[x++] = static_cast<int>(rint(sum * (255.0 / OVERSAMPLING)));
+  }
 
   while (x < length)
-    {
-      lookup[x++] = 0;
-    }
+  {
+    lookup[x++] = 0;
+  }
 
   cs = cos (- 2 * M_PI / brush->spikes);
   ss = sin (- 2 * M_PI / brush->spikes);
 
   /* for an even number of spikes compute one half and mirror it */
   for (y = (brush->spikes % 2 ? -height : 0); y <= height; y++)
+  {
+    for (x = -width; x <= width; x++)
     {
-      for (x = -width; x <= width; x++)
-        {
-          double tx, ty, angle;
+      double tx, ty, angle;
 
-          tx = c*x - s*y;
-          ty = fabs (s*x + c*y);
+      tx = c*x - s*y;
+      ty = fabs (s*x + c*y);
 
-          if (brush->spikes > 2)
-            {
-              angle = atan2 (ty, tx);
+      if (brush->spikes > 2)
+      {
+        angle = atan2 (ty, tx);
 
-              while (angle > M_PI / brush->spikes)
-                {
-                  double sx = tx, sy = ty;
+        while (angle > M_PI / brush->spikes)
+        {
+          double sx = tx, sy = ty;
 
-                  tx = cs * sx - ss * sy;
-                  ty = ss * sx + cs * sy;
+          tx = cs * sx - ss * sy;
+          ty = ss * sx + cs * sy;
 
-                  angle -= 2 * M_PI / brush->spikes;
-                }
-            }
+          angle -= 2 * M_PI / brush->spikes;
+        }
+      }
 
-          ty *= brush->aspect_ratio;
-          switch (brush->shape)
-            {
-            case BRUSH_SHAPE_CIRCLE:
-              d = sqrt (tx*tx + ty*ty);
-              break;
-            case BRUSH_SHAPE_SQUARE:
-              d = std::max (fabs (tx), fabs (ty));
-              break;
-            case BRUSH_SHAPE_DIAMOND:
-              d = fabs (tx) + fabs (ty);
-              break;
-            }
+      ty *= brush->aspect_ratio;
+      switch (brush->shape)
+      {
+        case BRUSH_SHAPE_CIRCLE:
+          d = sqrt (tx*tx + ty*ty);
+          break;
+        case BRUSH_SHAPE_SQUARE:
+          d = std::max (fabs (tx), fabs (ty));
+          break;
+        case BRUSH_SHAPE_DIAMOND:
+          d = fabs (tx) + fabs (ty);
+          break;
+      }
 
-          if (d < brush->radius + 1)
-            a = lookup[(gint) rint (d * OVERSAMPLING)];
-          else
-            a = 0;
+      if (d < brush->radius + 1)
+        a = lookup[(gint) rint (d * OVERSAMPLING)];
+      else
+        a = 0;
 
-          centerp[ y * brush->mask->width + x] = a;
+      centerp[ y * brush->mask->width + x] = a;
 
-          if (brush->spikes % 2 == 0)
-            centerp[-1 * y * brush->mask->width - x] = a;
-        }
+      if (brush->spikes % 2 == 0)
+        centerp[-1 * y * brush->mask->width - x] = a;
     }
+  }
 
   delete lookup;
 }
@@ -308,12 +308,12 @@
   // FIXME: Leaving out the right/bottom border, since thats full of
   // random spots... more a workaround than a fix really
   for (int i = 0; i < brush.mask->height * brush.mask->width; ++i)
-    {
-      buf[i*4+0] = brush.mask->data[i];
-      buf[i*4+1] = 255;
-      buf[i*4+2] = 255;
-      buf[i*4+3] = 255;
-    }
+  {
+    buf[i*4+0] = brush.mask->data[i];
+    buf[i*4+1] = 255;
+    buf[i*4+2] = 255;
+    buf[i*4+3] = 255;
+  }
   buffer.unlock();
 
   return buffer;

Modified: trunk/flexlay/lib/colorpicker.cpp
===================================================================
--- trunk/flexlay/lib/colorpicker.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/colorpicker.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -61,68 +61,68 @@
     CL_Color new_color; 
 
     if (event.mouse_pos.y >= get_height() || event.mouse_pos.y < 0)
-      {
-        new_color = colors[0];
-      }
+    {
+      new_color = colors[0];
+    }
     else
-      {
-        float factor  = (float(event.mouse_pos.y) / get_height()) * (colors.size()-1);
-        int   prevcol = int(factor);
-        int   nextcol = prevcol+1;
+    {
+      float factor  = (float(event.mouse_pos.y) / get_height()) * (colors.size()-1);
+      int   prevcol = int(factor);
+      int   nextcol = prevcol+1;
 
-        float val  = factor - prevcol;
-        float ival = 1.0f - val;
+      float val  = factor - prevcol;
+      float ival = 1.0f - val;
 
 
-        if (val >= 0 && val < 1.0f)
-          {
-            new_color = CL_Color(int(val * colors[nextcol].get_red()   + ival * colors[prevcol].get_red()),
-                                 int(val * colors[nextcol].get_green() + ival * colors[prevcol].get_green()),
-                                 int(val * colors[nextcol].get_blue()  + ival * colors[prevcol].get_blue()),
-                                 int(val * colors[nextcol].get_alpha() + ival * colors[prevcol].get_alpha()));
-          }
-        else
-          {
-            std::cout << "Out of range" << std::endl;
-            new_color = colors[0];
-          }
+      if (val >= 0 && val < 1.0f)
+      {
+        new_color = CL_Color(int(val * colors[nextcol].get_red()   + ival * colors[prevcol].get_red()),
+                             int(val * colors[nextcol].get_green() + ival * colors[prevcol].get_green()),
+                             int(val * colors[nextcol].get_blue()  + ival * colors[prevcol].get_blue()),
+                             int(val * colors[nextcol].get_alpha() + ival * colors[prevcol].get_alpha()));
       }
+      else
+      {
+        std::cout << "Out of range" << std::endl;
+        new_color = colors[0];
+      }
+    }
     on_color_change(new_color);
 
     /*
-    std::cout << new_color.get_red() << ", "
-              << new_color.get_green() << ", "
-              << new_color.get_blue() << ", "
-              << new_color.get_alpha()
-              << std::endl;*/
+      std::cout << new_color.get_red() << ", "
+      << new_color.get_green() << ", "
+      << new_color.get_blue() << ", "
+      << new_color.get_alpha()
+      << std::endl;*/
   }
   
   void on_mouse_up(const CL_InputEvent& event)
   {
     if (event.id == CL_MOUSE_LEFT)
-      {
-        pressed = false;
-        release_mouse();
-        update_pointer(event);
-      }
+    {
+      pressed = false;
+      release_mouse();
+      update_pointer(event);
+    }
   }
 
   void on_mouse_down(const CL_InputEvent& event)
   {
     if (event.id == CL_MOUSE_LEFT)
-      {
-        pressed = true;
-        capture_mouse();
-        update_pointer(event);
-      }  
+    {
+      pressed = true;
+      capture_mouse();
+      update_pointer(event);
+    }  
   }
   
   void on_mouse_move(const CL_InputEvent& event)
   {
     if (pressed)
-      {
-        update_pointer(event);
-      }
+    {
+      update_pointer(event);
+    }
   }
 
   void draw()
@@ -133,14 +133,14 @@
     int psize = get_height()/6;
     
     for(Colors::size_type i = 0; i < colors.size()-1; ++i)
-      {
-        CL_Display::fill_rect(CL_Rect(CL_Point(0, i*psize),
-                                      CL_Size(get_width(), psize)),
-                              CL_Gradient(colors[i],
-                                          colors[i],
-                                          colors[i+1],
-                                          colors[i+1]));
-      }
+    {
+      CL_Display::fill_rect(CL_Rect(CL_Point(0, i*psize),
+                                    CL_Size(get_width(), psize)),
+                            CL_Gradient(colors[i],
+                                        colors[i],
+                                        colors[i+1],
+                                        colors[i+1]));
+    }
 
     CL_Display::pop_modelview();    
   }
@@ -196,29 +196,29 @@
   void on_mouse_up(const CL_InputEvent& event)
   {
     if (event.id == CL_MOUSE_LEFT)
-      {
-        pressed = false;
-        release_mouse();
-        update_pointer(event);
-      }
+    {
+      pressed = false;
+      release_mouse();
+      update_pointer(event);
+    }
   }
 
   void on_mouse_down(const CL_InputEvent& event)
   {
     if (event.id == CL_MOUSE_LEFT)
-      {
-        pressed = true;
-        capture_mouse();
-        update_pointer(event);
-      }
+    {
+      pressed = true;
+      capture_mouse();
+      update_pointer(event);
+    }
   }
 
   void on_mouse_move(const CL_InputEvent& event)
   {
     if (pressed)
-      {
-        update_pointer(event);    
-      }
+    {
+      update_pointer(event);    
+    }
   }
 };
 
@@ -285,11 +285,11 @@
                        color.get_alpha());
     on_color_change(new_color);
     /*
-    std::cout << new_color.get_red() << ", "
-              << new_color.get_green() << ", "
-              << new_color.get_blue() << ", "
-              << new_color.get_alpha()
-              << std::endl;
+      std::cout << new_color.get_red() << ", "
+      << new_color.get_green() << ", "
+      << new_color.get_blue() << ", "
+      << new_color.get_alpha()
+      << std::endl;
     */
   }
 
@@ -304,29 +304,29 @@
   void on_mouse_up(const CL_InputEvent& event)
   {
     if (event.id == CL_MOUSE_LEFT)
-      {
-        pressed = false;
-        release_mouse();
-        update_pointer(event);
-      }    
+    {
+      pressed = false;
+      release_mouse();
+      update_pointer(event);
+    }    
   }
 
   void on_mouse_down(const CL_InputEvent& event)
   {
     if (event.id == CL_MOUSE_LEFT)
-      {
-        pressed = true;
-        capture_mouse();
-        update_pointer(event);
-      }
+    {
+      pressed = true;
+      capture_mouse();
+      update_pointer(event);
+    }
   }
 
   void on_mouse_move(const CL_InputEvent& event)
   {
     if (pressed)
-      {
-        update_pointer(event);
-      }
+    {
+      update_pointer(event);
+    }
   }
 };
 

Modified: trunk/flexlay/lib/console.cpp
===================================================================
--- trunk/flexlay/lib/console.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/console.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -59,9 +59,9 @@
 
   for(int y = 0; y < size.height; ++y)
     for(int x = 0; x < size.width; ++x)
-      {
-        font.draw_character(x * font_w, y * font_h, screen.at(x, y));
-      }
+    {
+      font.draw_character(x * font_w, y * font_h, screen.at(x, y));
+    }
 }
 
 Console::Console(/*const CL_Font& font,*/ const CL_Rect& rect, CL_Component* parent)
@@ -91,19 +91,19 @@
   full_buffer += c; 
 
   if (c == '\n')
-    {
-      cursor_pos.x = 0;
-      cursor_pos.y += 1;
-    }
+  {
+    cursor_pos.x = 0;
+    cursor_pos.y += 1;
+  }
   else
-    {
-      screen.at(cursor_pos.x, cursor_pos.y) = c;
+  {
+    screen.at(cursor_pos.x, cursor_pos.y) = c;
 
-      cursor_pos.x += 1;
+    cursor_pos.x += 1;
 
-      if (cursor_pos.x >= size.width)
-        cursor_pos.x = 0;
-    }
+    if (cursor_pos.x >= size.width)
+      cursor_pos.x = 0;
+  }
 
   // Move all content one line up
   if (cursor_pos.y >= size.height)
@@ -116,10 +116,10 @@
   std::cout << str << std::flush;
 
   for(std::string::const_iterator i = str.begin(); i != str.end(); ++i)
-    {
-      if (*i != 0)
-        impl->putchar(*i);
-    }
+  {
+    if (*i != 0)
+      impl->putchar(*i);
+  }
 }
 
 /* EOF */

Modified: trunk/flexlay/lib/directory_view.cpp
===================================================================
--- trunk/flexlay/lib/directory_view.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/directory_view.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -110,39 +110,39 @@
 
   int j = 0;
   for(Items::iterator i = items.begin(); i != items.begin()+50 && i != items.end(); ++i)
+  {
+    if (current_item && current_item < int(items.size()) && j == current_item)
     {
-      if (current_item && current_item < int(items.size()) && j == current_item)
-        {
-          CL_Rect rect = font.bounding_rect(x_pos * (column_width + horizontal_spacing) + 1, 
-                                            y_pos * (font.get_height() + vertical_spacing) + 1,
-                                            i->name);
-          CL_Display::fill_rect(CL_Rect(rect.left-5, rect.top-3,
-                                        rect.left+5+column_width, rect.bottom+3),
-                                CL_Color(250, 200, 0));
-        }
+      CL_Rect rect = font.bounding_rect(x_pos * (column_width + horizontal_spacing) + 1, 
+                                        y_pos * (font.get_height() + vertical_spacing) + 1,
+                                        i->name);
+      CL_Display::fill_rect(CL_Rect(rect.left-5, rect.top-3,
+                                    rect.left+5+column_width, rect.bottom+3),
+                            CL_Color(250, 200, 0));
+    }
 
-      // draw item
-      if (!i->directory)
-        {
-          font.draw(x_pos * (column_width + horizontal_spacing), 
-                    y_pos * (font.get_height() + vertical_spacing),
-                    i->name);
-        }
-      else
-        {
-          font.draw(x_pos * (column_width + horizontal_spacing), 
-                    y_pos * (font.get_height() + vertical_spacing),
-                    "[" + i->name + "]");
-        }
+    // draw item
+    if (!i->directory)
+    {
+      font.draw(x_pos * (column_width + horizontal_spacing), 
+                y_pos * (font.get_height() + vertical_spacing),
+                i->name);
+    }
+    else
+    {
+      font.draw(x_pos * (column_width + horizontal_spacing), 
+                y_pos * (font.get_height() + vertical_spacing),
+                "[" + i->name + "]");
+    }
 
-      x_pos += 1;
-      if (x_pos >= num_columns)
-        {
-          x_pos = 0;
-          y_pos += 1;
-        }
-      ++j;
+    x_pos += 1;
+    if (x_pos >= num_columns)
+    {
+      x_pos = 0;
+      y_pos += 1;
     }
+    ++j;
+  }
 }
 
 int
@@ -162,10 +162,10 @@
 {
   current_item = get_item(event.mouse_pos);
   if (current_item >= 0 && current_item < int(items.size()))
-    {
-      if (items[current_item].directory)
+  {
+    if (items[current_item].directory)
       parent->set_directory(path + "/" + items[current_item].name);
-    }
+  }
 }
 
 void 
@@ -182,13 +182,13 @@
 
   scanner.scan(path);
   while(scanner.next())
-    {
-      DirectoryViewEntry entry;
-      entry.name = scanner.get_name();
-      entry.hidden = (scanner.get_name()[0] == '.');
-      entry.directory = scanner.is_directory();
-      items.push_back(entry);
-    }
+  {
+    DirectoryViewEntry entry;
+    entry.name = scanner.get_name();
+    entry.hidden = (scanner.get_name()[0] == '.');
+    entry.directory = scanner.is_directory();
+    items.push_back(entry);
+  }
 
   std::sort(items.begin(), items.end(), DirectoryViewSorter());
 
@@ -196,10 +196,10 @@
 
   column_width = 60; // min_colum_width
   for(Items::iterator i = items.begin(); i != items.end(); ++i)
-    {
-      CL_Rect rect = font.bounding_rect(0, 0, i->name + "[]");
-      column_width = std::max(column_width, rect.get_width());
-    }
+  {
+    CL_Rect rect = font.bounding_rect(0, 0, i->name + "[]");
+    column_width = std::max(column_width, rect.get_width());
+  }
 
   num_columns = parent->get_width()/column_width;
 }

Modified: trunk/flexlay/lib/editor_map.cpp
===================================================================
--- trunk/flexlay/lib/editor_map.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/editor_map.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -58,15 +58,15 @@
   : impl(0)
 {
   if (create)
-    {
-      impl = new EditorMapImpl();
-      impl->background_color = CL_Color(100, 80, 100);
-      impl->foreground_color = CL_Color(255, 80, 255);
-      impl->modified = false;
-      impl->serial = 0;
-      impl->has_bounding_rect = false;
-      impl->bounding_rect = CL_Rect(0,0,0,0);
-    }
+  {
+    impl = new EditorMapImpl();
+    impl->background_color = CL_Color(100, 80, 100);
+    impl->foreground_color = CL_Color(255, 80, 255);
+    impl->modified = false;
+    impl->serial = 0;
+    impl->has_bounding_rect = false;
+    impl->bounding_rect = CL_Rect(0,0,0,0);
+  }
 }
 
 void
@@ -90,14 +90,14 @@
   CL_Rect rect = get_bounding_rect();
 
   if (rect != CL_Rect(0,0,0,0))
-    {
-      gc->fill_rect(rect, impl->background_color);
-      gc->draw_rect(rect, impl->foreground_color);
-    }
+  {
+    gc->fill_rect(rect, impl->background_color);
+    gc->draw_rect(rect, impl->foreground_color);
+  }
   else
-    {
-      gc->clear(impl->background_color);
-    }
+  {
+    gc->clear(impl->background_color);
+  }
 }
 
 void
@@ -171,50 +171,50 @@
 EditorMap::set_bounding_rect(const CL_Rect& rect)
 {
   if (rect != CL_Rect(0,0,0,0))
-    {
-      impl->has_bounding_rect = true;
-      impl->bounding_rect     = rect;
-    }
+  {
+    impl->has_bounding_rect = true;
+    impl->bounding_rect     = rect;
+  }
   else
-    {
-      impl->has_bounding_rect = false;
-      impl->bounding_rect     = rect;
-    }
+  {
+    impl->has_bounding_rect = false;
+    impl->bounding_rect     = rect;
+  }
 }
 
 CL_Rect
 EditorMap::get_bounding_rect()
 {
   if (impl->has_bounding_rect)
-    {
-      return impl->bounding_rect;
-    }
+  {
+    return impl->bounding_rect;
+  }
   else
+  {
+    bool init = false;
+    CL_Rect rect(0,0,0,0);
+
+    for(EditorMapImpl::Layers::iterator i = impl->layers.begin(); i != impl->layers.end(); ++i)
     {
-      bool init = false;
-      CL_Rect rect(0,0,0,0);
-
-      for(EditorMapImpl::Layers::iterator i = impl->layers.begin(); i != impl->layers.end(); ++i)
+      if (i->has_bounding_rect())
+      {
+        if (!init)
         {
-          if (i->has_bounding_rect())
-            {
-              if (!init)
-                {
-                  rect = i->get_bounding_rect();
-                  init = true;
-                }
-              else
-                {
-                  CL_Rect other = i->get_bounding_rect();
-                  rect.top    = std::min(rect.top,    other.top);
-                  rect.bottom = std::max(rect.bottom, other.bottom);
-                  rect.left   = std::min(rect.left,   other.left);
-                  rect.right  = std::max(rect.right,  other.right);              
-                }
-            }
+          rect = i->get_bounding_rect();
+          init = true;
         }
-      return rect;
+        else
+        {
+          CL_Rect other = i->get_bounding_rect();
+          rect.top    = std::min(rect.top,    other.top);
+          rect.bottom = std::max(rect.bottom, other.bottom);
+          rect.left   = std::min(rect.left,   other.left);
+          rect.right  = std::max(rect.right,  other.right);              
+        }
+      }
     }
+    return rect;
+  }
 }
 
 void
@@ -236,26 +236,26 @@
 EditorMap::undo()
 {
   if (!impl->undo_stack.empty())
-    {
-      Command command = impl->undo_stack.back();
-      impl->undo_stack.pop_back();
-      command.undo();
-      impl->redo_stack.push_back(command);
-      impl->on_change();
-    }
+  {
+    Command command = impl->undo_stack.back();
+    impl->undo_stack.pop_back();
+    command.undo();
+    impl->redo_stack.push_back(command);
+    impl->on_change();
+  }
 }
 
 void
 EditorMap::redo()
 {
   if (!impl->redo_stack.empty())
-    {
-      Command command = impl->redo_stack.back();
-      impl->redo_stack.pop_back();
-      command.redo();
-      impl->undo_stack.push_back(command);
-      impl->on_change();
-    }
+  {
+    Command command = impl->redo_stack.back();
+    impl->redo_stack.pop_back();
+    command.redo();
+    impl->undo_stack.push_back(command);
+    impl->on_change();
+  }
 }
 
 int

Modified: trunk/flexlay/lib/editor_map_component.cpp
===================================================================
--- trunk/flexlay/lib/editor_map_component.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/editor_map_component.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -106,20 +106,20 @@
 EditorMapComponentImpl::on_key_down(const CL_InputEvent& event)
 {
   if (event.id >= 0 && event.id < 256)
-    { 
-      CL_Rect rect = parent->get_position();
-      key_bindings[event.id](CL_Mouse::get_x() - rect.left,
-                             CL_Mouse::get_y() - rect.top);
-    }
+  { 
+    CL_Rect rect = parent->get_position();
+    key_bindings[event.id](CL_Mouse::get_x() - rect.left,
+                           CL_Mouse::get_y() - rect.top);
+  }
 
   if (event.repeat_count == 0)
-    {
-      CL_Rect rect = parent->get_position();
-      CL_InputEvent ev2 = event;
-      ev2.mouse_pos = CL_Point(CL_Mouse::get_x() - rect.left,
-                               CL_Mouse::get_y() - rect.top);
-      workspace.key_down(ev2);
-    }
+  {
+    CL_Rect rect = parent->get_position();
+    CL_InputEvent ev2 = event;
+    ev2.mouse_pos = CL_Point(CL_Mouse::get_x() - rect.left,
+                             CL_Mouse::get_y() - rect.top);
+    workspace.key_down(ev2);
+  }
 }
 
 void
@@ -254,14 +254,14 @@
   //std::cout << str << " => " << id << std::endl;
 
   if (id > 0 && id < 256)
-    {
-      return impl->key_bindings[id];
-    }
+  {
+    return impl->key_bindings[id];
+  }
   else
-    {
-      std::cout << "EditorMapComponent::sig_on_key: invalid key id: " << id << std::endl;
-      return impl->key_bindings[0];
-    }
+  {
+    std::cout << "EditorMapComponent::sig_on_key: invalid key id: " << id << std::endl;
+    return impl->key_bindings[0];
+  }
 }
 
 GraphicContextState&

Modified: trunk/flexlay/lib/field.hpp
===================================================================
--- trunk/flexlay/lib/field.hpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/field.hpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -68,11 +68,11 @@
   Field<T>& operator=(const Field<T>& copy)
   {
     if (this != &copy)
-      {
-        width  = copy.width;
-        height = copy.height;
-        vec    = copy.vec;
-      }
+    {
+      width  = copy.width;
+      height = copy.height;
+      vec    = copy.vec;
+    }
     return *this;
   }
 

Modified: trunk/flexlay/lib/flexlay.cpp
===================================================================
--- trunk/flexlay/lib/flexlay.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/flexlay.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -53,9 +53,9 @@
 
   std::cout << "Flexlay::init()" << std::endl;
   try {
-    #ifdef WIN32
+#ifdef WIN32
     CL_SetupCore::set_instance(GetModuleHandle("flexlay_wrap.dll"));
-    #endif
+#endif
     CL_SetupCore::init();
 #ifdef HAVE_LIBSDL
     if (use_opengl)

Modified: trunk/flexlay/lib/flexlay.hpp
===================================================================
--- trunk/flexlay/lib/flexlay.hpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/flexlay.hpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -24,49 +24,49 @@
 
 /*! \mainpage Flexlay - A Flexible Layered 2D Editor
   
-\section intro Introduction
+  \section intro Introduction
 
-Flexlay is a rather flexible layered editor mainly meant for editing
-game data such as levels, tilemaps, enemy placement and such. It
-provides a basic framework which makes it easy to add new
-functionality, special dialog windows and such needed to customize it
-for a specific game. Flexlay itself is actually a Python module and
-not an editor in itself, however due to reasonably simple Python
-scripts one can already have a fully working editor.
+  Flexlay is a rather flexible layered editor mainly meant for editing
+  game data such as levels, tilemaps, enemy placement and such. It
+  provides a basic framework which makes it easy to add new
+  functionality, special dialog windows and such needed to customize it
+  for a specific game. Flexlay itself is actually a Python module and
+  not an editor in itself, however due to reasonably simple Python
+  scripts one can already have a fully working editor.
 
-\section structure Structure
+  \section structure Structure
 
-Flexlay provides the following basic classes on which everything else
-is build:
+  Flexlay provides the following basic classes on which everything else
+  is build:
 
-Command: each operation on data is encapsuled in a Command object
-which provides undo/redo capability, together with a way to easily
-record macros and write scripts with it.
+  Command: each operation on data is encapsuled in a Command object
+  which provides undo/redo capability, together with a way to easily
+  record macros and write scripts with it.
 
-EditorMapLayer: a map layer is the class that holds the data, special
-layers such as object or tilemap layers derive from this class to
-provide the capabilites needed to use them
+  EditorMapLayer: a map layer is the class that holds the data, special
+  layers such as object or tilemap layers derive from this class to
+  provide the capabilites needed to use them
 
-Tool: A tool manages and dispatches mouse input to Commands, thus
-giving the user an interactive way to manipulate map data.
+  Tool: A tool manages and dispatches mouse input to Commands, thus
+  giving the user an interactive way to manipulate map data.
 
-GUI: Flexlay provides a simple GUI framework that can be used from
-Python to create dialogboxes, add buttons to the main window and such.
+  GUI: Flexlay provides a simple GUI framework that can be used from
+  Python to create dialogboxes, add buttons to the main window and such.
 
-\section games Games
+  \section games Games
 
-Currently Flexlay supports the following games with different levels
-of completeness:
+  Currently Flexlay supports the following games with different levels
+  of completeness:
 
-netPanzer: fully working load/save and map editing capabilites
+  netPanzer: fully working load/save and map editing capabilites
 
-SuperTux: fully working load/save and map editing capabilites, however
-a bit limited when it comes to object properties
+  SuperTux: fully working load/save and map editing capabilites, however
+  a bit limited when it comes to object properties
 
-Windstille: fully working load/save support, however due to the game
-itself not being ready this is not so usefull
+  Windstille: fully working load/save support, however due to the game
+  itself not being ready this is not so usefull
 
-Pingus: just very basic load support
+  Pingus: just very basic load support
 
 */
 

Modified: trunk/flexlay/lib/generated_brush.cpp
===================================================================
--- trunk/flexlay/lib/generated_brush.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/generated_brush.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -40,7 +40,7 @@
 };
 
 GeneratedBrush::GeneratedBrush(const Brush& brush)
-: impl(dynamic_cast<GeneratedBrushImpl*>(brush.impl.get())) // FIXME: WANT WORK WITH REAL SMARTPTR!!!
+  : impl(dynamic_cast<GeneratedBrushImpl*>(brush.impl.get())) // FIXME: WANT WORK WITH REAL SMARTPTR!!!
 {
 }
 
@@ -65,18 +65,18 @@
 GeneratedBrushImpl::update()
 {
   if (dirty)
-    {
-      CL_SpriteDescription desc;
-      desc.add_frame(generate_brushmask(shape,
-                                        radius, 
-                                        spikes,
-                                        hardness, 
-                                        aspect_ratio, 
-                                        angle));
-      sprite = CL_Sprite(desc);
-      sprite.set_alignment(origin_center);
-      dirty = false;
-    }
+  {
+    CL_SpriteDescription desc;
+    desc.add_frame(generate_brushmask(shape,
+                                      radius, 
+                                      spikes,
+                                      hardness, 
+                                      aspect_ratio, 
+                                      angle));
+    sprite = CL_Sprite(desc);
+    sprite.set_alignment(origin_center);
+    dirty = false;
+  }
 }
 
 void

Modified: trunk/flexlay/lib/graphic_context_state.cpp
===================================================================
--- trunk/flexlay/lib/graphic_context_state.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/graphic_context_state.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -141,13 +141,13 @@
   
   //std::cout << "Screen: " << screen_relation << " Zoom: " << rect_relation << std::endl;
   if (rect_relation < screen_relation) // take width, ignore height
-    {
-      impl->zoom = get_width()/width; 
-    }
+  {
+    impl->zoom = get_width()/width; 
+  }
   else // take height, ignore width
-    {
-      impl->zoom = get_height()/height;
-    }
+  {
+    impl->zoom = get_height()/height;
+  }
 
   impl->offset.x = (get_width()  / (2*impl->zoom)) - center_x;
   impl->offset.y = (get_height() / (2*impl->zoom)) - center_y;

Modified: trunk/flexlay/lib/helper.cpp
===================================================================
--- trunk/flexlay/lib/helper.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/helper.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -150,12 +150,12 @@
   
   for(int y = 0; y < height; ++y)
     for(int x = 0; x < width; ++x)
-      {
-        target_buf[target_pitch*y + 4*x + 0] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 0];
-        target_buf[target_pitch*y + 4*x + 1] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 1];
-        target_buf[target_pitch*y + 4*x + 2] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 2];
-        target_buf[target_pitch*y + 4*x + 3] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 3];
-      }
+    {
+      target_buf[target_pitch*y + 4*x + 0] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 0];
+      target_buf[target_pitch*y + 4*x + 1] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 1];
+      target_buf[target_pitch*y + 4*x + 2] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 2];
+      target_buf[target_pitch*y + 4*x + 3] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 3];
+    }
 
   buffer.unlock();
   target.unlock();

Modified: trunk/flexlay/lib/icon.cpp
===================================================================
--- trunk/flexlay/lib/icon.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/icon.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -80,30 +80,30 @@
   sprite.set_alignment(origin_center);
 
   if (is_enabled)
+  {
+    if (is_down)
     {
-      if (is_down)
-        {
+      Box::draw_button_down(rect);
+    }
+    else
+    {
+      if (parent->has_mouse_over())
+      {
+        if (down)
           Box::draw_button_down(rect);
-        }
+        else
+          Box::draw_button_up(rect);
+      }
       else
-        {
-          if (parent->has_mouse_over())
-            {
-              if (down)
-                Box::draw_button_down(rect);
-              else
-                Box::draw_button_up(rect);
-            }
-          else
-            Box::draw_button_neutral(rect);
-        }
-      sprite.set_alpha(1.0f);
+        Box::draw_button_neutral(rect);
     }
+    sprite.set_alpha(1.0f);
+  }
   else
-    {
-      Box::draw_button_neutral(rect);
-      sprite.set_alpha(0.3f);
-    }
+  {
+    Box::draw_button_neutral(rect);
+    sprite.set_alpha(0.3f);
+  }
   sprite.draw((rect.get_width()+1)/2, (rect.get_height()+1)/2);
   CL_Display::pop_modelview();
 }
@@ -112,25 +112,25 @@
 IconImpl::mouse_up  (const CL_InputEvent& event)
 {
   if (is_enabled)
+  {
+    down         = false;
+    parent->release_mouse();  
+
+    if (parent->has_mouse_over())
     {
-      down         = false;
-      parent->release_mouse();  
-
-      if (parent->has_mouse_over())
-        {
-          sig_on_click();
-        }
+      sig_on_click();
     }
+  }
 }
 
 void
 IconImpl::mouse_down(const CL_InputEvent& event)
 {
   if (is_enabled)
-    {
-      down         = true;
-      parent->capture_mouse();
-    }
+  {
+    down         = true;
+    parent->capture_mouse();
+  }
 }
 
 void 

Modified: trunk/flexlay/lib/layer.cpp
===================================================================
--- trunk/flexlay/lib/layer.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/layer.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -37,19 +37,19 @@
 Layer::draw(EditorMapComponent* parent, CL_GraphicContext* gc) 
 { 
   if (impl.get())
+  {
+    if (impl->pos.x != 0 || impl->pos.y != 0)
     {
-      if (impl->pos.x != 0 || impl->pos.y != 0)
-        {
-          gc->push_modelview();
-          gc->add_translate(impl->pos.x, impl->pos.y);
-          impl->draw(parent, gc);
-          gc->pop_modelview();
-        }
-      else
-        {
-          impl->draw(parent, gc);
-        }
+      gc->push_modelview();
+      gc->add_translate(impl->pos.x, impl->pos.y);
+      impl->draw(parent, gc);
+      gc->pop_modelview();
     }
+    else
+    {
+      impl->draw(parent, gc);
+    }
+  }
 }
   
 bool
@@ -67,13 +67,13 @@
   CL_Rect rect;
   
   if (impl.get())
-    {
-      rect = impl->get_bounding_rect();
-      rect.left   += static_cast<int>(impl->pos.x);
-      rect.top    += static_cast<int>(impl->pos.y);
-      rect.right  += static_cast<int>(impl->pos.x);
-      rect.bottom += static_cast<int>(impl->pos.y);
-    }
+  {
+    rect = impl->get_bounding_rect();
+    rect.left   += static_cast<int>(impl->pos.x);
+    rect.top    += static_cast<int>(impl->pos.y);
+    rect.right  += static_cast<int>(impl->pos.x);
+    rect.bottom += static_cast<int>(impl->pos.y);
+  }
   
   return rect;
 }

Modified: trunk/flexlay/lib/lispreader.cpp
===================================================================
--- trunk/flexlay/lib/lispreader.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/lispreader.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -73,25 +73,25 @@
 _next_char (lisp_stream_t *stream)
 {
   switch (stream->type)
-    {
+  {
     case LISP_STREAM_FILE :
       return getc(stream->v.file);
 
     case LISP_STREAM_STRING :
-      {
-        char c = stream->v.string.buf[stream->v.string.pos];
+    {
+      char c = stream->v.string.buf[stream->v.string.pos];
 
-        if (c == 0)
-          return EOF;
+      if (c == 0)
+        return EOF;
 
-        ++stream->v.string.pos;
+      ++stream->v.string.pos;
 
-        return c;
-      }
+      return c;
+    }
 
     case LISP_STREAM_ANY:
       return stream->v.any.next_char(stream->v.any.data);
-    }
+  }
 
   throw LispReaderException("_next_char()", __FILE__, __LINE__);
   return EOF;
@@ -101,7 +101,7 @@
 _unget_char (char c, lisp_stream_t *stream)
 {
   switch (stream->type)
-    {
+  {
     case LISP_STREAM_FILE :
       ungetc(c, stream->v.file);
       break;
@@ -116,7 +116,7 @@
 
     default :
       throw LispReaderException("_unget_char()", __FILE__, __LINE__);
-    }
+  }
 }
 
 static int
@@ -129,24 +129,24 @@
   _token_clear();
 
   do
-    {
-      c = _next_char(stream);
-      if (c == EOF)
-        return TOKEN_EOF;
-      else if (c == ';')     	 /* comment start */
-        while (1)
-          {
-            c = _next_char(stream);
-            if (c == EOF)
-              return TOKEN_EOF;
-            else if (c == '\n')
-              break;
-          }
-    }
+  {
+    c = _next_char(stream);
+    if (c == EOF)
+      return TOKEN_EOF;
+    else if (c == ';')           /* comment start */
+      while (1)
+      {
+        c = _next_char(stream);
+        if (c == EOF)
+          return TOKEN_EOF;
+        else if (c == '\n')
+          break;
+      }
+  }
   while (isspace(c));
 
   switch (c)
-    {
+  {
     case '(' :
       return TOKEN_OPEN_PAREN;
 
@@ -155,33 +155,33 @@
 
     case '"' :
       while (1)
+      {
+        c = _next_char(stream);
+        if (c == EOF)
+          return TOKEN_ERROR;
+        if (c == '"')
+          break;
+        if (c == '\\')
         {
           c = _next_char(stream);
-          if (c == EOF)
-            return TOKEN_ERROR;
-          if (c == '"')
-            break;
-          if (c == '\\')
-            {
-              c = _next_char(stream);
 
-              switch (c)
-                {
-                case EOF :
-                  return TOKEN_ERROR;
+          switch (c)
+          {
+            case EOF :
+              return TOKEN_ERROR;
 
-                case 'n' :
-                  c = '\n';
-                  break;
+            case 'n' :
+              c = '\n';
+              break;
 
-                case 't' :
-                  c = '\t';
-                  break;
-                }
-            }
+            case 't' :
+              c = '\t';
+              break;
+          }
+        }
 
-          _token_append(c);
-        }
+        _token_append(c);
+      }
       return TOKEN_STRING;
 
     case '#' :
@@ -190,7 +190,7 @@
         return TOKEN_ERROR;
 
       switch (c)
-        {
+      {
         case 't' :
           return TOKEN_TRUE;
 
@@ -206,67 +206,67 @@
             return TOKEN_PATTERN_OPEN_PAREN;
           else
             return TOKEN_ERROR;
-        }
+      }
       return TOKEN_ERROR;
 
     default :
       if (isdigit(c) || c == '-')
+      {
+        int have_nondigits = 0;
+        int have_digits = 0;
+        int have_floating_point = 0;
+
+        do
         {
-          int have_nondigits = 0;
-          int have_digits = 0;
-          int have_floating_point = 0;
+          if (isdigit(c))
+            have_digits = 1;
+          else if (c == '.')
+            have_floating_point++;
+          _token_append(c);
 
-          do
-            {
-              if (isdigit(c))
-                have_digits = 1;
-              else if (c == '.')
-                have_floating_point++;
-              _token_append(c);
+          c = _next_char(stream);
 
-              c = _next_char(stream);
+          if (c != EOF && !isdigit(c) && !isspace(c) && c != '.' && !strchr(delims, c))
+            have_nondigits = 1;
+        }
+        while (c != EOF && !isspace(c) && !strchr(delims, c));
 
-              if (c != EOF && !isdigit(c) && !isspace(c) && c != '.' && !strchr(delims, c))
-                have_nondigits = 1;
-            }
-          while (c != EOF && !isspace(c) && !strchr(delims, c));
+        if (c != EOF)
+          _unget_char(c, stream);
 
-          if (c != EOF)
-            _unget_char(c, stream);
-
-          if (have_nondigits || !have_digits || have_floating_point > 1)
-            return TOKEN_SYMBOL;
-          else if (have_floating_point == 1)
-            return TOKEN_REAL;
-          else
-            return TOKEN_INTEGER;
-        }
+        if (have_nondigits || !have_digits || have_floating_point > 1)
+          return TOKEN_SYMBOL;
+        else if (have_floating_point == 1)
+          return TOKEN_REAL;
+        else
+          return TOKEN_INTEGER;
+      }
       else
+      {
+        if (c == '.')
         {
-          if (c == '.')
-            {
-              c = _next_char(stream);
-              if (c != EOF && !isspace(c) && !strchr(delims, c))
-                _token_append('.');
-              else
-                {
-                  _unget_char(c, stream);
-                  return TOKEN_DOT;
-                }
-            }
-          do
-            {
-              _token_append(c);
-              c = _next_char(stream);
-            }
-          while (c != EOF && !isspace(c) && !strchr(delims, c));
-          if (c != EOF)
+          c = _next_char(stream);
+          if (c != EOF && !isspace(c) && !strchr(delims, c))
+            _token_append('.');
+          else
+          {
             _unget_char(c, stream);
-
-          return TOKEN_SYMBOL;
+            return TOKEN_DOT;
+          }
         }
-    }
+        do
+        {
+          _token_append(c);
+          c = _next_char(stream);
+        }
+        while (c != EOF && !isspace(c) && !strchr(delims, c));
+        if (c != EOF)
+          _unget_char(c, stream);
 
+        return TOKEN_SYMBOL;
+      }
+  }
+
   throw LispReaderException("_scan()", __FILE__, __LINE__);
   return TOKEN_ERROR;
 }
@@ -410,7 +410,7 @@
     return &end_marker;
 
   switch (token)
-    {
+  {
     case TOKEN_ERROR :
       return &error_object;
 
@@ -419,55 +419,55 @@
 
     case TOKEN_OPEN_PAREN :
     case TOKEN_PATTERN_OPEN_PAREN :
+    {
+      lisp_object_t *last = lisp_nil(), *car;
+
+      do
       {
-        lisp_object_t *last = lisp_nil(), *car;
+        car = lisp_read(in);
+        if (car == &error_object || car == &end_marker)
+        {
+          lisp_free(obj);
+          return &error_object;
+        }
+        else if (car == &dot_marker)
+        {
+          if (lisp_nil_p(last))
+          {
+            lisp_free(obj);
+            return &error_object;
+          }
 
-        do
+          car = lisp_read(in);
+          if (car == &error_object || car == &end_marker)
           {
-            car = lisp_read(in);
-            if (car == &error_object || car == &end_marker)
-              {
-                lisp_free(obj);
-                return &error_object;
-              }
-            else if (car == &dot_marker)
-              {
-                if (lisp_nil_p(last))
-                  {
-                    lisp_free(obj);
-                    return &error_object;
-                  }
+            lisp_free(obj);
+            return car;
+          }
+          else
+          {
+            last->v.cons.cdr = car;
 
-                car = lisp_read(in);
-                if (car == &error_object || car == &end_marker)
-                  {
-                    lisp_free(obj);
-                    return car;
-                  }
-                else
-                  {
-                    last->v.cons.cdr = car;
+            if (_scan(in) != TOKEN_CLOSE_PAREN)
+            {
+              lisp_free(obj);
+              return &error_object;
+            }
 
-                    if (_scan(in) != TOKEN_CLOSE_PAREN)
-                      {
-                        lisp_free(obj);
-                        return &error_object;
-                      }
-
-                    car = &close_paren_marker;
-                  }
-              }
-            else if (car != &close_paren_marker)
-              {
-                if (lisp_nil_p(last))
-                  obj = last = (token == TOKEN_OPEN_PAREN ? lisp_make_cons(car, lisp_nil()) : lisp_make_pattern_cons(car, lisp_nil()));
-                else
-                  last = last->v.cons.cdr = lisp_make_cons(car, lisp_nil());
-              }
+            car = &close_paren_marker;
           }
-        while (car != &close_paren_marker);
+        }
+        else if (car != &close_paren_marker)
+        {
+          if (lisp_nil_p(last))
+            obj = last = (token == TOKEN_OPEN_PAREN ? lisp_make_cons(car, lisp_nil()) : lisp_make_pattern_cons(car, lisp_nil()));
+          else
+            last = last->v.cons.cdr = lisp_make_cons(car, lisp_nil());
+        }
       }
-      return obj;
+      while (car != &close_paren_marker);
+    }
+    return obj;
 
     case TOKEN_CLOSE_PAREN :
       return &close_paren_marker;
@@ -492,7 +492,7 @@
 
     case TOKEN_FALSE :
       return lisp_make_boolean(0);
-    }
+  }
 
   throw LispReaderException("lisp_read()", __FILE__, __LINE__);
   return &error_object;
@@ -505,7 +505,7 @@
     return;
 
   switch (obj->type)
-    {
+  {
     case LISP_TYPE_INTERNAL :
     case LISP_TYPE_PARSE_ERROR :
     case LISP_TYPE_EOF :
@@ -525,7 +525,7 @@
     case LISP_TYPE_PATTERN_VAR :
       lisp_free(obj->v.pattern.sub);
       break;
-    }
+  }
 
   free(obj);
 }
@@ -546,73 +546,73 @@
     return 1;
 
   switch (lisp_type(*obj))
+  {
+    case LISP_TYPE_PATTERN_CONS :
     {
-    case LISP_TYPE_PATTERN_CONS :
+      struct
       {
-        struct
-          {
-            char *name;
-            int type;
-          }
-        types[] =
-          {
-            { "any", LISP_PATTERN_ANY },
-            { "symbol", LISP_PATTERN_SYMBOL },
-            { "string", LISP_PATTERN_STRING },
-            { "integer", LISP_PATTERN_INTEGER },
-            { "real", LISP_PATTERN_REAL },
-            { "boolean", LISP_PATTERN_BOOLEAN },
-            { "list", LISP_PATTERN_LIST },
-            { "or", LISP_PATTERN_OR },
-            { 0, 0 }
-          };
-        char *type_name;
+        char *name;
         int type;
-        int i;
-        lisp_object_t *pattern;
-        type = -1;
-	
-        if (lisp_type(lisp_car(*obj)) != LISP_TYPE_SYMBOL)
-          return 0;
+      }
+      types[] =
+        {
+          { "any", LISP_PATTERN_ANY },
+          { "symbol", LISP_PATTERN_SYMBOL },
+          { "string", LISP_PATTERN_STRING },
+          { "integer", LISP_PATTERN_INTEGER },
+          { "real", LISP_PATTERN_REAL },
+          { "boolean", LISP_PATTERN_BOOLEAN },
+          { "list", LISP_PATTERN_LIST },
+          { "or", LISP_PATTERN_OR },
+          { 0, 0 }
+        };
+      char *type_name;
+      int type;
+      int i;
+      lisp_object_t *pattern;
+      type = -1;
+        
+      if (lisp_type(lisp_car(*obj)) != LISP_TYPE_SYMBOL)
+        return 0;
 
-        type_name = lisp_symbol(lisp_car(*obj));
-        for (i = 0; types[i].name != 0; ++i)
-          {
-            if (strcmp(types[i].name, type_name) == 0)
-              {
-                type = types[i].type;
-                break;
-              }
-          }
+      type_name = lisp_symbol(lisp_car(*obj));
+      for (i = 0; types[i].name != 0; ++i)
+      {
+        if (strcmp(types[i].name, type_name) == 0)
+        {
+          type = types[i].type;
+          break;
+        }
+      }
 
-        if (types[i].name == 0)
-          return 0;
+      if (types[i].name == 0)
+        return 0;
 
-        if (type != LISP_PATTERN_OR && lisp_cdr(*obj) != 0)
-          return 0;
+      if (type != LISP_PATTERN_OR && lisp_cdr(*obj) != 0)
+        return 0;
 
-        pattern = lisp_make_pattern_var(type, (*index)++, lisp_nil());
+      pattern = lisp_make_pattern_var(type, (*index)++, lisp_nil());
 
-        if (type == LISP_PATTERN_OR)
-          {
-            lisp_object_t *cdr = lisp_cdr(*obj);
+      if (type == LISP_PATTERN_OR)
+      {
+        lisp_object_t *cdr = lisp_cdr(*obj);
 
-            if (!_compile_pattern(&cdr, index))
-              {
-                lisp_free(pattern);
-                return 0;
-              }
+        if (!_compile_pattern(&cdr, index))
+        {
+          lisp_free(pattern);
+          return 0;
+        }
 
-            pattern->v.pattern.sub = cdr;
+        pattern->v.pattern.sub = cdr;
 
-            (*obj)->v.cons.cdr = lisp_nil();
-          }
+        (*obj)->v.cons.cdr = lisp_nil();
+      }
 
-        lisp_free(*obj);
+      lisp_free(*obj);
 
-        *obj = pattern;
-      }
-      break;
+      *obj = pattern;
+    }
+    break;
 
     case LISP_TYPE_CONS :
       if (!_compile_pattern(&(*obj)->v.cons.car, index))
@@ -620,7 +620,7 @@
       if (!_compile_pattern(&(*obj)->v.cons.cdr, index))
         return 0;
       break;
-    }
+  }
 
   return 1;
 }
@@ -648,7 +648,7 @@
     throw LispReaderException("_match_pattern_var", __FILE__, __LINE__);
 
   switch (pattern->v.pattern.type)
-    {
+  {
     case LISP_PATTERN_ANY :
       break;
 
@@ -683,27 +683,27 @@
       break;
 
     case LISP_PATTERN_OR :
+    {
+      lisp_object_t *sub;
+      int matched = 0;
+
+      for (sub = pattern->v.pattern.sub; sub != 0; sub = lisp_cdr(sub))
       {
-        lisp_object_t *sub;
-        int matched = 0;
+        if (lisp_type(sub) != LISP_TYPE_CONS)
+          throw LispReaderException("_match_pattern_var()", __FILE__, __LINE__);
 
-        for (sub = pattern->v.pattern.sub; sub != 0; sub = lisp_cdr(sub))
-          {
-            if (lisp_type(sub) != LISP_TYPE_CONS)
-              throw LispReaderException("_match_pattern_var()", __FILE__, __LINE__);
+        if (_match_pattern(lisp_car(sub), obj, vars))
+          matched = 1;
+      }
 
-            if (_match_pattern(lisp_car(sub), obj, vars))
-              matched = 1;
-          }
+      if (!matched)
+        return 0;
+    }
+    break;
 
-        if (!matched)
-          return 0;
-      }
-      break;
-
     default :
       throw LispReaderException("_match_pattern_var()", __FILE__, __LINE__);
-    }
+  }
 
   if (vars != 0)
     vars[pattern->v.pattern.index] = obj;
@@ -727,7 +727,7 @@
     return 0;
 
   switch (lisp_type(pattern))
-    {
+  {
     case LISP_TYPE_SYMBOL :
       return strcmp(lisp_symbol(pattern), lisp_symbol(obj)) == 0;
 
@@ -741,19 +741,19 @@
       return lisp_real(pattern) == lisp_real(obj);
 
     case LISP_TYPE_CONS :
-      {
-        int result1, result2;
+    {
+      int result1, result2;
 
-        result1 = _match_pattern(lisp_car(pattern), lisp_car(obj), vars);
-        result2 = _match_pattern(lisp_cdr(pattern), lisp_cdr(obj), vars);
+      result1 = _match_pattern(lisp_car(pattern), lisp_car(obj), vars);
+      result2 = _match_pattern(lisp_cdr(pattern), lisp_cdr(obj), vars);
 
-        return result1 && result2;
-      }
-      break;
+      return result1 && result2;
+    }
+    break;
 
     default :
       throw LispReaderException("_match_pattern()", __FILE__, __LINE__);
-    }
+  }
 
   return 0;
 }
@@ -784,10 +784,10 @@
     return 0;
 
   if (!lisp_compile_pattern(&pattern, &num_subs))
-    {
-      lisp_free(pattern);
-      return 0;
-    }
+  {
+    lisp_free(pattern);
+    return 0;
+  }
 
   result = lisp_match_pattern(pattern, obj, vars, num_subs);
 
@@ -891,13 +891,13 @@
   int length = 0;
 
   while (obj != 0)
-    {
-      if (obj->type != LISP_TYPE_CONS && obj->type != LISP_TYPE_PATTERN_CONS)
-        throw LispReaderException("lisp_list_length()", __FILE__, __LINE__);
+  {
+    if (obj->type != LISP_TYPE_CONS && obj->type != LISP_TYPE_PATTERN_CONS)
+      throw LispReaderException("lisp_list_length()", __FILE__, __LINE__);
 
-      ++length;
-      obj = obj->v.cons.cdr;
-    }
+    ++length;
+    obj = obj->v.cons.cdr;
+  }
 
   return length;
 }
@@ -906,15 +906,15 @@
 lisp_list_nth_cdr (lisp_object_t *obj, int index)
 {
   while (index > 0)
-    {
-      if (obj == 0)
-        throw LispReaderException("lisp_list_nth_cdr()", __FILE__, __LINE__);
-      if (obj->type != LISP_TYPE_CONS && obj->type != LISP_TYPE_PATTERN_CONS)
-        throw LispReaderException("lisp_list_nth_cdr()", __FILE__, __LINE__);
+  {
+    if (obj == 0)
+      throw LispReaderException("lisp_list_nth_cdr()", __FILE__, __LINE__);
+    if (obj->type != LISP_TYPE_CONS && obj->type != LISP_TYPE_PATTERN_CONS)
+      throw LispReaderException("lisp_list_nth_cdr()", __FILE__, __LINE__);
 
-      --index;
-      obj = obj->v.cons.cdr;
-    }
+    --index;
+    obj = obj->v.cons.cdr;
+  }
 
   return obj;
 }
@@ -934,13 +934,13 @@
 lisp_dump (lisp_object_t *obj, FILE *out)
 {
   if (obj == 0)
-    {
-      fprintf(out, "()");
-      return;
-    }
+  {
+    fprintf(out, "()");
+    return;
+  }
 
   switch (lisp_type(obj))
-    {
+  {
     case LISP_TYPE_EOF :
       fputs("#<eof>", out);
       break;
@@ -962,40 +962,40 @@
       break;
 
     case LISP_TYPE_STRING :
+    {
+      char *p;
+
+      fputc('"', out);
+      for (p = lisp_string(obj); *p != 0; ++p)
       {
-        char *p;
-
-        fputc('"', out);
-        for (p = lisp_string(obj); *p != 0; ++p)
-          {
-            if (*p == '"' || *p == '\\')
-              fputc('\\', out);
-            fputc(*p, out);
-          }
-        fputc('"', out);
+        if (*p == '"' || *p == '\\')
+          fputc('\\', out);
+        fputc(*p, out);
       }
-      break;
+      fputc('"', out);
+    }
+    break;
 
     case LISP_TYPE_CONS :
     case LISP_TYPE_PATTERN_CONS :
       fputs(lisp_type(obj) == LISP_TYPE_CONS ? "(" : "#?(", out);
       while (obj != 0)
+      {
+        lisp_dump(lisp_car(obj), out);
+        obj = lisp_cdr(obj);
+        if (obj != 0)
         {
-          lisp_dump(lisp_car(obj), out);
-          obj = lisp_cdr(obj);
-          if (obj != 0)
-            {
-              if (lisp_type(obj) != LISP_TYPE_CONS
-                  && lisp_type(obj) != LISP_TYPE_PATTERN_CONS)
-                {
-                  fputs(" . ", out);
-                  lisp_dump(obj, out);
-                  break;
-                }
-              else
-                fputc(' ', out);
-            }
+          if (lisp_type(obj) != LISP_TYPE_CONS
+              && lisp_type(obj) != LISP_TYPE_PATTERN_CONS)
+          {
+            fputs(" . ", out);
+            lisp_dump(obj, out);
+            break;
+          }
+          else
+            fputc(' ', out);
         }
+      }
       fputc(')', out);
       break;
 
@@ -1008,13 +1008,13 @@
 
     default :
       throw LispReaderException("lisp_dump()", __FILE__, __LINE__);
-    }
+  }
 }
 
 using namespace std;
 
 LispReader::LispReader (lisp_object_t* l)
-    : lst (l)
+  : lst (l)
 {
   //std::cout << "LispReader: " << std::flush;
   //lisp_dump(lst, stdout);
@@ -1028,25 +1028,25 @@
   lisp_object_t* cursor = lst;
 
   while(!lisp_nil_p(cursor))
+  {
+    lisp_object_t* cur = lisp_car(cursor);
+
+    if (!lisp_cons_p(cur) || !lisp_symbol_p (lisp_car(cur)))
     {
-      lisp_object_t* cur = lisp_car(cursor);
+      lisp_dump(cur, stdout);
+      //throw ConstruoError (std::string("LispReader: Read error in search_for ") + name);
+      printf("LispReader: Read error in search\n");
+    }
+    else
+    {
+      if (strcmp(lisp_symbol(lisp_car(cur)), name) == 0)
+      {
+        return lisp_cdr(cur);
+      }
+    }
 
-      if (!lisp_cons_p(cur) || !lisp_symbol_p (lisp_car(cur)))
-        {
-          lisp_dump(cur, stdout);
-          //throw ConstruoError (std::string("LispReader: Read error in search_for ") + name);
-	  printf("LispReader: Read error in search\n");
-        }
-      else
-        {
-          if (strcmp(lisp_symbol(lisp_car(cur)), name) == 0)
-            {
-              return lisp_cdr(cur);
-            }
-        }
-
-      cursor = lisp_cdr (cursor);
-    }
+    cursor = lisp_cdr (cursor);
+  }
   return 0;
 }
 
@@ -1055,15 +1055,15 @@
 {
   lisp_object_t* obj = search_for (name);
   if (obj)
+  {
+    if (!lisp_integer_p(lisp_car(obj)))
     {
-      if (!lisp_integer_p(lisp_car(obj)))
-      {
-        //st_abort("LispReader expected type integer at token: ", name); /* Instead of giving up, we return with false now. */
-	return false;
-	}
-      *i = lisp_integer(lisp_car(obj));
-      return true;
+      //st_abort("LispReader expected type integer at token: ", name); /* Instead of giving up, we return with false now. */
+      return false;
     }
+    *i = lisp_integer(lisp_car(obj));
+    return true;
+  }
   return false;
 }
 
@@ -1072,10 +1072,10 @@
 {
   lisp_object_t* obj = search_for (name);
   if (obj)
-    {
-      *b = obj;
-      return true;
-    }
+  {
+    *b = obj;
+    return true;
+  }
   else
     return false;
 }
@@ -1085,13 +1085,13 @@
 {
   lisp_object_t* obj = search_for (name);
   if (obj)
-    {
-      if (!lisp_real_p(lisp_car(obj)) && !lisp_integer_p(lisp_car(obj)))
-        throw LispReaderException("LispReader expected type real at token: ",
-                                  __FILE__, __LINE__);
-      *f = lisp_real(lisp_car(obj));
-      return true;
-    }
+  {
+    if (!lisp_real_p(lisp_car(obj)) && !lisp_integer_p(lisp_car(obj)))
+      throw LispReaderException("LispReader expected type real at token: ",
+                                __FILE__, __LINE__);
+    *f = lisp_real(lisp_car(obj));
+    return true;
+  }
   return false;
 }
 
@@ -1100,16 +1100,16 @@
 {
   lisp_object_t* obj = search_for (name);
   if (obj)
+  {
+    while(!lisp_nil_p(obj))
     {
-      while(!lisp_nil_p(obj))
-        {
-          if (!lisp_string_p(lisp_car(obj)))
-            throw LispReaderException("LispReader expected type string at token: ", name);
-          vec->push_back(lisp_string(lisp_car(obj)));
-          obj = lisp_cdr(obj);
-        }
-      return true;
+      if (!lisp_string_p(lisp_car(obj)))
+        throw LispReaderException("LispReader expected type string at token: ", name);
+      vec->push_back(lisp_string(lisp_car(obj)));
+      obj = lisp_cdr(obj);
     }
+    return true;
+  }
   return false;    
 }
 
@@ -1118,16 +1118,16 @@
 {
   lisp_object_t* obj = search_for (name);
   if (obj)
+  {
+    while(!lisp_nil_p(obj))
     {
-      while(!lisp_nil_p(obj))
-        {
-          if (!lisp_integer_p(lisp_car(obj)))
-            throw LispReaderException("LispReader expected type integer at token: ", name);
-          vec->push_back(lisp_integer(lisp_car(obj)));
-          obj = lisp_cdr(obj);
-        }
-      return true;
+      if (!lisp_integer_p(lisp_car(obj)))
+        throw LispReaderException("LispReader expected type integer at token: ", name);
+      vec->push_back(lisp_integer(lisp_car(obj)));
+      obj = lisp_cdr(obj);
     }
+    return true;
+  }
   return false;    
 }
 
@@ -1136,14 +1136,14 @@
 {
   lisp_object_t* obj = search_for (name);
   if (obj)
+  {
+    while(!lisp_nil_p(obj))
     {
-      while(!lisp_nil_p(obj))
-        {
-          vec->push_back(*lisp_string(lisp_car(obj)));
-          obj = lisp_cdr(obj);
-        }
-      return true;
+      vec->push_back(*lisp_string(lisp_car(obj)));
+      obj = lisp_cdr(obj);
     }
+    return true;
+  }
   return false;    
 }
 
@@ -1152,12 +1152,12 @@
 {
   lisp_object_t* obj = search_for (name);
   if (obj)
-    {
-      if (!lisp_string_p(lisp_car(obj)))
-        throw LispReaderException("LispReader expected type string at token: ", name);
-     *str = lisp_string(lisp_car(obj));
-      return true;
-    }
+  {
+    if (!lisp_string_p(lisp_car(obj)))
+      throw LispReaderException("LispReader expected type string at token: ", name);
+    *str = lisp_string(lisp_car(obj));
+    return true;
+  }
   return false;  
 }
 
@@ -1166,12 +1166,12 @@
 {
   lisp_object_t* obj = search_for (name);
   if (obj)
-    {
-      if (!lisp_boolean_p(lisp_car(obj)))
-        throw LispReaderException("LispReader expected type bool at token: ");
-      *b = lisp_boolean(lisp_car(obj));
-      return true;
-    }
+  {
+    if (!lisp_boolean_p(lisp_car(obj)))
+      throw LispReaderException("LispReader expected type bool at token: ");
+    *b = lisp_boolean(lisp_car(obj));
+    return true;
+  }
   return false;
 }
 
@@ -1247,9 +1247,9 @@
 
   for(std::vector<lisp_object_t*>::reverse_iterator i = lisp_objs.rbegin ();
       i != lisp_objs.rend (); ++i)
-    {
-      lisp_obj = lisp_make_cons (*i, lisp_obj);
-    }
+  {
+    lisp_obj = lisp_make_cons (*i, lisp_obj);
+  }
   lisp_objs.clear();
 
   return lisp_obj;
@@ -1281,28 +1281,28 @@
   gzFile in = gzopen(filename, "r");
 
   while (!done)
+  {
+    int ret = gzread(in, buf + buf_pos, chunk_size);
+    if (ret == -1)
     {
-      int ret = gzread(in, buf + buf_pos, chunk_size);
-      if (ret == -1)
-        {
-          free (buf);
-          throw LispReaderException("Error while reading from file", __FILE__, __LINE__);
-        }
-      else if (ret == chunk_size) // buffer got full, eof not yet there so resize
-        {
-          buf_pos = chunk_size * try_number;
-          try_number += 1;
-          buf = static_cast<char*>(realloc(buf, chunk_size * try_number));
+      free (buf);
+      throw LispReaderException("Error while reading from file", __FILE__, __LINE__);
+    }
+    else if (ret == chunk_size) // buffer got full, eof not yet there so resize
+    {
+      buf_pos = chunk_size * try_number;
+      try_number += 1;
+      buf = static_cast<char*>(realloc(buf, chunk_size * try_number));
 
-          if (!buf)
-            throw LispReaderException("lisp_read_from_gzfile()", __FILE__, __LINE__);
-        }
-      else 
-        {
-          // everything fine, encountered EOF 
-          done = true;
-        }
+      if (!buf)
+        throw LispReaderException("lisp_read_from_gzfile()", __FILE__, __LINE__);
     }
+    else 
+    {
+      // everything fine, encountered EOF 
+      done = true;
+    }
+  }
       
   lisp_stream_t stream;
   lisp_stream_init_string (&stream, buf);
@@ -1322,13 +1322,13 @@
   const char* data_suffix = (data + data_len - suffix_len);
 
   if (data_suffix >= data)
-    {
-      return (strcmp(data_suffix, suffix) == 0);
-    }
+  {
+    return (strcmp(data_suffix, suffix) == 0);
+  }
   else
-    {
-      return false;
-    }
+  {
+    return false;
+  }
 }
 
 lisp_object_t* lisp_read_from_file(const std::string& filename)
@@ -1336,23 +1336,23 @@
   lisp_stream_t stream;
 
   if (has_suffix(filename.c_str(), ".gz"))
+  {
+    return lisp_read_from_gzfile(filename.c_str());
+  }
+  else
+  {
+    lisp_object_t* obj = 0;
+    FILE* in = fopen(filename.c_str(), "r");
+
+    if (in)
     {
-      return lisp_read_from_gzfile(filename.c_str());
+      lisp_stream_init_file(&stream, in);
+      obj = lisp_read(&stream);
+      fclose(in);
     }
-  else
-    {
-      lisp_object_t* obj = 0;
-      FILE* in = fopen(filename.c_str(), "r");
 
-      if (in)
-        {
-          lisp_stream_init_file(&stream, in);
-          obj = lisp_read(&stream);
-          fclose(in);
-        }
-
-      return obj;
-    }
+    return obj;
+  }
 }
 
 // EOF //

Modified: trunk/flexlay/lib/lispreader.hpp
===================================================================
--- trunk/flexlay/lib/lispreader.hpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/lispreader.hpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -58,19 +58,19 @@
 
 class LispReaderException : public std::exception
 {
-  public:
-    LispReaderException(const char* _message, const char* _file = "", const unsigned int _line = 0)
-      : message(_message), file(_file), line(_line) { };
-    virtual ~LispReaderException() throw() { };
+public:
+  LispReaderException(const char* _message, const char* _file = "", const unsigned int _line = 0)
+    : message(_message), file(_file), line(_line) { };
+  virtual ~LispReaderException() throw() { };
 
-    const char* what() const throw() { return message; };
-    const char* what_file() const throw() { return file; };
-    const unsigned int what_line() const throw() { return line; };
+  const char* what() const throw() { return message; };
+  const char* what_file() const throw() { return file; };
+  const unsigned int what_line() const throw() { return line; };
     
-  private:
-    const char* message;
-    const char* file;
-    const unsigned int line;
+private:
+  const char* message;
+  const char* file;
+  const unsigned int line;
 };
 
 typedef struct
@@ -85,17 +85,17 @@
       char *buf;
       int pos;
     }
-    string;
+      string;
     struct
     {
       void *data;
       int (*next_char) (void *data);
       void (*unget_char) (char c, void *data);
     }
-    any;
+      any;
   } v;
 }
-lisp_stream_t;
+  lisp_stream_t;
 
 typedef struct _lisp_object_t lisp_object_t;
 struct _lisp_object_t
@@ -109,7 +109,7 @@
       struct _lisp_object_t *car;
       struct _lisp_object_t *cdr;
     }
-    cons;
+      cons;
 
     char *string;
     int integer;
@@ -121,7 +121,7 @@
       int index;
       struct _lisp_object_t *sub;
     }
-    pattern;
+      pattern;
   } v;
 };
 

Modified: trunk/flexlay/lib/marker_stroke_drawer.cpp
===================================================================
--- trunk/flexlay/lib/marker_stroke_drawer.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/marker_stroke_drawer.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -38,75 +38,75 @@
                                                             DrawerProperties::current()->get_spacing());
 
     if (dabs.size() >= 2)
+    {
+      std::vector<CL_Pointf> normals;
+        
+      if (stroke.get_dab_count() == 2)
       {
-        std::vector<CL_Pointf> normals;
-        
-        if (stroke.get_dab_count() == 2)
-          {
-            normals.push_back(CL_Pointf(1.0f, 1.0f));
-            normals.push_back(CL_Pointf(1.0f, 1.0f));
-          }
-        else if (stroke.get_dab_count() >= 3)
-          {
-            for(Stroke::Dabs::size_type i = 0; i < dabs.size()-1; ++i)
-              {
-                CL_Pointf normal((dabs[i].pos.y - dabs[i+1].pos.y),
-                                 -(dabs[i].pos.x - dabs[i+1].pos.x));
+        normals.push_back(CL_Pointf(1.0f, 1.0f));
+        normals.push_back(CL_Pointf(1.0f, 1.0f));
+      }
+      else if (stroke.get_dab_count() >= 3)
+      {
+        for(Stroke::Dabs::size_type i = 0; i < dabs.size()-1; ++i)
+        {
+          CL_Pointf normal((dabs[i].pos.y - dabs[i+1].pos.y),
+                           -(dabs[i].pos.x - dabs[i+1].pos.x));
 
-                float length = sqrt(normal.x * normal.x + normal.y * normal.y);
+          float length = sqrt(normal.x * normal.x + normal.y * normal.y);
 
-                normal.x /= length;
-                normal.y /= length;
+          normal.x /= length;
+          normal.y /= length;
           
-                normals.push_back(normal);
-              }
+          normals.push_back(normal);
+        }
       
-            normals.push_back(CL_Pointf(1.0f, 1.0f));
-          }
+        normals.push_back(CL_Pointf(1.0f, 1.0f));
+      }
 
-        float len  = DrawerProperties::current()->get_size() * 8.0f;
-        float len2 = DrawerProperties::current()->get_size() * 16.0f;
+      float len  = DrawerProperties::current()->get_size() * 8.0f;
+      float len2 = DrawerProperties::current()->get_size() * 16.0f;
             
-        glEnable(GL_BLEND);
-        glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );
+      glEnable(GL_BLEND);
+      glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );
 
-        glBegin(GL_QUAD_STRIP);
-        for(unsigned int j = 0; j < dabs.size()-2; ++j)
-          {
-            glColor4ub(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
-            glVertex2f(dabs[j].pos.x + normals[j].x * len,
-                       dabs[j].pos.y + normals[j].y * len);
+      glBegin(GL_QUAD_STRIP);
+      for(unsigned int j = 0; j < dabs.size()-2; ++j)
+      {
+        glColor4ub(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
+        glVertex2f(dabs[j].pos.x + normals[j].x * len,
+                   dabs[j].pos.y + normals[j].y * len);
 
-            glColor4ub(color.get_red(), color.get_green(), color.get_blue(), 0);
-            glVertex2f(dabs[j].pos.x + normals[j].x * len2,
-                       dabs[j].pos.y + normals[j].y * len2);
-          }
-        glEnd();
+        glColor4ub(color.get_red(), color.get_green(), color.get_blue(), 0);
+        glVertex2f(dabs[j].pos.x + normals[j].x * len2,
+                   dabs[j].pos.y + normals[j].y * len2);
+      }
+      glEnd();
 
-        glBegin(GL_QUAD_STRIP);
-        for(unsigned int j = 0; j < dabs.size()-2; ++j)
-          {
-            glColor4ub(color.get_red(), color.get_green(), color.get_blue(), 0);
-            glVertex2f(dabs[j].pos.x - normals[j].x * len2,
-                       dabs[j].pos.y - normals[j].y * len2);
+      glBegin(GL_QUAD_STRIP);
+      for(unsigned int j = 0; j < dabs.size()-2; ++j)
+      {
+        glColor4ub(color.get_red(), color.get_green(), color.get_blue(), 0);
+        glVertex2f(dabs[j].pos.x - normals[j].x * len2,
+                   dabs[j].pos.y - normals[j].y * len2);
 
-            glColor4ub(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
-            glVertex2f(dabs[j].pos.x - normals[j].x * len,
-                       dabs[j].pos.y - normals[j].y * len);
-          }
-        glEnd();
-
-        glBegin(GL_QUAD_STRIP);
         glColor4ub(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
-        for(unsigned int j = 0; j < dabs.size()-2; ++j)
-          {
-            glVertex2f(dabs[j].pos.x + normals[j].x * len,
-                       dabs[j].pos.y + normals[j].y * len);
-            glVertex2f(dabs[j].pos.x - normals[j].x * len,
-                       dabs[j].pos.y - normals[j].y * len);
-          }
-        glEnd();
+        glVertex2f(dabs[j].pos.x - normals[j].x * len,
+                   dabs[j].pos.y - normals[j].y * len);
       }
+      glEnd();
+
+      glBegin(GL_QUAD_STRIP);
+      glColor4ub(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
+      for(unsigned int j = 0; j < dabs.size()-2; ++j)
+      {
+        glVertex2f(dabs[j].pos.x + normals[j].x * len,
+                   dabs[j].pos.y + normals[j].y * len);
+        glVertex2f(dabs[j].pos.x - normals[j].x * len,
+                   dabs[j].pos.y - normals[j].y * len);
+      }
+      glEnd();
+    }
   }
 
   StrokeDrawerImpl* clone() const 

Modified: trunk/flexlay/lib/menu.cpp
===================================================================
--- trunk/flexlay/lib/menu.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/menu.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -113,9 +113,9 @@
       CL_Display::fill_rect(CL_Rect(CL_Point(x, y-2), CL_Size(parent->get_width() - 7, 18)), 
                             CL_Color(255, 255, 255));
     if (sprite)
-      {
-        sprite.draw(x+10, y+7);
-      }
+    {
+      sprite.draw(x+10, y+7);
+    }
     Fonts::verdana11.draw(x+24, y, text);
   }
   int get_width()  { return Fonts::verdana11.bounding_rect(0, 0, text).get_width() + 16; }
@@ -212,13 +212,13 @@
   int y_pos = 6;
 
   for(int i = 0; i < int(items.size()); ++i)
-    {
-      if (i == current_item)
-        items[i]->draw(x_pos, y_pos, true);
-      else
-        items[i]->draw(x_pos, y_pos, false);
-      y_pos += items[i]->get_height() + 6;
-    }
+  {
+    if (i == current_item)
+      items[i]->draw(x_pos, y_pos, true);
+    else
+      items[i]->draw(x_pos, y_pos, false);
+    y_pos += items[i]->get_height() + 6;
+  }
   CL_Display::pop_modelview();
 }
 
@@ -238,9 +238,9 @@
 MenuImpl::on_mouse_down(const CL_InputEvent& event)
 {
   if (current_item != -1)
-    {
-      items[current_item]->sig_clicked()();
-    }
+  {
+    items[current_item]->sig_clicked()();
+  }
   parent->release_mouse();
   parent->show(false);
 }
@@ -249,24 +249,24 @@
 MenuImpl::on_mouse_move(const CL_InputEvent& event)
 {
   if (parent->has_mouse_over())
+  {
+    int y_pos = 6;
+
+    for(int i = 0; i < int(items.size()); ++i)
     {
-      int y_pos = 6;
-
-      for(int i = 0; i < int(items.size()); ++i)
-        {
-          y_pos += items[i]->get_height() + 6;      
-          if (y_pos > event.mouse_pos.y)
-            {
-              current_item = i;
-              return;
-            }
-        }
-      current_item = -1;
+      y_pos += items[i]->get_height() + 6;      
+      if (y_pos > event.mouse_pos.y)
+      {
+        current_item = i;
+        return;
+      }
     }
+    current_item = -1;
+  }
   else
-    {
-      current_item = -1;
-    }
+  {
+    current_item = -1;
+  }
 }
 
 CL_Signal_v0&
@@ -280,11 +280,11 @@
 {
   // FIXME: Make menu act sane on == 0 items
   if (impl->items.size() > 0)
-    {
-      show(true);
-      capture_mouse();
-      raise();
-    }
+  {
+    show(true);
+    capture_mouse();
+    raise();
+  }
 }
 
 /* EOF */

Modified: trunk/flexlay/lib/minimap.cpp
===================================================================
--- trunk/flexlay/lib/minimap.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/minimap.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -73,65 +73,65 @@
   // FIXME: Do this only on map changes
   if (impl->last_serial != impl->parent->get_workspace().get_map().get_serial())
     //      || editor_map != parent->get_workspace().get_map())
-    {
-      impl->update_minimap_surface();
-      impl->last_serial = impl->parent->get_workspace().get_map().get_serial();
-      impl->editor_map  = impl->parent->get_workspace().get_map();
-    }
+  {
+    impl->update_minimap_surface();
+    impl->last_serial = impl->parent->get_workspace().get_map().get_serial();
+    impl->editor_map  = impl->parent->get_workspace().get_map();
+  }
 
   if (1)
-    { // Draw background color
-      CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
-                                    CL_Size(get_width(),
-                                            get_height())),
-                            CL_Color(200, 200, 200, 225));
-    }
+  { // Draw background color
+    CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
+                                  CL_Size(get_width(),
+                                          get_height())),
+                          CL_Color(200, 200, 200, 225));
+  }
 
   // FIXME: This doesn't work all that well
   TilemapLayer tilemap = TilemapLayer::current();
 
   if (!tilemap.is_null() && tilemap.get_height() != 0 && tilemap.get_width() != 0)
-    {
-      int tile_size = tilemap.get_tileset().get_tile_size();
+  {
+    int tile_size = tilemap.get_tileset().get_tile_size();
 
-      int map_width  = tilemap.get_width()  * tile_size;
-      int map_height = tilemap.get_height() * tile_size;
+    int map_width  = tilemap.get_width()  * tile_size;
+    int map_height = tilemap.get_height() * tile_size;
 
-      CL_Size small_tile(tile_size * get_width() / map_width + 1,
-                         tile_size * get_height() / map_height + 1);
+    CL_Size small_tile(tile_size * get_width() / map_width + 1,
+                       tile_size * get_height() / map_height + 1);
 
-      Field<int>* field = tilemap.get_field();
+    Field<int>* field = tilemap.get_field();
 
-      // FIXME: No current tileset
-      if (0)
+    // FIXME: No current tileset
+    if (0)
+    {
+      for(int y = 0; y < field->get_height(); ++y)
+        for(int x = 0; x < field->get_width(); ++x)
         {
-          for(int y = 0; y < field->get_height(); ++y)
-            for(int x = 0; x < field->get_width(); ++x)
-              {
-                Tile* tile = tilemap.get_tileset().create(field->at(x, y));
-                if (tile)
-                  CL_Display::fill_rect(CL_Rect(CL_Point((x * tile_size) * get_width() / map_width,
-                                                         (y * tile_size) * get_height() / map_height),
-                                                small_tile),
-                                        tile->get_color());
-                CL_Display::flush();
-              }
+          Tile* tile = tilemap.get_tileset().create(field->at(x, y));
+          if (tile)
+            CL_Display::fill_rect(CL_Rect(CL_Point((x * tile_size) * get_width() / map_width,
+                                                   (y * tile_size) * get_height() / map_height),
+                                          small_tile),
+                                  tile->get_color());
+          CL_Display::flush();
         }
-      impl->minimap_surface.draw(CL_Rect(CL_Point(0, 0),
-                                   CL_Size(get_width(), get_height())));
-
-      // Draw cursor
-      CL_Rect rect(impl->parent->get_clip_rect());
-      CL_Rect screen_rect(CL_Point(rect.left  * get_width()  / map_width,
-                                   rect.top   * get_height() / map_height),
-                          CL_Size(rect.get_width() * get_width() /map_width,
-                                  rect.get_height()* get_height()/map_height));
-      CL_Display::fill_rect(screen_rect,
-                            CL_Color(255, 255, 0, 50));
-      CL_Display::draw_rect(screen_rect,
-                            CL_Color(0, 0, 0));
     }
+    impl->minimap_surface.draw(CL_Rect(CL_Point(0, 0),
+                                       CL_Size(get_width(), get_height())));
 
+    // Draw cursor
+    CL_Rect rect(impl->parent->get_clip_rect());
+    CL_Rect screen_rect(CL_Point(rect.left  * get_width()  / map_width,
+                                 rect.top   * get_height() / map_height),
+                        CL_Size(rect.get_width() * get_width() /map_width,
+                                rect.get_height()* get_height()/map_height));
+    CL_Display::fill_rect(screen_rect,
+                          CL_Color(255, 255, 0, 50));
+    CL_Display::draw_rect(screen_rect,
+                          CL_Color(0, 0, 0));
+  }
+
   CL_Display::pop_modelview();
   CL_Display::pop_cliprect();
 }
@@ -143,39 +143,39 @@
   TilemapLayer tilemap = TilemapLayer::current();
   
   if (!tilemap.is_null())
-    {
-      Field<int>* field = tilemap.get_field();
+  {
+    Field<int>* field = tilemap.get_field();
 
-      CL_PixelBuffer buffer(tilemap.get_width(), tilemap.get_height(), 
-                            tilemap.get_width()*4, CL_PixelFormat::rgba8888);
+    CL_PixelBuffer buffer(tilemap.get_width(), tilemap.get_height(), 
+                          tilemap.get_width()*4, CL_PixelFormat::rgba8888);
   
-      int map_width  = tilemap.get_width();
-      int map_height = tilemap.get_height();
+    int map_width  = tilemap.get_width();
+    int map_height = tilemap.get_height();
 
-      // FIXME: No Tileset::current()
-      unsigned char* buf = static_cast<unsigned char*>(buffer.get_data());
-      for(int y = 0; y < map_height; ++y)
-        for(int x = 0; x < map_width; ++x)
-          {
-            Tile* tile = tilemap.get_tileset().create(field->at(x, y));
-            if (tile)
-              {
-                buf[4*(x + y * map_width) + 3] = tile->get_color().get_red();
-                buf[4*(x + y * map_width) + 2] = tile->get_color().get_green();
-                buf[4*(x + y * map_width) + 1] = tile->get_color().get_blue();
-                buf[4*(x + y * map_width) + 0] = tile->get_color().get_alpha();
-              } 
-            else
-              {
-                buf[4*(x + y * map_width) + 0] = 0;
-                buf[4*(x + y * map_width) + 1] = 0;
-                buf[4*(x + y * map_width) + 2] = 0;
-                buf[4*(x + y * map_width) + 3] = 0;
-              }
-          }
+    // FIXME: No Tileset::current()
+    unsigned char* buf = static_cast<unsigned char*>(buffer.get_data());
+    for(int y = 0; y < map_height; ++y)
+      for(int x = 0; x < map_width; ++x)
+      {
+        Tile* tile = tilemap.get_tileset().create(field->at(x, y));
+        if (tile)
+        {
+          buf[4*(x + y * map_width) + 3] = tile->get_color().get_red();
+          buf[4*(x + y * map_width) + 2] = tile->get_color().get_green();
+          buf[4*(x + y * map_width) + 1] = tile->get_color().get_blue();
+          buf[4*(x + y * map_width) + 0] = tile->get_color().get_alpha();
+        } 
+        else
+        {
+          buf[4*(x + y * map_width) + 0] = 0;
+          buf[4*(x + y * map_width) + 1] = 0;
+          buf[4*(x + y * map_width) + 2] = 0;
+          buf[4*(x + y * map_width) + 3] = 0;
+        }
+      }
 
-      minimap_surface = CL_Surface(buffer);
-    }
+    minimap_surface = CL_Surface(buffer);
+  }
 }
 
 void
@@ -184,15 +184,15 @@
   // FIXME: This doesn't work all that well
   TilemapLayer tilemap = TilemapLayer::current();
   if (!tilemap.is_null())
-    {
-      int tile_size  = tilemap.get_tileset().get_tile_size();
-      int map_width  = tilemap.get_width()  * tile_size;
-      int map_height = tilemap.get_height() * tile_size;
+  {
+    int tile_size  = tilemap.get_tileset().get_tile_size();
+    int map_width  = tilemap.get_width()  * tile_size;
+    int map_height = tilemap.get_height() * tile_size;
 
-      if (impl->drag_active)
-        impl->parent->move_to(event.mouse_pos.x * map_width / get_width(),
-                              event.mouse_pos.y * map_height / get_height());
-    }
+    if (impl->drag_active)
+      impl->parent->move_to(event.mouse_pos.x * map_width / get_width(),
+                            event.mouse_pos.y * map_height / get_height());
+  }
 }
 
 void
@@ -201,16 +201,16 @@
   // FIXME: This doesn't work all that well
   TilemapLayer tilemap = TilemapLayer::current();
   if (!tilemap.is_null())
-    {
-      int tile_size  = tilemap.get_tileset().get_tile_size();
-      int map_width  = tilemap.get_width()  * tile_size;
-      int map_height = tilemap.get_height() * tile_size;
+  {
+    int tile_size  = tilemap.get_tileset().get_tile_size();
+    int map_width  = tilemap.get_width()  * tile_size;
+    int map_height = tilemap.get_height() * tile_size;
 
-      impl->parent->move_to(event.mouse_pos.x * map_width / get_width(),
-                            event.mouse_pos.y * map_height / get_height());
-      impl->drag_active = true;
-      capture_mouse();
-    }
+    impl->parent->move_to(event.mouse_pos.x * map_width / get_width(),
+                          event.mouse_pos.y * map_height / get_height());
+    impl->drag_active = true;
+    capture_mouse();
+  }
 }
 
 void
@@ -218,10 +218,10 @@
 {
   TilemapLayer tilemap = TilemapLayer::current();
   if (!tilemap.is_null())
-    {
-      impl->drag_active = false;
-      release_mouse();
-    }
+  {
+    impl->drag_active = false;
+    release_mouse();
+  }
 }
 
 void

Modified: trunk/flexlay/lib/object_add_command.cpp
===================================================================
--- trunk/flexlay/lib/object_add_command.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/object_add_command.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -45,10 +45,10 @@
 }
 
 /*int
-ObjectAddCommand::get_handle() const
-{ 
+  ObjectAddCommand::get_handle() const
+  { 
   return impl->obj->get_handle(); 
-}*/
+  }*/
 
 void
 ObjectAddCommand::add_object(const ObjMapObject& obj)

Modified: trunk/flexlay/lib/object_delete_command.cpp
===================================================================
--- trunk/flexlay/lib/object_delete_command.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/object_delete_command.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -52,9 +52,9 @@
 ObjectDeleteCommandImpl::execute()
 {
   for(Objects::iterator i = objects.begin(); i != objects.end(); ++i)
-    {
-      object_layer.delete_object(*i);
-    }
+  {
+    object_layer.delete_object(*i);
+  }
 }
 
 void
@@ -67,9 +67,9 @@
 ObjectDeleteCommandImpl::undo()
 {
   for(Objects::iterator i = objects.begin(); i != objects.end(); ++i)
-    {
-      object_layer.add_object(*i);
-    }
+  {
+    object_layer.add_object(*i);
+  }
 }
 
 Command

Modified: trunk/flexlay/lib/object_layer.cpp
===================================================================
--- trunk/flexlay/lib/object_layer.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/object_layer.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -54,16 +54,16 @@
 ObjectLayerImpl::draw(EditorMapComponent* parent, CL_GraphicContext* gc)
 {
   for(ObjectLayer::Objects::iterator i = objects.begin(); i != objects.end(); ++i)
-    {
-      // FIXME: Add clipping here
-      if (parent->get_clip_rect().is_overlapped((*i).get_bound_rect()))
-        (*i).draw(gc);
-    }
+  {
+    // FIXME: Add clipping here
+    if (parent->get_clip_rect().is_overlapped((*i).get_bound_rect()))
+      (*i).draw(gc);
+  }
 
   for(ObjectLayer::ControlPoints::iterator i = control_points.begin(); i != control_points.end(); ++i)
-    {
-      (*i).draw(gc);
-    }
+  {
+    (*i).draw(gc);
+  }
 }
 
 ObjMapControlPoint
@@ -72,12 +72,12 @@
   for(ControlPoints::reverse_iterator i = impl->control_points.rbegin(); 
       i != impl->control_points.rend(); 
       ++i)
-    {
-      CL_Rect rect = (*i).get_bound_rect();
+  {
+    CL_Rect rect = (*i).get_bound_rect();
      
-      if (rect.is_inside(CL_Point(click_pos)))
-        return *i;
-    }
+    if (rect.is_inside(CL_Point(click_pos)))
+      return *i;
+  }
   return ObjMapControlPoint(); 
 }
 
@@ -85,12 +85,12 @@
 ObjectLayer::find_object(const CL_Pointf& click_pos)
 {
   for(Objects::reverse_iterator i = impl->objects.rbegin(); i != impl->objects.rend(); ++i)
-    {
-      CL_Rectf rect = (*i).get_bound_rect();
+  {
+    CL_Rectf rect = (*i).get_bound_rect();
      
-      if (rect.is_inside(CL_Point(click_pos)))
-        return *i;
-    }
+    if (rect.is_inside(CL_Point(click_pos)))
+      return *i;
+  }
   return ObjMapObject();
 }
 
@@ -98,13 +98,13 @@
 ObjectLayer::delete_object(const ObjMapObject& obj)
 {
   for(Objects::iterator i = impl->objects.begin(); i != impl->objects.end(); ++i)
+  {
+    if (obj == (*i))
     {
-      if (obj == (*i))
-        {
-          impl->objects.erase(i);
-          break;
-        }
+      impl->objects.erase(i);
+      break;
     }
+  }
 }
 
 ObjectLayer::Objects
@@ -113,13 +113,13 @@
   Objects selection;
 
   for(Objects::iterator i = impl->objects.begin(); i != impl->objects.end(); ++i)
+  {
+    // FIXME:
+    if (rect.is_inside((*i).get_pos()))
     {
-      // FIXME:
-      if (rect.is_inside((*i).get_pos()))
-        {
-          selection.push_back(*i);
-        }
+      selection.push_back(*i);
     }
+  }
   
   return selection;
 }
@@ -159,12 +159,12 @@
 {
   Objects::size_type i;
   for(i = 0; i < impl->objects.size(); ++i)
+  {
+    if (impl->objects[i] == obj)
     {
-      if (impl->objects[i] == obj)
-        {
-          return i;
-        }
+      return i;
     }
+  }
   return -1;
 }
 
@@ -179,9 +179,9 @@
 {
   int i = get_object_index(obj);
   if (i != -1 && impl->objects.size() > 1 && i < int(impl->objects.size())-1)
-    {
-      std::swap(impl->objects[i], impl->objects[i+1]);
-    }
+  {
+    std::swap(impl->objects[i], impl->objects[i+1]);
+  }
 }
 
 void
@@ -189,9 +189,9 @@
 {
   int i = get_object_index(obj);
   if (i != -1 && i > 0)
-    {
-      std::swap(impl->objects[i], impl->objects[i-1]);
-    }
+  {
+    std::swap(impl->objects[i], impl->objects[i-1]);
+  }
 }
 
 /* EOF */

Modified: trunk/flexlay/lib/object_move_command.cpp
===================================================================
--- trunk/flexlay/lib/object_move_command.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/object_move_command.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -72,11 +72,11 @@
   for(ObjectMoveCommandImpl::Objects::iterator i = impl->objects.begin(); 
       i != impl->objects.end();
       ++i)
-    {
-      i->new_pos = i->old_pos + delta;
-      i->obj.set_pos(i->new_pos);
-      i->obj.sig_move()(i->obj);
-    }
+  {
+    i->new_pos = i->old_pos + delta;
+    i->obj.set_pos(i->new_pos);
+    i->obj.sig_move()(i->obj);
+  }
 }
 
 void
@@ -85,9 +85,9 @@
   for(ObjectMoveCommandImpl::Objects::iterator i = objects.begin(); 
       i != objects.end();
       ++i)
-    {
-      i->obj.set_pos(i->new_pos);
-    }  
+  {
+    i->obj.set_pos(i->new_pos);
+  }  
 }
 
 void
@@ -96,9 +96,9 @@
   for(ObjectMoveCommandImpl::Objects::iterator i = objects.begin(); 
       i != objects.end();
       ++i)
-    {
-      i->obj.set_pos(i->old_pos);
-    }
+  {
+    i->obj.set_pos(i->old_pos);
+  }
 }
 
 std::string

Modified: trunk/flexlay/lib/object_selector.cpp
===================================================================
--- trunk/flexlay/lib/object_selector.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/object_selector.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -51,38 +51,38 @@
 ObjectSelector::mouse_up(const CL_InputEvent& event)
 {
   switch(event.id)
+  {
+    case CL_MOUSE_LEFT:
     {
-    case CL_MOUSE_LEFT:
+      if (drag_obj != -1)
       {
-        if (drag_obj != -1)
-          {
-            release_mouse();
+        release_mouse();
       
-            if (!has_mouse_over())
-              {
-                CL_Point screen(event.mouse_pos.x + get_screen_rect().left,
-                                event.mouse_pos.y + get_screen_rect().top);
+        if (!has_mouse_over())
+        {
+          CL_Point screen(event.mouse_pos.x + get_screen_rect().left,
+                          event.mouse_pos.y + get_screen_rect().top);
 
-                CL_Point target(screen.x - EditorMapComponent::current()->get_screen_rect().left,
-                                screen.y - EditorMapComponent::current()->get_screen_rect().top);
+          CL_Point target(screen.x - EditorMapComponent::current()->get_screen_rect().left,
+                          screen.y - EditorMapComponent::current()->get_screen_rect().top);
       
-                // FIXME: Move this to the scripting layer
-                //ObjectAddCommand command(ObjectLayer::current());
+          // FIXME: Move this to the scripting layer
+          //ObjectAddCommand command(ObjectLayer::current());
 
-                //ObjMapObject obj = brushes[drag_obj].to_sprite_object
-                //(EditorMapComponent::current()->screen2world(target)).to_object();
+          //ObjMapObject obj = brushes[drag_obj].to_sprite_object
+          //(EditorMapComponent::current()->screen2world(target)).to_object();
 
-                //command.add_object(obj);
-                //Workspace::current().get_map().execute(command.to_command());
+          //command.add_object(obj);
+          //Workspace::current().get_map().execute(command.to_command());
                 
-                //std::cout << "C++: Calling on_drop" << std::endl;
-                on_drop(brushes[drag_obj], target);
-                //std::cout << "C++: Calling on_drop: done" << std::endl;
-              }
-            drag_obj = -1;
-          }
+          //std::cout << "C++: Calling on_drop" << std::endl;
+          on_drop(brushes[drag_obj], target);
+          //std::cout << "C++: Calling on_drop: done" << std::endl;
+        }
+        drag_obj = -1;
       }
-      break;
+    }
+    break;
 
     case CL_MOUSE_MIDDLE:
       scrolling = false;
@@ -91,23 +91,23 @@
 
     default:
       break;
-    }
+  }
 }
 
 void
 ObjectSelector::mouse_down(const CL_InputEvent& event)
 {
   switch(event.id)
+  {
+    case CL_MOUSE_LEFT:
     {
-    case CL_MOUSE_LEFT:
+      if (mouse_over_tile != -1)
       {
-        if (mouse_over_tile != -1)
-          {
-            drag_obj = mouse_over_tile;
-            capture_mouse();
-          }
+        drag_obj = mouse_over_tile;
+        capture_mouse();
       }
-      break;
+    }
+    break;
       
     case CL_MOUSE_MIDDLE:
       scrolling = true;
@@ -123,16 +123,16 @@
     case CL_MOUSE_WHEEL_DOWN:
       offset += static_cast<int>(obj_height*scale); 
       break;
-    }
+  }
 }
 
 void
 ObjectSelector::mouse_move(const CL_InputEvent& event)
 {
   if (scrolling)
-    {
-      offset = old_offset + (click_pos.y - event.mouse_pos.y);
-    }
+  {
+    offset = old_offset + (click_pos.y - event.mouse_pos.y);
+  }
 
   mouse_pos = event.mouse_pos;
 
@@ -159,43 +159,43 @@
   CL_Display::add_translate(get_screen_x(), get_screen_y());
     
   for(int i = 0; i < (int)brushes.size(); ++i)
-    {
-      int x = i%width;
-      int y = i/width;
+  {
+    int x = i%width;
+    int y = i/width;
 
-      CL_Rectf rect(CL_Pointf(x * obj_width, y * obj_height),
-                    CL_Sizef(obj_width, obj_height));
+    CL_Rectf rect(CL_Pointf(x * obj_width, y * obj_height),
+                  CL_Sizef(obj_width, obj_height));
 
-      CL_Sprite sprite = brushes[i].get_sprite();
-      sprite.set_alignment(origin_center, 0, 0);
-      sprite.set_scale(std::min(1.0f, (float)obj_width/(float)sprite.get_width()),
-                       std::min(1.0f, (float)obj_height/(float)sprite.get_height()));
+    CL_Sprite sprite = brushes[i].get_sprite();
+    sprite.set_alignment(origin_center, 0, 0);
+    sprite.set_scale(std::min(1.0f, (float)obj_width/(float)sprite.get_width()),
+                     std::min(1.0f, (float)obj_height/(float)sprite.get_height()));
         
-      sprite.draw(x * obj_width + obj_width/2, 
-                  y * obj_height + obj_height/2);
+    sprite.draw(x * obj_width + obj_width/2, 
+                y * obj_height + obj_height/2);
         
-      //CL_Display::draw_rect(rect, CL_Color(0,0,0,128));
+    //CL_Display::draw_rect(rect, CL_Color(0,0,0,128));
         
-      if (mouse_over_tile == i && has_mouse_over())
-        {
-          CL_Display::fill_rect(rect, CL_Color(0,0,255, 20));
-        }
+    if (mouse_over_tile == i && has_mouse_over())
+    {
+      CL_Display::fill_rect(rect, CL_Color(0,0,255, 20));
     }
+  }
 
   CL_Display::pop_modelview();
   CL_Display::pop_cliprect();
  
   // Draw drag sprite
   if (drag_obj != -1)
-    {
-      CL_Display::set_cliprect(CL_Rect(CL_Point(0, 0), 
-                                       CL_Size(CL_Display::get_width(),
-                                               CL_Display::get_height())));
+  {
+    CL_Display::set_cliprect(CL_Rect(CL_Point(0, 0), 
+                                     CL_Size(CL_Display::get_width(),
+                                             CL_Display::get_height())));
 
-      CL_Sprite sprite = brushes[drag_obj].get_sprite();
-      sprite.set_alpha(0.5f);
-      sprite.draw(mouse_pos.x + get_screen_x(), mouse_pos.y + get_screen_y());
-    }
+    CL_Sprite sprite = brushes[drag_obj].get_sprite();
+    sprite.set_alpha(0.5f);
+    sprite.draw(mouse_pos.x + get_screen_x(), mouse_pos.y + get_screen_y());
+  }
 }
 
 void

Modified: trunk/flexlay/lib/objmap_object.cpp
===================================================================
--- trunk/flexlay/lib/objmap_object.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/objmap_object.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -39,9 +39,9 @@
 ObjMapObject::set_pos(const CL_Pointf& p) 
 {
   if (impl.get())
-    {
-      impl->pos = p; 
-    }
+  {
+    impl->pos = p; 
+  }
 }
 
 MetaData

Modified: trunk/flexlay/lib/objmap_path_node.cpp
===================================================================
--- trunk/flexlay/lib/objmap_path_node.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/objmap_path_node.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -42,18 +42,18 @@
   gc->fill_rect(CL_Rect(CL_Point(pos) - CL_Point(16,16), CL_Size(32, 32)), 
                 CL_Color(200, 255, 200));
   if (next)
-    {
-      gc->draw_line(static_cast<int>(pos.x), static_cast<int>(pos.y),
-                    static_cast<int>((pos.x + next->pos.x)/2),
-                    static_cast<int>((pos.y+next->pos.y)/2),
-                    CL_Color(255, 255, 0));
+  {
+    gc->draw_line(static_cast<int>(pos.x), static_cast<int>(pos.y),
+                  static_cast<int>((pos.x + next->pos.x)/2),
+                  static_cast<int>((pos.y+next->pos.y)/2),
+                  CL_Color(255, 255, 0));
 
-      gc->draw_line(static_cast<int>((pos.x + next->pos.x)/2), 
-                    static_cast<int>((pos.y+next->pos.y)/2),
-                    static_cast<int>(next->pos.x),
-                    static_cast<int>(next->pos.y), 
-                    CL_Color(255, 0, 0));
-    }
+    gc->draw_line(static_cast<int>((pos.x + next->pos.x)/2), 
+                  static_cast<int>((pos.y+next->pos.y)/2),
+                  static_cast<int>(next->pos.x),
+                  static_cast<int>(next->pos.y), 
+                  CL_Color(255, 0, 0));
+  }
 }
 
 CL_Rectf
@@ -84,16 +84,16 @@
 ObjMapPathNode::connect(ObjMapPathNode next)
 {
   if (next.impl->next != impl.get()) // avoid circular link between two nodes
+  {
+    if (next.impl->prev) // ensure that each node links exactly to one prev and one next node 
     {
-      if (next.impl->prev) // ensure that each node links exactly to one prev and one next node 
-        {
-          next.impl->prev->next = 0;
-          next.impl->prev = 0;
-        }
+      next.impl->prev->next = 0;
+      next.impl->prev = 0;
+    }
 
-      impl->next = next.impl.get();
-      next.impl->prev = impl.get();
-    }
+    impl->next = next.impl.get();
+    next.impl->prev = impl.get();
+  }
 }
 
 ObjMapObject

Modified: trunk/flexlay/lib/objmap_rect_object.cpp
===================================================================
--- trunk/flexlay/lib/objmap_rect_object.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/objmap_rect_object.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -177,12 +177,12 @@
                                              MetaData());
  
   impl->cp_top_right = ObjMapControlPoint(CL_Sprite("resize2", &(Flexlay::current()->resources)), 
-                                             CL_Pointf(),
+                                          CL_Pointf(),
                                           MetaData());
   
   impl->cp_bottom_left = ObjMapControlPoint(CL_Sprite("resize2", &(Flexlay::current()->resources)), 
-                                                   CL_Pointf(),
-                                                   MetaData());
+                                            CL_Pointf(),
+                                            MetaData());
   
   impl->cp_middle_left = ObjMapControlPoint(CL_Sprite("resize_horz", &(Flexlay::current()->resources)), 
                                             CL_Pointf(),

Modified: trunk/flexlay/lib/objmap_sprite_object.cpp
===================================================================
--- trunk/flexlay/lib/objmap_sprite_object.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/objmap_sprite_object.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -74,7 +74,7 @@
   //  if (scale_x > 1.0f && scale_y > 1.0f)
   //    return CL_Rectf(pos - origin - align,
   //                   CL_Sizef(sprite.get_width() * scale_x, sprite.get_height() * scale_y));
-//  else
+  //  else
   return CL_Rectf(pos - origin - align,
                   CL_Sizef(sprite.get_width(), sprite.get_height()));  
 }

Modified: trunk/flexlay/lib/onion_skin_layer.cpp
===================================================================
--- trunk/flexlay/lib/onion_skin_layer.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/onion_skin_layer.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -67,22 +67,22 @@
   impl->surface2 = CL_Surface(CL_PixelBuffer(width/SCALE, height/SCALE, width*4/SCALE, CL_PixelFormat::rgba8888));
 
   try
-    {
-      impl->canvas = new CL_Canvas(impl->surface);
-      impl->canvas->get_gc()->clear(CL_Color(0, 0, 0, 0));
-      impl->canvas->get_gc()->flush();
-      impl->canvas->sync_surface();
+  {
+    impl->canvas = new CL_Canvas(impl->surface);
+    impl->canvas->get_gc()->clear(CL_Color(0, 0, 0, 0));
+    impl->canvas->get_gc()->flush();
+    impl->canvas->sync_surface();
 
-      impl->canvas2 = new CL_Canvas(impl->surface2);
-      impl->canvas2->get_gc()->clear(CL_Color(0, 0, 0, 0));
-      impl->canvas2->get_gc()->flush();
-      impl->canvas2->sync_surface();
-    }
+    impl->canvas2 = new CL_Canvas(impl->surface2);
+    impl->canvas2->get_gc()->clear(CL_Color(0, 0, 0, 0));
+    impl->canvas2->get_gc()->flush();
+    impl->canvas2->sync_surface();
+  }
   catch(CL_Error& err) 
-    {
-      std::cout << "CL_Error: " << err.message << std::endl;
-      throw err;
-    }
+  {
+    std::cout << "CL_Error: " << err.message << std::endl;
+    throw err;
+  }
 }
 
 void
@@ -104,21 +104,21 @@
 {
   impl->canvas->get_gc()->clear(CL_Color(0, 0, 0, 0));
   for (std::vector<EditorMap>::size_type i = 0; i < impl->editormaps.size(); ++i)
-    {
-      impl->canvas2->get_gc()->clear(CL_Color(0, 0, 0, 0));
-      impl->canvas2->get_gc()->push_modelview();
-      impl->canvas2->get_gc()->add_scale(1.0f/SCALE, 1.0f/SCALE);
+  {
+    impl->canvas2->get_gc()->clear(CL_Color(0, 0, 0, 0));
+    impl->canvas2->get_gc()->push_modelview();
+    impl->canvas2->get_gc()->add_scale(1.0f/SCALE, 1.0f/SCALE);
 
-      impl->editormaps[i].draw(EditorMapComponent::current(), impl->canvas2->get_gc());
+    impl->editormaps[i].draw(EditorMapComponent::current(), impl->canvas2->get_gc());
 
-      impl->canvas2->get_gc()->pop_modelview();
+    impl->canvas2->get_gc()->pop_modelview();
 
-      impl->canvas2->sync_surface();
+    impl->canvas2->sync_surface();
 
-      impl->surface2.set_color(impl->color[i]);
-      impl->surface2.draw(0, 0, impl->canvas->get_gc());
-      impl->canvas->sync_surface();
-    }
+    impl->surface2.set_color(impl->color[i]);
+    impl->surface2.draw(0, 0, impl->canvas->get_gc());
+    impl->canvas->sync_surface();
+  }
 }
 
 Layer

Modified: trunk/flexlay/lib/paint_command.cpp
===================================================================
--- trunk/flexlay/lib/paint_command.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/paint_command.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -89,12 +89,12 @@
                points.front().y + brush.get_height());
 
   for(PaintCommandImpl::Points::iterator i = points.begin(); i != points.end(); ++i)
-    {
-      rect.left   = std::min(rect.left,   (*i).x);
-      rect.top    = std::min(rect.top,    (*i).y);
-      rect.right  = std::max(rect.right,  (*i).x + brush.get_width());
-      rect.bottom = std::max(rect.bottom, (*i).y + brush.get_height());
-    }
+  {
+    rect.left   = std::min(rect.left,   (*i).x);
+    rect.top    = std::min(rect.top,    (*i).y);
+    rect.right  = std::max(rect.right,  (*i).x + brush.get_width());
+    rect.bottom = std::max(rect.bottom, (*i).y + brush.get_height());
+  }
   
   pos.x = rect.left;
   pos.y = rect.top;
@@ -130,9 +130,9 @@
 
   s << "_ = PaintCommand(" << &tilemap << ", " << &brush << ")" << std::endl;
   for(PaintCommandImpl::Points::iterator i = points.begin(); i != points.end(); ++i)
-    {
-      s << "_.add_paint(" << i->x << ", " << i->y << ")"  << std::endl;
-    }
+  {
+    s << "_.add_paint(" << i->x << ", " << i->y << ")"  << std::endl;
+  }
   s << "_ = None" << std::endl;
 
   return s.str();

Modified: trunk/flexlay/lib/popup_menu.cpp
===================================================================
--- trunk/flexlay/lib/popup_menu.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/popup_menu.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -37,17 +37,17 @@
 PopupMenu::on_mouse_up(const CL_InputEvent& event)
 {
   if (!menu->has_mouse_over() && !menu->has_mouse_in_submenus())
-    {
-      menu->collapse();
-      // FIXME: *yuck*
-      delete this;
-    }
+  {
+    menu->collapse();
+    // FIXME: *yuck*
+    delete this;
+  }
   else
-    {
-      // FIXME: this should be in the constructor, but doesn't work
-      // there since the menu collapses then instantly
-      menu->set_root_collapsing(true); 
-    }
+  {
+    // FIXME: this should be in the constructor, but doesn't work
+    // there since the menu collapses then instantly
+    menu->set_root_collapsing(true); 
+  }
 }
 
 /* EOF */

Modified: trunk/flexlay/lib/scrollbar.cpp
===================================================================
--- trunk/flexlay/lib/scrollbar.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/scrollbar.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -95,21 +95,21 @@
                         CL_Color(255, 255, 255));
 
   if (orientation == Scrollbar::HORIZONTAL)
-    {
-      float scale = parent->get_width()/(max - min);
-      CL_Display::fill_rect(CL_Rect(CL_Point(int((pos-min-(pagesize/2)) * scale), 2), 
-                                    CL_Size(int(pagesize*scale), 
-                                            parent->get_height()-5)),
-                            CL_Color(0, 0, 0));
-    }
+  {
+    float scale = parent->get_width()/(max - min);
+    CL_Display::fill_rect(CL_Rect(CL_Point(int((pos-min-(pagesize/2)) * scale), 2), 
+                                  CL_Size(int(pagesize*scale), 
+                                          parent->get_height()-5)),
+                          CL_Color(0, 0, 0));
+  }
   else if (orientation == Scrollbar::VERTICAL)
-    {
-      float scale = parent->get_height()/(max - min);
-      CL_Display::fill_rect(CL_Rect(CL_Point(2, int((pos-min-(pagesize/2)) * scale)), 
-                                    CL_Size(parent->get_width()-5,
-                                            int(pagesize*scale))),
-                            CL_Color(0, 0, 0));     
-    }
+  {
+    float scale = parent->get_height()/(max - min);
+    CL_Display::fill_rect(CL_Rect(CL_Point(2, int((pos-min-(pagesize/2)) * scale)), 
+                                  CL_Size(parent->get_width()-5,
+                                          int(pagesize*scale))),
+                          CL_Color(0, 0, 0));     
+  }
 
   CL_Display::draw_rect(rect,
                         CL_Color(155, 155, 155));
@@ -122,51 +122,51 @@
 ScrollbarImpl::on_mouse_up(const CL_InputEvent& event)
 {
   if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed = false;
-      parent->release_mouse();
-    }
+  {
+    pressed = false;
+    parent->release_mouse();
+  }
 }
 
 void
 ScrollbarImpl::on_mouse_down(const CL_InputEvent& event)
 {
   if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed   = true;
-      click_pos = event.mouse_pos;
+  {
+    pressed   = true;
+    click_pos = event.mouse_pos;
       
-      parent->capture_mouse();
+    parent->capture_mouse();
 
-      float scale = ((orientation == Scrollbar::VERTICAL)
-                     ? parent->get_height() : parent->get_width())/(max - min);
-      old_pos = pos * scale;
+    float scale = ((orientation == Scrollbar::VERTICAL)
+                   ? parent->get_height() : parent->get_width())/(max - min);
+    old_pos = pos * scale;
 
-      click_pos.x += parent->get_position().left;
-      click_pos.y += parent->get_position().top;
-    }
+    click_pos.x += parent->get_position().left;
+    click_pos.y += parent->get_position().top;
+  }
 }
 
 void
 ScrollbarImpl::on_mouse_move(const CL_InputEvent& event)
 {
   if(pressed)
-    {
-      CL_Rect rect = parent->get_position();
+  {
+    CL_Rect rect = parent->get_position();
       
-      float scale = ((orientation == Scrollbar::VERTICAL)
-                     ? parent->get_height() : parent->get_width())/(max - min);
+    float scale = ((orientation == Scrollbar::VERTICAL)
+                   ? parent->get_height() : parent->get_width())/(max - min);
       
-      if (orientation == Scrollbar::VERTICAL)
-        {
-          pos = (old_pos - (click_pos.y - (rect.top + event.mouse_pos.y)))/scale;
-        }
-      else if (orientation == Scrollbar::HORIZONTAL)
-        {
-          pos = (old_pos - (click_pos.x - (rect.left + event.mouse_pos.x)))/scale;
-        }
-      on_scrollbar_move(pos);
+    if (orientation == Scrollbar::VERTICAL)
+    {
+      pos = (old_pos - (click_pos.y - (rect.top + event.mouse_pos.y)))/scale;
     }
+    else if (orientation == Scrollbar::HORIZONTAL)
+    {
+      pos = (old_pos - (click_pos.x - (rect.left + event.mouse_pos.x)))/scale;
+    }
+    on_scrollbar_move(pos);
+  }
 }
 
 CL_Signal_v1<float>&

Modified: trunk/flexlay/lib/shared_ptr_comp.hpp
===================================================================
--- trunk/flexlay/lib/shared_ptr_comp.hpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/shared_ptr_comp.hpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -64,9 +64,9 @@
     std::cout << "SharedPtr: inc: " << (ref_count ? *ref_count : -45) << std::endl;
 #endif
     if (ref_count)
-      {
-        *ref_count += 1;
-      }
+    {
+      *ref_count += 1;
+    }
   }
   
   void dec() {
@@ -74,27 +74,27 @@
     std::cout << "SharedPtr: dec: " << (ref_count ? *ref_count : -45) << std::endl;
 #endif
     if (ref_count)
-      {
-        *ref_count -= 1;
-        if (*ref_count == 0) {
+    {
+      *ref_count -= 1;
+      if (*ref_count == 0) {
 #ifdef DEBUG
-          std::cout << "SharedPtr: deleting: type: "
-                    << typeid(deleter->ptr).name()
-                    << " ptr: " << deleter->ptr
-                    << std::endl;
+        std::cout << "SharedPtr: deleting: type: "
+                  << typeid(deleter->ptr).name()
+                  << " ptr: " << deleter->ptr
+                  << std::endl;
 #endif
-          deleter->del();
+        deleter->del();
           
-          delete ref_count; ref_count = 0;
-          delete deleter;   deleter   = 0;
-        }
+        delete ref_count; ref_count = 0;
+        delete deleter;   deleter   = 0;
       }
+    }
     else
-      {
+    {
 #ifdef DEBUG
-        std::cout << "SharedPtr: null delete" << std::endl;
+      std::cout << "SharedPtr: null delete" << std::endl;
 #endif
-      }
+    }
   }
 public:
   template<class Base> friend class SharedPtr;
@@ -127,24 +127,24 @@
     : deleter(0), ref_count(0)
   {
     if (copy.deleter)
-      {
-        deleter   = new SharedPtrDeleterImpl<T>(copy.deleter->ptr);
-        ref_count = copy.ref_count;
-        inc();
-      }
+    {
+      deleter   = new SharedPtrDeleterImpl<T>(copy.deleter->ptr);
+      ref_count = copy.ref_count;
+      inc();
+    }
 
 #ifdef DEBUG
     if (deleter)
-      {
-        std::cout << "SharedPtr: copy-ctor template: type: "
-                  << typeid(deleter->ptr).name()
-                  << " ptr: " << deleter->ptr
-                  << std::endl;
-      }
+    {
+      std::cout << "SharedPtr: copy-ctor template: type: "
+                << typeid(deleter->ptr).name()
+                << " ptr: " << deleter->ptr
+                << std::endl;
+    }
     else
-      {
-        std::cout << "SharedPtr: copy-ctor template null" << std::endl;
-      }
+    {
+      std::cout << "SharedPtr: copy-ctor template null" << std::endl;
+    }
 #endif
   }
 
@@ -156,30 +156,30 @@
     std::cout << "SharedPtr<T>& operator= (const SharedPtr<Base>& copy)" << std::endl;
 #endif
     if (ref_count != copy.ref_count)
+    {
+      dec();
+
+      if (copy.deleter)
       {
-        dec();
+        deleter   = new SharedPtrDeleterImpl<T>(copy.deleter->ptr);
+        ref_count = copy.ref_count;
+        inc();
+      }
 
-        if (copy.deleter)
-          {
-            deleter   = new SharedPtrDeleterImpl<T>(copy.deleter->ptr);
-            ref_count = copy.ref_count;
-            inc();
-          }
-
 #ifdef DEBUG
-        if (deleter)
-          {
-            std::cout << "SharedPtr: assign template: type: "
-                      << typeid(deleter->ptr).name()
-                      << " ptr: " << deleter->ptr
-                      << std::endl;
-          }
-        else
-          {
-            std::cout << "SharedPtr: assign template: null: " << std::endl;
-          }
+      if (deleter)
+      {
+        std::cout << "SharedPtr: assign template: type: "
+                  << typeid(deleter->ptr).name()
+                  << " ptr: " << deleter->ptr
+                  << std::endl;
+      }
+      else
+      {
+        std::cout << "SharedPtr: assign template: null: " << std::endl;
+      }
 #endif
-      }
+    }
 
     return *this;
   }
@@ -187,46 +187,46 @@
   SharedPtr<T>& operator= (const SharedPtr<T>& copy) 
   {
     if (this != &copy)
+    {
+      dec();
+
+      if (copy.deleter)
       {
-        dec();
+        deleter   = new SharedPtrDeleterImpl<T>(copy.deleter->ptr);
+        ref_count = copy.ref_count;
+        inc();
+      }
 
-        if (copy.deleter)
-          {
-            deleter   = new SharedPtrDeleterImpl<T>(copy.deleter->ptr);
-            ref_count = copy.ref_count;
-            inc();
-          }
-
 #ifdef DEBUG
-        if (deleter)
-          {
-            std::cout << "SharedPtr: assign normal: type: "
-                      << typeid(deleter->ptr).name()
-                      << " ptr: " << deleter->ptr
-                      << std::endl;
-          }
-        else
-          {
-            std::cout << "SharedPtr: assign normal null" << std::endl;
-          }
+      if (deleter)
+      {
+        std::cout << "SharedPtr: assign normal: type: "
+                  << typeid(deleter->ptr).name()
+                  << " ptr: " << deleter->ptr
+                  << std::endl;
+      }
+      else
+      {
+        std::cout << "SharedPtr: assign normal null" << std::endl;
+      }
 #endif
-      }
+    }
     else
+    {
+#ifdef DEBUG
+      if (deleter)
       {
-#ifdef DEBUG
-        if (deleter)
-          {
-            std::cout << "SharedPtr: self assin: type: "
-                      << typeid(deleter->ptr).name()
-                      << " ptr: " << deleter->ptr
-                      << std::endl;
-          }
-        else
-          {
-            std::cout << "SharedPtr: assign normal null" << std::endl;
-          }
+        std::cout << "SharedPtr: self assin: type: "
+                  << typeid(deleter->ptr).name()
+                  << " ptr: " << deleter->ptr
+                  << std::endl;
+      }
+      else
+      {
+        std::cout << "SharedPtr: assign normal null" << std::endl;
+      }
 #endif
-      }
+    }
 
     return *this;
   }
@@ -240,7 +240,7 @@
   T& operator*() { return *deleter->ptr; }
 
   T const& operator*() const { return *deleter->ptr; }
-	
+        
   //: Indirect member access operator.
   T* operator->() { return deleter->ptr; }
 

Modified: trunk/flexlay/lib/sketch_layer.cpp
===================================================================
--- trunk/flexlay/lib/sketch_layer.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/sketch_layer.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -69,13 +69,13 @@
     strokes.push_back(stroke);
 
     if (canvas)
-      {
-        EditorMapComponent* parent = EditorMapComponent::current();
-        parent->get_gc_state().push(canvas->get_gc());
-        stroke.draw(canvas->get_gc());
-        parent->get_gc_state().pop(canvas->get_gc());
-        canvas->sync_surface();
-      }
+    {
+      EditorMapComponent* parent = EditorMapComponent::current();
+      parent->get_gc_state().push(canvas->get_gc());
+      stroke.draw(canvas->get_gc());
+      parent->get_gc_state().pop(canvas->get_gc());
+      canvas->sync_surface();
+    }
   }
   
   void draw(EditorMapComponent* parent, CL_GraphicContext* gc) 
@@ -85,57 +85,57 @@
       return;
 
     if (canvas)
+    {
+      // Draw to canvas
+      if (last_zoom != parent->get_gc_state().get_zoom() ||
+          last_pos  != parent->get_gc_state().get_pos()  ||
+          last_rot  != parent->get_gc_state().get_rotation())
       {
-        // Draw to canvas
-        if (last_zoom != parent->get_gc_state().get_zoom() ||
-            last_pos  != parent->get_gc_state().get_pos()  ||
-            last_rot  != parent->get_gc_state().get_rotation())
-          {
-            // Rerender the image
-            last_zoom   = parent->get_gc_state().get_zoom();
-            last_pos    = parent->get_gc_state().get_pos();
-            last_rot    = parent->get_gc_state().get_rotation();
+        // Rerender the image
+        last_zoom   = parent->get_gc_state().get_zoom();
+        last_pos    = parent->get_gc_state().get_pos();
+        last_rot    = parent->get_gc_state().get_rotation();
 
-            parent->get_gc_state().push(canvas->get_gc());
-            canvas->get_gc()->clear(CL_Color(0, 0, 0, 0));
-            //canvas->get_gc()->clear(CL_Color::white);
+        parent->get_gc_state().push(canvas->get_gc());
+        canvas->get_gc()->clear(CL_Color(0, 0, 0, 0));
+        //canvas->get_gc()->clear(CL_Color::white);
 
-            CL_Rectf visible_area = parent->get_clip_rect();
+        CL_Rectf visible_area = parent->get_clip_rect();
 
-            for(Strokes::iterator i = strokes.begin(); i != strokes.end(); ++i)
-              {
-                // canvas->get_gc()->draw_rect(i->get_bounding_rect(), CL_Color(0, 255, 0));
-                // canvas->get_gc()->flush();
+        for(Strokes::iterator i = strokes.begin(); i != strokes.end(); ++i)
+        {
+          // canvas->get_gc()->draw_rect(i->get_bounding_rect(), CL_Color(0, 255, 0));
+          // canvas->get_gc()->flush();
 
-                if (visible_area.is_overlapped(i->get_bounding_rect()))
-                  {
-                    i->draw(canvas->get_gc());
-                  }
-              }
-            parent->get_gc_state().pop(canvas->get_gc());
+          if (visible_area.is_overlapped(i->get_bounding_rect()))
+          {
+            i->draw(canvas->get_gc());
+          }
+        }
+        parent->get_gc_state().pop(canvas->get_gc());
 
-            canvas->sync_surface();
-          }
+        canvas->sync_surface();
+      }
         
-        surface.set_blend_func(blend_one, blend_one_minus_src_alpha);
+      surface.set_blend_func(blend_one, blend_one_minus_src_alpha);
 
-        CL_Matrix4x4 matrix = CL_Display::get_modelview();
-        CL_Display::pop_modelview();
-        surface.draw();
-        CL_Display::set_modelview(matrix);
-        // FIXME: I think we need the line below, however with it it
-        //doesn't work, without it, it does, ClanLib bug or just
-        //consfusing function names?
-        //CL_Display::push_modelview();
-      }
+      CL_Matrix4x4 matrix = CL_Display::get_modelview();
+      CL_Display::pop_modelview();
+      surface.draw();
+      CL_Display::set_modelview(matrix);
+      // FIXME: I think we need the line below, however with it it
+      //doesn't work, without it, it does, ClanLib bug or just
+      //consfusing function names?
+      //CL_Display::push_modelview();
+    }
     else
-      { 
-        // Direct Drawing, slow
-        for(Strokes::iterator i = strokes.begin(); i != strokes.end(); ++i)
-          {
-            i->draw(0);
-          }
+    { 
+      // Direct Drawing, slow
+      for(Strokes::iterator i = strokes.begin(); i != strokes.end(); ++i)
+      {
+        i->draw(0);
       }
+    }
   }
 
   bool has_bounding_rect() const { 
@@ -159,7 +159,7 @@
 Layer
 SketchLayer::to_layer()
 {
-   return Layer(impl);
+  return Layer(impl);
 }
 
 std::vector<Stroke>

Modified: trunk/flexlay/lib/slider.cpp
===================================================================
--- trunk/flexlay/lib/slider.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/slider.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -84,31 +84,31 @@
 Slider::on_mouse_down(const CL_InputEvent& event)
 {
   if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed = true;
-      capture_mouse();
-      update_mouse(event);
-    }
+  {
+    pressed = true;
+    capture_mouse();
+    update_mouse(event);
+  }
 }
 
 void
 Slider::on_mouse_up  (const CL_InputEvent& event)
 {
   if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed = false;
-      release_mouse();
-      update_mouse(event);
-    }
+  {
+    pressed = false;
+    release_mouse();
+    update_mouse(event);
+  }
 }
 
 void
 Slider::on_mouse_move(const CL_InputEvent& event)
 {
   if (pressed)
-    {
-      update_mouse(event);
-    }
+  {
+    update_mouse(event);
+  }
 }
 
 /* EOF */

Modified: trunk/flexlay/lib/sprite_stroke_drawer.cpp
===================================================================
--- trunk/flexlay/lib/sprite_stroke_drawer.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/sprite_stroke_drawer.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -67,191 +67,191 @@
                                                    * DrawerProperties::current()->get_size());
 
   for(Stroke::Dabs::iterator i = dabs.begin(); i != dabs.end(); ++i)
-    {
-      Dab& dab = *i;
+  {
+    Dab& dab = *i;
 
-      CL_Sprite sprite = DrawerProperties::current()->get_brush().get_sprite();
+    CL_Sprite sprite = DrawerProperties::current()->get_brush().get_sprite();
 
-      CL_Color color = DrawerProperties::current()->get_color();
-      sprite.set_color(color);
-      sprite.set_alpha((color.get_alpha()/255.0f) * dab.pressure);
-      sprite.set_scale(DrawerProperties::current()->get_size() * dab.pressure,
-                       DrawerProperties::current()->get_size() * dab.pressure);
+    CL_Color color = DrawerProperties::current()->get_color();
+    sprite.set_color(color);
+    sprite.set_alpha((color.get_alpha()/255.0f) * dab.pressure);
+    sprite.set_scale(DrawerProperties::current()->get_size() * dab.pressure,
+                     DrawerProperties::current()->get_size() * dab.pressure);
 
-      if (gc != 0)
-        {
-          /* Correct function:
-             1: dest
-             2: src
+    if (gc != 0)
+    {
+      /* Correct function:
+         1: dest
+         2: src
              
-             R = R1 A1 (1 - A2) + R2 A2
-             G = G1 A1 (1 - A2) + G2 A2
-             B = B1 A1 (1 - A2) + B2 A2
-             A = A1 (1 - A2) + A2
+         R = R1 A1 (1 - A2) + R2 A2
+         G = G1 A1 (1 - A2) + G2 A2
+         B = B1 A1 (1 - A2) + B2 A2
+         A = A1 (1 - A2) + A2
 
-             // This is currently used, leads to premultiplied alpha
-             Aout  = Afgd + (1 - Afgd) * Abkg 
-             Cout' = Cfgd' + (1 - Afgd) * Cbkg' 
-             where
-             Cfgd' = Cfgd * Afgd
-             Cbkg' = Cbkg * Abkg
-             Cout' = Cout * Aout
+         // This is currently used, leads to premultiplied alpha
+         Aout  = Afgd + (1 - Afgd) * Abkg 
+         Cout' = Cfgd' + (1 - Afgd) * Cbkg' 
+         where
+         Cfgd' = Cfgd * Afgd
+         Cbkg' = Cbkg * Abkg
+         Cout' = Cout * Aout
 
-             Aout = (1 - (1 - Afgd) * (1 - Abkg)) 
-             Cout = (Cfgd * Afgd) + (1 - Afgd * Cbkg * Abkg) / Aout 
-             where
-             Cfgd = red, green, blue of foreground
-             Cbkg = red, green, blue of background
-             Afgd = alpha of foreground
-             Abkg = alpha of background
-          */
+         Aout = (1 - (1 - Afgd) * (1 - Abkg)) 
+         Cout = (Cfgd * Afgd) + (1 - Afgd * Cbkg * Abkg) / Aout 
+         where
+         Cfgd = red, green, blue of foreground
+         Cbkg = red, green, blue of background
+         Afgd = alpha of foreground
+         Abkg = alpha of background
+      */
 
-          // DO Multipass:
-          // 1: GL_ZERO, GL_DST_ALPHA
-          // 2: GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA
-          /*brush.set_blend_func_separate(blend_zero, blend_dst_alpha,
-            blend_zero, blend_one);
-            brush.draw(dab.pos.x, dab.pos.y, gc);*/
+      // DO Multipass:
+      // 1: GL_ZERO, GL_DST_ALPHA
+      // 2: GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA
+      /*brush.set_blend_func_separate(blend_zero, blend_dst_alpha,
+        blend_zero, blend_one);
+        brush.draw(dab.pos.x, dab.pos.y, gc);*/
           
-          switch (mode)
-            {
-            case SpriteStrokeDrawer::DM_NORMAL:
-              sprite.set_blend_func_separate(blend_src_alpha, blend_one_minus_src_alpha,
-                                             blend_one, blend_one_minus_src_alpha);
-              sprite.draw(dab.pos.x, dab.pos.y, gc);
-              break;
+      switch (mode)
+      {
+        case SpriteStrokeDrawer::DM_NORMAL:
+          sprite.set_blend_func_separate(blend_src_alpha, blend_one_minus_src_alpha,
+                                         blend_one, blend_one_minus_src_alpha);
+          sprite.draw(dab.pos.x, dab.pos.y, gc);
+          break;
 
-            case SpriteStrokeDrawer::DM_ADDITION:
-              sprite.set_blend_func_separate(blend_src_alpha, blend_one,
-                                             blend_zero, blend_one);
-              //blend_one, blend_one_minus_src_alpha);
-              sprite.draw(dab.pos.x, dab.pos.y, gc);
-              break;
+        case SpriteStrokeDrawer::DM_ADDITION:
+          sprite.set_blend_func_separate(blend_src_alpha, blend_one,
+                                         blend_zero, blend_one);
+          //blend_one, blend_one_minus_src_alpha);
+          sprite.draw(dab.pos.x, dab.pos.y, gc);
+          break;
               
-            case SpriteStrokeDrawer::DM_ERASE:
-              sprite.set_blend_func(blend_zero, blend_one_minus_src_alpha);
-              sprite.draw(dab.pos.x, dab.pos.y, gc);
-              break;
+        case SpriteStrokeDrawer::DM_ERASE:
+          sprite.set_blend_func(blend_zero, blend_one_minus_src_alpha);
+          sprite.draw(dab.pos.x, dab.pos.y, gc);
+          break;
           
-            case SpriteStrokeDrawer::DM_SMUDGE:
-              {
-                if (i != dabs.begin())
-                  {
-                    CL_Canvas* canvas = BitmapLayer::current()->get_canvas();
-                    CL_PixelBuffer buffer = canvas->get_pixeldata(CL_Rect(CL_Point(static_cast<int>((i-1)->pos.x) - sprite.get_width()/2,
-                                                                                   static_cast<int>((i-1)->pos.y) - sprite.get_height()/2),
-                                                                          CL_Size(sprite.get_width(), sprite.get_height())));
-                    CL_Surface surface(buffer);
-                    //surface.set_blend_func_separate(blend_src_alpha, blend_one_minus_src_alpha,
-                    //                                blend_one, blend_zero);
-                    surface.set_alignment(origin_center);
-                    surface.set_alpha(0.5);
-                    //surface.set_scale(DrawerProperties::current()->get_size(),
-                    //                 DrawerProperties::current()->get_size());
-                    surface.draw(dab.pos.x, dab.pos.y, gc);
-                  }
-              }
-              break;
+        case SpriteStrokeDrawer::DM_SMUDGE:
+        {
+          if (i != dabs.begin())
+          {
+            CL_Canvas* canvas = BitmapLayer::current()->get_canvas();
+            CL_PixelBuffer buffer = canvas->get_pixeldata(CL_Rect(CL_Point(static_cast<int>((i-1)->pos.x) - sprite.get_width()/2,
+                                                                           static_cast<int>((i-1)->pos.y) - sprite.get_height()/2),
+                                                                  CL_Size(sprite.get_width(), sprite.get_height())));
+            CL_Surface surface(buffer);
+            //surface.set_blend_func_separate(blend_src_alpha, blend_one_minus_src_alpha,
+            //                                blend_one, blend_zero);
+            surface.set_alignment(origin_center);
+            surface.set_alpha(0.5);
+            //surface.set_scale(DrawerProperties::current()->get_size(),
+            //                 DrawerProperties::current()->get_size());
+            surface.draw(dab.pos.x, dab.pos.y, gc);
+          }
+        }
+        break;
 
-            case SpriteStrokeDrawer::DM_SHADER:
-              {
+        case SpriteStrokeDrawer::DM_SHADER:
+        {
 #if 0 
-                CL_OpenGLState state(gc);
-                state.set_active();
-                state.setup_2d();
+          CL_OpenGLState state(gc);
+          state.set_active();
+          state.setup_2d();
 
-                if (program == 0)
-                  {
-                    program = new CL_ProgramObject();
+          if (program == 0)
+          {
+            program = new CL_ProgramObject();
                 
-                    CL_ShaderObject shader("shader", &(Flexlay::current()->resources));
-                    std::cout << "Shader status: " << (shader.get_compile_status() ? "true" : "false") << std::endl;
-                    std::cout << "Shader log: " << shader.get_info_log() << std::endl;
-                    std::cout << "Shader handle: " << shader.get_handle() << std::endl;
+            CL_ShaderObject shader("shader", &(Flexlay::current()->resources));
+            std::cout << "Shader status: " << (shader.get_compile_status() ? "true" : "false") << std::endl;
+            std::cout << "Shader log: " << shader.get_info_log() << std::endl;
+            std::cout << "Shader handle: " << shader.get_handle() << std::endl;
 
-                    program->attach(shader);
-                    program->link();
-                    std::cout << "Program status: " << (program->get_link_status() ? "true" : "false") << std::endl;
-                    std::cout << "Program log: " << program->get_info_log() << std::endl;
-                    std::cout << "Program handle: " << program->get_handle() << std::endl;
+            program->attach(shader);
+            program->link();
+            std::cout << "Program status: " << (program->get_link_status() ? "true" : "false") << std::endl;
+            std::cout << "Program log: " << program->get_info_log() << std::endl;
+            std::cout << "Program handle: " << program->get_handle() << std::endl;
 
-                    clUseProgram(program->get_handle());
-                  }
-                else
-                  {
-                    clUseProgram(program->get_handle());
-                  }
+            clUseProgram(program->get_handle());
+          }
+          else
+          {
+            clUseProgram(program->get_handle());
+          }
             
-                CL_OpenGLSurface glsurface(sprite.get_frame_surface(0));
-                glActiveTexture(GL_TEXTURE0);
-                glsurface.bind();
-                glEnable(GL_TEXTURE_2D);
+          CL_OpenGLSurface glsurface(sprite.get_frame_surface(0));
+          glActiveTexture(GL_TEXTURE0);
+          glsurface.bind();
+          glEnable(GL_TEXTURE_2D);
 
-                /*CL_OpenGLSurface glsurface2(SketchLayer::current()->get_background_surface());
-                  glActiveTexture(GL_TEXTURE1);
-                  glsurface2.bind();
-                  glEnable(GL_TEXTURE_2D);*/
+          /*CL_OpenGLSurface glsurface2(SketchLayer::current()->get_background_surface());
+            glActiveTexture(GL_TEXTURE1);
+            glsurface2.bind();
+            glEnable(GL_TEXTURE_2D);*/
             
-                clUniform1i(program->get_attribute_location("mytex"), 0);
-                //clUniform1i(program->get_attribute_location("background"), 1);
-                //program->validate();
-                //std::cout << "Program validate status: " << (program->get_validate_status() ? "true" : "false") << std::endl;
-                //std::cout << "Program log: " << program->get_info_log() << std::endl;
+          clUniform1i(program->get_attribute_location("mytex"), 0);
+          //clUniform1i(program->get_attribute_location("background"), 1);
+          //program->validate();
+          //std::cout << "Program validate status: " << (program->get_validate_status() ? "true" : "false") << std::endl;
+          //std::cout << "Program log: " << program->get_info_log() << std::endl;
 
-                clBegin(CL_QUADS);
-                clColor4b(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
-                float size = base_size * dab.pressure;
-                clVertex2f((dab.pos.x - sprite.get_width()/2) * size, (dab.pos.y - sprite.get_height()/2) * size);
-                clTexCoord2d(0.0, 0.0);
-                clVertex2f((dab.pos.x + sprite.get_width()/2) * size, (dab.pos.y - sprite.get_height()/2) * size);
-                clTexCoord2d(1.0, 0.0);
-                clVertex2f((dab.pos.x + sprite.get_width()/2) * size, (dab.pos.y + sprite.get_height()/2) * size);
-                clTexCoord2d(1.0, 1.0);
-                clVertex2f((dab.pos.x - sprite.get_width()/2) * size, (dab.pos.y + sprite.get_height()/2) * size);
-                clTexCoord2d(0.0, 1.0);
-                clEnd();
+          clBegin(CL_QUADS);
+          clColor4b(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
+          float size = base_size * dab.pressure;
+          clVertex2f((dab.pos.x - sprite.get_width()/2) * size, (dab.pos.y - sprite.get_height()/2) * size);
+          clTexCoord2d(0.0, 0.0);
+          clVertex2f((dab.pos.x + sprite.get_width()/2) * size, (dab.pos.y - sprite.get_height()/2) * size);
+          clTexCoord2d(1.0, 0.0);
+          clVertex2f((dab.pos.x + sprite.get_width()/2) * size, (dab.pos.y + sprite.get_height()/2) * size);
+          clTexCoord2d(1.0, 1.0);
+          clVertex2f((dab.pos.x - sprite.get_width()/2) * size, (dab.pos.y + sprite.get_height()/2) * size);
+          clTexCoord2d(0.0, 1.0);
+          clEnd();
             
-                state.set_active();
-                clUseProgram(0);
+          state.set_active();
+          clUseProgram(0);
 #endif
-              }
-              break;
-              
-            default:
-              std::cout << "Error: SpriteStrokeDrawer: Unknown draw mode: " << mode << std::endl;
-              break;
-            }
         }
-      else
-        {
-          switch (mode)
-            {
-            case SpriteStrokeDrawer::DM_NORMAL:  
-              sprite.set_blend_func(blend_src_alpha, blend_one_minus_src_alpha);
-              sprite.draw(dab.pos.x, dab.pos.y, gc);
-              break;
+        break;
               
-            case SpriteStrokeDrawer::DM_ADDITION:
-              sprite.set_blend_func(blend_src_alpha, blend_one);
-              sprite.draw(dab.pos.x, dab.pos.y, gc); 
-              break;
+        default:
+          std::cout << "Error: SpriteStrokeDrawer: Unknown draw mode: " << mode << std::endl;
+          break;
+      }
+    }
+    else
+    {
+      switch (mode)
+      {
+        case SpriteStrokeDrawer::DM_NORMAL:  
+          sprite.set_blend_func(blend_src_alpha, blend_one_minus_src_alpha);
+          sprite.draw(dab.pos.x, dab.pos.y, gc);
+          break;
+              
+        case SpriteStrokeDrawer::DM_ADDITION:
+          sprite.set_blend_func(blend_src_alpha, blend_one);
+          sprite.draw(dab.pos.x, dab.pos.y, gc); 
+          break;
             
-            case SpriteStrokeDrawer::DM_ERASE:
-              sprite.set_blend_func(blend_zero, blend_one_minus_src_alpha);
-              sprite.draw(dab.pos.x, dab.pos.y, gc);
-              break; 
+        case SpriteStrokeDrawer::DM_ERASE:
+          sprite.set_blend_func(blend_zero, blend_one_minus_src_alpha);
+          sprite.draw(dab.pos.x, dab.pos.y, gc);
+          break; 
           
-            case SpriteStrokeDrawer::DM_SMUDGE:
-              sprite.set_blend_func(blend_src_alpha, blend_one_minus_src_alpha);
-              sprite.draw(dab.pos.x, dab.pos.y, gc);          
-              break;
+        case SpriteStrokeDrawer::DM_SMUDGE:
+          sprite.set_blend_func(blend_src_alpha, blend_one_minus_src_alpha);
+          sprite.draw(dab.pos.x, dab.pos.y, gc);          
+          break;
 
-            default:
-              std::cout << "Error: SpriteStrokeDrawer: Unknown draw mode: " << mode << std::endl;
-              break;
-            }
-        }
+        default:
+          std::cout << "Error: SpriteStrokeDrawer: Unknown draw mode: " << mode << std::endl;
+          break;
+      }
     }
+  }
 }
 
 void

Modified: trunk/flexlay/lib/stroke.cpp
===================================================================
--- trunk/flexlay/lib/stroke.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/stroke.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -38,19 +38,19 @@
 
     // FIXME: Keep the drawer into account (ie. brushsize)
     if (dabs.size() > 0)
+    {
+      rect.left = rect.right  = dabs.front().pos.x;
+      rect.top  = rect.bottom = dabs.front().pos.y;
+
+      for(Stroke::Dabs::const_iterator i = dabs.begin()+1; i != dabs.end(); ++i)
       {
-        rect.left = rect.right  = dabs.front().pos.x;
-        rect.top  = rect.bottom = dabs.front().pos.y;
+        rect.left = std::min(i->pos.x, rect.left);
+        rect.top  = std::min(i->pos.y, rect.top);
 
-        for(Stroke::Dabs::const_iterator i = dabs.begin()+1; i != dabs.end(); ++i)
-          {
-            rect.left = std::min(i->pos.x, rect.left);
-            rect.top  = std::min(i->pos.y, rect.top);
-
-            rect.right  = std::max(i->pos.x, rect.right);
-            rect.bottom = std::max(i->pos.y, rect.bottom);
-          }
+        rect.right  = std::max(i->pos.x, rect.right);
+        rect.bottom = std::max(i->pos.y, rect.bottom);
       }
+    }
     
     return rect;
   }
@@ -82,49 +82,49 @@
 Stroke::get_interpolated_dabs(float x_spacing, float y_spacing) const
 {
   if (impl->dabs.size() > 0)
-    {
-      Dabs interpolated_dabs;
+  {
+    Dabs interpolated_dabs;
 
-      interpolated_dabs.push_back(impl->dabs.front());
+    interpolated_dabs.push_back(impl->dabs.front());
 
-      // The following code basically takes all the event dabs as recieved
-      // by from the InputDevice and interpolates new dabs inbetween to
-      // give them an equal spacing (ie. every dab is only 'spacing' away
-      // from the next)
-      float overspace = 0.0f;
-      const Stroke::Dabs& dabs = impl->dabs;
-      for(unsigned int j = 0; j < dabs.size()-1; ++j)
-        {
-          CL_Pointf dist = dabs[j+1].pos - dabs[j].pos;
-          float length = sqrt(dist.x * dist.x + dist.y * dist.y);
-          int n = 1;
+    // The following code basically takes all the event dabs as recieved
+    // by from the InputDevice and interpolates new dabs inbetween to
+    // give them an equal spacing (ie. every dab is only 'spacing' away
+    // from the next)
+    float overspace = 0.0f;
+    const Stroke::Dabs& dabs = impl->dabs;
+    for(unsigned int j = 0; j < dabs.size()-1; ++j)
+    {
+      CL_Pointf dist = dabs[j+1].pos - dabs[j].pos;
+      float length = sqrt(dist.x * dist.x + dist.y * dist.y);
+      int n = 1;
     
-          // Spacing is keep relative to the brush size
-          // FIXME: This is specific to a Sprite based drawer, might not work for others
-          // FIXME: y_spacing isn't taken into account either
-          float local_spacing = x_spacing * dabs[j].pressure;
+      // Spacing is keep relative to the brush size
+      // FIXME: This is specific to a Sprite based drawer, might not work for others
+      // FIXME: y_spacing isn't taken into account either
+      float local_spacing = x_spacing * dabs[j].pressure;
 
-          while (length + overspace > (local_spacing * n))
-            {
-              float factor = (local_spacing/length) * n - (overspace/length);
+      while (length + overspace > (local_spacing * n))
+      {
+        float factor = (local_spacing/length) * n - (overspace/length);
           
-              // FIXME: Interpolate tilting, pressure, etc. along the line
-              interpolated_dabs.push_back(Dab(dabs[j].pos.x + dist.x * factor,
-                                              dabs[j].pos.y + dist.y * factor,
-                                              dabs[j].pressure));
-              n += 1;
-            }
+        // FIXME: Interpolate tilting, pressure, etc. along the line
+        interpolated_dabs.push_back(Dab(dabs[j].pos.x + dist.x * factor,
+                                        dabs[j].pos.y + dist.y * factor,
+                                        dabs[j].pressure));
+        n += 1;
+      }
 
-          // calculate the space that wasn't used in the last iteration
-          overspace = (length + overspace) - (local_spacing * (n-1));
-        }
-      return interpolated_dabs;
+      // calculate the space that wasn't used in the last iteration
+      overspace = (length + overspace) - (local_spacing * (n-1));
     }
+    return interpolated_dabs;
+  }
   else
-    {
-      // No dabs available, so nothing to interpolate
-      return impl->dabs;
-    }
+  {
+    // No dabs available, so nothing to interpolate
+    return impl->dabs;
+  }
 }
 
 Stroke::Dabs
@@ -143,13 +143,13 @@
 Stroke::draw(CL_GraphicContext* gc) const
 {
   if (!impl->drawer.is_null())
-    {
-      const_cast<StrokeDrawer&>(impl->drawer).draw(*this, gc);
-    }
+  {
+    const_cast<StrokeDrawer&>(impl->drawer).draw(*this, gc);
+  }
   else
-    {
-      std::cout << "No drawer set!" << std::endl;
-    }
+  {
+    std::cout << "No drawer set!" << std::endl;
+  }
 }
 
 void
@@ -159,67 +159,67 @@
 }
 
 /* // calc normals
-  assert(normals.size() == 0);
+   assert(normals.size() == 0);
 
-  if (points.size() == 1)
-    {
-      normals.push_back(CL_Pointf(1.0f, 1.0f));
-    }
-  else if (points.size() == 2)
-    {
-      normals.push_back(CL_Pointf(1.0f, 1.0f));
-      normals.push_back(CL_Pointf(1.0f, 1.0f));
-    }
-  else if (points.size() >= 3)
-    {
-      for(Points::size_type i = 0; i < int(points.size())-1; ++i)
-        {
-          CL_Pointf normal((points[i].y - points[i+1].y),
-                           -(points[i].x - points[i+1].x));
+   if (points.size() == 1)
+   {
+   normals.push_back(CL_Pointf(1.0f, 1.0f));
+   }
+   else if (points.size() == 2)
+   {
+   normals.push_back(CL_Pointf(1.0f, 1.0f));
+   normals.push_back(CL_Pointf(1.0f, 1.0f));
+   }
+   else if (points.size() >= 3)
+   {
+   for(Points::size_type i = 0; i < int(points.size())-1; ++i)
+   {
+   CL_Pointf normal((points[i].y - points[i+1].y),
+   -(points[i].x - points[i+1].x));
 
-          float length = sqrt(normal.x * normal.x + normal.y * normal.y);
+   float length = sqrt(normal.x * normal.x + normal.y * normal.y);
 
-          normal.x /= length;
-          normal.y /= length;
+   normal.x /= length;
+   normal.y /= length;
           
-          normals.push_back(normal);
-        }
+   normals.push_back(normal);
+   }
       
-      normals.push_back(CL_Pointf(1.0f, 1.0f));
-    }
+   normals.push_back(CL_Pointf(1.0f, 1.0f));
+   }
 
-  //std::cout << normals.size() << " == " <<  points.size() << std::endl;
-  assert(normals.size() == points.size());
+   //std::cout << normals.size() << " == " <<  points.size() << std::endl;
+   assert(normals.size() == points.size());
 
- */
+*/
 
 /*
-  // Calc bounding rect
-  if (points.size() >= 1)
-    {
-      bounding_rect.left = bounding_rect.right  = points.front().x;
-      bounding_rect.top  = bounding_rect.bottom = points.front().y;
+// Calc bounding rect
+if (points.size() >= 1)
+{
+bounding_rect.left = bounding_rect.right  = points.front().x;
+bounding_rect.top  = bounding_rect.bottom = points.front().y;
 
-      for(Points::iterator i = points.begin()+1; i != points.end(); ++i)
-        {
-          bounding_rect.left   = Math::min(bounding_rect.left,   i->x);
-          bounding_rect.right  = Math::max(bounding_rect.right,  i->x);;
-          bounding_rect.top    = Math::min(bounding_rect.top,    i->y);
-          bounding_rect.bottom = Math::min(bounding_rect.bottom, i->y);
-        }
+for(Points::iterator i = points.begin()+1; i != points.end(); ++i)
+{
+bounding_rect.left   = Math::min(bounding_rect.left,   i->x);
+bounding_rect.right  = Math::max(bounding_rect.right,  i->x);;
+bounding_rect.top    = Math::min(bounding_rect.top,    i->y);
+bounding_rect.bottom = Math::min(bounding_rect.bottom, i->y);
+}
 
-      // FIXME: Need to take brush size into account
-    }
+// FIXME: Need to take brush size into account
+}
 */
 
 CL_Rectf
 Stroke::get_bounding_rect() const
 {
   if (impl->bounding_rect_needs_recalc)
-    {
-      impl->bounding_rect = impl->calc_bounding_rect();
-      impl->bounding_rect_needs_recalc = false;
-    }
+  {
+    impl->bounding_rect = impl->calc_bounding_rect();
+    impl->bounding_rect_needs_recalc = false;
+  }
   
   return impl->bounding_rect;
 }

Modified: trunk/flexlay/lib/tile.cpp
===================================================================
--- trunk/flexlay/lib/tile.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tile.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -89,15 +89,15 @@
 Tile::get_color()
 {
   if (impl->has_color)
-    {
-      return impl->color;
-    }
+  {
+    return impl->color;
+  }
   else
-    {
-      impl->color = calc_color();
-      impl->has_color = true;
-      return impl->color;
-    }
+  {
+    impl->color = calc_color();
+    impl->has_color = true;
+    return impl->color;
+  }
 }
 
 CL_Color
@@ -110,65 +110,65 @@
 Tile::get_sprite()
 {
   if (impl->sprite)
+  {
+    return impl->sprite;
+  }
+  else
+  {
+    if (impl->provider)
     {
-      return impl->sprite;
+      impl->sprite = impl->provider.get_sprite();
     }
-  else
+    else
     {
-      if (impl->provider)
-        {
-          impl->sprite = impl->provider.get_sprite();
-        }
-      else
-        {
-          CL_SpriteDescription desc;
-          desc.add_frame(CL_PixelBuffer(get_pixelbuffer()));
-          impl->sprite = CL_Sprite(desc);
-        }
+      CL_SpriteDescription desc;
+      desc.add_frame(CL_PixelBuffer(get_pixelbuffer()));
+      impl->sprite = CL_Sprite(desc);
+    }
 
-      return impl->sprite;
-    }
+    return impl->sprite;
+  }
 }
 
 CL_PixelBuffer
 Tile::get_pixelbuffer()
 {
   if (impl->pixelbuffer)
+  {
+    return impl->pixelbuffer;
+  }
+  else 
+  {
+    if (impl->provider)
     {
+      impl->pixelbuffer = impl->provider.get_pixelbuffer();
       return impl->pixelbuffer;
     }
-  else 
+    else
     {
-      if (impl->provider)
+      // FIXME: Move all this into a special provider
+
+      try {
+        if (has_suffix(impl->filename, ".png") || has_suffix(impl->filename, ".jpg"))
         {
-          impl->pixelbuffer = impl->provider.get_pixelbuffer();
-          return impl->pixelbuffer;
+          impl->pixelbuffer = CL_PixelBuffer(CL_ProviderFactory::load(impl->filename));
         }
-      else
+        else
         {
-          // FIXME: Move all this into a special provider
-
-          try {
-            if (has_suffix(impl->filename, ".png") || has_suffix(impl->filename, ".jpg"))
-              {
-                impl->pixelbuffer = CL_PixelBuffer(CL_ProviderFactory::load(impl->filename));
-              }
-            else
-              {
-                //CL_SpriteDescription descr(impl->filename, resources);
-                //impl->pixelbuffer = CL_PixelBuffer(*(descr.get_frames().begin()->first));
-                std::cout << "Error: not a png or jpg file: " << impl->filename << std::endl;
-                assert(0);
-              }
-            return impl->pixelbuffer;
+          //CL_SpriteDescription descr(impl->filename, resources);
+          //impl->pixelbuffer = CL_PixelBuffer(*(descr.get_frames().begin()->first));
+          std::cout << "Error: not a png or jpg file: " << impl->filename << std::endl;
+          assert(0);
+        }
+        return impl->pixelbuffer;
           
-          } catch(CL_Error& err) {
-            std::cout << "CL_Error: " << err.message << std::endl;
-            std::cout << "          filename = " << impl->filename << std::endl;
-            return CL_PixelBuffer();
-          }
-        }
+      } catch(CL_Error& err) {
+        std::cout << "CL_Error: " << err.message << std::endl;
+        std::cout << "          filename = " << impl->filename << std::endl;
+        return CL_PixelBuffer();
+      }
     }
+  }
 }
 
 CL_Color
@@ -185,39 +185,39 @@
   int alpha = 0;
   
   switch (buffer.get_format().get_depth())
+  {
+    case 8:
     {
-    case 8:
+      CL_Palette palette = buffer.get_palette();
+      for(int i = 0; i < len; ++i)
       {
-        CL_Palette palette = buffer.get_palette();
-        for(int i = 0; i < len; ++i)
-          {
-            red   += palette.colors[buf[i]].get_red();
-            green += palette.colors[buf[i]].get_green();
-            blue  += palette.colors[buf[i]].get_blue();
-            alpha += 255;
-          }
+        red   += palette.colors[buf[i]].get_red();
+        green += palette.colors[buf[i]].get_green();
+        blue  += palette.colors[buf[i]].get_blue();
+        alpha += 255;
       }
-      break;
+    }
+    break;
     case 24:
       for(int i = 0; i < len; ++i)
-        {
-          red   += buf[3*i + 0];
-          green += buf[3*i + 1];
-          blue  += buf[3*i + 2];
-          alpha += 255;
-        }
+      {
+        red   += buf[3*i + 0];
+        green += buf[3*i + 1];
+        blue  += buf[3*i + 2];
+        alpha += 255;
+      }
       break;
     case 32:
       for(int i = 0; i < len; ++i)
-        {
-          int a = buf[4*i + 0];
-          alpha += a;
-          red   += buf[4*i + 3]*a/255;;
-          green += buf[4*i + 2]*a/255;;
-          blue  += buf[4*i + 1]*a/255;;
-        }
+      {
+        int a = buf[4*i + 0];
+        alpha += a;
+        red   += buf[4*i + 3]*a/255;;
+        green += buf[4*i + 2]*a/255;;
+        blue  += buf[4*i + 1]*a/255;;
+      }
       break;
-    }
+  }
 
   buffer.unlock();
 

Modified: trunk/flexlay/lib/tile_brush.cpp
===================================================================
--- trunk/flexlay/lib/tile_brush.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tile_brush.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -44,48 +44,48 @@
   for(int y = 0; y < get_height(); ++y)
     for(int x = 0; x < get_width(); ++x)
       if (at(x, y) != 0)
-        {
-          rect.top = y;
-          goto bottom;
-        }
+      {
+        rect.top = y;
+        goto bottom;
+      }
 
- bottom:
+bottom:
   for(int y = get_height()-1; y >= 0; --y)
     for(int x = 0; x < get_width(); ++x)
       if (at(x, y) != 0)
-        {
-          rect.bottom = y + 1;
-          goto left;
-        }
+      {
+        rect.bottom = y + 1;
+        goto left;
+      }
 
- left:
+left:
   for(int x = 0; x < get_width(); ++x)
     for(int y = 0; y < get_height(); ++y)
       if (at(x, y) != 0)
-        {
-          rect.left = x;
-          goto right;
-        }
+      {
+        rect.left = x;
+        goto right;
+      }
 
- right:
+right:
   for(int x = get_width() - 1; x >= 0; --x)
     for(int y = 0; y < get_height(); ++y)
       if (at(x, y) != 0)
-        {
-          rect.right = x + 1;
-          goto end;
-        }
+      {
+        rect.right = x + 1;
+        goto end;
+      }
 
- end:
+end:
   if (rect.get_width() != 0)
     resize(rect.get_width(), rect.get_height(), 
            -rect.left, -rect.top);
   else
-    {
-      (*this) = TileBrush(1, 1);
-      at(0, 0) = 0;
-      set_opaque();
-    }
+  {
+    (*this) = TileBrush(1, 1);
+    at(0, 0) = 0;
+    set_opaque();
+  }
 }
 
 void

Modified: trunk/flexlay/lib/tile_editor.cpp
===================================================================
--- trunk/flexlay/lib/tile_editor.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tile_editor.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -48,31 +48,31 @@
   CL_Display::fill_rect(CL_Rect(0, 0, 32, 32), CL_Color(155, 0, 155));
 
   if (tile)
-    {
-      tile->get_sprite().draw(0, 0);
-      CL_Display::flush();
-      for(int tile_y = 0; tile_y < 8; ++tile_y)
-        for(int tile_x = 0; tile_x < 8; ++tile_x)
-          {
-            if (tile->get_col(tile_x, tile_y))
-              {
-                CL_Display::fill_rect(CL_Rect(tile_x*16, tile_y*16,
-                                              tile_x*16 + 16, tile_y*16 + 16),
-                                      CL_Color(255, 0, 0, 128));
-              }
-          }
-      CL_Display::flush();
-      if (has_mouse_over())
+  {
+    tile->get_sprite().draw(0, 0);
+    CL_Display::flush();
+    for(int tile_y = 0; tile_y < 8; ++tile_y)
+      for(int tile_x = 0; tile_x < 8; ++tile_x)
+      {
+        if (tile->get_col(tile_x, tile_y))
         {
-          CL_Display::fill_rect(CL_Rect(CL_Point(int(mouse_pos.x)/16 * 16, 
-                                                 int(mouse_pos.y)/16 * 16),
-                                        CL_Size(16, 16)),
-                                CL_Color(255, 255, 255, 128));
+          CL_Display::fill_rect(CL_Rect(tile_x*16, tile_y*16,
+                                        tile_x*16 + 16, tile_y*16 + 16),
+                                CL_Color(255, 0, 0, 128));
         }
+      }
+    CL_Display::flush();
+    if (has_mouse_over())
+    {
+      CL_Display::fill_rect(CL_Rect(CL_Point(int(mouse_pos.x)/16 * 16, 
+                                             int(mouse_pos.y)/16 * 16),
+                                    CL_Size(16, 16)),
+                            CL_Color(255, 255, 255, 128));
     }
+  }
   else
-    {
-    }
+  {
+  }
 
   CL_Display::pop_modelview();
 }
@@ -92,35 +92,35 @@
 TileEditor::mouse_down(const CL_InputEvent& event)
 {
   if (tile)
+  {
+    switch (event.id)
     {
-      switch (event.id)
-        {
-        case CL_MOUSE_LEFT:
-          paint(event.mouse_pos, true);
-          break;
+      case CL_MOUSE_LEFT:
+        paint(event.mouse_pos, true);
+        break;
               
-        case CL_MOUSE_RIGHT:
-          paint(event.mouse_pos, false);
-          break;
+      case CL_MOUSE_RIGHT:
+        paint(event.mouse_pos, false);
+        break;
         
-        }
     }
+  }
 }
 
 void
 TileEditor::paint(CL_Point pos, bool val)
 {
   if (tile)
+  {
+    int x = int(pos.x) / 16;
+    int y = int(pos.y) / 16;
+
+    if (x >= 0 && y >= 0
+        && x < 8 && y < 8)
     {
-      int x = int(pos.x) / 16;
-      int y = int(pos.y) / 16;
-
-      if (x >= 0 && y >= 0
-          && x < 8 && y < 8)
-        {
-          tile->set_col(x, y, val);
-        }
+      tile->set_col(x, y, val);
     }
+  }
 }
 
 void

Modified: trunk/flexlay/lib/tile_selection.cpp
===================================================================
--- trunk/flexlay/lib/tile_selection.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tile_selection.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -95,34 +95,34 @@
       || sel.top   > field.get_height() - 1
       || sel.right  <= 0
       || sel.bottom <= 0)
-    { // Selection is empty
-      std::cout << "Error: Invalid selection" << std::endl;
-      TileBrush brush(1, 1);
-      brush.at(0, 0) = 0;
-      brush.set_opaque();
-      return brush;
-    }
+  { // Selection is empty
+    std::cout << "Error: Invalid selection" << std::endl;
+    TileBrush brush(1, 1);
+    brush.at(0, 0) = 0;
+    brush.set_opaque();
+    return brush;
+  }
   else
-    { // Selection is valid
-      // Cut the selection to the field size
-      sel.left = Math::max(0, sel.left);
-      sel.top  = Math::max(0, sel.top);
+  { // Selection is valid
+    // Cut the selection to the field size
+    sel.left = Math::max(0, sel.left);
+    sel.top  = Math::max(0, sel.top);
 
-      sel.right  = Math::min(sel.right,  field.get_width()); 
-      sel.bottom = Math::min(sel.bottom, field.get_height()); 
+    sel.right  = Math::min(sel.right,  field.get_width()); 
+    sel.bottom = Math::min(sel.bottom, field.get_height()); 
 
-      TileBrush brush(sel.get_width(), 
-                      sel.get_height());
+    TileBrush brush(sel.get_width(), 
+                    sel.get_height());
 
-      for(int y = sel.top; y < sel.bottom; ++y)
-        for(int x = sel.left; x < sel.right; ++x)
-          {
-            brush.at(x - sel.left, 
-                     y - sel.top) = field.at(x, y);
-          }
+    for(int y = sel.top; y < sel.bottom; ++y)
+      for(int x = sel.left; x < sel.right; ++x)
+      {
+        brush.at(x - sel.left, 
+                 y - sel.top) = field.at(x, y);
+      }
 
-      return brush;
-    }
+    return brush;
+  }
 }
 
 CL_Rect

Modified: trunk/flexlay/lib/tile_selector.cpp
===================================================================
--- trunk/flexlay/lib/tile_selector.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tile_selector.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -68,74 +68,74 @@
 TileSelector::mouse_up(const CL_InputEvent& event)
 {
   if (event.id == CL_MOUSE_MIDDLE)
-    {
-      scrolling = false;
-      release_mouse();
-    }
+  {
+    scrolling = false;
+    release_mouse();
+  }
   else if (event.id == CL_MOUSE_RIGHT)
-    {
-      release_mouse();
-      region_select = false;
+  {
+    release_mouse();
+    region_select = false;
 
-      CL_Rect selection = get_selection();
-      //selection.bottom = Math::mid(0, selection.right, width);
+    CL_Rect selection = get_selection();
+    //selection.bottom = Math::mid(0, selection.right, width);
 
-      TileBrush brush(selection.get_width(), selection.get_height());
-      brush.set_transparent();
+    TileBrush brush(selection.get_width(), selection.get_height());
+    brush.set_transparent();
 
-      for(int y = 0; y < selection.get_height(); ++y)
-        for(int x = 0; x < selection.get_width(); ++x)
-          {
-            int tile = (selection.top + y) * width + (selection.left + x);
+    for(int y = 0; y < selection.get_height(); ++y)
+      for(int x = 0; x < selection.get_width(); ++x)
+      {
+        int tile = (selection.top + y) * width + (selection.left + x);
 
-            if (tile >= 0 && tile < int(tiles.size()))
-              brush.at(x, y) = tiles[tile];
-            else
-              brush.at(x, y) = 0;
-          }
+        if (tile >= 0 && tile < int(tiles.size()))
+          brush.at(x, y) = tiles[tile];
+        else
+          brush.at(x, y) = 0;
+      }
 
-      TileMapPaintTool::current().set_brush(brush);
-    }
+    TileMapPaintTool::current().set_brush(brush);
+  }
 }
 
 void
 TileSelector::mouse_down(const CL_InputEvent& event)
 {
   if (event.id == CL_MOUSE_LEFT)
-    {
-      TileBrush brush(1, 1);
+  {
+    TileBrush brush(1, 1);
 
-      brush.set_opaque();
-      if (mouse_over_tile >= 0 && mouse_over_tile < int(tiles.size()))
-        brush.at(0, 0) = tiles[mouse_over_tile];
-      else
-        brush.at(0, 0) = 0;
+    brush.set_opaque();
+    if (mouse_over_tile >= 0 && mouse_over_tile < int(tiles.size()))
+      brush.at(0, 0) = tiles[mouse_over_tile];
+    else
+      brush.at(0, 0) = 0;
 
-      TileMapPaintTool::current().set_brush(brush);
-    }
+    TileMapPaintTool::current().set_brush(brush);
+  }
   else if (event.id == CL_MOUSE_RIGHT) 
-    {
-      region_select = true;
-      region_select_start = current_pos;
-      capture_mouse();
-    }
+  {
+    region_select = true;
+    region_select_start = current_pos;
+    capture_mouse();
+  }
   else if (event.id == CL_MOUSE_MIDDLE)
-    {
-      scrolling = true;
-      mouse_pos = event.mouse_pos;
-      old_offset = offset;
-      capture_mouse();
-    }
+  {
+    scrolling = true;
+    mouse_pos = event.mouse_pos;
+    old_offset = offset;
+    capture_mouse();
+  }
   else if (event.id == CL_MOUSE_WHEEL_UP)
-    {
-      offset -= static_cast<int>(tileset.get_tile_size()*scale);
-      if (offset < 0)
-        offset = 0;
-    }
+  {
+    offset -= static_cast<int>(tileset.get_tile_size()*scale);
+    if (offset < 0)
+      offset = 0;
+  }
   else if (event.id == CL_MOUSE_WHEEL_DOWN)
-    {
-      offset += static_cast<int>(tileset.get_tile_size()*scale);
-    }
+  {
+    offset += static_cast<int>(tileset.get_tile_size()*scale);
+  }
 }
 
 CL_Point
@@ -153,11 +153,11 @@
   mouse_over_tile = pos.y * width + pos.x;
 
   if (scrolling)
-    {
-      offset = old_offset + (mouse_pos.y - event.mouse_pos.y);
-      if (offset < 0)
-        offset = 0;
-    }
+  {
+    offset = old_offset + (mouse_pos.y - event.mouse_pos.y);
+    if (offset < 0)
+      offset = 0;
+  }
 }
 
 void 
@@ -176,53 +176,53 @@
   
   // Draw tiles
   for(int i = (start_row*width); i < end_index; ++i)
-    {
-      int x = i % width;
-      int y = i / width;
+  {
+    int x = i % width;
+    int y = i / width;
 
-      Tile* tile = tileset.create(tiles[i]);
+    Tile* tile = tileset.create(tiles[i]);
 
-      CL_Rect rect(CL_Point(static_cast<int>(x * tileset.get_tile_size()*scale),
-                            static_cast<int>(y * tileset.get_tile_size()*scale)),
-                   CL_Size(static_cast<int>(tileset.get_tile_size()*scale),
-                           static_cast<int>(tileset.get_tile_size()*scale)));
+    CL_Rect rect(CL_Point(static_cast<int>(x * tileset.get_tile_size()*scale),
+                          static_cast<int>(y * tileset.get_tile_size()*scale)),
+                 CL_Size(static_cast<int>(tileset.get_tile_size()*scale),
+                         static_cast<int>(tileset.get_tile_size()*scale)));
 
-      if (tile)
-        {
-          CL_Sprite sprite = tile->get_sprite();
+    if (tile)
+    {
+      CL_Sprite sprite = tile->get_sprite();
 
-          sprite.set_scale(scale, scale);
+      sprite.set_scale(scale, scale);
 
-          sprite.draw(static_cast<int>(x * tileset.get_tile_size()*scale), 
-                      static_cast<int>(y * tileset.get_tile_size()*scale));
+      sprite.draw(static_cast<int>(x * tileset.get_tile_size()*scale), 
+                  static_cast<int>(y * tileset.get_tile_size()*scale));
 
-          // Use grid in the tileselector
-          //CL_Display::draw_rect(rect, CL_Color(0,0,0,128));
-        }
+      // Use grid in the tileselector
+      //CL_Display::draw_rect(rect, CL_Color(0,0,0,128));
+    }
 
-      if (brush.get_width() == 1 && brush.get_height() == 1
-          && brush.at(0, 0) == tiles[i])
-        {
-          CL_Display::fill_rect(rect,
-                                CL_Color(0,0,255, 100));
-        }
-      else if (mouse_over_tile == int(i) && has_mouse_over())
-        {
-          CL_Display::fill_rect(rect, CL_Color(0,0,255, 20));
-        }
+    if (brush.get_width() == 1 && brush.get_height() == 1
+        && brush.at(0, 0) == tiles[i])
+    {
+      CL_Display::fill_rect(rect,
+                            CL_Color(0,0,255, 100));
     }
+    else if (mouse_over_tile == int(i) && has_mouse_over())
+    {
+      CL_Display::fill_rect(rect, CL_Color(0,0,255, 20));
+    }
+  }
 
   if (region_select)
-    {
-      CL_Rect rect = get_selection();
+  {
+    CL_Rect rect = get_selection();
 
-      rect.top    *= static_cast<int>(tileset.get_tile_size()*scale);
-      rect.bottom *= static_cast<int>(tileset.get_tile_size()*scale);
-      rect.left   *= static_cast<int>(tileset.get_tile_size()*scale);
-      rect.right  *= static_cast<int>(tileset.get_tile_size()*scale);
+    rect.top    *= static_cast<int>(tileset.get_tile_size()*scale);
+    rect.bottom *= static_cast<int>(tileset.get_tile_size()*scale);
+    rect.left   *= static_cast<int>(tileset.get_tile_size()*scale);
+    rect.right  *= static_cast<int>(tileset.get_tile_size()*scale);
 
-      CL_Display::fill_rect(rect, CL_Color(0,0,255, 100));
-    }
+    CL_Display::fill_rect(rect, CL_Color(0,0,255, 100));
+  }
   
   CL_Display::pop_modelview();
   CL_Display::pop_cliprect();

Modified: trunk/flexlay/lib/tilemap_layer.cpp
===================================================================
--- trunk/flexlay/lib/tilemap_layer.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tilemap_layer.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -62,8 +62,8 @@
 
 /*TilemapLayer::TilemapLayer(const SharedPtr<TilemapLayerImpl>& i)
   : impl(i)
-{
-}*/
+  {
+  }*/
 
 TilemapLayer::TilemapLayer(Tileset tileset_, int w,  int h)
   : impl(new TilemapLayerImpl())
@@ -116,66 +116,66 @@
   int end_y   = std::min(this->field.get_height(), rect.bottom / tile_size + 1);
 
   if (foreground_color != CL_Color(255, 255, 255, 255))
-    {
-      for (int y = start_y; y < end_y; ++y)
-        for (int x = start_x; x < end_x; ++x)
-          {
-            int tile_id = this->field.at(x, y);
-            if (tile_id)
-              {
-                Tile* tile = tileset.create(tile_id);
-                if (tile) // skip transparent tile for faster draw
-                  {           
-                    CL_Sprite sprite = tile->get_sprite();
-                    sprite.set_color(foreground_color);
-                    sprite.draw(x * tile_size, y * tile_size, gc);
+  {
+    for (int y = start_y; y < end_y; ++y)
+      for (int x = start_x; x < end_x; ++x)
+      {
+        int tile_id = this->field.at(x, y);
+        if (tile_id)
+        {
+          Tile* tile = tileset.create(tile_id);
+          if (tile) // skip transparent tile for faster draw
+          {           
+            CL_Sprite sprite = tile->get_sprite();
+            sprite.set_color(foreground_color);
+            sprite.draw(x * tile_size, y * tile_size, gc);
       
-                    if (draw_attribute)
-                      CL_Display::fill_rect(CL_Rect(CL_Point(x, y), CL_Size(tileset.get_tile_size(),
-                                                                            tileset.get_tile_size())),
-                                            tile->get_attribute_color());
-                  }
-              }
+            if (draw_attribute)
+              CL_Display::fill_rect(CL_Rect(CL_Point(x, y), CL_Size(tileset.get_tile_size(),
+                                                                    tileset.get_tile_size())),
+                                    tile->get_attribute_color());
           }
-    }
+        }
+      }
+  }
   else
-    {
-      for (int y = start_y; y < end_y; ++y)
-        for (int x = start_x; x < end_x; ++x)
-          {
-            int tile_id = this->field.at(x, y);
-            if (tile_id) // skip transparent tile for faster draw
-              {
-                Tile* tile = tileset.create(this->field.at(x, y));
-                if (tile)
-                  {           
-                    tile->get_sprite().draw(x * tile_size, y * tile_size, gc);
+  {
+    for (int y = start_y; y < end_y; ++y)
+      for (int x = start_x; x < end_x; ++x)
+      {
+        int tile_id = this->field.at(x, y);
+        if (tile_id) // skip transparent tile for faster draw
+        {
+          Tile* tile = tileset.create(this->field.at(x, y));
+          if (tile)
+          {           
+            tile->get_sprite().draw(x * tile_size, y * tile_size, gc);
       
-                    if (draw_attribute)
-                      CL_Display::fill_rect(CL_Rect(CL_Point(x, y), CL_Size(tileset.get_tile_size(),
-                                                                            tileset.get_tile_size())),
-                                            tile->get_attribute_color());
-                  }
-              }
+            if (draw_attribute)
+              CL_Display::fill_rect(CL_Rect(CL_Point(x, y), CL_Size(tileset.get_tile_size(),
+                                                                    tileset.get_tile_size())),
+                                    tile->get_attribute_color());
           }
-    }
+        }
+      }
+  }
 
   if (this->draw_grid)
-    {
-      for (int y = start_y; y <= end_y; ++y)
-        CL_Display::draw_line(start_x * tile_size,
-                              y       * tile_size,
-                              end_x   * tile_size,
-                              y       * tile_size, 
-                              y % 2 ? CL_Color(150, 150, 150) : CL_Color(255, 255, 255));
+  {
+    for (int y = start_y; y <= end_y; ++y)
+      CL_Display::draw_line(start_x * tile_size,
+                            y       * tile_size,
+                            end_x   * tile_size,
+                            y       * tile_size, 
+                            y % 2 ? CL_Color(150, 150, 150) : CL_Color(255, 255, 255));
   
-      for (int x = start_x; x <= end_x; ++x)
-        CL_Display::draw_line(x       * tile_size,
-                              start_y * tile_size,
-                              x       * tile_size,
-                              end_y   * tile_size, 
-                              x % 2 ? CL_Color(150, 150, 150) : CL_Color(255, 255, 255));
-    }
+    for (int x = start_x; x <= end_x; ++x)
+      CL_Display::draw_line(x       * tile_size,
+                            start_y * tile_size,
+                            x       * tile_size,
+                            end_y   * tile_size, 
+                            x % 2 ? CL_Color(150, 150, 150) : CL_Color(255, 255, 255));
+  }
 
   CL_Display::flush();
 }
@@ -201,9 +201,9 @@
 {
   if (pos.x >= 0 && pos.x < impl->field.get_width()
       && pos.y >= 0 && pos.y < impl->field.get_height())
-    {
-      impl->field.at(pos.x, pos.y) = id;
-    }
+  {
+    impl->field.at(pos.x, pos.y) = id;
+  }
 }
 
 void
@@ -223,12 +223,12 @@
 
   for (int y = start_y; y < end_y; ++y)
     for (int x = start_x; x < end_x; ++x)
+    {
+      if (brush.is_opaque() || brush.at(x, y) != 0)
       {
-        if (brush.is_opaque() || brush.at(x, y) != 0)
-          {
-            field->at(pos.x + x, pos.y + y) = brush.at(x, y);
-          }
+        field->at(pos.x + x, pos.y + y) = brush.at(x, y);
       }
+    }
 }
 
 void
@@ -274,32 +274,32 @@
 
     // Draw a nice gradient
     for(int y = 0; y < height; ++y)
+    {
+      for (int x = 0; x < width; ++x)
       {
-        for (int x = 0; x < width; ++x)
-          {
-            buf[4*(y*width + x) + 0] = 255;
-            buf[4*(y*width + x) + 1] = 255;
-            buf[4*(y*width + x) + 2] = 255*y/height;
-            buf[4*(y*width + x) + 3] = 255*y/height;
-          }
+        buf[4*(y*width + x) + 0] = 255;
+        buf[4*(y*width + x) + 1] = 255;
+        buf[4*(y*width + x) + 2] = 255*y/height;
+        buf[4*(y*width + x) + 3] = 255*y/height;
       }
+    }
     pixelbuffer.unlock();
   }
 
   for (int y = 0; y < get_height(); ++y)
     for (int x = 0; x < get_width(); ++x)
+    {
+      Tile* tile = impl->tileset.create(impl->field.at(x, y));
+
+      if (tile)
       {
-        Tile* tile = impl->tileset.create(impl->field.at(x, y));
-
-        if (tile)
-          {
-            CL_PixelBuffer buf = tile->get_pixelbuffer();
-            if (buf)
-              {
-                blit(pixelbuffer, buf, x*tile_size, y*tile_size);
-              }
-          }
+        CL_PixelBuffer buf = tile->get_pixelbuffer();
+        if (buf)
+        {
+          blit(pixelbuffer, buf, x*tile_size, y*tile_size);
+        }
       }
+    }
 
   return pixelbuffer;
 }
@@ -403,7 +403,7 @@
 Layer
 TilemapLayer::to_layer()
 {
-   return Layer(impl);
+  return Layer(impl);
 }
 
 void

Modified: trunk/flexlay/lib/tilemap_layer.hpp
===================================================================
--- trunk/flexlay/lib/tilemap_layer.hpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tilemap_layer.hpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -53,7 +53,7 @@
 
   /** @param pos position of the old map in the new resized one
       @param size height of the new map */
- void resize(const CL_Size& size, const CL_Point& point);
+  void resize(const CL_Size& size, const CL_Point& point);
 
   const std::vector<int>& get_data();
   void set_data(std::vector<int> d);

Modified: trunk/flexlay/lib/tileset.cpp
===================================================================
--- trunk/flexlay/lib/tileset.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tileset.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -37,9 +37,9 @@
   ~TilesetImpl()
   {
     for(Tiles::iterator i = tiles.begin(); i != tiles.end(); ++i)
-      {
-        delete *i;
-      }
+    {
+      delete *i;
+    }
   }
 
   TileIds tile_ids;

Modified: trunk/flexlay/lib/titlebar.cpp
===================================================================
--- trunk/flexlay/lib/titlebar.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/titlebar.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -58,40 +58,40 @@
 TitlebarImpl::on_mouse_up(const CL_InputEvent& event)
 {
   if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed = false;
-      parent->release_mouse();
-    }
+  {
+    pressed = false;
+    parent->release_mouse();
+  }
 }
 
 void
 TitlebarImpl::on_mouse_down(const CL_InputEvent& event)
 {
   if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed   = true;
-      click_pos = event.mouse_pos;
-      parent->capture_mouse();
-      window->raise();
+  {
+    pressed   = true;
+    click_pos = event.mouse_pos;
+    parent->capture_mouse();
+    window->raise();
 
-      old_pos = window->get_position();
-      click_pos.x += old_pos.left;
-      click_pos.y += old_pos.top;
-    } 
+    old_pos = window->get_position();
+    click_pos.x += old_pos.left;
+    click_pos.y += old_pos.top;
+  } 
 }
 
 void
 TitlebarImpl::on_mouse_move(const CL_InputEvent& event)
 {
   if(pressed)
-    {
-      CL_Rect rect = window->get_position();
+  {
+    CL_Rect rect = window->get_position();
 
-      CL_Point move(old_pos.left - (click_pos.x - (rect.left + event.mouse_pos.x)), 
-                    old_pos.top  - (click_pos.y - (rect.top  + event.mouse_pos.y)));
+    CL_Point move(old_pos.left - (click_pos.x - (rect.left + event.mouse_pos.x)), 
+                  old_pos.top  - (click_pos.y - (rect.top  + event.mouse_pos.y)));
 
-      window->set_position(move.x, move.y);
-    }
+    window->set_position(move.x, move.y);
+  }
 }
 
 void
@@ -102,18 +102,18 @@
   // FIXME: Hack should be done via has_mouse_over(), but that doesn't include child components
   if (parent->get_parent()->get_position().is_inside(CL_Point(CL_Mouse::get_x(), 
                                                               CL_Mouse::get_y())))
-      //parent->get_parent()->has_mouse_over())
-    {
-      CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
-                                    CL_Size(parent->get_width()-1, parent->get_height())), 
-                            CL_Color(250, 250, 250));
-    }
+    //parent->get_parent()->has_mouse_over())
+  {
+    CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
+                                  CL_Size(parent->get_width()-1, parent->get_height())), 
+                          CL_Color(250, 250, 250));
+  }
   else
-    {
-      CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
-                                    CL_Size(parent->get_width()-1, parent->get_height())), 
-                            CL_Color(240, 240, 240));
-    }
+  {
+    CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
+                                  CL_Size(parent->get_width()-1, parent->get_height())), 
+                          CL_Color(240, 240, 240));
+  }
 
   Fonts::verdana11.draw(4, 0, title);
 

Modified: trunk/flexlay/lib/tools/layer_move_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/layer_move_tool.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tools/layer_move_tool.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -43,10 +43,10 @@
     EditorMap parent = EditorMapComponent::current()->get_workspace().get_map();
 
     for(int i = 0; i < parent.get_layer_count(); ++i)
-      {
-        if (parent.get_layer(i).get_bounding_rect().is_inside(CL_Point(pos)))
-          layer = parent.get_layer(i);
-      }
+    {
+      if (parent.get_layer(i).get_bounding_rect().is_inside(CL_Point(pos)))
+        layer = parent.get_layer(i);
+    }
 
     return layer;
   }
@@ -54,28 +54,28 @@
   void draw() 
   {
     for(int i = 0; i < EditorMapComponent::current()->get_workspace().get_map().get_layer_count(); ++i)
+    {
+      Layer layer = EditorMapComponent::current()->get_workspace().get_map().get_layer(i);
+      if (layer.has_bounding_rect())
       {
-        Layer layer = EditorMapComponent::current()->get_workspace().get_map().get_layer(i);
-        if (layer.has_bounding_rect())
-          {
-            CL_Rect rect = layer.get_bounding_rect();
-            CL_Display::draw_line(rect.left, rect.top, rect.right, rect.bottom,
-                                  CL_Color(0, 255, 255));
-            CL_Display::draw_line(rect.left, rect.bottom, rect.right, rect.top,
-                                  CL_Color(0, 255, 255));
-          }
+        CL_Rect rect = layer.get_bounding_rect();
+        CL_Display::draw_line(rect.left, rect.top, rect.right, rect.bottom,
+                              CL_Color(0, 255, 255));
+        CL_Display::draw_line(rect.left, rect.bottom, rect.right, rect.top,
+                              CL_Color(0, 255, 255));
       }
+    }
   }
 
   void on_mouse_up  (const CL_InputEvent& event) 
   {
     if (!layer.is_null())
-      {
-        scrolling = false;
-        update(event);
-        EditorMapComponent::current()->release_mouse();
-        layer = Layer();
-      }
+    {
+      scrolling = false;
+      update(event);
+      EditorMapComponent::current()->release_mouse();
+      layer = Layer();
+    }
   }
 
   void on_mouse_down(const CL_InputEvent& event)
@@ -85,33 +85,33 @@
 
     layer = find_closed_layer(pos);
     if (!layer.is_null())
-      {
-        scrolling = true;
-        old_trans_offset = layer.get_pos();
-        click_pos = pos;
-        EditorMapComponent::current()->capture_mouse();
-      }
+    {
+      scrolling = true;
+      old_trans_offset = layer.get_pos();
+      click_pos = pos;
+      EditorMapComponent::current()->capture_mouse();
+    }
   }
 
   void on_mouse_move(const CL_InputEvent& event)
   {
     if (!layer.is_null())
+    {
+      if (scrolling)
       {
-        if (scrolling)
-          {
-            update(event);
-          }
-      }    
+        update(event);
+      }
+    }    
   }
 
   void update(const CL_InputEvent& event)
   {
     if (!layer.is_null())
-      {
-        EditorMapComponent* parent = EditorMapComponent::current();
-        CL_Pointf pos = parent->screen2world(event.mouse_pos);
-        layer.set_pos(old_trans_offset + (pos - click_pos));
-      }
+    {
+      EditorMapComponent* parent = EditorMapComponent::current();
+      CL_Pointf pos = parent->screen2world(event.mouse_pos);
+      layer.set_pos(old_trans_offset + (pos - click_pos));
+    }
   }
 };
 

Modified: trunk/flexlay/lib/tools/objmap_select_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/objmap_select_tool.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tools/objmap_select_tool.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -108,13 +108,13 @@
 ObjMapSelectToolImpl::draw()
 {
   for (ObjMapSelectTool::Selection::iterator i = selection.begin(); i != selection.end(); ++i)
-    {
-      //      (*i).draw();
-      CL_Display::draw_rect((*i).get_bound_rect(), CL_Color(255, 0, 0));
-    }
+  {
+    //      (*i).draw();
+    CL_Display::draw_rect((*i).get_bound_rect(), CL_Color(255, 0, 0));
+  }
 
   switch(state)
-    {
+  {
     case DRAG:
       break;
     case SELECT:
@@ -123,7 +123,7 @@
       break;
     default:
       break;
-    }
+  }
 }
 
 void
@@ -136,16 +136,16 @@
   CL_Pointf pos = parent->screen2world(event.mouse_pos);
 
   switch (event.id)
-    {
+  {
     case CL_MOUSE_LEFT:
       switch(state)
-        {
+      {
         case DRAG:
           if (move_command)
-            {
-              Workspace::current().get_map().execute(move_command->to_command());
-              move_command = 0;
-            }
+          {
+            Workspace::current().get_map().execute(move_command->to_command());
+            move_command = 0;
+          }
           state = NONE;
           parent->release_mouse();
           break;
@@ -164,22 +164,22 @@
 
         default:
           break;
-        }
+      }
       break;
 
     case CL_MOUSE_RIGHT:
-      {
-        on_right_click(event.mouse_pos.x + parent->get_screen_rect().left,
-                       event.mouse_pos.y + parent->get_screen_rect().top);
-        /*
+    {
+      on_right_click(event.mouse_pos.x + parent->get_screen_rect().left,
+                     event.mouse_pos.y + parent->get_screen_rect().top);
+      /*
         PopupMenu* menu = new PopupMenu(CL_Point(event.mouse_pos.x + parent->get_screen_rect().left,
-                                                 event.mouse_pos.y + parent->get_screen_rect().top), 
-                                        GUIManager::current()->get_component());
+        event.mouse_pos.y + parent->get_screen_rect().top), 
+        GUIManager::current()->get_component());
 
-                                        on_popup_menu_display(menu->get_menu());*/
-      }
-      break;
+        on_popup_menu_display(menu->get_menu());*/
     }
+    break;
+  }
 }
 
 void
@@ -191,74 +191,74 @@
   CL_Pointf pos = parent->screen2world(event.mouse_pos);
       
   switch (event.id)
-    {
+  {
     case CL_MOUSE_LEFT:
       switch(state)
-        {
+      {
         default:
           control_point = objmap.find_control_point(pos);
 
           if (!control_point.is_null())
-            {
-              state = DRAG;
-              parent->capture_mouse();
-              offset = pos - control_point.get_pos();
-              drag_start = pos;
-            }
+          {
+            state = DRAG;
+            parent->capture_mouse();
+            offset = pos - control_point.get_pos();
+            drag_start = pos;
+          }
           else
+          {
+            ObjMapObject obj = objmap.find_object(pos);
+
+            if (!obj.is_null())
             {
-              ObjMapObject obj = objmap.find_object(pos);
+              if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT))
+              {
+                ObjMapSelectTool::Selection::iterator i
+                  = std::find(selection.begin(), selection.end(), obj);
+                if (i == selection.end())
+                  selection.push_back(obj);
+                else
+                  selection.erase(i);
 
-              if (!obj.is_null())
-                {
-                  if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT))
-                    {
-                      ObjMapSelectTool::Selection::iterator i
-                        = std::find(selection.begin(), selection.end(), obj);
-                      if (i == selection.end())
-                        selection.push_back(obj);
-                      else
-                        selection.erase(i);
+                on_selection_change();
+              }
+              else
+              {
+                state = DRAG;
+                parent->capture_mouse();
+                offset = pos - obj.get_pos();
+                drag_start = pos;
 
-                      on_selection_change();
-                    }
-                  else
-                    {
-                      state = DRAG;
-                      parent->capture_mouse();
-                      offset = pos - obj.get_pos();
-                      drag_start = pos;
+                if (std::find(selection.begin(), selection.end(), obj) == selection.end())
+                { // Clicked object is not in the selection, so we add it
+                  selection.clear();
+                  objmap.delete_control_points();
+                  selection.push_back(obj);
+                  on_selection_change();
+                }
 
-                      if (std::find(selection.begin(), selection.end(), obj) == selection.end())
-                        { // Clicked object is not in the selection, so we add it
-                          selection.clear();
-                          objmap.delete_control_points();
-                          selection.push_back(obj);
-                          on_selection_change();
-                        }
-
-                      move_command = new ObjectMoveCommand(objmap);
-                      for (ObjMapSelectTool::Selection::iterator i = selection.begin();
-                           i != selection.end(); ++i)
-                        {
-                          move_command->add_obj(*i);
-                        }
-                    }
-                }
-              else
+                move_command = new ObjectMoveCommand(objmap);
+                for (ObjMapSelectTool::Selection::iterator i = selection.begin();
+                     i != selection.end(); ++i)
                 {
-                  state = SELECT;
-                  selection_rect = CL_Rectf(pos.x, pos.y, pos.x, pos.y);
-                  parent->capture_mouse();
+                  move_command->add_obj(*i);
                 }
+              }
             }
+            else
+            {
+              state = SELECT;
+              selection_rect = CL_Rectf(pos.x, pos.y, pos.x, pos.y);
+              parent->capture_mouse();
+            }
+          }
           break;
-        }
+      }
       break;
 
     case CL_MOUSE_RIGHT:
       break;
-    }
+  }
 }
 
 void
@@ -268,25 +268,25 @@
   CL_Pointf pos = parent->screen2world(event.mouse_pos);
 
   switch(state)
-    {
+  {
     case DRAG:
       if (!control_point.is_null())
-        {
-          control_point.set_pos(pos - offset);
-        }
+      {
+        control_point.set_pos(pos - offset);
+      }
       else
-        {
-          move_command->move_by(pos - drag_start);
-          if (selection.size() == 1)
-            selection.front().update_control_points();
-        }
+      {
+        move_command->move_by(pos - drag_start);
+        if (selection.size() == 1)
+          selection.front().update_control_points();
+      }
       /*
-      for (ObjMapSelectTool::Selection::iterator i = selection.begin(); 
-           i != selection.end(); ++i)
+        for (ObjMapSelectTool::Selection::iterator i = selection.begin(); 
+        i != selection.end(); ++i)
         {
-          (*i).set_pos((*i).get_pos() + (pos - drag_start));
-          // FIXME: Move this into ObjMapObject
-          (*i).sig_move()(*i);
+        (*i).set_pos((*i).get_pos() + (pos - drag_start));
+        // FIXME: Move this into ObjMapObject
+        (*i).sig_move()(*i);
         }*/
       //drag_start = pos;
       break;
@@ -299,7 +299,7 @@
     default:
       // FIXME: Add some kind of highlighting here if mouse is over an object
       break;
-    }
+  }
 }
 
 Tool
@@ -315,9 +315,9 @@
   objmap.delete_control_points();
 
   if (selection.size() == 1)
-    {
-      selection.front().add_control_points();
-    } 
+  {
+    selection.front().add_control_points();
+  } 
 }
 
 /* EOF */

Modified: trunk/flexlay/lib/tools/sketch_stroke_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/sketch_stroke_tool.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tools/sketch_stroke_tool.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -51,52 +51,52 @@
   void draw() 
   {
     if (drawing)
-      {
-        // FIXME: This translation is a bit ugly, layer position should be handled somewhat different
-        CL_Display::push_modelview();
-        CL_Display::add_translate(BitmapLayer::current()->to_object().get_pos().x,
-                                  BitmapLayer::current()->to_object().get_pos().y);
-        stroke.draw(0);
-        CL_Display::pop_modelview();
-      }
+    {
+      // FIXME: This translation is a bit ugly, layer position should be handled somewhat different
+      CL_Display::push_modelview();
+      CL_Display::add_translate(BitmapLayer::current()->to_object().get_pos().x,
+                                BitmapLayer::current()->to_object().get_pos().y);
+      stroke.draw(0);
+      CL_Display::pop_modelview();
+    }
     else
-      {
-        EditorMapComponent* parent = EditorMapComponent::current();
-        CL_Pointf p = parent->screen2world(CL_Point(CL_Mouse::get_x() - parent->get_screen_x(), 
-                                                    CL_Mouse::get_y() - parent->get_screen_y()));
-        CL_Sprite s = DrawerProperties::current()->get_brush().get_sprite();
-        s.set_color(DrawerProperties::current()->get_color());
-        // FIXME: when using mouse 1.0, when tablet .5f
-        s.set_scale(DrawerProperties::current()->get_size()*0.5f, DrawerProperties::current()->get_size()*0.5f);
-        s.set_alpha(0.5);
-        s.draw(p.x, p.y);
-      }
+    {
+      EditorMapComponent* parent = EditorMapComponent::current();
+      CL_Pointf p = parent->screen2world(CL_Point(CL_Mouse::get_x() - parent->get_screen_x(), 
+                                                  CL_Mouse::get_y() - parent->get_screen_y()));
+      CL_Sprite s = DrawerProperties::current()->get_brush().get_sprite();
+      s.set_color(DrawerProperties::current()->get_color());
+      // FIXME: when using mouse 1.0, when tablet .5f
+      s.set_scale(DrawerProperties::current()->get_size()*0.5f, DrawerProperties::current()->get_size()*0.5f);
+      s.set_alpha(0.5);
+      s.draw(p.x, p.y);
+    }
   }
 
   void on_mouse_up  (const CL_InputEvent& event) 
   {
     if (event.id == CL_MOUSE_LEFT && drawing)
-      {
-        drawing = false;
-        EditorMapComponent* parent = EditorMapComponent::current();
-        parent->release_mouse();
+    {
+      drawing = false;
+      EditorMapComponent* parent = EditorMapComponent::current();
+      parent->release_mouse();
         
-        add_dab(event);
+      add_dab(event);
 
-        BitmapLayer::current()->add_stroke(stroke);
-      }    
+      BitmapLayer::current()->add_stroke(stroke);
+    }    
   }
 
   void on_mouse_down(const CL_InputEvent& event) {
     if (event.id == CL_MOUSE_LEFT)
-      {
-        drawing = true;
-        EditorMapComponent* parent = EditorMapComponent::current();
-        parent->capture_mouse();
-        stroke = Stroke();
-        stroke.set_drawer(drawer.clone());
-        add_dab(event);
-      }
+    {
+      drawing = true;
+      EditorMapComponent* parent = EditorMapComponent::current();
+      parent->capture_mouse();
+      stroke = Stroke();
+      stroke.set_drawer(drawer.clone());
+      add_dab(event);
+    }
   }
 
   void add_dab(const CL_InputEvent& event)
@@ -110,23 +110,23 @@
 
     // FIXME: Make tablet configurable
     if (CL_Display::get_current_window()->get_ic()->get_mouse_count() >= 4)
+    {
+      CL_InputDevice tablet = CL_Display::get_current_window()->get_ic()->get_mouse(5);
+
+      if (0)
       {
-        CL_InputDevice tablet = CL_Display::get_current_window()->get_ic()->get_mouse(5);
+        std::cout << "Mouse Count: " << CL_Display::get_current_window()->get_ic()->get_mouse_count() << std::endl;
+        std::cout << tablet.get_name() << ": ";
+        for(int i = 0; i < tablet.get_axis_count(); ++i)
+          std::cout << tablet.get_axis(i) << " ";
+        std::cout << std::endl;
+      }
 
-        if (0)
-          {
-            std::cout << "Mouse Count: " << CL_Display::get_current_window()->get_ic()->get_mouse_count() << std::endl;
-            std::cout << tablet.get_name() << ": ";
-            for(int i = 0; i < tablet.get_axis_count(); ++i)
-              std::cout << tablet.get_axis(i) << " ";
-            std::cout << std::endl;
-          }
+      dab.pressure = tablet.get_axis(2);
+      dab.tilt.x   = tablet.get_axis(3);
+      dab.tilt.y   = tablet.get_axis(4);
+    }
 
-        dab.pressure = tablet.get_axis(2);
-        dab.tilt.x   = tablet.get_axis(3);
-        dab.tilt.y   = tablet.get_axis(4);
-      }
-
     //std::cout << dab.pressure << " " << dab.tilt.x << " " << dab.tilt.y << std::endl;
 
     if (dab.pressure == 0) // most likly we are using the mouse
@@ -138,9 +138,9 @@
   void on_mouse_move(const CL_InputEvent& event) 
   {
     if (drawing)
-      {
-        add_dab(event);
-      }
+    {
+      add_dab(event);
+    }
   }
 };
 

Modified: trunk/flexlay/lib/tools/tilemap_paint_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/tilemap_paint_tool.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tools/tilemap_paint_tool.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -85,7 +85,7 @@
     return;
 
   switch(mode)
-    {
+  {
     case TileMapPaintToolImpl::SELECTING:
       if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT))
         selection.draw(CL_Color(255,  128, 128, 100));
@@ -99,38 +99,38 @@
       // Draw the brush:
       for(int y = 0; y < brush.get_height(); ++y)
         for(int x = 0; x < brush.get_width(); ++x)
+        {
+          Tile* tile = tilemap.get_tileset().create(brush.at(x, y));
+                
+          if (tile)
           {
-            Tile* tile = tilemap.get_tileset().create(brush.at(x, y));
-                
-            if (tile)
-              {
-                CL_Sprite sprite = tile->get_sprite();
-                sprite.set_alpha(0.5f);
-                sprite.draw((current_tile.x + x) * tile_size, 
-                            (current_tile.y + y) * tile_size);
+            CL_Sprite sprite = tile->get_sprite();
+            sprite.set_alpha(0.5f);
+            sprite.draw((current_tile.x + x) * tile_size, 
+                        (current_tile.y + y) * tile_size);
 
-                CL_Display::fill_rect(CL_Rect(CL_Point((current_tile.x + x) * tile_size, 
-                                                       (current_tile.y + y) * tile_size),
-                                              CL_Size(tile_size, tile_size)),
-                                      CL_Color(255, 255, 255, 100));
-              }
-            else if (brush.is_opaque())
-              {
-                CL_Display::fill_rect(CL_Rect(CL_Point((current_tile.x + x) * tile_size, 
-                                                       (current_tile.y + y) * tile_size),
-                                              CL_Size(tile_size, tile_size)),
-                                      CL_Color(255, 255, 255, 100));
-              }
-            else
-              {
-                CL_Display::fill_rect(CL_Rect(CL_Point((current_tile.x + x) * tile_size, 
-                                                       (current_tile.y + y) * tile_size),
-                                              CL_Size(tile_size, tile_size)),
-                                      CL_Color(255, 255, 255, 50));
-              }
+            CL_Display::fill_rect(CL_Rect(CL_Point((current_tile.x + x) * tile_size, 
+                                                   (current_tile.y + y) * tile_size),
+                                          CL_Size(tile_size, tile_size)),
+                                  CL_Color(255, 255, 255, 100));
           }
+          else if (brush.is_opaque())
+          {
+            CL_Display::fill_rect(CL_Rect(CL_Point((current_tile.x + x) * tile_size, 
+                                                   (current_tile.y + y) * tile_size),
+                                          CL_Size(tile_size, tile_size)),
+                                  CL_Color(255, 255, 255, 100));
+          }
+          else
+          {
+            CL_Display::fill_rect(CL_Rect(CL_Point((current_tile.x + x) * tile_size, 
+                                                   (current_tile.y + y) * tile_size),
+                                          CL_Size(tile_size, tile_size)),
+                                  CL_Color(255, 255, 255, 50));
+          }
+        }
       break;
-    }
+  }
 }
 
 const TileBrush& 
@@ -145,36 +145,36 @@
   TilemapLayer tilemap = TilemapLayer::current();
 
   if (!tilemap.is_null())
+  {
+    EditorMapComponent* parent = EditorMapComponent::current();
+    CL_Point pos = tilemap.world2tile(parent->screen2world(event.mouse_pos));
+
+    switch (mode)
     {
-      EditorMapComponent* parent = EditorMapComponent::current();
-      CL_Point pos = tilemap.world2tile(parent->screen2world(event.mouse_pos));
-
-      switch (mode)
+      case TileMapPaintToolImpl::NONE:
+        switch (event.id)
         {
-        case TileMapPaintToolImpl::NONE:
-          switch (event.id)
-            {
-            case CL_MOUSE_LEFT:
-              mode = TileMapPaintToolImpl::PAINTING;
-              parent->capture_mouse();
-              command = new PaintCommand(tilemap, brush);
-              command->add_point(pos);
-              last_draw = pos;
-              break;
+          case CL_MOUSE_LEFT:
+            mode = TileMapPaintToolImpl::PAINTING;
+            parent->capture_mouse();
+            command = new PaintCommand(tilemap, brush);
+            command->add_point(pos);
+            last_draw = pos;
+            break;
     
-            case CL_MOUSE_RIGHT:
-              mode = TileMapPaintToolImpl::SELECTING;
-              parent->capture_mouse();
+          case CL_MOUSE_RIGHT:
+            mode = TileMapPaintToolImpl::SELECTING;
+            parent->capture_mouse();
 
-              selection.start(tilemap, pos);
-              break;
-            }
-          break;
+            selection.start(tilemap, pos);
+            break;
+        }
+        break;
 
-        default:
-          break;
-        }
+      default:
+        break;
     }
+  }
 }
  
 void
@@ -183,30 +183,30 @@
   TilemapLayer tilemap = TilemapLayer::current();
 
   if (!tilemap.is_null())
+  {
+    EditorMapComponent* parent = EditorMapComponent::current();
+    current_tile = tilemap.world2tile(parent->screen2world(event.mouse_pos));
+
+    switch (mode)
     {
-      EditorMapComponent* parent = EditorMapComponent::current();
-      current_tile = tilemap.world2tile(parent->screen2world(event.mouse_pos));
-
-      switch (mode)
+      case PAINTING:
+        if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT) ||
+            (current_tile.x % brush.get_width())  == (last_draw.x % brush.get_width()) &&
+            (current_tile.y % brush.get_height() == (last_draw.y % brush.get_height())))
         {
-        case PAINTING:
-          if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT) ||
-              (current_tile.x % brush.get_width())  == (last_draw.x % brush.get_width()) &&
-              (current_tile.y % brush.get_height() == (last_draw.y % brush.get_height())))
-            {
-              command->add_point(current_tile);
-              last_draw = current_tile;
-            }
-          break;
+          command->add_point(current_tile);
+          last_draw = current_tile;
+        }
+        break;
     
-        case SELECTING:
-          selection.update(current_tile);
-          break;
+      case SELECTING:
+        selection.update(current_tile);
+        break;
       
-        default:
-          break;
-        }
+      default:
+        break;
     }
+  }
 }
 
 void
@@ -215,60 +215,60 @@
   TilemapLayer tilemap = TilemapLayer::current();
 
   if (!tilemap.is_null())
-    {
-      EditorMapComponent::current()->get_workspace().get_map().modify();
+  {
+    EditorMapComponent::current()->get_workspace().get_map().modify();
 
-      EditorMapComponent* parent = EditorMapComponent::current();
-      current_tile = tilemap.world2tile(parent->screen2world(event.mouse_pos));
+    EditorMapComponent* parent = EditorMapComponent::current();
+    current_tile = tilemap.world2tile(parent->screen2world(event.mouse_pos));
 
-      switch (event.id)
+    switch (event.id)
+    {
+      case CL_MOUSE_LEFT:
+        if (mode == PAINTING)
         {
-        case CL_MOUSE_LEFT:
-          if (mode == PAINTING)
-            {
-              parent->release_mouse();
-              mode = NONE;
+          parent->release_mouse();
+          mode = NONE;
 
-              if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT) ||
-                  (current_tile.x % brush.get_width()) == (last_draw.x % brush.get_width()) &&
-                  (current_tile.y % brush.get_height() == (last_draw.y % brush.get_height())))
-                {
-                  command->add_point(current_tile);
-                }
+          if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT) ||
+              (current_tile.x % brush.get_width()) == (last_draw.x % brush.get_width()) &&
+              (current_tile.y % brush.get_height() == (last_draw.y % brush.get_height())))
+          {
+            command->add_point(current_tile);
+          }
 
-              Workspace::current().get_map().execute(command->to_command());
-              command = 0;
+          Workspace::current().get_map().execute(command->to_command());
+          command = 0;
 
-              tilemap.draw_tile(brush, current_tile);
-              last_draw = CL_Point(-1, -1);
-            }
-          break;
+          tilemap.draw_tile(brush, current_tile);
+          last_draw = CL_Point(-1, -1);
+        }
+        break;
     
-        case CL_MOUSE_RIGHT:
-          if (mode == SELECTING)
-            {
-              parent->release_mouse();
-              mode = NONE;
+      case CL_MOUSE_RIGHT:
+        if (mode == SELECTING)
+        {
+          parent->release_mouse();
+          mode = NONE;
 
-              selection.update(current_tile);
-              brush = selection.get_brush(*tilemap.get_field());
+          selection.update(current_tile);
+          brush = selection.get_brush(*tilemap.get_field());
 
-              if ((brush.get_width() > 1 || brush.get_height() > 1)
-                  && !CL_Keyboard::get_keycode(CL_KEY_LSHIFT))
-                {
-                  brush.set_transparent();
-                  brush.auto_crop();
-                }
-              else
-                {
-                  brush.set_opaque();
-                }
+          if ((brush.get_width() > 1 || brush.get_height() > 1)
+              && !CL_Keyboard::get_keycode(CL_KEY_LSHIFT))
+          {
+            brush.set_transparent();
+            brush.auto_crop();
+          }
+          else
+          {
+            brush.set_opaque();
+          }
 
-              selection.clear();
-            }
-          break;
+          selection.clear();
         }
+        break;
     }
+  }
 }
 
 void

Modified: trunk/flexlay/lib/tools/tilemap_select_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/tilemap_select_tool.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tools/tilemap_select_tool.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -54,9 +54,9 @@
 TileMapSelectToolImpl::draw()
 {
   if (selection.is_active())
-    {
-      selection.draw();
-    }
+  {
+    selection.draw();
+  }
 }
 
 void
@@ -65,14 +65,14 @@
   EditorMapComponent* parent = EditorMapComponent::current();
 
   switch (event.id)
-    {
+  {
     case CL_MOUSE_LEFT:
       creating_selection = false;
       parent->release_mouse();
 
       selection.update(TilemapLayer::current().world2tile(parent->screen2world(event.mouse_pos)));
       break;
-    }
+  }
 }
 
 void
@@ -81,21 +81,21 @@
   EditorMapComponent* parent = EditorMapComponent::current();
 
   switch (event.id)
+  {
+    case CL_MOUSE_LEFT:
     {
-    case CL_MOUSE_LEFT:
-      {
-        creating_selection = true;
-        parent->capture_mouse();
-        TilemapLayer tilemap = TilemapLayer::current();
-        selection.start(tilemap, tilemap.world2tile(parent->screen2world(event.mouse_pos)));
-      }
-      break;
+      creating_selection = true;
+      parent->capture_mouse();
+      TilemapLayer tilemap = TilemapLayer::current();
+      selection.start(tilemap, tilemap.world2tile(parent->screen2world(event.mouse_pos)));
+    }
+    break;
       
     case CL_MOUSE_RIGHT:
       if (!creating_selection)
         selection.clear();
       break;
-    }
+  }
 }
 
 void
@@ -104,9 +104,9 @@
   EditorMapComponent* parent = EditorMapComponent::current();
 
   if (creating_selection)
-    {
-      selection.update(TilemapLayer::current().world2tile(parent->screen2world(event.mouse_pos)));
-    }
+  {
+    selection.update(TilemapLayer::current().world2tile(parent->screen2world(event.mouse_pos)));
+  }
 }
 
 TileBrush

Modified: trunk/flexlay/lib/tools/workspace_move_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/workspace_move_tool.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tools/workspace_move_tool.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -61,9 +61,9 @@
 WorkspaceMoveToolImpl::on_mouse_move(const CL_InputEvent& event)
 {
   if (scrolling)
-    {
-      update(event);
-    } 
+  {
+    update(event);
+  } 
 }
 
 void

Modified: trunk/flexlay/lib/tools/zoom2_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/zoom2_tool.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tools/zoom2_tool.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -69,20 +69,20 @@
 Zoom2ToolImpl::on_mouse_move(const CL_InputEvent& event)
 {
   if (active)
-    {
-      GraphicContextState& gc = EditorMapComponent::current()->get_gc_state();
+  {
+    GraphicContextState& gc = EditorMapComponent::current()->get_gc_state();
 
-      CL_Point zoom_pos(gc.get_width()/2,
-                        gc.get_height()/2);
+    CL_Point zoom_pos(gc.get_width()/2,
+                      gc.get_height()/2);
       
-      float factor = (event.mouse_pos.y - click_pos.y) / 20.0f;
-      if (factor > 0)
-        gc.set_zoom(zoom_pos, old_zoom * pow(1.25f, factor));
-      else if (factor < 0)
-        gc.set_zoom(zoom_pos, old_zoom / pow(1.25f, -factor));
-      else
-        gc.set_zoom(zoom_pos, old_zoom);
-    }
+    float factor = (event.mouse_pos.y - click_pos.y) / 20.0f;
+    if (factor > 0)
+      gc.set_zoom(zoom_pos, old_zoom * pow(1.25f, factor));
+    else if (factor < 0)
+      gc.set_zoom(zoom_pos, old_zoom / pow(1.25f, -factor));
+    else
+      gc.set_zoom(zoom_pos, old_zoom);
+  }
 }
 
 Tool

Modified: trunk/flexlay/lib/tools/zoom_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/zoom_tool.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/tools/zoom_tool.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -49,17 +49,17 @@
 ZoomToolImpl::draw()
 {
   switch (state)
+  {
+    case CREATE_ZOOM_RECT:
     {
-    case CREATE_ZOOM_RECT:
-      {
-        CL_Rectf tmp(zoom_rect);
-        tmp.normalize();
-        CL_Display::fill_rect(tmp, CL_Color(255, 255, 0, 50));
-        CL_Display::draw_rect(tmp, CL_Color(255, 255, 0, 200));
-      }
+      CL_Rectf tmp(zoom_rect);
+      tmp.normalize();
+      CL_Display::fill_rect(tmp, CL_Color(255, 255, 0, 50));
+      CL_Display::draw_rect(tmp, CL_Color(255, 255, 0, 200));
+    }
     case NONE:
       break;
-    }
+  }
 }
 
 void
@@ -68,25 +68,25 @@
   EditorMapComponent* parent = EditorMapComponent::current();
 
   if (event.id != CL_MOUSE_RIGHT)
+  {
+    switch (state)
     {
-      switch (state)
+      case CREATE_ZOOM_RECT:
+      {
+        state = NONE;
+        parent->release_mouse();
+
+        CL_Pointf pos = parent->screen2world(event.mouse_pos);
+        zoom_rect.right  = pos.x;
+        zoom_rect.bottom = pos.y;
+        zoom_rect.normalize();
+        if (zoom_rect.get_width() > 10 && zoom_rect.get_height() > 10)
         {
-        case CREATE_ZOOM_RECT:
-          {
-            state = NONE;
-            parent->release_mouse();
-
-            CL_Pointf pos = parent->screen2world(event.mouse_pos);
-            zoom_rect.right  = pos.x;
-            zoom_rect.bottom = pos.y;
-            zoom_rect.normalize();
-            if (zoom_rect.get_width() > 10 && zoom_rect.get_height() > 10)
-              {
-                parent->zoom_to(zoom_rect);
-              }
-          }
+          parent->zoom_to(zoom_rect);
         }
+      }
     }
+  }
 }
 
 void
@@ -95,39 +95,39 @@
   EditorMapComponent* parent = EditorMapComponent::current();
 
   switch(event.id)
-    {
+  {
     case CL_MOUSE_RIGHT:
       switch (state)
-        {
+      {
         case NONE:
           parent->zoom_out(event.mouse_pos);
           parent->zoom_out(event.mouse_pos);
           break;
         default:
           break;
-        }
+      }
       break;
 
     default:
       switch (state)
+      {
+        case NONE:
         {
-        case NONE:
-          {
-            state = CREATE_ZOOM_RECT;
-            parent->capture_mouse();
+          state = CREATE_ZOOM_RECT;
+          parent->capture_mouse();
 
-            CL_Pointf pos = parent->screen2world(event.mouse_pos);
-            zoom_rect.left   = pos.x;
-            zoom_rect.top    = pos.y;
-            zoom_rect.right  = pos.x;
-            zoom_rect.bottom = pos.y;
-          }
-          break;
+          CL_Pointf pos = parent->screen2world(event.mouse_pos);
+          zoom_rect.left   = pos.x;
+          zoom_rect.top    = pos.y;
+          zoom_rect.right  = pos.x;
+          zoom_rect.bottom = pos.y;
+        }
+        break;
         default:
           break;
-        }
+      }
       break;
-    }
+  }
 }
 
 void
@@ -136,17 +136,17 @@
   EditorMapComponent* parent = EditorMapComponent::current();
 
   switch (state)
+  {
+    case CREATE_ZOOM_RECT:
     {
-    case CREATE_ZOOM_RECT:
-      {
-        CL_Pointf pos = parent->screen2world(event.mouse_pos);
-        zoom_rect.right  = pos.x;
-        zoom_rect.bottom = pos.y;  
-      }
-      break;
+      CL_Pointf pos = parent->screen2world(event.mouse_pos);
+      zoom_rect.right  = pos.x;
+      zoom_rect.bottom = pos.y;  
+    }
+    break;
     default:
       break;
-    }
+  }
 }
 
 Tool

Modified: trunk/flexlay/lib/window.cpp
===================================================================
--- trunk/flexlay/lib/window.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/window.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -59,8 +59,8 @@
   //Fonts::verdana11.draw(8+15, 3, title);
 
   impl->close = new Icon(CL_Rect(CL_Point(3, 3), CL_Size(18,18)), 
-                        make_sprite("../data/images/window/close.png"),
-                        "", this);
+                         make_sprite("../data/images/window/close.png"),
+                         "", this);
   impl->minimize = new Icon(CL_Rect(CL_Point(get_width()-3-18-18, 3), CL_Size(18,18)), 
                             make_sprite("../data/images/window/minimize.png"),
                             "", this);
@@ -95,8 +95,8 @@
   maximize->set_position(parent->get_width()-3-18, 3);
   CL_Rect rect = parent->get_position();
   client_area->set_position(CL_Rect(CL_Point(4, 3+12+7), 
-                                   CL_Size(rect.get_width()-10,
-                                           rect.get_height()-28)));
+                                    CL_Size(rect.get_width()-10,
+                                            rect.get_height()-28)));
 }
 
 void
@@ -141,16 +141,16 @@
 {
   // FIXME: Move this to scripting language
   if (!is_maximized)
-    {
-      is_maximized = true;
-      old_position = parent->get_position();
-      parent->set_position(parent->get_parent()->get_position());
-    }
+  {
+    is_maximized = true;
+    old_position = parent->get_position();
+    parent->set_position(parent->get_parent()->get_position());
+  }
   else
-    {
-      is_maximized = false;
-      parent->set_position(old_position);
-    }
+  {
+    is_maximized = false;
+    parent->set_position(old_position);
+  }
 }
 
 CL_Component*

Modified: trunk/flexlay/lib/workspace.cpp
===================================================================
--- trunk/flexlay/lib/workspace.cpp	2009-11-22 03:06:27 UTC (rev 714)
+++ trunk/flexlay/lib/workspace.cpp	2009-11-22 03:07:59 UTC (rev 715)
@@ -41,11 +41,11 @@
   : impl(0)
 {
   if (create)
-    {
-      impl = new WorkspaceImpl();
-      current_ = *this;
-      std::cout << "Workspace()" << std::endl;
-    }
+  {
+    impl = new WorkspaceImpl();
+    current_ = *this;
+    std::cout << "Workspace()" << std::endl;
+  }
 }
 
 void
@@ -83,9 +83,9 @@
 
   for(WorkspaceImpl::Tools::iterator it = impl->tools.begin();
       it != impl->tools.end(); ++it)
-    {
-      it->second.on_mouse_move(event);
-    }
+  {
+    it->second.on_mouse_move(event);
+  }
 }
 
 void
@@ -98,7 +98,7 @@
     it->second.on_mouse_down(event);
 
   switch (event.id)
-    {
+  {
     case CL_MOUSE_WHEEL_UP:
       EditorMapComponent::current()->zoom_in(event.mouse_pos);
       break;
@@ -106,7 +106,7 @@
     case CL_MOUSE_WHEEL_DOWN:
       EditorMapComponent::current()->zoom_out(event.mouse_pos);
       break;
-    }
+  }
 }
 
 void



From grumbel at mail.berlios.de  Sun Nov 22 04:24:34 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 22 Nov 2009 04:24:34 +0100
Subject: [Flexlay-commit] r716 - in trunk/flexlay: . external
	external/clanlib/GL external/clanlib/GL/GLX lib
Message-ID: <200911220324.nAM3OYnQ022733@sheep.berlios.de>

Author: grumbel
Date: 2009-11-22 04:24:33 +0100 (Sun, 22 Nov 2009)
New Revision: 716

Added:
   trunk/flexlay/external/
   trunk/flexlay/external/clanlib/
   trunk/flexlay/external/clanlib/GL/GLX/input_device_linuxevent.cpp
   trunk/flexlay/external/clanlib/GL/GLX/input_device_xinput.cpp
   trunk/flexlay/external/clanlib/GL/canvas_opengl.cpp
Removed:
   trunk/flexlay/clanlib/
   trunk/flexlay/external/clanlib/GL/GLX/input_device_linuxevent.cpp
   trunk/flexlay/external/clanlib/GL/GLX/input_device_xinput.cpp
   trunk/flexlay/external/clanlib/GL/canvas_opengl.cpp
   trunk/flexlay/lib/paned.cpp
   trunk/flexlay/lib/paned.hpp
   trunk/flexlay/lib/serializer.cpp
   trunk/flexlay/lib/serializer.hpp
   trunk/flexlay/lib/sexpr_serializer.cpp
   trunk/flexlay/lib/sexpr_serializer.hpp
   trunk/flexlay/lib/simpleed.hpp
Modified:
   trunk/flexlay/SConstruct
   trunk/flexlay/lib/SConscript
   trunk/flexlay/lib/simpleed.cpp
Log:
Use Glob pattern instead of manual list of filenames, Deleted some unused files

Modified: trunk/flexlay/SConstruct
===================================================================
--- trunk/flexlay/SConstruct	2009-11-22 03:07:59 UTC (rev 715)
+++ trunk/flexlay/SConstruct	2009-11-22 03:24:33 UTC (rev 716)
@@ -1,29 +1,30 @@
 # -*- python -*-
 
-# FIXME: replace the X11 stuff with a proper X11 configure check and
-# make them somehow part of the clanlib libraries themself
-clanLib_env = Environment(CPPPATH=['../clanlib/'],
-                          LIBPATH=['/usr/X11R6/lib/',
-                                   '../clanlib/'],
-                          LIBS=['clanGUIStyleSilver', 
-                                'clanGUI',      
-                                'clanGL',
-                                'clanDisplay',
-                                'clanSignals', 
-                                'clanCore',
-                                'X11', 'Xmu', 'GL', 'GLU', 'png', 'jpeg', 'Xxf86vm', 'Xi'])
+# Set to False to use local ClanLib instead of global one
+if True:
+    clanLib_env = Environment(LIBPATH=[])
+    clanLib_env.ParseConfig("pkg-config --cflags --libs " +
+                            "clanCore-0.8 clanDisplay-0.8 clanGL-0.8 clanSignals-0.8 clanGUI-0.8 clanGUIStyleSilver-0.8")
+else:
+    # FIXME: replace the X11 stuff with a proper X11 configure check and
+    # make them somehow part of the clanlib libraries themself
+    clanLib_env = Environment(CPPPATH=['../external/clanlib/'],
+                              LIBPATH=['/usr/X11R6/lib/',
+                                       '../external/clanlib/'],
+                              LIBS=['clanGUIStyleSilver', 
+                                    'clanGUI',      
+                                    'clanGL',
+                                    'clanDisplay',
+                                    'clanSignals', 
+                                    'clanCore',
+                                    'X11', 'Xmu', 'GL', 'GLU', 'png', 'jpeg', 'Xxf86vm', 'Xi'])
 
-# Use this if you want to use your globally installed ClanLib
-#  clanLib_env = Environment()
-#  clanLib_env.ParseConfig("pkg-config --cflags --libs clanCore-0.8 clanDisplay-0.8 clanGL-0.8 clanSignals-0.8 clanGUI-0.8 clanGUIStyleSilver-0.8")
-
 Export('clanLib_env')
 
-SConscript(['clanlib/SConstruct'])
+SConscript(['external/clanlib/SConstruct'])
 SConscript(['lib/SConscript'])
 SConscript(['ruby/SConscript'])
 SConscript(['supertux/SConstruct'])
 SConscript(['netpanzer/SConscript'])
 
 # EOF #
-

Copied: trunk/flexlay/external/clanlib (from rev 712, trunk/flexlay/clanlib)

Deleted: trunk/flexlay/external/clanlib/GL/GLX/input_device_linuxevent.cpp
===================================================================
--- trunk/flexlay/clanlib/GL/GLX/input_device_linuxevent.cpp	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/external/clanlib/GL/GLX/input_device_linuxevent.cpp	2009-11-22 03:24:33 UTC (rev 716)
@@ -1,353 +0,0 @@
-/*
-**  ClanLib SDK
-**  Copyright (c) 1997-2005 The ClanLib Team
-**
-**  This software is provided 'as-is', without any express or implied
-**  warranty.  In no event will the authors be held liable for any damages
-**  arising from the use of this software.
-**
-**  Permission is granted to anyone to use this software for any purpose,
-**  including commercial applications, and to alter it and redistribute it
-**  freely, subject to the following restrictions:
-**
-**  1. The origin of this software must not be misrepresented; you must not
-**     claim that you wrote the original software. If you use this software
-**     in a product, an acknowledgment in the product documentation would be
-**     appreciated but is not required.
-**  2. Altered source versions must be plainly marked as such, and must not be
-**     misrepresented as being the original software.
-**  3. This notice may not be removed or altered from any source distribution.
-**
-**  Note: Some of the libraries ClanLib may link to may have additional
-**  requirements or restrictions.
-**
-**  File Author(s):
-**
-**    Magnus Norddahl
-**    (if your name is missing here, please add it)
-*/
-
-#include <assert.h>
-#include <string.h>
-#include <linux/input.h>
-#include <sys/ioctl.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <iostream>
-#include <errno.h>
-
-#include "API/Core/System/error.h"
-#include "API/Core/System/clanstring.h"
-#include "API/Display/input_event.h"
-#include "input_device_linuxevent.h"
-
-// FIXME: These three should be in linux/input.h
-#define MSC_RAW			0x03
-#define MSC_SCAN		0x04
-#define MSC_MAX			0x07
-
-
-#ifndef EV_SYN
-#define EV_SYN 0
-#endif
-
-#define BITS_PER_LONG (sizeof(long) * 8)
-#define NBITS(x) ((((x)-1)/BITS_PER_LONG)+1)
-#define OFF(x)  ((x)%BITS_PER_LONG)
-#define BIT(x)  (1UL<<OFF(x))
-#define LONG(x) ((x)/BITS_PER_LONG)
-#define test_bit(bit, array)	((array[LONG(bit)] >> OFF(bit)) & 1)
-
-static char *events[EV_MAX + 1] = { NULL };
-static char **names[EV_MAX + 1] = { NULL }; 
-
-CL_InputDevice_LinuxEvent::CL_InputDevice_LinuxEvent(CL_DisplayWindow_Generic* parent_, 
-																	  const std::string& device_)
-  : parent(parent_),
-	 device(device_) 
-{
-	fd = open(device.c_str(), O_RDONLY | O_NONBLOCK);
-
-	if (fd == -1)
-	{
-		throw CL_Error(strerror(errno));
-	}
-
-	if (ioctl(fd, EVIOCGVERSION, &version)) 
-	{
-		throw CL_Error("CL_InputDevice_LinuxEvent: can't get version");
-	}
-
-#if 0
-	if (0)
-	{ // FIXME: Some versions of linux don't have these structs, use arrays there
-		struct input_id id;
-		ioctl(fd, EVIOCGID, &id);
-		printf("Input device ID: bus 0x%x vendor 0x%x product 0x%x version 0x%x\n",
-				 id.bustype, id.vendor, id.product, id.vendor);
-	}
-#endif
-
-	{  // Get the human readable name
-		char c_name[256] = "Unknown";
-		ioctl(fd, EVIOCGNAME(sizeof(c_name)), c_name);
-		name = c_name;
-	}
-
-	{
-		unsigned long bit[EV_MAX][NBITS(KEY_MAX)];
-		memset(bit, 0, sizeof(bit));
-		ioctl(fd, EVIOCGBIT(0, EV_MAX), bit[0]);
-
-		for (int i = 0; i < EV_MAX; i++)
-		{
-			if (test_bit(i, bit[0])) 
-			{
-				//printf("  Event type %d (%s)\n", i, events[i] ? events[i] : "?");
-				
-				if (!i) continue;
-
-				ioctl(fd, EVIOCGBIT(i, KEY_MAX), bit[i]);
-				for (int j = 0; j < KEY_MAX; j++) 
-				{
-					if (test_bit(j, bit[i])) 
-					{
-						if (i == EV_KEY) 
-						{ // Found something that might be a button
-							buttons.push_back(Button(j));
-						} 
-						else if (i == EV_ABS) 
-						{ // Found something that might be an axis
-#if 0
-							// FIXME: Some Linuxes don't have these struct
-							struct input_absinfo absinfo;
-							ioctl(fd, EVIOCGABS(j), &absinfo);
-							// FIXME: we are ignoring absinfo.fuzz and absinfo.flat, not sure what they are good for
-							axes.push_back(Axis(j, absinfo.minimum, absinfo.maximum, absinfo.value));
-#else
-							int absinfo[5];
-							ioctl(fd, EVIOCGABS(j), &absinfo);
-							// FIXME: we are ignoring absinfo.fuzz and absinfo.flat, not sure what they are good for
-							axes.push_back(Axis(j, absinfo[1], absinfo[2], absinfo[0]));
-#endif
-						}
-						else if (i == EV_REL) 
-						{ // Found something mouse/ball like
-							balls.push_back(Ball(j));
-						}
-					}
-				}
-			}
-		}
-	}
-}
-
-int
-CL_InputDevice_LinuxEvent::get_ball_index_by_code(int code)
-{
-	for(std::vector<Ball>::size_type i = 0; i != balls.size(); ++i)
-	{
-		if (balls[i].code == code)
-		{
-			return i;
-		}
-	}
-	return -1;
-}
-
-int
-CL_InputDevice_LinuxEvent::get_button_index_by_code(int code)
-{
-	for(std::vector<Button>::size_type i = 0; i != buttons.size(); ++i)
-	{
-		if (buttons[i].code == code)
-		{
-			return i;
-		}
-	}
-	return -1;
-}
-
-int
-CL_InputDevice_LinuxEvent::get_axis_index_by_code(int code)
-{
-	for(std::vector<Axis>::size_type i = 0; i != axes.size(); ++i)
-	{
-		if (axes[i].code == code)
-		{
-			return i;
-		}
-	}
-	return -1;
-}
-
-void
-CL_InputDevice_LinuxEvent::keep_alive()
-{
-	struct input_event ev[64];
-	
-	int rd = read(fd, ev, sizeof(struct input_event) * 64);
-
-	if (rd >= (int) sizeof(struct input_event))
-	{
-		for (int i = 0; i < rd / (int)sizeof(struct input_event); ++i)
-		{
-			switch (ev[i].type)
-			{
-			case EV_ABS:
-			{
-				int axis_index = get_axis_index_by_code(ev[i].code);
-				if (axis_index != -1)
-				{
-					axes[axis_index].pos = ev[i].value;
-
-					CL_InputEvent e; 
-					
-					e.device   = CL_InputDevice(this);
-					e.type     = CL_InputEvent::axis_moved;
-					e.id       = axis_index;
-					e.axis_pos = axes[axis_index].get_posf();
-					e.repeat_count = 0;
-
-					sig_axis_move(e);
-				}
-			}
-			break;
-
-			case EV_REL:
-			{
-				int ball_index = get_ball_index_by_code(ev[i].code);
-
-				balls[ball_index].pos += ev[i].value;
-
-				CL_InputEvent e; 
-				
-				e.device       = CL_InputDevice(this);
-				e.type         = CL_InputEvent::ball_moved;
-				e.id           = ball_index;
-				e.mouse_pos.x  = ev[i].value;
-				e.mouse_pos.y  = 0;
-				e.axis_pos     = 0;
-				e.repeat_count = 0;
-
-				sig_ball_move(e);
-			}
-			break;
-
-			case EV_KEY:
-			{
-				int button_index = get_button_index_by_code(ev[i].code);
-
-				buttons[button_index].pressed = ev[i].value;
-
-				CL_InputEvent e; 
-			
-				e.device = CL_InputDevice(this);
-				e.id     = button_index;
-				e.repeat_count = 0;
-
-				if (ev[i].value)
-				{
-					e.type = CL_InputEvent::pressed;
-					sig_key_down(e);
-				}
-				else
-				{
-					e.type = CL_InputEvent::released;
-					sig_key_up(e);
-				}
-			}
-			break;
-
-			default:
-				if (0) 
-				{
-					if (ev[i].type == EV_SYN) 
-					{
-						printf("Event: time %ld.%06ld, -------------- %s ------------\n",
-								 ev[i].time.tv_sec, ev[i].time.tv_usec, ev[i].code ? "Config Sync" : "Report Sync" );
-					}
-					else if (ev[i].type == EV_MSC && (ev[i].code == MSC_RAW || ev[i].code == MSC_SCAN)) 
-					{
-						printf("Event: time %ld.%06ld, type %d (%s), code %d (%s), value %02x\n",
-								 ev[i].time.tv_sec, ev[i].time.tv_usec, ev[i].type,
-								 events[ev[i].type] ? events[ev[i].type] : "?",
-								 ev[i].code,
-								 names[ev[i].type] ? (names[ev[i].type][ev[i].code] ? names[ev[i].type][ev[i].code] : "?") : "?",
-								 ev[i].value);
-					} 
-					else 
-					{
-						printf("Event: time %ld.%06ld, type %d (%s), code %d (%s), value %d\n",
-								 ev[i].time.tv_sec, ev[i].time.tv_usec, ev[i].type,
-								 events[ev[i].type] ? events[ev[i].type] : "?",
-								 ev[i].code,
-								 names[ev[i].type] ? (names[ev[i].type][ev[i].code] ? names[ev[i].type][ev[i].code] : "?") : "?",
-								 ev[i].value);
-					}	
-				}
-				break;
-			}
-		}
-	}
-}
-
-CL_InputDevice_LinuxEvent::~CL_InputDevice_LinuxEvent()
-{
-	close(fd);
-}
-
-std::string
-CL_InputDevice_LinuxEvent::get_key_name(int num) const
-{
-	// FIXME: copy enum2string code from evtest here
-	return CL_String::from_int(num);
-}
-
-float
-CL_InputDevice_LinuxEvent::get_axis(int num)   const
-{
-	assert(num >= 0 && num < int(axes.size()));
-	return axes[num].pos;
-}
-
-bool
-CL_InputDevice_LinuxEvent::get_keycode(int num) const
-{
-	if (num >= 0 && num < int(buttons.size()) )
-	{
-		return buttons[num].pressed;
-	} 
-	else 
-	{
-		return false;
-	}
-}
-
-int
-CL_InputDevice_LinuxEvent::get_axis_count() const
-{
-	return axes.size();
-}
-
-int
-CL_InputDevice_LinuxEvent::get_button_count() const
-{
-	return buttons.size();
-}
-
-std::string
-CL_InputDevice_LinuxEvent::get_name() const 
-{
-	return name; 
-}
-
-std::string
-CL_InputDevice_LinuxEvent::get_device_name() const 
-{ 
-	return "linuxevent:" + device; 
-}
-
-// Local Variables: ***
-// mode: clanlib ***
-// End: ***

Copied: trunk/flexlay/external/clanlib/GL/GLX/input_device_linuxevent.cpp (from rev 713, trunk/flexlay/clanlib/GL/GLX/input_device_linuxevent.cpp)

Deleted: trunk/flexlay/external/clanlib/GL/GLX/input_device_xinput.cpp
===================================================================
--- trunk/flexlay/clanlib/GL/GLX/input_device_xinput.cpp	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/external/clanlib/GL/GLX/input_device_xinput.cpp	2009-11-22 03:24:33 UTC (rev 716)
@@ -1,428 +0,0 @@
-/*
-**  ClanLib SDK
-**  Copyright (c) 1997-2005 The ClanLib Team
-**
-**  This software is provided 'as-is', without any express or implied
-**  warranty.  In no event will the authors be held liable for any damages
-**  arising from the use of this software.
-**
-**  Permission is granted to anyone to use this software for any purpose,
-**  including commercial applications, and to alter it and redistribute it
-**  freely, subject to the following restrictions:
-**
-**  1. The origin of this software must not be misrepresented; you must not
-**     claim that you wrote the original software. If you use this software
-**     in a product, an acknowledgment in the product documentation would be
-**     appreciated but is not required.
-**  2. Altered source versions must be plainly marked as such, and must not be
-**     misrepresented as being the original software.
-**  3. This notice may not be removed or altered from any source distribution.
-**
-**  Note: Some of the libraries ClanLib may link to may have additional
-**  requirements or restrictions.
-**
-**  File Author(s):
-**
-**    Magnus Norddahl
-**    (if your name is missing here, please add it)
-*/
-
-#include <iostream>
-#include <string.h>
-#include "API/Core/System/log.h"
-#include "API/Display/input_device.h"
-#include "API/Display/input_event.h"
-#include "API/Core/System/clanstring.h"
-#include "API/Core/System/error.h"
-#include "input_device_xinput.h"
-#include "display_window_opengl.h"
-
-#define INVALID_EVENT_TYPE	-1
-
-CL_InputDevice_XInput::CL_InputDevice_XInput(CL_DisplayWindow_OpenGL *owner_, 
-															XDeviceInfo* info)
-	: owner(owner_),
-	  name(info->name),
-	  absolute(false),
-	  num_keys   (0),
-	  motion_type        (INVALID_EVENT_TYPE),
-	  button_press_type  (INVALID_EVENT_TYPE),
-	  button_release_type(INVALID_EVENT_TYPE),
-	  key_press_type     (INVALID_EVENT_TYPE),
-	  key_release_type   (INVALID_EVENT_TYPE),
-	  proximity_in_type  (INVALID_EVENT_TYPE),
-	  proximity_out_type (INVALID_EVENT_TYPE)
-
-{
-  type = CL_InputDevice::tablet;  
-
-  //info = find_device_info(owner->get_display(), name.c_str(), True);
-  //if (!info)
-  // throw CL_Error("CL_InputDeviceXInput Error: Couldn't find device: " + name);
-
-  get_info(info);
-
-  if (!register_events(owner->get_display(), info, name.c_str(), True))
-  {
-	  CL_Log::log("debug", "CL_InputDeviceXInput: Couldn't find device: " + name);
-  }
-  else
-  {
-	  slot_xevent = owner->sig_unknown_xevent.connect(this, &CL_InputDevice_XInput::on_xevent);
-  }
-}
-
-CL_InputDevice_XInput::~CL_InputDevice_XInput()
-{
-	
-}
-
-void
-CL_InputDevice_XInput::get_info(XDeviceInfo	*info)
-{
-	int			i,j;
-	XAnyClassPtr	any;
-	XKeyInfoPtr		k;
-	XButtonInfoPtr	b;
-	XValuatorInfoPtr	v;
-	XAxisInfoPtr	a;
-
-	//printf("\"%s\"\tid=%ld\t[%s]\n", info->name, info->id,
-	//		 (info->use == IsXExtensionDevice) ? "XExtensionDevice" :
-//			 ((info->use == IsXPointer) ? "XPointer" : "XKeyboard"));
-
-	if (info->num_classes > 0) {
-		any = (XAnyClassPtr) (info->inputclassinfo);
-		for (i=0; i<info->num_classes; i++) {
-			switch (any->c_class) {
-			case KeyClass:
-				k = (XKeyInfoPtr) any;
-				//printf("\tNum_keys is %d\n", k->num_keys);
-				//printf("\tMin_keycode is %d\n", k->min_keycode);
-				//printf("\tMax_keycode is %d\n", k->max_keycode);
-
-				num_keys = k->num_keys;
-				break;
-
-			case ButtonClass:
-				b = (XButtonInfoPtr) any;
-				//printf("\tNum_buttons is %d\n", b->num_buttons);
-
-				buttons.resize(b->num_buttons, false);
-				break;
-
-			case ValuatorClass:
-				v = (XValuatorInfoPtr) any;
-				a = (XAxisInfoPtr) ((char *) v + 
-										  sizeof (XValuatorInfo));
-
-				//printf("\tNum_axes is %d\n", v->num_axes);
-				//printf("\tMode is %s\n", (v->mode == Absolute) ? "Absolute" : "Relative");
-				//printf("\tMotion_buffer is %ld\n", v->motion_buffer);
-
-				absolute = (v->mode == Absolute);
-
-				for (j=0; j<v->num_axes; j++, a++) 
-				{
-					//printf("\tAxis %d :\n", j);
-					//printf("\t\tMin_value is %d\n", a->min_value);
-					//printf("\t\tMax_value is %d\n", a->max_value);
-					//printf ("\t\tResolution is %d\n", a->resolution);
-					
-					axis.push_back(AxisInfo(a->min_value, a->max_value, a->resolution));
-				}
-
-				break;
-		
-			default:
-				printf ("unknown class\n");
-			}
-			any = (XAnyClassPtr) ((char *) any + any->length);
-		}
-	}
-}
-
-XDeviceInfo*
-CL_InputDevice_XInput::find_device_info(Display	*display,
-													 const char		*name,
-													 Bool		only_extended)
-{
-	// FIXME: Not really needed could simply pass XDeviceInfo to the
-	// constructor, might however make a nicer interface
-	XDeviceInfo	*devices;
-	int		loop;
-	int		num_devices;
-	int		len = strlen(name);
-	Bool     is_id = True;
-	XID		id = 0;
-    
-	for(loop=0; loop<len; loop++) {
-		if (!isdigit(name[loop])) {
-			is_id = False;
-			break;
-		}
-	}
-
-	if (is_id) {
-		id = atoi(name);
-	}
-    
-	devices = XListInputDevices(display, &num_devices);
-
-	for(loop=0; loop<num_devices; loop++) {
-		if ((!only_extended || (devices[loop].use == IsXExtensionDevice)) &&
-			 ((!is_id && strcmp(devices[loop].name, name) == 0) ||
-			  (is_id && devices[loop].id == id))) {
-			return &devices[loop];
-		}
-	}
-	return NULL;
-}
-
-int
-CL_InputDevice_XInput::register_events(Display		*dpy,
-													XDeviceInfo	*info,
-													const char		*dev_name,
-													Bool		handle_proximity)
-{
-	int             number = 0;	/* number of events registered */
-	XEventClass     event_list[7];
-	int             i;
-	XDevice         *device;
-	Window          root_win;
-	unsigned long   screen;
-	XInputClassInfo *ip;
-
-	screen   = DefaultScreen(dpy);
-	root_win = RootWindow(dpy, screen);
-
-	device = XOpenDevice(dpy, info->id);
-
-	if (!device) {
-		fprintf(stderr, "unable to open device %s\n", dev_name);
-		return 0;
-	}
-    
-	if (device->num_classes > 0) {
-		for (ip = device->classes, i=0; i<info->num_classes; ip++, i++) {
-			switch (ip->input_class) {
-			case KeyClass:
-				DeviceKeyPress  (device, key_press_type,   event_list[number]); number++;
-				DeviceKeyRelease(device, key_release_type, event_list[number]); number++;
-				break;
-
-			case ButtonClass:
-				DeviceButtonPress  (device, button_press_type,   event_list[number]); number++;
-				DeviceButtonRelease(device, button_release_type, event_list[number]); number++;
-				break;
-
-			case ValuatorClass:
-				DeviceMotionNotify(device, motion_type, event_list[number]); number++;
-				if (handle_proximity) {
-					ProximityIn (device, proximity_in_type,  event_list[number]); number++;
-					ProximityOut(device, proximity_out_type, event_list[number]); number++;
-				}
-				break;
-		
-			default:
-				fprintf(stderr, "unknown class\n");
-				break;
-			}
-		}
-
-		if (XSelectExtensionEvent(dpy, root_win, event_list, number)) {
-			fprintf(stderr, "error selecting extended events\n");
-			return 0;
-		}
-	}
-
-	//std::cout << "### Registered events: " << number << std::endl;
-	return number;
-}
-
-void
-CL_InputDevice_XInput::on_xevent(XEvent &event)
-{
-	if (0)
-		std::cout << this << " event: " 
-					 << event.type << " Defs: "
-					 << motion_type << " " 
-					 << button_press_type << " " 
-					 << button_release_type << " " 
-					 << key_press_type << " " 
-					 << key_release_type << " " 
-					 << proximity_out_type << " " 
-					 << proximity_in_type << " " 
-					 << std::endl;
-
-	std::vector<AxisInfo> old_axis = axis;
-	std::vector<bool>     old_buttons = buttons;
-
-  	if (event.type == motion_type) 
-	{
-		XDeviceMotionEvent *motion = (XDeviceMotionEvent *) &event;
-
-		//printf("motion ");
-	    
-		for(int loop=0; loop<motion->axes_count; loop++) {
-			//printf("a[%d]=%d ", motion->first_axis + loop, motion->axis_data[loop]);
-			axis[loop + motion->first_axis].pos = motion->axis_data[loop];
-		}
-		//printf("\n");
-	} 
-	else if ((event.type == button_press_type) ||
-				(event.type == button_release_type)) 
-	{
-		int	loop;
-		XDeviceButtonEvent *button = (XDeviceButtonEvent *) &event;
-	    
-		//printf("button %s %d ", (event.type == button_release_type) ? "release" : "press  ", button->button);
-
-		buttons[button->button] = (event.type == button_press_type);
-	    
-		for(loop=0; loop<button->axes_count; loop++) {
-			//printf("a[%d]=%d ", button->first_axis + loop, button->axis_data[loop]);
-			axis[loop + button->first_axis].pos = button->axis_data[loop];
-		}
-		//printf("\n");
-	} 
-	else if ((event.type == key_press_type) ||
-				(event.type == key_release_type)) 
-	{
-		int	loop;
-		XDeviceKeyEvent *key = (XDeviceKeyEvent *) &event;
-	    
-		//printf("key %s %d ", (event.type == key_release_type) ? "release" : "press  ", key->keycode);
-	    
-		for(loop=0; loop<key->axes_count; loop++) {
-			//printf("a[%d]=%d ", key->first_axis + loop, key->axis_data[loop]);
-			axis[loop + key->first_axis].pos = key->axis_data[loop];
-		}
-		//printf("\n");
-	}
-	else if ((event.type == proximity_out_type) ||
-				(event.type == proximity_in_type))
-	{
-		int	loop;
-		XProximityNotifyEvent *prox = (XProximityNotifyEvent *) &event;
-	    
-		//printf("proximity %s ", (event.type == proximity_in_type) ? "in " : "out");
-	    
-		for(loop=0; loop<prox->axes_count; loop++) {
-			//printf("a[%d]=%d ", prox->first_axis + loop, prox->axis_data[loop]);
-			axis[loop + prox->first_axis].pos = prox->axis_data[loop];
-		}
-		//printf("\n");
-	}
-	else 
-	{
-		//printf("CL_InputDevice_XInput: what's that %d\n", event.type);
-	}
-
-
-	for (std::vector<bool>::size_type i = 0; i < buttons.size(); ++i)
-	{
-		if (buttons[i] != old_buttons[i])
-		{
-			CL_InputEvent ie;
-			
-			ie.id           = i;
-			ie.type         = CL_InputEvent::pressed;
-			ie.device       = CL_InputDevice(this);
-			ie.mouse_pos    = CL_Point(0, 0);
-			ie.axis_pos     = 0;
-			ie.repeat_count = false;
-
-			sig_axis_move(ie);
-		}
-	}
-
-	for (std::vector<AxisInfo>::size_type i = 0; i < axis.size(); ++i)
-	{
-		if (axis[i].pos != old_axis[i].pos)
-		{
-			CL_InputEvent ie;
-			
-			ie.id           = i;
-			ie.type         = CL_InputEvent::axis_moved;
-			ie.device       = CL_InputDevice(this);
-			ie.mouse_pos    = CL_Point(0, 0);
-			ie.axis_pos     = get_axis(i);
-			ie.repeat_count = false;
-
-			sig_axis_move(ie);
-		}
-	}
-}
-
-int
-CL_InputDevice_XInput::get_x() const
-{
-	return 0;
-}
-
-int
-CL_InputDevice_XInput::get_y() const
-{
-	return 0;
-}
-
-bool
-CL_InputDevice_XInput::get_keycode(int keycode) const
-{
-	if (keycode >=0 && keycode < int(buttons.size()))
-	{
-		return buttons[keycode];
-	}
-	else
-	{
-		return false;
-	}
-}
-
-std::string
-CL_InputDevice_XInput::get_key_name(int id) const
-{
-	return "button" + CL_String::from_int(id);
-}
-
-float
-CL_InputDevice_XInput::get_axis(int index) const
-{
-	if (index >= 0 && index < get_axis_count())
-	{
-		return float(axis[index].pos)/(axis[index].max_value - axis[index].min_value);
-	}
-	else
-	{
-		return 0.0f;
-	}
-}
-
-int
-CL_InputDevice_XInput::get_axis_count() const
-{
-	return axis.size();
-}
-
-std::string
-CL_InputDevice_XInput::get_name() const
-{
-	return name;
-}
-
-std::string
-CL_InputDevice_XInput::get_device_name() const
-{
-	return "xinput:" + name;
-}
-
-int
-CL_InputDevice_XInput::get_button_count() const
-{
-	return buttons.size();
-}
-
-// Local Variables: ***
-// mode: clanlib ***
-// End: ***

Copied: trunk/flexlay/external/clanlib/GL/GLX/input_device_xinput.cpp (from rev 713, trunk/flexlay/clanlib/GL/GLX/input_device_xinput.cpp)

Deleted: trunk/flexlay/external/clanlib/GL/canvas_opengl.cpp
===================================================================
--- trunk/flexlay/clanlib/GL/canvas_opengl.cpp	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/external/clanlib/GL/canvas_opengl.cpp	2009-11-22 03:24:33 UTC (rev 716)
@@ -1,433 +0,0 @@
-/*
-**  ClanLib SDK
-**  Copyright (c) 1997-2005 The ClanLib Team
-**
-**  This software is provided 'as-is', without any express or implied
-**  warranty.  In no event will the authors be held liable for any damages
-**  arising from the use of this software.
-**
-**  Permission is granted to anyone to use this software for any purpose,
-**  including commercial applications, and to alter it and redistribute it
-**  freely, subject to the following restrictions:
-**
-**  1. The origin of this software must not be misrepresented; you must not
-**     claim that you wrote the original software. If you use this software
-**     in a product, an acknowledgment in the product documentation would be
-**     appreciated but is not required.
-**  2. Altered source versions must be plainly marked as such, and must not be
-**     misrepresented as being the original software.
-**  3. This notice may not be removed or altered from any source distribution.
-**
-**  Note: Some of the libraries ClanLib may link to may have additional
-**  requirements or restrictions.
-**
-**  File Author(s):
-**
-**    Magnus Norddahl
-**    (if your name is missing here, please add it)
-*/
-
-#include <string.h>
-#include "Display/display_precomp.h"
-#include "canvas_opengl.h"
-#include "API/Core/System/error.h"
-#include "API/Display/pixel_buffer.h"
-#include "API/Display/display.h"
-#include "API/Display/display_window.h"
-#include "API/Display/graphic_context.h"
-#include "API/GL/opengl_state.h"
-#include "API/GL/opengl_wrap.h"
-#ifdef WIN32
-#include "WGL/display_window_opengl.h"
-#else
-#ifdef __APPLE__
-#include "AGL/display_window_opengl.h"
-#else
-#include "GLX/display_window_opengl.h"
-#endif
-#endif
-#include "graphic_context_opengl.h"
-#include "surface_target_opengl.h"
-
-/////////////////////////////////////////////////////////////////////////////
-// CL_Canvas_OpenGL construction:
-
-CL_Canvas_OpenGL::CL_Canvas_OpenGL()
-{
-	CL_OpenGLState state(CL_Display::get_current_window()->get_gc());
-	state.set_active();
-
-	selected_surface = 0;
-	gc = 0;
-	pbuffer = 0;
-	pbuffer_context = 0;
-
-#ifdef WIN32
-	pbuffer_dc = 0;
-
-	if (wglCreatePbufferARB == 0)
-	{
-		wglCreatePbufferARB = (ptr_wglCreatePbufferARB) wglGetProcAddress("wglCreatePbufferARB");
-		wglCreatePbufferARB = (ptr_wglCreatePbufferARB) wglGetProcAddress("wglCreatePbufferARB");
-		wglGetPbufferDCARB = (ptr_wglGetPbufferDCARB) wglGetProcAddress("wglGetPbufferDCARB");
-		wglReleasePbufferDCARB = (ptr_wglReleasePbufferDCARB) wglGetProcAddress("wglReleasePbufferDCARB");
-		wglDestroyPbufferARB = (ptr_wglDestroyPbufferARB) wglGetProcAddress("wglDestroyPbufferARB");
-		wglQueryPbufferARB = (ptr_wglQueryPbufferARB) wglGetProcAddress("wglQueryPbufferARB");
-	}
-#else
-#ifndef __APPLE__
-	if (glXCreateGLXPbufferSGIX == 0)
-	{
-		glXCreateGLXPbufferSGIX = (ptr_glXCreateGLXPbufferSGIX) CL_OpenGL::get_proc_address("glXCreateGLXPbufferSGIX");
-		glXDestroyGLXPbufferSGIX = (ptr_glXDestroyGLXPbufferSGIX) CL_OpenGL::get_proc_address("glXDestroyGLXPbufferSGIX");
-		glXQueryGLXPbufferSGIX = (ptr_glXQueryGLXPbufferSGIX) CL_OpenGL::get_proc_address("glXQueryGLXPbufferSGIX");
-		glXSelectEventSGIX = (ptr_glXSelectEventSGIX) CL_OpenGL::get_proc_address("glXSelectEventSGIX");
-		glXGetSelectedEventSGIX = (ptr_glXGetSelectedEventSGIX) CL_OpenGL::get_proc_address("glXGetSelectedEventSGIX");
-
-		glXChooseFBConfigSGIX = (ptr_glXChooseFBConfigSGIX) CL_OpenGL::get_proc_address("glXChooseFBConfigSGIX");
-		glXCreateContextWithConfigSGIX = (ptr_glXCreateContextWithConfigSGIX) CL_OpenGL::get_proc_address("glXCreateContextWithConfigSGIX");
-	}
-#endif
-#endif
-
-	pbuffer_changed = false;
-	texture_changed = true;
-}
-
-CL_Canvas_OpenGL::~CL_Canvas_OpenGL()
-{
-	delete gc;
-
-	CL_OpenGLState state(CL_Display::get_current_window()->get_gc());
-	state.set_active();
-#ifdef WIN32
-	if (pbuffer_context) wglDeleteContext(pbuffer_context);
-	if (pbuffer_dc) wglReleasePbufferDCARB(pbuffer, pbuffer_dc);
-	if (pbuffer) wglDestroyPbufferARB(pbuffer);
-#else
-#ifdef __APPLE__
-	if (pbuffer) aglDestroyPBuffer(pbuffer);
-	if (pbuffer_context) aglDestroyContext(pbuffer_context);
-#else
-	if (pbuffer_context) glXDestroyContext(CL_DisplayWindow_OpenGL::get_display(), pbuffer_context);
-	if (pbuffer) glXDestroyGLXPbufferSGIX(CL_DisplayWindow_OpenGL::get_display(), pbuffer);
-#endif
-#endif
-}
-
-/////////////////////////////////////////////////////////////////////////////
-// CL_Canvas_OpenGL attributes:
-
-CL_GraphicContext *CL_Canvas_OpenGL::get_gc()
-{
-	if (selected_surface == 0) return 0;
-
-	if (gc == 0)
-	{
-		// Create working pbuffer:
-#ifdef WIN32
-		if (wglCreatePbufferARB == 0)
-		{
-			throw CL_Error("WGL_ARB_pbuffer OpenGL extension not supported by this card");
-		}
-
-		int attribList[1] = { 0 };
-
-		PIXELFORMATDESCRIPTOR pfd =
-		{
-			sizeof(PIXELFORMATDESCRIPTOR),  // size of this pfd 
-			1,                              // version number
-			// PFD_DRAW_TO_WINDOW |            // support window
-			PFD_SUPPORT_OPENGL //|            // support OpenGL
-			//PFD_DOUBLEBUFFER |              // double buffered
-			//PFD_DEPTH_DONTCARE
-			,             // do you care about a zbuffer?
-			PFD_TYPE_RGBA,                  // RGBA type
-			24,                             // 24-bit color depth
-			0, 0, 0, 0, 0, 0,               // color bits ignored
-			8,                              // no alpha buffer
-			0,                              // shift bit ignored
-			0,                              // no accumulation buffer
-			0, 0, 0, 0,                     // accum bits ignored
-			0,                              // z-buffer
-			0,                              // no stencil buffer
-			0,                              // no auxiliary buffer
-			PFD_MAIN_PLANE,                 // main layer
-			0,                              // reserved
-			0, 0, 0                         // layer masks ignored
-		};
-
-		int pixelformat = ChoosePixelFormat(wglGetCurrentDC(), &pfd);
-
-//		int pixelformat = GetPixelFormat(wglGetCurrentDC());
-
-		pbuffer = wglCreatePbufferARB(
-			wglGetCurrentDC(),
-			pixelformat,
-			selected_surface->surface_size.width,
-			selected_surface->surface_size.height,
-			attribList);
-		pbuffer_dc = wglGetPbufferDCARB(pbuffer);
-		pbuffer_context = wglCreateContext(pbuffer_dc);
-
-		if (!CL_DisplayWindow_OpenGL::opengl_contexts.empty())
-		{
-			wglShareLists(CL_DisplayWindow_OpenGL::opengl_contexts.back(), pbuffer_context);
-		}
-#else
-#ifdef __APPLE__
-		GLint attrib[] = { AGL_RGBA, AGL_NO_RECOVERY, AGL_DEPTH_SIZE, 24, AGL_CLOSEST_POLICY, AGL_NONE };
-		AGLPixelFormat pixelformat = aglChoosePixelFormat(NULL, 0, attrib);
-		if (AGL_NO_ERROR != aglGetError())
-			throw CL_Error("Could not choose canvas pixel format: " + std::string((const char*)aglErrorString(aglGetError())));
-
-		pbuffer_context = aglCreateContext(pixelformat, CL_DisplayWindow_OpenGL::share_context);
-		if (AGL_NO_ERROR != aglGetError())
-			throw CL_Error("Could not create canvas gl context: " + std::string((const char*)aglErrorString(aglGetError())));
-
-		if (GL_FALSE==aglCreatePBuffer(
-				selected_surface->surface_size.width,
-				selected_surface->surface_size.height,
-				GL_TEXTURE_RECTANGLE_EXT, //GL_TEXTURE_2D,
-				GL_RGBA,
-				0,
-				&pbuffer)
-			) throw CL_Error("Could not create canvas PBuffer: " + std::string((const char*)aglErrorString(aglGetError())));
-
-		aglSetPBuffer(pbuffer_context, pbuffer, 0, 0, aglGetVirtualScreen(CL_DisplayWindow_OpenGL::share_context));
-		if (AGL_NO_ERROR != aglGetError())
-			throw CL_Error("Could not set up canvas PBuffer: " + std::string((const char*)aglErrorString(aglGetError())));
-#else
-   int scrnum;
-   GLXFBConfig *fbconfig;
-   XVisualInfo *visinfo;
-   int nitems;
-
-   int attrib[] = {
-      GLX_DOUBLEBUFFER,  False,
-      GLX_RED_SIZE,      1,
-      GLX_GREEN_SIZE,    1,
-      GLX_BLUE_SIZE,     1,
-      GLX_DEPTH_SIZE,    1,
-      GLX_RENDER_TYPE,   GLX_RGBA_BIT,
-      GLX_DRAWABLE_TYPE, GLX_PBUFFER_BIT | GLX_WINDOW_BIT,
-      None
-   };
-   int pbufAttrib[] = {
-     GLX_PBUFFER_WIDTH,   selected_surface->surface_size.width,
-     GLX_PBUFFER_HEIGHT,  selected_surface->surface_size.height,
-     GLX_LARGEST_PBUFFER, False,
-     None
-   };
-
-
-   scrnum   = DefaultScreen( CL_DisplayWindow_OpenGL::get_display() );
-
-   fbconfig = glXChooseFBConfig(CL_DisplayWindow_OpenGL::get_display(),
-                                scrnum,
-                                attrib,
-                                &nitems);
-   if (NULL == fbconfig) {
-      fprintf(stderr,"Error: couldn't get fbconfig\n");
-      exit(1);
-   }
-
-   pbuffer = glXCreatePbuffer(CL_DisplayWindow_OpenGL::get_display(), fbconfig[0], pbufAttrib);
-
-   visinfo = glXGetVisualFromFBConfig(CL_DisplayWindow_OpenGL::get_display(), fbconfig[0]);
-   if (!visinfo) {
-      fprintf(stderr, "Error: couldn't get an RGBA, double-buffered visual\n");
-      exit(1);
-   }
-
-   pbuffer_context = glXCreateContext( CL_DisplayWindow_OpenGL::get_display(), visinfo, 
-                                       dynamic_cast<CL_GraphicContext_OpenGL*>(CL_Display::get_current_window()->get_gc()->impl)->get_context(), GL_TRUE );
-   if (!pbuffer_context) {
-      fprintf(stderr, "Error: glXCreateContext failed\n");
-      exit(1);
-   }
-
-   XFree(fbconfig);
-   XFree(visinfo);
-
-#endif
-#endif
-
-		// Create GC interface for it:
-		gc = new CL_GraphicContext(new CL_GraphicContext_OpenGL(this));
-		gc->set_cliprect(CL_Rect(0, 0, selected_surface->surface_size.width, selected_surface->surface_size.height));
-
-		// Download surface to pbuffer:
-		pbuffer_changed = false;
-		texture_changed = true;
-		sync_pbuffer();
-	}
-
-	return gc;
-}
-
-CL_PixelBuffer CL_Canvas_OpenGL::get_pixeldata(const CL_Rect &area)
-{
-	if (selected_surface)
-		return selected_surface->get_pixeldata ();
-	else
-		return CL_PixelBuffer();
-}
-
-int CL_Canvas_OpenGL::get_width() const
-{
-	if (selected_surface) return selected_surface->get_width();
-	return 0;
-}
-	
-int CL_Canvas_OpenGL::get_height() const
-{
-	if (selected_surface) return selected_surface->get_height();
-	return 0;
-}
-	
-/////////////////////////////////////////////////////////////////////////////
-// CL_Canvas_OpenGL operations:
-
-void CL_Canvas_OpenGL::set_pixeldata(const CL_Point &dest, const CL_Rect &src, const CL_PixelBuffer &data)
-{
-}
-
-void CL_Canvas_OpenGL::select_surface(CL_Surface_Generic *surface)
-{
-	if (selected_surface)
-	{
-		sync_texture();
-		selected_surface->selected_canvas = 0;
-	}
-	if (surface == 0)
-	{
-		selected_surface = 0;
-		pbuffer_changed = false;
-		texture_changed = false;
-	}
-	else
-	{
-		selected_surface = (CL_Surface_Target_OpenGL *) surface->target;
-		selected_surface->selected_canvas = this;
-		pbuffer_changed = false;
-		texture_changed = true;
-		// alloc_pbuffer();
-	}
-}
-	
-void CL_Canvas_OpenGL::sync_surface()
-{
-	sync_texture();
-}
-
-void CL_Canvas_OpenGL::sync_pbuffer()
-{
-	if (texture_changed && gc != 0)
-	{
-		CL_OpenGLState state(gc);
-		state.set_active();
-
-		// Setup down/up 2d projection matrix:
-		clMatrixMode(CL_PROJECTION);
-		clLoadIdentity();
-
-		CLdouble viewport[4];
-		clGetDoublev(CL_VIEWPORT, viewport);
-
-		CLdouble width = viewport[2];
-		CLdouble height = viewport[3];
-		gluOrtho2D(0.0, width, 0.0, height);
-
-		clMatrixMode(CL_MODELVIEW);
-		clLoadIdentity();
-
-		// Copy texture to pbuffer:
-		clEnable(CL_TEXTURE_2D);
-		clBindTexture(CL_TEXTURE_2D, selected_surface->handle);
-		clMatrixMode(CL_TEXTURE);
-		CLdouble scale_matrix[16];
-		memset(scale_matrix, 0, sizeof(CLdouble)*16);
-		scale_matrix[0] = 1.0f/float(selected_surface->texture_size.width);
-		scale_matrix[5] = 1.0f/float(selected_surface->texture_size.height);
-		scale_matrix[10] = 1.0f;
-		scale_matrix[15] = 1.0f;
-		clLoadMatrixd(scale_matrix);
-		clMatrixMode(CL_MODELVIEW);
-
-		clBegin(CL_QUADS);
-		clColor3f(1.0f, 1.0f, 1.0f);
-		clTexCoord2f(float(selected_surface->surface_size.width), 0.0f);
-		clVertex2f(float(selected_surface->surface_size.width), 0.0f);
-		clTexCoord2f(float(selected_surface->surface_size.width), float(selected_surface->surface_size.height));
-		clVertex2f(float(selected_surface->surface_size.width), float(selected_surface->surface_size.height));
-		clTexCoord2f(0.0f, float(selected_surface->surface_size.height));
-		clVertex2f(0.0f, float(selected_surface->surface_size.height));
-		clTexCoord2f(0.0f, 0.0f);
-		clVertex2f(0.0f, 0.0f);
-		clEnd();
-#ifdef __APPLE__
-		clFlush();
-#endif
-	}
-	texture_changed = false;
-}
-
-void CL_Canvas_OpenGL::sync_texture()
-{
-	if (pbuffer_changed && gc != 0)
-	{
-		CL_OpenGLState state(gc);
-		state.set_active();
-
-		// Copy pbuffer to texture:
-		clEnable(CL_TEXTURE_2D);
-		clBindTexture(CL_TEXTURE_2D, selected_surface->handle);
-		clCopyTexSubImage2D(
-			CL_TEXTURE_2D,
-			0,
-			0, 0,
-			0, 0,
-			selected_surface->surface_size.width, selected_surface->surface_size.height);
-#ifdef __APPLE__
-		clFlush();
-#endif
-	}
-	pbuffer_changed = false;
-}
-
-void CL_Canvas_OpenGL::set_pbuffer_modified()
-{
-	pbuffer_changed = true;
-}
-
-/////////////////////////////////////////////////////////////////////////////
-// CL_Canvas_OpenGL implementation:
-
-#ifdef WIN32
-CL_Canvas_OpenGL::ptr_wglCreatePbufferARB CL_Canvas_OpenGL::wglCreatePbufferARB = 0;
-
-CL_Canvas_OpenGL::ptr_wglGetPbufferDCARB CL_Canvas_OpenGL::wglGetPbufferDCARB = 0;
-
-CL_Canvas_OpenGL::ptr_wglReleasePbufferDCARB CL_Canvas_OpenGL::wglReleasePbufferDCARB = 0;
-
-CL_Canvas_OpenGL::ptr_wglDestroyPbufferARB CL_Canvas_OpenGL::wglDestroyPbufferARB = 0;
-
-CL_Canvas_OpenGL::ptr_wglQueryPbufferARB CL_Canvas_OpenGL::wglQueryPbufferARB = 0;
-#else
-#ifndef __APPLE__
-CL_Canvas_OpenGL::ptr_glXCreateGLXPbufferSGIX CL_Canvas_OpenGL::glXCreateGLXPbufferSGIX = 0;
-
-CL_Canvas_OpenGL::ptr_glXDestroyGLXPbufferSGIX CL_Canvas_OpenGL::glXDestroyGLXPbufferSGIX = 0;
-
-CL_Canvas_OpenGL::ptr_glXQueryGLXPbufferSGIX CL_Canvas_OpenGL::glXQueryGLXPbufferSGIX = 0;
-
-CL_Canvas_OpenGL::ptr_glXSelectEventSGIX CL_Canvas_OpenGL::glXSelectEventSGIX = 0;
-
-CL_Canvas_OpenGL::ptr_glXGetSelectedEventSGIX CL_Canvas_OpenGL::glXGetSelectedEventSGIX = 0;
-
-CL_Canvas_OpenGL::ptr_glXChooseFBConfigSGIX CL_Canvas_OpenGL::glXChooseFBConfigSGIX = 0;
-	
-CL_Canvas_OpenGL::ptr_glXCreateContextWithConfigSGIX CL_Canvas_OpenGL::glXCreateContextWithConfigSGIX = 0;
-#endif
-#endif

Copied: trunk/flexlay/external/clanlib/GL/canvas_opengl.cpp (from rev 713, trunk/flexlay/clanlib/GL/canvas_opengl.cpp)

Modified: trunk/flexlay/lib/SConscript
===================================================================
--- trunk/flexlay/lib/SConscript	2009-11-22 03:07:59 UTC (rev 715)
+++ trunk/flexlay/lib/SConscript	2009-11-22 03:24:33 UTC (rev 716)
@@ -50,82 +50,7 @@
 libflexlay_env = env.Clone()
 flexlay_lib = libflexlay_env.StaticLibrary(
     target = 'libflexlay.a',
-    source = [
-    'blitter.cpp',
-    'box.cpp',
-    'brush.cpp',
-    'generated_brush.cpp',
-    'brushmask.cpp',
-    'command_group.cpp',
-    'command.cpp',
-    'console.cpp',
-    'colorpicker.cpp',
-    'drawer_properties.cpp',
-    'editor_map.cpp',
-    'editor_map_component.cpp',
-    'flexlay.cpp',
-    'globals.cpp',
-    'layer.cpp',
-    'helper.cpp', 
-    'graphic_context_state.cpp',
-    'gui_manager.cpp',
-    'icon.cpp',
-    'directory_view.cpp',
-    'fonts.cpp',
-    'minimap.cpp',
-    'meta_data.cpp',
-    'onion_skin_layer.cpp',
-    'object_layer.cpp',
-    'object_add_command.cpp',
-    'object_brush.cpp',
-    'object_delete_command.cpp',
-    'object_move_command.cpp',
-    'object_selector.cpp',
-    'object_transform_command.cpp',
-    'objmap_object.cpp',
-    'objmap_path_node.cpp',
-    'objmap_object_impl.cpp',
-    'objmap_sprite_object.cpp',
-    'objmap_control_point.cpp',
-    'objmap_rect_object.cpp',
-    'paint_command.cpp',
-    'panel.cpp',
-    'menu.cpp',
-    'menubar.cpp',
-    'popup_menu.cpp',
-    'lispreader.cpp',
-    'bitmap_layer.cpp',
-    'sketch_layer.cpp',
-    'stroke.cpp',
-    'stroke_drawer.cpp',
-    'sprite_stroke_drawer.cpp',
-    'sprite_brush.cpp',
-    'marker_stroke_drawer.cpp',
-    'slider.cpp', 
-    'scrollbar.cpp',
-    'tile.cpp',
-    'titlebar.cpp',
-    'tile_brush.cpp',
-    'tile_provider.cpp',
-    'tile_editor.cpp',
-    'tile_selection.cpp',
-    'tile_selector.cpp',
-    'tilemap_layer.cpp',
-    'tileset.cpp',
-    'workspace.cpp',
-    'window.cpp',
-    'viewport.cpp',
-
-    'tools/tool.cpp',
-    'tools/tilemap_paint_tool.cpp',
-    'tools/tilemap_select_tool.cpp',
-    'tools/sketch_stroke_tool.cpp',
-    'tools/objmap_select_tool.cpp',
-    'tools/layer_move_tool.cpp',
-    'tools/workspace_move_tool.cpp',
-    'tools/zoom_tool.cpp',
-    'tools/zoom2_tool.cpp'
-    ],
+    source = Glob('*.cpp') + Glob('*/*.cpp'),
     CPPPATH = ['.', '..'] + clanLib_env['CPPPATH'],
     CXXFLAGS  = env['CXXFLAGS'] + clanLib_env['CCFLAGS'],
     LINKFLAGS = clanLib_env['LINKFLAGS'],

Deleted: trunk/flexlay/lib/paned.cpp
===================================================================
--- trunk/flexlay/lib/paned.cpp	2009-11-22 03:07:59 UTC (rev 715)
+++ trunk/flexlay/lib/paned.cpp	2009-11-22 03:24:33 UTC (rev 716)
@@ -1,45 +0,0 @@
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "paned.hpp"
-
-class PanedImpl
-{
-public:
-  CL_Component* first;
-  CL_Component* second;
-};
-
-Paned::Paned(CL_Component* parent)
-  : impl(new PanedImpl())
-{
-  impl->first  = 0;
-  impl->second = 0;
-}
-
-void
-Paned::set_first(CL_Component* first)
-{
-  impl->first = first;
-}
-
-void
-Paned::set_second(CL_Component* second)
-{
-  impl->second = second;
-}
-
-/* EOF */

Deleted: trunk/flexlay/lib/paned.hpp
===================================================================
--- trunk/flexlay/lib/paned.hpp	2009-11-22 03:07:59 UTC (rev 715)
+++ trunk/flexlay/lib/paned.hpp	2009-11-22 03:24:33 UTC (rev 716)
@@ -1,38 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_PANED_HXX
-#define HEADER_PANED_HXX
-
-/** */
-class Paned : public CL_Component
-{
-protected:
-  virtual Paned() {}
-public:
-  Paned(CL_Component* parent);
-  
-  void set_first(CL_Component* );
-  void set_second(CL_Component* );
-private:
-  SharedPtr<PanedImpl> impl;
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/flexlay/lib/serializer.cpp
===================================================================
--- trunk/flexlay/lib/serializer.cpp	2009-11-22 03:07:59 UTC (rev 715)
+++ trunk/flexlay/lib/serializer.cpp	2009-11-22 03:24:33 UTC (rev 716)
@@ -1,39 +0,0 @@
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "serializer.hpp"
-
-Serializer
-Serializer::register_group (const char* name)
-{
-}
-
-void
-Serializer::register_float (const char* name, float& value)
-{
-}
-
-void
-Serializer::register_int   (const char* name, int& value)
-{
-}
-
-void
-Serializer::register_string(const char* name, std::string& value)
-{
-}
-
-/* EOF */

Deleted: trunk/flexlay/lib/serializer.hpp
===================================================================
--- trunk/flexlay/lib/serializer.hpp	2009-11-22 03:07:59 UTC (rev 715)
+++ trunk/flexlay/lib/serializer.hpp	2009-11-22 03:24:33 UTC (rev 716)
@@ -1,43 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_SERIALIZER_HXX
-#define HEADER_SERIALIZER_HXX
-
-/** */
-class Serializer
-{
-private:
-public:
-  Serializer() {}
-  
-  voi  register_group_start (const char* name) =0;
-  voi  register_group_end   () =0;
-
-  void register_float (const char* name, float& value) =0;
-  void register_int   (const char* name, int& value)   =0;
-  void register_string(const char* name, std::string& value) =0;
-
-private:
-  Serializer (const Serializer&);
-  Serializer& operator= (const Serializer&);
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/flexlay/lib/sexpr_serializer.cpp
===================================================================
--- trunk/flexlay/lib/sexpr_serializer.cpp	2009-11-22 03:07:59 UTC (rev 715)
+++ trunk/flexlay/lib/sexpr_serializer.cpp	2009-11-22 03:24:33 UTC (rev 716)
@@ -1,50 +0,0 @@
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "sexpr_serializer.hpp"
-
-SexprSerializer::SexprSerializer() 
-{
-}
-  
-void
-SexprSerializer::register_group_start (const char* name)
-{
-  
-}
-
-void
-SexprSerializer::register_group_end   ()
-{
-}
-
-void
-SexprSerializer::register_float (const char* name, float& value)
-{
-  
-}
-
-void
-SexprSerializer::register_int   (const char* name, int& value)
-{
-}
-
-void
-SexprSerializer::register_string(const char* name, std::string& value)
-{
-}
-
-/* EOF */

Deleted: trunk/flexlay/lib/sexpr_serializer.hpp
===================================================================
--- trunk/flexlay/lib/sexpr_serializer.hpp	2009-11-22 03:07:59 UTC (rev 715)
+++ trunk/flexlay/lib/sexpr_serializer.hpp	2009-11-22 03:24:33 UTC (rev 716)
@@ -1,43 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_SEXPR_SERIALIZER_HXX
-#define HEADER_SEXPR_SERIALIZER_HXX
-
-/** */
-class SexprSerializer
-{
-private:
-  
-public:
-  SexprSerializer() {}
-  
-  voi  register_group_start (const char* name);
-  voi  register_group_end   ();
-
-  void register_float (const char* name, float& value);
-  void register_int   (const char* name, int& value);
-  void register_string(const char* name, std::string& value);
-
-  /** Return a string representing the serialized objects */
-  std::string get_string();
-};
-
-#endif
-
-/* EOF */

Modified: trunk/flexlay/lib/simpleed.cpp
===================================================================
--- trunk/flexlay/lib/simpleed.cpp	2009-11-22 03:07:59 UTC (rev 715)
+++ trunk/flexlay/lib/simpleed.cpp	2009-11-22 03:24:33 UTC (rev 716)
@@ -14,6 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
+#if 0
+
 #include <iostream>
 #include <string>
 #include <ClanLib/core.h>
@@ -62,4 +64,6 @@
   flexlay.deinit();
 }
 
+#endif
+
 /* EOF */

Deleted: trunk/flexlay/lib/simpleed.hpp
===================================================================
--- trunk/flexlay/lib/simpleed.hpp	2009-11-22 03:07:59 UTC (rev 715)
+++ trunk/flexlay/lib/simpleed.hpp	2009-11-22 03:24:33 UTC (rev 716)
@@ -1,26 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_SIMPLEED_HXX
-#define HEADER_SIMPLEED_HXX
-
-
-
-#endif
-
-/* EOF */



From grumbel at mail.berlios.de  Sun Nov 22 04:25:41 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 22 Nov 2009 04:25:41 +0100
Subject: [Flexlay-commit] r717 - trunk/flexlay
Message-ID: <200911220325.nAM3Pf5P022814@sheep.berlios.de>

Author: grumbel
Date: 2009-11-22 04:25:40 +0100 (Sun, 22 Nov 2009)
New Revision: 717

Removed:
   trunk/flexlay/guile/
Log:
Deleted Guile code



From grumbel at mail.berlios.de  Sun Nov 22 04:27:12 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 22 Nov 2009 04:27:12 +0100
Subject: [Flexlay-commit] r718 - trunk/flexlay
Message-ID: <200911220327.nAM3RCp9022864@sheep.berlios.de>

Author: grumbel
Date: 2009-11-22 04:27:11 +0100 (Sun, 22 Nov 2009)
New Revision: 718

Removed:
   trunk/flexlay/ChangeLog
   trunk/flexlay/pingus/
Log:
Deleted pingus editor

Deleted: trunk/flexlay/ChangeLog
===================================================================
--- trunk/flexlay/ChangeLog	2009-11-22 03:25:40 UTC (rev 717)
+++ trunk/flexlay/ChangeLog	2009-11-22 03:27:11 UTC (rev 718)
@@ -1,744 +0,0 @@
-------------------------------------------------------------------------
-r147 | grumbel | 2004-01-10 03:19:28 +0100 (Sat, 10 Jan 2004) | 1 line
-
-
-------------------------------------------------------------------------
-r146 | grumbel | 2003-12-11 14:13:29 +0100 (Thu, 11 Dec 2003) | 2 lines
-
-- fixed frame counter
-
-------------------------------------------------------------------------
-r145 | grumbel | 2003-12-11 14:03:34 +0100 (Thu, 11 Dec 2003) | 1 line
-
-- added input/ to configure
-------------------------------------------------------------------------
-r144 | grumbel | 2003-12-11 13:59:21 +0100 (Thu, 11 Dec 2003) | 1 line
-
-- added input recording and video recording
-------------------------------------------------------------------------
-r143 | grumbel | 2003-12-05 21:57:30 +0100 (Fri, 05 Dec 2003) | 1 line
-
-- added clanlib gui stuff
-------------------------------------------------------------------------
-r142 | grumbel | 2003-12-02 22:21:13 +0100 (Tue, 02 Dec 2003) | 1 line
-
-- some cleanup of obsolote files
-------------------------------------------------------------------------
-r141 | grumbel | 2003-12-02 22:04:30 +0100 (Tue, 02 Dec 2003) | 1 line
-
-- added ignorance
-------------------------------------------------------------------------
-r138 | grumbel | 2003-12-02 17:50:41 +0100 (Tue, 02 Dec 2003) | 2 lines
-
-- disabled readline support
-
-------------------------------------------------------------------------
-r137 | grumbel | 2003-11-13 13:59:42 +0100 (Thu, 13 Nov 2003) | 2 lines
-
-- some minor bug fixes
-
-------------------------------------------------------------------------
-r136 | grumbel | 2003-11-11 15:19:04 +0100 (Tue, 11 Nov 2003) | 2 lines
-
-*** empty log message ***
-
-------------------------------------------------------------------------
-r135 | grumbel | 2003-11-07 23:41:18 +0100 (Fri, 07 Nov 2003) | 2 lines
-
-- fixed a bunch of issues that my last commit broke
-
-------------------------------------------------------------------------
-r134 | grumbel | 2003-11-07 14:00:39 +0100 (Fri, 07 Nov 2003) | 2 lines
-
-- restructed the startup a bit
-
-------------------------------------------------------------------------
-r133 | grumbel | 2003-11-06 15:44:48 +0100 (Thu, 06 Nov 2003) | 2 lines
-
-what do you do in CVS?
-
-------------------------------------------------------------------------
-r132 | grumbel | 2003-11-06 11:32:22 +0100 (Thu, 06 Nov 2003) | 2 lines
-
-- finalized the extra screen
-
-------------------------------------------------------------------------
-r131 | grumbel | 2003-11-06 10:53:43 +0100 (Thu, 06 Nov 2003) | 2 lines
-
-- more extra pics + timing for the bonus screen
-
-------------------------------------------------------------------------
-r130 | grumbel | 2003-11-06 10:47:16 +0100 (Thu, 06 Nov 2003) | 2 lines
-
-- more images
-
-------------------------------------------------------------------------
-r129 | grumbel | 2003-11-06 10:24:17 +0100 (Thu, 06 Nov 2003) | 2 lines
-
-- added better music support
-
-------------------------------------------------------------------------
-r128 | grumbel | 2003-11-06 00:00:27 +0100 (Thu, 06 Nov 2003) | 2 lines
-
-missing music
-
-------------------------------------------------------------------------
-r127 | grumbel | 2003-11-05 23:51:27 +0100 (Wed, 05 Nov 2003) | 2 lines
-
-- added some missing files
-
-------------------------------------------------------------------------
-r126 | grumbel | 2003-11-05 23:44:49 +0100 (Wed, 05 Nov 2003) | 2 lines
-
-- added extra's screen
-
-------------------------------------------------------------------------
-r125 | grumbel | 2003-11-05 14:36:17 +0100 (Wed, 05 Nov 2003) | 2 lines
-
-- fixed kill and respawn behaviour
-
-------------------------------------------------------------------------
-r124 | grumbel | 2003-11-05 13:41:37 +0100 (Wed, 05 Nov 2003) | 2 lines
-
-- added half working dead animation
-
-------------------------------------------------------------------------
-r123 | grumbel | 2003-11-05 12:09:36 +0100 (Wed, 05 Nov 2003) | 2 lines
-
-- added light and exit marker
-
-------------------------------------------------------------------------
-r122 | grumbel | 2003-11-04 23:48:51 +0100 (Tue, 04 Nov 2003) | 2 lines
-
-- fixed fadeout a bit
-
-------------------------------------------------------------------------
-r121 | grumbel | 2003-10-29 16:34:43 +0100 (Wed, 29 Oct 2003) | 2 lines
-
-- added joystick support
-
-------------------------------------------------------------------------
-r120 | grumbel | 2003-10-12 17:22:31 +0200 (Sun, 12 Oct 2003) | 2 lines
-
-missing file
-
-------------------------------------------------------------------------
-r119 | grumbel | 2003-10-12 13:58:09 +0200 (Sun, 12 Oct 2003) | 3 lines
-
-- added gui style
-- added some more or less usefull stuff to the gamegui
-
-------------------------------------------------------------------------
-r118 | grumbel | 2003-10-11 14:15:59 +0200 (Sat, 11 Oct 2003) | 2 lines
-
-- moved some stuff from WindstilleGame into ViewComponent
-
-------------------------------------------------------------------------
-r117 | grumbel | 2003-10-11 10:11:59 +0200 (Sat, 11 Oct 2003) | 3 lines
-
-- removed some now reduntant editor code
-- cleaned up gui a bit
-
-------------------------------------------------------------------------
-r116 | grumbel | 2003-10-10 23:06:22 +0200 (Fri, 10 Oct 2003) | 5 lines
-
-- some little compile fixes
-- fixed naming conflict between X11 and Windstille classes
-- seperated editor gui code into its own class
-- added gui to the game itself (just for debugging)
-
-------------------------------------------------------------------------
-r115 | grumbel | 2003-10-01 01:01:06 +0200 (Wed, 01 Oct 2003) | 2 lines
-
-- added some missing tiles
-
-------------------------------------------------------------------------
-r114 | grumbel | 2003-09-30 18:47:39 +0200 (Tue, 30 Sep 2003) | 2 lines
-
-- fixed broken igel
-
-------------------------------------------------------------------------
-r113 | grumbel | 2003-09-30 18:42:26 +0200 (Tue, 30 Sep 2003) | 3 lines
-
-- added startup dialog
-- added dynamic resize of dialog box
-
-------------------------------------------------------------------------
-r112 | grumbel | 2003-09-30 00:20:57 +0200 (Tue, 30 Sep 2003) | 2 lines
-
-- added clanSound/Vorbis check
-
-------------------------------------------------------------------------
-r111 | grumbel | 2003-09-29 23:51:40 +0200 (Mon, 29 Sep 2003) | 2 lines
-
-- added music
-
-------------------------------------------------------------------------
-r110 | grumbel | 2003-09-29 23:26:46 +0200 (Mon, 29 Sep 2003) | 2 lines
-
-- added some fadeout stuff
-
-------------------------------------------------------------------------
-r109 | grumbel | 2003-09-29 21:56:42 +0200 (Mon, 29 Sep 2003) | 2 lines
-
-- made menu useable
-
-------------------------------------------------------------------------
-r108 | grumbel | 2003-09-29 21:29:17 +0200 (Mon, 29 Sep 2003) | 2 lines
-
-- added (non-working) menu
-
-------------------------------------------------------------------------
-r107 | grumbel | 2003-09-28 18:58:04 +0200 (Sun, 28 Sep 2003) | 2 lines
-
-- added functions to adjust game speed
-
-------------------------------------------------------------------------
-r106 | grumbel | 2003-09-28 13:00:25 +0200 (Sun, 28 Sep 2003) | 2 lines
-
-- added bomb/igel collision
-
-------------------------------------------------------------------------
-r105 | grumbel | 2003-09-28 12:55:34 +0200 (Sun, 28 Sep 2003) | 2 lines
-
-- added bomb/igel collision
-
-------------------------------------------------------------------------
-r104 | grumbel | 2003-09-27 22:57:39 +0200 (Sat, 27 Sep 2003) | 2 lines
-
-- fixed igel a bit, added diamond counting
-
-------------------------------------------------------------------------
-r103 | grumbel | 2003-09-27 10:29:12 +0200 (Sat, 27 Sep 2003) | 3 lines
-
-- added another tree tile
-- added function to return the passed time
-
-------------------------------------------------------------------------
-r102 | grumbel | 2003-09-26 16:29:36 +0200 (Fri, 26 Sep 2003) | 2 lines
-
-- added per level scripts
-
-------------------------------------------------------------------------
-r101 | grumbel | 2003-09-24 20:19:13 +0200 (Wed, 24 Sep 2003) | 2 lines
-
-- some more diamond support
-
-------------------------------------------------------------------------
-r100 | grumbel | 2003-09-24 13:52:00 +0200 (Wed, 24 Sep 2003) | 2 lines
-
-- more levels
-
-------------------------------------------------------------------------
-r99 | grumbel | 2003-09-24 13:49:19 +0200 (Wed, 24 Sep 2003) | 2 lines
-
-- completed level9 a bit more
-
-------------------------------------------------------------------------
-r98 | grumbel | 2003-09-24 01:08:00 +0200 (Wed, 24 Sep 2003) | 2 lines
-
-- new level
-
-------------------------------------------------------------------------
-r97 | grumbel | 2003-09-24 00:10:40 +0200 (Wed, 24 Sep 2003) | 2 lines
-
-- some more tool seperation
-
-------------------------------------------------------------------------
-r96 | grumbel | 2003-09-23 21:41:23 +0200 (Tue, 23 Sep 2003) | 2 lines
-
-- small level
-
-------------------------------------------------------------------------
-r95 | grumbel | 2003-09-23 21:33:43 +0200 (Tue, 23 Sep 2003) | 2 lines
-
-- added limitation to view pos
-
-------------------------------------------------------------------------
-r94 | grumbel | 2003-09-23 21:10:05 +0200 (Tue, 23 Sep 2003) | 2 lines
-
-- seperated tilemap tool  into seperate class
-
-------------------------------------------------------------------------
-r93 | grumbel | 2003-09-23 12:48:03 +0200 (Tue, 23 Sep 2003) | 3 lines
-
-- improved some tiles
-- let editor keep track of the name of the current level
-
-------------------------------------------------------------------------
-r92 | grumbel | 2003-09-22 20:37:05 +0200 (Mon, 22 Sep 2003) | 2 lines
-
-- added tile editor
-
-------------------------------------------------------------------------
-r91 | grumbel | 2003-09-22 11:13:16 +0200 (Mon, 22 Sep 2003) | 2 lines
-
-- more tiles
-
-------------------------------------------------------------------------
-r90 | grumbel | 2003-09-22 00:10:29 +0200 (Mon, 22 Sep 2003) | 2 lines
-
-- some tile stuff
-
-------------------------------------------------------------------------
-r89 | grumbel | 2003-09-21 23:57:40 +0200 (Sun, 21 Sep 2003) | 2 lines
-
-- added some new tiles with new naming convention
-
-------------------------------------------------------------------------
-r88 | grumbel | 2003-09-21 20:24:37 +0200 (Sun, 21 Sep 2003) | 2 lines
-
-- added readline check
-
-------------------------------------------------------------------------
-r87 | grumbel | 2003-09-21 20:05:21 +0200 (Sun, 21 Sep 2003) | 2 lines
-
-- optimized tiledrawing a bit (speed from 90% CPU usage to something hardly noticable ;)
-
-------------------------------------------------------------------------
-r86 | grumbel | 2003-09-21 19:34:54 +0200 (Sun, 21 Sep 2003) | 2 lines
-
-- some dialog triggery
-
-------------------------------------------------------------------------
-r85 | grumbel | 2003-09-21 17:22:59 +0200 (Sun, 21 Sep 2003) | 2 lines
-
-- hooked up dialog stuff a bit into the scripting
-
-------------------------------------------------------------------------
-r84 | grumbel | 2003-09-21 10:49:47 +0200 (Sun, 21 Sep 2003) | 2 lines
-
-some more image goodiness
-
-------------------------------------------------------------------------
-r83 | grumbel | 2003-09-20 23:55:57 +0200 (Sat, 20 Sep 2003) | 2 lines
-
-- seperated some junk out of windstille_game
-
-------------------------------------------------------------------------
-r82 | grumbel | 2003-09-20 23:53:38 +0200 (Sat, 20 Sep 2003) | 3 lines
-
-- fixed jump behaviour
-- cleaned up controller and made it event driven (more or less)
-
-------------------------------------------------------------------------
-r81 | grumbel | 2003-09-17 20:48:45 +0200 (Wed, 17 Sep 2003) | 2 lines
-
-- added some simple trigger code
-
-------------------------------------------------------------------------
-r80 | grumbel | 2003-09-15 19:00:38 +0200 (Mon, 15 Sep 2003) | 2 lines
-
-- fixed stuff to suit clanlib-0.7 cvs
-
-------------------------------------------------------------------------
-r79 | grumbel | 2003-09-13 20:37:57 +0200 (Sat, 13 Sep 2003) | 2 lines
-
-*** empty log message ***
-
-------------------------------------------------------------------------
-r78 | grumbel | 2003-09-13 20:01:17 +0200 (Sat, 13 Sep 2003) | 2 lines
-
-*** empty log message ***
-
-------------------------------------------------------------------------
-r77 | grumbel | 2003-09-13 19:54:40 +0200 (Sat, 13 Sep 2003) | 2 lines
-
-- some more gfx
-
-------------------------------------------------------------------------
-r76 | grumbel | 2003-09-13 12:19:08 +0200 (Sat, 13 Sep 2003) | 2 lines
-
-- fixed update behaviour a bit
-
-------------------------------------------------------------------------
-r75 | grumbel | 2003-09-13 12:11:33 +0200 (Sat, 13 Sep 2003) | 2 lines
-
-- added a first enemy and energie
-
-------------------------------------------------------------------------
-r74 | grumbel | 2003-09-13 00:41:06 +0200 (Sat, 13 Sep 2003) | 2 lines
-
-- added some stupid code to collect diamonds
-
-------------------------------------------------------------------------
-r73 | grumbel | 2003-09-13 00:14:03 +0200 (Sat, 13 Sep 2003) | 2 lines
-
-- added energiebar
-
-------------------------------------------------------------------------
-r72 | grumbel | 2003-09-12 23:43:21 +0200 (Fri, 12 Sep 2003) | 2 lines
-
-- changed splash function
-
-------------------------------------------------------------------------
-r71 | grumbel | 2003-09-12 22:57:29 +0200 (Fri, 12 Sep 2003) | 2 lines
-
-- some cleanup
-
-------------------------------------------------------------------------
-r70 | grumbel | 2003-09-12 22:17:06 +0200 (Fri, 12 Sep 2003) | 4 lines
-
-- added watersplash
-- added water to levelfile
-- seperated scripting a bit
-
-------------------------------------------------------------------------
-r69 | grumbel | 2003-09-12 18:31:21 +0200 (Fri, 12 Sep 2003) | 2 lines
-
-- added diamonds and water
-
-------------------------------------------------------------------------
-r68 | grumbel | 2003-09-12 11:25:48 +0200 (Fri, 12 Sep 2003) | 2 lines
-
-- fixed out-of-bounce crash
-
-------------------------------------------------------------------------
-r67 | grumbel | 2003-09-12 10:27:41 +0200 (Fri, 12 Sep 2003) | 2 lines
-
-- another experimental level
-
-------------------------------------------------------------------------
-r66 | grumbel | 2003-09-11 22:11:01 +0200 (Thu, 11 Sep 2003) | 2 lines
-
-- added some simple file dialogs
-
-------------------------------------------------------------------------
-r65 | grumbel | 2003-09-11 20:58:19 +0200 (Thu, 11 Sep 2003) | 2 lines
-
-- added some load save stuff
-
-------------------------------------------------------------------------
-r64 | grumbel | 2003-09-10 20:56:03 +0200 (Wed, 10 Sep 2003) | 2 lines
-
-- added support for multilayer tilemaps
-
-------------------------------------------------------------------------
-r63 | grumbel | 2003-09-10 15:58:30 +0200 (Wed, 10 Sep 2003) | 4 lines
-
-- added tile selector to the editor
-- fixed few bugs in editor code
-- editor now already half useable
-
-------------------------------------------------------------------------
-r62 | grumbel | 2003-09-10 15:53:11 +0200 (Wed, 10 Sep 2003) | 4 lines
-
-- added tile selector to the editor
-- fixed few bugs in editor code
-- editor now already half useable
-
-------------------------------------------------------------------------
-r61 | grumbel | 2003-09-10 12:58:29 +0200 (Wed, 10 Sep 2003) | 2 lines
-
-- fixed the editor a bit, scrolling around and viewing levels is now possible
-
-------------------------------------------------------------------------
-r60 | grumbel | 2003-09-10 10:25:29 +0200 (Wed, 10 Sep 2003) | 3 lines
-
-- started editor rewrite
-- added scripting support for gui (still pretty much experimental)
-
-------------------------------------------------------------------------
-r59 | grumbel | 2003-09-08 21:59:57 +0200 (Mon, 08 Sep 2003) | 4 lines
-
-- made the game independed of the start path
-- moved args_parse into ClanLib
-- added CL_CommandLine argument parsing
-
-------------------------------------------------------------------------
-r58 | grumbel | 2003-09-07 23:01:45 +0200 (Sun, 07 Sep 2003) | 2 lines
-
-- changed API to be more DirectoryScanner like
-
-------------------------------------------------------------------------
-r57 | grumbel | 2003-09-06 22:38:18 +0200 (Sat, 06 Sep 2003) | 3 lines
-
-- ClanLib nameing style and indention
-- _Generic seperation
-
-------------------------------------------------------------------------
-r56 | grumbel | 2003-09-06 19:29:07 +0200 (Sat, 06 Sep 2003) | 2 lines
-
-- added special handling for usage and extra docu
-
-------------------------------------------------------------------------
-r55 | grumbel | 2003-09-06 17:13:18 +0200 (Sat, 06 Sep 2003) | 2 lines
-
-- fixed bug that caused a single '-' not to be threaded as rest argument
-
-------------------------------------------------------------------------
-r54 | grumbel | 2003-09-06 17:05:10 +0200 (Sat, 06 Sep 2003) | 2 lines
-
-changed class layout a bit so that one doesn't have to derive from ArgsParse
-
-------------------------------------------------------------------------
-r53 | grumbel | 2003-09-06 13:48:01 +0200 (Sat, 06 Sep 2003) | 2 lines
-
-added docu
-
-------------------------------------------------------------------------
-r52 | grumbel | 2003-09-06 13:14:16 +0200 (Sat, 06 Sep 2003) | 3 lines
-
-- added support for --foobar=foo style options
-- option argument is now printed in help
-
-------------------------------------------------------------------------
-r51 | grumbel | 2003-09-05 22:41:52 +0200 (Fri, 05 Sep 2003) | 2 lines
-
-- added argument parser
-
-------------------------------------------------------------------------
-r50 | grumbel | 2003-09-05 00:51:04 +0200 (Fri, 05 Sep 2003) | 3 lines
-
-- fixed bug in scaling collision check
-- added seperate x/y axis for scaling collision check
-
-------------------------------------------------------------------------
-r49 | grumbel | 2003-09-03 00:25:23 +0200 (Wed, 03 Sep 2003) | 2 lines
-
-- fixed bug in scaling test, but still buggy
-
-------------------------------------------------------------------------
-r48 | grumbel | 2003-09-03 00:05:02 +0200 (Wed, 03 Sep 2003) | 3 lines
-
-- added collisionsprite
-- added some support for scaling (broken)
-
-------------------------------------------------------------------------
-r47 | grumbel | 2003-09-02 15:52:04 +0200 (Tue, 02 Sep 2003) | 2 lines
-
-- added benchmark
-
-------------------------------------------------------------------------
-r46 | grumbel | 2003-09-02 15:51:43 +0200 (Tue, 02 Sep 2003) | 2 lines
-
-replaced a few 32 with int_width
-
-------------------------------------------------------------------------
-r45 | grumbel | 2003-09-02 13:16:35 +0200 (Tue, 02 Sep 2003) | 2 lines
-
-- a bug fix and some docu
-
-------------------------------------------------------------------------
-r44 | grumbel | 2003-09-02 13:01:44 +0200 (Tue, 02 Sep 2003) | 2 lines
-
-- seems to work now and I might even know why... time for some more testing
-
-------------------------------------------------------------------------
-r43 | grumbel | 2003-09-02 12:33:01 +0200 (Tue, 02 Sep 2003) | 2 lines
-
-- seems to work, not sure why
-
-------------------------------------------------------------------------
-r42 | grumbel | 2003-09-02 01:43:16 +0200 (Tue, 02 Sep 2003) | 2 lines
-
-- at least 32xHEIGHT is working, rest not, but doesn't look completly wrong
-
-------------------------------------------------------------------------
-r41 | grumbel | 2003-09-01 22:56:57 +0200 (Mon, 01 Sep 2003) | 2 lines
-
-- at least 32xHEIGHT is working...
-
-------------------------------------------------------------------------
-r40 | grumbel | 2003-09-01 17:36:02 +0200 (Mon, 01 Sep 2003) | 2 lines
-
-- some code for pixel perfect collisions
-
-------------------------------------------------------------------------
-r39 | grumbel | 2003-08-28 19:15:31 +0200 (Thu, 28 Aug 2003) | 2 lines
-
-start script for windows
-
-------------------------------------------------------------------------
-r38 | grumbel | 2003-08-23 10:32:28 +0200 (Sat, 23 Aug 2003) | 2 lines
-
-- new music
-
-------------------------------------------------------------------------
-r37 | grumbel | 2003-08-19 15:49:37 +0200 (Tue, 19 Aug 2003) | 2 lines
-
-- removed obsolete files
-
-------------------------------------------------------------------------
-r36 | grumbel | 2003-08-19 15:40:48 +0200 (Tue, 19 Aug 2003) | 2 lines
-
-- added missing assert.h's
-
-------------------------------------------------------------------------
-r35 | grumbel | 2003-08-19 12:33:20 +0200 (Tue, 19 Aug 2003) | 2 lines
-
-- more tiles
-
-------------------------------------------------------------------------
-r34 | grumbel | 2003-08-18 21:53:05 +0200 (Mon, 18 Aug 2003) | 2 lines
-
-- more tiles
-
-------------------------------------------------------------------------
-r33 | grumbel | 2003-08-18 17:14:43 +0200 (Mon, 18 Aug 2003) | 2 lines
-
-- increased level size a bit, more tiles
-
-------------------------------------------------------------------------
-r32 | grumbel | 2003-08-18 10:52:06 +0200 (Mon, 18 Aug 2003) | 2 lines
-
-- added windstille binary start script
-
-------------------------------------------------------------------------
-r31 | grumbel | 2003-08-18 10:50:22 +0200 (Mon, 18 Aug 2003) | 3 lines
-
-- added a few more gfx
-- added a second tile layer (background-tilemap)
-
-------------------------------------------------------------------------
-r30 | grumbel | 2003-08-13 15:49:32 +0200 (Wed, 13 Aug 2003) | 2 lines
-
-- fixed build rules, made release
-
-------------------------------------------------------------------------
-r29 | grumbel | 2003-08-13 01:41:48 +0200 (Wed, 13 Aug 2003) | 2 lines
-
-- added code for static linking
-
-------------------------------------------------------------------------
-r28 | grumbel | 2003-08-12 21:38:08 +0200 (Tue, 12 Aug 2003) | 2 lines
-
-- fixed make dist
-
-------------------------------------------------------------------------
-r27 | grumbel | 2003-08-12 21:30:02 +0200 (Tue, 12 Aug 2003) | 2 lines
-
-- cleanup
-
-------------------------------------------------------------------------
-r26 | grumbel | 2003-08-12 21:24:21 +0200 (Tue, 12 Aug 2003) | 2 lines
-
-- cleanup
-
-------------------------------------------------------------------------
-r25 | grumbel | 2003-08-12 21:09:50 +0200 (Tue, 12 Aug 2003) | 2 lines
-
-- cleanup
-
-------------------------------------------------------------------------
-r24 | grumbel | 2003-08-12 16:37:03 +0200 (Tue, 12 Aug 2003) | 4 lines
-
-- added darkning
-- added logo
-- updated INSTALL and README
-
-------------------------------------------------------------------------
-r23 | grumbel | 2003-08-12 16:34:56 +0200 (Tue, 12 Aug 2003) | 2 lines
-
-- more gfx
-
-------------------------------------------------------------------------
-r22 | grumbel | 2003-08-12 10:58:49 +0200 (Tue, 12 Aug 2003) | 2 lines
-
-- added indicator for current active tile
-
-------------------------------------------------------------------------
-r21 | grumbel | 2003-08-12 10:24:41 +0200 (Tue, 12 Aug 2003) | 3 lines
-
-- fixed copyright header
-- some cleanup
-
-------------------------------------------------------------------------
-r20 | grumbel | 2003-08-11 23:50:35 +0200 (Mon, 11 Aug 2003) | 3 lines
-
-- tweaked the player behaviour a little bit
-- added friendlier sky color
-
-------------------------------------------------------------------------
-r19 | grumbel | 2003-08-11 22:26:07 +0200 (Mon, 11 Aug 2003) | 2 lines
-
-- some cleanup and new gfx
-
-------------------------------------------------------------------------
-r18 | grumbel | 2003-08-11 21:54:22 +0200 (Mon, 11 Aug 2003) | 2 lines
-
-- fixed crash bug
-
-------------------------------------------------------------------------
-r17 | grumbel | 2003-08-11 21:50:12 +0200 (Mon, 11 Aug 2003) | 3 lines
-
-- cleaned level format up a bit
-- integrated tile factory
-
-------------------------------------------------------------------------
-r16 | grumbel | 2003-08-11 13:19:41 +0200 (Mon, 11 Aug 2003) | 2 lines
-
-- cleanup, added handling for sub-tile collision
-
-------------------------------------------------------------------------
-r15 | grumbel | 2003-08-11 13:18:11 +0200 (Mon, 11 Aug 2003) | 2 lines
-
-- added definition file for tiles
-
-------------------------------------------------------------------------
-r14 | grumbel | 2003-08-11 12:04:38 +0200 (Mon, 11 Aug 2003) | 2 lines
-
-- cleanup, added handling for sub-tile collision
-
-------------------------------------------------------------------------
-r13 | grumbel | 2003-08-11 10:03:23 +0200 (Mon, 11 Aug 2003) | 3 lines
-
-- added support for 128x128 tiles
-- added colorfull background gradient
-
-------------------------------------------------------------------------
-r12 | grumbel | 2003-08-11 00:55:50 +0200 (Mon, 11 Aug 2003) | 2 lines
-
-- replaced xml with guile
-
-------------------------------------------------------------------------
-r11 | grumbel | 2003-08-10 21:58:39 +0200 (Sun, 10 Aug 2003) | 2 lines
-
-- renamed files to lowercase
-
-------------------------------------------------------------------------
-r10 | grumbel | 2003-08-10 21:30:03 +0200 (Sun, 10 Aug 2003) | 2 lines
-
-- fixed game to compile and run again
-
-------------------------------------------------------------------------
-r9 | grumbel | 2003-08-06 19:29:19 +0200 (Wed, 06 Aug 2003) | 2 lines
-
-- some CL0.7 fixes
-
-------------------------------------------------------------------------
-r8 | grumbel | 2003-08-06 19:16:19 +0200 (Wed, 06 Aug 2003) | 2 lines
-
-- some cleanup
-
-------------------------------------------------------------------------
-r7 | grumbel | 2002-09-01 15:07:53 +0200 (Sun, 01 Sep 2002) | 2 lines
-
-ported .scr file over to ClanLib-0.7, game runs again now (slow like hell and hero sprite is missing...)
-
-------------------------------------------------------------------------
-r6 | grumbel | 2002-09-01 02:05:33 +0200 (Sun, 01 Sep 2002) | 2 lines
-
-made it compilable with ClanLib-0.7
-
-------------------------------------------------------------------------
-r5 | grumbel | 2002-08-28 22:59:10 +0200 (Wed, 28 Aug 2002) | 2 lines
-
-byebye mp3, welcome ogg
-
-------------------------------------------------------------------------
-r4 | grumbel | 2002-08-25 12:48:07 +0200 (Sun, 25 Aug 2002) | 2 lines
-
-- added title song from Ralph Weinert
-
-------------------------------------------------------------------------
-r3 | grumbel | 2002-03-19 19:05:02 +0100 (Tue, 19 Mar 2002) | 2 lines
-
-Added missing file
-
-------------------------------------------------------------------------
-r1 | grumbel | 2002-03-19 18:56:44 +0100 (Tue, 19 Mar 2002) | 2 lines
-
-Initial revision
-
-------------------------------------------------------------------------



From grumbel at mail.berlios.de  Sun Nov 22 04:27:57 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 22 Nov 2009 04:27:57 +0100
Subject: [Flexlay-commit] r719 - trunk/flexlay
Message-ID: <200911220327.nAM3RvN7022943@sheep.berlios.de>

Author: grumbel
Date: 2009-11-22 04:27:56 +0100 (Sun, 22 Nov 2009)
New Revision: 719

Removed:
   trunk/flexlay/python/
Log:
Deleted Python code



From grumbel at mail.berlios.de  Sun Nov 22 04:32:03 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 22 Nov 2009 04:32:03 +0100
Subject: [Flexlay-commit] r720 - trunk/flexlay
Message-ID: <200911220332.nAM3W3uJ023687@sheep.berlios.de>

Author: grumbel
Date: 2009-11-22 04:32:02 +0100 (Sun, 22 Nov 2009)
New Revision: 720

Removed:
   trunk/flexlay/windstille/
Log:
Deleted Windstille editor



From grumbel at mail.berlios.de  Sun Nov 22 04:35:04 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 22 Nov 2009 04:35:04 +0100
Subject: [Flexlay-commit] r721 - in trunk/flexlay: . supertux
Message-ID: <200911220335.nAM3Z4AM023808@sheep.berlios.de>

Author: grumbel
Date: 2009-11-22 04:35:03 +0100 (Sun, 22 Nov 2009)
New Revision: 721

Removed:
   trunk/flexlay/supertux/SConstruct
Modified:
   trunk/flexlay/README
   trunk/flexlay/SConstruct
Log:
Removed dead SConscript, updated README a bit

Modified: trunk/flexlay/README
===================================================================
--- trunk/flexlay/README	2009-11-22 03:32:02 UTC (rev 720)
+++ trunk/flexlay/README	2009-11-22 03:35:03 UTC (rev 721)
@@ -9,10 +9,8 @@
 
 Supported games are at the moment:
 
- Windstille - http://www.nongnu.org/windstille/
  netPanzer  - http://netpanzer.berlios.de/
  SuperTux   - http://super-tux.sourceforge.net/
- Pingus     - http://pingus.seul.org/
 
 Other Stuff:
 

Modified: trunk/flexlay/SConstruct
===================================================================
--- trunk/flexlay/SConstruct	2009-11-22 03:32:02 UTC (rev 720)
+++ trunk/flexlay/SConstruct	2009-11-22 03:35:03 UTC (rev 721)
@@ -24,7 +24,6 @@
 SConscript(['external/clanlib/SConstruct'])
 SConscript(['lib/SConscript'])
 SConscript(['ruby/SConscript'])
-SConscript(['supertux/SConstruct'])
 SConscript(['netpanzer/SConscript'])
 
 # EOF #

Deleted: trunk/flexlay/supertux/SConstruct
===================================================================
--- trunk/flexlay/supertux/SConstruct	2009-11-22 03:32:02 UTC (rev 720)
+++ trunk/flexlay/supertux/SConstruct	2009-11-22 03:35:03 UTC (rev 721)
@@ -1,26 +0,0 @@
-## -*- mode: python -*-
-##  $Id$
-##
-##  Flexlay - A Generic 2D Game Editor
-##  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-##
-##  This program is free software; you can redistribute it and/or
-##  modify it under the terms of the GNU General Public License
-##  as published by the Free Software Foundation; either version 2
-##  of the License, or (at your option) any later version.
-##
-##  This program is distributed in the hope that it will be useful,
-##  but WITHOUT ANY WARRANTY; without even the implied warranty of
-##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-##  GNU General Public License for more details.
-##
-##  You should have received a copy of the GNU General Public License
-##  along with this program; if not, write to the Free Software
-##  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-import os
-import glob
-
-opts = Variables('custom.py')
-
-# EOF #



From grumbel at mail.berlios.de  Sun Nov 22 04:48:02 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 22 Nov 2009 04:48:02 +0100
Subject: [Flexlay-commit] r722 - in trunk/flexlay/lib: . tools
Message-ID: <200911220348.nAM3m2jO027015@sheep.berlios.de>

Author: grumbel
Date: 2009-11-22 04:48:00 +0100 (Sun, 22 Nov 2009)
New Revision: 722

Modified:
   trunk/flexlay/lib/bitmap_layer.hpp
   trunk/flexlay/lib/blitter.hpp
   trunk/flexlay/lib/box.hpp
   trunk/flexlay/lib/brush.hpp
   trunk/flexlay/lib/brush_impl.hpp
   trunk/flexlay/lib/brushmask.cpp
   trunk/flexlay/lib/brushmask.hpp
   trunk/flexlay/lib/colorpicker.cpp
   trunk/flexlay/lib/colorpicker.hpp
   trunk/flexlay/lib/command.hpp
   trunk/flexlay/lib/command_group.hpp
   trunk/flexlay/lib/command_impl.hpp
   trunk/flexlay/lib/console.hpp
   trunk/flexlay/lib/directory_view.hpp
   trunk/flexlay/lib/drawer_properties.hpp
   trunk/flexlay/lib/editor_map.hpp
   trunk/flexlay/lib/editor_map_component.hpp
   trunk/flexlay/lib/editor_names.hpp
   trunk/flexlay/lib/field.hpp
   trunk/flexlay/lib/flexlay.hpp
   trunk/flexlay/lib/fonts.hpp
   trunk/flexlay/lib/generated_brush.hpp
   trunk/flexlay/lib/globals.hpp
   trunk/flexlay/lib/graphic_context_state.hpp
   trunk/flexlay/lib/gui_manager.hpp
   trunk/flexlay/lib/helper.hpp
   trunk/flexlay/lib/icon.hpp
   trunk/flexlay/lib/layer.hpp
   trunk/flexlay/lib/layer_impl.hpp
   trunk/flexlay/lib/marker_stroke_drawer.hpp
   trunk/flexlay/lib/math.hpp
   trunk/flexlay/lib/menu.hpp
   trunk/flexlay/lib/menubar.hpp
   trunk/flexlay/lib/meta_data.hpp
   trunk/flexlay/lib/meta_data_impl.hpp
   trunk/flexlay/lib/minimap.hpp
   trunk/flexlay/lib/object_add_command.hpp
   trunk/flexlay/lib/object_brush.hpp
   trunk/flexlay/lib/object_delete_command.hpp
   trunk/flexlay/lib/object_layer.hpp
   trunk/flexlay/lib/object_move_command.hpp
   trunk/flexlay/lib/object_selector.hpp
   trunk/flexlay/lib/object_transform_command.hpp
   trunk/flexlay/lib/objmap_control_point.cpp
   trunk/flexlay/lib/objmap_control_point.hpp
   trunk/flexlay/lib/objmap_object.hpp
   trunk/flexlay/lib/objmap_object_impl.hpp
   trunk/flexlay/lib/objmap_path_node.hpp
   trunk/flexlay/lib/objmap_rect_object.cpp
   trunk/flexlay/lib/objmap_rect_object.hpp
   trunk/flexlay/lib/objmap_sprite_object.hpp
   trunk/flexlay/lib/onion_skin_layer.cpp
   trunk/flexlay/lib/onion_skin_layer.hpp
   trunk/flexlay/lib/paint_command.hpp
   trunk/flexlay/lib/panel.hpp
   trunk/flexlay/lib/popup_menu.hpp
   trunk/flexlay/lib/scrollbar.hpp
   trunk/flexlay/lib/shared_ptr.hpp
   trunk/flexlay/lib/shared_ptr_comp.hpp
   trunk/flexlay/lib/sharedptrtest.hpp
   trunk/flexlay/lib/sketch_layer.hpp
   trunk/flexlay/lib/slider.hpp
   trunk/flexlay/lib/sprite_brush.cpp
   trunk/flexlay/lib/sprite_brush.hpp
   trunk/flexlay/lib/sprite_stroke_drawer.hpp
   trunk/flexlay/lib/string_converter.hpp
   trunk/flexlay/lib/stroke.hpp
   trunk/flexlay/lib/stroke_drawer.hpp
   trunk/flexlay/lib/stroke_drawer_impl.hpp
   trunk/flexlay/lib/tile.hpp
   trunk/flexlay/lib/tile_brush.hpp
   trunk/flexlay/lib/tile_editor.hpp
   trunk/flexlay/lib/tile_provider.hpp
   trunk/flexlay/lib/tile_provider_impl.hpp
   trunk/flexlay/lib/tile_selection.hpp
   trunk/flexlay/lib/tile_selector.hpp
   trunk/flexlay/lib/tilemap_layer.hpp
   trunk/flexlay/lib/tilemap_minimap.hpp
   trunk/flexlay/lib/tileset.hpp
   trunk/flexlay/lib/titlebar.hpp
   trunk/flexlay/lib/tools/layer_move_tool.cpp
   trunk/flexlay/lib/tools/layer_move_tool.hpp
   trunk/flexlay/lib/tools/objmap_select_tool.hpp
   trunk/flexlay/lib/tools/sketch_stroke_tool.cpp
   trunk/flexlay/lib/tools/sketch_stroke_tool.hpp
   trunk/flexlay/lib/tools/tilemap_paint_tool.hpp
   trunk/flexlay/lib/tools/tilemap_select_tool.hpp
   trunk/flexlay/lib/tools/tool.hpp
   trunk/flexlay/lib/tools/tool_impl.hpp
   trunk/flexlay/lib/tools/workspace_move_tool.cpp
   trunk/flexlay/lib/tools/workspace_move_tool.hpp
   trunk/flexlay/lib/tools/zoom2_tool.hpp
   trunk/flexlay/lib/tools/zoom_tool.hpp
   trunk/flexlay/lib/viewport.hpp
   trunk/flexlay/lib/window.hpp
   trunk/flexlay/lib/workspace.hpp
Log:
Header and include guard cleanup

Modified: trunk/flexlay/lib/bitmap_layer.hpp
===================================================================
--- trunk/flexlay/lib/bitmap_layer.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/bitmap_layer.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_BITMAP_LAYER_HXX
-#define HEADER_BITMAP_LAYER_HXX
+#ifndef HEADER_FLEXLAY_BITMAP_LAYER_HPP
+#define HEADER_FLEXLAY_BITMAP_LAYER_HPP
 
 #include <vector>
 #include <ClanLib/Core/Math/point.h>

Modified: trunk/flexlay/lib/blitter.hpp
===================================================================
--- trunk/flexlay/lib/blitter.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/blitter.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_BLITTER_HXX
-#define HEADER_BLITTER_HXX
+#ifndef HEADER_FLEXLAY_BLITTER_HPP
+#define HEADER_FLEXLAY_BLITTER_HPP
 
 #include <ClanLib/Display/pixel_buffer.h>
 

Modified: trunk/flexlay/lib/box.hpp
===================================================================
--- trunk/flexlay/lib/box.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/box.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_BOX_HXX
-#define HEADER_BOX_HXX
+#ifndef HEADER_FLEXLAY_BOX_HPP
+#define HEADER_FLEXLAY_BOX_HPP
 
 #include <ClanLib/Core/Math/rect.h>
 

Modified: trunk/flexlay/lib/brush.hpp
===================================================================
--- trunk/flexlay/lib/brush.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/brush.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_BRUSH_HXX
-#define HEADER_BRUSH_HXX
+#ifndef HEADER_FLEXLAY_BRUSH_HPP
+#define HEADER_FLEXLAY_BRUSH_HPP
 
 #include "brush_impl.hpp"
 #include "shared_ptr.hpp"

Modified: trunk/flexlay/lib/brush_impl.hpp
===================================================================
--- trunk/flexlay/lib/brush_impl.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/brush_impl.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_BRUSH_IMPL_HXX
-#define HEADER_BRUSH_IMPL_HXX
+#ifndef HEADER_FLEXLAY_BRUSH_IMPL_HPP
+#define HEADER_FLEXLAY_BRUSH_IMPL_HPP
 
 #include <ClanLib/Display/sprite.h>
 

Modified: trunk/flexlay/lib/brushmask.cpp
===================================================================
--- trunk/flexlay/lib/brushmask.cpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/brushmask.cpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2004 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/brushmask.hpp
===================================================================
--- trunk/flexlay/lib/brushmask.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/brushmask.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2004 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_BRUSHMASK_HXX
-#define HEADER_BRUSHMASK_HXX
+#ifndef HEADER_FLEXLAY_BRUSHMASK_HPP
+#define HEADER_FLEXLAY_BRUSHMASK_HPP
 
 #include <ClanLib/Display/pixel_buffer.h>
 

Modified: trunk/flexlay/lib/colorpicker.cpp
===================================================================
--- trunk/flexlay/lib/colorpicker.cpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/colorpicker.cpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/colorpicker.hpp
===================================================================
--- trunk/flexlay/lib/colorpicker.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/colorpicker.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_COLORPICKER_HXX
-#define HEADER_COLORPICKER_HXX
+#ifndef HEADER_FLEXLAY_COLORPICKER_HPP
+#define HEADER_FLEXLAY_COLORPICKER_HPP
 
 #include <ClanLib/Display/display.h>
 #include <ClanLib/Display/color.h>

Modified: trunk/flexlay/lib/command.hpp
===================================================================
--- trunk/flexlay/lib/command.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/command.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_COMMAND_HXX
-#define HEADER_COMMAND_HXX
+#ifndef HEADER_FLEXLAY_COMMAND_HPP
+#define HEADER_FLEXLAY_COMMAND_HPP
 
 #include <iosfwd>
 #include "shared_ptr.hpp"

Modified: trunk/flexlay/lib/command_group.hpp
===================================================================
--- trunk/flexlay/lib/command_group.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/command_group.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_COMMAND_GROUP_HXX
-#define HEADER_COMMAND_GROUP_HXX
+#ifndef HEADER_FLEXLAY_COMMAND_GROUP_HPP
+#define HEADER_FLEXLAY_COMMAND_GROUP_HPP
 
 #include <vector>
 #include "command.hpp"

Modified: trunk/flexlay/lib/command_impl.hpp
===================================================================
--- trunk/flexlay/lib/command_impl.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/command_impl.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -15,8 +13,8 @@
 //  
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-#ifndef HEADER_COMMAND_IMPL_HXX
-#define HEADER_COMMAND_IMPL_HXX
+#ifndef HEADER_FLEXLAY_COMMAND_IMPL_HPP
+#define HEADER_FLEXLAY_COMMAND_IMPL_HPP
 
 /** */
 class CommandImpl

Modified: trunk/flexlay/lib/console.hpp
===================================================================
--- trunk/flexlay/lib/console.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/console.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_CONSOLE_HXX
-#define HEADER_CONSOLE_HXX
+#ifndef HEADER_FLEXLAY_CONSOLE_HPP
+#define HEADER_FLEXLAY_CONSOLE_HPP
 
 #include <ClanLib/GUI/component.h>
 #include "shared_ptr.hpp"

Modified: trunk/flexlay/lib/directory_view.hpp
===================================================================
--- trunk/flexlay/lib/directory_view.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/directory_view.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_DIRECTORY_VIEW_HXX
-#define HEADER_DIRECTORY_VIEW_HXX
+#ifndef HEADER_FLEXLAY_DIRECTORY_VIEW_HPP
+#define HEADER_FLEXLAY_DIRECTORY_VIEW_HPP
 
 #include <ClanLib/GUI/component.h>
 #include "shared_ptr.hpp"

Modified: trunk/flexlay/lib/drawer_properties.hpp
===================================================================
--- trunk/flexlay/lib/drawer_properties.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/drawer_properties.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_DRAWER_PROPERTIES_HXX
-#define HEADER_DRAWER_PROPERTIES_HXX
+#ifndef HEADER_FLEXLAY_DRAWER_PROPERTIES_HPP
+#define HEADER_FLEXLAY_DRAWER_PROPERTIES_HPP
 
 #include <ClanLib/Display/color.h>
 #include "brush.hpp"

Modified: trunk/flexlay/lib/editor_map.hpp
===================================================================
--- trunk/flexlay/lib/editor_map.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/editor_map.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_EDITOR_MAP_HXX
-#define HEADER_EDITOR_MAP_HXX
+#ifndef HEADER_FLEXLAY_EDITOR_MAP_HPP
+#define HEADER_FLEXLAY_EDITOR_MAP_HPP
 
 #include <vector>
 #include <ClanLib/Display/sprite.h>

Modified: trunk/flexlay/lib/editor_map_component.hpp
===================================================================
--- trunk/flexlay/lib/editor_map_component.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/editor_map_component.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_EDITOR_MAP_COMPONENT_HXX
-#define HEADER_EDITOR_MAP_COMPONENT_HXX
+#ifndef HEADER_FLEXLAY_EDITOR_MAP_COMPONENT_HPP
+#define HEADER_FLEXLAY_EDITOR_MAP_COMPONENT_HPP
 
 #include <vector>
 #include <ClanLib/Display/sprite.h>

Modified: trunk/flexlay/lib/editor_names.hpp
===================================================================
--- trunk/flexlay/lib/editor_names.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/editor_names.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_EDITOR_NAMES_HXX
-#define HEADER_EDITOR_NAMES_HXX
+#ifndef HEADER_FLEXLAY_EDITOR_NAMES_HPP
+#define HEADER_FLEXLAY_EDITOR_NAMES_HPP
 
 enum { TILEMAP_NAME = 0, OBJECTMAP_NAME = 1 };
 enum { PAINT_TOOL_NAME = 0, SELECT_TOOL_NAME = 1, DIAMOND_TOOL = 2, OBJECT_TOOL_NAME = 3 }; 

Modified: trunk/flexlay/lib/field.hpp
===================================================================
--- trunk/flexlay/lib/field.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/field.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -16,8 +16,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef FIELD_HXX
-#define FIELD_HXX
+#ifndef HEADER_FLEXLAY_FIELD_HPP
+#define HEADER_FLEXLAY_FIELD_HPP
 
 #include <vector>
 #include <assert.h>

Modified: trunk/flexlay/lib/flexlay.hpp
===================================================================
--- trunk/flexlay/lib/flexlay.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/flexlay.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_FLEXLAY_HXX
-#define HEADER_FLEXLAY_HXX
+#ifndef HEADER_FLEXLAY_FLEXLAY_HPP
+#define HEADER_FLEXLAY_FLEXLAY_HPP
 
 #include <ClanLib/Display/display_window.h>
 #include <ClanLib/Core/Resources/resource_manager.h>

Modified: trunk/flexlay/lib/fonts.hpp
===================================================================
--- trunk/flexlay/lib/fonts.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/fonts.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_FONTS_HXX
-#define HEADER_FONTS_HXX
+#ifndef HEADER_FLEXLAY_FONTS_HPP
+#define HEADER_FLEXLAY_FONTS_HPP
 
 #include <ClanLib/Display/font.h>
 

Modified: trunk/flexlay/lib/generated_brush.hpp
===================================================================
--- trunk/flexlay/lib/generated_brush.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/generated_brush.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_GENERATED_BRUSH_HXX
-#define HEADER_GENERATED_BRUSH_HXX
+#ifndef HEADER_FLEXLAY_GENERATED_BRUSH_HPP
+#define HEADER_FLEXLAY_GENERATED_BRUSH_HPP
 
 #include "shared_ptr.hpp"
 #include "brushmask.hpp"

Modified: trunk/flexlay/lib/globals.hpp
===================================================================
--- trunk/flexlay/lib/globals.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/globals.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -16,8 +16,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef GLOBALS_HXX
-#define GLOBALS_HXX
+#ifndef HEADER_FLEXLAY_GLOBALS_HPP
+#define HEADER_FLEXLAY_GLOBALS_HPP
 
 #include <string>
 #include <ClanLib/Core/Resources/resource_manager.h>

Modified: trunk/flexlay/lib/graphic_context_state.hpp
===================================================================
--- trunk/flexlay/lib/graphic_context_state.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/graphic_context_state.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_GRAPHIC_CONTEXT_STATE_HXX
-#define HEADER_GRAPHIC_CONTEXT_STATE_HXX
+#ifndef HEADER_FLEXLAY_GRAPHIC_CONTEXT_STATE_HPP
+#define HEADER_FLEXLAY_GRAPHIC_CONTEXT_STATE_HPP
 
 #include <ClanLib/Core/Math/point.h>
 #include <ClanLib/Core/Math/rect.h>

Modified: trunk/flexlay/lib/gui_manager.hpp
===================================================================
--- trunk/flexlay/lib/gui_manager.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/gui_manager.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -16,8 +16,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_GUI_MANAGER_HXX
-#define HEADER_GUI_MANAGER_HXX
+#ifndef HEADER_FLEXLAY_GUI_MANAGER_HPP
+#define HEADER_FLEXLAY_GUI_MANAGER_HPP
 
 #include "shared_ptr.hpp"
 

Modified: trunk/flexlay/lib/helper.hpp
===================================================================
--- trunk/flexlay/lib/helper.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/helper.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_HELPER_HXX
-#define HEADER_HELPER_HXX
+#ifndef HEADER_FLEXLAY_HELPER_HPP
+#define HEADER_FLEXLAY_HELPER_HPP
 
 #include <ClanLib/Display/sprite.h>
 #include <ClanLib/Display/pixel_buffer.h>

Modified: trunk/flexlay/lib/icon.hpp
===================================================================
--- trunk/flexlay/lib/icon.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/icon.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_ICON_HXX
-#define HEADER_ICON_HXX
+#ifndef HEADER_FLEXLAY_ICON_HPP
+#define HEADER_FLEXLAY_ICON_HPP
 
 #include <ClanLib/GUI/component.h>
 #include <ClanLib/Core/Math/point.h>

Modified: trunk/flexlay/lib/layer.hpp
===================================================================
--- trunk/flexlay/lib/layer.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/layer.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_LAYER_HXX
-#define HEADER_LAYER_HXX
+#ifndef HEADER_FLEXLAY_LAYER_HPP
+#define HEADER_FLEXLAY_LAYER_HPP
 
 #include <ClanLib/Core/Math/rect.h>
 #include <ClanLib/Display/graphic_context.h>

Modified: trunk/flexlay/lib/layer_impl.hpp
===================================================================
--- trunk/flexlay/lib/layer_impl.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/layer_impl.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_LAYER_IMPL_HXX
-#define HEADER_LAYER_IMPL_HXX
+#ifndef HEADER_FLEXLAY_LAYER_IMPL_HPP
+#define HEADER_FLEXLAY_LAYER_IMPL_HPP
 
 #include <ClanLib/Core/Math/rect.h>
 #include <ClanLib/Display/graphic_context.h>

Modified: trunk/flexlay/lib/marker_stroke_drawer.hpp
===================================================================
--- trunk/flexlay/lib/marker_stroke_drawer.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/marker_stroke_drawer.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_MARKER_STROKE_DRAWER_HXX
-#define HEADER_MARKER_STROKE_DRAWER_HXX
+#ifndef HEADER_FLEXLAY_MARKER_STROKE_DRAWER_HPP
+#define HEADER_FLEXLAY_MARKER_STROKE_DRAWER_HPP
 
 #include "stroke_drawer.hpp"
 

Modified: trunk/flexlay/lib/math.hpp
===================================================================
--- trunk/flexlay/lib/math.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/math.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_MATH_HXX
-#define HEADER_MATH_HXX
+#ifndef HEADER_FLEXLAY_MATH_HPP
+#define HEADER_FLEXLAY_MATH_HPP
 
 namespace Math {
 

Modified: trunk/flexlay/lib/menu.hpp
===================================================================
--- trunk/flexlay/lib/menu.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/menu.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_MENU_HXX
-#define HEADER_MENU_HXX
+#ifndef HEADER_FLEXLAY_MENU_HPP
+#define HEADER_FLEXLAY_MENU_HPP
 
 #include <string>
 #include <ClanLib/GUI/component.h>

Modified: trunk/flexlay/lib/menubar.hpp
===================================================================
--- trunk/flexlay/lib/menubar.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/menubar.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_MENUBAR_HXX
-#define HEADER_MENUBAR_HXX
+#ifndef HEADER_FLEXLAY_MENUBAR_HPP
+#define HEADER_FLEXLAY_MENUBAR_HPP
 
 #include <ClanLib/GUI/component.h>
 #include <ClanLib/Core/Math/rect.h>

Modified: trunk/flexlay/lib/meta_data.hpp
===================================================================
--- trunk/flexlay/lib/meta_data.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/meta_data.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_META_DATA_HXX
-#define HEADER_META_DATA_HXX
+#ifndef HEADER_FLEXLAY_META_DATA_HPP
+#define HEADER_FLEXLAY_META_DATA_HPP
 
 #include "shared_ptr.hpp"
 

Modified: trunk/flexlay/lib/meta_data_impl.hpp
===================================================================
--- trunk/flexlay/lib/meta_data_impl.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/meta_data_impl.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_META_DATA_IMPL_HXX
-#define HEADER_META_DATA_IMPL_HXX
+#ifndef HEADER_FLEXLAY_META_DATA_IMPL_HPP
+#define HEADER_FLEXLAY_META_DATA_IMPL_HPP
 
 /** */
 class MetaDataImpl

Modified: trunk/flexlay/lib/minimap.hpp
===================================================================
--- trunk/flexlay/lib/minimap.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/minimap.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_MINIMAP_HXX
-#define HEADER_MINIMAP_HXX
+#ifndef HEADER_FLEXLAY_MINIMAP_HPP
+#define HEADER_FLEXLAY_MINIMAP_HPP
 
 #include <ClanLib/GUI/component.h>
 

Modified: trunk/flexlay/lib/object_add_command.hpp
===================================================================
--- trunk/flexlay/lib/object_add_command.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/object_add_command.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_OBJECT_ADD_COMMAND_HXX
-#define HEADER_OBJECT_ADD_COMMAND_HXX
+#ifndef HEADER_FLEXLAY_OBJECT_ADD_COMMAND_HPP
+#define HEADER_FLEXLAY_OBJECT_ADD_COMMAND_HPP
 
 #include "objmap_object.hpp"
 #include "command.hpp"

Modified: trunk/flexlay/lib/object_brush.hpp
===================================================================
--- trunk/flexlay/lib/object_brush.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/object_brush.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_OBJECT_BRUSH_HXX
-#define HEADER_OBJECT_BRUSH_HXX
+#ifndef HEADER_FLEXLAY_OBJECT_BRUSH_HPP
+#define HEADER_FLEXLAY_OBJECT_BRUSH_HPP
 
 #include <ClanLib/Display/sprite.h>
 #include <ClanLib/Core/Math/point.h>

Modified: trunk/flexlay/lib/object_delete_command.hpp
===================================================================
--- trunk/flexlay/lib/object_delete_command.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/object_delete_command.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_OBJECT_DELETE_COMMAND_HXX
-#define HEADER_OBJECT_DELETE_COMMAND_HXX
+#ifndef HEADER_FLEXLAY_OBJECT_DELETE_COMMAND_HPP
+#define HEADER_FLEXLAY_OBJECT_DELETE_COMMAND_HPP
 
 #include <vector>
 #include "objmap_object.hpp"

Modified: trunk/flexlay/lib/object_layer.hpp
===================================================================
--- trunk/flexlay/lib/object_layer.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/object_layer.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_OBJECT_LAYER_HXX
-#define HEADER_OBJECT_LAYER_HXX
+#ifndef HEADER_FLEXLAY_OBJECT_LAYER_HPP
+#define HEADER_FLEXLAY_OBJECT_LAYER_HPP
 
 #include <vector>
 #include <ClanLib/Display/sprite.h>

Modified: trunk/flexlay/lib/object_move_command.hpp
===================================================================
--- trunk/flexlay/lib/object_move_command.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/object_move_command.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_OBJECT_COMMAND_HXX
-#define HEADER_OBJECT_COMMAND_HXX
+#ifndef HEADER_FLEXLAY_OBJECT_MOVE_COMMAND_HPP
+#define HEADER_FLEXLAY_OBJECT_MOVE_COMMAND_HPP
 
 #include "command.hpp"
 

Modified: trunk/flexlay/lib/object_selector.hpp
===================================================================
--- trunk/flexlay/lib/object_selector.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/object_selector.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_OBJECTSELECTOR_HXX
-#define HEADER_OBJECTSELECTOR_HXX
+#ifndef HEADER_FLEXLAY_OBJECT_SELECTOR_HPP
+#define HEADER_FLEXLAY_OBJECT_SELECTOR_HPP
 
 #include <ClanLib/GUI/component.h>
 #include <ClanLib/GUI/component.h>

Modified: trunk/flexlay/lib/object_transform_command.hpp
===================================================================
--- trunk/flexlay/lib/object_transform_command.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/object_transform_command.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_OBJECT_TRANSFORM_COMMAND_HXX
-#define HEADER_OBJECT_TRANSFORM_COMMAND_HXX
+#ifndef HEADER_FLEXLAY_OBJECT_TRANSFORM_COMMAND_HPP
+#define HEADER_FLEXLAY_OBJECT_TRANSFORM_COMMAND_HPP
 
 #include <vector>
 #include "command.hpp"

Modified: trunk/flexlay/lib/objmap_control_point.cpp
===================================================================
--- trunk/flexlay/lib/objmap_control_point.cpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/objmap_control_point.cpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/objmap_control_point.hpp
===================================================================
--- trunk/flexlay/lib/objmap_control_point.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/objmap_control_point.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_OBJMAP_CONTROL_POINT_HXX
-#define HEADER_OBJMAP_CONTROL_POINT_HXX
+#ifndef HEADER_FLEXLAY_OBJMAP_CONTROL_POINT_HPP
+#define HEADER_FLEXLAY_OBJMAP_CONTROL_POINT_HPP
 
 #include <ClanLib/Display/sprite.h>
 #include <ClanLib/Core/Math/point.h>

Modified: trunk/flexlay/lib/objmap_object.hpp
===================================================================
--- trunk/flexlay/lib/objmap_object.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/objmap_object.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_OBJMAP_OBJECT_HXX
-#define HEADER_OBJMAP_OBJECT_HXX
+#ifndef HEADER_FLEXLAY_OBJMAP_OBJECT_HPP
+#define HEADER_FLEXLAY_OBJMAP_OBJECT_HPP
 
 #include <ClanLib/signals.h>
 #include <ClanLib/Display/graphic_context.h>

Modified: trunk/flexlay/lib/objmap_object_impl.hpp
===================================================================
--- trunk/flexlay/lib/objmap_object_impl.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/objmap_object_impl.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_OBJMAP_OBJECT_IMPL_HXX
-#define HEADER_OBJMAP_OBJECT_IMPL_HXX
+#ifndef HEADER_FLEXLAY_OBJMAP_OBJECT_IMPL_HPP
+#define HEADER_FLEXLAY_OBJMAP_OBJECT_IMPL_HPP
 
 #include <ClanLib/Core/Math/point.h>
 #include <ClanLib/Core/Math/rect.h>

Modified: trunk/flexlay/lib/objmap_path_node.hpp
===================================================================
--- trunk/flexlay/lib/objmap_path_node.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/objmap_path_node.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_OBJMAP_PATH_NODE_HXX
-#define HEADER_OBJMAP_PATH_NODE_HXX
+#ifndef HEADER_FLEXLAY_OBJMAP_PATH_NODE_HPP
+#define HEADER_FLEXLAY_OBJMAP_PATH_NODE_HPP
 
 #include "objmap_object.hpp"
 

Modified: trunk/flexlay/lib/objmap_rect_object.cpp
===================================================================
--- trunk/flexlay/lib/objmap_rect_object.cpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/objmap_rect_object.cpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/objmap_rect_object.hpp
===================================================================
--- trunk/flexlay/lib/objmap_rect_object.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/objmap_rect_object.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_OBJMAP_RECT_OBJECT_HXX
-#define HEADER_OBJMAP_RECT_OBJECT_HXX
+#ifndef HEADER_FLEXLAY_OBJMAP_RECT_OBJECT_HPP
+#define HEADER_FLEXLAY_OBJMAP_RECT_OBJECT_HPP
 
 #include <ClanLib/Core/Math/rect.h>
 #include <ClanLib/Display/color.h>

Modified: trunk/flexlay/lib/objmap_sprite_object.hpp
===================================================================
--- trunk/flexlay/lib/objmap_sprite_object.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/objmap_sprite_object.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_OBJMAP_SPRITE_OBJECT_HXX
-#define HEADER_OBJMAP_SPRITE_OBJECT_HXX
+#ifndef HEADER_FLEXLAY_OBJMAP_SPRITE_OBJECT_HPP
+#define HEADER_FLEXLAY_OBJMAP_SPRITE_OBJECT_HPP
 
 #include <ClanLib/Display/sprite.h>
 #include <ClanLib/Core/Math/point.h>

Modified: trunk/flexlay/lib/onion_skin_layer.cpp
===================================================================
--- trunk/flexlay/lib/onion_skin_layer.cpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/onion_skin_layer.cpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/onion_skin_layer.hpp
===================================================================
--- trunk/flexlay/lib/onion_skin_layer.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/onion_skin_layer.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_ONION_SKIN_LAYER_HXX
-#define HEADER_ONION_SKIN_LAYER_HXX
+#ifndef HEADER_FLEXLAY_ONION_SKIN_LAYER_HPP
+#define HEADER_FLEXLAY_ONION_SKIN_LAYER_HPP
 
 #include "editor_map.hpp"
 

Modified: trunk/flexlay/lib/paint_command.hpp
===================================================================
--- trunk/flexlay/lib/paint_command.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/paint_command.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_PAINT_COMMAND_HXX
-#define HEADER_PAINT_COMMAND_HXX
+#ifndef HEADER_FLEXLAY_PAINT_COMMAND_HPP
+#define HEADER_FLEXLAY_PAINT_COMMAND_HPP
 
 #include <ClanLib/Core/Math/point.h>
 #include "tile_brush.hpp"

Modified: trunk/flexlay/lib/panel.hpp
===================================================================
--- trunk/flexlay/lib/panel.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/panel.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_PANEL_HXX
-#define HEADER_PANEL_HXX
+#ifndef HEADER_FLEXLAY_PANEL_HPP
+#define HEADER_FLEXLAY_PANEL_HPP
 
 #include <ClanLib/GUI/component.h>
 #include <ClanLib/Core/Math/rect.h>

Modified: trunk/flexlay/lib/popup_menu.hpp
===================================================================
--- trunk/flexlay/lib/popup_menu.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/popup_menu.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_POPUP_MENU_HXX
-#define HEADER_POPUP_MENU_HXX
+#ifndef HEADER_FLEXLAY_POPUP_MENU_HPP
+#define HEADER_FLEXLAY_POPUP_MENU_HPP
 
 #include <vector>
 #include <ClanLib/Signals/slot.h>

Modified: trunk/flexlay/lib/scrollbar.hpp
===================================================================
--- trunk/flexlay/lib/scrollbar.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/scrollbar.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_SCROLLBAR_HXX
-#define HEADER_SCROLLBAR_HXX
+#ifndef HEADER_FLEXLAY_SCROLLBAR_HPP
+#define HEADER_FLEXLAY_SCROLLBAR_HPP
 
 #include <ClanLib/GUI/component.h>
 #include <ClanLib/Core/Math/rect.h>

Modified: trunk/flexlay/lib/shared_ptr.hpp
===================================================================
--- trunk/flexlay/lib/shared_ptr.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/shared_ptr.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_SHARED_PTR_HXX
-#define HEADER_SHARED_PTR_HXX
+#ifndef HEADER_FLEXLAY_SHARED_PTR_HPP
+#define HEADER_FLEXLAY_SHARED_PTR_HPP
 
 #include <assert.h>
 

Modified: trunk/flexlay/lib/shared_ptr_comp.hpp
===================================================================
--- trunk/flexlay/lib/shared_ptr_comp.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/shared_ptr_comp.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_SHARED_PTR_HXX
-#define HEADER_SHARED_PTR_HXX
+#ifndef HEADER_FLEXLAY_SHARED_PTR_COMP_HPP
+#define HEADER_FLEXLAY_SHARED_PTR_COMP_HPP
 
 #include <iostream>
 #include <typeinfo>

Modified: trunk/flexlay/lib/sharedptrtest.hpp
===================================================================
--- trunk/flexlay/lib/sharedptrtest.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/sharedptrtest.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_SHAREDPTRTEST_HXX
-#define HEADER_SHAREDPTRTEST_HXX
+#ifndef HEADER_FLEXLAY_SHAREDPTRTEST_HPP
+#define HEADER_FLEXLAY_SHAREDPTRTEST_HPP
 
 
 #endif

Modified: trunk/flexlay/lib/sketch_layer.hpp
===================================================================
--- trunk/flexlay/lib/sketch_layer.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/sketch_layer.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_SKETCH_LAYER_HXX
-#define HEADER_SKETCH_LAYER_HXX
+#ifndef HEADER_FLEXLAY_SKETCH_LAYER_HPP
+#define HEADER_FLEXLAY_SKETCH_LAYER_HPP
 
 #include <vector>
 #include <ClanLib/Core/Math/point.h>

Modified: trunk/flexlay/lib/slider.hpp
===================================================================
--- trunk/flexlay/lib/slider.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/slider.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_SLIDER_HXX
-#define HEADER_SLIDER_HXX
+#ifndef HEADER_FLEXLAY_SLIDER_HPP
+#define HEADER_FLEXLAY_SLIDER_HPP
 
 #include <vector>
 #include <ClanLib/GUI/component.h>

Modified: trunk/flexlay/lib/sprite_brush.cpp
===================================================================
--- trunk/flexlay/lib/sprite_brush.cpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/sprite_brush.cpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/sprite_brush.hpp
===================================================================
--- trunk/flexlay/lib/sprite_brush.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/sprite_brush.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_SPRITE_BRUSH_HXX
-#define HEADER_SPRITE_BRUSH_HXX
+#ifndef HEADER_FLEXLAY_SPRITE_BRUSH_HPP
+#define HEADER_FLEXLAY_SPRITE_BRUSH_HPP
 
 #include <ClanLib/Display/sprite.h>
 #include "brush.hpp"

Modified: trunk/flexlay/lib/sprite_stroke_drawer.hpp
===================================================================
--- trunk/flexlay/lib/sprite_stroke_drawer.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/sprite_stroke_drawer.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_SPRITE_STROKE_DRAWER_HXX
-#define HEADER_SPRITE_STROKE_DRAWER_HXX
+#ifndef HEADER_FLEXLAY_SPRITE_STROKE_DRAWER_HPP
+#define HEADER_FLEXLAY_SPRITE_STROKE_DRAWER_HPP
 
 #include <ClanLib/Display/color.h>
 #include <ClanLib/Display/sprite.h>

Modified: trunk/flexlay/lib/string_converter.hpp
===================================================================
--- trunk/flexlay/lib/string_converter.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/string_converter.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -16,8 +16,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef STRINGCONVERTER_HXX
-#define STRINGCONVERTER_HXX
+#ifndef HEADER_FLEXLAY_STRING_CONVERTER_HPP
+#define HEADER_FLEXLAY_STRING_CONVERTER_HPP
 
 #include <stdexcept>
 #include <sstream>

Modified: trunk/flexlay/lib/stroke.hpp
===================================================================
--- trunk/flexlay/lib/stroke.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/stroke.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_STROKE_HXX
-#define HEADER_STROKE_HXX
+#ifndef HEADER_FLEXLAY_STROKE_HPP
+#define HEADER_FLEXLAY_STROKE_HPP
 
 #include <vector>
 #include <ClanLib/Core/Math/point.h>

Modified: trunk/flexlay/lib/stroke_drawer.hpp
===================================================================
--- trunk/flexlay/lib/stroke_drawer.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/stroke_drawer.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_STROKE_DRAWER_HXX
-#define HEADER_STROKE_DRAWER_HXX
+#ifndef HEADER_FLEXLAY_STROKE_DRAWER_HPP
+#define HEADER_FLEXLAY_STROKE_DRAWER_HPP
 
 #include "shared_ptr.hpp"
 

Modified: trunk/flexlay/lib/stroke_drawer_impl.hpp
===================================================================
--- trunk/flexlay/lib/stroke_drawer_impl.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/stroke_drawer_impl.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_STROKE_DRAWER_IMPL_HXX
-#define HEADER_STROKE_DRAWER_IMPL_HXX
+#ifndef HEADER_FLEXLAY_STROKE_DRAWER_IMPL_HPP
+#define HEADER_FLEXLAY_STROKE_DRAWER_IMPL_HPP
 
 class CL_GraphicContext;
 class Stroke;

Modified: trunk/flexlay/lib/tile.hpp
===================================================================
--- trunk/flexlay/lib/tile.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/tile.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -16,8 +16,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_TILE_HXX
-#define HEADER_TILE_HXX
+#ifndef HEADER_FLEXLAY_TILE_HPP
+#define HEADER_FLEXLAY_TILE_HPP
 
 #include <assert.h>
 #include <ClanLib/Display/sprite.h>

Modified: trunk/flexlay/lib/tile_brush.hpp
===================================================================
--- trunk/flexlay/lib/tile_brush.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/tile_brush.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_EDITOR_TILE_BRUSH_HXX
-#define HEADER_EDITOR_TILE_BRUSH_HXX
+#ifndef HEADER_FLEXLAY_TILE_BRUSH_HPP
+#define HEADER_FLEXLAY_TILE_BRUSH_HPP
 
 #include "field.hpp"
 

Modified: trunk/flexlay/lib/tile_editor.hpp
===================================================================
--- trunk/flexlay/lib/tile_editor.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/tile_editor.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -16,8 +16,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_TILE_EDITOR_HXX
-#define HEADER_TILE_EDITOR_HXX
+#ifndef HEADER_FLEXLAY_TILE_EDITOR_HPP
+#define HEADER_FLEXLAY_TILE_EDITOR_HPP
 
 #include <ClanLib/GUI/component.h>
 #include <ClanLib/Signals/slot_container.h>

Modified: trunk/flexlay/lib/tile_provider.hpp
===================================================================
--- trunk/flexlay/lib/tile_provider.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/tile_provider.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_TILE_PROVIDER_HXX
-#define HEADER_TILE_PROVIDER_HXX
+#ifndef HEADER_FLEXLAY_TILE_PROVIDER_HPP
+#define HEADER_FLEXLAY_TILE_PROVIDER_HPP
 
 #include <ClanLib/Display/sprite.h>
 #include <ClanLib/Display/pixel_buffer.h>

Modified: trunk/flexlay/lib/tile_provider_impl.hpp
===================================================================
--- trunk/flexlay/lib/tile_provider_impl.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/tile_provider_impl.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Pingus - A free Lemmings clone
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_TILE_PROVIDER_IMPL_HXX
-#define HEADER_TILE_PROVIDER_IMPL_HXX
+#ifndef HEADER_FLEXLAY_TILE_PROVIDER_IMPL_HPP
+#define HEADER_FLEXLAY_TILE_PROVIDER_IMPL_HPP
 
 #include <ClanLib/Display/sprite.h>
 #include <ClanLib/Display/pixel_buffer.h>

Modified: trunk/flexlay/lib/tile_selection.hpp
===================================================================
--- trunk/flexlay/lib/tile_selection.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/tile_selection.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_TILE_SELECTION_HXX
-#define HEADER_TILE_SELECTION_HXX
+#ifndef HEADER_FLEXLAY_TILE_SELECTION_HPP
+#define HEADER_FLEXLAY_TILE_SELECTION_HPP
 
 #include <ClanLib/Core/Math/rect.h>
 #include <ClanLib/Display/color.h>

Modified: trunk/flexlay/lib/tile_selector.hpp
===================================================================
--- trunk/flexlay/lib/tile_selector.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/tile_selector.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -16,8 +16,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef TILESELECTOR_HXX
-#define TILESELECTOR_HXX
+#ifndef HEADER_FLEXLAY_TILE_SELECTOR_HPP
+#define HEADER_FLEXLAY_TILE_SELECTOR_HPP
 
 #include <ClanLib/gui.h>
 #include "tileset.hpp"

Modified: trunk/flexlay/lib/tilemap_layer.hpp
===================================================================
--- trunk/flexlay/lib/tilemap_layer.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/tilemap_layer.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_TILEMAP_LAYER_HXX
-#define HEADER_TILEMAP_LAYER_HXX
+#ifndef HEADER_FLEXLAY_TILEMAP_LAYER_HPP
+#define HEADER_FLEXLAY_TILEMAP_LAYER_HPP
 
 #include <ClanLib/Display/pixel_buffer.h>
 #include "field.hpp"

Modified: trunk/flexlay/lib/tilemap_minimap.hpp
===================================================================
--- trunk/flexlay/lib/tilemap_minimap.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/tilemap_minimap.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_TILEMAP_MINIMAP_HXX
-#define HEADER_TILEMAP_MINIMAP_HXX
+#ifndef HEADER_FLEXLAY_TILEMAP_MINIMAP_HPP
+#define HEADER_FLEXLAY_TILEMAP_MINIMAP_HPP
 
 /** */
 class TilemapMinimap

Modified: trunk/flexlay/lib/tileset.hpp
===================================================================
--- trunk/flexlay/lib/tileset.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/tileset.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -16,8 +16,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef TILESET_HXX
-#define TILESET_HXX
+#ifndef HEADER_FLEXLAY_TILESET_HPP
+#define HEADER_FLEXLAY_TILESET_HPP
 
 #include <vector>
 #include <string>

Modified: trunk/flexlay/lib/titlebar.hpp
===================================================================
--- trunk/flexlay/lib/titlebar.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/titlebar.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_TITLEBAR_HXX
-#define HEADER_TITLEBAR_HXX
+#ifndef HEADER_FLEXLAY_TITLEBAR_HPP
+#define HEADER_FLEXLAY_TITLEBAR_HPP
 
 #include <ClanLib/GUI/component.h>
 #include <ClanLib/Core/Math/rect.h>

Modified: trunk/flexlay/lib/tools/layer_move_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/layer_move_tool.cpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/tools/layer_move_tool.cpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2004 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/tools/layer_move_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/layer_move_tool.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/tools/layer_move_tool.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2004 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -17,8 +15,8 @@
 //  along with this program; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
-#ifndef HEADER_LAYER_MOVE_TOOL_HXX
-#define HEADER_LAYER_MOVE_TOOL_HXX
+#ifndef HEADER_FLEXLAY_TOOLS_LAYER_MOVE_TOOL_HPP
+#define HEADER_FLEXLAY_TOOLS_LAYER_MOVE_TOOL_HPP
 
 #include "tool.hpp"
 

Modified: trunk/flexlay/lib/tools/objmap_select_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/objmap_select_tool.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/tools/objmap_select_tool.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -17,8 +17,8 @@
 //  along with this program; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
-#ifndef HEADER_OBJMAP_SELECT_TOOL_HXX
-#define HEADER_OBJMAP_SELECT_TOOL_HXX
+#ifndef HEADER_FLEXLAY_TOOLS_OBJMAP_SELECT_TOOL_HPP
+#define HEADER_FLEXLAY_TOOLS_OBJMAP_SELECT_TOOL_HPP
 
 #include "object_layer.hpp"
 #include "object_brush.hpp"

Modified: trunk/flexlay/lib/tools/sketch_stroke_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/sketch_stroke_tool.cpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/tools/sketch_stroke_tool.cpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software; you can redistribute it and/or

Modified: trunk/flexlay/lib/tools/sketch_stroke_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/sketch_stroke_tool.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/tools/sketch_stroke_tool.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,6 +1,4 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software; you can redistribute it and/or
@@ -17,8 +15,8 @@
 //  along with this program; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
-#ifndef HEADER_SKETCH_STROKE_TOOL_HXX
-#define HEADER_SKETCH_STROKE_TOOL_HXX
+#ifndef HEADER_FLEXLAY_TOOLS_SKETCH_STROKE_TOOL_HPP
+#define HEADER_FLEXLAY_TOOLS_SKETCH_STROKE_TOOL_HPP
 
 #include "tool_impl.hpp"
 #include "stroke_drawer.hpp"

Modified: trunk/flexlay/lib/tools/tilemap_paint_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/tilemap_paint_tool.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/tools/tilemap_paint_tool.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -17,8 +17,8 @@
 //  along with this program; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
-#ifndef HEADER_TILEMAP_PAINT_TOOL_HXX
-#define HEADER_TILEMAP_PAINT_TOOL_HXX
+#ifndef HEADER_FLEXLAY_TOOLS_TILEMAP_PAINT_TOOL_HPP
+#define HEADER_FLEXLAY_TOOLS_TILEMAP_PAINT_TOOL_HPP
 
 #include "tool.hpp"
 #include "tile_brush.hpp"

Modified: trunk/flexlay/lib/tools/tilemap_select_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/tilemap_select_tool.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/tools/tilemap_select_tool.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id: tilemap_select_tool.hpp,v 1.1 2003/09/23 22:10:40 grumbel Exp $
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -17,8 +15,8 @@
 //  along with this program; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
-#ifndef HEADER_TILEMAP_SELECT_TOOL_HXX
-#define HEADER_TILEMAP_SELECT_TOOL_HXX
+#ifndef HEADER_FLEXLAY_TOOLS_TILEMAP_SELECT_TOOL_HPP
+#define HEADER_FLEXLAY_TOOLS_TILEMAP_SELECT_TOOL_HPP
 
 #include <ClanLib/Core/Math/rect.h>
 #include <ClanLib/Core/Math/point.h>

Modified: trunk/flexlay/lib/tools/tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/tool.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/tools/tool.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -17,8 +17,8 @@
 //  along with this program; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
-#ifndef HEADER_TILEMAP_TOOL_HXX
-#define HEADER_TILEMAP_TOOL_HXX
+#ifndef HEADER_FLEXLAY_TOOLS_TOOL_HPP
+#define HEADER_FLEXLAY_TOOLS_TOOL_HPP
 
 class EditorMapComponent;
 class CL_InputEvent;

Modified: trunk/flexlay/lib/tools/tool_impl.hpp
===================================================================
--- trunk/flexlay/lib/tools/tool_impl.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/tools/tool_impl.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -17,8 +17,8 @@
 //  along with this program; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
-#ifndef HEADER_TOOL_IMPL_HXX
-#define HEADER_TOOL_IMPL_HXX
+#ifndef HEADER_FLEXLAY_TOOLS_TOOL_IMPL_HPP
+#define HEADER_FLEXLAY_TOOLS_TOOL_IMPL_HPP
 
 class CL_InputEvent;
 

Modified: trunk/flexlay/lib/tools/workspace_move_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/workspace_move_tool.cpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/tools/workspace_move_tool.cpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software; you can redistribute it and/or

Modified: trunk/flexlay/lib/tools/workspace_move_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/workspace_move_tool.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/tools/workspace_move_tool.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,6 +1,4 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software; you can redistribute it and/or
@@ -17,8 +15,8 @@
 //  along with this program; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
-#ifndef HEADER_WORKSPACE_MOVE_TOOL_HXX
-#define HEADER_WORKSPACE_MOVE_TOOL_HXX
+#ifndef HEADER_FLEXLAY_TOOLS_WORKSPACE_MOVE_TOOL_HPP
+#define HEADER_FLEXLAY_TOOLS_WORKSPACE_MOVE_TOOL_HPP
 
 #include "tool.hpp"
 

Modified: trunk/flexlay/lib/tools/zoom2_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/zoom2_tool.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/tools/zoom2_tool.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -17,8 +15,8 @@
 //  along with this program; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
-#ifndef HEADER_ZOOM2_TOOL_HXX
-#define HEADER_ZOOM2_TOOL_HXX
+#ifndef HEADER_FLEXLAY_TOOLS_ZOOM2_TOOL_HPP
+#define HEADER_FLEXLAY_TOOLS_ZOOM2_TOOL_HPP
 
 #include <ClanLib/Core/Math/rect.h>
 #include <ClanLib/Display/input_event.h>

Modified: trunk/flexlay/lib/tools/zoom_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/zoom_tool.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/tools/zoom_tool.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -17,8 +15,8 @@
 //  along with this program; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
-#ifndef HEADER_ZOOM_TOOL_HXX
-#define HEADER_ZOOM_TOOL_HXX
+#ifndef HEADER_FLEXLAY_TOOLS_ZOOM_TOOL_HPP
+#define HEADER_FLEXLAY_TOOLS_ZOOM_TOOL_HPP
 
 #include <ClanLib/Core/Math/rect.h>
 #include <ClanLib/Display/input_event.h>

Modified: trunk/flexlay/lib/viewport.hpp
===================================================================
--- trunk/flexlay/lib/viewport.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/viewport.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_VIEWPORT_HXX
-#define HEADER_VIEWPORT_HXX
+#ifndef HEADER_FLEXLAY_VIEWPORT_HPP
+#define HEADER_FLEXLAY_VIEWPORT_HPP
 
 #include <ClanLib/GUI/component.h>
 #include <ClanLib/Core/Math/rect.h>

Modified: trunk/flexlay/lib/window.hpp
===================================================================
--- trunk/flexlay/lib/window.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/window.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_WINDOW_HXX
-#define HEADER_WINDOW_HXX
+#ifndef HEADER_FLEXLAY_WINDOW_HPP
+#define HEADER_FLEXLAY_WINDOW_HPP
 
 #include <ClanLib/GUI/component.h>
 #include <ClanLib/Core/Math/rect.h>

Modified: trunk/flexlay/lib/workspace.hpp
===================================================================
--- trunk/flexlay/lib/workspace.hpp	2009-11-22 03:35:03 UTC (rev 721)
+++ trunk/flexlay/lib/workspace.hpp	2009-11-22 03:48:00 UTC (rev 722)
@@ -1,5 +1,3 @@
-//  $Id$
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -16,8 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#ifndef HEADER_WORKSPACE_HXX
-#define HEADER_WORKSPACE_HXX
+#ifndef HEADER_FLEXLAY_WORKSPACE_HPP
+#define HEADER_FLEXLAY_WORKSPACE_HPP
 
 #include <ClanLib/Core/System/sharedptr.h>
 #include <ClanLib/Display/input_event.h>



From grumbel at mail.berlios.de  Sun Nov 22 05:36:19 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 22 Nov 2009 05:36:19 +0100
Subject: [Flexlay-commit] r723 - in trunk/flexlay/lib: . tools
Message-ID: <200911220436.nAM4aJW9030220@sheep.berlios.de>

Author: grumbel
Date: 2009-11-22 05:36:12 +0100 (Sun, 22 Nov 2009)
New Revision: 723

Modified:
   trunk/flexlay/lib/SConscript
   trunk/flexlay/lib/blitter.cpp
   trunk/flexlay/lib/box.cpp
   trunk/flexlay/lib/box.hpp
   trunk/flexlay/lib/brushmask.cpp
   trunk/flexlay/lib/colorpicker.cpp
   trunk/flexlay/lib/colorpicker.hpp
   trunk/flexlay/lib/command.hpp
   trunk/flexlay/lib/command_impl.hpp
   trunk/flexlay/lib/console.cpp
   trunk/flexlay/lib/directory_view.cpp
   trunk/flexlay/lib/drawer_properties.hpp
   trunk/flexlay/lib/editor_map.cpp
   trunk/flexlay/lib/editor_map.hpp
   trunk/flexlay/lib/editor_map_component.cpp
   trunk/flexlay/lib/editor_map_component.hpp
   trunk/flexlay/lib/field.hpp
   trunk/flexlay/lib/flexlay.cpp
   trunk/flexlay/lib/flexlay.hpp
   trunk/flexlay/lib/generated_brush.cpp
   trunk/flexlay/lib/generated_brush.hpp
   trunk/flexlay/lib/globals.hpp
   trunk/flexlay/lib/graphic_context_state.cpp
   trunk/flexlay/lib/gui_manager.cpp
   trunk/flexlay/lib/gui_manager.hpp
   trunk/flexlay/lib/helper.cpp
   trunk/flexlay/lib/helper.hpp
   trunk/flexlay/lib/icon.cpp
   trunk/flexlay/lib/icon.hpp
   trunk/flexlay/lib/layer.cpp
   trunk/flexlay/lib/layer.hpp
   trunk/flexlay/lib/lispreader.cpp
   trunk/flexlay/lib/lispreader.hpp
   trunk/flexlay/lib/menu.cpp
   trunk/flexlay/lib/menu.hpp
   trunk/flexlay/lib/menubar.cpp
   trunk/flexlay/lib/menubar.hpp
   trunk/flexlay/lib/minimap.cpp
   trunk/flexlay/lib/minimap.hpp
   trunk/flexlay/lib/object_add_command.cpp
   trunk/flexlay/lib/object_add_command.hpp
   trunk/flexlay/lib/object_brush.cpp
   trunk/flexlay/lib/object_brush.hpp
   trunk/flexlay/lib/object_delete_command.cpp
   trunk/flexlay/lib/object_delete_command.hpp
   trunk/flexlay/lib/object_layer.cpp
   trunk/flexlay/lib/object_layer.hpp
   trunk/flexlay/lib/object_move_command.cpp
   trunk/flexlay/lib/objmap_control_point.hpp
   trunk/flexlay/lib/objmap_object.cpp
   trunk/flexlay/lib/objmap_object.hpp
   trunk/flexlay/lib/objmap_object_impl.cpp
   trunk/flexlay/lib/objmap_object_impl.hpp
   trunk/flexlay/lib/objmap_path_node.cpp
   trunk/flexlay/lib/objmap_path_node.hpp
   trunk/flexlay/lib/objmap_sprite_object.cpp
   trunk/flexlay/lib/objmap_sprite_object.hpp
   trunk/flexlay/lib/paint_command.cpp
   trunk/flexlay/lib/paint_command.hpp
   trunk/flexlay/lib/panel.cpp
   trunk/flexlay/lib/panel.hpp
   trunk/flexlay/lib/popup_menu.cpp
   trunk/flexlay/lib/popup_menu.hpp
   trunk/flexlay/lib/scrollbar.hpp
   trunk/flexlay/lib/sharedptrtest.cpp
   trunk/flexlay/lib/simpleed.cpp
   trunk/flexlay/lib/slider.hpp
   trunk/flexlay/lib/sprite_brush.cpp
   trunk/flexlay/lib/sprite_brush.hpp
   trunk/flexlay/lib/sprite_stroke_drawer.cpp
   trunk/flexlay/lib/sprite_stroke_drawer.hpp
   trunk/flexlay/lib/string_converter.hpp
   trunk/flexlay/lib/stroke.hpp
   trunk/flexlay/lib/stroke_drawer.cpp
   trunk/flexlay/lib/tile.cpp
   trunk/flexlay/lib/tile.hpp
   trunk/flexlay/lib/tile_brush.cpp
   trunk/flexlay/lib/tile_editor.cpp
   trunk/flexlay/lib/tile_editor.hpp
   trunk/flexlay/lib/tile_provider.hpp
   trunk/flexlay/lib/tile_selection.cpp
   trunk/flexlay/lib/tile_selection.hpp
   trunk/flexlay/lib/tile_selector.hpp
   trunk/flexlay/lib/tilemap_layer.cpp
   trunk/flexlay/lib/tileset.hpp
   trunk/flexlay/lib/titlebar.cpp
   trunk/flexlay/lib/titlebar.hpp
   trunk/flexlay/lib/tools/objmap_select_tool.hpp
   trunk/flexlay/lib/tools/tilemap_paint_tool.cpp
   trunk/flexlay/lib/tools/tilemap_paint_tool.hpp
   trunk/flexlay/lib/tools/tool.hpp
   trunk/flexlay/lib/tools/tool_impl.hpp
   trunk/flexlay/lib/window.cpp
   trunk/flexlay/lib/window.hpp
Log:
Include cleanup

Modified: trunk/flexlay/lib/SConscript
===================================================================
--- trunk/flexlay/lib/SConscript	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/SConscript	2009-11-22 04:36:12 UTC (rev 723)
@@ -1,6 +1,3 @@
-## -*- mode: python -*-
-##  $Id$
-##
 ##  Flexlay - A Generic 2D Game Editor
 ##  Copyright (C) 2004 Ingo Ruhnke <grumbel at gmx.de>
 ##

Modified: trunk/flexlay/lib/blitter.cpp
===================================================================
--- trunk/flexlay/lib/blitter.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/blitter.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -16,7 +16,6 @@
 
 #include <assert.h>
 #include <iostream>
-#include <algorithm>
 #include <ClanLib/Display/pixel_format.h>
 #include <ClanLib/Display/palette.h>
 #include "blitter.hpp"

Modified: trunk/flexlay/lib/box.cpp
===================================================================
--- trunk/flexlay/lib/box.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/box.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -14,7 +14,6 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include <ClanLib/Display/color.h>
 #include <ClanLib/Display/display.h>
 #include "box.hpp"
 

Modified: trunk/flexlay/lib/box.hpp
===================================================================
--- trunk/flexlay/lib/box.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/box.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -17,7 +17,6 @@
 #ifndef HEADER_FLEXLAY_BOX_HPP
 #define HEADER_FLEXLAY_BOX_HPP
 
-#include <ClanLib/Core/Math/rect.h>
 
 /** Little helper class to draw boxes and stuff in the GUI */
 class Box

Modified: trunk/flexlay/lib/brushmask.cpp
===================================================================
--- trunk/flexlay/lib/brushmask.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/brushmask.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -19,7 +19,6 @@
 */
 
 #include <iostream>
-#include <math.h>
 #include <string.h>
 #include <ClanLib/Display/pixel_format.h>
 #include "brushmask.hpp"

Modified: trunk/flexlay/lib/colorpicker.cpp
===================================================================
--- trunk/flexlay/lib/colorpicker.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/colorpicker.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -14,14 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include <vector>
 #include <iostream>
-#include <ClanLib/Display/display_iostream.h>
-#include <ClanLib/Display/color.h>
-#include <ClanLib/Display/display.h>
 #include <ClanLib/Display/keys.h>
-#include <ClanLib/Core/Math/rect.h>
-#include <ClanLib/Core/Math/point.h>
 #include <ClanLib/GUI/component.h>
 #include "colorpicker.hpp"
 #include "math.hpp"

Modified: trunk/flexlay/lib/colorpicker.hpp
===================================================================
--- trunk/flexlay/lib/colorpicker.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/colorpicker.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -18,8 +18,6 @@
 #define HEADER_FLEXLAY_COLORPICKER_HPP
 
 #include <ClanLib/Display/display.h>
-#include <ClanLib/Display/color.h>
-#include <ClanLib/Display/gradient.h>
 
 class ColorPickerHue;
 class ColorPickerAlpha;

Modified: trunk/flexlay/lib/command.hpp
===================================================================
--- trunk/flexlay/lib/command.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/command.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -17,7 +17,6 @@
 #ifndef HEADER_FLEXLAY_COMMAND_HPP
 #define HEADER_FLEXLAY_COMMAND_HPP
 
-#include <iosfwd>
 #include "shared_ptr.hpp"
 #include "command_impl.hpp"
 

Modified: trunk/flexlay/lib/command_impl.hpp
===================================================================
--- trunk/flexlay/lib/command_impl.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/command_impl.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -13,10 +13,12 @@
 //  
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
 #ifndef HEADER_FLEXLAY_COMMAND_IMPL_HPP
 #define HEADER_FLEXLAY_COMMAND_IMPL_HPP
 
-/** */
+#include <string>
+
 class CommandImpl
 {
 private:

Modified: trunk/flexlay/lib/console.cpp
===================================================================
--- trunk/flexlay/lib/console.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/console.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -15,7 +15,6 @@
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include <iostream>
-#include <ClanLib/Display/font.h>
 #include "fonts.hpp"
 #include "field.hpp"
 #include "console.hpp"

Modified: trunk/flexlay/lib/directory_view.cpp
===================================================================
--- trunk/flexlay/lib/directory_view.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/directory_view.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -14,10 +14,7 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include <assert.h>
-#include <ClanLib/Core/Math/rect.h>
 #include <ClanLib/Core/IOData/directory_scanner.h>
-#include <ClanLib/Display/font.h>
 #include <ClanLib/Display/display.h>
 #include "fonts.hpp"
 #include "directory_view.hpp"

Modified: trunk/flexlay/lib/drawer_properties.hpp
===================================================================
--- trunk/flexlay/lib/drawer_properties.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/drawer_properties.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -17,7 +17,6 @@
 #ifndef HEADER_FLEXLAY_DRAWER_PROPERTIES_HPP
 #define HEADER_FLEXLAY_DRAWER_PROPERTIES_HPP
 
-#include <ClanLib/Display/color.h>
 #include "brush.hpp"
 
 class DrawerPropertiesImpl;

Modified: trunk/flexlay/lib/editor_map.cpp
===================================================================
--- trunk/flexlay/lib/editor_map.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/editor_map.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -15,13 +15,10 @@
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include <iostream>
-#include <assert.h>
-#include <ClanLib/Core/core_iostream.h>
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/keys.h>
-#include "editor_names.hpp"
+#include <ClanLib/Display/color.h>
+#include <ClanLib/Display/graphic_context.h>
+#include <ClanLib/signals.h>
 #include "editor_map.hpp"
-#include "editor_map_component.hpp"
 
 class EditorMapImpl
 {

Modified: trunk/flexlay/lib/editor_map.hpp
===================================================================
--- trunk/flexlay/lib/editor_map.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/editor_map.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -17,19 +17,18 @@
 #ifndef HEADER_FLEXLAY_EDITOR_MAP_HPP
 #define HEADER_FLEXLAY_EDITOR_MAP_HPP
 
-#include <vector>
-#include <ClanLib/Display/sprite.h>
-#include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/Math/point.h>
-#include "field.hpp"
-#include "object_layer.hpp"
-#include "tilemap_layer.hpp"
+#include <ClanLib/Core/Math/rect.h>
+#include <ClanLib/Core/System/sharedptr.h>
 #include "layer.hpp"
+#include "meta_data.hpp"
 #include "command.hpp"
 
-class Command;
+class CL_GraphicContext;
 class EditorMapComponent;
 class EditorMapImpl;
+class Layer;
+class MetaData;
+class CL_Signal_v0;
 
 /** Object which represents a level, quirled together with the GUI
     stuff */
@@ -86,6 +85,7 @@
   CL_Signal_v0& sig_change();
 
   bool is_null() const { return !impl.get(); }
+
 private:
   CL_SharedPtr<EditorMapImpl> impl;
 };

Modified: trunk/flexlay/lib/editor_map_component.cpp
===================================================================
--- trunk/flexlay/lib/editor_map_component.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/editor_map_component.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -15,16 +15,10 @@
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include <iostream>
-#include <ClanLib/Core/core_iostream.h>
 #include <ClanLib/Display/keyboard.h>
 #include <ClanLib/Display/mouse.h>
 #include <ClanLib/Display/display.h>
-#include <ClanLib/Display/display_iostream.h>
-#include <ClanLib/Display/keys.h>
-#include "tileset.hpp"
-#include "editor_names.hpp"
 #include "editor_map.hpp"
-#include "workspace.hpp"
 #include "scrollbar.hpp"
 #include "editor_map_component.hpp"
 

Modified: trunk/flexlay/lib/editor_map_component.hpp
===================================================================
--- trunk/flexlay/lib/editor_map_component.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/editor_map_component.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -17,13 +17,7 @@
 #ifndef HEADER_FLEXLAY_EDITOR_MAP_COMPONENT_HPP
 #define HEADER_FLEXLAY_EDITOR_MAP_COMPONENT_HPP
 
-#include <vector>
-#include <ClanLib/Display/sprite.h>
 #include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/Math/point.h>
-#include "field.hpp"
-#include "object_layer.hpp"
-#include "graphic_context_state.hpp"
 #include "workspace.hpp"
 
 class Scrollbar;

Modified: trunk/flexlay/lib/field.hpp
===================================================================
--- trunk/flexlay/lib/field.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/field.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -1,5 +1,3 @@
-//  $Id: field.hpp,v 1.4 2003/09/12 09:25:48 grumbel Exp $
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2000 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/flexlay.cpp
===================================================================
--- trunk/flexlay/lib/flexlay.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/flexlay.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -14,15 +14,14 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
+#include "flexlay.hpp"
+
 #include <ClanLib/core.h>
 #include <ClanLib/display.h>
 #include <ClanLib/gui.h>
-#include <ClanLib/guistylesilver.h>
 #include <ClanLib/gl.h>
-#include "config.h"
 #include "globals.hpp"
 #include "fonts.hpp"
-#include "flexlay.hpp"
 
 Flexlay* Flexlay::current_ = 0;
 

Modified: trunk/flexlay/lib/flexlay.hpp
===================================================================
--- trunk/flexlay/lib/flexlay.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/flexlay.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -17,9 +17,10 @@
 #ifndef HEADER_FLEXLAY_FLEXLAY_HPP
 #define HEADER_FLEXLAY_FLEXLAY_HPP
 
-#include <ClanLib/Display/display_window.h>
 #include <ClanLib/Core/Resources/resource_manager.h>
 
+class CL_DisplayWindow;
+
 /*! \mainpage Flexlay - A Flexible Layered 2D Editor
   
   \section intro Introduction

Modified: trunk/flexlay/lib/generated_brush.cpp
===================================================================
--- trunk/flexlay/lib/generated_brush.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/generated_brush.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -15,7 +15,6 @@
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include <ClanLib/Display/sprite_description.h>
-#include "brush_impl.hpp"
 #include "generated_brush.hpp"
 
 class GeneratedBrushImpl : public BrushImpl

Modified: trunk/flexlay/lib/generated_brush.hpp
===================================================================
--- trunk/flexlay/lib/generated_brush.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/generated_brush.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -17,7 +17,6 @@
 #ifndef HEADER_FLEXLAY_GENERATED_BRUSH_HPP
 #define HEADER_FLEXLAY_GENERATED_BRUSH_HPP
 
-#include "shared_ptr.hpp"
 #include "brushmask.hpp"
 #include "brush.hpp"
 

Modified: trunk/flexlay/lib/globals.hpp
===================================================================
--- trunk/flexlay/lib/globals.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/globals.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -1,5 +1,3 @@
-//  $Id: globals.hpp,v 1.11 2003/11/07 13:00:39 grumbel Exp $
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2000 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -20,7 +18,6 @@
 #define HEADER_FLEXLAY_GLOBALS_HPP
 
 #include <string>
-#include <ClanLib/Core/Resources/resource_manager.h>
 
 /** datadir => /usr/local/share/games/windstille/ */
 extern std::string datadir;

Modified: trunk/flexlay/lib/graphic_context_state.cpp
===================================================================
--- trunk/flexlay/lib/graphic_context_state.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/graphic_context_state.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -14,12 +14,11 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
+#include "graphic_context_state.hpp"
+
 #include <ClanLib/Display/display.h>
 #include <ClanLib/Display/display_window.h>
 #include <ClanLib/Display/graphic_context.h>
-#include <ClanLib/GUI/component.h>
-#include <math.h>
-#include "graphic_context_state.hpp"
 
 class GraphicContextStateImpl
 {

Modified: trunk/flexlay/lib/gui_manager.cpp
===================================================================
--- trunk/flexlay/lib/gui_manager.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/gui_manager.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -14,7 +14,6 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include <iostream>
 #include <ClanLib/gui.h>
 #include <ClanLib/guistylesilver.h>
 #include <ClanLib/core.h>

Modified: trunk/flexlay/lib/gui_manager.hpp
===================================================================
--- trunk/flexlay/lib/gui_manager.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/gui_manager.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -1,5 +1,3 @@
-//  $Id: gui_manager.hpp,v 1.2 2003/10/12 11:58:09 grumbel Exp $
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/helper.cpp
===================================================================
--- trunk/flexlay/lib/helper.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/helper.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -14,8 +14,6 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include <map>
-#include <string>
 #include <ClanLib/Display/sprite_description.h>
 #include <ClanLib/Display/pixel_format.h>
 #include <ClanLib/Display/Providers/provider_factory.h>

Modified: trunk/flexlay/lib/helper.hpp
===================================================================
--- trunk/flexlay/lib/helper.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/helper.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -18,7 +18,6 @@
 #define HEADER_FLEXLAY_HELPER_HPP
 
 #include <ClanLib/Display/sprite.h>
-#include <ClanLib/Display/pixel_buffer.h>
 
 CL_Sprite      pixelbuffer2sprite(const CL_PixelBuffer& buffer);
 CL_Sprite      make_sprite(const std::string& filename);

Modified: trunk/flexlay/lib/icon.cpp
===================================================================
--- trunk/flexlay/lib/icon.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/icon.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -14,11 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include <iostream>
 #include <ClanLib/Display/display.h>
-#include <ClanLib/Display/display_iostream.h>
 #include "box.hpp"
-#include "fonts.hpp"
 #include "icon.hpp"
 
 class IconImpl

Modified: trunk/flexlay/lib/icon.hpp
===================================================================
--- trunk/flexlay/lib/icon.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/icon.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -18,7 +18,6 @@
 #define HEADER_FLEXLAY_ICON_HPP
 
 #include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/Math/point.h>
 #include <ClanLib/Display/sprite.h>
 #include "shared_ptr.hpp"
 

Modified: trunk/flexlay/lib/layer.cpp
===================================================================
--- trunk/flexlay/lib/layer.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/layer.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -14,8 +14,6 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include <iostream>
-#include <ClanLib/Display/display.h>
 #include "layer_impl.hpp"
 #include "layer.hpp"
 

Modified: trunk/flexlay/lib/layer.hpp
===================================================================
--- trunk/flexlay/lib/layer.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/layer.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -17,13 +17,13 @@
 #ifndef HEADER_FLEXLAY_LAYER_HPP
 #define HEADER_FLEXLAY_LAYER_HPP
 
-#include <ClanLib/Core/Math/rect.h>
-#include <ClanLib/Display/graphic_context.h>
+
 #include "meta_data.hpp"
 #include "shared_ptr.hpp"
 
 class EditorMapComponent;
 class LayerImpl;
+class CL_GraphicContext;
 
 /** Each \a EditorMap consists out of one or more \a Layer,
     The \a Layer is an abstract base class from which the

Modified: trunk/flexlay/lib/lispreader.cpp
===================================================================
--- trunk/flexlay/lib/lispreader.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/lispreader.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -21,9 +21,6 @@
  * Boston, MA 02111-1307, USA.
  */
 
-#include <iostream>
-#include <string>
-#include <ctype.h>
 #include <stdlib.h>
 #include <string.h>
 #include "lispreader.hpp"

Modified: trunk/flexlay/lib/lispreader.hpp
===================================================================
--- trunk/flexlay/lib/lispreader.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/lispreader.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -28,7 +28,6 @@
 #include <zlib.h>
 #include <string>
 #include <vector>
-#include <exception>
 
 #define LISP_STREAM_FILE       1
 #define LISP_STREAM_STRING     2

Modified: trunk/flexlay/lib/menu.cpp
===================================================================
--- trunk/flexlay/lib/menu.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/menu.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -14,8 +14,6 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include <iostream>
-#include <string>
 #include <ClanLib/Display/display.h>
 #include <ClanLib/Display/sprite.h>
 #include "fonts.hpp"

Modified: trunk/flexlay/lib/menu.hpp
===================================================================
--- trunk/flexlay/lib/menu.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/menu.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -17,9 +17,7 @@
 #ifndef HEADER_FLEXLAY_MENU_HPP
 #define HEADER_FLEXLAY_MENU_HPP
 
-#include <string>
 #include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/Math/rect.h>
 #include "shared_ptr.hpp"
 
 class MenuImpl;

Modified: trunk/flexlay/lib/menubar.cpp
===================================================================
--- trunk/flexlay/lib/menubar.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/menubar.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -14,7 +14,6 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include "menu.hpp"
 #include "menubar.hpp"
 
 class MenubarItem

Modified: trunk/flexlay/lib/menubar.hpp
===================================================================
--- trunk/flexlay/lib/menubar.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/menubar.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -18,7 +18,6 @@
 #define HEADER_FLEXLAY_MENUBAR_HPP
 
 #include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/Math/rect.h>
 #include "shared_ptr.hpp"
 
 class Menu;

Modified: trunk/flexlay/lib/minimap.cpp
===================================================================
--- trunk/flexlay/lib/minimap.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/minimap.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -14,17 +14,20 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
+#include "minimap.hpp"
+
 #include <iostream>
 #include <ClanLib/Display/display.h>
+#include <ClanLib/Display/surface.h>
 #include <ClanLib/Display/pixel_format.h>
 #include <ClanLib/Display/pixel_buffer.h>
+
 #include "tile.hpp"
 #include "tileset.hpp"
 #include "editor_map.hpp"
 #include "editor_map_component.hpp"
 #include "tilemap_layer.hpp"
 #include "workspace.hpp"
-#include "minimap.hpp"
 
 class MinimapImpl
 {

Modified: trunk/flexlay/lib/minimap.hpp
===================================================================
--- trunk/flexlay/lib/minimap.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/minimap.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -18,8 +18,12 @@
 #define HEADER_FLEXLAY_MINIMAP_HPP
 
 #include <ClanLib/GUI/component.h>
+#include <ClanLib/Core/System/sharedptr.h>
 
+#include "shared_ptr.hpp"
+
 class MinimapImpl;
+class EditorMapComponent;
 
 /** */
 class Minimap : public CL_Component

Modified: trunk/flexlay/lib/object_add_command.cpp
===================================================================
--- trunk/flexlay/lib/object_add_command.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/object_add_command.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -15,7 +15,6 @@
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "object_layer.hpp"
-#include "objmap_object.hpp"
 #include "object_add_command.hpp"
 
 class ObjectAddCommandImpl : public CommandImpl

Modified: trunk/flexlay/lib/object_add_command.hpp
===================================================================
--- trunk/flexlay/lib/object_add_command.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/object_add_command.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -17,11 +17,11 @@
 #ifndef HEADER_FLEXLAY_OBJECT_ADD_COMMAND_HPP
 #define HEADER_FLEXLAY_OBJECT_ADD_COMMAND_HPP
 
-#include "objmap_object.hpp"
 #include "command.hpp"
 
+class ObjMapObject;
+class ObjectAddCommandImpl;
 class ObjectLayer;
-class ObjectAddCommandImpl;
 
 /** ObjectAddCommand adds on object to an ObjectLayer, the user needs
     to supply an Object together with the \a ObjectLayer to which it

Modified: trunk/flexlay/lib/object_brush.cpp
===================================================================
--- trunk/flexlay/lib/object_brush.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/object_brush.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -15,10 +15,7 @@
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "objmap_sprite_object.hpp"
-#include "object_add_command.hpp"
-#include "objmap_sprite_object.hpp"
 #include "object_brush.hpp"
-#include "editor_map.hpp"
 
 class ObjectBrushImpl
 {

Modified: trunk/flexlay/lib/object_brush.hpp
===================================================================
--- trunk/flexlay/lib/object_brush.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/object_brush.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -17,13 +17,10 @@
 #ifndef HEADER_FLEXLAY_OBJECT_BRUSH_HPP
 #define HEADER_FLEXLAY_OBJECT_BRUSH_HPP
 
-#include <ClanLib/Display/sprite.h>
-#include <ClanLib/Core/Math/point.h>
-#include "object_layer.hpp"
-#include "objmap_object.hpp"
 #include "objmap_sprite_object.hpp"
-#include "meta_data.hpp"
 
+class MetaData;
+
 class ObjectBrushImpl;
 
 class ObjectBrush

Modified: trunk/flexlay/lib/object_delete_command.cpp
===================================================================
--- trunk/flexlay/lib/object_delete_command.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/object_delete_command.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -15,8 +15,6 @@
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "object_layer.hpp"
-#include "objmap_object.hpp"
-#include "command_impl.hpp"
 #include "object_delete_command.hpp"
 
 class ObjectDeleteCommandImpl : public CommandImpl

Modified: trunk/flexlay/lib/object_delete_command.hpp
===================================================================
--- trunk/flexlay/lib/object_delete_command.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/object_delete_command.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -17,8 +17,6 @@
 #ifndef HEADER_FLEXLAY_OBJECT_DELETE_COMMAND_HPP
 #define HEADER_FLEXLAY_OBJECT_DELETE_COMMAND_HPP
 
-#include <vector>
-#include "objmap_object.hpp"
 #include "command.hpp"
 
 class ObjectDeleteCommandImpl;

Modified: trunk/flexlay/lib/object_layer.cpp
===================================================================
--- trunk/flexlay/lib/object_layer.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/object_layer.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -14,13 +14,6 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include <iostream>
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Core/Math/origin.h>
-#include <ClanLib/Core/System/error.h>
-#include "objmap_object.hpp"
-#include "objmap_sprite_object.hpp"
-#include "objmap_control_point.hpp"
 #include "object_layer.hpp"
 #include "editor_map_component.hpp"
 #include "layer_impl.hpp"

Modified: trunk/flexlay/lib/object_layer.hpp
===================================================================
--- trunk/flexlay/lib/object_layer.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/object_layer.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -17,15 +17,12 @@
 #ifndef HEADER_FLEXLAY_OBJECT_LAYER_HPP
 #define HEADER_FLEXLAY_OBJECT_LAYER_HPP
 
-#include <vector>
 #include <ClanLib/Display/sprite.h>
 #include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/Math/point.h>
 #include "meta_data.hpp"
 #include "layer.hpp"
 #include "objmap_object.hpp"
 #include "objmap_control_point.hpp"
-#include "shared_ptr.hpp"
 
 class ObjectLayerImpl;
 

Modified: trunk/flexlay/lib/object_move_command.cpp
===================================================================
--- trunk/flexlay/lib/object_move_command.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/object_move_command.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -15,7 +15,6 @@
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "object_layer.hpp"
-#include "objmap_object.hpp"
 #include "object_move_command.hpp"
 
 class ObjectMoveCommandImpl : public CommandImpl

Modified: trunk/flexlay/lib/objmap_control_point.hpp
===================================================================
--- trunk/flexlay/lib/objmap_control_point.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/objmap_control_point.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -18,9 +18,7 @@
 #define HEADER_FLEXLAY_OBJMAP_CONTROL_POINT_HPP
 
 #include <ClanLib/Display/sprite.h>
-#include <ClanLib/Core/Math/point.h>
 #include "meta_data.hpp"
-#include "shared_ptr.hpp"
 
 class ObjMapControlPointImpl;
 

Modified: trunk/flexlay/lib/objmap_object.cpp
===================================================================
--- trunk/flexlay/lib/objmap_object.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/objmap_object.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -15,7 +15,6 @@
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "objmap_object_impl.hpp"
-#include "objmap_object.hpp"
 
 ObjMapObject::ObjMapObject()
 {

Modified: trunk/flexlay/lib/objmap_object.hpp
===================================================================
--- trunk/flexlay/lib/objmap_object.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/objmap_object.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -17,10 +17,7 @@
 #ifndef HEADER_FLEXLAY_OBJMAP_OBJECT_HPP
 #define HEADER_FLEXLAY_OBJMAP_OBJECT_HPP
 
-#include <ClanLib/signals.h>
 #include <ClanLib/Display/graphic_context.h>
-#include <ClanLib/Core/Math/point.h>
-#include <ClanLib/Core/Math/rect.h>
 #include "meta_data.hpp"
 
 class ObjMapObjectImpl;

Modified: trunk/flexlay/lib/objmap_object_impl.cpp
===================================================================
--- trunk/flexlay/lib/objmap_object_impl.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/objmap_object_impl.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -14,7 +14,6 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include <iostream>
 #include "objmap_object_impl.hpp"
 
 ObjMapObjectImpl::ObjMapObjectImpl()

Modified: trunk/flexlay/lib/objmap_object_impl.hpp
===================================================================
--- trunk/flexlay/lib/objmap_object_impl.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/objmap_object_impl.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -17,10 +17,7 @@
 #ifndef HEADER_FLEXLAY_OBJMAP_OBJECT_IMPL_HPP
 #define HEADER_FLEXLAY_OBJMAP_OBJECT_IMPL_HPP
 
-#include <ClanLib/Core/Math/point.h>
-#include <ClanLib/Core/Math/rect.h>
 #include "objmap_object.hpp"
-#include "meta_data.hpp"
 
 class ObjMapObjectImpl 
 {

Modified: trunk/flexlay/lib/objmap_path_node.cpp
===================================================================
--- trunk/flexlay/lib/objmap_path_node.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/objmap_path_node.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -14,7 +14,6 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include <ClanLib/Display/display.h>
 #include "objmap_object_impl.hpp"
 #include "objmap_path_node.hpp"
 

Modified: trunk/flexlay/lib/objmap_path_node.hpp
===================================================================
--- trunk/flexlay/lib/objmap_path_node.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/objmap_path_node.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -17,7 +17,6 @@
 #ifndef HEADER_FLEXLAY_OBJMAP_PATH_NODE_HPP
 #define HEADER_FLEXLAY_OBJMAP_PATH_NODE_HPP
 
-#include "objmap_object.hpp"
 
 class ObjMapPathNodeImpl;
 

Modified: trunk/flexlay/lib/objmap_sprite_object.cpp
===================================================================
--- trunk/flexlay/lib/objmap_sprite_object.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/objmap_sprite_object.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -14,10 +14,10 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include <ClanLib/Display/display.h>
-#include "objmap_object_impl.hpp"
 #include "objmap_sprite_object.hpp"
 
+#include "objmap_object_impl.hpp"
+
 class ObjMapSpriteObjectImpl : public ObjMapObjectImpl
 {
 public:

Modified: trunk/flexlay/lib/objmap_sprite_object.hpp
===================================================================
--- trunk/flexlay/lib/objmap_sprite_object.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/objmap_sprite_object.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -18,11 +18,10 @@
 #define HEADER_FLEXLAY_OBJMAP_SPRITE_OBJECT_HPP
 
 #include <ClanLib/Display/sprite.h>
-#include <ClanLib/Core/Math/point.h>
-#include "shared_ptr.hpp"
-#include "meta_data.hpp"
 #include "objmap_object.hpp"
 
+#include "meta_data.hpp"
+
 class ObjMapSpriteObjectImpl;
 
 /** */

Modified: trunk/flexlay/lib/paint_command.cpp
===================================================================
--- trunk/flexlay/lib/paint_command.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/paint_command.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -14,14 +14,7 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include <assert.h>
-#include <iostream>
 #include <sstream>
-#include <vector>
-#include <ClanLib/Core/core_iostream.h>
-#include <ClanLib/Core/Math/rect.h>
-#include "field.hpp"
-#include "tilemap_layer.hpp"
 #include "paint_command.hpp"
 
 class PaintCommandImpl : public CommandImpl

Modified: trunk/flexlay/lib/paint_command.hpp
===================================================================
--- trunk/flexlay/lib/paint_command.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/paint_command.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -17,9 +17,7 @@
 #ifndef HEADER_FLEXLAY_PAINT_COMMAND_HPP
 #define HEADER_FLEXLAY_PAINT_COMMAND_HPP
 
-#include <ClanLib/Core/Math/point.h>
 #include "tile_brush.hpp"
-#include "shared_ptr.hpp"
 #include "tilemap_layer.hpp"
 #include "command.hpp"
 

Modified: trunk/flexlay/lib/panel.cpp
===================================================================
--- trunk/flexlay/lib/panel.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/panel.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -14,8 +14,6 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include <vector>
-#include <ClanLib/Signals/slot.h>
 #include <ClanLib/Display/display.h>
 #include "box.hpp"
 #include "panel.hpp"

Modified: trunk/flexlay/lib/panel.hpp
===================================================================
--- trunk/flexlay/lib/panel.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/panel.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -18,7 +18,6 @@
 #define HEADER_FLEXLAY_PANEL_HPP
 
 #include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/Math/rect.h>
 #include "shared_ptr.hpp"
 
 class PanelImpl;

Modified: trunk/flexlay/lib/popup_menu.cpp
===================================================================
--- trunk/flexlay/lib/popup_menu.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/popup_menu.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -14,7 +14,6 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include <iostream>
 #include <ClanLib/Display/mouse.h>
 #include "popup_menu.hpp"
 

Modified: trunk/flexlay/lib/popup_menu.hpp
===================================================================
--- trunk/flexlay/lib/popup_menu.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/popup_menu.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -17,9 +17,6 @@
 #ifndef HEADER_FLEXLAY_POPUP_MENU_HPP
 #define HEADER_FLEXLAY_POPUP_MENU_HPP
 
-#include <vector>
-#include <ClanLib/Signals/slot.h>
-#include <ClanLib/GUI/component.h>
 #include <ClanLib/GUI/menu.h>
 
 /** */

Modified: trunk/flexlay/lib/scrollbar.hpp
===================================================================
--- trunk/flexlay/lib/scrollbar.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/scrollbar.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -18,7 +18,6 @@
 #define HEADER_FLEXLAY_SCROLLBAR_HPP
 
 #include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/Math/rect.h>
 #include "shared_ptr.hpp"
 
 class ScrollbarImpl;

Modified: trunk/flexlay/lib/sharedptrtest.cpp
===================================================================
--- trunk/flexlay/lib/sharedptrtest.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/sharedptrtest.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -15,9 +15,7 @@
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include <iostream>
-#include <ClanLib/Core/System/sharedptr.h>
 #include <boost/shared_ptr.hpp>
-#include "sharedptrtest.hpp"
 
 #define SharedPtr boost::shared_ptr
 

Modified: trunk/flexlay/lib/simpleed.cpp
===================================================================
--- trunk/flexlay/lib/simpleed.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/simpleed.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -16,18 +16,6 @@
 
 #if 0
 
-#include <iostream>
-#include <string>
-#include <ClanLib/core.h>
-#include <ClanLib/gui.h>
-#include "workspace.hpp"
-#include "tileset.hpp"
-#include "editor_map_component.hpp"
-#include "gui_manager.hpp"
-#include "layer.hpp"
-#include "tilemap_layer.hpp"
-#include "flexlay.hpp"
-#include "editor_map.hpp"
 
 int main()
 {

Modified: trunk/flexlay/lib/slider.hpp
===================================================================
--- trunk/flexlay/lib/slider.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/slider.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -17,9 +17,7 @@
 #ifndef HEADER_FLEXLAY_SLIDER_HPP
 #define HEADER_FLEXLAY_SLIDER_HPP
 
-#include <vector>
 #include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/Math/rect.h>
 
 /** Little Slider GUI component */
 class Slider : public CL_Component

Modified: trunk/flexlay/lib/sprite_brush.cpp
===================================================================
--- trunk/flexlay/lib/sprite_brush.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/sprite_brush.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -14,7 +14,6 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include "brush_impl.hpp"
 #include "sprite_brush.hpp"
 
 class SpriteBrushImpl : public BrushImpl

Modified: trunk/flexlay/lib/sprite_brush.hpp
===================================================================
--- trunk/flexlay/lib/sprite_brush.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/sprite_brush.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -17,9 +17,7 @@
 #ifndef HEADER_FLEXLAY_SPRITE_BRUSH_HPP
 #define HEADER_FLEXLAY_SPRITE_BRUSH_HPP
 
-#include <ClanLib/Display/sprite.h>
 #include "brush.hpp"
-#include "shared_ptr.hpp"
 
 class SpriteBrushImpl;
 

Modified: trunk/flexlay/lib/sprite_stroke_drawer.cpp
===================================================================
--- trunk/flexlay/lib/sprite_stroke_drawer.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/sprite_stroke_drawer.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -21,7 +21,6 @@
 #include <ClanLib/gl.h>
 #include <ClanLib/GL/opengl_wrap.h>
 #include "stroke.hpp"
-#include "flexlay.hpp"
 #include "stroke_drawer_impl.hpp"
 #include "sprite_stroke_drawer.hpp"
 #include "drawer_properties.hpp"

Modified: trunk/flexlay/lib/sprite_stroke_drawer.hpp
===================================================================
--- trunk/flexlay/lib/sprite_stroke_drawer.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/sprite_stroke_drawer.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -17,10 +17,7 @@
 #ifndef HEADER_FLEXLAY_SPRITE_STROKE_DRAWER_HPP
 #define HEADER_FLEXLAY_SPRITE_STROKE_DRAWER_HPP
 
-#include <ClanLib/Display/color.h>
-#include <ClanLib/Display/sprite.h>
 #include "stroke_drawer.hpp"
-#include "brush.hpp"
 
 class Stroke;
 class SpriteStrokeDrawerImpl;

Modified: trunk/flexlay/lib/string_converter.hpp
===================================================================
--- trunk/flexlay/lib/string_converter.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/string_converter.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -1,5 +1,3 @@
-//  $Id: string_converter.hpp,v 1.3 2003/11/04 22:48:51 grumbel Exp $
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2000 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/stroke.hpp
===================================================================
--- trunk/flexlay/lib/stroke.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/stroke.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -18,7 +18,6 @@
 #define HEADER_FLEXLAY_STROKE_HPP
 
 #include <vector>
-#include <ClanLib/Core/Math/point.h>
 #include <ClanLib/Core/Math/rect.h>
 #include <ClanLib/Core/System/system.h>
 #include "shared_ptr.hpp"

Modified: trunk/flexlay/lib/stroke_drawer.cpp
===================================================================
--- trunk/flexlay/lib/stroke_drawer.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/stroke_drawer.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -14,7 +14,6 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include "stroke.hpp"
 #include "stroke_drawer_impl.hpp"
 #include "stroke_drawer.hpp"
 

Modified: trunk/flexlay/lib/tile.cpp
===================================================================
--- trunk/flexlay/lib/tile.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/tile.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -16,7 +16,7 @@
 
 #include <ClanLib/Core/System/error.h>
 #include <ClanLib/Display/sprite_description.h>
-#include <ClanLib/Display/pixel_buffer.h>
+#include <ClanLib/Display/sprite.h>
 #include <ClanLib/Display/pixel_format.h>
 #include <ClanLib/Display/palette.h>
 #include <ClanLib/Display/Providers/provider_factory.h>

Modified: trunk/flexlay/lib/tile.hpp
===================================================================
--- trunk/flexlay/lib/tile.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/tile.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -1,5 +1,3 @@
-//  $Id: tile.hpp,v 1.6 2003/09/22 18:37:05 grumbel Exp $
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -19,13 +17,13 @@
 #ifndef HEADER_FLEXLAY_TILE_HPP
 #define HEADER_FLEXLAY_TILE_HPP
 
-#include <assert.h>
-#include <ClanLib/Display/sprite.h>
-#include <ClanLib/Display/pixel_buffer.h>
+#include <ClanLib/Display/color.h>
 #include "shared_ptr.hpp"
 
 class TileImpl;
 class TileProvider;
+class CL_PixelBuffer;
+class CL_Sprite;
 
 /** A Tile is a surface or sprite together with meta information for
     collision (aka colmap), walkability or such. */

Modified: trunk/flexlay/lib/tile_brush.cpp
===================================================================
--- trunk/flexlay/lib/tile_brush.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/tile_brush.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -15,8 +15,6 @@
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include <ClanLib/Core/Math/rect.h>
-#include <iostream>
-#include <ClanLib/Core/core_iostream.h>
 #include "tile_brush.hpp"
 
 TileBrush::TileBrush()

Modified: trunk/flexlay/lib/tile_editor.cpp
===================================================================
--- trunk/flexlay/lib/tile_editor.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/tile_editor.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -14,14 +14,13 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include <iostream>
-#include <ClanLib/gui.h>
+#include "tile_editor.hpp"
+
 #include <ClanLib/Display/display.h>
 #include <ClanLib/Display/keys.h>
+#include <ClanLib/Display/sprite.h>
 #include <ClanLib/Display/mouse.h>
 #include "tile.hpp"
-#include "globals.hpp"
-#include "tile_editor.hpp"
 
 TileEditor::TileEditor(int x, int y, int w, int h, CL_Component* parent)
   : CL_Component(CL_Rect(CL_Rect(CL_Point(x, y), 

Modified: trunk/flexlay/lib/tile_editor.hpp
===================================================================
--- trunk/flexlay/lib/tile_editor.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/tile_editor.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -1,5 +1,3 @@
-//  $Id: tile_editor.hpp,v 1.1 2003/09/22 18:37:05 grumbel Exp $
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
@@ -20,8 +18,6 @@
 #define HEADER_FLEXLAY_TILE_EDITOR_HPP
 
 #include <ClanLib/GUI/component.h>
-#include <ClanLib/Signals/slot_container.h>
-#include <ClanLib/Core/Math/point.h>
 
 class Tile;
 

Modified: trunk/flexlay/lib/tile_provider.hpp
===================================================================
--- trunk/flexlay/lib/tile_provider.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/tile_provider.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -17,8 +17,6 @@
 #ifndef HEADER_FLEXLAY_TILE_PROVIDER_HPP
 #define HEADER_FLEXLAY_TILE_PROVIDER_HPP
 
-#include <ClanLib/Display/sprite.h>
-#include <ClanLib/Display/pixel_buffer.h>
 #include "shared_ptr.hpp"
 
 class TileProviderImpl;

Modified: trunk/flexlay/lib/tile_selection.cpp
===================================================================
--- trunk/flexlay/lib/tile_selection.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/tile_selection.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -16,9 +16,7 @@
 
 #include <ClanLib/Display/display.h>
 #include <iostream>
-#include <ClanLib/Core/core_iostream.h>
 #include "math.hpp"
-#include "tilemap_layer.hpp"
 #include "tileset.hpp"
 #include "tile_selection.hpp"
 

Modified: trunk/flexlay/lib/tile_selection.hpp
===================================================================
--- trunk/flexlay/lib/tile_selection.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/tile_selection.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -17,9 +17,6 @@
 #ifndef HEADER_FLEXLAY_TILE_SELECTION_HPP
 #define HEADER_FLEXLAY_TILE_SELECTION_HPP
 
-#include <ClanLib/Core/Math/rect.h>
-#include <ClanLib/Display/color.h>
-#include <ClanLib/Core/Math/point.h>
 #include "tile_brush.hpp"
 #include "tilemap_layer.hpp"
 

Modified: trunk/flexlay/lib/tile_selector.hpp
===================================================================
--- trunk/flexlay/lib/tile_selector.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/tile_selector.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -1,5 +1,3 @@
-//  $Id: tile_selector.hpp,v 1.2 2003/09/10 13:53:11 grumbel Exp $
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2000 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/tilemap_layer.cpp
===================================================================
--- trunk/flexlay/lib/tilemap_layer.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/tilemap_layer.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -14,12 +14,16 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
+#include "tilemap_layer.hpp"
+
 #include <math.h>
 #include <ClanLib/Display/display.h>
 #include <ClanLib/Display/pixel_buffer.h>
 #include <ClanLib/Display/pixel_format.h>
 #include <ClanLib/Display/palette.h>
+#include <ClanLib/Display/sprite.h>
 #include <ClanLib/gl.h>
+
 #include "tile.hpp"
 #include "tileset.hpp"
 #include "editor_map.hpp"
@@ -29,7 +33,6 @@
 #include "blitter.hpp"
 #include "layer_impl.hpp"
 #include "editor_map_component.hpp"
-#include "tilemap_layer.hpp"
 
 TilemapLayer TilemapLayer::current_;
 

Modified: trunk/flexlay/lib/tileset.hpp
===================================================================
--- trunk/flexlay/lib/tileset.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/tileset.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -1,5 +1,3 @@
-//  $Id: tile_factory.hpp,v 1.8 2003/09/22 18:37:05 grumbel Exp $
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2000 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/titlebar.cpp
===================================================================
--- trunk/flexlay/lib/titlebar.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/titlebar.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -14,7 +14,6 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include <iostream>
 #include <ClanLib/Display/display.h>
 #include <ClanLib/Display/keys.h>
 #include <ClanLib/Display/mouse.h>

Modified: trunk/flexlay/lib/titlebar.hpp
===================================================================
--- trunk/flexlay/lib/titlebar.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/titlebar.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -18,7 +18,6 @@
 #define HEADER_FLEXLAY_TITLEBAR_HPP
 
 #include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/Math/rect.h>
 #include "shared_ptr.hpp"
 
 class TitlebarImpl;

Modified: trunk/flexlay/lib/tools/objmap_select_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/objmap_select_tool.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/tools/objmap_select_tool.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -1,5 +1,3 @@
-//  $Id: tilemap_object_tool.hpp,v 1.1 2003/09/23 22:10:40 grumbel Exp $
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/tools/tilemap_paint_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/tilemap_paint_tool.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/tools/tilemap_paint_tool.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -20,6 +20,7 @@
 #include <ClanLib/Display/keyboard.h>
 #include <ClanLib/Display/keys.h>
 #include <ClanLib/Display/display.h>
+#include <ClanLib/Display/sprite.h>
 
 #include "globals.hpp"
 #include "tilemap_layer.hpp"

Modified: trunk/flexlay/lib/tools/tilemap_paint_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/tilemap_paint_tool.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/tools/tilemap_paint_tool.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -1,5 +1,3 @@
-//  $Id: tilemap_paint_tool.hpp,v 1.1 2003/09/23 19:10:05 grumbel Exp $
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/tools/tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/tool.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/tools/tool.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -1,5 +1,3 @@
-//  $Id: tilemap_tool.hpp,v 1.1 2003/09/23 19:10:05 grumbel Exp $
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/tools/tool_impl.hpp
===================================================================
--- trunk/flexlay/lib/tools/tool_impl.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/tools/tool_impl.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -1,5 +1,3 @@
-//  $Id: tilemap_tool.hpp,v 1.1 2003/09/23 19:10:05 grumbel Exp $
-// 
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //

Modified: trunk/flexlay/lib/window.cpp
===================================================================
--- trunk/flexlay/lib/window.cpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/window.cpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -15,14 +15,8 @@
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include <iostream>
-#include <ClanLib/Core/core_iostream.h>
 #include <ClanLib/Display/display.h>
-#include <ClanLib/Display/keys.h>
-#include <ClanLib/Display/sprite_description.h>
-#include <ClanLib/Display/Providers/provider_factory.h>
-#include <ClanLib/GUI/gui_manager.h>
 #include "box.hpp"
-#include "fonts.hpp"
 #include "icon.hpp"
 #include "helper.hpp"
 #include "titlebar.hpp"

Modified: trunk/flexlay/lib/window.hpp
===================================================================
--- trunk/flexlay/lib/window.hpp	2009-11-22 03:48:00 UTC (rev 722)
+++ trunk/flexlay/lib/window.hpp	2009-11-22 04:36:12 UTC (rev 723)
@@ -17,9 +17,6 @@
 #ifndef HEADER_FLEXLAY_WINDOW_HPP
 #define HEADER_FLEXLAY_WINDOW_HPP
 
-#include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/Math/rect.h>
-#include "shared_ptr.hpp"
 
 class WindowImpl;
 



From grumbel at mail.berlios.de  Sun Nov 22 05:59:28 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 22 Nov 2009 05:59:28 +0100
Subject: [Flexlay-commit] r724 - in trunk/flexlay: lib lib/tools netpanzer
Message-ID: <200911220459.nAM4xSOt031942@sheep.berlios.de>

Author: grumbel
Date: 2009-11-22 05:59:25 +0100 (Sun, 22 Nov 2009)
New Revision: 724

Removed:
   trunk/flexlay/lib/shared_ptr.hpp
   trunk/flexlay/lib/shared_ptr_comp.hpp
   trunk/flexlay/lib/sharedptrtest.cpp
   trunk/flexlay/lib/sharedptrtest.hpp
Modified:
   trunk/flexlay/lib/bitmap_layer.hpp
   trunk/flexlay/lib/brush.cpp
   trunk/flexlay/lib/brush.hpp
   trunk/flexlay/lib/command.cpp
   trunk/flexlay/lib/command.hpp
   trunk/flexlay/lib/console.hpp
   trunk/flexlay/lib/directory_view.hpp
   trunk/flexlay/lib/drawer_properties.hpp
   trunk/flexlay/lib/editor_map.cpp
   trunk/flexlay/lib/editor_map.hpp
   trunk/flexlay/lib/editor_map_component.hpp
   trunk/flexlay/lib/generated_brush.hpp
   trunk/flexlay/lib/graphic_context_state.hpp
   trunk/flexlay/lib/gui_manager.hpp
   trunk/flexlay/lib/icon.hpp
   trunk/flexlay/lib/layer.cpp
   trunk/flexlay/lib/layer.hpp
   trunk/flexlay/lib/marker_stroke_drawer.hpp
   trunk/flexlay/lib/menu.hpp
   trunk/flexlay/lib/menubar.hpp
   trunk/flexlay/lib/meta_data.cpp
   trunk/flexlay/lib/meta_data.hpp
   trunk/flexlay/lib/minimap.hpp
   trunk/flexlay/lib/object_add_command.hpp
   trunk/flexlay/lib/object_brush.hpp
   trunk/flexlay/lib/object_delete_command.hpp
   trunk/flexlay/lib/object_layer.hpp
   trunk/flexlay/lib/object_move_command.hpp
   trunk/flexlay/lib/objmap_control_point.hpp
   trunk/flexlay/lib/objmap_object.cpp
   trunk/flexlay/lib/objmap_object.hpp
   trunk/flexlay/lib/objmap_path_node.hpp
   trunk/flexlay/lib/objmap_rect_object.cpp
   trunk/flexlay/lib/objmap_rect_object.hpp
   trunk/flexlay/lib/objmap_sprite_object.cpp
   trunk/flexlay/lib/objmap_sprite_object.hpp
   trunk/flexlay/lib/onion_skin_layer.hpp
   trunk/flexlay/lib/paint_command.hpp
   trunk/flexlay/lib/panel.hpp
   trunk/flexlay/lib/scrollbar.hpp
   trunk/flexlay/lib/sketch_layer.hpp
   trunk/flexlay/lib/sprite_brush.hpp
   trunk/flexlay/lib/sprite_stroke_drawer.cpp
   trunk/flexlay/lib/sprite_stroke_drawer.hpp
   trunk/flexlay/lib/stroke.hpp
   trunk/flexlay/lib/stroke_drawer.cpp
   trunk/flexlay/lib/stroke_drawer.hpp
   trunk/flexlay/lib/tile.hpp
   trunk/flexlay/lib/tile_provider.hpp
   trunk/flexlay/lib/tile_selection.hpp
   trunk/flexlay/lib/tilemap_layer.cpp
   trunk/flexlay/lib/tilemap_layer.hpp
   trunk/flexlay/lib/tileset.hpp
   trunk/flexlay/lib/titlebar.hpp
   trunk/flexlay/lib/tools/layer_move_tool.hpp
   trunk/flexlay/lib/tools/objmap_select_tool.hpp
   trunk/flexlay/lib/tools/sketch_stroke_tool.hpp
   trunk/flexlay/lib/tools/tilemap_paint_tool.hpp
   trunk/flexlay/lib/tools/tilemap_select_tool.hpp
   trunk/flexlay/lib/tools/tool.cpp
   trunk/flexlay/lib/tools/tool.hpp
   trunk/flexlay/lib/tools/workspace_move_tool.hpp
   trunk/flexlay/lib/tools/zoom2_tool.hpp
   trunk/flexlay/lib/tools/zoom_tool.hpp
   trunk/flexlay/lib/viewport.hpp
   trunk/flexlay/lib/window.hpp
   trunk/flexlay/lib/workspace.cpp
   trunk/flexlay/lib/workspace.hpp
   trunk/flexlay/netpanzer/netpanzer.hpp
Log:
Switched from SharedPtr/CL_SharedPtr to boost::shared_ptr<>


Modified: trunk/flexlay/lib/bitmap_layer.hpp
===================================================================
--- trunk/flexlay/lib/bitmap_layer.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/bitmap_layer.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -57,7 +57,7 @@
   ObjMapObject to_object();
 
 private:
-  SharedPtr<BitmapLayerImpl> impl;
+  boost::shared_ptr<BitmapLayerImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/brush.cpp
===================================================================
--- trunk/flexlay/lib/brush.cpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/brush.cpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -20,7 +20,7 @@
 {
 }
 
-Brush::Brush(SharedPtr<BrushImpl> impl_)
+Brush::Brush(boost::shared_ptr<BrushImpl> impl_)
   : impl(impl_)
 {
   
@@ -29,7 +29,7 @@
 Brush
 Brush::clone() const
 {
-  return Brush(impl->clone());
+  return Brush(boost::shared_ptr<BrushImpl>(impl->clone()));
 }
 
 CL_Sprite

Modified: trunk/flexlay/lib/brush.hpp
===================================================================
--- trunk/flexlay/lib/brush.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/brush.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -17,21 +17,22 @@
 #ifndef HEADER_FLEXLAY_BRUSH_HPP
 #define HEADER_FLEXLAY_BRUSH_HPP
 
+#include <boost/shared_ptr.hpp>
+
 #include "brush_impl.hpp"
-#include "shared_ptr.hpp"
 
-/** */
 class Brush
 {
 public:
   Brush();
-  Brush(SharedPtr<BrushImpl> impl);
+  Brush(boost::shared_ptr<BrushImpl> impl);
 
   CL_Sprite get_sprite();
   Brush clone() const;
   bool is_null() const { return !impl.get(); }
+
 public:
-  SharedPtr<BrushImpl> impl;
+  boost::shared_ptr<BrushImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/command.cpp
===================================================================
--- trunk/flexlay/lib/command.cpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/command.cpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -21,7 +21,7 @@
 {
 }
 
-Command::Command(const SharedPtr<CommandImpl>& impl_)
+Command::Command(const boost::shared_ptr<CommandImpl>& impl_)
   : impl(impl_)
 {
 }

Modified: trunk/flexlay/lib/command.hpp
===================================================================
--- trunk/flexlay/lib/command.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/command.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -17,7 +17,7 @@
 #ifndef HEADER_FLEXLAY_COMMAND_HPP
 #define HEADER_FLEXLAY_COMMAND_HPP
 
-#include "shared_ptr.hpp"
+#include <boost/shared_ptr.hpp>
 #include "command_impl.hpp"
 
 /** Command is an abstract base class for all data manipulating
@@ -29,7 +29,7 @@
 private:
 public:
   Command();
-  Command(const SharedPtr<CommandImpl>& impl_);
+  Command(const boost::shared_ptr<CommandImpl>& impl_);
 
   /** Execute the command */
   void execute();
@@ -44,7 +44,7 @@
   std::string serialize();
 
 private:
-  SharedPtr<CommandImpl> impl;
+  boost::shared_ptr<CommandImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/console.hpp
===================================================================
--- trunk/flexlay/lib/console.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/console.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -18,7 +18,7 @@
 #define HEADER_FLEXLAY_CONSOLE_HPP
 
 #include <ClanLib/GUI/component.h>
-#include "shared_ptr.hpp"
+#include <boost/shared_ptr.hpp>
 
 class CL_Font;
 class CL_Size;
@@ -36,7 +36,7 @@
   void write(const std::string& );
   void clearscr();
 private:
-  SharedPtr<ConsoleImpl> impl;
+  boost::shared_ptr<ConsoleImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/directory_view.hpp
===================================================================
--- trunk/flexlay/lib/directory_view.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/directory_view.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -18,7 +18,7 @@
 #define HEADER_FLEXLAY_DIRECTORY_VIEW_HPP
 
 #include <ClanLib/GUI/component.h>
-#include "shared_ptr.hpp"
+#include <boost/shared_ptr.hpp>
 
 class DirectoryViewImpl;
 
@@ -38,7 +38,7 @@
   CL_Signal_v1<std::string>& sig_on_click();
 
 private:
-  SharedPtr<DirectoryViewImpl> impl;
+  boost::shared_ptr<DirectoryViewImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/drawer_properties.hpp
===================================================================
--- trunk/flexlay/lib/drawer_properties.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/drawer_properties.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -53,7 +53,7 @@
   Brush get_brush() const;
 
 private:
-  SharedPtr<DrawerPropertiesImpl> impl;
+  boost::shared_ptr<DrawerPropertiesImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/editor_map.cpp
===================================================================
--- trunk/flexlay/lib/editor_map.cpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/editor_map.cpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -14,11 +14,12 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
+#include "editor_map.hpp"
+
 #include <iostream>
 #include <ClanLib/Display/color.h>
 #include <ClanLib/Display/graphic_context.h>
 #include <ClanLib/signals.h>
-#include "editor_map.hpp"
 
 class EditorMapImpl
 {
@@ -51,12 +52,12 @@
   CL_Rect bounding_rect;
 };
 
-EditorMap::EditorMap(bool create)
-  : impl(0)
+EditorMap::EditorMap(bool create) :
+  impl()
 {
   if (create)
   {
-    impl = new EditorMapImpl();
+    impl.reset(new EditorMapImpl());
     impl->background_color = CL_Color(100, 80, 100);
     impl->foreground_color = CL_Color(255, 80, 255);
     impl->modified = false;

Modified: trunk/flexlay/lib/editor_map.hpp
===================================================================
--- trunk/flexlay/lib/editor_map.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/editor_map.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -19,6 +19,8 @@
 
 #include <ClanLib/Core/Math/rect.h>
 #include <ClanLib/Core/System/sharedptr.h>
+#include <ClanLib/Display/color.h>
+
 #include "layer.hpp"
 #include "meta_data.hpp"
 #include "command.hpp"
@@ -87,7 +89,7 @@
   bool is_null() const { return !impl.get(); }
 
 private:
-  CL_SharedPtr<EditorMapImpl> impl;
+  boost::shared_ptr<EditorMapImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/editor_map_component.hpp
===================================================================
--- trunk/flexlay/lib/editor_map_component.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/editor_map_component.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -57,7 +57,7 @@
   GraphicContextState& get_gc_state();
 
 private:
-  SharedPtr<EditorMapComponentImpl> impl;
+  boost::shared_ptr<EditorMapComponentImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/generated_brush.hpp
===================================================================
--- trunk/flexlay/lib/generated_brush.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/generated_brush.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -55,7 +55,7 @@
 
   Brush to_brush();
 private:
-  SharedPtr<GeneratedBrushImpl> impl;
+  boost::shared_ptr<GeneratedBrushImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/graphic_context_state.hpp
===================================================================
--- trunk/flexlay/lib/graphic_context_state.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/graphic_context_state.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -19,7 +19,7 @@
 
 #include <ClanLib/Core/Math/point.h>
 #include <ClanLib/Core/Math/rect.h>
-#include "shared_ptr.hpp"
+#include <boost/shared_ptr.hpp>
 
 class CL_GraphicContext;
 
@@ -68,7 +68,7 @@
   CL_Pointf screen2world(const CL_Point& pos);
 
 private:
-  SharedPtr<GraphicContextStateImpl> impl;
+  boost::shared_ptr<GraphicContextStateImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/gui_manager.hpp
===================================================================
--- trunk/flexlay/lib/gui_manager.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/gui_manager.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -17,7 +17,7 @@
 #ifndef HEADER_FLEXLAY_GUI_MANAGER_HPP
 #define HEADER_FLEXLAY_GUI_MANAGER_HPP
 
-#include "shared_ptr.hpp"
+#include <boost/shared_ptr.hpp>
 
 class GUIManagerImpl;
 
@@ -50,7 +50,7 @@
   CL_SlotContainer* get_slot_container();
 
 private:
-  SharedPtr<GUIManagerImpl> impl;
+  boost::shared_ptr<GUIManagerImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/icon.hpp
===================================================================
--- trunk/flexlay/lib/icon.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/icon.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -19,7 +19,7 @@
 
 #include <ClanLib/GUI/component.h>
 #include <ClanLib/Display/sprite.h>
-#include "shared_ptr.hpp"
+#include <boost/shared_ptr.hpp>
 
 class IconImpl;
 
@@ -43,7 +43,7 @@
   Icon (const Icon&);
   Icon& operator= (const Icon&);
 
-  SharedPtr<IconImpl> impl;
+  boost::shared_ptr<IconImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/layer.cpp
===================================================================
--- trunk/flexlay/lib/layer.cpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/layer.cpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -17,12 +17,12 @@
 #include "layer_impl.hpp"
 #include "layer.hpp"
 
-Layer::Layer()
-  : impl(0)
+Layer::Layer() :
+  impl()
 {
 }
 
-Layer::Layer(SharedPtr<LayerImpl> i)
+Layer::Layer(boost::shared_ptr<LayerImpl> i)
   : impl(i)
 {
 }

Modified: trunk/flexlay/lib/layer.hpp
===================================================================
--- trunk/flexlay/lib/layer.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/layer.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -17,9 +17,9 @@
 #ifndef HEADER_FLEXLAY_LAYER_HPP
 #define HEADER_FLEXLAY_LAYER_HPP
 
+#include <boost/shared_ptr.hpp>
 
 #include "meta_data.hpp"
-#include "shared_ptr.hpp"
 
 class EditorMapComponent;
 class LayerImpl;
@@ -35,7 +35,7 @@
 private:
 public:
   Layer();
-  Layer(SharedPtr<LayerImpl> i);
+  Layer(boost::shared_ptr<LayerImpl> i);
   ~Layer();
 
   MetaData get_metadata() const;
@@ -56,8 +56,9 @@
   /** Returns the current position of the layer */
   CL_Pointf get_pos() const;
   bool is_null() const;
+
 public:
-  SharedPtr<LayerImpl> impl;
+  boost::shared_ptr<LayerImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/marker_stroke_drawer.hpp
===================================================================
--- trunk/flexlay/lib/marker_stroke_drawer.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/marker_stroke_drawer.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -31,7 +31,7 @@
   StrokeDrawer to_drawer();
 
 private:
-  SharedPtr<MarkerStrokeDrawerImpl> impl;
+  boost::shared_ptr<MarkerStrokeDrawerImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/menu.hpp
===================================================================
--- trunk/flexlay/lib/menu.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/menu.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -18,7 +18,7 @@
 #define HEADER_FLEXLAY_MENU_HPP
 
 #include <ClanLib/GUI/component.h>
-#include "shared_ptr.hpp"
+#include <boost/shared_ptr.hpp>
 
 class MenuImpl;
 class CL_Sprite;
@@ -45,7 +45,7 @@
 
   void run();
 private:
-  SharedPtr<MenuImpl> impl;
+  boost::shared_ptr<MenuImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/menubar.hpp
===================================================================
--- trunk/flexlay/lib/menubar.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/menubar.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -18,7 +18,7 @@
 #define HEADER_FLEXLAY_MENUBAR_HPP
 
 #include <ClanLib/GUI/component.h>
-#include "shared_ptr.hpp"
+#include <boost/shared_ptr.hpp>
 
 class Menu;
 class MenubarImpl;
@@ -33,7 +33,7 @@
 
   void add_submenu(const std::string& name, Menu* menu);
 private:
-  SharedPtr<MenubarImpl> impl;
+  boost::shared_ptr<MenubarImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/meta_data.cpp
===================================================================
--- trunk/flexlay/lib/meta_data.cpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/meta_data.cpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -20,7 +20,7 @@
 {
 }
 
-MetaData::MetaData(SharedPtr<MetaDataImpl> impl_)
+MetaData::MetaData(boost::shared_ptr<MetaDataImpl> impl_)
   : impl(impl_)
 {
 }
@@ -29,7 +29,7 @@
 {
 }
 
-SharedPtr<MetaDataImpl>
+boost::shared_ptr<MetaDataImpl>
 MetaData::get_impl() const
 {
   return impl;

Modified: trunk/flexlay/lib/meta_data.hpp
===================================================================
--- trunk/flexlay/lib/meta_data.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/meta_data.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -17,7 +17,7 @@
 #ifndef HEADER_FLEXLAY_META_DATA_HPP
 #define HEADER_FLEXLAY_META_DATA_HPP
 
-#include "shared_ptr.hpp"
+#include <boost/shared_ptr.hpp>
 
 class MetaDataImpl;
 
@@ -27,12 +27,12 @@
 private:
 public:
   MetaData();
-  MetaData(SharedPtr<MetaDataImpl> impl_);
+  MetaData(boost::shared_ptr<MetaDataImpl> impl_);
   ~MetaData();
   
-  SharedPtr<MetaDataImpl> get_impl() const;
+  boost::shared_ptr<MetaDataImpl> get_impl() const;
 private:
-  SharedPtr<MetaDataImpl> impl;
+  boost::shared_ptr<MetaDataImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/minimap.hpp
===================================================================
--- trunk/flexlay/lib/minimap.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/minimap.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -20,7 +20,7 @@
 #include <ClanLib/GUI/component.h>
 #include <ClanLib/Core/System/sharedptr.h>
 
-#include "shared_ptr.hpp"
+#include <boost/shared_ptr.hpp>
 
 class MinimapImpl;
 class EditorMapComponent;
@@ -41,7 +41,7 @@
   void mouse_up  (const CL_InputEvent& event);
   
 private:
-  SharedPtr<MinimapImpl> impl;
+  boost::shared_ptr<MinimapImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/object_add_command.hpp
===================================================================
--- trunk/flexlay/lib/object_add_command.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/object_add_command.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -40,7 +40,7 @@
   Command to_command();
 
 private:
-  SharedPtr<ObjectAddCommandImpl> impl;
+  boost::shared_ptr<ObjectAddCommandImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/object_brush.hpp
===================================================================
--- trunk/flexlay/lib/object_brush.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/object_brush.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -35,7 +35,7 @@
 
   ObjMapSpriteObject to_sprite_object(const CL_Pointf& pos);
 private:
-  SharedPtr<ObjectBrushImpl> impl;
+  boost::shared_ptr<ObjectBrushImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/object_delete_command.hpp
===================================================================
--- trunk/flexlay/lib/object_delete_command.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/object_delete_command.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -33,7 +33,7 @@
 
   Command to_command();
 private:
-  SharedPtr<ObjectDeleteCommandImpl> impl;
+  boost::shared_ptr<ObjectDeleteCommandImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/object_layer.hpp
===================================================================
--- trunk/flexlay/lib/object_layer.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/object_layer.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -72,7 +72,7 @@
   Layer to_layer();
 
 private:
-  SharedPtr<ObjectLayerImpl> impl;
+  boost::shared_ptr<ObjectLayerImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/object_move_command.hpp
===================================================================
--- trunk/flexlay/lib/object_move_command.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/object_move_command.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -36,7 +36,7 @@
 
   Command to_command();
 private:
-  SharedPtr<ObjectMoveCommandImpl> impl;
+  boost::shared_ptr<ObjectMoveCommandImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/objmap_control_point.hpp
===================================================================
--- trunk/flexlay/lib/objmap_control_point.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/objmap_control_point.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -18,6 +18,8 @@
 #define HEADER_FLEXLAY_OBJMAP_CONTROL_POINT_HPP
 
 #include <ClanLib/Display/sprite.h>
+#include <boost/shared_ptr.hpp>
+
 #include "meta_data.hpp"
 
 class ObjMapControlPointImpl;
@@ -30,7 +32,7 @@
 {
 private:
 public:
-  ObjMapControlPoint() : impl(0) {}
+  ObjMapControlPoint() : impl() {}
   ObjMapControlPoint(CL_Sprite sprite_, CL_Pointf pos_, MetaData data_);
 
   CL_Pointf get_pos() const;
@@ -43,8 +45,9 @@
   CL_Signal_v1<CL_Pointf>& sig_set_pos();
 
   bool is_null() const { return !impl.get(); }
+
 private:
-  SharedPtr<ObjMapControlPointImpl> impl;
+  boost::shared_ptr<ObjMapControlPointImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/objmap_object.cpp
===================================================================
--- trunk/flexlay/lib/objmap_object.cpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/objmap_object.cpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -20,7 +20,7 @@
 {
 }
 
-ObjMapObject::ObjMapObject(const SharedPtr<ObjMapObjectImpl>& impl_)
+ObjMapObject::ObjMapObject(const boost::shared_ptr<ObjMapObjectImpl>& impl_)
   : impl(impl_)
 {
 }

Modified: trunk/flexlay/lib/objmap_object.hpp
===================================================================
--- trunk/flexlay/lib/objmap_object.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/objmap_object.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -27,7 +27,7 @@
 {
 public:
   ObjMapObject();
-  ObjMapObject(const SharedPtr<ObjMapObjectImpl>& impl_);
+  ObjMapObject(const boost::shared_ptr<ObjMapObjectImpl>& impl_);
   virtual ~ObjMapObject() {}
 
   CL_Pointf get_pos() const;
@@ -51,7 +51,7 @@
   bool operator==(const ObjMapObject& obj) const;
   bool operator<(const ObjMapObject& obj) const;
 private:
-  SharedPtr<ObjMapObjectImpl> impl;
+  boost::shared_ptr<ObjMapObjectImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/objmap_path_node.hpp
===================================================================
--- trunk/flexlay/lib/objmap_path_node.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/objmap_path_node.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -32,7 +32,7 @@
 
   ObjMapObject to_object();
 private:
-  SharedPtr<ObjMapPathNodeImpl> impl;
+  boost::shared_ptr<ObjMapPathNodeImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/objmap_rect_object.cpp
===================================================================
--- trunk/flexlay/lib/objmap_rect_object.cpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/objmap_rect_object.cpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -225,7 +225,7 @@
 ObjMapObject
 ObjMapRectObject::to_object()
 {
-  return ObjMapObject(SharedPtr<ObjMapObjectImpl>(impl));
+  return ObjMapObject(boost::shared_ptr<ObjMapObjectImpl>(impl));
 }
 
 void

Modified: trunk/flexlay/lib/objmap_rect_object.hpp
===================================================================
--- trunk/flexlay/lib/objmap_rect_object.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/objmap_rect_object.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -38,7 +38,7 @@
 
   ObjMapObject to_object();
 private:
-  SharedPtr<ObjMapRectObjectImpl> impl;
+  boost::shared_ptr<ObjMapRectObjectImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/objmap_sprite_object.cpp
===================================================================
--- trunk/flexlay/lib/objmap_sprite_object.cpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/objmap_sprite_object.cpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -119,7 +119,7 @@
 ObjMapObject
 ObjMapSpriteObject::to_object()
 {
-  return ObjMapObject(SharedPtr<ObjMapObjectImpl>(impl));
+  return ObjMapObject(boost::shared_ptr<ObjMapObjectImpl>(impl));
 }
 
 /* EOF */

Modified: trunk/flexlay/lib/objmap_sprite_object.hpp
===================================================================
--- trunk/flexlay/lib/objmap_sprite_object.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/objmap_sprite_object.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -40,7 +40,7 @@
   
   ObjMapObject to_object();
 private:
-  SharedPtr<ObjMapSpriteObjectImpl> impl;
+  boost::shared_ptr<ObjMapSpriteObjectImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/onion_skin_layer.hpp
===================================================================
--- trunk/flexlay/lib/onion_skin_layer.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/onion_skin_layer.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -46,7 +46,7 @@
   bool is_null() const { return !impl.get(); }
   Layer to_layer();
 private:
-  SharedPtr<OnionSkinLayerImpl> impl;  
+  boost::shared_ptr<OnionSkinLayerImpl> impl;  
 };
 
 #endif

Modified: trunk/flexlay/lib/paint_command.hpp
===================================================================
--- trunk/flexlay/lib/paint_command.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/paint_command.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -37,7 +37,7 @@
 
   Command to_command();
 private:
-  SharedPtr<PaintCommandImpl> impl;
+  boost::shared_ptr<PaintCommandImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/panel.hpp
===================================================================
--- trunk/flexlay/lib/panel.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/panel.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -18,7 +18,7 @@
 #define HEADER_FLEXLAY_PANEL_HPP
 
 #include <ClanLib/GUI/component.h>
-#include "shared_ptr.hpp"
+#include <boost/shared_ptr.hpp>
 
 class PanelImpl;
 
@@ -28,7 +28,7 @@
 public:
   Panel(const CL_Rect& rect, CL_Component* parent);
 private:
-  SharedPtr<PanelImpl> impl;
+  boost::shared_ptr<PanelImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/scrollbar.hpp
===================================================================
--- trunk/flexlay/lib/scrollbar.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/scrollbar.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -18,7 +18,7 @@
 #define HEADER_FLEXLAY_SCROLLBAR_HPP
 
 #include <ClanLib/GUI/component.h>
-#include "shared_ptr.hpp"
+#include <boost/shared_ptr.hpp>
 
 class ScrollbarImpl;
 
@@ -38,7 +38,7 @@
   
   CL_Signal_v1<float>& sig_scrollbar_move();
 private:
-  SharedPtr<ScrollbarImpl> impl;
+  boost::shared_ptr<ScrollbarImpl> impl;
 };
 
 #endif

Deleted: trunk/flexlay/lib/shared_ptr.hpp
===================================================================
--- trunk/flexlay/lib/shared_ptr.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/shared_ptr.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -1,48 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_FLEXLAY_SHARED_PTR_HPP
-#define HEADER_FLEXLAY_SHARED_PTR_HPP
-
-#include <assert.h>
-
-/** */
-template<typename T>
-class SharedPtr
-{
-private:
-  T* ptr;
-public:
-  template<typename Parent> friend class SharedPtr;
-
-  SharedPtr() : ptr(0) {}
-  SharedPtr(T* p) : ptr(p) {}
-  
-  template <typename Parent>
-  SharedPtr(const SharedPtr<Parent>& p) : ptr(p.ptr) {}
-
-  T& operator*() { assert(ptr); return *ptr; }
-  T const& operator*() const { assert(ptr); return *ptr; }
-
-  T* operator->() { assert(ptr); return ptr; }
-  T const* operator->() const { assert(ptr); return ptr; }
-
-  T* get() const { return ptr; }
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/flexlay/lib/shared_ptr_comp.hpp
===================================================================
--- trunk/flexlay/lib/shared_ptr_comp.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/shared_ptr_comp.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -1,258 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_FLEXLAY_SHARED_PTR_COMP_HPP
-#define HEADER_FLEXLAY_SHARED_PTR_COMP_HPP
-
-#include <iostream>
-#include <typeinfo>
-
-template<class T>
-class SharedPtrDeleter
-{
-public:
-  T* ptr; 
-
-  SharedPtrDeleter(T* p) : ptr(p) {}
-  virtual ~SharedPtrDeleter() {}
-  
-  virtual void del() =0;
-};
-
-template<class T>
-class SharedPtrDeleterImpl : public SharedPtrDeleter<T>
-{
-public:
-  SharedPtrDeleterImpl(T* p)
-    : SharedPtrDeleter<T>(p) {}
-
-  ~SharedPtrDeleterImpl()
-  {
-  }  
-
-  void del() {
-    //if (ptr)
-    //  delete ptr;
-    ptr = 0;
-  }
-};
-
-template<class T>
-class SharedPtr
-{
-private:
-  SharedPtrDeleter<T>* deleter;
-  int* ref_count;
-
-  void inc() {
-#ifdef DEBUG
-    std::cout << "SharedPtr: inc: " << (ref_count ? *ref_count : -45) << std::endl;
-#endif
-    if (ref_count)
-    {
-      *ref_count += 1;
-    }
-  }
-  
-  void dec() {
-#ifdef DEBUG
-    std::cout << "SharedPtr: dec: " << (ref_count ? *ref_count : -45) << std::endl;
-#endif
-    if (ref_count)
-    {
-      *ref_count -= 1;
-      if (*ref_count == 0) {
-#ifdef DEBUG
-        std::cout << "SharedPtr: deleting: type: "
-                  << typeid(deleter->ptr).name()
-                  << " ptr: " << deleter->ptr
-                  << std::endl;
-#endif
-        deleter->del();
-          
-        delete ref_count; ref_count = 0;
-        delete deleter;   deleter   = 0;
-      }
-    }
-    else
-    {
-#ifdef DEBUG
-      std::cout << "SharedPtr: null delete" << std::endl;
-#endif
-    }
-  }
-public:
-  template<class Base> friend class SharedPtr;
-
-  // Constructors
-  SharedPtr()
-    : deleter(0),
-      ref_count(0)
-  {
-#ifdef DEBUG
-    std::cout << "SharedPtr: ctor null" << std::endl;
-#endif
-  }
-
-  template<typename D>
-  SharedPtr(D* p)
-    : deleter(new SharedPtrDeleterImpl<T>(p)), 
-      ref_count(new int(1))
-  {
-#ifdef DEBUG
-    std::cout << "SharedPtr: ctor: type: "
-              << typeid(deleter->ptr).name()
-              << " ptr: " << deleter->ptr
-              << std::endl;
-#endif
-  }
-  
-  template<class Base>
-  SharedPtr(const SharedPtr<Base>& copy)
-    : deleter(0), ref_count(0)
-  {
-    if (copy.deleter)
-    {
-      deleter   = new SharedPtrDeleterImpl<T>(copy.deleter->ptr);
-      ref_count = copy.ref_count;
-      inc();
-    }
-
-#ifdef DEBUG
-    if (deleter)
-    {
-      std::cout << "SharedPtr: copy-ctor template: type: "
-                << typeid(deleter->ptr).name()
-                << " ptr: " << deleter->ptr
-                << std::endl;
-    }
-    else
-    {
-      std::cout << "SharedPtr: copy-ctor template null" << std::endl;
-    }
-#endif
-  }
-
-  // Assign
-  template<class Base>
-  SharedPtr<T>& operator= (const SharedPtr<Base>& copy) 
-  {
-#ifdef DEBUG
-    std::cout << "SharedPtr<T>& operator= (const SharedPtr<Base>& copy)" << std::endl;
-#endif
-    if (ref_count != copy.ref_count)
-    {
-      dec();
-
-      if (copy.deleter)
-      {
-        deleter   = new SharedPtrDeleterImpl<T>(copy.deleter->ptr);
-        ref_count = copy.ref_count;
-        inc();
-      }
-
-#ifdef DEBUG
-      if (deleter)
-      {
-        std::cout << "SharedPtr: assign template: type: "
-                  << typeid(deleter->ptr).name()
-                  << " ptr: " << deleter->ptr
-                  << std::endl;
-      }
-      else
-      {
-        std::cout << "SharedPtr: assign template: null: " << std::endl;
-      }
-#endif
-    }
-
-    return *this;
-  }
-
-  SharedPtr<T>& operator= (const SharedPtr<T>& copy) 
-  {
-    if (this != &copy)
-    {
-      dec();
-
-      if (copy.deleter)
-      {
-        deleter   = new SharedPtrDeleterImpl<T>(copy.deleter->ptr);
-        ref_count = copy.ref_count;
-        inc();
-      }
-
-#ifdef DEBUG
-      if (deleter)
-      {
-        std::cout << "SharedPtr: assign normal: type: "
-                  << typeid(deleter->ptr).name()
-                  << " ptr: " << deleter->ptr
-                  << std::endl;
-      }
-      else
-      {
-        std::cout << "SharedPtr: assign normal null" << std::endl;
-      }
-#endif
-    }
-    else
-    {
-#ifdef DEBUG
-      if (deleter)
-      {
-        std::cout << "SharedPtr: self assin: type: "
-                  << typeid(deleter->ptr).name()
-                  << " ptr: " << deleter->ptr
-                  << std::endl;
-      }
-      else
-      {
-        std::cout << "SharedPtr: assign normal null" << std::endl;
-      }
-#endif
-    }
-
-    return *this;
-  }
-  
-  ~SharedPtr()
-  {
-    dec();
-  }
-
-  //: Dereferencing operator.
-  T& operator*() { return *deleter->ptr; }
-
-  T const& operator*() const { return *deleter->ptr; }
-        
-  //: Indirect member access operator.
-  T* operator->() { return deleter->ptr; }
-
-  T const* operator->() const { return deleter->ptr; }
-
-  T* get() const 
-  {
-    if (deleter) 
-      return deleter->ptr;
-    else
-      return 0; 
-  }
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/flexlay/lib/sharedptrtest.cpp
===================================================================
--- trunk/flexlay/lib/sharedptrtest.cpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/sharedptrtest.cpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -1,88 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <boost/shared_ptr.hpp>
-
-#define SharedPtr boost::shared_ptr
-
-class B
-{
-public:
-  B() { std::cout << "B(" << this << ")" << std::endl; }
-  virtual ~B() { std::cout << "~B(" << this << ")" << std::endl; }
-
-  virtual void do_something()
-  {
-    std::cout << "B: do_something" << std::endl;
-  }
-};
-
-class A : public B
-{
-public:
-  A() { std::cout << "A(" << this << ")" << std::endl; }
-  virtual ~A() { std::cout << "~A(" << this << ")" << std::endl; }
-  
-  void do_something()
-  {
-    std::cout << "A: do_something" << std::endl;
-  }
-};
-
-class C;
-
-int main()
-{
-  SharedPtr<A> p0_;
-  SharedPtr<A> p1_;
-  SharedPtr<B> p2_(p0_);
-  SharedPtr<B> p3_(p1_);
-
-  SharedPtr<B> p0(new B());
-  {
-    SharedPtr<B> ptr0(new A());
-  }
-  {
-    SharedPtr<A> aptr0(new A());
-    {
-      p0_ = p1_;
-      SharedPtr<B> ptr1(new B());
-      {
-        SharedPtr<B> ptr2 = ptr1;
-        SharedPtr<B> ptr1 = ptr2;
-        ptr1 = aptr0;
-        p0   = aptr0;
-      }
-    }
-  }
-
-  std::cout << "\nInteresting part: " << std::endl;
-  {
-    std::cout << "### SharedPtr<A> p1;" << std::endl;
-    SharedPtr<A> p1;
-    {
-      std::cout << "### SharedPtr<A> p(new A());" << std::endl;
-      SharedPtr<A> p(new A());
-      std::cout << "### p1 = p;" << std::endl;
-      p1 = p;
-    }
-    std::cout << "### p1->do_something()" << std::endl;
-    p1->do_something();
-  }
-}
-
-/* EOF */

Deleted: trunk/flexlay/lib/sharedptrtest.hpp
===================================================================
--- trunk/flexlay/lib/sharedptrtest.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/sharedptrtest.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -1,23 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_FLEXLAY_SHAREDPTRTEST_HPP
-#define HEADER_FLEXLAY_SHAREDPTRTEST_HPP
-
-
-#endif
-
-/* EOF */

Modified: trunk/flexlay/lib/sketch_layer.hpp
===================================================================
--- trunk/flexlay/lib/sketch_layer.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/sketch_layer.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -48,7 +48,7 @@
   Layer to_layer();
 
 private:
-  SharedPtr<SketchLayerImpl> impl;  
+  boost::shared_ptr<SketchLayerImpl> impl;  
 };
 
 #endif

Modified: trunk/flexlay/lib/sprite_brush.hpp
===================================================================
--- trunk/flexlay/lib/sprite_brush.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/sprite_brush.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -28,7 +28,7 @@
 
   Brush to_brush();
 private:
-  SharedPtr<SpriteBrushImpl> impl;
+  boost::shared_ptr<SpriteBrushImpl> impl;
 };
 
 

Modified: trunk/flexlay/lib/sprite_stroke_drawer.cpp
===================================================================
--- trunk/flexlay/lib/sprite_stroke_drawer.cpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/sprite_stroke_drawer.cpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -43,8 +43,7 @@
 
 SpriteStrokeDrawer::SpriteStrokeDrawer(StrokeDrawer drawer)
 {
-  // FIXME: THIS WON'T WORK WITH A REAL SMARTPTR!!!!
-  impl = dynamic_cast<SpriteStrokeDrawerImpl*>(drawer.impl.get());
+  impl = boost::dynamic_pointer_cast<SpriteStrokeDrawerImpl>(drawer.impl);
   assert(impl.get());
 }
 

Modified: trunk/flexlay/lib/sprite_stroke_drawer.hpp
===================================================================
--- trunk/flexlay/lib/sprite_stroke_drawer.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/sprite_stroke_drawer.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -37,7 +37,7 @@
 
   StrokeDrawer to_drawer();
 private:
-  SharedPtr<SpriteStrokeDrawerImpl> impl;
+  boost::shared_ptr<SpriteStrokeDrawerImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/stroke.hpp
===================================================================
--- trunk/flexlay/lib/stroke.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/stroke.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -20,7 +20,7 @@
 #include <vector>
 #include <ClanLib/Core/Math/rect.h>
 #include <ClanLib/Core/System/system.h>
-#include "shared_ptr.hpp"
+#include <boost/shared_ptr.hpp>
 
 class StrokeImpl;
 class StrokeDrawer;
@@ -87,7 +87,7 @@
 
   CL_Rectf get_bounding_rect() const;
 private:
-  SharedPtr<StrokeImpl> impl;
+  boost::shared_ptr<StrokeImpl> impl;
 };
 
 

Modified: trunk/flexlay/lib/stroke_drawer.cpp
===================================================================
--- trunk/flexlay/lib/stroke_drawer.cpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/stroke_drawer.cpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -21,7 +21,7 @@
 {
 }
 
-StrokeDrawer::StrokeDrawer(SharedPtr<StrokeDrawerImpl> impl_)
+StrokeDrawer::StrokeDrawer(boost::shared_ptr<StrokeDrawerImpl> impl_)
   :impl(impl_)
 {
   
@@ -37,7 +37,7 @@
 StrokeDrawer
 StrokeDrawer::clone() const
 {
-  return StrokeDrawer(impl->clone());
+  return StrokeDrawer(boost::shared_ptr<StrokeDrawerImpl>(impl->clone()));
 }
 
 /* EOF */

Modified: trunk/flexlay/lib/stroke_drawer.hpp
===================================================================
--- trunk/flexlay/lib/stroke_drawer.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/stroke_drawer.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -17,7 +17,7 @@
 #ifndef HEADER_FLEXLAY_STROKE_DRAWER_HPP
 #define HEADER_FLEXLAY_STROKE_DRAWER_HPP
 
-#include "shared_ptr.hpp"
+#include <boost/shared_ptr.hpp>
 
 class Stroke;
 class StrokeDrawerImpl;
@@ -30,14 +30,15 @@
 private:
 public:
   StrokeDrawer();
-  StrokeDrawer(SharedPtr<StrokeDrawerImpl> impl);
+  StrokeDrawer(boost::shared_ptr<StrokeDrawerImpl> impl);
   
   void draw(const Stroke& stroke, CL_GraphicContext* gc);
 
   bool is_null() const { return !impl.get(); }
   StrokeDrawer clone() const;
+
 public:
-  SharedPtr<StrokeDrawerImpl> impl;
+  boost::shared_ptr<StrokeDrawerImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/tile.hpp
===================================================================
--- trunk/flexlay/lib/tile.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/tile.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -18,7 +18,7 @@
 #define HEADER_FLEXLAY_TILE_HPP
 
 #include <ClanLib/Display/color.h>
-#include "shared_ptr.hpp"
+#include <boost/shared_ptr.hpp>
 
 class TileImpl;
 class TileProvider;
@@ -61,7 +61,7 @@
   CL_Color calc_color();
 
 private:
-  SharedPtr<TileImpl> impl;
+  boost::shared_ptr<TileImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/tile_provider.hpp
===================================================================
--- trunk/flexlay/lib/tile_provider.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/tile_provider.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -17,7 +17,7 @@
 #ifndef HEADER_FLEXLAY_TILE_PROVIDER_HPP
 #define HEADER_FLEXLAY_TILE_PROVIDER_HPP
 
-#include "shared_ptr.hpp"
+#include <boost/shared_ptr.hpp>
 
 class TileProviderImpl;
 
@@ -33,7 +33,7 @@
 
   operator bool() const { return impl.get(); }
 private:
-  SharedPtr<TileProviderImpl> impl;
+  boost::shared_ptr<TileProviderImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/tile_selection.hpp
===================================================================
--- trunk/flexlay/lib/tile_selection.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/tile_selection.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -44,7 +44,7 @@
 
   TileBrush get_brush(const Field<int>& field) const;
 private:
-  SharedPtr<TileSelectionImpl> impl;
+  boost::shared_ptr<TileSelectionImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/tilemap_layer.cpp
===================================================================
--- trunk/flexlay/lib/tilemap_layer.cpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/tilemap_layer.cpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -63,7 +63,7 @@
 {
 }
 
-/*TilemapLayer::TilemapLayer(const SharedPtr<TilemapLayerImpl>& i)
+/*TilemapLayer::TilemapLayer(const boost::shared_ptr<TilemapLayerImpl>& i)
   : impl(i)
   {
   }*/

Modified: trunk/flexlay/lib/tilemap_layer.hpp
===================================================================
--- trunk/flexlay/lib/tilemap_layer.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/tilemap_layer.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -20,7 +20,7 @@
 #include <ClanLib/Display/pixel_buffer.h>
 #include "field.hpp"
 #include "meta_data.hpp"
-#include "shared_ptr.hpp"
+#include <boost/shared_ptr.hpp>
 #include "layer.hpp"
 
 class Tileset;
@@ -93,7 +93,7 @@
   Layer to_layer();
 
 private:
-  SharedPtr<TilemapLayerImpl> impl;
+  boost::shared_ptr<TilemapLayerImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/tileset.hpp
===================================================================
--- trunk/flexlay/lib/tileset.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/tileset.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -20,6 +20,7 @@
 #include <vector>
 #include <string>
 #include <ClanLib/Core/System/sharedptr.h>
+#include <boost/shared_ptr.hpp>
 
 class Tile;
 class TilesetImpl;
@@ -54,7 +55,7 @@
   std::vector<int> get_tiles() const;
 
 private:
-  CL_SharedPtr<TilesetImpl> impl;
+  boost::shared_ptr<TilesetImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/titlebar.hpp
===================================================================
--- trunk/flexlay/lib/titlebar.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/titlebar.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -18,7 +18,7 @@
 #define HEADER_FLEXLAY_TITLEBAR_HPP
 
 #include <ClanLib/GUI/component.h>
-#include "shared_ptr.hpp"
+#include <boost/shared_ptr.hpp>
 
 class TitlebarImpl;
 
@@ -31,7 +31,7 @@
   Titlebar(const CL_Rect& rect, const std::string& title, CL_Component* parent);
 
 private:
-  SharedPtr<TitlebarImpl> impl;
+  boost::shared_ptr<TitlebarImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/tools/layer_move_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/layer_move_tool.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/tools/layer_move_tool.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -30,7 +30,7 @@
 
   Tool to_tool();
 private:
-  SharedPtr<LayerMoveToolImpl> impl;
+  boost::shared_ptr<LayerMoveToolImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/tools/objmap_select_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/objmap_select_tool.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/tools/objmap_select_tool.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -43,7 +43,7 @@
 
   Tool to_tool();
 private:
-  SharedPtr<ObjMapSelectToolImpl> impl;
+  boost::shared_ptr<ObjMapSelectToolImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/tools/sketch_stroke_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/sketch_stroke_tool.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/tools/sketch_stroke_tool.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -34,7 +34,7 @@
 
   Tool to_tool();
 private:
-  SharedPtr<SketchStrokeToolImpl> impl;
+  boost::shared_ptr<SketchStrokeToolImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/tools/tilemap_paint_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/tilemap_paint_tool.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/tools/tilemap_paint_tool.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -40,7 +40,7 @@
 
   Tool to_tool();
 private:
-  SharedPtr<TileMapPaintToolImpl> impl;
+  boost::shared_ptr<TileMapPaintToolImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/tools/tilemap_select_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/tilemap_select_tool.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/tools/tilemap_select_tool.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -39,7 +39,7 @@
 
   Tool to_tool();
 private:
-  SharedPtr<TileMapSelectToolImpl> impl;
+  boost::shared_ptr<TileMapSelectToolImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/tools/tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/tool.cpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/tools/tool.cpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -22,7 +22,7 @@
 {
 }
 
-Tool::Tool(SharedPtr<ToolImpl> impl_)
+Tool::Tool(boost::shared_ptr<ToolImpl> impl_)
   : impl(impl_)
 {
 }

Modified: trunk/flexlay/lib/tools/tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/tool.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/tools/tool.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -21,7 +21,7 @@
 class EditorMapComponent;
 class CL_InputEvent;
 
-#include "shared_ptr.hpp"
+#include <boost/shared_ptr.hpp>
 
 class ToolImpl;
 
@@ -32,7 +32,7 @@
 
 public:
   Tool();
-  Tool(SharedPtr<ToolImpl> impl_);
+  Tool(boost::shared_ptr<ToolImpl> impl_);
   ~Tool();
 
   void draw();
@@ -42,7 +42,7 @@
   void on_mouse_move(const CL_InputEvent& event);
 
 private:
-  SharedPtr<ToolImpl> impl;
+  boost::shared_ptr<ToolImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/tools/workspace_move_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/workspace_move_tool.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/tools/workspace_move_tool.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -30,7 +30,7 @@
 
   Tool to_tool();
 private:
-  SharedPtr<WorkspaceMoveToolImpl> impl;
+  boost::shared_ptr<WorkspaceMoveToolImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/tools/zoom2_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/zoom2_tool.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/tools/zoom2_tool.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -33,7 +33,7 @@
 
   Tool to_tool();
 private:
-  SharedPtr<Zoom2ToolImpl> impl;
+  boost::shared_ptr<Zoom2ToolImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/tools/zoom_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/zoom_tool.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/tools/zoom_tool.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -33,7 +33,7 @@
 
   Tool to_tool();
 private:
-  SharedPtr<ZoomToolImpl> impl;
+  boost::shared_ptr<ZoomToolImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/viewport.hpp
===================================================================
--- trunk/flexlay/lib/viewport.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/viewport.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -19,7 +19,7 @@
 
 #include <ClanLib/GUI/component.h>
 #include <ClanLib/Core/Math/rect.h>
-#include "shared_ptr.hpp"
+#include <boost/shared_ptr.hpp>
 
 class ViewportImpl;
 
@@ -34,7 +34,7 @@
   void set_pos(const CL_Pointf& pos);
   CL_Pointf get_pos() const;
 private:
-  SharedPtr<ViewportImpl> impl;
+  boost::shared_ptr<ViewportImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/window.hpp
===================================================================
--- trunk/flexlay/lib/window.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/window.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -36,7 +36,7 @@
   Window (const Window&);
   Window& operator= (const Window&);
 
-  SharedPtr<WindowImpl> impl;
+  boost::shared_ptr<WindowImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/lib/workspace.cpp
===================================================================
--- trunk/flexlay/lib/workspace.cpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/workspace.cpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -37,12 +37,12 @@
   Tools tools;
 };
 
-Workspace::Workspace(bool create)
-  : impl(0)
+Workspace::Workspace(bool create) :
+  impl()
 {
   if (create)
   {
-    impl = new WorkspaceImpl();
+    impl.reset(new WorkspaceImpl());
     current_ = *this;
     std::cout << "Workspace()" << std::endl;
   }

Modified: trunk/flexlay/lib/workspace.hpp
===================================================================
--- trunk/flexlay/lib/workspace.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/lib/workspace.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -53,7 +53,7 @@
 
   bool is_null() const { return !impl.get(); }
 private:
-  CL_SharedPtr<WorkspaceImpl> impl;
+  boost::shared_ptr<WorkspaceImpl> impl;
 };
 
 #endif

Modified: trunk/flexlay/netpanzer/netpanzer.hpp
===================================================================
--- trunk/flexlay/netpanzer/netpanzer.hpp	2009-11-22 04:36:12 UTC (rev 723)
+++ trunk/flexlay/netpanzer/netpanzer.hpp	2009-11-22 04:59:25 UTC (rev 724)
@@ -23,9 +23,9 @@
 #include <ClanLib/Display/palette.h>
 #include <ClanLib/Display/surface.h>
 #include <ClanLib/Display/sprite.h>
+
 #include "../lib/tileset.hpp"
 #include "../lib/tilemap_layer.hpp"
-#include "../lib/shared_ptr.hpp"
 
 void load_netpanzer_tileset(Tileset tileset, const char* filename);
 
@@ -119,8 +119,9 @@
   void set_tilemap(TilemapLayer l); 
 
   void save(const std::string& filename);
+
 private:
-  SharedPtr<NetPanzerFileStructImpl> impl;
+  boost::shared_ptr<NetPanzerFileStructImpl> impl;
 };
 
 #endif



From grumbel at mail.berlios.de  Sun Nov 22 06:06:13 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 22 Nov 2009 06:06:13 +0100
Subject: [Flexlay-commit] r725 - in trunk/flexlay: . ruby
Message-ID: <200911220506.nAM56DVb004078@sheep.berlios.de>

Author: grumbel
Date: 2009-11-22 06:06:12 +0100 (Sun, 22 Nov 2009)
New Revision: 725

Modified:
   trunk/flexlay/SConstruct
   trunk/flexlay/ruby/ruby_meta_data.cpp
Log:
Switched from SharedPtr/CL_SharedPtr to boost::shared_ptr<>


Modified: trunk/flexlay/SConstruct
===================================================================
--- trunk/flexlay/SConstruct	2009-11-22 04:59:25 UTC (rev 724)
+++ trunk/flexlay/SConstruct	2009-11-22 05:06:12 UTC (rev 725)
@@ -21,7 +21,7 @@
 
 Export('clanLib_env')
 
-SConscript(['external/clanlib/SConstruct'])
+# SConscript(['external/clanlib/SConstruct'])
 SConscript(['lib/SConscript'])
 SConscript(['ruby/SConscript'])
 SConscript(['netpanzer/SConscript'])

Modified: trunk/flexlay/ruby/ruby_meta_data.cpp
===================================================================
--- trunk/flexlay/ruby/ruby_meta_data.cpp	2009-11-22 04:59:25 UTC (rev 724)
+++ trunk/flexlay/ruby/ruby_meta_data.cpp	2009-11-22 05:06:12 UTC (rev 725)
@@ -16,18 +16,20 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
+#include "ruby_meta_data.hpp"
+
 #include <iostream>
 #include <ClanLib/Signals/signal_v0.h>
+
 #include "ruby_object.hpp"
 #include "meta_data_impl.hpp"
 #include "ruby_functor.hpp"
-#include "ruby_meta_data.hpp"
 
 typedef MetaDataGeneric<RubyObject> RubyMetaData;
 
 MetaData  make_metadata(VALUE obj)
 {
-  return MetaData(SharedPtr<MetaDataImpl>(new RubyMetaData(RubyObject(obj))));
+  return MetaData(boost::shared_ptr<MetaDataImpl>(new RubyMetaData(RubyObject(obj))));
 }
 
 VALUE get_ruby_object(const MetaData& data_obj)



From grumbel at mail.berlios.de  Sun Nov 22 07:18:31 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 22 Nov 2009 07:18:31 +0100
Subject: [Flexlay-commit] r726 - in trunk/flexlay: lib supertux
Message-ID: <200911220618.nAM6IVeZ005449@sheep.berlios.de>

Author: grumbel
Date: 2009-11-22 07:18:27 +0100 (Sun, 22 Nov 2009)
New Revision: 726

Modified:
   trunk/flexlay/lib/helper.cpp
   trunk/flexlay/lib/helper.hpp
   trunk/flexlay/lib/tile_selector.cpp
   trunk/flexlay/supertux/tileset.rb
Log:
Fixed make_region_pixelbuffer_from_resource()


Modified: trunk/flexlay/lib/helper.cpp
===================================================================
--- trunk/flexlay/lib/helper.cpp	2009-11-22 05:06:12 UTC (rev 725)
+++ trunk/flexlay/lib/helper.cpp	2009-11-22 06:18:27 UTC (rev 726)
@@ -18,6 +18,7 @@
 #include <ClanLib/Display/pixel_format.h>
 #include <ClanLib/Display/Providers/provider_factory.h>
 #include <ClanLib/core.h>
+
 #include "blitter.hpp"
 #include "helper.hpp"
 
@@ -67,21 +68,22 @@
 }
 
 CL_PixelBuffer
-make_region_pixelbuffer(const std::string& filename, int x, int y, int w, int h)
+make_region_pixelbuffer_from_resource(const std::string& filename, int x, int y, int w, int h)
 {
-  try {
+  try 
+  {
     CL_PixelBuffer buffer = get_pixelbuffer(filename);
-
-    CL_PixelBuffer target(w, h, w * (buffer.get_format().get_depth()/8), buffer.get_format());
+    CL_PixelBuffer target(w, h, w * 4, CL_PixelFormat::rgba8888);
     clear(target);
     blit_opaque(target, buffer, -x, -y);
 
     return target;
-  } catch (CL_Error& err) {
+  } 
+  catch (CL_Error& err) 
+  {
     std::cout << "CL_Error: " << err.message << std::endl;
     return CL_PixelBuffer();
   }
-
 }
 
 CL_Sprite
@@ -118,7 +120,7 @@
 make_region_pixelbuffer(const CL_PixelBuffer& buffer, int x, int y, int w, int h)
 {
   try {
-    CL_PixelBuffer target(w, h, w * (buffer.get_format().get_depth()/8), buffer.get_format());
+    CL_PixelBuffer target(w, h, w * 4, CL_PixelFormat::rgba8888);
     clear(target);
     blit_opaque(target, buffer, -x, -y);
 

Modified: trunk/flexlay/lib/helper.hpp
===================================================================
--- trunk/flexlay/lib/helper.hpp	2009-11-22 05:06:12 UTC (rev 725)
+++ trunk/flexlay/lib/helper.hpp	2009-11-22 06:18:27 UTC (rev 726)
@@ -22,7 +22,7 @@
 CL_Sprite      pixelbuffer2sprite(const CL_PixelBuffer& buffer);
 CL_Sprite      make_sprite(const std::string& filename);
 CL_PixelBuffer make_pixelbuffer(const std::string& filename);
-CL_PixelBuffer make_region_pixelbuffer(const std::string& filename, int x, int y, int w, int h);
+CL_PixelBuffer make_region_pixelbuffer_from_resource(const std::string& filename, int x, int y, int w, int h);
 CL_PixelBuffer make_region_pixelbuffer(const CL_PixelBuffer& buffer, int x, int y, int w, int h);
 CL_PixelBuffer make_pixelbuffer(int width, int height);
 CL_PixelBuffer scale_pixelbuffer(CL_PixelBuffer buffer);

Modified: trunk/flexlay/lib/tile_selector.cpp
===================================================================
--- trunk/flexlay/lib/tile_selector.cpp	2009-11-22 05:06:12 UTC (rev 725)
+++ trunk/flexlay/lib/tile_selector.cpp	2009-11-22 06:18:27 UTC (rev 726)
@@ -14,18 +14,20 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
+#include "tile_selector.hpp"
+
 #include <iostream>
 #include <ClanLib/display.h>
 #include <ClanLib/core.h>
+
 #include "math.hpp"
 #include "tileset.hpp"
 #include "tile.hpp"
-#include "tile_selector.hpp"
 #include "tools/tilemap_paint_tool.hpp"
 
-TileSelector::TileSelector(const CL_Rect& rect, CL_Component* parent)
-  : CL_Component(rect, parent),
-    width(1)
+TileSelector::TileSelector(const CL_Rect& rect, CL_Component* parent) :
+  CL_Component(rect, parent),
+  width(1)
 {
   index = 0;
 

Modified: trunk/flexlay/supertux/tileset.rb
===================================================================
--- trunk/flexlay/supertux/tileset.rb	2009-11-22 05:06:12 UTC (rev 725)
+++ trunk/flexlay/supertux/tileset.rb	2009-11-22 06:18:27 UTC (rev 726)
@@ -39,8 +39,8 @@
         x = 0
         y = 0
         ids.each{|id|
-          pixelbuffer = make_region_pixelbuffer($datadir + 'images/' + image,
-                                                x * 32, y * 32, 32, 32)
+          pixelbuffer = make_region_pixelbuffer_from_resource($datadir + 'images/' + image,
+                                                              x * 32, y * 32, 32, 32)
           add_tile(id, Tile.new(pixelbuffer))
           x += 1
           if (x == width) then
@@ -63,10 +63,8 @@
           pixelbuffer = make_pixelbuffer($datadir + 'images/' + image)
         elsif image.is_a?(Array) then
           if image[0] == :region then
-            # FIXME: Doesn't work, causes memory corruption
-            # pixelbuffer = make_region_pixelbuffer($datadir + 'images/' + image[1],
-            #                                       image[2], image[3], image[4], image[5])
-            pixelbuffer = nil
+            pixelbuffer = make_region_pixelbuffer_from_resource($datadir + 'images/' + image[1],
+                                                                image[2], image[3], image[4], image[5])
           end
         end
         
@@ -87,7 +85,7 @@
           @tilegroups = []
         end
         @tilegroups.push(TileGroup.new(name, tiles))
-    
+        
       end
 
       counter += 1



From grumbel at mail.berlios.de  Sun Nov 22 07:25:39 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 22 Nov 2009 07:25:39 +0100
Subject: [Flexlay-commit] r727 - trunk/flexlay/lib
Message-ID: <200911220625.nAM6Pds9012485@sheep.berlios.de>

Author: grumbel
Date: 2009-11-22 07:25:37 +0100 (Sun, 22 Nov 2009)
New Revision: 727

Modified:
   trunk/flexlay/lib/blitter.cpp
Log:
Fixed another bug in the blitter code


Modified: trunk/flexlay/lib/blitter.cpp
===================================================================
--- trunk/flexlay/lib/blitter.cpp	2009-11-22 06:18:27 UTC (rev 726)
+++ trunk/flexlay/lib/blitter.cpp	2009-11-22 06:25:37 UTC (rev 727)
@@ -23,6 +23,9 @@
 void 
 blit_opaque(CL_PixelBuffer target, CL_PixelBuffer brush, int x_pos, int y_pos)
 {
+  assert(target.get_format().get_type() == pixelformat_rgba);
+  assert(target.get_format().get_depth() == 32);
+  
   target.lock();
   brush.lock();
 
@@ -59,7 +62,7 @@
       for (int y = start_y; y < end_y; ++y)
         for (int x = start_x; x < end_x; ++x)
         {
-          int target_pos = (y + y_pos) * target_pitch + 3*(x + x_pos);
+          int target_pos = (y + y_pos) * target_pitch + 4*(x + x_pos);
           int brush_pos  = y * brush_pitch + 3*x;
 
           target_buf[target_pos + 0] = 255;



From grumbel at mail.berlios.de  Sun Nov 22 04:02:23 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 22 Nov 2009 04:02:23 +0100
Subject: [Flexlay-commit] r713 - in trunk/flexlay: clanlib/GL clanlib/GL/GLX
	lib lib/tools netpanzer ruby
Message-ID: <200911220302.nAM32NPq021097@sheep.berlios.de>

Author: grumbel
Date: 2009-11-22 04:02:03 +0100 (Sun, 22 Nov 2009)
New Revision: 713

Added:
   trunk/flexlay/lib/bitmap_layer.cpp
   trunk/flexlay/lib/bitmap_layer.hpp
   trunk/flexlay/lib/blitter.cpp
   trunk/flexlay/lib/blitter.hpp
   trunk/flexlay/lib/box.cpp
   trunk/flexlay/lib/box.hpp
   trunk/flexlay/lib/brush.cpp
   trunk/flexlay/lib/brush.hpp
   trunk/flexlay/lib/brush_impl.hpp
   trunk/flexlay/lib/brushmask.cpp
   trunk/flexlay/lib/brushmask.hpp
   trunk/flexlay/lib/colorpicker.cpp
   trunk/flexlay/lib/colorpicker.hpp
   trunk/flexlay/lib/command.cpp
   trunk/flexlay/lib/command.hpp
   trunk/flexlay/lib/command_group.cpp
   trunk/flexlay/lib/command_group.hpp
   trunk/flexlay/lib/command_impl.hpp
   trunk/flexlay/lib/console.cpp
   trunk/flexlay/lib/console.hpp
   trunk/flexlay/lib/directory_view.cpp
   trunk/flexlay/lib/directory_view.hpp
   trunk/flexlay/lib/drawer_properties.cpp
   trunk/flexlay/lib/drawer_properties.hpp
   trunk/flexlay/lib/editor_map.cpp
   trunk/flexlay/lib/editor_map.hpp
   trunk/flexlay/lib/editor_map_component.cpp
   trunk/flexlay/lib/editor_map_component.hpp
   trunk/flexlay/lib/editor_names.hpp
   trunk/flexlay/lib/field.hpp
   trunk/flexlay/lib/flexlay.cpp
   trunk/flexlay/lib/flexlay.hpp
   trunk/flexlay/lib/fonts.cpp
   trunk/flexlay/lib/fonts.hpp
   trunk/flexlay/lib/generated_brush.cpp
   trunk/flexlay/lib/generated_brush.hpp
   trunk/flexlay/lib/globals.cpp
   trunk/flexlay/lib/globals.hpp
   trunk/flexlay/lib/graphic_context_state.cpp
   trunk/flexlay/lib/graphic_context_state.hpp
   trunk/flexlay/lib/gui_manager.cpp
   trunk/flexlay/lib/gui_manager.hpp
   trunk/flexlay/lib/helper.cpp
   trunk/flexlay/lib/helper.hpp
   trunk/flexlay/lib/icon.cpp
   trunk/flexlay/lib/icon.hpp
   trunk/flexlay/lib/layer.cpp
   trunk/flexlay/lib/layer.hpp
   trunk/flexlay/lib/layer_impl.hpp
   trunk/flexlay/lib/lispreader.cpp
   trunk/flexlay/lib/lispreader.hpp
   trunk/flexlay/lib/marker_stroke_drawer.cpp
   trunk/flexlay/lib/marker_stroke_drawer.hpp
   trunk/flexlay/lib/math.hpp
   trunk/flexlay/lib/menu.cpp
   trunk/flexlay/lib/menu.hpp
   trunk/flexlay/lib/menubar.cpp
   trunk/flexlay/lib/menubar.hpp
   trunk/flexlay/lib/meta_data.cpp
   trunk/flexlay/lib/meta_data.hpp
   trunk/flexlay/lib/meta_data_impl.hpp
   trunk/flexlay/lib/minimap.cpp
   trunk/flexlay/lib/minimap.hpp
   trunk/flexlay/lib/object_add_command.cpp
   trunk/flexlay/lib/object_add_command.hpp
   trunk/flexlay/lib/object_brush.cpp
   trunk/flexlay/lib/object_brush.hpp
   trunk/flexlay/lib/object_delete_command.cpp
   trunk/flexlay/lib/object_delete_command.hpp
   trunk/flexlay/lib/object_layer.cpp
   trunk/flexlay/lib/object_layer.hpp
   trunk/flexlay/lib/object_move_command.cpp
   trunk/flexlay/lib/object_move_command.hpp
   trunk/flexlay/lib/object_selector.cpp
   trunk/flexlay/lib/object_selector.hpp
   trunk/flexlay/lib/object_transform_command.cpp
   trunk/flexlay/lib/object_transform_command.hpp
   trunk/flexlay/lib/objmap_control_point.cpp
   trunk/flexlay/lib/objmap_control_point.hpp
   trunk/flexlay/lib/objmap_object.cpp
   trunk/flexlay/lib/objmap_object.hpp
   trunk/flexlay/lib/objmap_object_impl.cpp
   trunk/flexlay/lib/objmap_object_impl.hpp
   trunk/flexlay/lib/objmap_path_node.cpp
   trunk/flexlay/lib/objmap_path_node.hpp
   trunk/flexlay/lib/objmap_rect_object.cpp
   trunk/flexlay/lib/objmap_rect_object.hpp
   trunk/flexlay/lib/objmap_sprite_object.cpp
   trunk/flexlay/lib/objmap_sprite_object.hpp
   trunk/flexlay/lib/onion_skin_layer.cpp
   trunk/flexlay/lib/onion_skin_layer.hpp
   trunk/flexlay/lib/paint_command.cpp
   trunk/flexlay/lib/paint_command.hpp
   trunk/flexlay/lib/paned.cpp
   trunk/flexlay/lib/paned.hpp
   trunk/flexlay/lib/panel.cpp
   trunk/flexlay/lib/panel.hpp
   trunk/flexlay/lib/popup_menu.cpp
   trunk/flexlay/lib/popup_menu.hpp
   trunk/flexlay/lib/scrollbar.cpp
   trunk/flexlay/lib/scrollbar.hpp
   trunk/flexlay/lib/serializer.cpp
   trunk/flexlay/lib/serializer.hpp
   trunk/flexlay/lib/sexpr_serializer.cpp
   trunk/flexlay/lib/sexpr_serializer.hpp
   trunk/flexlay/lib/shared_ptr.hpp
   trunk/flexlay/lib/shared_ptr_comp.hpp
   trunk/flexlay/lib/sharedptrtest.cpp
   trunk/flexlay/lib/sharedptrtest.hpp
   trunk/flexlay/lib/simpleed.cpp
   trunk/flexlay/lib/simpleed.hpp
   trunk/flexlay/lib/sketch_layer.cpp
   trunk/flexlay/lib/sketch_layer.hpp
   trunk/flexlay/lib/slider.cpp
   trunk/flexlay/lib/slider.hpp
   trunk/flexlay/lib/sprite_brush.cpp
   trunk/flexlay/lib/sprite_brush.hpp
   trunk/flexlay/lib/sprite_stroke_drawer.cpp
   trunk/flexlay/lib/sprite_stroke_drawer.hpp
   trunk/flexlay/lib/string_converter.hpp
   trunk/flexlay/lib/stroke.cpp
   trunk/flexlay/lib/stroke.hpp
   trunk/flexlay/lib/stroke_drawer.cpp
   trunk/flexlay/lib/stroke_drawer.hpp
   trunk/flexlay/lib/stroke_drawer_impl.hpp
   trunk/flexlay/lib/tile.cpp
   trunk/flexlay/lib/tile.hpp
   trunk/flexlay/lib/tile_brush.cpp
   trunk/flexlay/lib/tile_brush.hpp
   trunk/flexlay/lib/tile_editor.cpp
   trunk/flexlay/lib/tile_editor.hpp
   trunk/flexlay/lib/tile_provider.cpp
   trunk/flexlay/lib/tile_provider.hpp
   trunk/flexlay/lib/tile_provider_impl.hpp
   trunk/flexlay/lib/tile_selection.cpp
   trunk/flexlay/lib/tile_selection.hpp
   trunk/flexlay/lib/tile_selector.cpp
   trunk/flexlay/lib/tile_selector.hpp
   trunk/flexlay/lib/tilemap_layer.cpp
   trunk/flexlay/lib/tilemap_layer.hpp
   trunk/flexlay/lib/tilemap_minimap.hpp
   trunk/flexlay/lib/tileset.cpp
   trunk/flexlay/lib/tileset.hpp
   trunk/flexlay/lib/titlebar.cpp
   trunk/flexlay/lib/titlebar.hpp
   trunk/flexlay/lib/tools/layer_move_tool.cpp
   trunk/flexlay/lib/tools/layer_move_tool.hpp
   trunk/flexlay/lib/tools/objmap_select_tool.cpp
   trunk/flexlay/lib/tools/objmap_select_tool.hpp
   trunk/flexlay/lib/tools/sketch_stroke_tool.cpp
   trunk/flexlay/lib/tools/sketch_stroke_tool.hpp
   trunk/flexlay/lib/tools/tilemap_paint_tool.cpp
   trunk/flexlay/lib/tools/tilemap_paint_tool.hpp
   trunk/flexlay/lib/tools/tilemap_select_tool.cpp
   trunk/flexlay/lib/tools/tilemap_select_tool.hpp
   trunk/flexlay/lib/tools/tool.cpp
   trunk/flexlay/lib/tools/tool.hpp
   trunk/flexlay/lib/tools/tool_impl.hpp
   trunk/flexlay/lib/tools/workspace_move_tool.cpp
   trunk/flexlay/lib/tools/workspace_move_tool.hpp
   trunk/flexlay/lib/tools/zoom2_tool.cpp
   trunk/flexlay/lib/tools/zoom2_tool.hpp
   trunk/flexlay/lib/tools/zoom_tool.cpp
   trunk/flexlay/lib/tools/zoom_tool.hpp
   trunk/flexlay/lib/viewport.cpp
   trunk/flexlay/lib/viewport.hpp
   trunk/flexlay/lib/window.cpp
   trunk/flexlay/lib/window.hpp
   trunk/flexlay/lib/workspace.cpp
   trunk/flexlay/lib/workspace.hpp
   trunk/flexlay/netpanzer/averagecolor.cpp
   trunk/flexlay/netpanzer/netpanzer.cpp
   trunk/flexlay/netpanzer/netpanzer.hpp
   trunk/flexlay/ruby/flexlay_wrap.hpp
   trunk/flexlay/ruby/ruby_converter.cpp
   trunk/flexlay/ruby/ruby_functor.cpp
   trunk/flexlay/ruby/ruby_functor.hpp
   trunk/flexlay/ruby/ruby_meta_data.cpp
   trunk/flexlay/ruby/ruby_meta_data.hpp
   trunk/flexlay/ruby/ruby_object.cpp
   trunk/flexlay/ruby/ruby_object.hpp
   trunk/flexlay/ruby/ruby_sexpr_parser.cpp
   trunk/flexlay/ruby/ruby_sexpr_parser.hpp
Removed:
   trunk/flexlay/lib/bitmap_layer.cxx
   trunk/flexlay/lib/bitmap_layer.hxx
   trunk/flexlay/lib/blitter.cxx
   trunk/flexlay/lib/blitter.hxx
   trunk/flexlay/lib/box.cxx
   trunk/flexlay/lib/box.hxx
   trunk/flexlay/lib/brush.cxx
   trunk/flexlay/lib/brush.hxx
   trunk/flexlay/lib/brush_impl.hxx
   trunk/flexlay/lib/brushmask.cxx
   trunk/flexlay/lib/brushmask.hxx
   trunk/flexlay/lib/colorpicker.cxx
   trunk/flexlay/lib/colorpicker.hxx
   trunk/flexlay/lib/command.cxx
   trunk/flexlay/lib/command.hxx
   trunk/flexlay/lib/command_group.cxx
   trunk/flexlay/lib/command_group.hxx
   trunk/flexlay/lib/command_impl.hxx
   trunk/flexlay/lib/console.cxx
   trunk/flexlay/lib/console.hxx
   trunk/flexlay/lib/directory_view.cxx
   trunk/flexlay/lib/directory_view.hxx
   trunk/flexlay/lib/drawer_properties.cxx
   trunk/flexlay/lib/drawer_properties.hxx
   trunk/flexlay/lib/editor_map.cxx
   trunk/flexlay/lib/editor_map.hxx
   trunk/flexlay/lib/editor_map_component.cxx
   trunk/flexlay/lib/editor_map_component.hxx
   trunk/flexlay/lib/editor_names.hxx
   trunk/flexlay/lib/field.hxx
   trunk/flexlay/lib/flexlay.cxx
   trunk/flexlay/lib/flexlay.hxx
   trunk/flexlay/lib/fonts.cxx
   trunk/flexlay/lib/fonts.hxx
   trunk/flexlay/lib/generated_brush.cxx
   trunk/flexlay/lib/generated_brush.hxx
   trunk/flexlay/lib/globals.cxx
   trunk/flexlay/lib/globals.hxx
   trunk/flexlay/lib/graphic_context_state.cxx
   trunk/flexlay/lib/graphic_context_state.hxx
   trunk/flexlay/lib/gui_manager.cxx
   trunk/flexlay/lib/gui_manager.hxx
   trunk/flexlay/lib/helper.cxx
   trunk/flexlay/lib/helper.hxx
   trunk/flexlay/lib/icon.cxx
   trunk/flexlay/lib/icon.hxx
   trunk/flexlay/lib/layer.cxx
   trunk/flexlay/lib/layer.hxx
   trunk/flexlay/lib/layer_impl.hxx
   trunk/flexlay/lib/lispreader.cxx
   trunk/flexlay/lib/lispreader.hxx
   trunk/flexlay/lib/marker_stroke_drawer.cxx
   trunk/flexlay/lib/marker_stroke_drawer.hxx
   trunk/flexlay/lib/math.hxx
   trunk/flexlay/lib/menu.cxx
   trunk/flexlay/lib/menu.hxx
   trunk/flexlay/lib/menubar.cxx
   trunk/flexlay/lib/menubar.hxx
   trunk/flexlay/lib/meta_data.cxx
   trunk/flexlay/lib/meta_data.hxx
   trunk/flexlay/lib/meta_data_impl.hxx
   trunk/flexlay/lib/minimap.cxx
   trunk/flexlay/lib/minimap.hxx
   trunk/flexlay/lib/object_add_command.cxx
   trunk/flexlay/lib/object_add_command.hxx
   trunk/flexlay/lib/object_brush.cxx
   trunk/flexlay/lib/object_brush.hxx
   trunk/flexlay/lib/object_delete_command.cxx
   trunk/flexlay/lib/object_delete_command.hxx
   trunk/flexlay/lib/object_layer.cxx
   trunk/flexlay/lib/object_layer.hxx
   trunk/flexlay/lib/object_move_command.cxx
   trunk/flexlay/lib/object_move_command.hxx
   trunk/flexlay/lib/object_selector.cxx
   trunk/flexlay/lib/object_selector.hxx
   trunk/flexlay/lib/object_transform_command.cxx
   trunk/flexlay/lib/object_transform_command.hxx
   trunk/flexlay/lib/objmap_control_point.cxx
   trunk/flexlay/lib/objmap_control_point.hxx
   trunk/flexlay/lib/objmap_object.cxx
   trunk/flexlay/lib/objmap_object.hxx
   trunk/flexlay/lib/objmap_object_impl.cxx
   trunk/flexlay/lib/objmap_object_impl.hxx
   trunk/flexlay/lib/objmap_path_node.cxx
   trunk/flexlay/lib/objmap_path_node.hxx
   trunk/flexlay/lib/objmap_rect_object.cxx
   trunk/flexlay/lib/objmap_rect_object.hxx
   trunk/flexlay/lib/objmap_sprite_object.cxx
   trunk/flexlay/lib/objmap_sprite_object.hxx
   trunk/flexlay/lib/onion_skin_layer.cxx
   trunk/flexlay/lib/onion_skin_layer.hxx
   trunk/flexlay/lib/paint_command.cxx
   trunk/flexlay/lib/paint_command.hxx
   trunk/flexlay/lib/paned.cxx
   trunk/flexlay/lib/paned.hxx
   trunk/flexlay/lib/panel.cxx
   trunk/flexlay/lib/panel.hxx
   trunk/flexlay/lib/popup_menu.cxx
   trunk/flexlay/lib/popup_menu.hxx
   trunk/flexlay/lib/scrollbar.cxx
   trunk/flexlay/lib/scrollbar.hxx
   trunk/flexlay/lib/serializer.cxx
   trunk/flexlay/lib/serializer.hxx
   trunk/flexlay/lib/sexpr_serializer.cxx
   trunk/flexlay/lib/sexpr_serializer.hxx
   trunk/flexlay/lib/shared_ptr.hxx
   trunk/flexlay/lib/shared_ptr_comp.hxx
   trunk/flexlay/lib/sharedptrtest.cxx
   trunk/flexlay/lib/sharedptrtest.hxx
   trunk/flexlay/lib/simpleed.cxx
   trunk/flexlay/lib/simpleed.hxx
   trunk/flexlay/lib/sketch_layer.cxx
   trunk/flexlay/lib/sketch_layer.hxx
   trunk/flexlay/lib/slider.cxx
   trunk/flexlay/lib/slider.hxx
   trunk/flexlay/lib/sprite_brush.cxx
   trunk/flexlay/lib/sprite_brush.hxx
   trunk/flexlay/lib/sprite_stroke_drawer.cxx
   trunk/flexlay/lib/sprite_stroke_drawer.hxx
   trunk/flexlay/lib/string_converter.hxx
   trunk/flexlay/lib/stroke.cxx
   trunk/flexlay/lib/stroke.hxx
   trunk/flexlay/lib/stroke_drawer.cxx
   trunk/flexlay/lib/stroke_drawer.hxx
   trunk/flexlay/lib/stroke_drawer_impl.hxx
   trunk/flexlay/lib/tile.cxx
   trunk/flexlay/lib/tile.hxx
   trunk/flexlay/lib/tile_brush.cxx
   trunk/flexlay/lib/tile_brush.hxx
   trunk/flexlay/lib/tile_editor.cxx
   trunk/flexlay/lib/tile_editor.hxx
   trunk/flexlay/lib/tile_provider.cxx
   trunk/flexlay/lib/tile_provider.hxx
   trunk/flexlay/lib/tile_provider_impl.hxx
   trunk/flexlay/lib/tile_selection.cxx
   trunk/flexlay/lib/tile_selection.hxx
   trunk/flexlay/lib/tile_selector.cxx
   trunk/flexlay/lib/tile_selector.hxx
   trunk/flexlay/lib/tilemap_layer.cxx
   trunk/flexlay/lib/tilemap_layer.hxx
   trunk/flexlay/lib/tilemap_minimap.hxx
   trunk/flexlay/lib/tileset.cxx
   trunk/flexlay/lib/tileset.hxx
   trunk/flexlay/lib/titlebar.cxx
   trunk/flexlay/lib/titlebar.hxx
   trunk/flexlay/lib/tools/layer_move_tool.cxx
   trunk/flexlay/lib/tools/layer_move_tool.hxx
   trunk/flexlay/lib/tools/objmap_select_tool.cxx
   trunk/flexlay/lib/tools/objmap_select_tool.hxx
   trunk/flexlay/lib/tools/sketch_stroke_tool.cxx
   trunk/flexlay/lib/tools/sketch_stroke_tool.hxx
   trunk/flexlay/lib/tools/tilemap_paint_tool.cxx
   trunk/flexlay/lib/tools/tilemap_paint_tool.hxx
   trunk/flexlay/lib/tools/tilemap_select_tool.cxx
   trunk/flexlay/lib/tools/tilemap_select_tool.hxx
   trunk/flexlay/lib/tools/tool.cxx
   trunk/flexlay/lib/tools/tool.hxx
   trunk/flexlay/lib/tools/tool_impl.hxx
   trunk/flexlay/lib/tools/workspace_move_tool.cxx
   trunk/flexlay/lib/tools/workspace_move_tool.hxx
   trunk/flexlay/lib/tools/zoom2_tool.cxx
   trunk/flexlay/lib/tools/zoom2_tool.hxx
   trunk/flexlay/lib/tools/zoom_tool.cxx
   trunk/flexlay/lib/tools/zoom_tool.hxx
   trunk/flexlay/lib/viewport.cxx
   trunk/flexlay/lib/viewport.hxx
   trunk/flexlay/lib/window.cxx
   trunk/flexlay/lib/window.hxx
   trunk/flexlay/lib/workspace.cxx
   trunk/flexlay/lib/workspace.hxx
   trunk/flexlay/netpanzer/averagecolor.cxx
   trunk/flexlay/netpanzer/netpanzer.cxx
   trunk/flexlay/netpanzer/netpanzer.hxx
   trunk/flexlay/ruby/flexlay_wrap.hxx
   trunk/flexlay/ruby/ruby_converter.cxx
   trunk/flexlay/ruby/ruby_functor.cxx
   trunk/flexlay/ruby/ruby_functor.hxx
   trunk/flexlay/ruby/ruby_meta_data.cxx
   trunk/flexlay/ruby/ruby_meta_data.hxx
   trunk/flexlay/ruby/ruby_object.cxx
   trunk/flexlay/ruby/ruby_object.hxx
   trunk/flexlay/ruby/ruby_sexpr_parser.cxx
   trunk/flexlay/ruby/ruby_sexpr_parser.hxx
Modified:
   trunk/flexlay/clanlib/GL/GLX/input_device_linuxevent.cpp
   trunk/flexlay/clanlib/GL/GLX/input_device_xinput.cpp
   trunk/flexlay/clanlib/GL/canvas_opengl.cpp
   trunk/flexlay/lib/SConscript
   trunk/flexlay/lib/flexlay_wrap.i
   trunk/flexlay/netpanzer/SConscript
   trunk/flexlay/netpanzer/netpanzer.i
   trunk/flexlay/ruby/SConscript
Log:
Switched from .?pp to .?pp

Modified: trunk/flexlay/clanlib/GL/GLX/input_device_linuxevent.cpp
===================================================================
--- trunk/flexlay/clanlib/GL/GLX/input_device_linuxevent.cpp	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/clanlib/GL/GLX/input_device_linuxevent.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -34,6 +34,7 @@
 #include <fcntl.h>
 #include <unistd.h>
 #include <iostream>
+#include <stdio.h>
 #include <errno.h>
 
 #include "API/Core/System/error.h"

Modified: trunk/flexlay/clanlib/GL/GLX/input_device_xinput.cpp
===================================================================
--- trunk/flexlay/clanlib/GL/GLX/input_device_xinput.cpp	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/clanlib/GL/GLX/input_device_xinput.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -29,6 +29,7 @@
 
 #include <iostream>
 #include <string.h>
+#include <stdio.h>
 #include "API/Core/System/log.h"
 #include "API/Display/input_device.h"
 #include "API/Display/input_event.h"

Modified: trunk/flexlay/clanlib/GL/canvas_opengl.cpp
===================================================================
--- trunk/flexlay/clanlib/GL/canvas_opengl.cpp	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/clanlib/GL/canvas_opengl.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -28,6 +28,7 @@
 */
 
 #include <string.h>
+#include <stdio.h>
 #include "Display/display_precomp.h"
 #include "canvas_opengl.h"
 #include "API/Core/System/error.h"

Modified: trunk/flexlay/lib/SConscript
===================================================================
--- trunk/flexlay/lib/SConscript	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/SConscript	2009-11-22 03:02:03 UTC (rev 713)
@@ -37,11 +37,11 @@
                   options=opts)
 Help(opts.GenerateHelpText(env))
 
-#env.Program('sharedptrtest', 'sharedptrtest.cxx',
+#env.Program('sharedptrtest', 'sharedptrtest.cpp',
 #            CPPPATH=['/home/ingo/run/ClanLib-0.8-current/include/ClanLib-0.8/'])
 
 # env.Program('simpleed',
-#             ['simpleed.cxx'],
+#             ['simpleed.cpp'],
 #             CPPPATH=['.', 
 #                     '/home/ingo/run/ClanLib-0.8-current//include/ClanLib-0.8/'],
 #            LIBPATH=['.', '/home/ingo/run/ClanLib-0.8-current//lib/'],
@@ -51,80 +51,80 @@
 flexlay_lib = libflexlay_env.StaticLibrary(
     target = 'libflexlay.a',
     source = [
-    'blitter.cxx',
-    'box.cxx',
-    'brush.cxx',
-    'generated_brush.cxx',
-    'brushmask.cxx',
-    'command_group.cxx',
-    'command.cxx',
-    'console.cxx',
-    'colorpicker.cxx',
-    'drawer_properties.cxx',
-    'editor_map.cxx',
-    'editor_map_component.cxx',
-    'flexlay.cxx',
-    'globals.cxx',
-    'layer.cxx',
-    'helper.cxx', 
-    'graphic_context_state.cxx',
-    'gui_manager.cxx',
-    'icon.cxx',
-    'directory_view.cxx',
-    'fonts.cxx',
-    'minimap.cxx',
-    'meta_data.cxx',
-    'onion_skin_layer.cxx',
-    'object_layer.cxx',
-    'object_add_command.cxx',
-    'object_brush.cxx',
-    'object_delete_command.cxx',
-    'object_move_command.cxx',
-    'object_selector.cxx',
-    'object_transform_command.cxx',
-    'objmap_object.cxx',
-    'objmap_path_node.cxx',
-    'objmap_object_impl.cxx',
-    'objmap_sprite_object.cxx',
-    'objmap_control_point.cxx',
-    'objmap_rect_object.cxx',
-    'paint_command.cxx',
-    'panel.cxx',
-    'menu.cxx',
-    'menubar.cxx',
-    'popup_menu.cxx',
-    'lispreader.cxx',
-    'bitmap_layer.cxx',
-    'sketch_layer.cxx',
-    'stroke.cxx',
-    'stroke_drawer.cxx',
-    'sprite_stroke_drawer.cxx',
-    'sprite_brush.cxx',
-    'marker_stroke_drawer.cxx',
-    'slider.cxx', 
-    'scrollbar.cxx',
-    'tile.cxx',
-    'titlebar.cxx',
-    'tile_brush.cxx',
-    'tile_provider.cxx',
-    'tile_editor.cxx',
-    'tile_selection.cxx',
-    'tile_selector.cxx',
-    'tilemap_layer.cxx',
-    'tileset.cxx',
-    'workspace.cxx',
-    'window.cxx',
-    'viewport.cxx',
+    'blitter.cpp',
+    'box.cpp',
+    'brush.cpp',
+    'generated_brush.cpp',
+    'brushmask.cpp',
+    'command_group.cpp',
+    'command.cpp',
+    'console.cpp',
+    'colorpicker.cpp',
+    'drawer_properties.cpp',
+    'editor_map.cpp',
+    'editor_map_component.cpp',
+    'flexlay.cpp',
+    'globals.cpp',
+    'layer.cpp',
+    'helper.cpp', 
+    'graphic_context_state.cpp',
+    'gui_manager.cpp',
+    'icon.cpp',
+    'directory_view.cpp',
+    'fonts.cpp',
+    'minimap.cpp',
+    'meta_data.cpp',
+    'onion_skin_layer.cpp',
+    'object_layer.cpp',
+    'object_add_command.cpp',
+    'object_brush.cpp',
+    'object_delete_command.cpp',
+    'object_move_command.cpp',
+    'object_selector.cpp',
+    'object_transform_command.cpp',
+    'objmap_object.cpp',
+    'objmap_path_node.cpp',
+    'objmap_object_impl.cpp',
+    'objmap_sprite_object.cpp',
+    'objmap_control_point.cpp',
+    'objmap_rect_object.cpp',
+    'paint_command.cpp',
+    'panel.cpp',
+    'menu.cpp',
+    'menubar.cpp',
+    'popup_menu.cpp',
+    'lispreader.cpp',
+    'bitmap_layer.cpp',
+    'sketch_layer.cpp',
+    'stroke.cpp',
+    'stroke_drawer.cpp',
+    'sprite_stroke_drawer.cpp',
+    'sprite_brush.cpp',
+    'marker_stroke_drawer.cpp',
+    'slider.cpp', 
+    'scrollbar.cpp',
+    'tile.cpp',
+    'titlebar.cpp',
+    'tile_brush.cpp',
+    'tile_provider.cpp',
+    'tile_editor.cpp',
+    'tile_selection.cpp',
+    'tile_selector.cpp',
+    'tilemap_layer.cpp',
+    'tileset.cpp',
+    'workspace.cpp',
+    'window.cpp',
+    'viewport.cpp',
 
-    'tools/tool.cxx',
-    'tools/tilemap_paint_tool.cxx',
-    'tools/tilemap_select_tool.cxx',
-    'tools/sketch_stroke_tool.cxx',
-    'tools/objmap_select_tool.cxx',
-    'tools/layer_move_tool.cxx',
-    'tools/workspace_move_tool.cxx',
-    'tools/zoom_tool.cxx',
-    'tools/zoom2_tool.cxx'
+    'tools/tool.cpp',
+    'tools/tilemap_paint_tool.cpp',
+    'tools/tilemap_select_tool.cpp',
+    'tools/sketch_stroke_tool.cpp',
+    'tools/objmap_select_tool.cpp',
+    'tools/layer_move_tool.cpp',
+    'tools/workspace_move_tool.cpp',
+    'tools/zoom_tool.cpp',
+    'tools/zoom2_tool.cpp'
     ],
     CPPPATH = ['.', '..'] + clanLib_env['CPPPATH'],
     CXXFLAGS  = env['CXXFLAGS'] + clanLib_env['CCFLAGS'],

Copied: trunk/flexlay/lib/bitmap_layer.cpp (from rev 712, trunk/flexlay/lib/bitmap_layer.cxx)
===================================================================
--- trunk/flexlay/lib/bitmap_layer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/bitmap_layer.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,198 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include <assert.h>
+#include <ClanLib/gl.h>
+#include <ClanLib/Core/core_iostream.h>
+#include <ClanLib/Core/System/error.h>
+#include <ClanLib/Display/display.h>
+#include <ClanLib/Display/sprite.h>
+#include <ClanLib/Display/pixel_buffer.h>
+#include <ClanLib/Display/canvas.h>
+#include <ClanLib/Display/blend_func.h>
+#include <ClanLib/Display/graphic_context.h>
+#include <ClanLib/Display/display_window.h>
+#include "flexlay.hpp"
+#include "editor_map_component.hpp"
+#include "layer_impl.hpp"
+#include "bitmap_layer.hpp"
+#include "objmap_object_impl.hpp"
+#include "math.hpp"
+
+BitmapLayer* BitmapLayer::current_ = 0;
+
+class BitmapLayerImpl : public ObjMapObjectImpl
+{
+public:
+  typedef std::vector<Stroke> Strokes;
+  /** All strokes done on this image are recorded for possible later
+      playback on a larger size canvas */
+  Strokes strokes;
+
+  /** Used to cache drawings */
+  CL_Surface  surface;
+  CL_Canvas*  canvas;
+  CL_Pointf   last_pos;
+
+  BitmapLayerImpl(CL_Surface surface_)
+    : surface(surface_),
+      canvas(0)
+  {
+    try {
+      canvas = new CL_Canvas(surface);
+      canvas->sync_surface();
+    } catch(CL_Error& err) {
+      std::cout << "CL_Error: " << err.message << std::endl;
+      throw err;
+    }
+  }
+  
+  BitmapLayerImpl(CL_PixelBuffer buffer)
+    : surface(buffer),
+      canvas(0)
+  {
+    try {
+      canvas = new CL_Canvas(surface);
+      canvas->sync_surface();
+    } catch(CL_Error& err) {
+      std::cout << "CL_Error: " << err.message << std::endl;
+      throw err;
+    }
+  }
+
+  BitmapLayerImpl(int width, int height) 
+    : surface(CL_PixelBuffer(width, height, width*4, CL_PixelFormat::rgba8888)),
+      canvas(0)
+  {
+    try {
+      canvas = new CL_Canvas(surface);
+      canvas->get_gc()->clear(CL_Color(0, 0, 0, 0));
+      canvas->get_gc()->flush();
+      canvas->sync_surface();
+    } catch(CL_Error& err) {
+      std::cout << "CL_Error: " << err.message << std::endl;
+      throw err;
+    }
+  }
+
+  ~BitmapLayerImpl() {
+    delete canvas;
+  }
+
+  void draw(CL_GraphicContext* gc)
+  {
+    assert(canvas);
+
+    // Nothing to draw, so we go byebye
+    if (strokes.empty()) 
+      return;
+
+    surface.set_blend_func(blend_one, blend_one_minus_src_alpha);
+    surface.draw(pos.x, pos.y, gc);
+
+    gc->draw_rect(get_bounding_rect(), CL_Color(155, 155, 155, 100));
+  }
+
+  CL_Rectf get_bound_rect() const  
+  {
+    return CL_Rectf(CL_Pointf(ObjMapObjectImpl::pos), CL_Sizef(surface.get_width(), surface.get_height()));
+  }
+
+  CL_Rect get_bounding_rect() { 
+    // FIXME: Do we need to handle its position here or does the Layer keep care of that?
+    return CL_Rect(CL_Point(0, 0),
+                   CL_Size(surface.get_width(), surface.get_height())); 
+  }
+
+  bool has_bounding_rect() const { 
+    return true;
+  }
+};
+
+BitmapLayer::BitmapLayer(CL_Surface surface)
+  : impl(new BitmapLayerImpl(surface))
+{
+  current_ = this;
+}
+
+BitmapLayer::BitmapLayer(int width, int height)
+  : impl(new BitmapLayerImpl(width, height))
+{
+  current_ = this;
+}
+
+BitmapLayer::BitmapLayer(CL_PixelBuffer buffer)
+  : impl(new BitmapLayerImpl(buffer))
+{
+  current_ = this;
+}
+
+void
+BitmapLayer::add_stroke(const Stroke& stroke)
+{
+  if (stroke.get_dab_count() > 0)
+    {
+      impl->strokes.push_back(stroke);
+      stroke.draw(impl->canvas->get_gc());
+      // FIXME: doesn't sync when manually manipulating the canvas
+      impl->canvas->get_gc()->flush();
+      impl->canvas->sync_surface();
+    }
+}
+
+std::vector<Stroke>
+BitmapLayer::get_strokes()
+{
+  return impl->strokes;
+}
+
+CL_Surface
+BitmapLayer::get_background_surface()
+{
+  return impl->surface;
+}
+
+CL_Canvas*
+BitmapLayer::get_canvas() const
+{
+  return impl->canvas;
+}
+
+void
+BitmapLayer::set_pixeldata(CL_PixelBuffer buffer)
+{
+  //impl->canvas->set_pixeldata(buffer);
+  CL_Surface(buffer).draw(0, 0, impl->canvas->get_gc());
+  impl->canvas->get_gc()->flush();
+  impl->canvas->sync_surface();
+}
+
+CL_PixelBuffer
+BitmapLayer::get_pixeldata() const
+{
+  return impl->canvas->get_pixeldata();
+}
+
+ObjMapObject
+BitmapLayer::to_object()
+{
+  return ObjMapObject(impl);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/bitmap_layer.cxx
===================================================================
--- trunk/flexlay/lib/bitmap_layer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/bitmap_layer.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,198 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <assert.h>
-#include <ClanLib/gl.h>
-#include <ClanLib/Core/core_iostream.h>
-#include <ClanLib/Core/System/error.h>
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/sprite.h>
-#include <ClanLib/Display/pixel_buffer.h>
-#include <ClanLib/Display/canvas.h>
-#include <ClanLib/Display/blend_func.h>
-#include <ClanLib/Display/graphic_context.h>
-#include <ClanLib/Display/display_window.h>
-#include "flexlay.hxx"
-#include "editor_map_component.hxx"
-#include "layer_impl.hxx"
-#include "bitmap_layer.hxx"
-#include "objmap_object_impl.hxx"
-#include "math.hxx"
-
-BitmapLayer* BitmapLayer::current_ = 0;
-
-class BitmapLayerImpl : public ObjMapObjectImpl
-{
-public:
-  typedef std::vector<Stroke> Strokes;
-  /** All strokes done on this image are recorded for possible later
-      playback on a larger size canvas */
-  Strokes strokes;
-
-  /** Used to cache drawings */
-  CL_Surface  surface;
-  CL_Canvas*  canvas;
-  CL_Pointf   last_pos;
-
-  BitmapLayerImpl(CL_Surface surface_)
-    : surface(surface_),
-      canvas(0)
-  {
-    try {
-      canvas = new CL_Canvas(surface);
-      canvas->sync_surface();
-    } catch(CL_Error& err) {
-      std::cout << "CL_Error: " << err.message << std::endl;
-      throw err;
-    }
-  }
-  
-  BitmapLayerImpl(CL_PixelBuffer buffer)
-    : surface(buffer),
-      canvas(0)
-  {
-    try {
-      canvas = new CL_Canvas(surface);
-      canvas->sync_surface();
-    } catch(CL_Error& err) {
-      std::cout << "CL_Error: " << err.message << std::endl;
-      throw err;
-    }
-  }
-
-  BitmapLayerImpl(int width, int height) 
-    : surface(CL_PixelBuffer(width, height, width*4, CL_PixelFormat::rgba8888)),
-      canvas(0)
-  {
-    try {
-      canvas = new CL_Canvas(surface);
-      canvas->get_gc()->clear(CL_Color(0, 0, 0, 0));
-      canvas->get_gc()->flush();
-      canvas->sync_surface();
-    } catch(CL_Error& err) {
-      std::cout << "CL_Error: " << err.message << std::endl;
-      throw err;
-    }
-  }
-
-  ~BitmapLayerImpl() {
-    delete canvas;
-  }
-
-  void draw(CL_GraphicContext* gc)
-  {
-    assert(canvas);
-
-    // Nothing to draw, so we go byebye
-    if (strokes.empty()) 
-      return;
-
-    surface.set_blend_func(blend_one, blend_one_minus_src_alpha);
-    surface.draw(pos.x, pos.y, gc);
-
-    gc->draw_rect(get_bounding_rect(), CL_Color(155, 155, 155, 100));
-  }
-
-  CL_Rectf get_bound_rect() const  
-  {
-    return CL_Rectf(CL_Pointf(ObjMapObjectImpl::pos), CL_Sizef(surface.get_width(), surface.get_height()));
-  }
-
-  CL_Rect get_bounding_rect() { 
-    // FIXME: Do we need to handle its position here or does the Layer keep care of that?
-    return CL_Rect(CL_Point(0, 0),
-                   CL_Size(surface.get_width(), surface.get_height())); 
-  }
-
-  bool has_bounding_rect() const { 
-    return true;
-  }
-};
-
-BitmapLayer::BitmapLayer(CL_Surface surface)
-  : impl(new BitmapLayerImpl(surface))
-{
-  current_ = this;
-}
-
-BitmapLayer::BitmapLayer(int width, int height)
-  : impl(new BitmapLayerImpl(width, height))
-{
-  current_ = this;
-}
-
-BitmapLayer::BitmapLayer(CL_PixelBuffer buffer)
-  : impl(new BitmapLayerImpl(buffer))
-{
-  current_ = this;
-}
-
-void
-BitmapLayer::add_stroke(const Stroke& stroke)
-{
-  if (stroke.get_dab_count() > 0)
-    {
-      impl->strokes.push_back(stroke);
-      stroke.draw(impl->canvas->get_gc());
-      // FIXME: doesn't sync when manually manipulating the canvas
-      impl->canvas->get_gc()->flush();
-      impl->canvas->sync_surface();
-    }
-}
-
-std::vector<Stroke>
-BitmapLayer::get_strokes()
-{
-  return impl->strokes;
-}
-
-CL_Surface
-BitmapLayer::get_background_surface()
-{
-  return impl->surface;
-}
-
-CL_Canvas*
-BitmapLayer::get_canvas() const
-{
-  return impl->canvas;
-}
-
-void
-BitmapLayer::set_pixeldata(CL_PixelBuffer buffer)
-{
-  //impl->canvas->set_pixeldata(buffer);
-  CL_Surface(buffer).draw(0, 0, impl->canvas->get_gc());
-  impl->canvas->get_gc()->flush();
-  impl->canvas->sync_surface();
-}
-
-CL_PixelBuffer
-BitmapLayer::get_pixeldata() const
-{
-  return impl->canvas->get_pixeldata();
-}
-
-ObjMapObject
-BitmapLayer::to_object()
-{
-  return ObjMapObject(impl);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/bitmap_layer.hpp (from rev 712, trunk/flexlay/lib/bitmap_layer.hxx)
===================================================================
--- trunk/flexlay/lib/bitmap_layer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/bitmap_layer.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,67 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_BITMAP_LAYER_HXX
+#define HEADER_BITMAP_LAYER_HXX
+
+#include <vector>
+#include <ClanLib/Core/Math/point.h>
+#include <ClanLib/Display/color.h>
+#include "objmap_object.hpp"
+#include "layer.hpp"
+#include "stroke.hpp"
+
+class BitmapLayerImpl;
+
+/** This layer holds a simple bitmap, size and color format are
+    configurable, it works similar to the SketchLayer, however it
+    doesn't rerender the image all the time, but simply holds it in a
+    CL_Canvas making it a whole lot faster. */
+class BitmapLayer
+{
+  friend class BitmapLayerImpl;
+private:
+  static BitmapLayer* current_;
+public:
+  static BitmapLayer* current() { return current_; }
+  static void set_current(BitmapLayer* c) { current_ = c; }
+
+  BitmapLayer(CL_Surface surface);
+  BitmapLayer(CL_PixelBuffer buffer);
+  BitmapLayer(int width, int height);
+  
+  void add_stroke(const Stroke&);
+
+  std::vector<Stroke> get_strokes();
+
+  CL_Surface get_background_surface();
+
+  void set_pixeldata(CL_PixelBuffer buffer);
+  CL_PixelBuffer get_pixeldata() const;
+  CL_Canvas*     get_canvas() const;
+  
+  bool is_null() const { return !impl.get(); }
+  ObjMapObject to_object();
+
+private:
+  SharedPtr<BitmapLayerImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/bitmap_layer.hxx
===================================================================
--- trunk/flexlay/lib/bitmap_layer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/bitmap_layer.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,67 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_BITMAP_LAYER_HXX
-#define HEADER_BITMAP_LAYER_HXX
-
-#include <vector>
-#include <ClanLib/Core/Math/point.h>
-#include <ClanLib/Display/color.h>
-#include "objmap_object.hxx"
-#include "layer.hxx"
-#include "stroke.hxx"
-
-class BitmapLayerImpl;
-
-/** This layer holds a simple bitmap, size and color format are
-    configurable, it works similar to the SketchLayer, however it
-    doesn't rerender the image all the time, but simply holds it in a
-    CL_Canvas making it a whole lot faster. */
-class BitmapLayer
-{
-  friend class BitmapLayerImpl;
-private:
-  static BitmapLayer* current_;
-public:
-  static BitmapLayer* current() { return current_; }
-  static void set_current(BitmapLayer* c) { current_ = c; }
-
-  BitmapLayer(CL_Surface surface);
-  BitmapLayer(CL_PixelBuffer buffer);
-  BitmapLayer(int width, int height);
-  
-  void add_stroke(const Stroke&);
-
-  std::vector<Stroke> get_strokes();
-
-  CL_Surface get_background_surface();
-
-  void set_pixeldata(CL_PixelBuffer buffer);
-  CL_PixelBuffer get_pixeldata() const;
-  CL_Canvas*     get_canvas() const;
-  
-  bool is_null() const { return !impl.get(); }
-  ObjMapObject to_object();
-
-private:
-  SharedPtr<BitmapLayerImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/blitter.cpp (from rev 712, trunk/flexlay/lib/blitter.cxx)
===================================================================
--- trunk/flexlay/lib/blitter.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/blitter.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,207 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <assert.h>
+#include <iostream>
+#include <algorithm>
+#include <ClanLib/Display/pixel_format.h>
+#include <ClanLib/Display/palette.h>
+#include "blitter.hpp"
+
+void 
+blit_opaque(CL_PixelBuffer target, CL_PixelBuffer brush, int x_pos, int y_pos)
+{
+  target.lock();
+  brush.lock();
+
+  int start_x = std::max(0, -x_pos);
+  int start_y = std::max(0, -y_pos);
+  
+  int end_x = std::min(brush.get_width(),  target.get_width()  - x_pos);
+  int end_y = std::min(brush.get_height(), target.get_height() - y_pos);
+
+  unsigned char* target_buf = static_cast<unsigned char*>(target.get_data());
+  unsigned char* brush_buf  = static_cast<unsigned char*>(brush.get_data());
+
+  int target_pitch = target.get_pitch();
+  int brush_pitch  = brush.get_pitch();
+
+  if (brush.get_format().get_type() == pixelformat_rgba)
+    {
+      if (brush.get_format().get_depth() == 32)
+        {
+          for (int y = start_y; y < end_y; ++y)
+            for (int x = start_x; x < end_x; ++x)
+              {
+                int target_pos = (y + y_pos) * target_pitch + 4*(x + x_pos);
+                int brush_pos  = y * brush_pitch + x*4;
+
+                target_buf[target_pos + 0] = brush_buf[brush_pos + 0];
+                target_buf[target_pos + 1] = brush_buf[brush_pos + 1];
+                target_buf[target_pos + 2] = brush_buf[brush_pos + 2];
+                target_buf[target_pos + 3] = brush_buf[brush_pos + 3];
+              } 
+        }
+      else if (brush.get_format().get_depth() == 24)
+        {
+          for (int y = start_y; y < end_y; ++y)
+            for (int x = start_x; x < end_x; ++x)
+              {
+                int target_pos = (y + y_pos) * target_pitch + 3*(x + x_pos);
+                int brush_pos  = y * brush_pitch + 3*x;
+
+                target_buf[target_pos + 0] = 255;
+                target_buf[target_pos + 1] = brush_buf[brush_pos + 0];
+                target_buf[target_pos + 2] = brush_buf[brush_pos + 1];
+                target_buf[target_pos + 3] = brush_buf[brush_pos + 2];
+              }
+        }
+      else
+        {
+          std::cout << "Unsupported bpp: " << brush.get_format().get_depth() << std::endl;
+        }
+    }
+  else if (brush.get_format().get_type() == pixelformat_index)
+    {
+      CL_Palette palette = brush.get_palette();
+      for (int y = start_y; y < end_y; ++y)
+        for (int x = start_x; x < end_x; ++x)
+          {
+            int target_pos = (y + y_pos) * target_pitch + 4*(x + x_pos);
+            int brush_pos  = y * brush_pitch + x;
+            
+            target_buf[target_pos + 0] = 255;
+            target_buf[target_pos + 1] = palette.colors[brush_buf[brush_pos]].get_blue();
+            target_buf[target_pos + 2] = palette.colors[brush_buf[brush_pos]].get_green();
+            target_buf[target_pos + 3] = palette.colors[brush_buf[brush_pos]].get_red();
+          }
+    }
+  else
+    {
+      assert(!"Unknown pixelformat type");
+    }
+    
+
+
+  brush.unlock();
+  target.unlock();
+}
+
+void 
+blit(CL_PixelBuffer target, CL_PixelBuffer brush, int x_pos, int y_pos)
+{
+  target.lock();
+  brush.lock();
+
+  int start_x = std::max(0, -x_pos);
+  int start_y = std::max(0, -y_pos);
+  
+  int end_x = std::min(brush.get_width(),  target.get_width()  - x_pos);
+  int end_y = std::min(brush.get_height(), target.get_height() - y_pos);
+
+  unsigned char* target_buf = static_cast<unsigned char*>(target.get_data());
+  unsigned char* brush_buf  = static_cast<unsigned char*>(brush.get_data());
+
+  // FIXME: This doesn't take pitch into account
+  int target_width = target.get_width();
+  int brush_width  = brush.get_width();
+
+  if (brush.get_format().get_type() == pixelformat_rgba)
+    {
+      if (brush.get_format().get_depth() == 32)
+        {
+          for (int y = start_y; y < end_y; ++y)
+            for (int x = start_x; x < end_x; ++x)
+              {
+                int target_pos = (y + y_pos) * target_width + x + x_pos;
+                int brush_pos  = y * brush_width + x;
+
+                unsigned char a  = brush_buf[4*brush_pos + 0];
+                unsigned char r  = brush_buf[4*brush_pos + 1];
+                unsigned char g  = brush_buf[4*brush_pos + 2];
+                unsigned char b  = brush_buf[4*brush_pos + 3];
+
+                unsigned char ta = target_buf[4*target_pos + 0];
+                unsigned char tr = target_buf[4*target_pos + 1];
+                unsigned char tg = target_buf[4*target_pos + 2];
+                unsigned char tb = target_buf[4*target_pos + 3];
+
+                float alpha  = a/255.0f;
+        
+                target_buf[4*target_pos + 0] = std::min(255, ta + a);
+                target_buf[4*target_pos + 1] = std::min(255, int((1-alpha)*tr + alpha*r));
+                target_buf[4*target_pos + 2] = std::min(255, int((1-alpha)*tg + alpha*g));
+                target_buf[4*target_pos + 3] = std::min(255, int((1-alpha)*tb + alpha*b));
+              }
+        }
+      else if (brush.get_format().get_depth() == 24)
+        {
+          for (int y = start_y; y < end_y; ++y)
+            for (int x = start_x; x < end_x; ++x)
+              {
+                int target_pos = (y + y_pos) * target_width + x + x_pos;
+                int brush_pos  = y * brush_width + x;
+
+                target_buf[4*target_pos + 0] = 255;
+                target_buf[4*target_pos + 1] = brush_buf[3*brush_pos + 0];
+                target_buf[4*target_pos + 2] = brush_buf[3*brush_pos + 1];
+                target_buf[4*target_pos + 3] = brush_buf[3*brush_pos + 2];
+              }
+        }
+      else
+        {
+          std::cout << "Unsupported bpp: " << brush.get_format().get_depth() << std::endl;
+        }
+    }
+  else if (brush.get_format().get_type() == pixelformat_index)
+    {
+      CL_Palette palette = brush.get_palette();
+      for (int y = start_y; y < end_y; ++y)
+        for (int x = start_x; x < end_x; ++x)
+          {
+            int target_pos = (y + y_pos) * target_width + x + x_pos;
+            int brush_pos  = y * brush_width + x;
+            
+            target_buf[4*target_pos + 0] = 255;
+            target_buf[4*target_pos + 1] = palette.colors[brush_buf[brush_pos]].get_blue();
+            target_buf[4*target_pos + 2] = palette.colors[brush_buf[brush_pos]].get_green();
+            target_buf[4*target_pos + 3] = palette.colors[brush_buf[brush_pos]].get_red();
+          }
+    }
+  else
+    {
+      assert(!"Unknown pixelformat type");
+    }
+    
+
+
+  brush.unlock();
+  target.unlock();
+}
+
+void clear(CL_PixelBuffer canvas)
+{
+  unsigned char* buffer;
+
+  canvas.lock();
+  buffer = static_cast<unsigned char*>(canvas.get_data());
+  memset(buffer, 0, sizeof(unsigned char) * canvas.get_pitch() * canvas.get_height());
+  canvas.unlock();
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/blitter.cxx
===================================================================
--- trunk/flexlay/lib/blitter.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/blitter.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,207 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <assert.h>
-#include <iostream>
-#include <algorithm>
-#include <ClanLib/Display/pixel_format.h>
-#include <ClanLib/Display/palette.h>
-#include "blitter.hxx"
-
-void 
-blit_opaque(CL_PixelBuffer target, CL_PixelBuffer brush, int x_pos, int y_pos)
-{
-  target.lock();
-  brush.lock();
-
-  int start_x = std::max(0, -x_pos);
-  int start_y = std::max(0, -y_pos);
-  
-  int end_x = std::min(brush.get_width(),  target.get_width()  - x_pos);
-  int end_y = std::min(brush.get_height(), target.get_height() - y_pos);
-
-  unsigned char* target_buf = static_cast<unsigned char*>(target.get_data());
-  unsigned char* brush_buf  = static_cast<unsigned char*>(brush.get_data());
-
-  int target_pitch = target.get_pitch();
-  int brush_pitch  = brush.get_pitch();
-
-  if (brush.get_format().get_type() == pixelformat_rgba)
-    {
-      if (brush.get_format().get_depth() == 32)
-        {
-          for (int y = start_y; y < end_y; ++y)
-            for (int x = start_x; x < end_x; ++x)
-              {
-                int target_pos = (y + y_pos) * target_pitch + 4*(x + x_pos);
-                int brush_pos  = y * brush_pitch + x*4;
-
-                target_buf[target_pos + 0] = brush_buf[brush_pos + 0];
-                target_buf[target_pos + 1] = brush_buf[brush_pos + 1];
-                target_buf[target_pos + 2] = brush_buf[brush_pos + 2];
-                target_buf[target_pos + 3] = brush_buf[brush_pos + 3];
-              } 
-        }
-      else if (brush.get_format().get_depth() == 24)
-        {
-          for (int y = start_y; y < end_y; ++y)
-            for (int x = start_x; x < end_x; ++x)
-              {
-                int target_pos = (y + y_pos) * target_pitch + 3*(x + x_pos);
-                int brush_pos  = y * brush_pitch + 3*x;
-
-                target_buf[target_pos + 0] = 255;
-                target_buf[target_pos + 1] = brush_buf[brush_pos + 0];
-                target_buf[target_pos + 2] = brush_buf[brush_pos + 1];
-                target_buf[target_pos + 3] = brush_buf[brush_pos + 2];
-              }
-        }
-      else
-        {
-          std::cout << "Unsupported bpp: " << brush.get_format().get_depth() << std::endl;
-        }
-    }
-  else if (brush.get_format().get_type() == pixelformat_index)
-    {
-      CL_Palette palette = brush.get_palette();
-      for (int y = start_y; y < end_y; ++y)
-        for (int x = start_x; x < end_x; ++x)
-          {
-            int target_pos = (y + y_pos) * target_pitch + 4*(x + x_pos);
-            int brush_pos  = y * brush_pitch + x;
-            
-            target_buf[target_pos + 0] = 255;
-            target_buf[target_pos + 1] = palette.colors[brush_buf[brush_pos]].get_blue();
-            target_buf[target_pos + 2] = palette.colors[brush_buf[brush_pos]].get_green();
-            target_buf[target_pos + 3] = palette.colors[brush_buf[brush_pos]].get_red();
-          }
-    }
-  else
-    {
-      assert(!"Unknown pixelformat type");
-    }
-    
-
-
-  brush.unlock();
-  target.unlock();
-}
-
-void 
-blit(CL_PixelBuffer target, CL_PixelBuffer brush, int x_pos, int y_pos)
-{
-  target.lock();
-  brush.lock();
-
-  int start_x = std::max(0, -x_pos);
-  int start_y = std::max(0, -y_pos);
-  
-  int end_x = std::min(brush.get_width(),  target.get_width()  - x_pos);
-  int end_y = std::min(brush.get_height(), target.get_height() - y_pos);
-
-  unsigned char* target_buf = static_cast<unsigned char*>(target.get_data());
-  unsigned char* brush_buf  = static_cast<unsigned char*>(brush.get_data());
-
-  // FIXME: This doesn't take pitch into account
-  int target_width = target.get_width();
-  int brush_width  = brush.get_width();
-
-  if (brush.get_format().get_type() == pixelformat_rgba)
-    {
-      if (brush.get_format().get_depth() == 32)
-        {
-          for (int y = start_y; y < end_y; ++y)
-            for (int x = start_x; x < end_x; ++x)
-              {
-                int target_pos = (y + y_pos) * target_width + x + x_pos;
-                int brush_pos  = y * brush_width + x;
-
-                unsigned char a  = brush_buf[4*brush_pos + 0];
-                unsigned char r  = brush_buf[4*brush_pos + 1];
-                unsigned char g  = brush_buf[4*brush_pos + 2];
-                unsigned char b  = brush_buf[4*brush_pos + 3];
-
-                unsigned char ta = target_buf[4*target_pos + 0];
-                unsigned char tr = target_buf[4*target_pos + 1];
-                unsigned char tg = target_buf[4*target_pos + 2];
-                unsigned char tb = target_buf[4*target_pos + 3];
-
-                float alpha  = a/255.0f;
-        
-                target_buf[4*target_pos + 0] = std::min(255, ta + a);
-                target_buf[4*target_pos + 1] = std::min(255, int((1-alpha)*tr + alpha*r));
-                target_buf[4*target_pos + 2] = std::min(255, int((1-alpha)*tg + alpha*g));
-                target_buf[4*target_pos + 3] = std::min(255, int((1-alpha)*tb + alpha*b));
-              }
-        }
-      else if (brush.get_format().get_depth() == 24)
-        {
-          for (int y = start_y; y < end_y; ++y)
-            for (int x = start_x; x < end_x; ++x)
-              {
-                int target_pos = (y + y_pos) * target_width + x + x_pos;
-                int brush_pos  = y * brush_width + x;
-
-                target_buf[4*target_pos + 0] = 255;
-                target_buf[4*target_pos + 1] = brush_buf[3*brush_pos + 0];
-                target_buf[4*target_pos + 2] = brush_buf[3*brush_pos + 1];
-                target_buf[4*target_pos + 3] = brush_buf[3*brush_pos + 2];
-              }
-        }
-      else
-        {
-          std::cout << "Unsupported bpp: " << brush.get_format().get_depth() << std::endl;
-        }
-    }
-  else if (brush.get_format().get_type() == pixelformat_index)
-    {
-      CL_Palette palette = brush.get_palette();
-      for (int y = start_y; y < end_y; ++y)
-        for (int x = start_x; x < end_x; ++x)
-          {
-            int target_pos = (y + y_pos) * target_width + x + x_pos;
-            int brush_pos  = y * brush_width + x;
-            
-            target_buf[4*target_pos + 0] = 255;
-            target_buf[4*target_pos + 1] = palette.colors[brush_buf[brush_pos]].get_blue();
-            target_buf[4*target_pos + 2] = palette.colors[brush_buf[brush_pos]].get_green();
-            target_buf[4*target_pos + 3] = palette.colors[brush_buf[brush_pos]].get_red();
-          }
-    }
-  else
-    {
-      assert(!"Unknown pixelformat type");
-    }
-    
-
-
-  brush.unlock();
-  target.unlock();
-}
-
-void clear(CL_PixelBuffer canvas)
-{
-  unsigned char* buffer;
-
-  canvas.lock();
-  buffer = static_cast<unsigned char*>(canvas.get_data());
-  memset(buffer, 0, sizeof(unsigned char) * canvas.get_pitch() * canvas.get_height());
-  canvas.unlock();
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/blitter.hpp (from rev 712, trunk/flexlay/lib/blitter.hxx)

Deleted: trunk/flexlay/lib/blitter.hxx
===================================================================
--- trunk/flexlay/lib/blitter.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/blitter.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,30 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_BLITTER_HXX
-#define HEADER_BLITTER_HXX
-
-#include <ClanLib/Display/pixel_buffer.h>
-
-void blit(CL_PixelBuffer target, CL_PixelBuffer brush, int x_pos, int y_pos);
-void blit_opaque(CL_PixelBuffer target, CL_PixelBuffer brush, int x_pos, int y_pos);
-void clear(CL_PixelBuffer target);
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/box.cpp (from rev 712, trunk/flexlay/lib/box.cxx)
===================================================================
--- trunk/flexlay/lib/box.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/box.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,104 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <ClanLib/Display/color.h>
+#include <ClanLib/Display/display.h>
+#include "box.hpp"
+
+CL_Color background   (210, 210, 210);
+CL_Color background_hl(240, 240, 240);
+CL_Color background_sw(200, 200, 200);
+CL_Color highlight    (255, 255, 255);
+CL_Color midtone      (150, 150, 150);
+CL_Color shadow       (100, 100, 100);
+
+void
+Box::draw_button_up(const CL_Rect& rect)
+{
+  CL_Display::fill_rect(rect, background_hl);
+  CL_Display::draw_line(rect.left, rect.top, 
+                        rect.right, rect.top, highlight);
+  CL_Display::draw_line(rect.left, rect.top, 
+                        rect.left, rect.bottom, highlight);
+
+  CL_Display::draw_line(rect.left, rect.bottom, 
+                        rect.right, rect.bottom, shadow);
+  CL_Display::draw_line(rect.right, rect.top, 
+                        rect.right, rect.bottom, shadow);
+}
+
+void
+Box::draw_button_down(const CL_Rect& rect)
+{
+  CL_Display::fill_rect(rect, background_sw);
+
+  CL_Display::draw_line(rect.left, rect.bottom, 
+                        rect.right, rect.bottom, highlight);
+  CL_Display::draw_line(rect.right, rect.top, 
+                        rect.right, rect.bottom, highlight);
+
+  CL_Display::draw_line(rect.left, rect.top, 
+                        rect.right, rect.top, shadow);
+  CL_Display::draw_line(rect.left, rect.top, 
+                        rect.left, rect.bottom, shadow);
+}
+
+void
+Box::draw_button_neutral(const CL_Rect& rect)
+{
+  CL_Display::fill_rect(rect, background);
+}
+
+void
+Box::draw_panel(const CL_Rect& rect)
+{
+  CL_Display::fill_rect(rect, background);
+  CL_Display::draw_line(rect.left, rect.top, 
+                        rect.right, rect.top, highlight);
+  CL_Display::draw_line(rect.left, rect.top, 
+                        rect.left, rect.bottom, highlight);
+
+  CL_Display::draw_line(rect.left, rect.bottom, 
+                        rect.right, rect.bottom, shadow);
+  CL_Display::draw_line(rect.right, rect.top, 
+                        rect.right, rect.bottom, shadow);
+}
+
+void
+Box::draw_panel_down(const CL_Rect& rect)
+{
+  CL_Display::fill_rect(rect, background);
+  CL_Display::draw_line(rect.left, rect.top, 
+                        rect.right, rect.top, shadow);
+  CL_Display::draw_line(rect.left, rect.top, 
+                        rect.left, rect.bottom, shadow);
+
+  CL_Display::draw_line(rect.left, rect.bottom, 
+                        rect.right, rect.bottom, highlight);
+  CL_Display::draw_line(rect.right, rect.top, 
+                        rect.right, rect.bottom, highlight);
+}
+
+void
+Box::draw_window(const CL_Rect& rect)
+{
+  draw_panel(CL_Rect(rect.left+1, rect.top+1, rect.right-2, rect.bottom-2));
+  CL_Display::draw_rect(rect, CL_Color(0, 0, 0));
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/box.cxx
===================================================================
--- trunk/flexlay/lib/box.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/box.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,104 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <ClanLib/Display/color.h>
-#include <ClanLib/Display/display.h>
-#include "box.hxx"
-
-CL_Color background   (210, 210, 210);
-CL_Color background_hl(240, 240, 240);
-CL_Color background_sw(200, 200, 200);
-CL_Color highlight    (255, 255, 255);
-CL_Color midtone      (150, 150, 150);
-CL_Color shadow       (100, 100, 100);
-
-void
-Box::draw_button_up(const CL_Rect& rect)
-{
-  CL_Display::fill_rect(rect, background_hl);
-  CL_Display::draw_line(rect.left, rect.top, 
-                        rect.right, rect.top, highlight);
-  CL_Display::draw_line(rect.left, rect.top, 
-                        rect.left, rect.bottom, highlight);
-
-  CL_Display::draw_line(rect.left, rect.bottom, 
-                        rect.right, rect.bottom, shadow);
-  CL_Display::draw_line(rect.right, rect.top, 
-                        rect.right, rect.bottom, shadow);
-}
-
-void
-Box::draw_button_down(const CL_Rect& rect)
-{
-  CL_Display::fill_rect(rect, background_sw);
-
-  CL_Display::draw_line(rect.left, rect.bottom, 
-                        rect.right, rect.bottom, highlight);
-  CL_Display::draw_line(rect.right, rect.top, 
-                        rect.right, rect.bottom, highlight);
-
-  CL_Display::draw_line(rect.left, rect.top, 
-                        rect.right, rect.top, shadow);
-  CL_Display::draw_line(rect.left, rect.top, 
-                        rect.left, rect.bottom, shadow);
-}
-
-void
-Box::draw_button_neutral(const CL_Rect& rect)
-{
-  CL_Display::fill_rect(rect, background);
-}
-
-void
-Box::draw_panel(const CL_Rect& rect)
-{
-  CL_Display::fill_rect(rect, background);
-  CL_Display::draw_line(rect.left, rect.top, 
-                        rect.right, rect.top, highlight);
-  CL_Display::draw_line(rect.left, rect.top, 
-                        rect.left, rect.bottom, highlight);
-
-  CL_Display::draw_line(rect.left, rect.bottom, 
-                        rect.right, rect.bottom, shadow);
-  CL_Display::draw_line(rect.right, rect.top, 
-                        rect.right, rect.bottom, shadow);
-}
-
-void
-Box::draw_panel_down(const CL_Rect& rect)
-{
-  CL_Display::fill_rect(rect, background);
-  CL_Display::draw_line(rect.left, rect.top, 
-                        rect.right, rect.top, shadow);
-  CL_Display::draw_line(rect.left, rect.top, 
-                        rect.left, rect.bottom, shadow);
-
-  CL_Display::draw_line(rect.left, rect.bottom, 
-                        rect.right, rect.bottom, highlight);
-  CL_Display::draw_line(rect.right, rect.top, 
-                        rect.right, rect.bottom, highlight);
-}
-
-void
-Box::draw_window(const CL_Rect& rect)
-{
-  draw_panel(CL_Rect(rect.left+1, rect.top+1, rect.right-2, rect.bottom-2));
-  CL_Display::draw_rect(rect, CL_Color(0, 0, 0));
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/box.hpp (from rev 712, trunk/flexlay/lib/box.hxx)

Deleted: trunk/flexlay/lib/box.hxx
===================================================================
--- trunk/flexlay/lib/box.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/box.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,38 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_BOX_HXX
-#define HEADER_BOX_HXX
-
-#include <ClanLib/Core/Math/rect.h>
-
-/** Little helper class to draw boxes and stuff in the GUI */
-class Box
-{
-public:
-  static void draw_button_up(const CL_Rect& rect);
-  static void draw_button_down(const CL_Rect& rect);
-  static void draw_button_neutral(const CL_Rect& rect);
-  static void draw_panel(const CL_Rect& rect);
-  static void draw_panel_down(const CL_Rect& rect);
-  static void draw_window(const CL_Rect& rect);
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/brush.cpp (from rev 712, trunk/flexlay/lib/brush.cxx)
===================================================================
--- trunk/flexlay/lib/brush.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/brush.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,43 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "brush.hpp"
+
+Brush::Brush()
+{
+}
+
+Brush::Brush(SharedPtr<BrushImpl> impl_)
+  : impl(impl_)
+{
+  
+}
+
+Brush
+Brush::clone() const
+{
+  return Brush(impl->clone());
+}
+
+CL_Sprite
+Brush::get_sprite()
+{
+  return impl->get_sprite();
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/brush.cxx
===================================================================
--- trunk/flexlay/lib/brush.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/brush.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,43 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "brush.hxx"
-
-Brush::Brush()
-{
-}
-
-Brush::Brush(SharedPtr<BrushImpl> impl_)
-  : impl(impl_)
-{
-  
-}
-
-Brush
-Brush::clone() const
-{
-  return Brush(impl->clone());
-}
-
-CL_Sprite
-Brush::get_sprite()
-{
-  return impl->get_sprite();
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/brush.hpp (from rev 712, trunk/flexlay/lib/brush.hxx)
===================================================================
--- trunk/flexlay/lib/brush.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/brush.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,41 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_BRUSH_HXX
+#define HEADER_BRUSH_HXX
+
+#include "brush_impl.hpp"
+#include "shared_ptr.hpp"
+
+/** */
+class Brush
+{
+public:
+  Brush();
+  Brush(SharedPtr<BrushImpl> impl);
+
+  CL_Sprite get_sprite();
+  Brush clone() const;
+  bool is_null() const { return !impl.get(); }
+public:
+  SharedPtr<BrushImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/brush.hxx
===================================================================
--- trunk/flexlay/lib/brush.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/brush.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,41 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_BRUSH_HXX
-#define HEADER_BRUSH_HXX
-
-#include "brush_impl.hxx"
-#include "shared_ptr.hxx"
-
-/** */
-class Brush
-{
-public:
-  Brush();
-  Brush(SharedPtr<BrushImpl> impl);
-
-  CL_Sprite get_sprite();
-  Brush clone() const;
-  bool is_null() const { return !impl.get(); }
-public:
-  SharedPtr<BrushImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/brush_impl.hpp (from rev 712, trunk/flexlay/lib/brush_impl.hxx)

Deleted: trunk/flexlay/lib/brush_impl.hxx
===================================================================
--- trunk/flexlay/lib/brush_impl.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/brush_impl.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,35 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_BRUSH_IMPL_HXX
-#define HEADER_BRUSH_IMPL_HXX
-
-#include <ClanLib/Display/sprite.h>
-
-/** */
-class BrushImpl
-{
-public:
-  virtual ~BrushImpl() {}
-  virtual CL_Sprite get_sprite() =0;
-  virtual BrushImpl* clone() const =0;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/brushmask.cpp (from rev 712, trunk/flexlay/lib/brushmask.cxx)
===================================================================
--- trunk/flexlay/lib/brushmask.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/brushmask.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,353 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2004 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+/* Most of the code below is taken from Gimp2.2:
+   gimp_brush_generated module Copyright 1998 Jay Cox <jaycox at earthlink.net> 
+ */
+
+#include <iostream>
+#include <math.h>
+#include <string.h>
+#include <ClanLib/Display/pixel_format.h>
+#include "brushmask.hpp"
+
+#define OVERSAMPLING 5
+
+typedef int gint;
+typedef unsigned char guchar;
+
+struct TempBuf {
+  gint      width;
+  gint      height;
+
+  guchar   *data;       /*  The data buffer. Do never access this field
+                            directly, use temp_buf_data() instead !!       */
+};
+
+void
+temp_buf_free (TempBuf *temp_buf)
+{
+  // FIXME:
+  delete temp_buf;
+}
+
+guchar *
+temp_buf_data (TempBuf *temp_buf)
+{
+  return temp_buf->data;
+}
+
+TempBuf *
+temp_buf_new (gint    width,
+	      gint    height,
+	      gint    bytes,
+	      gint    x,
+	      gint    y,
+	      guchar *col)
+{
+  TempBuf* buf = new TempBuf;
+
+  buf->data   = new guchar[width*height];
+  memset(buf->data, 0, width*height*sizeof(guchar));
+ 
+  buf->width  = width;
+  buf->height = height;
+
+  return buf;
+}
+
+#define gimp_deg_to_rad(angle) ((angle) * (2.0 * M_PI) / 360.0)
+#define gimp_rad_to_deg(angle) ((angle) * 360.0 / (2.0 * M_PI))
+
+static double
+gauss (double f)
+{
+  /* this aint' a real gauss function */
+  if (f < -0.5)
+    {
+      f = -1.0 - f;
+      return (2.0 * f*f);
+    }
+
+  if (f < 0.5)
+    return (1.0 - 2.0 * f*f);
+
+  f = 1.0 - f;
+  return (2.0 * f*f);
+}
+
+struct GimpVector2
+{
+  double x, y;
+};
+
+struct GimpBrushGenerated
+{
+  TempBuf      *mask;       /*  the actual mask                */
+
+  GimpVector2   x_axis;     /*  for calculating brush spacing  */
+  GimpVector2   y_axis;     /*  for calculating brush spacing  */
+
+  BrushShape shape;
+  float                  radius;
+  gint                    spikes;       /* 2 - 20     */
+  float                  hardness;     /* 0.0 - 1.0  */
+  float                  aspect_ratio; /* y/x        */
+  float                  angle;        /* in degrees */
+};
+
+
+static void
+gimp_brush_generated_dirty (GimpBrushGenerated *brush)
+{
+  gint                x, y;
+  guchar             *centerp;
+  double             d;
+  double             exponent;
+  guchar              a;
+  gint                length;
+  gint                width  = 0;
+  gint                height = 0;
+  guchar             *lookup;
+  double             sum;
+  double             c, s, cs, ss;
+  double             short_radius;
+  double             buffer[OVERSAMPLING];
+
+  if (brush->mask)
+    temp_buf_free (brush->mask);
+
+  s = sin (gimp_deg_to_rad (brush->angle));
+  c = cos (gimp_deg_to_rad (brush->angle));
+
+  short_radius = brush->radius / brush->aspect_ratio;
+
+  brush->x_axis.x =        c * brush->radius;
+  brush->x_axis.y = -1.0 * s * brush->radius;
+  brush->y_axis.x =        s * short_radius;
+  brush->y_axis.y =        c * short_radius;
+
+  switch (brush->shape)
+    {
+    case BRUSH_SHAPE_CIRCLE:
+      width  = static_cast<int>(ceil (sqrt (brush->x_axis.x * brush->x_axis.x +
+                                            brush->y_axis.x * brush->y_axis.x)));
+      height = static_cast<int>(ceil (sqrt (brush->x_axis.y * brush->x_axis.y +
+                                            brush->y_axis.y * brush->y_axis.y)));
+      break;
+
+    case BRUSH_SHAPE_SQUARE:
+      width  = static_cast<int>(ceil (fabs (brush->x_axis.x) + fabs (brush->y_axis.x)));
+      height = static_cast<int>(ceil (fabs (brush->x_axis.y) + fabs (brush->y_axis.y)));
+      break;
+
+    case BRUSH_SHAPE_DIAMOND:
+      width  = static_cast<int>(ceil (std::max(fabs (brush->x_axis.x), fabs (brush->y_axis.x))));
+      height = static_cast<int>(ceil (std::max(fabs (brush->x_axis.y), fabs (brush->y_axis.y))));
+      break;
+
+    default:
+      return;
+    }
+
+  if (brush->spikes > 2)
+    {
+      /* could be optimized by respecting the angle */
+      width = height = static_cast<int>(ceil (sqrt (brush->radius * brush->radius +
+                                                    short_radius * short_radius)));
+      brush->y_axis.x =        s * brush->radius;
+      brush->y_axis.y =        c * brush->radius;
+    }
+
+  brush->mask = temp_buf_new (width  * 2 + 1,
+                              height * 2 + 1,
+                              1, width, height, NULL);
+
+  centerp = temp_buf_data (brush->mask) + height * brush->mask->width + width;
+
+  /* set up lookup table */
+  length = static_cast<int>(OVERSAMPLING * ceil (1 + sqrt (2 *
+                                                           ceil (brush->radius + 1.0) *
+                                                           ceil (brush->radius + 1.0))));
+
+  if ((1.0 - brush->hardness) < 0.0000004)
+    exponent = 1000000.0;
+  else
+    exponent = 0.4 / (1.0 - brush->hardness);
+
+  lookup = new guchar[length];
+  sum = 0.0;
+
+  for (x = 0; x < OVERSAMPLING; x++)
+    {
+      d = fabs ((x + 0.5) / OVERSAMPLING - 0.5);
+
+      if (d > brush->radius)
+        buffer[x] = 0.0;
+      else
+        buffer[x] = gauss (pow (d / brush->radius, exponent));
+
+      sum += buffer[x];
+    }
+
+  for (x = 0; d < brush->radius || sum > 0.00001; d += 1.0 / OVERSAMPLING)
+    {
+      sum -= buffer[x % OVERSAMPLING];
+
+      if (d > brush->radius)
+        buffer[x % OVERSAMPLING] = 0.0;
+      else
+        buffer[x % OVERSAMPLING] = gauss (pow (d / brush->radius, exponent));
+
+      sum += buffer[x % OVERSAMPLING];
+      lookup[x++] = static_cast<int>(rint(sum * (255.0 / OVERSAMPLING)));
+    }
+
+  while (x < length)
+    {
+      lookup[x++] = 0;
+    }
+
+  cs = cos (- 2 * M_PI / brush->spikes);
+  ss = sin (- 2 * M_PI / brush->spikes);
+
+  /* for an even number of spikes compute one half and mirror it */
+  for (y = (brush->spikes % 2 ? -height : 0); y <= height; y++)
+    {
+      for (x = -width; x <= width; x++)
+        {
+          double tx, ty, angle;
+
+          tx = c*x - s*y;
+          ty = fabs (s*x + c*y);
+
+          if (brush->spikes > 2)
+            {
+              angle = atan2 (ty, tx);
+
+              while (angle > M_PI / brush->spikes)
+                {
+                  double sx = tx, sy = ty;
+
+                  tx = cs * sx - ss * sy;
+                  ty = ss * sx + cs * sy;
+
+                  angle -= 2 * M_PI / brush->spikes;
+                }
+            }
+
+          ty *= brush->aspect_ratio;
+          switch (brush->shape)
+            {
+            case BRUSH_SHAPE_CIRCLE:
+              d = sqrt (tx*tx + ty*ty);
+              break;
+            case BRUSH_SHAPE_SQUARE:
+              d = std::max (fabs (tx), fabs (ty));
+              break;
+            case BRUSH_SHAPE_DIAMOND:
+              d = fabs (tx) + fabs (ty);
+              break;
+            }
+
+          if (d < brush->radius + 1)
+            a = lookup[(gint) rint (d * OVERSAMPLING)];
+          else
+            a = 0;
+
+          centerp[ y * brush->mask->width + x] = a;
+
+          if (brush->spikes % 2 == 0)
+            centerp[-1 * y * brush->mask->width - x] = a;
+        }
+    }
+
+  delete lookup;
+}
+
+CL_PixelBuffer generate_brushmask(BrushShape shape,
+                                  float  radius,
+                                  int    spikes,        /* 2 - 20     */
+                                  float  hardness,      /* 0.0 - 1.0  */
+                                  float  aspect_ratio,  /* y/x        */
+                                  float  angle)         /* in degrees */
+{
+  GimpBrushGenerated brush;
+  
+  brush.mask         = 0;
+  brush.shape        = shape;
+  brush.radius       = radius;
+  brush.spikes       = spikes;
+  brush.hardness     = hardness;
+  brush.aspect_ratio = aspect_ratio;
+  brush.angle        = angle;
+
+  gimp_brush_generated_dirty(&brush);
+
+  CL_PixelBuffer buffer(brush.mask->width, brush.mask->height, brush.mask->width*4,
+                        CL_PixelFormat::rgba8888);
+  
+  buffer.lock();
+  unsigned char* buf = static_cast<unsigned char*>(buffer.get_data());
+
+  // FIXME: Leaving out the right/bottom border, since thats full of
+  // random spots... more a workaround than a fix really
+  for (int i = 0; i < brush.mask->height * brush.mask->width; ++i)
+    {
+      buf[i*4+0] = brush.mask->data[i];
+      buf[i*4+1] = 255;
+      buf[i*4+2] = 255;
+      buf[i*4+3] = 255;
+    }
+  buffer.unlock();
+
+  return buffer;
+}
+
+#ifdef TEST
+int main()
+{
+  GimpBrushGenerated brush;
+  
+  brush.mask         = 0;
+  brush.shape        = BRUSH_SHAPE_DIAMOND;
+  brush.radius       = 512;
+  brush.spikes       = 19;
+  brush.hardness     = 0.9;
+  brush.aspect_ratio = 1;
+  brush.angle        = 0;
+
+  gimp_brush_generated_dirty(&brush);
+
+  std::cout << "P2\n";
+  std::cout << "# Gimp Brush Generator\n";
+  std::cout << brush.mask->width << " " << brush.mask->height << "\n";
+  std::cout << "255\n";
+
+  for (int i = 0; i < brush.mask->width * brush.mask->height; ++i)
+    std::cout << int(brush.mask->data[i]) << " ";
+
+  temp_buf_free(brush.mask);
+  
+  std::cout << std::endl;
+
+  return 0;
+}
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/brushmask.cxx
===================================================================
--- trunk/flexlay/lib/brushmask.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/brushmask.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,353 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2004 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-/* Most of the code below is taken from Gimp2.2:
-   gimp_brush_generated module Copyright 1998 Jay Cox <jaycox at earthlink.net> 
- */
-
-#include <iostream>
-#include <math.h>
-#include <string.h>
-#include <ClanLib/Display/pixel_format.h>
-#include "brushmask.hxx"
-
-#define OVERSAMPLING 5
-
-typedef int gint;
-typedef unsigned char guchar;
-
-struct TempBuf {
-  gint      width;
-  gint      height;
-
-  guchar   *data;       /*  The data buffer. Do never access this field
-                            directly, use temp_buf_data() instead !!       */
-};
-
-void
-temp_buf_free (TempBuf *temp_buf)
-{
-  // FIXME:
-  delete temp_buf;
-}
-
-guchar *
-temp_buf_data (TempBuf *temp_buf)
-{
-  return temp_buf->data;
-}
-
-TempBuf *
-temp_buf_new (gint    width,
-	      gint    height,
-	      gint    bytes,
-	      gint    x,
-	      gint    y,
-	      guchar *col)
-{
-  TempBuf* buf = new TempBuf;
-
-  buf->data   = new guchar[width*height];
-  memset(buf->data, 0, width*height*sizeof(guchar));
- 
-  buf->width  = width;
-  buf->height = height;
-
-  return buf;
-}
-
-#define gimp_deg_to_rad(angle) ((angle) * (2.0 * M_PI) / 360.0)
-#define gimp_rad_to_deg(angle) ((angle) * 360.0 / (2.0 * M_PI))
-
-static double
-gauss (double f)
-{
-  /* this aint' a real gauss function */
-  if (f < -0.5)
-    {
-      f = -1.0 - f;
-      return (2.0 * f*f);
-    }
-
-  if (f < 0.5)
-    return (1.0 - 2.0 * f*f);
-
-  f = 1.0 - f;
-  return (2.0 * f*f);
-}
-
-struct GimpVector2
-{
-  double x, y;
-};
-
-struct GimpBrushGenerated
-{
-  TempBuf      *mask;       /*  the actual mask                */
-
-  GimpVector2   x_axis;     /*  for calculating brush spacing  */
-  GimpVector2   y_axis;     /*  for calculating brush spacing  */
-
-  BrushShape shape;
-  float                  radius;
-  gint                    spikes;       /* 2 - 20     */
-  float                  hardness;     /* 0.0 - 1.0  */
-  float                  aspect_ratio; /* y/x        */
-  float                  angle;        /* in degrees */
-};
-
-
-static void
-gimp_brush_generated_dirty (GimpBrushGenerated *brush)
-{
-  gint                x, y;
-  guchar             *centerp;
-  double             d;
-  double             exponent;
-  guchar              a;
-  gint                length;
-  gint                width  = 0;
-  gint                height = 0;
-  guchar             *lookup;
-  double             sum;
-  double             c, s, cs, ss;
-  double             short_radius;
-  double             buffer[OVERSAMPLING];
-
-  if (brush->mask)
-    temp_buf_free (brush->mask);
-
-  s = sin (gimp_deg_to_rad (brush->angle));
-  c = cos (gimp_deg_to_rad (brush->angle));
-
-  short_radius = brush->radius / brush->aspect_ratio;
-
-  brush->x_axis.x =        c * brush->radius;
-  brush->x_axis.y = -1.0 * s * brush->radius;
-  brush->y_axis.x =        s * short_radius;
-  brush->y_axis.y =        c * short_radius;
-
-  switch (brush->shape)
-    {
-    case BRUSH_SHAPE_CIRCLE:
-      width  = static_cast<int>(ceil (sqrt (brush->x_axis.x * brush->x_axis.x +
-                                            brush->y_axis.x * brush->y_axis.x)));
-      height = static_cast<int>(ceil (sqrt (brush->x_axis.y * brush->x_axis.y +
-                                            brush->y_axis.y * brush->y_axis.y)));
-      break;
-
-    case BRUSH_SHAPE_SQUARE:
-      width  = static_cast<int>(ceil (fabs (brush->x_axis.x) + fabs (brush->y_axis.x)));
-      height = static_cast<int>(ceil (fabs (brush->x_axis.y) + fabs (brush->y_axis.y)));
-      break;
-
-    case BRUSH_SHAPE_DIAMOND:
-      width  = static_cast<int>(ceil (std::max(fabs (brush->x_axis.x), fabs (brush->y_axis.x))));
-      height = static_cast<int>(ceil (std::max(fabs (brush->x_axis.y), fabs (brush->y_axis.y))));
-      break;
-
-    default:
-      return;
-    }
-
-  if (brush->spikes > 2)
-    {
-      /* could be optimized by respecting the angle */
-      width = height = static_cast<int>(ceil (sqrt (brush->radius * brush->radius +
-                                                    short_radius * short_radius)));
-      brush->y_axis.x =        s * brush->radius;
-      brush->y_axis.y =        c * brush->radius;
-    }
-
-  brush->mask = temp_buf_new (width  * 2 + 1,
-                              height * 2 + 1,
-                              1, width, height, NULL);
-
-  centerp = temp_buf_data (brush->mask) + height * brush->mask->width + width;
-
-  /* set up lookup table */
-  length = static_cast<int>(OVERSAMPLING * ceil (1 + sqrt (2 *
-                                                           ceil (brush->radius + 1.0) *
-                                                           ceil (brush->radius + 1.0))));
-
-  if ((1.0 - brush->hardness) < 0.0000004)
-    exponent = 1000000.0;
-  else
-    exponent = 0.4 / (1.0 - brush->hardness);
-
-  lookup = new guchar[length];
-  sum = 0.0;
-
-  for (x = 0; x < OVERSAMPLING; x++)
-    {
-      d = fabs ((x + 0.5) / OVERSAMPLING - 0.5);
-
-      if (d > brush->radius)
-        buffer[x] = 0.0;
-      else
-        buffer[x] = gauss (pow (d / brush->radius, exponent));
-
-      sum += buffer[x];
-    }
-
-  for (x = 0; d < brush->radius || sum > 0.00001; d += 1.0 / OVERSAMPLING)
-    {
-      sum -= buffer[x % OVERSAMPLING];
-
-      if (d > brush->radius)
-        buffer[x % OVERSAMPLING] = 0.0;
-      else
-        buffer[x % OVERSAMPLING] = gauss (pow (d / brush->radius, exponent));
-
-      sum += buffer[x % OVERSAMPLING];
-      lookup[x++] = static_cast<int>(rint(sum * (255.0 / OVERSAMPLING)));
-    }
-
-  while (x < length)
-    {
-      lookup[x++] = 0;
-    }
-
-  cs = cos (- 2 * M_PI / brush->spikes);
-  ss = sin (- 2 * M_PI / brush->spikes);
-
-  /* for an even number of spikes compute one half and mirror it */
-  for (y = (brush->spikes % 2 ? -height : 0); y <= height; y++)
-    {
-      for (x = -width; x <= width; x++)
-        {
-          double tx, ty, angle;
-
-          tx = c*x - s*y;
-          ty = fabs (s*x + c*y);
-
-          if (brush->spikes > 2)
-            {
-              angle = atan2 (ty, tx);
-
-              while (angle > M_PI / brush->spikes)
-                {
-                  double sx = tx, sy = ty;
-
-                  tx = cs * sx - ss * sy;
-                  ty = ss * sx + cs * sy;
-
-                  angle -= 2 * M_PI / brush->spikes;
-                }
-            }
-
-          ty *= brush->aspect_ratio;
-          switch (brush->shape)
-            {
-            case BRUSH_SHAPE_CIRCLE:
-              d = sqrt (tx*tx + ty*ty);
-              break;
-            case BRUSH_SHAPE_SQUARE:
-              d = std::max (fabs (tx), fabs (ty));
-              break;
-            case BRUSH_SHAPE_DIAMOND:
-              d = fabs (tx) + fabs (ty);
-              break;
-            }
-
-          if (d < brush->radius + 1)
-            a = lookup[(gint) rint (d * OVERSAMPLING)];
-          else
-            a = 0;
-
-          centerp[ y * brush->mask->width + x] = a;
-
-          if (brush->spikes % 2 == 0)
-            centerp[-1 * y * brush->mask->width - x] = a;
-        }
-    }
-
-  delete lookup;
-}
-
-CL_PixelBuffer generate_brushmask(BrushShape shape,
-                                  float  radius,
-                                  int    spikes,        /* 2 - 20     */
-                                  float  hardness,      /* 0.0 - 1.0  */
-                                  float  aspect_ratio,  /* y/x        */
-                                  float  angle)         /* in degrees */
-{
-  GimpBrushGenerated brush;
-  
-  brush.mask         = 0;
-  brush.shape        = shape;
-  brush.radius       = radius;
-  brush.spikes       = spikes;
-  brush.hardness     = hardness;
-  brush.aspect_ratio = aspect_ratio;
-  brush.angle        = angle;
-
-  gimp_brush_generated_dirty(&brush);
-
-  CL_PixelBuffer buffer(brush.mask->width, brush.mask->height, brush.mask->width*4,
-                        CL_PixelFormat::rgba8888);
-  
-  buffer.lock();
-  unsigned char* buf = static_cast<unsigned char*>(buffer.get_data());
-
-  // FIXME: Leaving out the right/bottom border, since thats full of
-  // random spots... more a workaround than a fix really
-  for (int i = 0; i < brush.mask->height * brush.mask->width; ++i)
-    {
-      buf[i*4+0] = brush.mask->data[i];
-      buf[i*4+1] = 255;
-      buf[i*4+2] = 255;
-      buf[i*4+3] = 255;
-    }
-  buffer.unlock();
-
-  return buffer;
-}
-
-#ifdef TEST
-int main()
-{
-  GimpBrushGenerated brush;
-  
-  brush.mask         = 0;
-  brush.shape        = BRUSH_SHAPE_DIAMOND;
-  brush.radius       = 512;
-  brush.spikes       = 19;
-  brush.hardness     = 0.9;
-  brush.aspect_ratio = 1;
-  brush.angle        = 0;
-
-  gimp_brush_generated_dirty(&brush);
-
-  std::cout << "P2\n";
-  std::cout << "# Gimp Brush Generator\n";
-  std::cout << brush.mask->width << " " << brush.mask->height << "\n";
-  std::cout << "255\n";
-
-  for (int i = 0; i < brush.mask->width * brush.mask->height; ++i)
-    std::cout << int(brush.mask->data[i]) << " ";
-
-  temp_buf_free(brush.mask);
-  
-  std::cout << std::endl;
-
-  return 0;
-}
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/brushmask.hpp (from rev 712, trunk/flexlay/lib/brushmask.hxx)

Deleted: trunk/flexlay/lib/brushmask.hxx
===================================================================
--- trunk/flexlay/lib/brushmask.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/brushmask.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,39 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2004 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_BRUSHMASK_HXX
-#define HEADER_BRUSHMASK_HXX
-
-#include <ClanLib/Display/pixel_buffer.h>
-
-enum BrushShape {
-  BRUSH_SHAPE_CIRCLE,
-  BRUSH_SHAPE_SQUARE,
-  BRUSH_SHAPE_DIAMOND
-};
-
-CL_PixelBuffer generate_brushmask(BrushShape shape,
-                                  float  radius,
-                                  int    spikes,        /* 2 - 20     */
-                                  float  hardness,      /* 0.0 - 1.0  */
-                                  float  aspect_ratio,  /* y/x        */
-                                  float  angle);        /* in degrees */
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/colorpicker.cpp (from rev 712, trunk/flexlay/lib/colorpicker.cxx)
===================================================================
--- trunk/flexlay/lib/colorpicker.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/colorpicker.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,409 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <vector>
+#include <iostream>
+#include <ClanLib/Display/display_iostream.h>
+#include <ClanLib/Display/color.h>
+#include <ClanLib/Display/display.h>
+#include <ClanLib/Display/keys.h>
+#include <ClanLib/Core/Math/rect.h>
+#include <ClanLib/Core/Math/point.h>
+#include <ClanLib/GUI/component.h>
+#include "colorpicker.hpp"
+#include "math.hpp"
+
+class ColorPickerHue : public CL_Component
+{
+public:
+  std::vector<CL_Slot> slots;
+  typedef std::vector<CL_Color> Colors;
+  Colors  colors;
+  bool pressed;
+  CL_Signal_v1<CL_Color> on_color_change;
+  
+  ColorPickerHue(const CL_Rect& rect, CL_Component* parent) 
+    : CL_Component(rect, parent),
+      pressed(false)
+  {
+    colors.push_back(CL_Color(255,   0,   0));
+    colors.push_back(CL_Color(255,   0, 255));
+    colors.push_back(CL_Color(  0,   0, 255));
+    colors.push_back(CL_Color(  0, 255, 255));
+    colors.push_back(CL_Color(  0, 255,   0));
+    colors.push_back(CL_Color(255, 255,   0));
+    colors.push_back(CL_Color(255,   0,   0));
+
+    slots.push_back(sig_paint().connect(this, &ColorPickerHue::draw));
+
+    slots.push_back(sig_mouse_down().connect(this, &ColorPickerHue::on_mouse_down));
+    slots.push_back(sig_mouse_up().connect(this, &ColorPickerHue::on_mouse_up));
+    slots.push_back(sig_mouse_move().connect(this, &ColorPickerHue::on_mouse_move));
+  }
+
+  void update_pointer(const CL_InputEvent& event)
+  {
+    CL_Color new_color; 
+
+    if (event.mouse_pos.y >= get_height() || event.mouse_pos.y < 0)
+      {
+        new_color = colors[0];
+      }
+    else
+      {
+        float factor  = (float(event.mouse_pos.y) / get_height()) * (colors.size()-1);
+        int   prevcol = int(factor);
+        int   nextcol = prevcol+1;
+
+        float val  = factor - prevcol;
+        float ival = 1.0f - val;
+
+
+        if (val >= 0 && val < 1.0f)
+          {
+            new_color = CL_Color(int(val * colors[nextcol].get_red()   + ival * colors[prevcol].get_red()),
+                                 int(val * colors[nextcol].get_green() + ival * colors[prevcol].get_green()),
+                                 int(val * colors[nextcol].get_blue()  + ival * colors[prevcol].get_blue()),
+                                 int(val * colors[nextcol].get_alpha() + ival * colors[prevcol].get_alpha()));
+          }
+        else
+          {
+            std::cout << "Out of range" << std::endl;
+            new_color = colors[0];
+          }
+      }
+    on_color_change(new_color);
+
+    /*
+    std::cout << new_color.get_red() << ", "
+              << new_color.get_green() << ", "
+              << new_color.get_blue() << ", "
+              << new_color.get_alpha()
+              << std::endl;*/
+  }
+  
+  void on_mouse_up(const CL_InputEvent& event)
+  {
+    if (event.id == CL_MOUSE_LEFT)
+      {
+        pressed = false;
+        release_mouse();
+        update_pointer(event);
+      }
+  }
+
+  void on_mouse_down(const CL_InputEvent& event)
+  {
+    if (event.id == CL_MOUSE_LEFT)
+      {
+        pressed = true;
+        capture_mouse();
+        update_pointer(event);
+      }  
+  }
+  
+  void on_mouse_move(const CL_InputEvent& event)
+  {
+    if (pressed)
+      {
+        update_pointer(event);
+      }
+  }
+
+  void draw()
+  {
+    CL_Display::push_modelview();
+    CL_Display::add_translate(get_screen_x(), get_screen_y());
+    
+    int psize = get_height()/6;
+    
+    for(Colors::size_type i = 0; i < colors.size()-1; ++i)
+      {
+        CL_Display::fill_rect(CL_Rect(CL_Point(0, i*psize),
+                                      CL_Size(get_width(), psize)),
+                              CL_Gradient(colors[i],
+                                          colors[i],
+                                          colors[i+1],
+                                          colors[i+1]));
+      }
+
+    CL_Display::pop_modelview();    
+  }
+};
+
+class ColorPickerAlpha : public CL_Component
+{
+public:
+  std::vector<CL_Slot> slots;
+  bool pressed;
+  CL_Signal_v1<float> on_color_change;
+  float alpha;
+
+  ColorPickerAlpha(const CL_Rect& rect, CL_Component* parent) 
+    : CL_Component(rect, parent),
+      pressed(false),
+      alpha(0.5f)
+  {
+    slots.push_back(sig_paint().connect(this, &ColorPickerAlpha::draw));
+
+    slots.push_back(sig_mouse_down().connect(this, &ColorPickerAlpha::on_mouse_down));
+    slots.push_back(sig_mouse_up().connect(this, &ColorPickerAlpha::on_mouse_up));
+    slots.push_back(sig_mouse_move().connect(this, &ColorPickerAlpha::on_mouse_move));
+  }
+
+  void set_alpha(float alpha_)
+  {
+    alpha = alpha_;
+    on_color_change(alpha);
+  }  
+
+  void draw()
+  {
+    CL_Display::push_modelview();
+    CL_Display::add_translate(get_screen_x(), get_screen_y());    
+   
+    CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
+                                  CL_Size(get_width(), get_height())),
+                          CL_Gradient(CL_Color(0, 0, 0),
+                                      CL_Color(255, 255, 255),
+                                      CL_Color(0, 0, 0),
+                                      CL_Color(255, 255, 255)));
+
+    CL_Display::pop_modelview();
+  }
+
+  void update_pointer(const CL_InputEvent& event)
+  {
+    alpha = 1.0f - (Math::mid(0.0f, float(event.mouse_pos.x) / get_width(), 1.0f));
+    on_color_change(alpha);
+  }
+
+  void on_mouse_up(const CL_InputEvent& event)
+  {
+    if (event.id == CL_MOUSE_LEFT)
+      {
+        pressed = false;
+        release_mouse();
+        update_pointer(event);
+      }
+  }
+
+  void on_mouse_down(const CL_InputEvent& event)
+  {
+    if (event.id == CL_MOUSE_LEFT)
+      {
+        pressed = true;
+        capture_mouse();
+        update_pointer(event);
+      }
+  }
+
+  void on_mouse_move(const CL_InputEvent& event)
+  {
+    if (pressed)
+      {
+        update_pointer(event);    
+      }
+  }
+};
+
+class ColorPickerBrightness : public CL_Component
+{
+public:
+  std::vector<CL_Slot> slots;
+  CL_Color color;
+  bool pressed;
+  CL_Signal_v1<CL_Color> on_color_change;
+  float factor_x;
+  float factor_y;
+  ColorPickerBrightness(const CL_Rect& rect, CL_Component* parent) 
+    : CL_Component(rect, parent),
+      pressed(false),
+      factor_x(1.0f),
+      factor_y(1.0f)
+  {
+    color = CL_Color(255, 0, 0);
+    slots.push_back(sig_paint().connect(this, &ColorPickerBrightness::draw));
+
+    slots.push_back(sig_mouse_down().connect(this, &ColorPickerBrightness::on_mouse_down));
+    slots.push_back(sig_mouse_up().connect(this, &ColorPickerBrightness::on_mouse_up));
+    slots.push_back(sig_mouse_move().connect(this, &ColorPickerBrightness::on_mouse_move));
+  }
+
+  void draw()
+  {
+    CL_Display::push_modelview();
+    CL_Display::add_translate(get_screen_x(), get_screen_y());
+
+    CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
+                                  CL_Size(get_width(), get_height())),
+                          CL_Gradient(CL_Color(0, 0, 0),
+                                      color,
+                                      CL_Color(0, 0, 0),
+                                      CL_Color(255, 255, 255)));
+
+    CL_Display::draw_line(factor_x * get_width(),
+                          0,
+                          factor_x * get_width(),
+                          get_height(),
+                          CL_Color(255, 255, 255));
+
+    CL_Display::draw_line(0,
+                          factor_y * get_height(),
+                          get_width(),
+                          factor_y * get_height(),
+                          CL_Color(255, 255, 255));
+
+    CL_Display::pop_modelview();
+  }
+
+  void set_color(CL_Color color_) {
+    color = color_;
+    update_color();
+  }
+
+  void update_color()
+  {
+    CL_Color new_color(Math::mid(0, int(factor_x * color.get_red()   * (1.0f - factor_y) + factor_x * 255 * (factor_y)), 255),
+                       Math::mid(0, int(factor_x * color.get_green() * (1.0f - factor_y) + factor_x * 255 * (factor_y)), 255),   
+                       Math::mid(0, int(factor_x * color.get_blue()  * (1.0f - factor_y) + factor_x * 255 * (factor_y)), 255),
+                       color.get_alpha());
+    on_color_change(new_color);
+    /*
+    std::cout << new_color.get_red() << ", "
+              << new_color.get_green() << ", "
+              << new_color.get_blue() << ", "
+              << new_color.get_alpha()
+              << std::endl;
+    */
+  }
+
+  void update_pointer(const CL_InputEvent& event)
+  {
+    factor_x = Math::mid(0.0f, float(event.mouse_pos.x)/get_width(), 1.0f);
+    factor_y = Math::mid(0.0f, float(event.mouse_pos.y)/get_height(), 1.0f);
+
+    update_color();
+  }
+
+  void on_mouse_up(const CL_InputEvent& event)
+  {
+    if (event.id == CL_MOUSE_LEFT)
+      {
+        pressed = false;
+        release_mouse();
+        update_pointer(event);
+      }    
+  }
+
+  void on_mouse_down(const CL_InputEvent& event)
+  {
+    if (event.id == CL_MOUSE_LEFT)
+      {
+        pressed = true;
+        capture_mouse();
+        update_pointer(event);
+      }
+  }
+
+  void on_mouse_move(const CL_InputEvent& event)
+  {
+    if (pressed)
+      {
+        update_pointer(event);
+      }
+  }
+};
+
+ColorPicker::ColorPicker(const CL_Rect& rect, CL_Component* parent)
+  : CL_Component(rect, parent)
+{
+  float pwidth  = rect.get_width()/11.0;
+  float pheight = rect.get_height()/11.0;
+
+  brightness = new ColorPickerBrightness(CL_Rect(CL_Point(0, 0),
+                                                 CL_Size(int(pwidth*10), int(pheight*10))), 
+                                         this);
+  
+  hue        = new ColorPickerHue(CL_Rect(CL_Point(int(pwidth*10), 0),
+                                          CL_Size(int(pwidth*1), int(pheight*10))),
+                                  this);
+
+  alpha      = new ColorPickerAlpha(CL_Rect(CL_Point(0, int(pheight*10)),
+                                            CL_Size(int(pwidth*10), int(pheight*1))),
+                                    this);
+
+  slots.push_back(hue->on_color_change.connect(brightness, &ColorPickerBrightness::set_color));
+  slots.push_back(brightness->on_color_change.connect(this, &ColorPicker::update_brightness_color));
+  slots.push_back(alpha->on_color_change.connect(this, &ColorPicker::update_alpha_color));
+  slots.push_back(sig_paint().connect(this, &ColorPicker::draw));
+
+  brightness->set_color(CL_Color(255, 0, 0));
+  alpha->set_alpha(0.5f);
+}
+
+void
+ColorPicker::update_alpha_color(float alpha)
+{
+  color.set_alpha(int(255 * alpha));
+  on_color_change(color);  
+}
+
+void
+ColorPicker::update_brightness_color(CL_Color color_)
+{
+  color.set_red(color_.get_red());
+  color.set_green(color_.get_green());
+  color.set_blue(color_.get_blue());
+  on_color_change(color);
+}
+
+void
+ColorPicker::draw()
+{
+  CL_Display::push_modelview();
+  CL_Display::add_translate(get_screen_x(), get_screen_y());
+  
+  float pwidth  = get_width()/11.0;
+  float pheight = get_height()/11.0;
+  CL_Display::fill_rect(CL_Rect(CL_Point(int(pwidth*10), int(pheight*10)),
+                                CL_Size(int(pwidth), int(pheight))),
+                        color);
+
+  CL_Display::pop_modelview();
+}
+
+CL_Signal_v1<CL_Color>&
+ColorPicker::sig_color_change()
+{
+  return on_color_change;
+}
+
+CL_Color
+ColorPicker::get_color()
+{
+  return color;
+}
+
+void
+ColorPicker::set_color(const CL_Color& color_)
+{
+  color = color_;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/colorpicker.cxx
===================================================================
--- trunk/flexlay/lib/colorpicker.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/colorpicker.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,409 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <vector>
-#include <iostream>
-#include <ClanLib/Display/display_iostream.h>
-#include <ClanLib/Display/color.h>
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/keys.h>
-#include <ClanLib/Core/Math/rect.h>
-#include <ClanLib/Core/Math/point.h>
-#include <ClanLib/GUI/component.h>
-#include "colorpicker.hxx"
-#include "math.hxx"
-
-class ColorPickerHue : public CL_Component
-{
-public:
-  std::vector<CL_Slot> slots;
-  typedef std::vector<CL_Color> Colors;
-  Colors  colors;
-  bool pressed;
-  CL_Signal_v1<CL_Color> on_color_change;
-  
-  ColorPickerHue(const CL_Rect& rect, CL_Component* parent) 
-    : CL_Component(rect, parent),
-      pressed(false)
-  {
-    colors.push_back(CL_Color(255,   0,   0));
-    colors.push_back(CL_Color(255,   0, 255));
-    colors.push_back(CL_Color(  0,   0, 255));
-    colors.push_back(CL_Color(  0, 255, 255));
-    colors.push_back(CL_Color(  0, 255,   0));
-    colors.push_back(CL_Color(255, 255,   0));
-    colors.push_back(CL_Color(255,   0,   0));
-
-    slots.push_back(sig_paint().connect(this, &ColorPickerHue::draw));
-
-    slots.push_back(sig_mouse_down().connect(this, &ColorPickerHue::on_mouse_down));
-    slots.push_back(sig_mouse_up().connect(this, &ColorPickerHue::on_mouse_up));
-    slots.push_back(sig_mouse_move().connect(this, &ColorPickerHue::on_mouse_move));
-  }
-
-  void update_pointer(const CL_InputEvent& event)
-  {
-    CL_Color new_color; 
-
-    if (event.mouse_pos.y >= get_height() || event.mouse_pos.y < 0)
-      {
-        new_color = colors[0];
-      }
-    else
-      {
-        float factor  = (float(event.mouse_pos.y) / get_height()) * (colors.size()-1);
-        int   prevcol = int(factor);
-        int   nextcol = prevcol+1;
-
-        float val  = factor - prevcol;
-        float ival = 1.0f - val;
-
-
-        if (val >= 0 && val < 1.0f)
-          {
-            new_color = CL_Color(int(val * colors[nextcol].get_red()   + ival * colors[prevcol].get_red()),
-                                 int(val * colors[nextcol].get_green() + ival * colors[prevcol].get_green()),
-                                 int(val * colors[nextcol].get_blue()  + ival * colors[prevcol].get_blue()),
-                                 int(val * colors[nextcol].get_alpha() + ival * colors[prevcol].get_alpha()));
-          }
-        else
-          {
-            std::cout << "Out of range" << std::endl;
-            new_color = colors[0];
-          }
-      }
-    on_color_change(new_color);
-
-    /*
-    std::cout << new_color.get_red() << ", "
-              << new_color.get_green() << ", "
-              << new_color.get_blue() << ", "
-              << new_color.get_alpha()
-              << std::endl;*/
-  }
-  
-  void on_mouse_up(const CL_InputEvent& event)
-  {
-    if (event.id == CL_MOUSE_LEFT)
-      {
-        pressed = false;
-        release_mouse();
-        update_pointer(event);
-      }
-  }
-
-  void on_mouse_down(const CL_InputEvent& event)
-  {
-    if (event.id == CL_MOUSE_LEFT)
-      {
-        pressed = true;
-        capture_mouse();
-        update_pointer(event);
-      }  
-  }
-  
-  void on_mouse_move(const CL_InputEvent& event)
-  {
-    if (pressed)
-      {
-        update_pointer(event);
-      }
-  }
-
-  void draw()
-  {
-    CL_Display::push_modelview();
-    CL_Display::add_translate(get_screen_x(), get_screen_y());
-    
-    int psize = get_height()/6;
-    
-    for(Colors::size_type i = 0; i < colors.size()-1; ++i)
-      {
-        CL_Display::fill_rect(CL_Rect(CL_Point(0, i*psize),
-                                      CL_Size(get_width(), psize)),
-                              CL_Gradient(colors[i],
-                                          colors[i],
-                                          colors[i+1],
-                                          colors[i+1]));
-      }
-
-    CL_Display::pop_modelview();    
-  }
-};
-
-class ColorPickerAlpha : public CL_Component
-{
-public:
-  std::vector<CL_Slot> slots;
-  bool pressed;
-  CL_Signal_v1<float> on_color_change;
-  float alpha;
-
-  ColorPickerAlpha(const CL_Rect& rect, CL_Component* parent) 
-    : CL_Component(rect, parent),
-      pressed(false),
-      alpha(0.5f)
-  {
-    slots.push_back(sig_paint().connect(this, &ColorPickerAlpha::draw));
-
-    slots.push_back(sig_mouse_down().connect(this, &ColorPickerAlpha::on_mouse_down));
-    slots.push_back(sig_mouse_up().connect(this, &ColorPickerAlpha::on_mouse_up));
-    slots.push_back(sig_mouse_move().connect(this, &ColorPickerAlpha::on_mouse_move));
-  }
-
-  void set_alpha(float alpha_)
-  {
-    alpha = alpha_;
-    on_color_change(alpha);
-  }  
-
-  void draw()
-  {
-    CL_Display::push_modelview();
-    CL_Display::add_translate(get_screen_x(), get_screen_y());    
-   
-    CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
-                                  CL_Size(get_width(), get_height())),
-                          CL_Gradient(CL_Color(0, 0, 0),
-                                      CL_Color(255, 255, 255),
-                                      CL_Color(0, 0, 0),
-                                      CL_Color(255, 255, 255)));
-
-    CL_Display::pop_modelview();
-  }
-
-  void update_pointer(const CL_InputEvent& event)
-  {
-    alpha = 1.0f - (Math::mid(0.0f, float(event.mouse_pos.x) / get_width(), 1.0f));
-    on_color_change(alpha);
-  }
-
-  void on_mouse_up(const CL_InputEvent& event)
-  {
-    if (event.id == CL_MOUSE_LEFT)
-      {
-        pressed = false;
-        release_mouse();
-        update_pointer(event);
-      }
-  }
-
-  void on_mouse_down(const CL_InputEvent& event)
-  {
-    if (event.id == CL_MOUSE_LEFT)
-      {
-        pressed = true;
-        capture_mouse();
-        update_pointer(event);
-      }
-  }
-
-  void on_mouse_move(const CL_InputEvent& event)
-  {
-    if (pressed)
-      {
-        update_pointer(event);    
-      }
-  }
-};
-
-class ColorPickerBrightness : public CL_Component
-{
-public:
-  std::vector<CL_Slot> slots;
-  CL_Color color;
-  bool pressed;
-  CL_Signal_v1<CL_Color> on_color_change;
-  float factor_x;
-  float factor_y;
-  ColorPickerBrightness(const CL_Rect& rect, CL_Component* parent) 
-    : CL_Component(rect, parent),
-      pressed(false),
-      factor_x(1.0f),
-      factor_y(1.0f)
-  {
-    color = CL_Color(255, 0, 0);
-    slots.push_back(sig_paint().connect(this, &ColorPickerBrightness::draw));
-
-    slots.push_back(sig_mouse_down().connect(this, &ColorPickerBrightness::on_mouse_down));
-    slots.push_back(sig_mouse_up().connect(this, &ColorPickerBrightness::on_mouse_up));
-    slots.push_back(sig_mouse_move().connect(this, &ColorPickerBrightness::on_mouse_move));
-  }
-
-  void draw()
-  {
-    CL_Display::push_modelview();
-    CL_Display::add_translate(get_screen_x(), get_screen_y());
-
-    CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
-                                  CL_Size(get_width(), get_height())),
-                          CL_Gradient(CL_Color(0, 0, 0),
-                                      color,
-                                      CL_Color(0, 0, 0),
-                                      CL_Color(255, 255, 255)));
-
-    CL_Display::draw_line(factor_x * get_width(),
-                          0,
-                          factor_x * get_width(),
-                          get_height(),
-                          CL_Color(255, 255, 255));
-
-    CL_Display::draw_line(0,
-                          factor_y * get_height(),
-                          get_width(),
-                          factor_y * get_height(),
-                          CL_Color(255, 255, 255));
-
-    CL_Display::pop_modelview();
-  }
-
-  void set_color(CL_Color color_) {
-    color = color_;
-    update_color();
-  }
-
-  void update_color()
-  {
-    CL_Color new_color(Math::mid(0, int(factor_x * color.get_red()   * (1.0f - factor_y) + factor_x * 255 * (factor_y)), 255),
-                       Math::mid(0, int(factor_x * color.get_green() * (1.0f - factor_y) + factor_x * 255 * (factor_y)), 255),   
-                       Math::mid(0, int(factor_x * color.get_blue()  * (1.0f - factor_y) + factor_x * 255 * (factor_y)), 255),
-                       color.get_alpha());
-    on_color_change(new_color);
-    /*
-    std::cout << new_color.get_red() << ", "
-              << new_color.get_green() << ", "
-              << new_color.get_blue() << ", "
-              << new_color.get_alpha()
-              << std::endl;
-    */
-  }
-
-  void update_pointer(const CL_InputEvent& event)
-  {
-    factor_x = Math::mid(0.0f, float(event.mouse_pos.x)/get_width(), 1.0f);
-    factor_y = Math::mid(0.0f, float(event.mouse_pos.y)/get_height(), 1.0f);
-
-    update_color();
-  }
-
-  void on_mouse_up(const CL_InputEvent& event)
-  {
-    if (event.id == CL_MOUSE_LEFT)
-      {
-        pressed = false;
-        release_mouse();
-        update_pointer(event);
-      }    
-  }
-
-  void on_mouse_down(const CL_InputEvent& event)
-  {
-    if (event.id == CL_MOUSE_LEFT)
-      {
-        pressed = true;
-        capture_mouse();
-        update_pointer(event);
-      }
-  }
-
-  void on_mouse_move(const CL_InputEvent& event)
-  {
-    if (pressed)
-      {
-        update_pointer(event);
-      }
-  }
-};
-
-ColorPicker::ColorPicker(const CL_Rect& rect, CL_Component* parent)
-  : CL_Component(rect, parent)
-{
-  float pwidth  = rect.get_width()/11.0;
-  float pheight = rect.get_height()/11.0;
-
-  brightness = new ColorPickerBrightness(CL_Rect(CL_Point(0, 0),
-                                                 CL_Size(int(pwidth*10), int(pheight*10))), 
-                                         this);
-  
-  hue        = new ColorPickerHue(CL_Rect(CL_Point(int(pwidth*10), 0),
-                                          CL_Size(int(pwidth*1), int(pheight*10))),
-                                  this);
-
-  alpha      = new ColorPickerAlpha(CL_Rect(CL_Point(0, int(pheight*10)),
-                                            CL_Size(int(pwidth*10), int(pheight*1))),
-                                    this);
-
-  slots.push_back(hue->on_color_change.connect(brightness, &ColorPickerBrightness::set_color));
-  slots.push_back(brightness->on_color_change.connect(this, &ColorPicker::update_brightness_color));
-  slots.push_back(alpha->on_color_change.connect(this, &ColorPicker::update_alpha_color));
-  slots.push_back(sig_paint().connect(this, &ColorPicker::draw));
-
-  brightness->set_color(CL_Color(255, 0, 0));
-  alpha->set_alpha(0.5f);
-}
-
-void
-ColorPicker::update_alpha_color(float alpha)
-{
-  color.set_alpha(int(255 * alpha));
-  on_color_change(color);  
-}
-
-void
-ColorPicker::update_brightness_color(CL_Color color_)
-{
-  color.set_red(color_.get_red());
-  color.set_green(color_.get_green());
-  color.set_blue(color_.get_blue());
-  on_color_change(color);
-}
-
-void
-ColorPicker::draw()
-{
-  CL_Display::push_modelview();
-  CL_Display::add_translate(get_screen_x(), get_screen_y());
-  
-  float pwidth  = get_width()/11.0;
-  float pheight = get_height()/11.0;
-  CL_Display::fill_rect(CL_Rect(CL_Point(int(pwidth*10), int(pheight*10)),
-                                CL_Size(int(pwidth), int(pheight))),
-                        color);
-
-  CL_Display::pop_modelview();
-}
-
-CL_Signal_v1<CL_Color>&
-ColorPicker::sig_color_change()
-{
-  return on_color_change;
-}
-
-CL_Color
-ColorPicker::get_color()
-{
-  return color;
-}
-
-void
-ColorPicker::set_color(const CL_Color& color_)
-{
-  color = color_;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/colorpicker.hpp (from rev 712, trunk/flexlay/lib/colorpicker.hxx)

Deleted: trunk/flexlay/lib/colorpicker.hxx
===================================================================
--- trunk/flexlay/lib/colorpicker.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/colorpicker.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,59 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_COLORPICKER_HXX
-#define HEADER_COLORPICKER_HXX
-
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/color.h>
-#include <ClanLib/Display/gradient.h>
-
-class ColorPickerHue;
-class ColorPickerAlpha;
-class ColorPickerBrightness;
-
-/** */
-class ColorPicker : public CL_Component
-{
-protected:
-  ~ColorPicker() {}
-private:
-  CL_Signal_v1<CL_Color> on_color_change;
-  std::vector<CL_Slot> slots;
-  CL_Color color;
-
-  ColorPickerHue*     hue;
-  ColorPickerBrightness* brightness;
-  ColorPickerAlpha*      alpha;
-
-  void update_brightness_color(CL_Color color);
-  void update_alpha_color(float alpha);
-public:
-  ColorPicker(const CL_Rect& rect, CL_Component* parent);
-  
-  void draw();
-
-  CL_Signal_v1<CL_Color>& sig_color_change();
-
-  CL_Color get_color();
-  void set_color(const CL_Color& color);
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/command.cpp (from rev 712, trunk/flexlay/lib/command.cxx)
===================================================================
--- trunk/flexlay/lib/command.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/command.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,55 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <string>
+#include "command.hpp"
+
+Command::Command()
+{
+}
+
+Command::Command(const SharedPtr<CommandImpl>& impl_)
+  : impl(impl_)
+{
+}
+
+void
+Command::execute()
+{
+  impl->execute();
+}
+  
+void
+Command::redo()
+{
+  impl->redo();
+}
+
+void
+Command::undo()
+{
+  impl->undo();
+}
+
+std::string
+Command::serialize()
+{
+  return impl->serialize();
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/command.cxx
===================================================================
--- trunk/flexlay/lib/command.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/command.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,55 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <string>
-#include "command.hxx"
-
-Command::Command()
-{
-}
-
-Command::Command(const SharedPtr<CommandImpl>& impl_)
-  : impl(impl_)
-{
-}
-
-void
-Command::execute()
-{
-  impl->execute();
-}
-  
-void
-Command::redo()
-{
-  impl->redo();
-}
-
-void
-Command::undo()
-{
-  impl->undo();
-}
-
-std::string
-Command::serialize()
-{
-  return impl->serialize();
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/command.hpp (from rev 712, trunk/flexlay/lib/command.hxx)
===================================================================
--- trunk/flexlay/lib/command.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/command.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,55 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_COMMAND_HXX
+#define HEADER_COMMAND_HXX
+
+#include <iosfwd>
+#include "shared_ptr.hpp"
+#include "command_impl.hpp"
+
+/** Command is an abstract base class for all data manipulating
+    operations on EditorLayer or even EditorMap metedata. Each Command
+    that manipulates data must provide a way to undo and redo the
+    operations. */
+class Command
+{
+private:
+public:
+  Command();
+  Command(const SharedPtr<CommandImpl>& impl_);
+
+  /** Execute the command */
+  void execute();
+  
+  /** Execute the command a second time after the command got
+      undo'ed */
+  void redo();
+
+  /** Undo the effects caused by execute() */
+  void undo();
+
+  std::string serialize();
+
+private:
+  SharedPtr<CommandImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/command.hxx
===================================================================
--- trunk/flexlay/lib/command.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/command.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,55 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_COMMAND_HXX
-#define HEADER_COMMAND_HXX
-
-#include <iosfwd>
-#include "shared_ptr.hxx"
-#include "command_impl.hxx"
-
-/** Command is an abstract base class for all data manipulating
-    operations on EditorLayer or even EditorMap metedata. Each Command
-    that manipulates data must provide a way to undo and redo the
-    operations. */
-class Command
-{
-private:
-public:
-  Command();
-  Command(const SharedPtr<CommandImpl>& impl_);
-
-  /** Execute the command */
-  void execute();
-  
-  /** Execute the command a second time after the command got
-      undo'ed */
-  void redo();
-
-  /** Undo the effects caused by execute() */
-  void undo();
-
-  std::string serialize();
-
-private:
-  SharedPtr<CommandImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/command_group.cpp (from rev 712, trunk/flexlay/lib/command_group.cxx)
===================================================================
--- trunk/flexlay/lib/command_group.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/command_group.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,62 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "command_group.hpp"
+
+class CommandGroupImpl : public CommandImpl
+{
+public:
+};
+
+CommandGroup::CommandGroup()
+{
+  
+}
+
+CommandGroup::~CommandGroup()
+{
+}
+  
+void
+CommandGroup::add_command(Command* c)
+{
+  commands.push_back(c);
+}
+
+void
+CommandGroup::execute()
+{
+  for(Commands::iterator i = commands.begin(); i != commands.end(); ++i)
+    (*i)->execute();    
+}
+
+void
+CommandGroup::undo()
+{
+  for(Commands::iterator i = commands.begin(); i != commands.end(); ++i)
+    (*i)->undo();
+}
+
+void
+CommandGroup::redo()
+{
+  for(Commands::iterator i = commands.begin(); i != commands.end(); ++i)
+    (*i)->redo();
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/command_group.cxx
===================================================================
--- trunk/flexlay/lib/command_group.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/command_group.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,62 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "command_group.hxx"
-
-class CommandGroupImpl : public CommandImpl
-{
-public:
-};
-
-CommandGroup::CommandGroup()
-{
-  
-}
-
-CommandGroup::~CommandGroup()
-{
-}
-  
-void
-CommandGroup::add_command(Command* c)
-{
-  commands.push_back(c);
-}
-
-void
-CommandGroup::execute()
-{
-  for(Commands::iterator i = commands.begin(); i != commands.end(); ++i)
-    (*i)->execute();    
-}
-
-void
-CommandGroup::undo()
-{
-  for(Commands::iterator i = commands.begin(); i != commands.end(); ++i)
-    (*i)->undo();
-}
-
-void
-CommandGroup::redo()
-{
-  for(Commands::iterator i = commands.begin(); i != commands.end(); ++i)
-    (*i)->redo();
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/command_group.hpp (from rev 712, trunk/flexlay/lib/command_group.hxx)
===================================================================
--- trunk/flexlay/lib/command_group.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/command_group.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,44 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_COMMAND_GROUP_HXX
+#define HEADER_COMMAND_GROUP_HXX
+
+#include <vector>
+#include "command.hpp"
+
+/** */
+class CommandGroup
+{
+private:
+  typedef std::vector<Command*> Commands;
+  Commands commands;
+public:
+  CommandGroup();
+  virtual ~CommandGroup();
+
+  void add_command(Command* c);
+  
+  void execute();
+  void undo();
+  void redo();
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/command_group.hxx
===================================================================
--- trunk/flexlay/lib/command_group.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/command_group.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,44 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_COMMAND_GROUP_HXX
-#define HEADER_COMMAND_GROUP_HXX
-
-#include <vector>
-#include "command.hxx"
-
-/** */
-class CommandGroup
-{
-private:
-  typedef std::vector<Command*> Commands;
-  Commands commands;
-public:
-  CommandGroup();
-  virtual ~CommandGroup();
-
-  void add_command(Command* c);
-  
-  void execute();
-  void undo();
-  void redo();
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/command_impl.hpp (from rev 712, trunk/flexlay/lib/command_impl.hxx)

Deleted: trunk/flexlay/lib/command_impl.hxx
===================================================================
--- trunk/flexlay/lib/command_impl.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/command_impl.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,43 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-#ifndef HEADER_COMMAND_IMPL_HXX
-#define HEADER_COMMAND_IMPL_HXX
-
-/** */
-class CommandImpl
-{
-private:
-public:
-  virtual ~CommandImpl() {}
-
-  /** Execute the command */
-  virtual void execute() =0;
-
-  /** Execute the command a second time after the command got
-      undo'ed */
-  virtual void redo() =0;
-
-  /** Undo the effects caused by execute() */
-  virtual void undo() =0;
-
-  virtual std::string serialize() =0;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/console.cpp (from rev 712, trunk/flexlay/lib/console.cxx)
===================================================================
--- trunk/flexlay/lib/console.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/console.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,127 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include <ClanLib/Display/font.h>
+#include "fonts.hpp"
+#include "field.hpp"
+#include "console.hpp"
+
+class ConsoleImpl
+{
+public:
+  std::vector<CL_Slot> slots;
+
+  CL_Size size;
+
+  /** Complete log of everything that got written to the console */
+  std::string full_buffer;
+
+  /** Buffer of the stuff currently visible on the screen */
+  Field<char> screen;
+
+  CL_Point cursor_pos;
+
+  CL_Font font;
+
+  ConsoleImpl(int w, int h);
+  void putchar(char c);
+  void draw();
+};
+
+ConsoleImpl::ConsoleImpl(int w, int h)
+  : size(w, h),
+    screen(w, h),
+    cursor_pos(0, 0)
+{
+}
+
+void
+ConsoleImpl::draw()
+{
+  //std::cout << "ConsoleImpl::draw()" << std::endl;
+
+  int font_w = font.get_width("W");
+  int font_h = font.get_height();
+
+  for(int y = 0; y < size.height; ++y)
+    for(int x = 0; x < size.width; ++x)
+      {
+        font.draw_character(x * font_w, y * font_h, screen.at(x, y));
+      }
+}
+
+Console::Console(/*const CL_Font& font,*/ const CL_Rect& rect, CL_Component* parent)
+  : CL_Component(rect, parent),
+    impl(new ConsoleImpl(40, 24))
+{
+  impl->font = Fonts::verdana11_yellow;
+  impl->slots.push_back(sig_paint().connect(impl.get(), &ConsoleImpl::draw));
+}
+
+Console::~Console()
+{
+  
+}
+
+void
+Console::clearscr()
+{
+  for(int y = 0; y < impl->size.height; ++y)
+    for(int x = 0; x < impl->size.width; ++x)
+      impl->screen.at(x, y) = 0;
+}
+
+void
+ConsoleImpl::putchar(char c)
+{
+  full_buffer += c; 
+
+  if (c == '\n')
+    {
+      cursor_pos.x = 0;
+      cursor_pos.y += 1;
+    }
+  else
+    {
+      screen.at(cursor_pos.x, cursor_pos.y) = c;
+
+      cursor_pos.x += 1;
+
+      if (cursor_pos.x >= size.width)
+        cursor_pos.x = 0;
+    }
+
+  // Move all content one line up
+  if (cursor_pos.y >= size.height)
+    screen.resize(size.width, size.height, 0, -1);
+}
+
+void
+Console::write(const std::string& str)
+{
+  std::cout << str << std::flush;
+
+  for(std::string::const_iterator i = str.begin(); i != str.end(); ++i)
+    {
+      if (*i != 0)
+        impl->putchar(*i);
+    }
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/console.cxx
===================================================================
--- trunk/flexlay/lib/console.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/console.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,127 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <ClanLib/Display/font.h>
-#include "fonts.hxx"
-#include "field.hxx"
-#include "console.hxx"
-
-class ConsoleImpl
-{
-public:
-  std::vector<CL_Slot> slots;
-
-  CL_Size size;
-
-  /** Complete log of everything that got written to the console */
-  std::string full_buffer;
-
-  /** Buffer of the stuff currently visible on the screen */
-  Field<char> screen;
-
-  CL_Point cursor_pos;
-
-  CL_Font font;
-
-  ConsoleImpl(int w, int h);
-  void putchar(char c);
-  void draw();
-};
-
-ConsoleImpl::ConsoleImpl(int w, int h)
-  : size(w, h),
-    screen(w, h),
-    cursor_pos(0, 0)
-{
-}
-
-void
-ConsoleImpl::draw()
-{
-  //std::cout << "ConsoleImpl::draw()" << std::endl;
-
-  int font_w = font.get_width("W");
-  int font_h = font.get_height();
-
-  for(int y = 0; y < size.height; ++y)
-    for(int x = 0; x < size.width; ++x)
-      {
-        font.draw_character(x * font_w, y * font_h, screen.at(x, y));
-      }
-}
-
-Console::Console(/*const CL_Font& font,*/ const CL_Rect& rect, CL_Component* parent)
-  : CL_Component(rect, parent),
-    impl(new ConsoleImpl(40, 24))
-{
-  impl->font = Fonts::verdana11_yellow;
-  impl->slots.push_back(sig_paint().connect(impl.get(), &ConsoleImpl::draw));
-}
-
-Console::~Console()
-{
-  
-}
-
-void
-Console::clearscr()
-{
-  for(int y = 0; y < impl->size.height; ++y)
-    for(int x = 0; x < impl->size.width; ++x)
-      impl->screen.at(x, y) = 0;
-}
-
-void
-ConsoleImpl::putchar(char c)
-{
-  full_buffer += c; 
-
-  if (c == '\n')
-    {
-      cursor_pos.x = 0;
-      cursor_pos.y += 1;
-    }
-  else
-    {
-      screen.at(cursor_pos.x, cursor_pos.y) = c;
-
-      cursor_pos.x += 1;
-
-      if (cursor_pos.x >= size.width)
-        cursor_pos.x = 0;
-    }
-
-  // Move all content one line up
-  if (cursor_pos.y >= size.height)
-    screen.resize(size.width, size.height, 0, -1);
-}
-
-void
-Console::write(const std::string& str)
-{
-  std::cout << str << std::flush;
-
-  for(std::string::const_iterator i = str.begin(); i != str.end(); ++i)
-    {
-      if (*i != 0)
-        impl->putchar(*i);
-    }
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/console.hpp (from rev 712, trunk/flexlay/lib/console.hxx)
===================================================================
--- trunk/flexlay/lib/console.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/console.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,46 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_CONSOLE_HXX
+#define HEADER_CONSOLE_HXX
+
+#include <ClanLib/GUI/component.h>
+#include "shared_ptr.hpp"
+
+class CL_Font;
+class CL_Size;
+class ConsoleImpl;
+
+/** */
+class Console : public CL_Component
+{
+protected:
+  virtual ~Console();
+public:
+  Console(/*const CL_Font& font, */const CL_Rect& rect, CL_Component* parent);
+
+  /** Write something to the console */
+  void write(const std::string& );
+  void clearscr();
+private:
+  SharedPtr<ConsoleImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/console.hxx
===================================================================
--- trunk/flexlay/lib/console.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/console.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,46 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_CONSOLE_HXX
-#define HEADER_CONSOLE_HXX
-
-#include <ClanLib/GUI/component.h>
-#include "shared_ptr.hxx"
-
-class CL_Font;
-class CL_Size;
-class ConsoleImpl;
-
-/** */
-class Console : public CL_Component
-{
-protected:
-  virtual ~Console();
-public:
-  Console(/*const CL_Font& font, */const CL_Rect& rect, CL_Component* parent);
-
-  /** Write something to the console */
-  void write(const std::string& );
-  void clearscr();
-private:
-  SharedPtr<ConsoleImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/directory_view.cpp (from rev 712, trunk/flexlay/lib/directory_view.cxx)
===================================================================
--- trunk/flexlay/lib/directory_view.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/directory_view.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,209 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <assert.h>
+#include <ClanLib/Core/Math/rect.h>
+#include <ClanLib/Core/IOData/directory_scanner.h>
+#include <ClanLib/Display/font.h>
+#include <ClanLib/Display/display.h>
+#include "fonts.hpp"
+#include "directory_view.hpp"
+
+class DirectoryViewEntry
+{
+public:
+  std::string name;
+  bool directory;
+  bool hidden;
+};
+
+struct DirectoryViewSorter
+{
+  bool operator()(const DirectoryViewEntry& lhs, const DirectoryViewEntry& rhs)
+  {
+    if (lhs.directory > rhs.directory)
+      return true;
+    else if (lhs.directory < rhs.directory)
+      return false;
+    else
+      return lhs.name < rhs.name;
+  }
+};
+
+class DirectoryViewImpl
+{
+public:
+  DirectoryView* parent;
+
+  std::vector<CL_Slot> slots;
+
+  std::string path;
+  CL_Signal_v1<std::string> sig_on_click;
+  typedef std::vector<DirectoryViewEntry> Items;
+  Items items;
+  int current_item;
+  int column_width;
+  int num_columns;
+
+  void update_items();
+  void draw();
+  int get_item(const CL_Point& pos);
+  void on_mouse_move(const CL_InputEvent& event);
+  void on_mouse_down(const CL_InputEvent& event);
+};
+
+DirectoryView::DirectoryView(const CL_Rect& rect, CL_Component* parent)
+  : CL_Component(rect, parent),
+    impl(new DirectoryViewImpl())
+{ 
+  impl->parent = this;
+
+  //  impl->slots.push_back(sig_mouse_down().connect(impl.get(), &DirectoryViewImpl::draw));
+  impl->slots.push_back(sig_paint().connect(impl.get(), &DirectoryViewImpl::draw));
+  impl->slots.push_back(sig_mouse_move().connect(impl.get(), &DirectoryViewImpl::on_mouse_move));
+  impl->slots.push_back(sig_mouse_down().connect(impl.get(), &DirectoryViewImpl::on_mouse_down));
+
+  impl->current_item = -1;
+}
+
+DirectoryView::~DirectoryView()
+{
+}
+
+void
+DirectoryView::set_directory(const std::string& path_)
+{
+  impl->path = path_;
+  impl->update_items();
+}
+
+CL_Signal_v1<std::string>&
+DirectoryView::sig_on_click()
+{
+  return impl->sig_on_click;
+}
+
+void 
+DirectoryViewImpl::draw()
+{
+  CL_Font font = Fonts::verdana11; 
+
+  int horizontal_spacing = 10;
+  int vertical_spacing   = 5;
+  int x_pos = 0;
+  int y_pos = 0;
+
+  CL_Display::clear(CL_Color(255, 255, 0));
+
+  int j = 0;
+  for(Items::iterator i = items.begin(); i != items.begin()+50 && i != items.end(); ++i)
+    {
+      if (current_item && current_item < int(items.size()) && j == current_item)
+        {
+          CL_Rect rect = font.bounding_rect(x_pos * (column_width + horizontal_spacing) + 1, 
+                                            y_pos * (font.get_height() + vertical_spacing) + 1,
+                                            i->name);
+          CL_Display::fill_rect(CL_Rect(rect.left-5, rect.top-3,
+                                        rect.left+5+column_width, rect.bottom+3),
+                                CL_Color(250, 200, 0));
+        }
+
+      // draw item
+      if (!i->directory)
+        {
+          font.draw(x_pos * (column_width + horizontal_spacing), 
+                    y_pos * (font.get_height() + vertical_spacing),
+                    i->name);
+        }
+      else
+        {
+          font.draw(x_pos * (column_width + horizontal_spacing), 
+                    y_pos * (font.get_height() + vertical_spacing),
+                    "[" + i->name + "]");
+        }
+
+      x_pos += 1;
+      if (x_pos >= num_columns)
+        {
+          x_pos = 0;
+          y_pos += 1;
+        }
+      ++j;
+    }
+}
+
+int
+DirectoryViewImpl::get_item(const CL_Point& pos)
+{
+  CL_Font font = Fonts::verdana11; 
+
+  int horizontal_spacing = 10;
+  int vertical_spacing   = 5;
+
+  return (pos.x / (column_width + horizontal_spacing))
+    + num_columns * (pos.y / (font.get_height() + vertical_spacing));    
+}
+
+void 
+DirectoryViewImpl::on_mouse_down(const CL_InputEvent& event)
+{
+  current_item = get_item(event.mouse_pos);
+  if (current_item >= 0 && current_item < int(items.size()))
+    {
+      if (items[current_item].directory)
+      parent->set_directory(path + "/" + items[current_item].name);
+    }
+}
+
+void 
+DirectoryViewImpl::on_mouse_move(const CL_InputEvent& event)
+{
+  current_item = get_item(event.mouse_pos);
+}
+
+void
+DirectoryViewImpl::update_items()
+{
+  items.clear();
+  CL_DirectoryScanner scanner;
+
+  scanner.scan(path);
+  while(scanner.next())
+    {
+      DirectoryViewEntry entry;
+      entry.name = scanner.get_name();
+      entry.hidden = (scanner.get_name()[0] == '.');
+      entry.directory = scanner.is_directory();
+      items.push_back(entry);
+    }
+
+  std::sort(items.begin(), items.end(), DirectoryViewSorter());
+
+  CL_Font font = Fonts::verdana11; 
+
+  column_width = 60; // min_colum_width
+  for(Items::iterator i = items.begin(); i != items.end(); ++i)
+    {
+      CL_Rect rect = font.bounding_rect(0, 0, i->name + "[]");
+      column_width = std::max(column_width, rect.get_width());
+    }
+
+  num_columns = parent->get_width()/column_width;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/directory_view.cxx
===================================================================
--- trunk/flexlay/lib/directory_view.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/directory_view.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,209 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <assert.h>
-#include <ClanLib/Core/Math/rect.h>
-#include <ClanLib/Core/IOData/directory_scanner.h>
-#include <ClanLib/Display/font.h>
-#include <ClanLib/Display/display.h>
-#include "fonts.hxx"
-#include "directory_view.hxx"
-
-class DirectoryViewEntry
-{
-public:
-  std::string name;
-  bool directory;
-  bool hidden;
-};
-
-struct DirectoryViewSorter
-{
-  bool operator()(const DirectoryViewEntry& lhs, const DirectoryViewEntry& rhs)
-  {
-    if (lhs.directory > rhs.directory)
-      return true;
-    else if (lhs.directory < rhs.directory)
-      return false;
-    else
-      return lhs.name < rhs.name;
-  }
-};
-
-class DirectoryViewImpl
-{
-public:
-  DirectoryView* parent;
-
-  std::vector<CL_Slot> slots;
-
-  std::string path;
-  CL_Signal_v1<std::string> sig_on_click;
-  typedef std::vector<DirectoryViewEntry> Items;
-  Items items;
-  int current_item;
-  int column_width;
-  int num_columns;
-
-  void update_items();
-  void draw();
-  int get_item(const CL_Point& pos);
-  void on_mouse_move(const CL_InputEvent& event);
-  void on_mouse_down(const CL_InputEvent& event);
-};
-
-DirectoryView::DirectoryView(const CL_Rect& rect, CL_Component* parent)
-  : CL_Component(rect, parent),
-    impl(new DirectoryViewImpl())
-{ 
-  impl->parent = this;
-
-  //  impl->slots.push_back(sig_mouse_down().connect(impl.get(), &DirectoryViewImpl::draw));
-  impl->slots.push_back(sig_paint().connect(impl.get(), &DirectoryViewImpl::draw));
-  impl->slots.push_back(sig_mouse_move().connect(impl.get(), &DirectoryViewImpl::on_mouse_move));
-  impl->slots.push_back(sig_mouse_down().connect(impl.get(), &DirectoryViewImpl::on_mouse_down));
-
-  impl->current_item = -1;
-}
-
-DirectoryView::~DirectoryView()
-{
-}
-
-void
-DirectoryView::set_directory(const std::string& path_)
-{
-  impl->path = path_;
-  impl->update_items();
-}
-
-CL_Signal_v1<std::string>&
-DirectoryView::sig_on_click()
-{
-  return impl->sig_on_click;
-}
-
-void 
-DirectoryViewImpl::draw()
-{
-  CL_Font font = Fonts::verdana11; 
-
-  int horizontal_spacing = 10;
-  int vertical_spacing   = 5;
-  int x_pos = 0;
-  int y_pos = 0;
-
-  CL_Display::clear(CL_Color(255, 255, 0));
-
-  int j = 0;
-  for(Items::iterator i = items.begin(); i != items.begin()+50 && i != items.end(); ++i)
-    {
-      if (current_item && current_item < int(items.size()) && j == current_item)
-        {
-          CL_Rect rect = font.bounding_rect(x_pos * (column_width + horizontal_spacing) + 1, 
-                                            y_pos * (font.get_height() + vertical_spacing) + 1,
-                                            i->name);
-          CL_Display::fill_rect(CL_Rect(rect.left-5, rect.top-3,
-                                        rect.left+5+column_width, rect.bottom+3),
-                                CL_Color(250, 200, 0));
-        }
-
-      // draw item
-      if (!i->directory)
-        {
-          font.draw(x_pos * (column_width + horizontal_spacing), 
-                    y_pos * (font.get_height() + vertical_spacing),
-                    i->name);
-        }
-      else
-        {
-          font.draw(x_pos * (column_width + horizontal_spacing), 
-                    y_pos * (font.get_height() + vertical_spacing),
-                    "[" + i->name + "]");
-        }
-
-      x_pos += 1;
-      if (x_pos >= num_columns)
-        {
-          x_pos = 0;
-          y_pos += 1;
-        }
-      ++j;
-    }
-}
-
-int
-DirectoryViewImpl::get_item(const CL_Point& pos)
-{
-  CL_Font font = Fonts::verdana11; 
-
-  int horizontal_spacing = 10;
-  int vertical_spacing   = 5;
-
-  return (pos.x / (column_width + horizontal_spacing))
-    + num_columns * (pos.y / (font.get_height() + vertical_spacing));    
-}
-
-void 
-DirectoryViewImpl::on_mouse_down(const CL_InputEvent& event)
-{
-  current_item = get_item(event.mouse_pos);
-  if (current_item >= 0 && current_item < int(items.size()))
-    {
-      if (items[current_item].directory)
-      parent->set_directory(path + "/" + items[current_item].name);
-    }
-}
-
-void 
-DirectoryViewImpl::on_mouse_move(const CL_InputEvent& event)
-{
-  current_item = get_item(event.mouse_pos);
-}
-
-void
-DirectoryViewImpl::update_items()
-{
-  items.clear();
-  CL_DirectoryScanner scanner;
-
-  scanner.scan(path);
-  while(scanner.next())
-    {
-      DirectoryViewEntry entry;
-      entry.name = scanner.get_name();
-      entry.hidden = (scanner.get_name()[0] == '.');
-      entry.directory = scanner.is_directory();
-      items.push_back(entry);
-    }
-
-  std::sort(items.begin(), items.end(), DirectoryViewSorter());
-
-  CL_Font font = Fonts::verdana11; 
-
-  column_width = 60; // min_colum_width
-  for(Items::iterator i = items.begin(); i != items.end(); ++i)
-    {
-      CL_Rect rect = font.bounding_rect(0, 0, i->name + "[]");
-      column_width = std::max(column_width, rect.get_width());
-    }
-
-  num_columns = parent->get_width()/column_width;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/directory_view.hpp (from rev 712, trunk/flexlay/lib/directory_view.hxx)
===================================================================
--- trunk/flexlay/lib/directory_view.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/directory_view.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,48 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_DIRECTORY_VIEW_HXX
+#define HEADER_DIRECTORY_VIEW_HXX
+
+#include <ClanLib/GUI/component.h>
+#include "shared_ptr.hpp"
+
+class DirectoryViewImpl;
+
+/** */
+class DirectoryView : public CL_Component
+{
+private:
+protected:
+  virtual ~DirectoryView();
+public:
+  DirectoryView(const CL_Rect& rect, CL_Component* parent);
+
+  /** Set the directory which should be shown */
+  void set_directory(const std::string& path_);
+
+  /** Call the callback on click on a directory item */
+  CL_Signal_v1<std::string>& sig_on_click();
+
+private:
+  SharedPtr<DirectoryViewImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/directory_view.hxx
===================================================================
--- trunk/flexlay/lib/directory_view.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/directory_view.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,48 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_DIRECTORY_VIEW_HXX
-#define HEADER_DIRECTORY_VIEW_HXX
-
-#include <ClanLib/GUI/component.h>
-#include "shared_ptr.hxx"
-
-class DirectoryViewImpl;
-
-/** */
-class DirectoryView : public CL_Component
-{
-private:
-protected:
-  virtual ~DirectoryView();
-public:
-  DirectoryView(const CL_Rect& rect, CL_Component* parent);
-
-  /** Set the directory which should be shown */
-  void set_directory(const std::string& path_);
-
-  /** Call the callback on click on a directory item */
-  CL_Signal_v1<std::string>& sig_on_click();
-
-private:
-  SharedPtr<DirectoryViewImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/drawer_properties.cpp (from rev 712, trunk/flexlay/lib/drawer_properties.cxx)
===================================================================
--- trunk/flexlay/lib/drawer_properties.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/drawer_properties.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,99 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "drawer_properties.hpp"
+
+DrawerProperties* DrawerProperties::current_ = 0;
+
+class DrawerPropertiesImpl
+{
+public:
+  CL_Color  color;
+  float     base_size;
+  float     spacing;
+  Brush     brush;
+};
+
+DrawerProperties*
+DrawerProperties::current()
+{
+  if (!current_)
+    return (current_ = new DrawerProperties());
+  else
+    return current_;
+}
+
+DrawerProperties::DrawerProperties()
+  : impl(new DrawerPropertiesImpl())
+{
+  impl->color     = CL_Color(255, 255, 255, 255);
+  impl->base_size = 1.0f;
+    
+  impl->base_size = 1.0f;
+  impl->spacing   = 15.0f;
+}
+
+void
+DrawerProperties::set_spacing(float spacing_)
+{
+  impl->spacing = spacing_;
+}
+
+float
+DrawerProperties::get_spacing() const
+{
+  return impl->spacing;
+}
+
+void
+DrawerProperties::set_size(float s)
+{
+  impl->base_size = s;
+}
+
+float
+DrawerProperties::get_size() const
+{
+  return impl->base_size;
+}
+
+void
+DrawerProperties::set_color(const CL_Color& color_)
+{
+  impl->color = color_;
+}
+
+CL_Color
+DrawerProperties::get_color() const
+{
+  return impl->color;
+}
+
+void
+DrawerProperties::set_brush(const Brush& brush)
+{
+  impl->brush = brush;
+}
+
+Brush
+DrawerProperties::get_brush() const
+{
+  return impl->brush;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/drawer_properties.cxx
===================================================================
--- trunk/flexlay/lib/drawer_properties.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/drawer_properties.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,99 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "drawer_properties.hxx"
-
-DrawerProperties* DrawerProperties::current_ = 0;
-
-class DrawerPropertiesImpl
-{
-public:
-  CL_Color  color;
-  float     base_size;
-  float     spacing;
-  Brush     brush;
-};
-
-DrawerProperties*
-DrawerProperties::current()
-{
-  if (!current_)
-    return (current_ = new DrawerProperties());
-  else
-    return current_;
-}
-
-DrawerProperties::DrawerProperties()
-  : impl(new DrawerPropertiesImpl())
-{
-  impl->color     = CL_Color(255, 255, 255, 255);
-  impl->base_size = 1.0f;
-    
-  impl->base_size = 1.0f;
-  impl->spacing   = 15.0f;
-}
-
-void
-DrawerProperties::set_spacing(float spacing_)
-{
-  impl->spacing = spacing_;
-}
-
-float
-DrawerProperties::get_spacing() const
-{
-  return impl->spacing;
-}
-
-void
-DrawerProperties::set_size(float s)
-{
-  impl->base_size = s;
-}
-
-float
-DrawerProperties::get_size() const
-{
-  return impl->base_size;
-}
-
-void
-DrawerProperties::set_color(const CL_Color& color_)
-{
-  impl->color = color_;
-}
-
-CL_Color
-DrawerProperties::get_color() const
-{
-  return impl->color;
-}
-
-void
-DrawerProperties::set_brush(const Brush& brush)
-{
-  impl->brush = brush;
-}
-
-Brush
-DrawerProperties::get_brush() const
-{
-  return impl->brush;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/drawer_properties.hpp (from rev 712, trunk/flexlay/lib/drawer_properties.hxx)
===================================================================
--- trunk/flexlay/lib/drawer_properties.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/drawer_properties.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,64 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_DRAWER_PROPERTIES_HXX
+#define HEADER_DRAWER_PROPERTIES_HXX
+
+#include <ClanLib/Display/color.h>
+#include "brush.hpp"
+
+class DrawerPropertiesImpl;
+
+/** */
+class DrawerProperties
+{
+private:
+  static DrawerProperties* current_;
+public:
+  static DrawerProperties* current();
+
+  DrawerProperties();
+
+  /** Set the spacing that will be between the sprites that are drawn
+      along the dabs */
+  void  set_spacing(float spacing);
+  float get_spacing() const;
+
+  /** Set the base size of the Sprite, the real size itself can be
+      affected by pressure and is than calculated by combining
+      basesize and pressure or tilting */
+  void  set_size(float s);
+  float get_size() const;
+
+  /** Set the base color, the real color itself is calculated from
+      combining the base color with the current pressure or tilting */
+  void     set_color(const CL_Color& color);
+  CL_Color get_color() const;
+
+  /** Set the brush to be used, its color and size settings are
+      ignored */
+  void  set_brush(const Brush& brush);
+  Brush get_brush() const;
+
+private:
+  SharedPtr<DrawerPropertiesImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/drawer_properties.hxx
===================================================================
--- trunk/flexlay/lib/drawer_properties.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/drawer_properties.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,64 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_DRAWER_PROPERTIES_HXX
-#define HEADER_DRAWER_PROPERTIES_HXX
-
-#include <ClanLib/Display/color.h>
-#include "brush.hxx"
-
-class DrawerPropertiesImpl;
-
-/** */
-class DrawerProperties
-{
-private:
-  static DrawerProperties* current_;
-public:
-  static DrawerProperties* current();
-
-  DrawerProperties();
-
-  /** Set the spacing that will be between the sprites that are drawn
-      along the dabs */
-  void  set_spacing(float spacing);
-  float get_spacing() const;
-
-  /** Set the base size of the Sprite, the real size itself can be
-      affected by pressure and is than calculated by combining
-      basesize and pressure or tilting */
-  void  set_size(float s);
-  float get_size() const;
-
-  /** Set the base color, the real color itself is calculated from
-      combining the base color with the current pressure or tilting */
-  void     set_color(const CL_Color& color);
-  CL_Color get_color() const;
-
-  /** Set the brush to be used, its color and size settings are
-      ignored */
-  void  set_brush(const Brush& brush);
-  Brush get_brush() const;
-
-private:
-  SharedPtr<DrawerPropertiesImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/editor_map.cpp (from rev 712, trunk/flexlay/lib/editor_map.cxx)
===================================================================
--- trunk/flexlay/lib/editor_map.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/editor_map.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,281 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include <assert.h>
+#include <ClanLib/Core/core_iostream.h>
+#include <ClanLib/Display/display.h>
+#include <ClanLib/Display/keys.h>
+#include "editor_names.hpp"
+#include "editor_map.hpp"
+#include "editor_map_component.hpp"
+
+class EditorMapImpl
+{
+public:
+  /** Flag if the map got modified, used for 'Some maps are unsaved'
+      style massages */
+  bool modified;
+
+  /** Gets incremented with each map change so that other component
+      can update if required */
+  int serial;
+
+  typedef std::vector<Layer> Layers;
+  Layers layers;
+
+  CL_Color background_color;
+  CL_Color foreground_color;
+
+  /** Metadata attached to this map (ie. mapname, description, scripts, etc.) */
+  MetaData metadata;
+
+  typedef std::vector<Command> Commands;
+
+  Commands undo_stack;
+  Commands redo_stack;
+
+  CL_Signal_v0 on_change;
+
+  bool    has_bounding_rect;
+  CL_Rect bounding_rect;
+};
+
+EditorMap::EditorMap(bool create)
+  : impl(0)
+{
+  if (create)
+    {
+      impl = new EditorMapImpl();
+      impl->background_color = CL_Color(100, 80, 100);
+      impl->foreground_color = CL_Color(255, 80, 255);
+      impl->modified = false;
+      impl->serial = 0;
+      impl->has_bounding_rect = false;
+      impl->bounding_rect = CL_Rect(0,0,0,0);
+    }
+}
+
+void
+EditorMap::add_layer(const Layer& layer, int pos)
+{
+  std::cout << impl << " EditorMap::add_layer" << std::endl;
+
+  assert(pos == -1 || (pos >= 0 && pos < int(impl->layers.size())));
+
+  if (pos == -1) // insert at last pos
+    impl->layers.push_back(layer);
+  else
+    impl->layers.insert(impl->layers.begin() + pos, layer);
+
+  impl->serial += 1;
+}
+
+void 
+EditorMap::draw_gui(CL_GraphicContext* gc)
+{
+  CL_Rect rect = get_bounding_rect();
+
+  if (rect != CL_Rect(0,0,0,0))
+    {
+      gc->fill_rect(rect, impl->background_color);
+      gc->draw_rect(rect, impl->foreground_color);
+    }
+  else
+    {
+      gc->clear(impl->background_color);
+    }
+}
+
+void
+EditorMap::draw (EditorMapComponent* parent, CL_GraphicContext* gc)
+{
+  for(EditorMapImpl::Layers::iterator i = impl->layers.begin(); i != impl->layers.end(); ++i)
+    (*i).draw(parent, gc);
+  
+  gc->flush();
+}
+
+bool
+EditorMap::is_modified() const
+{
+  return impl->modified;
+}
+
+void
+EditorMap::set_unmodified() 
+{
+  impl->modified = false; 
+}
+
+void
+EditorMap::modify()
+{
+  impl->modified = true; 
+  impl->serial += 1; 
+}
+
+int
+EditorMap::get_serial() const 
+{ 
+  return impl->serial; 
+}
+
+int
+EditorMap::get_layer_count() const
+{
+  return static_cast<int>(impl->layers.size());
+}
+
+Layer
+EditorMap::get_layer(int i)
+{
+  if (i >= 0 && i < static_cast<int>(impl->layers.size()))
+    return impl->layers[i];
+  else
+    return Layer();
+}
+
+void
+EditorMap::set_metadata(const MetaData& obj)
+{
+  impl->metadata = obj; 
+}
+
+MetaData
+EditorMap::get_metadata() const
+{
+  return impl->metadata; 
+}
+
+bool
+EditorMap::has_bounding_rect() const
+{
+  return impl->has_bounding_rect;
+}
+
+void
+EditorMap::set_bounding_rect(const CL_Rect& rect)
+{
+  if (rect != CL_Rect(0,0,0,0))
+    {
+      impl->has_bounding_rect = true;
+      impl->bounding_rect     = rect;
+    }
+  else
+    {
+      impl->has_bounding_rect = false;
+      impl->bounding_rect     = rect;
+    }
+}
+
+CL_Rect
+EditorMap::get_bounding_rect()
+{
+  if (impl->has_bounding_rect)
+    {
+      return impl->bounding_rect;
+    }
+  else
+    {
+      bool init = false;
+      CL_Rect rect(0,0,0,0);
+
+      for(EditorMapImpl::Layers::iterator i = impl->layers.begin(); i != impl->layers.end(); ++i)
+        {
+          if (i->has_bounding_rect())
+            {
+              if (!init)
+                {
+                  rect = i->get_bounding_rect();
+                  init = true;
+                }
+              else
+                {
+                  CL_Rect other = i->get_bounding_rect();
+                  rect.top    = std::min(rect.top,    other.top);
+                  rect.bottom = std::max(rect.bottom, other.bottom);
+                  rect.left   = std::min(rect.left,   other.left);
+                  rect.right  = std::max(rect.right,  other.right);              
+                }
+            }
+        }
+      return rect;
+    }
+}
+
+void
+EditorMap::set_background_color(const CL_Color& color)
+{
+  impl-> background_color = color;
+}
+
+void
+EditorMap::execute(Command command)
+{
+  impl->redo_stack.clear();
+  command.execute();
+  impl->undo_stack.push_back(command);
+  impl->on_change();
+}
+
+void
+EditorMap::undo()
+{
+  if (!impl->undo_stack.empty())
+    {
+      Command command = impl->undo_stack.back();
+      impl->undo_stack.pop_back();
+      command.undo();
+      impl->redo_stack.push_back(command);
+      impl->on_change();
+    }
+}
+
+void
+EditorMap::redo()
+{
+  if (!impl->redo_stack.empty())
+    {
+      Command command = impl->redo_stack.back();
+      impl->redo_stack.pop_back();
+      command.redo();
+      impl->undo_stack.push_back(command);
+      impl->on_change();
+    }
+}
+
+int
+EditorMap::undo_stack_size()
+{
+  return impl->undo_stack.size();
+}
+
+int
+EditorMap::redo_stack_size()
+{
+  return impl->redo_stack.size();
+}
+
+CL_Signal_v0&
+EditorMap::sig_change()
+{
+  return impl->on_change;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/editor_map.cxx
===================================================================
--- trunk/flexlay/lib/editor_map.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/editor_map.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,281 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <assert.h>
-#include <ClanLib/Core/core_iostream.h>
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/keys.h>
-#include "editor_names.hxx"
-#include "editor_map.hxx"
-#include "editor_map_component.hxx"
-
-class EditorMapImpl
-{
-public:
-  /** Flag if the map got modified, used for 'Some maps are unsaved'
-      style massages */
-  bool modified;
-
-  /** Gets incremented with each map change so that other component
-      can update if required */
-  int serial;
-
-  typedef std::vector<Layer> Layers;
-  Layers layers;
-
-  CL_Color background_color;
-  CL_Color foreground_color;
-
-  /** Metadata attached to this map (ie. mapname, description, scripts, etc.) */
-  MetaData metadata;
-
-  typedef std::vector<Command> Commands;
-
-  Commands undo_stack;
-  Commands redo_stack;
-
-  CL_Signal_v0 on_change;
-
-  bool    has_bounding_rect;
-  CL_Rect bounding_rect;
-};
-
-EditorMap::EditorMap(bool create)
-  : impl(0)
-{
-  if (create)
-    {
-      impl = new EditorMapImpl();
-      impl->background_color = CL_Color(100, 80, 100);
-      impl->foreground_color = CL_Color(255, 80, 255);
-      impl->modified = false;
-      impl->serial = 0;
-      impl->has_bounding_rect = false;
-      impl->bounding_rect = CL_Rect(0,0,0,0);
-    }
-}
-
-void
-EditorMap::add_layer(const Layer& layer, int pos)
-{
-  std::cout << impl << " EditorMap::add_layer" << std::endl;
-
-  assert(pos == -1 || (pos >= 0 && pos < int(impl->layers.size())));
-
-  if (pos == -1) // insert at last pos
-    impl->layers.push_back(layer);
-  else
-    impl->layers.insert(impl->layers.begin() + pos, layer);
-
-  impl->serial += 1;
-}
-
-void 
-EditorMap::draw_gui(CL_GraphicContext* gc)
-{
-  CL_Rect rect = get_bounding_rect();
-
-  if (rect != CL_Rect(0,0,0,0))
-    {
-      gc->fill_rect(rect, impl->background_color);
-      gc->draw_rect(rect, impl->foreground_color);
-    }
-  else
-    {
-      gc->clear(impl->background_color);
-    }
-}
-
-void
-EditorMap::draw (EditorMapComponent* parent, CL_GraphicContext* gc)
-{
-  for(EditorMapImpl::Layers::iterator i = impl->layers.begin(); i != impl->layers.end(); ++i)
-    (*i).draw(parent, gc);
-  
-  gc->flush();
-}
-
-bool
-EditorMap::is_modified() const
-{
-  return impl->modified;
-}
-
-void
-EditorMap::set_unmodified() 
-{
-  impl->modified = false; 
-}
-
-void
-EditorMap::modify()
-{
-  impl->modified = true; 
-  impl->serial += 1; 
-}
-
-int
-EditorMap::get_serial() const 
-{ 
-  return impl->serial; 
-}
-
-int
-EditorMap::get_layer_count() const
-{
-  return static_cast<int>(impl->layers.size());
-}
-
-Layer
-EditorMap::get_layer(int i)
-{
-  if (i >= 0 && i < static_cast<int>(impl->layers.size()))
-    return impl->layers[i];
-  else
-    return Layer();
-}
-
-void
-EditorMap::set_metadata(const MetaData& obj)
-{
-  impl->metadata = obj; 
-}
-
-MetaData
-EditorMap::get_metadata() const
-{
-  return impl->metadata; 
-}
-
-bool
-EditorMap::has_bounding_rect() const
-{
-  return impl->has_bounding_rect;
-}
-
-void
-EditorMap::set_bounding_rect(const CL_Rect& rect)
-{
-  if (rect != CL_Rect(0,0,0,0))
-    {
-      impl->has_bounding_rect = true;
-      impl->bounding_rect     = rect;
-    }
-  else
-    {
-      impl->has_bounding_rect = false;
-      impl->bounding_rect     = rect;
-    }
-}
-
-CL_Rect
-EditorMap::get_bounding_rect()
-{
-  if (impl->has_bounding_rect)
-    {
-      return impl->bounding_rect;
-    }
-  else
-    {
-      bool init = false;
-      CL_Rect rect(0,0,0,0);
-
-      for(EditorMapImpl::Layers::iterator i = impl->layers.begin(); i != impl->layers.end(); ++i)
-        {
-          if (i->has_bounding_rect())
-            {
-              if (!init)
-                {
-                  rect = i->get_bounding_rect();
-                  init = true;
-                }
-              else
-                {
-                  CL_Rect other = i->get_bounding_rect();
-                  rect.top    = std::min(rect.top,    other.top);
-                  rect.bottom = std::max(rect.bottom, other.bottom);
-                  rect.left   = std::min(rect.left,   other.left);
-                  rect.right  = std::max(rect.right,  other.right);              
-                }
-            }
-        }
-      return rect;
-    }
-}
-
-void
-EditorMap::set_background_color(const CL_Color& color)
-{
-  impl-> background_color = color;
-}
-
-void
-EditorMap::execute(Command command)
-{
-  impl->redo_stack.clear();
-  command.execute();
-  impl->undo_stack.push_back(command);
-  impl->on_change();
-}
-
-void
-EditorMap::undo()
-{
-  if (!impl->undo_stack.empty())
-    {
-      Command command = impl->undo_stack.back();
-      impl->undo_stack.pop_back();
-      command.undo();
-      impl->redo_stack.push_back(command);
-      impl->on_change();
-    }
-}
-
-void
-EditorMap::redo()
-{
-  if (!impl->redo_stack.empty())
-    {
-      Command command = impl->redo_stack.back();
-      impl->redo_stack.pop_back();
-      command.redo();
-      impl->undo_stack.push_back(command);
-      impl->on_change();
-    }
-}
-
-int
-EditorMap::undo_stack_size()
-{
-  return impl->undo_stack.size();
-}
-
-int
-EditorMap::redo_stack_size()
-{
-  return impl->redo_stack.size();
-}
-
-CL_Signal_v0&
-EditorMap::sig_change()
-{
-  return impl->on_change;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/editor_map.hpp (from rev 712, trunk/flexlay/lib/editor_map.hxx)
===================================================================
--- trunk/flexlay/lib/editor_map.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/editor_map.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,97 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_EDITOR_MAP_HXX
+#define HEADER_EDITOR_MAP_HXX
+
+#include <vector>
+#include <ClanLib/Display/sprite.h>
+#include <ClanLib/GUI/component.h>
+#include <ClanLib/Core/Math/point.h>
+#include "field.hpp"
+#include "object_layer.hpp"
+#include "tilemap_layer.hpp"
+#include "layer.hpp"
+#include "command.hpp"
+
+class Command;
+class EditorMapComponent;
+class EditorMapImpl;
+
+/** Object which represents a level, quirled together with the GUI
+    stuff */
+class EditorMap
+{
+public:
+  EditorMap(bool create = false);
+
+  /** FIXME: EditorMapComponent parameter shouldn't really be here */
+  void draw(EditorMapComponent* parent, CL_GraphicContext* gc);
+  
+  /** Draw stuff that is only relevant on the GUI (bounding rects and such) */
+  void draw_gui(CL_GraphicContext* gc);
+
+  void add_layer(const Layer& layer, int pos = -1);
+
+  bool is_modified() const;
+  void set_unmodified();
+  void modify();
+
+  int get_serial() const;
+
+  int get_layer_count() const;
+  Layer get_layer(int i);
+
+  void   set_metadata(const MetaData& obj);
+  MetaData get_metadata() const;
+
+  bool has_bounding_rect() const;
+  CL_Rect get_bounding_rect();
+
+  /** Set the bounding rect for this map, if the given rect is
+      CL_Rect() the bounding rect will be calculated automatically
+      from the content of the map */
+  void    set_bounding_rect(const CL_Rect& rect);
+
+  void set_background_color(const CL_Color& color);
+
+  /** Execute a command and place it on the undo stack, commands given
+      to this function will be deleted by the Editor class, so they
+      have to be new'ed */
+  void execute(Command command);
+
+  /** Move backward in the undo stack */
+  void undo();
+
+  /** Move forward in the undo stack */
+  void redo();
+
+  int undo_stack_size();
+
+  int redo_stack_size();
+
+  CL_Signal_v0& sig_change();
+
+  bool is_null() const { return !impl.get(); }
+private:
+  CL_SharedPtr<EditorMapImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/editor_map.hxx
===================================================================
--- trunk/flexlay/lib/editor_map.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/editor_map.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,97 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_EDITOR_MAP_HXX
-#define HEADER_EDITOR_MAP_HXX
-
-#include <vector>
-#include <ClanLib/Display/sprite.h>
-#include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/Math/point.h>
-#include "field.hxx"
-#include "object_layer.hxx"
-#include "tilemap_layer.hxx"
-#include "layer.hxx"
-#include "command.hxx"
-
-class Command;
-class EditorMapComponent;
-class EditorMapImpl;
-
-/** Object which represents a level, quirled together with the GUI
-    stuff */
-class EditorMap
-{
-public:
-  EditorMap(bool create = false);
-
-  /** FIXME: EditorMapComponent parameter shouldn't really be here */
-  void draw(EditorMapComponent* parent, CL_GraphicContext* gc);
-  
-  /** Draw stuff that is only relevant on the GUI (bounding rects and such) */
-  void draw_gui(CL_GraphicContext* gc);
-
-  void add_layer(const Layer& layer, int pos = -1);
-
-  bool is_modified() const;
-  void set_unmodified();
-  void modify();
-
-  int get_serial() const;
-
-  int get_layer_count() const;
-  Layer get_layer(int i);
-
-  void   set_metadata(const MetaData& obj);
-  MetaData get_metadata() const;
-
-  bool has_bounding_rect() const;
-  CL_Rect get_bounding_rect();
-
-  /** Set the bounding rect for this map, if the given rect is
-      CL_Rect() the bounding rect will be calculated automatically
-      from the content of the map */
-  void    set_bounding_rect(const CL_Rect& rect);
-
-  void set_background_color(const CL_Color& color);
-
-  /** Execute a command and place it on the undo stack, commands given
-      to this function will be deleted by the Editor class, so they
-      have to be new'ed */
-  void execute(Command command);
-
-  /** Move backward in the undo stack */
-  void undo();
-
-  /** Move forward in the undo stack */
-  void redo();
-
-  int undo_stack_size();
-
-  int redo_stack_size();
-
-  CL_Signal_v0& sig_change();
-
-  bool is_null() const { return !impl.get(); }
-private:
-  CL_SharedPtr<EditorMapImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/editor_map_component.cpp (from rev 712, trunk/flexlay/lib/editor_map_component.cxx)
===================================================================
--- trunk/flexlay/lib/editor_map_component.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/editor_map_component.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,275 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include <ClanLib/Core/core_iostream.h>
+#include <ClanLib/Display/keyboard.h>
+#include <ClanLib/Display/mouse.h>
+#include <ClanLib/Display/display.h>
+#include <ClanLib/Display/display_iostream.h>
+#include <ClanLib/Display/keys.h>
+#include "tileset.hpp"
+#include "editor_names.hpp"
+#include "editor_map.hpp"
+#include "workspace.hpp"
+#include "scrollbar.hpp"
+#include "editor_map_component.hpp"
+
+EditorMapComponent* EditorMapComponent::current_ = 0; 
+
+class EditorMapComponentImpl
+{
+public:
+  EditorMapComponent* parent;
+  GraphicContextState gc_state;
+  Scrollbar* scrollbar_h;
+  Scrollbar* scrollbar_v;
+  CL_SlotContainer slots;
+  Workspace workspace;
+  CL_Signal_v2<int, int> key_bindings[256];
+
+  EditorMapComponentImpl()
+    :workspace(true) 
+  {}
+
+  void draw();
+  void mouse_up  (const CL_InputEvent& event);
+  void mouse_down(const CL_InputEvent& event);
+  void mouse_move(const CL_InputEvent& event);
+  void on_key_up(const CL_InputEvent& event);
+  void on_key_down(const CL_InputEvent& event);
+  void on_resize(int old_w, int old_h);
+};
+
+EditorMapComponent::EditorMapComponent(const CL_Rect& rect, CL_Component* parent)
+  : CL_Component(rect, parent),
+    impl(new EditorMapComponentImpl())
+{
+  impl->parent = this;
+  impl->gc_state  = GraphicContextState(rect.get_width(), rect.get_height());
+
+  current_ = this;
+
+  impl->scrollbar_v = new Scrollbar(CL_Rect(CL_Point(rect.get_width() - 14, 2) + CL_Point(rect.left, rect.top), 
+                                            CL_Size(12, rect.get_height() - 4 - 14)),
+                                    Scrollbar::VERTICAL,
+                                    parent);
+
+  impl->scrollbar_h = new Scrollbar(CL_Rect(CL_Point(2, rect.get_height() - 14) + CL_Point(rect.left, rect.top), 
+                                            CL_Size(rect.get_width() - 4 - 14, 12)),
+                                    Scrollbar::HORIZONTAL,
+                                    parent);
+
+  impl->slots.connect(impl->scrollbar_h->sig_scrollbar_move(), this, &EditorMapComponent::move_to_x);
+  impl->slots.connect(impl->scrollbar_v->sig_scrollbar_move(), this, &EditorMapComponent::move_to_y);
+
+  impl->slots.connect(sig_paint(),      impl.get(), &EditorMapComponentImpl::draw);
+  impl->slots.connect(sig_mouse_up(),   impl.get(), &EditorMapComponentImpl::mouse_up);
+  impl->slots.connect(sig_mouse_down(), impl.get(), &EditorMapComponentImpl::mouse_down);
+  impl->slots.connect(sig_mouse_move(), impl.get(), &EditorMapComponentImpl::mouse_move);
+  impl->slots.connect(sig_key_down(),   impl.get(), &EditorMapComponentImpl::on_key_down);
+  impl->slots.connect(sig_key_up(),     impl.get(), &EditorMapComponentImpl::on_key_up);
+  impl->slots.connect(sig_resize(),     impl.get(), &EditorMapComponentImpl::on_resize);
+}
+
+EditorMapComponent::~EditorMapComponent()
+{
+  std::cout << "~EditorMapComponent()" << std::endl;
+}
+
+Workspace
+EditorMapComponent::get_workspace() const
+{
+  return impl->workspace;
+}
+
+void
+EditorMapComponent::set_workspace(Workspace m)
+{
+  impl->workspace = m;
+}
+
+void
+EditorMapComponentImpl::on_key_down(const CL_InputEvent& event)
+{
+  if (event.id >= 0 && event.id < 256)
+    { 
+      CL_Rect rect = parent->get_position();
+      key_bindings[event.id](CL_Mouse::get_x() - rect.left,
+                             CL_Mouse::get_y() - rect.top);
+    }
+
+  if (event.repeat_count == 0)
+    {
+      CL_Rect rect = parent->get_position();
+      CL_InputEvent ev2 = event;
+      ev2.mouse_pos = CL_Point(CL_Mouse::get_x() - rect.left,
+                               CL_Mouse::get_y() - rect.top);
+      workspace.key_down(ev2);
+    }
+}
+
+void
+EditorMapComponentImpl::on_key_up(const CL_InputEvent& event)
+{
+  CL_Rect rect = parent->get_position();
+  CL_InputEvent ev2 = event;
+  ev2.mouse_pos = CL_Point(CL_Mouse::get_x() - rect.left,
+                           CL_Mouse::get_y() - rect.top);
+  workspace.key_up(ev2);
+}
+
+void
+EditorMapComponentImpl::mouse_up(const CL_InputEvent& event)
+{
+  workspace.mouse_up(event);
+}
+
+void
+EditorMapComponentImpl::mouse_move(const CL_InputEvent& event)
+{
+  workspace.mouse_move(event);
+}
+
+void
+EditorMapComponentImpl::mouse_down(const CL_InputEvent& event)
+{
+  workspace.mouse_down(event);
+}
+  
+void
+EditorMapComponentImpl::draw ()
+{
+  if (workspace.get_map().is_null()) return;
+
+  CL_Display::push_cliprect(parent->get_screen_rect());
+
+  CL_Display::push_translate(parent->get_screen_x(), parent->get_screen_y());
+
+  // Update scrollbars (FIXME: move me to function)
+  scrollbar_v->set_range(0, workspace.get_map().get_bounding_rect().get_height());
+  scrollbar_v->set_pagesize(parent->get_height()/gc_state.get_zoom());
+  scrollbar_v->set_pos(gc_state.get_pos().y);
+
+  scrollbar_h->set_range(0, workspace.get_map().get_bounding_rect().get_width());
+  scrollbar_h->set_pagesize(parent->get_width()/gc_state.get_zoom());
+  scrollbar_h->set_pos(gc_state.get_pos().x);
+
+  gc_state.push();
+  workspace.draw();
+  gc_state.pop();
+
+  CL_Display::pop_modelview();
+  CL_Display::pop_cliprect();
+}
+
+CL_Pointf
+EditorMapComponent::screen2world(const CL_Point& pos)
+{
+  return impl->gc_state.screen2world(pos);
+}
+
+void
+EditorMapComponent::set_zoom(float z)
+{
+  impl->gc_state.set_zoom(z);
+}
+
+void
+EditorMapComponent::zoom_out(CL_Point pos)
+{
+  impl->gc_state.set_zoom(CL_Pointf(pos.x, pos.y),
+                          impl->gc_state.get_zoom()/1.25f);
+}
+
+void
+EditorMapComponent::zoom_in(CL_Point pos)
+{
+  impl->gc_state.set_zoom(CL_Pointf(pos.x, pos.y), 
+                          impl->gc_state.get_zoom()*1.25f);
+}
+
+void
+EditorMapComponent::zoom_to(CL_Rectf rect)
+{
+  impl->gc_state.zoom_to(rect);
+}
+
+CL_Rectf
+EditorMapComponent::get_clip_rect()
+{
+  return impl->gc_state.get_clip_rect();
+}
+
+void
+EditorMapComponent::move_to(int x, int y)
+{
+  impl->gc_state.set_pos(CL_Pointf(x, y));
+}
+
+void
+EditorMapComponent::move_to_x(float x)
+{
+  impl->gc_state.set_pos(CL_Pointf(x, impl->gc_state.get_pos().y));
+}
+
+void
+EditorMapComponent::move_to_y(float y)
+{
+  impl->gc_state.set_pos(CL_Pointf(impl->gc_state.get_pos().x, y));
+}
+
+void
+EditorMapComponentImpl::on_resize(int old_w, int old_h)
+{
+  CL_Rect rect = parent->get_screen_rect();
+
+  scrollbar_v->set_position(rect.get_width() - 14 + rect.left,  2 + rect.top);
+  scrollbar_v->set_size(12, rect.get_height() - 4 - 14);
+  
+  scrollbar_h->set_position(2 + rect.left, rect.get_height() - 14 + rect.top);
+  scrollbar_h->set_size(rect.get_width() - 4 - 14, 12);
+
+  gc_state.set_size(rect.get_width(), rect.get_height());
+}
+
+CL_Signal_v2<int, int>&
+EditorMapComponent::sig_on_key(const std::string& str)
+{
+  int id = CL_Keyboard::get_device().string_to_keyid(str);
+
+  //std::cout << str << " => " << id << std::endl;
+
+  if (id > 0 && id < 256)
+    {
+      return impl->key_bindings[id];
+    }
+  else
+    {
+      std::cout << "EditorMapComponent::sig_on_key: invalid key id: " << id << std::endl;
+      return impl->key_bindings[0];
+    }
+}
+
+GraphicContextState&
+EditorMapComponent::get_gc_state()
+{
+  return impl->gc_state;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/editor_map_component.cxx
===================================================================
--- trunk/flexlay/lib/editor_map_component.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/editor_map_component.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,275 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <ClanLib/Core/core_iostream.h>
-#include <ClanLib/Display/keyboard.h>
-#include <ClanLib/Display/mouse.h>
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/display_iostream.h>
-#include <ClanLib/Display/keys.h>
-#include "tileset.hxx"
-#include "editor_names.hxx"
-#include "editor_map.hxx"
-#include "workspace.hxx"
-#include "scrollbar.hxx"
-#include "editor_map_component.hxx"
-
-EditorMapComponent* EditorMapComponent::current_ = 0; 
-
-class EditorMapComponentImpl
-{
-public:
-  EditorMapComponent* parent;
-  GraphicContextState gc_state;
-  Scrollbar* scrollbar_h;
-  Scrollbar* scrollbar_v;
-  CL_SlotContainer slots;
-  Workspace workspace;
-  CL_Signal_v2<int, int> key_bindings[256];
-
-  EditorMapComponentImpl()
-    :workspace(true) 
-  {}
-
-  void draw();
-  void mouse_up  (const CL_InputEvent& event);
-  void mouse_down(const CL_InputEvent& event);
-  void mouse_move(const CL_InputEvent& event);
-  void on_key_up(const CL_InputEvent& event);
-  void on_key_down(const CL_InputEvent& event);
-  void on_resize(int old_w, int old_h);
-};
-
-EditorMapComponent::EditorMapComponent(const CL_Rect& rect, CL_Component* parent)
-  : CL_Component(rect, parent),
-    impl(new EditorMapComponentImpl())
-{
-  impl->parent = this;
-  impl->gc_state  = GraphicContextState(rect.get_width(), rect.get_height());
-
-  current_ = this;
-
-  impl->scrollbar_v = new Scrollbar(CL_Rect(CL_Point(rect.get_width() - 14, 2) + CL_Point(rect.left, rect.top), 
-                                            CL_Size(12, rect.get_height() - 4 - 14)),
-                                    Scrollbar::VERTICAL,
-                                    parent);
-
-  impl->scrollbar_h = new Scrollbar(CL_Rect(CL_Point(2, rect.get_height() - 14) + CL_Point(rect.left, rect.top), 
-                                            CL_Size(rect.get_width() - 4 - 14, 12)),
-                                    Scrollbar::HORIZONTAL,
-                                    parent);
-
-  impl->slots.connect(impl->scrollbar_h->sig_scrollbar_move(), this, &EditorMapComponent::move_to_x);
-  impl->slots.connect(impl->scrollbar_v->sig_scrollbar_move(), this, &EditorMapComponent::move_to_y);
-
-  impl->slots.connect(sig_paint(),      impl.get(), &EditorMapComponentImpl::draw);
-  impl->slots.connect(sig_mouse_up(),   impl.get(), &EditorMapComponentImpl::mouse_up);
-  impl->slots.connect(sig_mouse_down(), impl.get(), &EditorMapComponentImpl::mouse_down);
-  impl->slots.connect(sig_mouse_move(), impl.get(), &EditorMapComponentImpl::mouse_move);
-  impl->slots.connect(sig_key_down(),   impl.get(), &EditorMapComponentImpl::on_key_down);
-  impl->slots.connect(sig_key_up(),     impl.get(), &EditorMapComponentImpl::on_key_up);
-  impl->slots.connect(sig_resize(),     impl.get(), &EditorMapComponentImpl::on_resize);
-}
-
-EditorMapComponent::~EditorMapComponent()
-{
-  std::cout << "~EditorMapComponent()" << std::endl;
-}
-
-Workspace
-EditorMapComponent::get_workspace() const
-{
-  return impl->workspace;
-}
-
-void
-EditorMapComponent::set_workspace(Workspace m)
-{
-  impl->workspace = m;
-}
-
-void
-EditorMapComponentImpl::on_key_down(const CL_InputEvent& event)
-{
-  if (event.id >= 0 && event.id < 256)
-    { 
-      CL_Rect rect = parent->get_position();
-      key_bindings[event.id](CL_Mouse::get_x() - rect.left,
-                             CL_Mouse::get_y() - rect.top);
-    }
-
-  if (event.repeat_count == 0)
-    {
-      CL_Rect rect = parent->get_position();
-      CL_InputEvent ev2 = event;
-      ev2.mouse_pos = CL_Point(CL_Mouse::get_x() - rect.left,
-                               CL_Mouse::get_y() - rect.top);
-      workspace.key_down(ev2);
-    }
-}
-
-void
-EditorMapComponentImpl::on_key_up(const CL_InputEvent& event)
-{
-  CL_Rect rect = parent->get_position();
-  CL_InputEvent ev2 = event;
-  ev2.mouse_pos = CL_Point(CL_Mouse::get_x() - rect.left,
-                           CL_Mouse::get_y() - rect.top);
-  workspace.key_up(ev2);
-}
-
-void
-EditorMapComponentImpl::mouse_up(const CL_InputEvent& event)
-{
-  workspace.mouse_up(event);
-}
-
-void
-EditorMapComponentImpl::mouse_move(const CL_InputEvent& event)
-{
-  workspace.mouse_move(event);
-}
-
-void
-EditorMapComponentImpl::mouse_down(const CL_InputEvent& event)
-{
-  workspace.mouse_down(event);
-}
-  
-void
-EditorMapComponentImpl::draw ()
-{
-  if (workspace.get_map().is_null()) return;
-
-  CL_Display::push_cliprect(parent->get_screen_rect());
-
-  CL_Display::push_translate(parent->get_screen_x(), parent->get_screen_y());
-
-  // Update scrollbars (FIXME: move me to function)
-  scrollbar_v->set_range(0, workspace.get_map().get_bounding_rect().get_height());
-  scrollbar_v->set_pagesize(parent->get_height()/gc_state.get_zoom());
-  scrollbar_v->set_pos(gc_state.get_pos().y);
-
-  scrollbar_h->set_range(0, workspace.get_map().get_bounding_rect().get_width());
-  scrollbar_h->set_pagesize(parent->get_width()/gc_state.get_zoom());
-  scrollbar_h->set_pos(gc_state.get_pos().x);
-
-  gc_state.push();
-  workspace.draw();
-  gc_state.pop();
-
-  CL_Display::pop_modelview();
-  CL_Display::pop_cliprect();
-}
-
-CL_Pointf
-EditorMapComponent::screen2world(const CL_Point& pos)
-{
-  return impl->gc_state.screen2world(pos);
-}
-
-void
-EditorMapComponent::set_zoom(float z)
-{
-  impl->gc_state.set_zoom(z);
-}
-
-void
-EditorMapComponent::zoom_out(CL_Point pos)
-{
-  impl->gc_state.set_zoom(CL_Pointf(pos.x, pos.y),
-                          impl->gc_state.get_zoom()/1.25f);
-}
-
-void
-EditorMapComponent::zoom_in(CL_Point pos)
-{
-  impl->gc_state.set_zoom(CL_Pointf(pos.x, pos.y), 
-                          impl->gc_state.get_zoom()*1.25f);
-}
-
-void
-EditorMapComponent::zoom_to(CL_Rectf rect)
-{
-  impl->gc_state.zoom_to(rect);
-}
-
-CL_Rectf
-EditorMapComponent::get_clip_rect()
-{
-  return impl->gc_state.get_clip_rect();
-}
-
-void
-EditorMapComponent::move_to(int x, int y)
-{
-  impl->gc_state.set_pos(CL_Pointf(x, y));
-}
-
-void
-EditorMapComponent::move_to_x(float x)
-{
-  impl->gc_state.set_pos(CL_Pointf(x, impl->gc_state.get_pos().y));
-}
-
-void
-EditorMapComponent::move_to_y(float y)
-{
-  impl->gc_state.set_pos(CL_Pointf(impl->gc_state.get_pos().x, y));
-}
-
-void
-EditorMapComponentImpl::on_resize(int old_w, int old_h)
-{
-  CL_Rect rect = parent->get_screen_rect();
-
-  scrollbar_v->set_position(rect.get_width() - 14 + rect.left,  2 + rect.top);
-  scrollbar_v->set_size(12, rect.get_height() - 4 - 14);
-  
-  scrollbar_h->set_position(2 + rect.left, rect.get_height() - 14 + rect.top);
-  scrollbar_h->set_size(rect.get_width() - 4 - 14, 12);
-
-  gc_state.set_size(rect.get_width(), rect.get_height());
-}
-
-CL_Signal_v2<int, int>&
-EditorMapComponent::sig_on_key(const std::string& str)
-{
-  int id = CL_Keyboard::get_device().string_to_keyid(str);
-
-  //std::cout << str << " => " << id << std::endl;
-
-  if (id > 0 && id < 256)
-    {
-      return impl->key_bindings[id];
-    }
-  else
-    {
-      std::cout << "EditorMapComponent::sig_on_key: invalid key id: " << id << std::endl;
-      return impl->key_bindings[0];
-    }
-}
-
-GraphicContextState&
-EditorMapComponent::get_gc_state()
-{
-  return impl->gc_state;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/editor_map_component.hpp (from rev 712, trunk/flexlay/lib/editor_map_component.hxx)
===================================================================
--- trunk/flexlay/lib/editor_map_component.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/editor_map_component.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,73 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_EDITOR_MAP_COMPONENT_HXX
+#define HEADER_EDITOR_MAP_COMPONENT_HXX
+
+#include <vector>
+#include <ClanLib/Display/sprite.h>
+#include <ClanLib/GUI/component.h>
+#include <ClanLib/Core/Math/point.h>
+#include "field.hpp"
+#include "object_layer.hpp"
+#include "graphic_context_state.hpp"
+#include "workspace.hpp"
+
+class Scrollbar;
+class EditorMapComponentImpl;
+
+/** Object which represents a level, quirled together with the GUI
+    stuff */
+class EditorMapComponent : public CL_Component
+{
+private:
+  static EditorMapComponent* current_; 
+protected:
+  virtual ~EditorMapComponent();
+public:
+  static EditorMapComponent* current() { return current_; } 
+
+  EditorMapComponent(const CL_Rect& rect, CL_Component* parent);
+ 
+  Workspace get_workspace() const;
+  void      set_workspace(Workspace m);
+
+  void  set_zoom(float z);
+  void  zoom_to(CL_Rectf rect);
+  void  zoom_out(CL_Point pos);
+  void  zoom_in (CL_Point pos);
+
+  void move_to(int x, int y);
+  void move_to_x(float x);
+  void move_to_y(float y);
+
+  CL_Signal_v2<int, int>& sig_on_key(const std::string& str);
+
+  CL_Pointf screen2world(const CL_Point& pos);
+
+  CL_Rectf get_clip_rect();
+
+  GraphicContextState& get_gc_state();
+
+private:
+  SharedPtr<EditorMapComponentImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/editor_map_component.hxx
===================================================================
--- trunk/flexlay/lib/editor_map_component.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/editor_map_component.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,73 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_EDITOR_MAP_COMPONENT_HXX
-#define HEADER_EDITOR_MAP_COMPONENT_HXX
-
-#include <vector>
-#include <ClanLib/Display/sprite.h>
-#include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/Math/point.h>
-#include "field.hxx"
-#include "object_layer.hxx"
-#include "graphic_context_state.hxx"
-#include "workspace.hxx"
-
-class Scrollbar;
-class EditorMapComponentImpl;
-
-/** Object which represents a level, quirled together with the GUI
-    stuff */
-class EditorMapComponent : public CL_Component
-{
-private:
-  static EditorMapComponent* current_; 
-protected:
-  virtual ~EditorMapComponent();
-public:
-  static EditorMapComponent* current() { return current_; } 
-
-  EditorMapComponent(const CL_Rect& rect, CL_Component* parent);
- 
-  Workspace get_workspace() const;
-  void      set_workspace(Workspace m);
-
-  void  set_zoom(float z);
-  void  zoom_to(CL_Rectf rect);
-  void  zoom_out(CL_Point pos);
-  void  zoom_in (CL_Point pos);
-
-  void move_to(int x, int y);
-  void move_to_x(float x);
-  void move_to_y(float y);
-
-  CL_Signal_v2<int, int>& sig_on_key(const std::string& str);
-
-  CL_Pointf screen2world(const CL_Point& pos);
-
-  CL_Rectf get_clip_rect();
-
-  GraphicContextState& get_gc_state();
-
-private:
-  SharedPtr<EditorMapComponentImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/editor_names.hpp (from rev 712, trunk/flexlay/lib/editor_names.hxx)

Deleted: trunk/flexlay/lib/editor_names.hxx
===================================================================
--- trunk/flexlay/lib/editor_names.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/editor_names.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,27 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_EDITOR_NAMES_HXX
-#define HEADER_EDITOR_NAMES_HXX
-
-enum { TILEMAP_NAME = 0, OBJECTMAP_NAME = 1 };
-enum { PAINT_TOOL_NAME = 0, SELECT_TOOL_NAME = 1, DIAMOND_TOOL = 2, OBJECT_TOOL_NAME = 3 }; 
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/field.hpp (from rev 712, trunk/flexlay/lib/field.hxx)
===================================================================
--- trunk/flexlay/lib/field.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/field.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,139 @@
+//  $Id: field.hpp,v 1.4 2003/09/12 09:25:48 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2000 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef FIELD_HXX
+#define FIELD_HXX
+
+#include <vector>
+#include <assert.h>
+
+template<class T>
+class Field
+{
+private:
+  int width;
+  int height;
+  std::vector<T> vec;
+
+public:
+  typedef typename std::vector<T>::iterator iterator;
+
+  Field()
+    : width(0), height(0)
+  {
+  }
+
+  Field (int w, int h) 
+    : width (w), height (h), vec (width * height)
+  {
+  }
+
+  Field(const Field<T>& copy)
+    : width(copy.width), height(copy.height), vec(copy.vec)
+  {
+  }
+
+  /** Creates a new field out of a subsection from an already excisting one 
+   *  @param pos_x The position of the old field in the new resized one
+   *  @param pos_y The position of the old field in the new resized one */
+  Field(const Field<T>& arg_field, int w, int h, int pos_x, int pos_y)
+    : width (w), height (h), vec (width * height)
+  {
+    int start_x = std::max(0, -pos_x);
+    int start_y = std::max(0, -pos_y);
+
+    int end_x = std::min(arg_field.get_width(),  get_width()  - pos_x);
+    int end_y = std::min(arg_field.get_height(), get_height() - pos_y);
+
+    for(int y = start_y; y < end_y; ++y)
+      for(int x = start_x; x < end_x; ++x)
+        at(pos_x + x, pos_y + y) = arg_field.at(x, y);
+  }
+
+  Field<T>& operator=(const Field<T>& copy)
+  {
+    if (this != &copy)
+      {
+        width  = copy.width;
+        height = copy.height;
+        vec    = copy.vec;
+      }
+    return *this;
+  }
+
+  const T& operator[] (int i) const {
+    return vec[i];
+  }
+
+  T& operator[] (int i) {
+    return vec[i];
+  }
+
+  T& operator() (int x, int y) 
+  {
+    assert (x >= 0 || x < (int) width || y >= 0 || y < (int) height);
+    return vec [width*y + x];
+  }
+
+  const T& operator() (int x, int y) const
+  {
+    assert (x >= 0 || x < (int) width || y >= 0 || y < (int) height);
+    return vec [width*y + x];
+  }
+  
+  inline const T& at (int x, int y) const {
+    return vec [width*y + x];
+  }
+
+  inline T& at (int x, int y) {
+    return (*this) (x, y);
+  }
+
+  /** Resize a field to a new size
+   *  @param pos_x The position of the old field in the new resized one
+   *  @param pos_y The position of the old field in the new resized one
+   **/
+  void resize(int w, int h, int pos_x = 0, int pos_y = 0) 
+  {
+    *this = Field<T>(*this, w, h, pos_x, pos_y);
+  }
+
+  void clear()
+  {
+    width  = 0;
+    height = 0;
+    vec.clear();
+  }
+
+  std::vector<T>& get_data() { return vec; }
+  void set_data(const std::vector<T>& d) { 
+    for(typename std::vector<T>::size_type i = 0; i < vec.size() && i < d.size(); ++i)
+      vec[i] = d[i]; 
+  }
+
+  iterator begin () { return vec.begin (); }
+  iterator end () { return vec.end (); }
+
+  int size() const { return vec.size(); }
+  int get_width () const { return width; }
+  int get_height () const { return height; }
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/field.hxx
===================================================================
--- trunk/flexlay/lib/field.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/field.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,139 +0,0 @@
-//  $Id: field.hxx,v 1.4 2003/09/12 09:25:48 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2000 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef FIELD_HXX
-#define FIELD_HXX
-
-#include <vector>
-#include <assert.h>
-
-template<class T>
-class Field
-{
-private:
-  int width;
-  int height;
-  std::vector<T> vec;
-
-public:
-  typedef typename std::vector<T>::iterator iterator;
-
-  Field()
-    : width(0), height(0)
-  {
-  }
-
-  Field (int w, int h) 
-    : width (w), height (h), vec (width * height)
-  {
-  }
-
-  Field(const Field<T>& copy)
-    : width(copy.width), height(copy.height), vec(copy.vec)
-  {
-  }
-
-  /** Creates a new field out of a subsection from an already excisting one 
-   *  @param pos_x The position of the old field in the new resized one
-   *  @param pos_y The position of the old field in the new resized one */
-  Field(const Field<T>& arg_field, int w, int h, int pos_x, int pos_y)
-    : width (w), height (h), vec (width * height)
-  {
-    int start_x = std::max(0, -pos_x);
-    int start_y = std::max(0, -pos_y);
-
-    int end_x = std::min(arg_field.get_width(),  get_width()  - pos_x);
-    int end_y = std::min(arg_field.get_height(), get_height() - pos_y);
-
-    for(int y = start_y; y < end_y; ++y)
-      for(int x = start_x; x < end_x; ++x)
-        at(pos_x + x, pos_y + y) = arg_field.at(x, y);
-  }
-
-  Field<T>& operator=(const Field<T>& copy)
-  {
-    if (this != &copy)
-      {
-        width  = copy.width;
-        height = copy.height;
-        vec    = copy.vec;
-      }
-    return *this;
-  }
-
-  const T& operator[] (int i) const {
-    return vec[i];
-  }
-
-  T& operator[] (int i) {
-    return vec[i];
-  }
-
-  T& operator() (int x, int y) 
-  {
-    assert (x >= 0 || x < (int) width || y >= 0 || y < (int) height);
-    return vec [width*y + x];
-  }
-
-  const T& operator() (int x, int y) const
-  {
-    assert (x >= 0 || x < (int) width || y >= 0 || y < (int) height);
-    return vec [width*y + x];
-  }
-  
-  inline const T& at (int x, int y) const {
-    return vec [width*y + x];
-  }
-
-  inline T& at (int x, int y) {
-    return (*this) (x, y);
-  }
-
-  /** Resize a field to a new size
-   *  @param pos_x The position of the old field in the new resized one
-   *  @param pos_y The position of the old field in the new resized one
-   **/
-  void resize(int w, int h, int pos_x = 0, int pos_y = 0) 
-  {
-    *this = Field<T>(*this, w, h, pos_x, pos_y);
-  }
-
-  void clear()
-  {
-    width  = 0;
-    height = 0;
-    vec.clear();
-  }
-
-  std::vector<T>& get_data() { return vec; }
-  void set_data(const std::vector<T>& d) { 
-    for(typename std::vector<T>::size_type i = 0; i < vec.size() && i < d.size(); ++i)
-      vec[i] = d[i]; 
-  }
-
-  iterator begin () { return vec.begin (); }
-  iterator end () { return vec.end (); }
-
-  int size() const { return vec.size(); }
-  int get_width () const { return width; }
-  int get_height () const { return height; }
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/flexlay.cpp (from rev 712, trunk/flexlay/lib/flexlay.cxx)
===================================================================
--- trunk/flexlay/lib/flexlay.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/flexlay.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,105 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <ClanLib/core.h>
+#include <ClanLib/display.h>
+#include <ClanLib/gui.h>
+#include <ClanLib/guistylesilver.h>
+#include <ClanLib/gl.h>
+#include "config.h"
+#include "globals.hpp"
+#include "fonts.hpp"
+#include "flexlay.hpp"
+
+Flexlay* Flexlay::current_ = 0;
+
+Flexlay::Flexlay()
+{
+  screen_width  = 800;
+  screen_height = 600;
+  fullscreen    = false;
+  allow_resize  = false;
+  use_opengl    = true;
+  
+  current_ = this;
+}
+
+CL_Signal_v2<int, int>&
+Flexlay::sig_resize()
+{
+  return window->sig_resize();
+}
+
+void
+Flexlay::init(const std::string& title, int width, int height, bool fullscreen_, bool allow_resize_)
+{
+  screen_width  = width;
+  screen_height = height;
+  fullscreen    = fullscreen_; 
+  allow_resize  = allow_resize_;
+
+  std::cout << "Flexlay::init()" << std::endl;
+  try {
+    #ifdef WIN32
+    CL_SetupCore::set_instance(GetModuleHandle("flexlay_wrap.dll"));
+    #endif
+    CL_SetupCore::init();
+#ifdef HAVE_LIBSDL
+    if (use_opengl)
+      CL_SetupGL::init();
+    else
+      CL_SetupSDL::init();
+#else
+    CL_SetupGL::init();
+#endif
+    CL_SetupDisplay::init();
+    CL_SetupGUI::init();
+  
+    datadir = "../data/";
+
+    window = new CL_DisplayWindow(title,
+                                  screen_width, screen_height, fullscreen, allow_resize);
+
+    resources = CL_ResourceManager(datadir + "flexlay.xml");
+    Fonts::verdana11        = CL_Font("verdana11_black", &resources);
+    Fonts::verdana11_yellow = CL_Font("verdana11_yellow", &resources);
+  } catch (CL_Error& err) {
+    std::cout << "CL_Error: " << err.message << std::endl;
+  }
+}
+
+void
+Flexlay::deinit()
+{
+  std::cout << "Flexlay::deinit()" << std::endl;
+
+  CL_SetupDisplay::deinit();
+
+#ifdef HAVE_LIBSDL
+  if (use_opengl)
+    CL_SetupGL::deinit();
+  else
+    CL_SetupSDL::init();
+#else
+  CL_SetupGL::deinit();
+#endif
+
+  CL_SetupCore::deinit();
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/flexlay.cxx
===================================================================
--- trunk/flexlay/lib/flexlay.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/flexlay.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,105 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <ClanLib/core.h>
-#include <ClanLib/display.h>
-#include <ClanLib/gui.h>
-#include <ClanLib/guistylesilver.h>
-#include <ClanLib/gl.h>
-#include "config.h"
-#include "globals.hxx"
-#include "fonts.hxx"
-#include "flexlay.hxx"
-
-Flexlay* Flexlay::current_ = 0;
-
-Flexlay::Flexlay()
-{
-  screen_width  = 800;
-  screen_height = 600;
-  fullscreen    = false;
-  allow_resize  = false;
-  use_opengl    = true;
-  
-  current_ = this;
-}
-
-CL_Signal_v2<int, int>&
-Flexlay::sig_resize()
-{
-  return window->sig_resize();
-}
-
-void
-Flexlay::init(const std::string& title, int width, int height, bool fullscreen_, bool allow_resize_)
-{
-  screen_width  = width;
-  screen_height = height;
-  fullscreen    = fullscreen_; 
-  allow_resize  = allow_resize_;
-
-  std::cout << "Flexlay::init()" << std::endl;
-  try {
-    #ifdef WIN32
-    CL_SetupCore::set_instance(GetModuleHandle("flexlay_wrap.dll"));
-    #endif
-    CL_SetupCore::init();
-#ifdef HAVE_LIBSDL
-    if (use_opengl)
-      CL_SetupGL::init();
-    else
-      CL_SetupSDL::init();
-#else
-    CL_SetupGL::init();
-#endif
-    CL_SetupDisplay::init();
-    CL_SetupGUI::init();
-  
-    datadir = "../data/";
-
-    window = new CL_DisplayWindow(title,
-                                  screen_width, screen_height, fullscreen, allow_resize);
-
-    resources = CL_ResourceManager(datadir + "flexlay.xml");
-    Fonts::verdana11        = CL_Font("verdana11_black", &resources);
-    Fonts::verdana11_yellow = CL_Font("verdana11_yellow", &resources);
-  } catch (CL_Error& err) {
-    std::cout << "CL_Error: " << err.message << std::endl;
-  }
-}
-
-void
-Flexlay::deinit()
-{
-  std::cout << "Flexlay::deinit()" << std::endl;
-
-  CL_SetupDisplay::deinit();
-
-#ifdef HAVE_LIBSDL
-  if (use_opengl)
-    CL_SetupGL::deinit();
-  else
-    CL_SetupSDL::init();
-#else
-  CL_SetupGL::deinit();
-#endif
-
-  CL_SetupCore::deinit();
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/flexlay.hpp (from rev 712, trunk/flexlay/lib/flexlay.hxx)

Deleted: trunk/flexlay/lib/flexlay.hxx
===================================================================
--- trunk/flexlay/lib/flexlay.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/flexlay.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,106 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_FLEXLAY_HXX
-#define HEADER_FLEXLAY_HXX
-
-#include <ClanLib/Display/display_window.h>
-#include <ClanLib/Core/Resources/resource_manager.h>
-
-/*! \mainpage Flexlay - A Flexible Layered 2D Editor
-  
-\section intro Introduction
-
-Flexlay is a rather flexible layered editor mainly meant for editing
-game data such as levels, tilemaps, enemy placement and such. It
-provides a basic framework which makes it easy to add new
-functionality, special dialog windows and such needed to customize it
-for a specific game. Flexlay itself is actually a Python module and
-not an editor in itself, however due to reasonably simple Python
-scripts one can already have a fully working editor.
-
-\section structure Structure
-
-Flexlay provides the following basic classes on which everything else
-is build:
-
-Command: each operation on data is encapsuled in a Command object
-which provides undo/redo capability, together with a way to easily
-record macros and write scripts with it.
-
-EditorMapLayer: a map layer is the class that holds the data, special
-layers such as object or tilemap layers derive from this class to
-provide the capabilites needed to use them
-
-Tool: A tool manages and dispatches mouse input to Commands, thus
-giving the user an interactive way to manipulate map data.
-
-GUI: Flexlay provides a simple GUI framework that can be used from
-Python to create dialogboxes, add buttons to the main window and such.
-
-\section games Games
-
-Currently Flexlay supports the following games with different levels
-of completeness:
-
-netPanzer: fully working load/save and map editing capabilites
-
-SuperTux: fully working load/save and map editing capabilites, however
-a bit limited when it comes to object properties
-
-Windstille: fully working load/save support, however due to the game
-itself not being ready this is not so usefull
-
-Pingus: just very basic load support
-
-*/
-
-/** Flexlay holds the DisplayWindow and manages the graphic mode and
-    screen resolution that should be. Its the top most class that
-    needs to be inited before the rest becomes useable. FIXME: Make
-    Flexlay 'batchable' so that it can run without a GUI */
-class Flexlay
-{
-private:
-  CL_DisplayWindow* window;
-
-public:
-  int  screen_width;
-  int  screen_height;
-  bool fullscreen;
-  bool allow_resize;
-  bool use_opengl;
-
-  CL_ResourceManager resources;
-
-  static Flexlay* current() { return current_; }
-public:
-  static Flexlay* current_;
-
-  Flexlay();
-
-  CL_Signal_v2<int, int>& sig_resize();
-
-  void init(const std::string& title = "Flexlay", int width = 800, int height = 600,
-            bool fullscreen = false, bool allow_resize = false);
-  void deinit();
-};
-
-#endif
-
-/* EOF */

Modified: trunk/flexlay/lib/flexlay_wrap.i
===================================================================
--- trunk/flexlay/lib/flexlay_wrap.i	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/flexlay_wrap.i	2009-11-22 03:02:03 UTC (rev 713)
@@ -22,76 +22,76 @@
 #include <ClanLib/GUI/window.h>
 #include <ClanLib/Core/Math/rect.h>
 #include <ClanLib/Core/Math/point.h>
-#include "command.hxx"
-#include "paint_command.hxx"
-#include "object_move_command.hxx"
-#include "object_add_command.hxx"
-#include "object_delete_command.hxx"
-#include "tile.hxx"
-#include "tile_brush.hxx"
-#include "meta_data.hxx"
-#include "console.hxx"
-#include "blitter.hxx"
+#include "command.hpp"
+#include "paint_command.hpp"
+#include "object_move_command.hpp"
+#include "object_add_command.hpp"
+#include "object_delete_command.hpp"
+#include "tile.hpp"
+#include "tile_brush.hpp"
+#include "meta_data.hpp"
+#include "console.hpp"
+#include "blitter.hpp"
 
-#include "layer.hxx"
-#include "tilemap_layer.hxx"
-#include "object_layer.hxx"
-#include "onion_skin_layer.hxx"
+#include "layer.hpp"
+#include "tilemap_layer.hpp"
+#include "object_layer.hpp"
+#include "onion_skin_layer.hpp"
 
-#include "minimap.hxx"
-#include "editor_map.hxx"
-#include "workspace.hxx"
-#include "tileset.hxx"
-#include "editor_map_component.hxx"
-#include "flexlay.hxx"
-#include "globals.hxx"
-#include "gui_manager.hxx"
-#include "tile_selector.hxx"
-#include "object_brush.hxx"
-#include "object_selector.hxx"
-#include "icon.hxx"
-#include "window.hxx"
-#include "panel.hxx"
-#include "directory_view.hxx"
-#include "menu.hxx"
-#include "menubar.hxx"
-#include "scrollbar.hxx"
-#include "graphic_context_state.hxx"
+#include "minimap.hpp"
+#include "editor_map.hpp"
+#include "workspace.hpp"
+#include "tileset.hpp"
+#include "editor_map_component.hpp"
+#include "flexlay.hpp"
+#include "globals.hpp"
+#include "gui_manager.hpp"
+#include "tile_selector.hpp"
+#include "object_brush.hpp"
+#include "object_selector.hpp"
+#include "icon.hpp"
+#include "window.hpp"
+#include "panel.hpp"
+#include "directory_view.hpp"
+#include "menu.hpp"
+#include "menubar.hpp"
+#include "scrollbar.hpp"
+#include "graphic_context_state.hpp"
  
-#include "tools/workspace_move_tool.hxx"
-#include "tools/layer_move_tool.hxx"
-#include "tools/sketch_stroke_tool.hxx"
-#include "sketch_layer.hxx"
-#include "bitmap_layer.hxx"
-#include "stroke.hxx"
-#include "stroke_drawer.hxx"
-#include "drawer_properties.hxx"
-#include "sprite_stroke_drawer.hxx"
-#include "marker_stroke_drawer.hxx"
-#include "brushmask.hxx"
-#include "brush.hxx"
-#include "generated_brush.hxx"
-#include "sprite_brush.hxx"
+#include "tools/workspace_move_tool.hpp"
+#include "tools/layer_move_tool.hpp"
+#include "tools/sketch_stroke_tool.hpp"
+#include "sketch_layer.hpp"
+#include "bitmap_layer.hpp"
+#include "stroke.hpp"
+#include "stroke_drawer.hpp"
+#include "drawer_properties.hpp"
+#include "sprite_stroke_drawer.hpp"
+#include "marker_stroke_drawer.hpp"
+#include "brushmask.hpp"
+#include "brush.hpp"
+#include "generated_brush.hpp"
+#include "sprite_brush.hpp"
 
-#include "colorpicker.hxx"
-#include "slider.hxx"
-#include "tools/tilemap_paint_tool.hxx"
-#include "tools/tilemap_select_tool.hxx"
-#include "tools/objmap_select_tool.hxx"
-#include "objmap_sprite_object.hxx"
-#include "objmap_rect_object.hxx"
-#include "objmap_object.hxx"
-#include "tools/zoom_tool.hxx"
-#include "tools/zoom2_tool.hxx"
-#include "objmap_path_node.hxx"
+#include "colorpicker.hpp"
+#include "slider.hpp"
+#include "tools/tilemap_paint_tool.hpp"
+#include "tools/tilemap_select_tool.hpp"
+#include "tools/objmap_select_tool.hpp"
+#include "objmap_sprite_object.hpp"
+#include "objmap_rect_object.hpp"
+#include "objmap_object.hpp"
+#include "tools/zoom_tool.hpp"
+#include "tools/zoom2_tool.hpp"
+#include "objmap_path_node.hpp"
 
-// #include "netpanzer.hxx" 
-#include "helper.hxx"
+// #include "netpanzer.hpp" 
+#include "helper.hpp"
 
 #ifdef SWIGRUBY
-#include "ruby_sexpr_parser.hxx"
-#include "ruby_meta_data.hxx"
-#include "ruby_functor.hxx"
+#include "ruby_sexpr_parser.hpp"
+#include "ruby_meta_data.hpp"
+#include "ruby_functor.hpp"
 
 VALUE ObjMapObject2Value(const ObjMapObject& arg)
 {
@@ -137,76 +137,76 @@
 %template(Std_vector_Dab) std::vector<Dab>;
 
 %include "clanlib.i"
-%include "command.hxx"
-%include "paint_command.hxx"
-%include "object_move_command.hxx"
-%include "object_add_command.hxx"
-%include "object_delete_command.hxx"
-%include "tile.hxx"
-%include "tile_brush.hxx"
-%include "meta_data.hxx"
-%include "console.hxx"
-%include "blitter.hxx"
+%include "command.hpp"
+%include "paint_command.hpp"
+%include "object_move_command.hpp"
+%include "object_add_command.hpp"
+%include "object_delete_command.hpp"
+%include "tile.hpp"
+%include "tile_brush.hpp"
+%include "meta_data.hpp"
+%include "console.hpp"
+%include "blitter.hpp"
  
-%include "layer.hxx"
-%include "tilemap_layer.hxx"
-%include "object_layer.hxx"
-%include "onion_skin_layer.hxx"
+%include "layer.hpp"
+%include "tilemap_layer.hpp"
+%include "object_layer.hpp"
+%include "onion_skin_layer.hpp"
 
-%include "editor_map.hxx"
-%include "workspace.hxx"
-%include "tileset.hxx"
-%include "editor_map_component.hxx"
-%include "flexlay.hxx"
-%include "globals.hxx"
-%include "gui_manager.hxx"
-%include "tile_selector.hxx"
-%include "object_brush.hxx"
-%include "object_selector.hxx"
-%include "icon.hxx"
-%include "window.hxx"
-%include "panel.hxx"
-%include "minimap.hxx"
-%include "directory_view.hxx"
-%include "menu.hxx"
-%include "menubar.hxx"
-%include "scrollbar.hxx"
+%include "editor_map.hpp"
+%include "workspace.hpp"
+%include "tileset.hpp"
+%include "editor_map_component.hpp"
+%include "flexlay.hpp"
+%include "globals.hpp"
+%include "gui_manager.hpp"
+%include "tile_selector.hpp"
+%include "object_brush.hpp"
+%include "object_selector.hpp"
+%include "icon.hpp"
+%include "window.hpp"
+%include "panel.hpp"
+%include "minimap.hpp"
+%include "directory_view.hpp"
+%include "menu.hpp"
+%include "menubar.hpp"
+%include "scrollbar.hpp"
 
-%include "tools/workspace_move_tool.hxx"
-%include "tools/layer_move_tool.hxx"
-%include "tools/sketch_stroke_tool.hxx"
-%include "sketch_layer.hxx"
-%include "bitmap_layer.hxx"
-%include "stroke.hxx"
-%include "stroke_drawer.hxx"
-%include "drawer_properties.hxx"
-%include "sprite_stroke_drawer.hxx"
-%include "marker_stroke_drawer.hxx"
-%include "brushmask.hxx"
-%include "brush.hxx"
-%include "generated_brush.hxx"
-%include "sprite_brush.hxx"
+%include "tools/workspace_move_tool.hpp"
+%include "tools/layer_move_tool.hpp"
+%include "tools/sketch_stroke_tool.hpp"
+%include "sketch_layer.hpp"
+%include "bitmap_layer.hpp"
+%include "stroke.hpp"
+%include "stroke_drawer.hpp"
+%include "drawer_properties.hpp"
+%include "sprite_stroke_drawer.hpp"
+%include "marker_stroke_drawer.hpp"
+%include "brushmask.hpp"
+%include "brush.hpp"
+%include "generated_brush.hpp"
+%include "sprite_brush.hpp"
 
-%include "colorpicker.hxx"
-%include "slider.hxx"
-%include "tools/tilemap_paint_tool.hxx"
-%include "tools/tilemap_select_tool.hxx"
-%include "tools/objmap_select_tool.hxx"
-%include "objmap_sprite_object.hxx"
-%include "objmap_rect_object.hxx"
-%include "objmap_object.hxx"
-%include "tools/zoom_tool.hxx" 
-%include "tools/zoom2_tool.hxx" 
-%include "graphic_context_state.hxx"
-%include "objmap_path_node.hxx"
-# %include "scripting/editor.hxx"
+%include "colorpicker.hpp"
+%include "slider.hpp"
+%include "tools/tilemap_paint_tool.hpp"
+%include "tools/tilemap_select_tool.hpp"
+%include "tools/objmap_select_tool.hpp"
+%include "objmap_sprite_object.hpp"
+%include "objmap_rect_object.hpp"
+%include "objmap_object.hpp"
+%include "tools/zoom_tool.hpp" 
+%include "tools/zoom2_tool.hpp" 
+%include "graphic_context_state.hpp"
+%include "objmap_path_node.hpp"
+# %include "scripting/editor.hpp"
 
-// %include "netpanzer.hxx" 
-%include "helper.hxx"
+// %include "netpanzer.hpp" 
+%include "helper.hpp"
 
 #ifdef SWIGRUBY
-%include "../ruby/ruby_meta_data.hxx"
-%include "../ruby/ruby_sexpr_parser.hxx"
+%include "../ruby/ruby_meta_data.hpp"
+%include "../ruby/ruby_sexpr_parser.hpp"
 #endif
 
 // 8

Copied: trunk/flexlay/lib/fonts.cpp (from rev 712, trunk/flexlay/lib/fonts.cxx)
===================================================================
--- trunk/flexlay/lib/fonts.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/fonts.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,24 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "fonts.hpp"
+
+CL_Font Fonts::verdana11;
+CL_Font Fonts::verdana11_yellow;
+
+/* EOF */

Deleted: trunk/flexlay/lib/fonts.cxx
===================================================================
--- trunk/flexlay/lib/fonts.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/fonts.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,24 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "fonts.hxx"
-
-CL_Font Fonts::verdana11;
-CL_Font Fonts::verdana11_yellow;
-
-/* EOF */

Copied: trunk/flexlay/lib/fonts.hpp (from rev 712, trunk/flexlay/lib/fonts.hxx)

Deleted: trunk/flexlay/lib/fonts.hxx
===================================================================
--- trunk/flexlay/lib/fonts.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/fonts.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,34 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_FONTS_HXX
-#define HEADER_FONTS_HXX
-
-#include <ClanLib/Display/font.h>
-
-/** */
-class Fonts
-{
-public:
-  static CL_Font verdana11;
-  static CL_Font verdana11_yellow;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/generated_brush.cpp (from rev 712, trunk/flexlay/lib/generated_brush.cxx)
===================================================================
--- trunk/flexlay/lib/generated_brush.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/generated_brush.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,185 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <ClanLib/Display/sprite_description.h>
+#include "brush_impl.hpp"
+#include "generated_brush.hpp"
+
+class GeneratedBrushImpl : public BrushImpl
+{
+public:
+  BrushShape shape;
+  float  radius;
+  int    spikes;
+  float  hardness;
+  float  aspect_ratio;
+  float  angle;
+
+  /** When set surface is out of date and needs updating */
+  bool dirty;
+
+  CL_Sprite sprite;
+
+  virtual ~GeneratedBrushImpl() {}
+  CL_Sprite get_sprite();
+  void update();
+  BrushImpl* clone() const;
+};
+
+GeneratedBrush::GeneratedBrush(const Brush& brush)
+: impl(dynamic_cast<GeneratedBrushImpl*>(brush.impl.get())) // FIXME: WANT WORK WITH REAL SMARTPTR!!!
+{
+}
+
+GeneratedBrush::GeneratedBrush(BrushShape shape,
+                               float  radius,
+                               int    spikes,        /* 2 - 20     */
+                               float  hardness,      /* 0.0 - 1.0  */
+                               float  aspect_ratio,  /* y/x        */
+                               float  angle)
+  : impl(new GeneratedBrushImpl())
+{
+  impl->shape        = shape;
+  impl->radius       = radius;
+  impl->spikes       = spikes;
+  impl->hardness     = hardness;
+  impl->aspect_ratio = aspect_ratio;
+  impl->angle        = angle;
+  impl->dirty        = true;
+}
+
+void
+GeneratedBrushImpl::update()
+{
+  if (dirty)
+    {
+      CL_SpriteDescription desc;
+      desc.add_frame(generate_brushmask(shape,
+                                        radius, 
+                                        spikes,
+                                        hardness, 
+                                        aspect_ratio, 
+                                        angle));
+      sprite = CL_Sprite(desc);
+      sprite.set_alignment(origin_center);
+      dirty = false;
+    }
+}
+
+void
+GeneratedBrush::set_shape(BrushShape shape)
+{
+  impl->shape = shape;
+  impl->dirty = true;
+}
+
+BrushShape
+GeneratedBrush::get_shape()
+{
+  return impl->shape;
+}
+
+void
+GeneratedBrush::set_radius(float radius)
+{
+  impl->radius = radius;
+  impl->dirty = true;
+}
+
+float
+GeneratedBrush::get_radius()
+{
+  return impl->radius;
+}
+
+void
+GeneratedBrush::set_spikes(int spikes)
+{
+  impl->spikes = spikes;
+  impl->dirty = true;
+}
+
+int
+GeneratedBrush::get_spikes()
+{
+  return impl->spikes;
+}
+
+void
+GeneratedBrush::set_hardness(float hardness)
+{
+  impl->hardness = hardness;
+  impl->dirty = true;
+}
+
+float
+GeneratedBrush::get_hardness()
+{
+  return impl->hardness;
+}
+
+void
+GeneratedBrush::set_aspect_ratio(float aspect)
+{
+  impl->aspect_ratio = aspect;
+  impl->dirty = true;
+}
+
+float
+GeneratedBrush::get_aspect_ratio()
+{
+  return impl->aspect_ratio;
+}
+
+void
+GeneratedBrush::set_angle(float angle)
+{
+  impl->angle = angle;
+  impl->dirty = true;
+}
+
+float
+GeneratedBrush::get_angle()
+{
+  return impl->angle;
+}
+
+CL_Sprite
+GeneratedBrushImpl::get_sprite() 
+{
+  update();
+  return sprite;
+}
+
+BrushImpl*
+GeneratedBrushImpl::clone() const
+{
+  // FIXME: Make this Copy-On-Write cloning, else it might get a
+  // little bit expensive with all the CL_Sprite's per stroke
+  GeneratedBrushImpl* c = new GeneratedBrushImpl();
+  *c = *this;
+  return c;
+}
+
+Brush
+GeneratedBrush::to_brush()
+{
+  return Brush(impl);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/generated_brush.cxx
===================================================================
--- trunk/flexlay/lib/generated_brush.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/generated_brush.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,185 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <ClanLib/Display/sprite_description.h>
-#include "brush_impl.hxx"
-#include "generated_brush.hxx"
-
-class GeneratedBrushImpl : public BrushImpl
-{
-public:
-  BrushShape shape;
-  float  radius;
-  int    spikes;
-  float  hardness;
-  float  aspect_ratio;
-  float  angle;
-
-  /** When set surface is out of date and needs updating */
-  bool dirty;
-
-  CL_Sprite sprite;
-
-  virtual ~GeneratedBrushImpl() {}
-  CL_Sprite get_sprite();
-  void update();
-  BrushImpl* clone() const;
-};
-
-GeneratedBrush::GeneratedBrush(const Brush& brush)
-: impl(dynamic_cast<GeneratedBrushImpl*>(brush.impl.get())) // FIXME: WANT WORK WITH REAL SMARTPTR!!!
-{
-}
-
-GeneratedBrush::GeneratedBrush(BrushShape shape,
-                               float  radius,
-                               int    spikes,        /* 2 - 20     */
-                               float  hardness,      /* 0.0 - 1.0  */
-                               float  aspect_ratio,  /* y/x        */
-                               float  angle)
-  : impl(new GeneratedBrushImpl())
-{
-  impl->shape        = shape;
-  impl->radius       = radius;
-  impl->spikes       = spikes;
-  impl->hardness     = hardness;
-  impl->aspect_ratio = aspect_ratio;
-  impl->angle        = angle;
-  impl->dirty        = true;
-}
-
-void
-GeneratedBrushImpl::update()
-{
-  if (dirty)
-    {
-      CL_SpriteDescription desc;
-      desc.add_frame(generate_brushmask(shape,
-                                        radius, 
-                                        spikes,
-                                        hardness, 
-                                        aspect_ratio, 
-                                        angle));
-      sprite = CL_Sprite(desc);
-      sprite.set_alignment(origin_center);
-      dirty = false;
-    }
-}
-
-void
-GeneratedBrush::set_shape(BrushShape shape)
-{
-  impl->shape = shape;
-  impl->dirty = true;
-}
-
-BrushShape
-GeneratedBrush::get_shape()
-{
-  return impl->shape;
-}
-
-void
-GeneratedBrush::set_radius(float radius)
-{
-  impl->radius = radius;
-  impl->dirty = true;
-}
-
-float
-GeneratedBrush::get_radius()
-{
-  return impl->radius;
-}
-
-void
-GeneratedBrush::set_spikes(int spikes)
-{
-  impl->spikes = spikes;
-  impl->dirty = true;
-}
-
-int
-GeneratedBrush::get_spikes()
-{
-  return impl->spikes;
-}
-
-void
-GeneratedBrush::set_hardness(float hardness)
-{
-  impl->hardness = hardness;
-  impl->dirty = true;
-}
-
-float
-GeneratedBrush::get_hardness()
-{
-  return impl->hardness;
-}
-
-void
-GeneratedBrush::set_aspect_ratio(float aspect)
-{
-  impl->aspect_ratio = aspect;
-  impl->dirty = true;
-}
-
-float
-GeneratedBrush::get_aspect_ratio()
-{
-  return impl->aspect_ratio;
-}
-
-void
-GeneratedBrush::set_angle(float angle)
-{
-  impl->angle = angle;
-  impl->dirty = true;
-}
-
-float
-GeneratedBrush::get_angle()
-{
-  return impl->angle;
-}
-
-CL_Sprite
-GeneratedBrushImpl::get_sprite() 
-{
-  update();
-  return sprite;
-}
-
-BrushImpl*
-GeneratedBrushImpl::clone() const
-{
-  // FIXME: Make this Copy-On-Write cloning, else it might get a
-  // little bit expensive with all the CL_Sprite's per stroke
-  GeneratedBrushImpl* c = new GeneratedBrushImpl();
-  *c = *this;
-  return c;
-}
-
-Brush
-GeneratedBrush::to_brush()
-{
-  return Brush(impl);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/generated_brush.hpp (from rev 712, trunk/flexlay/lib/generated_brush.hxx)
===================================================================
--- trunk/flexlay/lib/generated_brush.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/generated_brush.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,66 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_GENERATED_BRUSH_HXX
+#define HEADER_GENERATED_BRUSH_HXX
+
+#include "shared_ptr.hpp"
+#include "brushmask.hpp"
+#include "brush.hpp"
+
+class GeneratedBrushImpl;
+
+/** */
+class GeneratedBrush
+{
+private:
+public:
+  GeneratedBrush(const Brush& brush);
+  GeneratedBrush(BrushShape shape,
+                 float  radius,
+                 int    spikes,        /* 2 - 20     */
+                 float  hardness,      /* 0.0 - 1.0  */
+                 float  aspect_ratio,  /* y/x        */
+                 float  angle);
+
+  void set_shape(BrushShape shape);
+  BrushShape get_shape();
+
+  void  set_radius(float radius);
+  float get_radius();
+
+  void  set_spikes(int spikes);
+  int   get_spikes();
+
+  void  set_hardness(float hardness);
+  float get_hardness();
+
+  void  set_aspect_ratio(float aspect);
+  float get_aspect_ratio();
+
+  void  set_angle(float angle);
+  float get_angle();
+
+  Brush to_brush();
+private:
+  SharedPtr<GeneratedBrushImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/generated_brush.hxx
===================================================================
--- trunk/flexlay/lib/generated_brush.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/generated_brush.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,66 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_GENERATED_BRUSH_HXX
-#define HEADER_GENERATED_BRUSH_HXX
-
-#include "shared_ptr.hxx"
-#include "brushmask.hxx"
-#include "brush.hxx"
-
-class GeneratedBrushImpl;
-
-/** */
-class GeneratedBrush
-{
-private:
-public:
-  GeneratedBrush(const Brush& brush);
-  GeneratedBrush(BrushShape shape,
-                 float  radius,
-                 int    spikes,        /* 2 - 20     */
-                 float  hardness,      /* 0.0 - 1.0  */
-                 float  aspect_ratio,  /* y/x        */
-                 float  angle);
-
-  void set_shape(BrushShape shape);
-  BrushShape get_shape();
-
-  void  set_radius(float radius);
-  float get_radius();
-
-  void  set_spikes(int spikes);
-  int   get_spikes();
-
-  void  set_hardness(float hardness);
-  float get_hardness();
-
-  void  set_aspect_ratio(float aspect);
-  float get_aspect_ratio();
-
-  void  set_angle(float angle);
-  float get_angle();
-
-  Brush to_brush();
-private:
-  SharedPtr<GeneratedBrushImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/globals.cpp (from rev 712, trunk/flexlay/lib/globals.cxx)
===================================================================
--- trunk/flexlay/lib/globals.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/globals.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,27 @@
+//  $Id: globals.cxx,v 1.6 2003/11/07 22:41:18 grumbel Exp $
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "globals.hpp"
+
+std::string datadir;
+std::string bindir;
+std::string homedir;
+
+int  debug = 0;
+
+/* EOF */

Deleted: trunk/flexlay/lib/globals.cxx
===================================================================
--- trunk/flexlay/lib/globals.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/globals.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,27 +0,0 @@
-//  $Id: globals.cxx,v 1.6 2003/11/07 22:41:18 grumbel Exp $
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "globals.hxx"
-
-std::string datadir;
-std::string bindir;
-std::string homedir;
-
-int  debug = 0;
-
-/* EOF */

Copied: trunk/flexlay/lib/globals.hpp (from rev 712, trunk/flexlay/lib/globals.hxx)
===================================================================
--- trunk/flexlay/lib/globals.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/globals.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,38 @@
+//  $Id: globals.hpp,v 1.11 2003/11/07 13:00:39 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2000 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef GLOBALS_HXX
+#define GLOBALS_HXX
+
+#include <string>
+#include <ClanLib/Core/Resources/resource_manager.h>
+
+/** datadir => /usr/local/share/games/windstille/ */
+extern std::string datadir;
+
+/** bindir => /usr/local/games/ */
+extern std::string bindir;
+
+/** homedir => /home/juser/.windstille/ */
+extern std::string homedir;
+
+extern int   debug;
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/globals.hxx
===================================================================
--- trunk/flexlay/lib/globals.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/globals.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,38 +0,0 @@
-//  $Id: globals.hxx,v 1.11 2003/11/07 13:00:39 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2000 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef GLOBALS_HXX
-#define GLOBALS_HXX
-
-#include <string>
-#include <ClanLib/Core/Resources/resource_manager.h>
-
-/** datadir => /usr/local/share/games/windstille/ */
-extern std::string datadir;
-
-/** bindir => /usr/local/games/ */
-extern std::string bindir;
-
-/** homedir => /home/juser/.windstille/ */
-extern std::string homedir;
-
-extern int   debug;
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/graphic_context_state.cpp (from rev 712, trunk/flexlay/lib/graphic_context_state.cxx)
===================================================================
--- trunk/flexlay/lib/graphic_context_state.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/graphic_context_state.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,201 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <ClanLib/Display/display.h>
+#include <ClanLib/Display/display_window.h>
+#include <ClanLib/Display/graphic_context.h>
+#include <ClanLib/GUI/component.h>
+#include <math.h>
+#include "graphic_context_state.hpp"
+
+class GraphicContextStateImpl
+{
+public:
+  int width;
+  int height;
+  
+  CL_Pointf offset;
+  float zoom;
+  float rotation;
+};
+
+GraphicContextState::GraphicContextState()
+  : impl(new GraphicContextStateImpl())
+{
+  impl->width  = 1;
+  impl->height = 1; 
+  impl->offset = CL_Pointf(0,0);
+  impl->zoom   = 1.0f;
+  impl->rotation = 0;
+}
+
+GraphicContextState::GraphicContextState(int w, int h)
+  : impl(new GraphicContextStateImpl())
+{  
+  impl->width  = w;
+  impl->height = h;
+  impl->offset = CL_Pointf(0,0); 
+  impl->zoom   = 1.0f;
+  impl->rotation = 0;
+}
+
+void
+GraphicContextState::set_size(int w, int h)
+{
+  impl->width  = w;
+  impl->height = h;
+}
+
+void
+GraphicContextState::push(CL_GraphicContext* gc)
+{
+  if (gc == 0)
+    gc = CL_Display::get_current_window()->get_gc();
+  
+  gc->push_modelview();
+
+  gc->add_translate(impl->width/2, impl->height/2);
+  gc->add_rotate(impl->rotation, 0, 0, 1.0);
+  gc->add_translate(-impl->width/2, -impl->height/2);
+
+  gc->add_scale(get_zoom(), get_zoom());
+  gc->add_translate(impl->offset.x, impl->offset.y);
+}
+
+void
+GraphicContextState::pop(CL_GraphicContext* gc)
+{
+  if (gc == 0)
+    gc = CL_Display::get_current_window()->get_gc();
+  
+  gc->pop_modelview();
+}
+
+CL_Rectf
+GraphicContextState::get_clip_rect()
+{
+  return CL_Rectf(CL_Pointf(-impl->offset.x,
+                            -impl->offset.y),
+                  CL_Sizef(get_width()  / impl->zoom,
+                           get_height() / impl->zoom));
+}
+
+void
+GraphicContextState::set_pos(const CL_Pointf& pos)
+{
+  impl->offset.x = -pos.x + (get_width()/2  / impl->zoom);
+  impl->offset.y = -pos.y + (get_height()/2 / impl->zoom);
+}
+
+CL_Pointf
+GraphicContextState::get_pos() const
+{
+  return CL_Pointf(-impl->offset.x + (get_width()/2  / impl->zoom),
+                   -impl->offset.y + (get_height()/2  / impl->zoom));
+}
+
+void
+GraphicContextState::set_zoom(CL_Pointf pos, float z)
+{
+  float old_zoom = impl->zoom;
+  set_zoom(z);
+  impl->offset.x = pos.x/impl->zoom - pos.x/old_zoom + impl->offset.x;
+  impl->offset.y = pos.y/impl->zoom - pos.y/old_zoom + impl->offset.y;
+}
+
+void
+GraphicContextState::set_zoom(float z)
+{
+  impl->zoom = z;
+}
+
+float
+GraphicContextState::get_zoom()
+{
+  return impl->zoom;
+}
+
+void
+GraphicContextState::zoom_to (const CL_Rectf& rect)
+{
+  float center_x = (rect.left + rect.right) / 2.0f;
+  float center_y = (rect.top + rect.bottom) / 2.0f;
+
+  float width  = rect.right - rect.left;
+  float height = rect.bottom - rect.top;
+  float screen_relation = float(get_height())/float(get_width ());
+  float rect_relation   = height/width; 
+  
+  //std::cout << "Screen: " << screen_relation << " Zoom: " << rect_relation << std::endl;
+  if (rect_relation < screen_relation) // take width, ignore height
+    {
+      impl->zoom = get_width()/width; 
+    }
+  else // take height, ignore width
+    {
+      impl->zoom = get_height()/height;
+    }
+
+  impl->offset.x = (get_width()  / (2*impl->zoom)) - center_x;
+  impl->offset.y = (get_height() / (2*impl->zoom)) - center_y;
+}
+
+CL_Pointf
+GraphicContextState::screen2world(const CL_Point& pos_)
+{
+  CL_Pointf pos = pos_;
+  float sa = sin(-impl->rotation/180.0f*M_PI);
+  float ca = cos(-impl->rotation/180.0f*M_PI);
+
+  float dx = pos.x - impl->width/2;
+  float dy = pos.y - impl->height/2;
+
+  pos.x = impl->width/2  + (ca * dx - sa * dy);
+  pos.y = impl->height/2 + (sa * dx + ca * dy);
+
+  CL_Pointf p((float(pos.x) / impl->zoom) - impl->offset.x, 
+              (float(pos.y) / impl->zoom) - impl->offset.y);
+
+  return p;
+}
+
+void
+GraphicContextState::set_rotation(float angle)
+{
+  impl->rotation = angle;
+}
+
+float
+GraphicContextState::get_rotation()
+{
+  return impl->rotation;
+}
+
+int
+GraphicContextState::get_width()  const 
+{
+  return impl->width; 
+}
+
+int
+GraphicContextState::get_height() const 
+{ 
+  return impl->height; 
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/graphic_context_state.cxx
===================================================================
--- trunk/flexlay/lib/graphic_context_state.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/graphic_context_state.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,201 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/display_window.h>
-#include <ClanLib/Display/graphic_context.h>
-#include <ClanLib/GUI/component.h>
-#include <math.h>
-#include "graphic_context_state.hxx"
-
-class GraphicContextStateImpl
-{
-public:
-  int width;
-  int height;
-  
-  CL_Pointf offset;
-  float zoom;
-  float rotation;
-};
-
-GraphicContextState::GraphicContextState()
-  : impl(new GraphicContextStateImpl())
-{
-  impl->width  = 1;
-  impl->height = 1; 
-  impl->offset = CL_Pointf(0,0);
-  impl->zoom   = 1.0f;
-  impl->rotation = 0;
-}
-
-GraphicContextState::GraphicContextState(int w, int h)
-  : impl(new GraphicContextStateImpl())
-{  
-  impl->width  = w;
-  impl->height = h;
-  impl->offset = CL_Pointf(0,0); 
-  impl->zoom   = 1.0f;
-  impl->rotation = 0;
-}
-
-void
-GraphicContextState::set_size(int w, int h)
-{
-  impl->width  = w;
-  impl->height = h;
-}
-
-void
-GraphicContextState::push(CL_GraphicContext* gc)
-{
-  if (gc == 0)
-    gc = CL_Display::get_current_window()->get_gc();
-  
-  gc->push_modelview();
-
-  gc->add_translate(impl->width/2, impl->height/2);
-  gc->add_rotate(impl->rotation, 0, 0, 1.0);
-  gc->add_translate(-impl->width/2, -impl->height/2);
-
-  gc->add_scale(get_zoom(), get_zoom());
-  gc->add_translate(impl->offset.x, impl->offset.y);
-}
-
-void
-GraphicContextState::pop(CL_GraphicContext* gc)
-{
-  if (gc == 0)
-    gc = CL_Display::get_current_window()->get_gc();
-  
-  gc->pop_modelview();
-}
-
-CL_Rectf
-GraphicContextState::get_clip_rect()
-{
-  return CL_Rectf(CL_Pointf(-impl->offset.x,
-                            -impl->offset.y),
-                  CL_Sizef(get_width()  / impl->zoom,
-                           get_height() / impl->zoom));
-}
-
-void
-GraphicContextState::set_pos(const CL_Pointf& pos)
-{
-  impl->offset.x = -pos.x + (get_width()/2  / impl->zoom);
-  impl->offset.y = -pos.y + (get_height()/2 / impl->zoom);
-}
-
-CL_Pointf
-GraphicContextState::get_pos() const
-{
-  return CL_Pointf(-impl->offset.x + (get_width()/2  / impl->zoom),
-                   -impl->offset.y + (get_height()/2  / impl->zoom));
-}
-
-void
-GraphicContextState::set_zoom(CL_Pointf pos, float z)
-{
-  float old_zoom = impl->zoom;
-  set_zoom(z);
-  impl->offset.x = pos.x/impl->zoom - pos.x/old_zoom + impl->offset.x;
-  impl->offset.y = pos.y/impl->zoom - pos.y/old_zoom + impl->offset.y;
-}
-
-void
-GraphicContextState::set_zoom(float z)
-{
-  impl->zoom = z;
-}
-
-float
-GraphicContextState::get_zoom()
-{
-  return impl->zoom;
-}
-
-void
-GraphicContextState::zoom_to (const CL_Rectf& rect)
-{
-  float center_x = (rect.left + rect.right) / 2.0f;
-  float center_y = (rect.top + rect.bottom) / 2.0f;
-
-  float width  = rect.right - rect.left;
-  float height = rect.bottom - rect.top;
-  float screen_relation = float(get_height())/float(get_width ());
-  float rect_relation   = height/width; 
-  
-  //std::cout << "Screen: " << screen_relation << " Zoom: " << rect_relation << std::endl;
-  if (rect_relation < screen_relation) // take width, ignore height
-    {
-      impl->zoom = get_width()/width; 
-    }
-  else // take height, ignore width
-    {
-      impl->zoom = get_height()/height;
-    }
-
-  impl->offset.x = (get_width()  / (2*impl->zoom)) - center_x;
-  impl->offset.y = (get_height() / (2*impl->zoom)) - center_y;
-}
-
-CL_Pointf
-GraphicContextState::screen2world(const CL_Point& pos_)
-{
-  CL_Pointf pos = pos_;
-  float sa = sin(-impl->rotation/180.0f*M_PI);
-  float ca = cos(-impl->rotation/180.0f*M_PI);
-
-  float dx = pos.x - impl->width/2;
-  float dy = pos.y - impl->height/2;
-
-  pos.x = impl->width/2  + (ca * dx - sa * dy);
-  pos.y = impl->height/2 + (sa * dx + ca * dy);
-
-  CL_Pointf p((float(pos.x) / impl->zoom) - impl->offset.x, 
-              (float(pos.y) / impl->zoom) - impl->offset.y);
-
-  return p;
-}
-
-void
-GraphicContextState::set_rotation(float angle)
-{
-  impl->rotation = angle;
-}
-
-float
-GraphicContextState::get_rotation()
-{
-  return impl->rotation;
-}
-
-int
-GraphicContextState::get_width()  const 
-{
-  return impl->width; 
-}
-
-int
-GraphicContextState::get_height() const 
-{ 
-  return impl->height; 
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/graphic_context_state.hpp (from rev 712, trunk/flexlay/lib/graphic_context_state.hxx)
===================================================================
--- trunk/flexlay/lib/graphic_context_state.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/graphic_context_state.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,78 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_GRAPHIC_CONTEXT_STATE_HXX
+#define HEADER_GRAPHIC_CONTEXT_STATE_HXX
+
+#include <ClanLib/Core/Math/point.h>
+#include <ClanLib/Core/Math/rect.h>
+#include "shared_ptr.hpp"
+
+class CL_GraphicContext;
+
+class GraphicContextStateImpl;
+
+/** Helper class for capturing the state of a GraphicContext, with
+    additional convenience functions to make handling GraphicContexts
+    easier */
+class GraphicContextState
+{
+public:
+  GraphicContextState();
+  GraphicContextState(int w, int h);
+
+  void set_size(int w, int h);
+
+  void push(CL_GraphicContext* gc = 0);
+  void pop (CL_GraphicContext* gc = 0);
+
+  /** Return a rectangle in world coordinates that represents the area
+      visible on the screen */
+  CL_Rectf get_clip_rect();
+
+  int get_width()  const;
+  int get_height() const;
+
+  /** Set the current rotation angel */
+  void  set_rotation(float angle);
+
+  /** Return the current rotation angel */
+  float get_rotation();
+
+  /** Move the center of the visible area to pos */
+  void      set_pos(const CL_Pointf& pos);
+  CL_Pointf get_pos() const;
+
+  /** Set zoom to z, while ensuring that the screen position \a pos
+      (normaly the position of the mouse pointer) stays in the same
+      position even after zoomed in/out */
+  void  set_zoom(CL_Pointf pos, float z);
+  void  set_zoom(float z);
+  float get_zoom(); 
+
+  void zoom_to (const CL_Rectf& rect);
+
+  CL_Pointf screen2world(const CL_Point& pos);
+
+private:
+  SharedPtr<GraphicContextStateImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/graphic_context_state.hxx
===================================================================
--- trunk/flexlay/lib/graphic_context_state.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/graphic_context_state.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,78 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_GRAPHIC_CONTEXT_STATE_HXX
-#define HEADER_GRAPHIC_CONTEXT_STATE_HXX
-
-#include <ClanLib/Core/Math/point.h>
-#include <ClanLib/Core/Math/rect.h>
-#include "shared_ptr.hxx"
-
-class CL_GraphicContext;
-
-class GraphicContextStateImpl;
-
-/** Helper class for capturing the state of a GraphicContext, with
-    additional convenience functions to make handling GraphicContexts
-    easier */
-class GraphicContextState
-{
-public:
-  GraphicContextState();
-  GraphicContextState(int w, int h);
-
-  void set_size(int w, int h);
-
-  void push(CL_GraphicContext* gc = 0);
-  void pop (CL_GraphicContext* gc = 0);
-
-  /** Return a rectangle in world coordinates that represents the area
-      visible on the screen */
-  CL_Rectf get_clip_rect();
-
-  int get_width()  const;
-  int get_height() const;
-
-  /** Set the current rotation angel */
-  void  set_rotation(float angle);
-
-  /** Return the current rotation angel */
-  float get_rotation();
-
-  /** Move the center of the visible area to pos */
-  void      set_pos(const CL_Pointf& pos);
-  CL_Pointf get_pos() const;
-
-  /** Set zoom to z, while ensuring that the screen position \a pos
-      (normaly the position of the mouse pointer) stays in the same
-      position even after zoomed in/out */
-  void  set_zoom(CL_Pointf pos, float z);
-  void  set_zoom(float z);
-  float get_zoom(); 
-
-  void zoom_to (const CL_Rectf& rect);
-
-  CL_Pointf screen2world(const CL_Point& pos);
-
-private:
-  SharedPtr<GraphicContextStateImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/gui_manager.cpp (from rev 712, trunk/flexlay/lib/gui_manager.cxx)
===================================================================
--- trunk/flexlay/lib/gui_manager.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/gui_manager.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,133 @@
+//  $Id: gui_manager.cxx,v 1.3 2003/11/05 12:41:37 grumbel Exp $
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include <ClanLib/gui.h>
+#include <ClanLib/guistylesilver.h>
+#include <ClanLib/core.h>
+
+#include "globals.hpp"
+#include "gui_manager.hpp"
+
+GUIManager* GUIManager::current_ = 0;
+
+class GUIManagerImpl
+{
+public:
+  std::stack<CL_Component*> components;
+
+  CL_GUIManager*      manager;
+  CL_StyleManager*    style;
+  CL_ResourceManager* resources;
+  CL_SlotContainer*   slot_container;
+};
+
+GUIManager::GUIManager()
+  : impl(new GUIManagerImpl())
+{
+  std::cout << "Creating GUIManager: " << datadir + "gui/gui.xml" << std::endl;
+  impl->slot_container = new CL_SlotContainer();
+  impl->resources = new CL_ResourceManager(datadir + "gui/gui.xml", false);
+  impl->style     = new CL_StyleManager_Silver(impl->resources);
+  impl->manager   = new CL_GUIManager(impl->style);
+  current_  = this;
+
+  // Make the manager the first component on the stack
+  push_component(impl->manager);
+}
+
+GUIManager::~GUIManager()
+{
+  pop_component();
+
+  delete impl->manager;
+  //delete style; FIXME: Memory hole?!
+  //delete resources;  FIXME: Memory hole?!
+  delete impl->slot_container;
+}
+  
+void
+GUIManager::draw()
+{
+  if (impl->manager->is_input_enabled())
+    impl->manager->show();
+}
+
+void
+GUIManager::update()
+{
+  // nothing to do
+}
+
+void
+GUIManager::run()
+{
+  impl->manager->run();
+}
+
+CL_Component* 
+GUIManager::get_component()
+{
+  return impl->components.top();
+}
+
+CL_SlotContainer*
+GUIManager::get_slot_container()
+{
+  return impl->slot_container;
+}
+
+void
+GUIManager::hide()
+{
+  if (impl->manager->is_input_enabled())
+    impl->manager->disable_input();
+}
+
+void
+GUIManager::show()
+{
+  if (!impl->manager->is_input_enabled())
+    impl->manager->enable_input();
+}
+
+bool
+GUIManager::is_visible()
+{
+  return impl->manager->is_input_enabled();
+}
+
+void
+GUIManager::quit()
+{
+  impl->manager->quit(); 
+} 
+
+void
+GUIManager::push_component(CL_Component* c)
+{
+  impl->components.push(c); 
+}
+
+void
+GUIManager::pop_component() 
+{ 
+  impl->components.pop(); 
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/gui_manager.cxx
===================================================================
--- trunk/flexlay/lib/gui_manager.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/gui_manager.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,133 +0,0 @@
-//  $Id: gui_manager.cxx,v 1.3 2003/11/05 12:41:37 grumbel Exp $
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <ClanLib/gui.h>
-#include <ClanLib/guistylesilver.h>
-#include <ClanLib/core.h>
-
-#include "globals.hxx"
-#include "gui_manager.hxx"
-
-GUIManager* GUIManager::current_ = 0;
-
-class GUIManagerImpl
-{
-public:
-  std::stack<CL_Component*> components;
-
-  CL_GUIManager*      manager;
-  CL_StyleManager*    style;
-  CL_ResourceManager* resources;
-  CL_SlotContainer*   slot_container;
-};
-
-GUIManager::GUIManager()
-  : impl(new GUIManagerImpl())
-{
-  std::cout << "Creating GUIManager: " << datadir + "gui/gui.xml" << std::endl;
-  impl->slot_container = new CL_SlotContainer();
-  impl->resources = new CL_ResourceManager(datadir + "gui/gui.xml", false);
-  impl->style     = new CL_StyleManager_Silver(impl->resources);
-  impl->manager   = new CL_GUIManager(impl->style);
-  current_  = this;
-
-  // Make the manager the first component on the stack
-  push_component(impl->manager);
-}
-
-GUIManager::~GUIManager()
-{
-  pop_component();
-
-  delete impl->manager;
-  //delete style; FIXME: Memory hole?!
-  //delete resources;  FIXME: Memory hole?!
-  delete impl->slot_container;
-}
-  
-void
-GUIManager::draw()
-{
-  if (impl->manager->is_input_enabled())
-    impl->manager->show();
-}
-
-void
-GUIManager::update()
-{
-  // nothing to do
-}
-
-void
-GUIManager::run()
-{
-  impl->manager->run();
-}
-
-CL_Component* 
-GUIManager::get_component()
-{
-  return impl->components.top();
-}
-
-CL_SlotContainer*
-GUIManager::get_slot_container()
-{
-  return impl->slot_container;
-}
-
-void
-GUIManager::hide()
-{
-  if (impl->manager->is_input_enabled())
-    impl->manager->disable_input();
-}
-
-void
-GUIManager::show()
-{
-  if (!impl->manager->is_input_enabled())
-    impl->manager->enable_input();
-}
-
-bool
-GUIManager::is_visible()
-{
-  return impl->manager->is_input_enabled();
-}
-
-void
-GUIManager::quit()
-{
-  impl->manager->quit(); 
-} 
-
-void
-GUIManager::push_component(CL_Component* c)
-{
-  impl->components.push(c); 
-}
-
-void
-GUIManager::pop_component() 
-{ 
-  impl->components.pop(); 
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/gui_manager.hpp (from rev 712, trunk/flexlay/lib/gui_manager.hxx)
===================================================================
--- trunk/flexlay/lib/gui_manager.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/gui_manager.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,60 @@
+//  $Id: gui_manager.hpp,v 1.2 2003/10/12 11:58:09 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_GUI_MANAGER_HXX
+#define HEADER_GUI_MANAGER_HXX
+
+#include "shared_ptr.hpp"
+
+class GUIManagerImpl;
+
+/** */
+class GUIManager
+{
+private:
+  static GUIManager* current_;
+
+public:
+  static GUIManager* current() { return current_; }
+
+  GUIManager();
+  ~GUIManager();
+
+  void draw();
+  void update();
+
+  void run();
+  void quit();
+
+  void push_component(CL_Component* c);
+  void pop_component();
+
+  void hide();
+  void show();
+  bool is_visible();
+
+  CL_Component* get_component();  
+  CL_SlotContainer* get_slot_container();
+
+private:
+  SharedPtr<GUIManagerImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/gui_manager.hxx
===================================================================
--- trunk/flexlay/lib/gui_manager.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/gui_manager.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,60 +0,0 @@
-//  $Id: gui_manager.hxx,v 1.2 2003/10/12 11:58:09 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_GUI_MANAGER_HXX
-#define HEADER_GUI_MANAGER_HXX
-
-#include "shared_ptr.hxx"
-
-class GUIManagerImpl;
-
-/** */
-class GUIManager
-{
-private:
-  static GUIManager* current_;
-
-public:
-  static GUIManager* current() { return current_; }
-
-  GUIManager();
-  ~GUIManager();
-
-  void draw();
-  void update();
-
-  void run();
-  void quit();
-
-  void push_component(CL_Component* c);
-  void pop_component();
-
-  void hide();
-  void show();
-  bool is_visible();
-
-  CL_Component* get_component();  
-  CL_SlotContainer* get_slot_container();
-
-private:
-  SharedPtr<GUIManagerImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/helper.cpp (from rev 712, trunk/flexlay/lib/helper.cxx)
===================================================================
--- trunk/flexlay/lib/helper.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/helper.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,168 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <map>
+#include <string>
+#include <ClanLib/Display/sprite_description.h>
+#include <ClanLib/Display/pixel_format.h>
+#include <ClanLib/Display/Providers/provider_factory.h>
+#include <ClanLib/core.h>
+#include "blitter.hpp"
+#include "helper.hpp"
+
+typedef std::map<std::string, CL_PixelBuffer> PixelBufferCache;
+PixelBufferCache pixelbuffer_cache;
+
+CL_PixelBuffer get_pixelbuffer(const std::string& filename)
+{
+  PixelBufferCache::iterator it = pixelbuffer_cache.find(filename);
+  
+  if (it == pixelbuffer_cache.end())
+    return (pixelbuffer_cache[filename] = CL_ProviderFactory::load(filename));
+  else
+    return it->second;
+}
+
+CL_Sprite
+pixelbuffer2sprite(const CL_PixelBuffer& buffer)
+{
+  CL_SpriteDescription desc;
+  desc.add_frame(buffer);
+  return CL_Sprite(desc);
+}
+
+CL_Sprite
+make_sprite(const std::string& filename)
+{
+  try {
+    CL_SpriteDescription desc;
+    desc.add_frame(get_pixelbuffer(filename));
+    return CL_Sprite(desc);
+  } catch (CL_Error& err) {
+    std::cout << "CL_Error: " << err.message << std::endl;
+    return CL_Sprite();
+  }
+}
+
+CL_PixelBuffer
+make_pixelbuffer(const std::string& filename)
+{
+  try {
+    return get_pixelbuffer(filename);
+  } catch (CL_Error& err) {
+    std::cout << "CL_Error: " << err.message << std::endl;
+    return CL_PixelBuffer();
+  }
+}
+
+CL_PixelBuffer
+make_region_pixelbuffer(const std::string& filename, int x, int y, int w, int h)
+{
+  try {
+    CL_PixelBuffer buffer = get_pixelbuffer(filename);
+
+    CL_PixelBuffer target(w, h, w * (buffer.get_format().get_depth()/8), buffer.get_format());
+    clear(target);
+    blit_opaque(target, buffer, -x, -y);
+
+    return target;
+  } catch (CL_Error& err) {
+    std::cout << "CL_Error: " << err.message << std::endl;
+    return CL_PixelBuffer();
+  }
+
+}
+
+CL_Sprite
+make_sprite_from_resource(const std::string& filename, CL_ResourceManager& resources)
+{
+  try {
+    return CL_Sprite(filename, &resources);
+  } catch (CL_Error& err) {
+    std::cout << "CL_Error: " << err.message << std::endl;
+    return CL_Sprite();
+  }  
+}
+
+CL_PixelBuffer
+make_pixelbuffer_from_resource(const std::string& filename, CL_ResourceManager& resources)
+{
+  try {
+    // FIXME: expects a sprite, won't work with 'surface'
+    CL_SpriteDescription descr(filename, &resources);
+    return CL_PixelBuffer(descr.get_frames().begin()->first);
+  } catch (CL_Error& err) {
+    std::cout << "CL_Error: " << err.message << std::endl;
+    return CL_PixelBuffer();
+  }
+}
+
+CL_PixelBuffer
+make_pixelbuffer(int width, int height)
+{
+  return CL_PixelBuffer(width, height, width*4, CL_PixelFormat::rgba8888);
+}
+
+CL_PixelBuffer
+make_region_pixelbuffer(const CL_PixelBuffer& buffer, int x, int y, int w, int h)
+{
+  try {
+    CL_PixelBuffer target(w, h, w * (buffer.get_format().get_depth()/8), buffer.get_format());
+    clear(target);
+    blit_opaque(target, buffer, -x, -y);
+
+    return target;
+  } catch (CL_Error& err) {
+    std::cout << "CL_Error: " << err.message << std::endl;
+    return CL_PixelBuffer();
+  }
+}
+
+CL_PixelBuffer
+scale_pixelbuffer(CL_PixelBuffer buffer)
+{
+  CL_PixelBuffer target(buffer.get_width()/2, buffer.get_height()/2, (buffer.get_width()/2)*4, 
+                        CL_PixelFormat::rgba8888);
+
+  target.lock();
+  buffer.lock();
+
+  unsigned char* target_buf = static_cast<unsigned char*>(target.get_data());
+  unsigned char* buffer_buf = static_cast<unsigned char*>(buffer.get_data());
+  
+  int width  = target.get_width();
+  int height = target.get_height();
+  int target_pitch = target.get_pitch();
+  int buffer_pitch = buffer.get_pitch();
+  
+  for(int y = 0; y < height; ++y)
+    for(int x = 0; x < width; ++x)
+      {
+        target_buf[target_pitch*y + 4*x + 0] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 0];
+        target_buf[target_pitch*y + 4*x + 1] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 1];
+        target_buf[target_pitch*y + 4*x + 2] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 2];
+        target_buf[target_pitch*y + 4*x + 3] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 3];
+      }
+
+  buffer.unlock();
+  target.unlock();
+  
+  return target;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/helper.cxx
===================================================================
--- trunk/flexlay/lib/helper.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/helper.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,168 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <map>
-#include <string>
-#include <ClanLib/Display/sprite_description.h>
-#include <ClanLib/Display/pixel_format.h>
-#include <ClanLib/Display/Providers/provider_factory.h>
-#include <ClanLib/core.h>
-#include "blitter.hxx"
-#include "helper.hxx"
-
-typedef std::map<std::string, CL_PixelBuffer> PixelBufferCache;
-PixelBufferCache pixelbuffer_cache;
-
-CL_PixelBuffer get_pixelbuffer(const std::string& filename)
-{
-  PixelBufferCache::iterator it = pixelbuffer_cache.find(filename);
-  
-  if (it == pixelbuffer_cache.end())
-    return (pixelbuffer_cache[filename] = CL_ProviderFactory::load(filename));
-  else
-    return it->second;
-}
-
-CL_Sprite
-pixelbuffer2sprite(const CL_PixelBuffer& buffer)
-{
-  CL_SpriteDescription desc;
-  desc.add_frame(buffer);
-  return CL_Sprite(desc);
-}
-
-CL_Sprite
-make_sprite(const std::string& filename)
-{
-  try {
-    CL_SpriteDescription desc;
-    desc.add_frame(get_pixelbuffer(filename));
-    return CL_Sprite(desc);
-  } catch (CL_Error& err) {
-    std::cout << "CL_Error: " << err.message << std::endl;
-    return CL_Sprite();
-  }
-}
-
-CL_PixelBuffer
-make_pixelbuffer(const std::string& filename)
-{
-  try {
-    return get_pixelbuffer(filename);
-  } catch (CL_Error& err) {
-    std::cout << "CL_Error: " << err.message << std::endl;
-    return CL_PixelBuffer();
-  }
-}
-
-CL_PixelBuffer
-make_region_pixelbuffer(const std::string& filename, int x, int y, int w, int h)
-{
-  try {
-    CL_PixelBuffer buffer = get_pixelbuffer(filename);
-
-    CL_PixelBuffer target(w, h, w * (buffer.get_format().get_depth()/8), buffer.get_format());
-    clear(target);
-    blit_opaque(target, buffer, -x, -y);
-
-    return target;
-  } catch (CL_Error& err) {
-    std::cout << "CL_Error: " << err.message << std::endl;
-    return CL_PixelBuffer();
-  }
-
-}
-
-CL_Sprite
-make_sprite_from_resource(const std::string& filename, CL_ResourceManager& resources)
-{
-  try {
-    return CL_Sprite(filename, &resources);
-  } catch (CL_Error& err) {
-    std::cout << "CL_Error: " << err.message << std::endl;
-    return CL_Sprite();
-  }  
-}
-
-CL_PixelBuffer
-make_pixelbuffer_from_resource(const std::string& filename, CL_ResourceManager& resources)
-{
-  try {
-    // FIXME: expects a sprite, won't work with 'surface'
-    CL_SpriteDescription descr(filename, &resources);
-    return CL_PixelBuffer(descr.get_frames().begin()->first);
-  } catch (CL_Error& err) {
-    std::cout << "CL_Error: " << err.message << std::endl;
-    return CL_PixelBuffer();
-  }
-}
-
-CL_PixelBuffer
-make_pixelbuffer(int width, int height)
-{
-  return CL_PixelBuffer(width, height, width*4, CL_PixelFormat::rgba8888);
-}
-
-CL_PixelBuffer
-make_region_pixelbuffer(const CL_PixelBuffer& buffer, int x, int y, int w, int h)
-{
-  try {
-    CL_PixelBuffer target(w, h, w * (buffer.get_format().get_depth()/8), buffer.get_format());
-    clear(target);
-    blit_opaque(target, buffer, -x, -y);
-
-    return target;
-  } catch (CL_Error& err) {
-    std::cout << "CL_Error: " << err.message << std::endl;
-    return CL_PixelBuffer();
-  }
-}
-
-CL_PixelBuffer
-scale_pixelbuffer(CL_PixelBuffer buffer)
-{
-  CL_PixelBuffer target(buffer.get_width()/2, buffer.get_height()/2, (buffer.get_width()/2)*4, 
-                        CL_PixelFormat::rgba8888);
-
-  target.lock();
-  buffer.lock();
-
-  unsigned char* target_buf = static_cast<unsigned char*>(target.get_data());
-  unsigned char* buffer_buf = static_cast<unsigned char*>(buffer.get_data());
-  
-  int width  = target.get_width();
-  int height = target.get_height();
-  int target_pitch = target.get_pitch();
-  int buffer_pitch = buffer.get_pitch();
-  
-  for(int y = 0; y < height; ++y)
-    for(int x = 0; x < width; ++x)
-      {
-        target_buf[target_pitch*y + 4*x + 0] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 0];
-        target_buf[target_pitch*y + 4*x + 1] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 1];
-        target_buf[target_pitch*y + 4*x + 2] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 2];
-        target_buf[target_pitch*y + 4*x + 3] = buffer_buf[buffer_pitch * y*2 + 4*x*2 + 3];
-      }
-
-  buffer.unlock();
-  target.unlock();
-  
-  return target;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/helper.hpp (from rev 712, trunk/flexlay/lib/helper.hxx)

Deleted: trunk/flexlay/lib/helper.hxx
===================================================================
--- trunk/flexlay/lib/helper.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/helper.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,37 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_HELPER_HXX
-#define HEADER_HELPER_HXX
-
-#include <ClanLib/Display/sprite.h>
-#include <ClanLib/Display/pixel_buffer.h>
-
-CL_Sprite      pixelbuffer2sprite(const CL_PixelBuffer& buffer);
-CL_Sprite      make_sprite(const std::string& filename);
-CL_PixelBuffer make_pixelbuffer(const std::string& filename);
-CL_PixelBuffer make_region_pixelbuffer(const std::string& filename, int x, int y, int w, int h);
-CL_PixelBuffer make_region_pixelbuffer(const CL_PixelBuffer& buffer, int x, int y, int w, int h);
-CL_PixelBuffer make_pixelbuffer(int width, int height);
-CL_PixelBuffer scale_pixelbuffer(CL_PixelBuffer buffer);
-
-CL_Sprite      make_sprite_from_resource(const std::string& filename, CL_ResourceManager& resources);
-CL_PixelBuffer make_pixelbuffer_from_resource(const std::string& filename, CL_ResourceManager& resources);
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/icon.cpp (from rev 712, trunk/flexlay/lib/icon.cxx)
===================================================================
--- trunk/flexlay/lib/icon.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/icon.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,168 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include <ClanLib/Display/display.h>
+#include <ClanLib/Display/display_iostream.h>
+#include "box.hpp"
+#include "fonts.hpp"
+#include "icon.hpp"
+
+class IconImpl
+{
+public:
+  IconImpl(Icon* p) : parent(p) {}
+
+  Icon* parent;
+
+  std::vector<CL_Slot> slots;
+  CL_Sprite sprite;
+  std::string tooltip;
+  bool draw_tooltip;
+  bool down;
+
+  /** Parameter to keep the button down all the time, aka togglebutton
+      like */
+  bool is_down;
+
+  bool is_enabled;
+  CL_Signal_v0 sig_on_click;
+
+  void draw();
+
+  void mouse_up  (const CL_InputEvent& event);
+  void mouse_down(const CL_InputEvent& event);
+  void mouse_move(const CL_InputEvent& event);
+};
+
+Icon::Icon(const CL_Rect& rect, const CL_Sprite& sprite, const std::string& tooltip, 
+           CL_Component* parent)
+  : CL_Component(rect, parent),
+    impl(new IconImpl(this))
+{
+  impl->sprite       = sprite;
+  impl->tooltip      = tooltip;
+  impl->draw_tooltip = true;
+  impl->down         = false;
+  impl->is_down      = false;
+  impl->is_enabled   = true;
+
+  impl->slots.push_back(sig_paint().connect(impl.get(), &IconImpl::draw));
+  impl->slots.push_back(sig_mouse_down().connect(impl.get(), &IconImpl::mouse_down));
+  impl->slots.push_back(sig_mouse_up().connect(impl.get(),   &IconImpl::mouse_up));
+}
+
+CL_Signal_v0&
+Icon::sig_clicked()
+{
+  return impl->sig_on_click;
+}
+  
+void
+IconImpl::draw()
+{
+  CL_Display::push_translate(parent->get_screen_x(), parent->get_screen_y());
+  CL_Rect rect(CL_Point(0, 0), CL_Size(parent->get_width()-4, parent->get_height()-4));
+
+  sprite.set_alignment(origin_center);
+
+  if (is_enabled)
+    {
+      if (is_down)
+        {
+          Box::draw_button_down(rect);
+        }
+      else
+        {
+          if (parent->has_mouse_over())
+            {
+              if (down)
+                Box::draw_button_down(rect);
+              else
+                Box::draw_button_up(rect);
+            }
+          else
+            Box::draw_button_neutral(rect);
+        }
+      sprite.set_alpha(1.0f);
+    }
+  else
+    {
+      Box::draw_button_neutral(rect);
+      sprite.set_alpha(0.3f);
+    }
+  sprite.draw((rect.get_width()+1)/2, (rect.get_height()+1)/2);
+  CL_Display::pop_modelview();
+}
+
+void
+IconImpl::mouse_up  (const CL_InputEvent& event)
+{
+  if (is_enabled)
+    {
+      down         = false;
+      parent->release_mouse();  
+
+      if (parent->has_mouse_over())
+        {
+          sig_on_click();
+        }
+    }
+}
+
+void
+IconImpl::mouse_down(const CL_InputEvent& event)
+{
+  if (is_enabled)
+    {
+      down         = true;
+      parent->capture_mouse();
+    }
+}
+
+void 
+IconImpl::mouse_move(const CL_InputEvent& event)
+{
+  //std::cout << "icon: mouse_move: " << event << std::endl;
+}
+
+void
+Icon::disable()
+{
+  impl->is_enabled = false;
+}
+
+void
+Icon::enable()
+{
+  impl->is_enabled = true;
+}
+
+void
+Icon::set_up()
+{
+  impl->is_down = false;
+}
+
+void
+Icon::set_down()
+{
+  impl->is_down = true;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/icon.cxx
===================================================================
--- trunk/flexlay/lib/icon.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/icon.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,168 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/display_iostream.h>
-#include "box.hxx"
-#include "fonts.hxx"
-#include "icon.hxx"
-
-class IconImpl
-{
-public:
-  IconImpl(Icon* p) : parent(p) {}
-
-  Icon* parent;
-
-  std::vector<CL_Slot> slots;
-  CL_Sprite sprite;
-  std::string tooltip;
-  bool draw_tooltip;
-  bool down;
-
-  /** Parameter to keep the button down all the time, aka togglebutton
-      like */
-  bool is_down;
-
-  bool is_enabled;
-  CL_Signal_v0 sig_on_click;
-
-  void draw();
-
-  void mouse_up  (const CL_InputEvent& event);
-  void mouse_down(const CL_InputEvent& event);
-  void mouse_move(const CL_InputEvent& event);
-};
-
-Icon::Icon(const CL_Rect& rect, const CL_Sprite& sprite, const std::string& tooltip, 
-           CL_Component* parent)
-  : CL_Component(rect, parent),
-    impl(new IconImpl(this))
-{
-  impl->sprite       = sprite;
-  impl->tooltip      = tooltip;
-  impl->draw_tooltip = true;
-  impl->down         = false;
-  impl->is_down      = false;
-  impl->is_enabled   = true;
-
-  impl->slots.push_back(sig_paint().connect(impl.get(), &IconImpl::draw));
-  impl->slots.push_back(sig_mouse_down().connect(impl.get(), &IconImpl::mouse_down));
-  impl->slots.push_back(sig_mouse_up().connect(impl.get(),   &IconImpl::mouse_up));
-}
-
-CL_Signal_v0&
-Icon::sig_clicked()
-{
-  return impl->sig_on_click;
-}
-  
-void
-IconImpl::draw()
-{
-  CL_Display::push_translate(parent->get_screen_x(), parent->get_screen_y());
-  CL_Rect rect(CL_Point(0, 0), CL_Size(parent->get_width()-4, parent->get_height()-4));
-
-  sprite.set_alignment(origin_center);
-
-  if (is_enabled)
-    {
-      if (is_down)
-        {
-          Box::draw_button_down(rect);
-        }
-      else
-        {
-          if (parent->has_mouse_over())
-            {
-              if (down)
-                Box::draw_button_down(rect);
-              else
-                Box::draw_button_up(rect);
-            }
-          else
-            Box::draw_button_neutral(rect);
-        }
-      sprite.set_alpha(1.0f);
-    }
-  else
-    {
-      Box::draw_button_neutral(rect);
-      sprite.set_alpha(0.3f);
-    }
-  sprite.draw((rect.get_width()+1)/2, (rect.get_height()+1)/2);
-  CL_Display::pop_modelview();
-}
-
-void
-IconImpl::mouse_up  (const CL_InputEvent& event)
-{
-  if (is_enabled)
-    {
-      down         = false;
-      parent->release_mouse();  
-
-      if (parent->has_mouse_over())
-        {
-          sig_on_click();
-        }
-    }
-}
-
-void
-IconImpl::mouse_down(const CL_InputEvent& event)
-{
-  if (is_enabled)
-    {
-      down         = true;
-      parent->capture_mouse();
-    }
-}
-
-void 
-IconImpl::mouse_move(const CL_InputEvent& event)
-{
-  //std::cout << "icon: mouse_move: " << event << std::endl;
-}
-
-void
-Icon::disable()
-{
-  impl->is_enabled = false;
-}
-
-void
-Icon::enable()
-{
-  impl->is_enabled = true;
-}
-
-void
-Icon::set_up()
-{
-  impl->is_down = false;
-}
-
-void
-Icon::set_down()
-{
-  impl->is_down = true;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/icon.hpp (from rev 712, trunk/flexlay/lib/icon.hxx)
===================================================================
--- trunk/flexlay/lib/icon.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/icon.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,54 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_ICON_HXX
+#define HEADER_ICON_HXX
+
+#include <ClanLib/GUI/component.h>
+#include <ClanLib/Core/Math/point.h>
+#include <ClanLib/Display/sprite.h>
+#include "shared_ptr.hpp"
+
+class IconImpl;
+
+/** */
+class Icon : public CL_Component
+{
+protected:
+  virtual ~Icon() {}
+public:
+  Icon(const CL_Rect& rect, const CL_Sprite& sprite, const std::string& tooltip, CL_Component* parent);
+
+  void disable();
+  void enable();
+
+  void set_up();
+  void set_down();
+  
+  CL_Signal_v0& sig_clicked();
+
+private:
+  Icon (const Icon&);
+  Icon& operator= (const Icon&);
+
+  SharedPtr<IconImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/icon.hxx
===================================================================
--- trunk/flexlay/lib/icon.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/icon.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,54 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_ICON_HXX
-#define HEADER_ICON_HXX
-
-#include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/Math/point.h>
-#include <ClanLib/Display/sprite.h>
-#include "shared_ptr.hxx"
-
-class IconImpl;
-
-/** */
-class Icon : public CL_Component
-{
-protected:
-  virtual ~Icon() {}
-public:
-  Icon(const CL_Rect& rect, const CL_Sprite& sprite, const std::string& tooltip, CL_Component* parent);
-
-  void disable();
-  void enable();
-
-  void set_up();
-  void set_down();
-  
-  CL_Signal_v0& sig_clicked();
-
-private:
-  Icon (const Icon&);
-  Icon& operator= (const Icon&);
-
-  SharedPtr<IconImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/layer.cpp (from rev 712, trunk/flexlay/lib/layer.cxx)
===================================================================
--- trunk/flexlay/lib/layer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/layer.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,117 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include <ClanLib/Display/display.h>
+#include "layer_impl.hpp"
+#include "layer.hpp"
+
+Layer::Layer()
+  : impl(0)
+{
+}
+
+Layer::Layer(SharedPtr<LayerImpl> i)
+  : impl(i)
+{
+}
+
+Layer::~Layer()
+{
+}
+
+void
+Layer::draw(EditorMapComponent* parent, CL_GraphicContext* gc) 
+{ 
+  if (impl.get())
+    {
+      if (impl->pos.x != 0 || impl->pos.y != 0)
+        {
+          gc->push_modelview();
+          gc->add_translate(impl->pos.x, impl->pos.y);
+          impl->draw(parent, gc);
+          gc->pop_modelview();
+        }
+      else
+        {
+          impl->draw(parent, gc);
+        }
+    }
+}
+  
+bool
+Layer::has_bounding_rect() const 
+{
+  if (impl.get())
+    return impl->has_bounding_rect(); 
+  else
+    return false;
+} 
+
+CL_Rect
+Layer::get_bounding_rect() 
+{ 
+  CL_Rect rect;
+  
+  if (impl.get())
+    {
+      rect = impl->get_bounding_rect();
+      rect.left   += static_cast<int>(impl->pos.x);
+      rect.top    += static_cast<int>(impl->pos.y);
+      rect.right  += static_cast<int>(impl->pos.x);
+      rect.bottom += static_cast<int>(impl->pos.y);
+    }
+  
+  return rect;
+}
+
+MetaData
+Layer::get_metadata() const
+{
+  if (impl.get())
+    return impl->data; 
+  else
+    return MetaData();
+}
+
+void
+Layer::set_metadata(MetaData data_)
+{
+  if (impl.get())
+    impl->data = data_;
+}
+
+void
+Layer::set_pos(const CL_Pointf& pos)
+{
+  impl->pos = pos;
+}
+
+CL_Pointf
+Layer::get_pos() const
+{
+  return impl->pos;
+}
+
+bool
+Layer::is_null() const
+{
+  return impl.get() == 0;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/layer.cxx
===================================================================
--- trunk/flexlay/lib/layer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/layer.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,117 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <ClanLib/Display/display.h>
-#include "layer_impl.hxx"
-#include "layer.hxx"
-
-Layer::Layer()
-  : impl(0)
-{
-}
-
-Layer::Layer(SharedPtr<LayerImpl> i)
-  : impl(i)
-{
-}
-
-Layer::~Layer()
-{
-}
-
-void
-Layer::draw(EditorMapComponent* parent, CL_GraphicContext* gc) 
-{ 
-  if (impl.get())
-    {
-      if (impl->pos.x != 0 || impl->pos.y != 0)
-        {
-          gc->push_modelview();
-          gc->add_translate(impl->pos.x, impl->pos.y);
-          impl->draw(parent, gc);
-          gc->pop_modelview();
-        }
-      else
-        {
-          impl->draw(parent, gc);
-        }
-    }
-}
-  
-bool
-Layer::has_bounding_rect() const 
-{
-  if (impl.get())
-    return impl->has_bounding_rect(); 
-  else
-    return false;
-} 
-
-CL_Rect
-Layer::get_bounding_rect() 
-{ 
-  CL_Rect rect;
-  
-  if (impl.get())
-    {
-      rect = impl->get_bounding_rect();
-      rect.left   += static_cast<int>(impl->pos.x);
-      rect.top    += static_cast<int>(impl->pos.y);
-      rect.right  += static_cast<int>(impl->pos.x);
-      rect.bottom += static_cast<int>(impl->pos.y);
-    }
-  
-  return rect;
-}
-
-MetaData
-Layer::get_metadata() const
-{
-  if (impl.get())
-    return impl->data; 
-  else
-    return MetaData();
-}
-
-void
-Layer::set_metadata(MetaData data_)
-{
-  if (impl.get())
-    impl->data = data_;
-}
-
-void
-Layer::set_pos(const CL_Pointf& pos)
-{
-  impl->pos = pos;
-}
-
-CL_Pointf
-Layer::get_pos() const
-{
-  return impl->pos;
-}
-
-bool
-Layer::is_null() const
-{
-  return impl.get() == 0;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/layer.hpp (from rev 712, trunk/flexlay/lib/layer.hxx)
===================================================================
--- trunk/flexlay/lib/layer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/layer.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,67 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_LAYER_HXX
+#define HEADER_LAYER_HXX
+
+#include <ClanLib/Core/Math/rect.h>
+#include <ClanLib/Display/graphic_context.h>
+#include "meta_data.hpp"
+#include "shared_ptr.hpp"
+
+class EditorMapComponent;
+class LayerImpl;
+
+/** Each \a EditorMap consists out of one or more \a Layer,
+    The \a Layer is an abstract base class from which the
+    data holding layers derive. The basic functionality of a layer
+    consists only of data holding and visualization. (FIXME: move
+    visuals off into another class) */
+class Layer
+{
+private:
+public:
+  Layer();
+  Layer(SharedPtr<LayerImpl> i);
+  ~Layer();
+
+  MetaData get_metadata() const;
+  
+  /** Attaches a piece of MetaData to the layer, metadata is some user
+      supplied piece of data that is associated with a layer (ie. the
+      name of the layer or similar properties which aren't handled by
+      the layer itself) */
+  void     set_metadata(MetaData data_);
+
+  void draw(EditorMapComponent* parent, CL_GraphicContext* gc);
+  bool has_bounding_rect() const;
+  CL_Rect get_bounding_rect();
+
+  /** Moves the layer to the given position */
+  void set_pos(const CL_Pointf& pos);
+
+  /** Returns the current position of the layer */
+  CL_Pointf get_pos() const;
+  bool is_null() const;
+public:
+  SharedPtr<LayerImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/layer.hxx
===================================================================
--- trunk/flexlay/lib/layer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/layer.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,67 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_LAYER_HXX
-#define HEADER_LAYER_HXX
-
-#include <ClanLib/Core/Math/rect.h>
-#include <ClanLib/Display/graphic_context.h>
-#include "meta_data.hxx"
-#include "shared_ptr.hxx"
-
-class EditorMapComponent;
-class LayerImpl;
-
-/** Each \a EditorMap consists out of one or more \a Layer,
-    The \a Layer is an abstract base class from which the
-    data holding layers derive. The basic functionality of a layer
-    consists only of data holding and visualization. (FIXME: move
-    visuals off into another class) */
-class Layer
-{
-private:
-public:
-  Layer();
-  Layer(SharedPtr<LayerImpl> i);
-  ~Layer();
-
-  MetaData get_metadata() const;
-  
-  /** Attaches a piece of MetaData to the layer, metadata is some user
-      supplied piece of data that is associated with a layer (ie. the
-      name of the layer or similar properties which aren't handled by
-      the layer itself) */
-  void     set_metadata(MetaData data_);
-
-  void draw(EditorMapComponent* parent, CL_GraphicContext* gc);
-  bool has_bounding_rect() const;
-  CL_Rect get_bounding_rect();
-
-  /** Moves the layer to the given position */
-  void set_pos(const CL_Pointf& pos);
-
-  /** Returns the current position of the layer */
-  CL_Pointf get_pos() const;
-  bool is_null() const;
-public:
-  SharedPtr<LayerImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/layer_impl.hpp (from rev 712, trunk/flexlay/lib/layer_impl.hxx)
===================================================================
--- trunk/flexlay/lib/layer_impl.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/layer_impl.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,55 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_LAYER_IMPL_HXX
+#define HEADER_LAYER_IMPL_HXX
+
+#include <ClanLib/Core/Math/rect.h>
+#include <ClanLib/Display/graphic_context.h>
+#include "meta_data.hpp"
+
+class EditorMapComponent;
+
+class LayerImpl
+{
+public:
+  /** MetaData attached to the layer, MetaData can be any data
+      supplied by the user, but most commonly it is used to associate
+      the given layer with a scripting language object (PyObj, SCM,
+      etc.), so that the user can attach additional data to a layer
+      from the scripting side. */
+  MetaData  data;
+  
+  /** The position of the layer */
+  CL_Pointf pos;
+
+  LayerImpl() 
+    : pos(0, 0)
+  {}
+  virtual ~LayerImpl() {}
+
+  virtual void draw(EditorMapComponent* parent, CL_GraphicContext* gc) =0;
+  virtual bool has_bounding_rect() const =0;
+
+  // FIXME: Should use CL_Rectf
+  virtual CL_Rect get_bounding_rect() { return CL_Rect(); }
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/layer_impl.hxx
===================================================================
--- trunk/flexlay/lib/layer_impl.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/layer_impl.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,55 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_LAYER_IMPL_HXX
-#define HEADER_LAYER_IMPL_HXX
-
-#include <ClanLib/Core/Math/rect.h>
-#include <ClanLib/Display/graphic_context.h>
-#include "meta_data.hxx"
-
-class EditorMapComponent;
-
-class LayerImpl
-{
-public:
-  /** MetaData attached to the layer, MetaData can be any data
-      supplied by the user, but most commonly it is used to associate
-      the given layer with a scripting language object (PyObj, SCM,
-      etc.), so that the user can attach additional data to a layer
-      from the scripting side. */
-  MetaData  data;
-  
-  /** The position of the layer */
-  CL_Pointf pos;
-
-  LayerImpl() 
-    : pos(0, 0)
-  {}
-  virtual ~LayerImpl() {}
-
-  virtual void draw(EditorMapComponent* parent, CL_GraphicContext* gc) =0;
-  virtual bool has_bounding_rect() const =0;
-
-  // FIXME: Should use CL_Rectf
-  virtual CL_Rect get_bounding_rect() { return CL_Rect(); }
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/lispreader.cpp (from rev 712, trunk/flexlay/lib/lispreader.cxx)
===================================================================
--- trunk/flexlay/lib/lispreader.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/lispreader.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,1358 @@
+/* $Id: lispreader.cpp,v 1.19 2004/05/11 22:16:12 sik0fewl Exp $ */
+/*
+ * lispreader.c
+ *
+ * Copyright (C) 1998-2000 Mark Probst
+ * Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <iostream>
+#include <string>
+#include <ctype.h>
+#include <stdlib.h>
+#include <string.h>
+#include "lispreader.hpp"
+
+#define TOKEN_ERROR                   -1
+#define TOKEN_EOF                     0
+#define TOKEN_OPEN_PAREN              1
+#define TOKEN_CLOSE_PAREN             2
+#define TOKEN_SYMBOL                  3
+#define TOKEN_STRING                  4
+#define TOKEN_INTEGER                 5
+#define TOKEN_REAL                    6
+#define TOKEN_PATTERN_OPEN_PAREN      7
+#define TOKEN_DOT                     8
+#define TOKEN_TRUE                    9
+#define TOKEN_FALSE                   10
+
+
+#define MAX_TOKEN_LENGTH           1024
+
+static char token_string[MAX_TOKEN_LENGTH + 1] = "";
+static int token_length = 0;
+
+static lisp_object_t end_marker = { LISP_TYPE_EOF, {{0, 0}} };
+static lisp_object_t error_object = { LISP_TYPE_PARSE_ERROR , {{0,0}}  };
+static lisp_object_t close_paren_marker = { LISP_TYPE_PARSE_ERROR , {{0,0}}  };
+static lisp_object_t dot_marker = { LISP_TYPE_PARSE_ERROR , {{0,0}} };
+
+static void
+_token_clear (void)
+{
+  token_string[0] = '\0';
+  token_length = 0;
+}
+
+static void
+_token_append (char c)
+{
+  if (token_length >= MAX_TOKEN_LENGTH)
+    throw LispReaderException("_token_append()", __FILE__, __LINE__);
+
+  token_string[token_length++] = c;
+  token_string[token_length] = '\0';
+}
+
+static int
+_next_char (lisp_stream_t *stream)
+{
+  switch (stream->type)
+    {
+    case LISP_STREAM_FILE :
+      return getc(stream->v.file);
+
+    case LISP_STREAM_STRING :
+      {
+        char c = stream->v.string.buf[stream->v.string.pos];
+
+        if (c == 0)
+          return EOF;
+
+        ++stream->v.string.pos;
+
+        return c;
+      }
+
+    case LISP_STREAM_ANY:
+      return stream->v.any.next_char(stream->v.any.data);
+    }
+
+  throw LispReaderException("_next_char()", __FILE__, __LINE__);
+  return EOF;
+}
+
+static void
+_unget_char (char c, lisp_stream_t *stream)
+{
+  switch (stream->type)
+    {
+    case LISP_STREAM_FILE :
+      ungetc(c, stream->v.file);
+      break;
+
+    case LISP_STREAM_STRING :
+      --stream->v.string.pos;
+      break;
+
+    case LISP_STREAM_ANY:
+      stream->v.any.unget_char(c, stream->v.any.data);
+      break;
+
+    default :
+      throw LispReaderException("_unget_char()", __FILE__, __LINE__);
+    }
+}
+
+static int
+_scan (lisp_stream_t *stream)
+{
+  static char *delims = "\"();";
+
+  int c;
+
+  _token_clear();
+
+  do
+    {
+      c = _next_char(stream);
+      if (c == EOF)
+        return TOKEN_EOF;
+      else if (c == ';')     	 /* comment start */
+        while (1)
+          {
+            c = _next_char(stream);
+            if (c == EOF)
+              return TOKEN_EOF;
+            else if (c == '\n')
+              break;
+          }
+    }
+  while (isspace(c));
+
+  switch (c)
+    {
+    case '(' :
+      return TOKEN_OPEN_PAREN;
+
+    case ')' :
+      return TOKEN_CLOSE_PAREN;
+
+    case '"' :
+      while (1)
+        {
+          c = _next_char(stream);
+          if (c == EOF)
+            return TOKEN_ERROR;
+          if (c == '"')
+            break;
+          if (c == '\\')
+            {
+              c = _next_char(stream);
+
+              switch (c)
+                {
+                case EOF :
+                  return TOKEN_ERROR;
+
+                case 'n' :
+                  c = '\n';
+                  break;
+
+                case 't' :
+                  c = '\t';
+                  break;
+                }
+            }
+
+          _token_append(c);
+        }
+      return TOKEN_STRING;
+
+    case '#' :
+      c = _next_char(stream);
+      if (c == EOF)
+        return TOKEN_ERROR;
+
+      switch (c)
+        {
+        case 't' :
+          return TOKEN_TRUE;
+
+        case 'f' :
+          return TOKEN_FALSE;
+
+        case '?' :
+          c = _next_char(stream);
+          if (c == EOF)
+            return TOKEN_ERROR;
+
+          if (c == '(')
+            return TOKEN_PATTERN_OPEN_PAREN;
+          else
+            return TOKEN_ERROR;
+        }
+      return TOKEN_ERROR;
+
+    default :
+      if (isdigit(c) || c == '-')
+        {
+          int have_nondigits = 0;
+          int have_digits = 0;
+          int have_floating_point = 0;
+
+          do
+            {
+              if (isdigit(c))
+                have_digits = 1;
+              else if (c == '.')
+                have_floating_point++;
+              _token_append(c);
+
+              c = _next_char(stream);
+
+              if (c != EOF && !isdigit(c) && !isspace(c) && c != '.' && !strchr(delims, c))
+                have_nondigits = 1;
+            }
+          while (c != EOF && !isspace(c) && !strchr(delims, c));
+
+          if (c != EOF)
+            _unget_char(c, stream);
+
+          if (have_nondigits || !have_digits || have_floating_point > 1)
+            return TOKEN_SYMBOL;
+          else if (have_floating_point == 1)
+            return TOKEN_REAL;
+          else
+            return TOKEN_INTEGER;
+        }
+      else
+        {
+          if (c == '.')
+            {
+              c = _next_char(stream);
+              if (c != EOF && !isspace(c) && !strchr(delims, c))
+                _token_append('.');
+              else
+                {
+                  _unget_char(c, stream);
+                  return TOKEN_DOT;
+                }
+            }
+          do
+            {
+              _token_append(c);
+              c = _next_char(stream);
+            }
+          while (c != EOF && !isspace(c) && !strchr(delims, c));
+          if (c != EOF)
+            _unget_char(c, stream);
+
+          return TOKEN_SYMBOL;
+        }
+    }
+
+  throw LispReaderException("_scan()", __FILE__, __LINE__);
+  return TOKEN_ERROR;
+}
+
+static lisp_object_t*
+lisp_object_alloc (int type)
+{
+  lisp_object_t *obj = (lisp_object_t*)malloc(sizeof(lisp_object_t));
+
+  obj->type = type;
+
+  return obj;
+}
+
+lisp_stream_t*
+lisp_stream_init_file (lisp_stream_t *stream, FILE *file)
+{
+  stream->type = LISP_STREAM_FILE;
+  stream->v.file = file;
+
+  return stream;
+}
+
+lisp_stream_t*
+lisp_stream_init_string (lisp_stream_t *stream, char *buf)
+{
+  stream->type = LISP_STREAM_STRING;
+  stream->v.string.buf = buf;
+  stream->v.string.pos = 0;
+
+  return stream;
+}
+
+lisp_stream_t*
+lisp_stream_init_any (lisp_stream_t *stream, void *data,
+                      int (*next_char) (void *data),
+                      void (*unget_char) (char c, void *data))
+{
+  if (next_char == 0 || unget_char == 0)
+    throw LispReaderException("lisp_stream_init_any()", __FILE__, __LINE__);
+
+  stream->type = LISP_STREAM_ANY;
+  stream->v.any.data = data;
+  stream->v.any.next_char= next_char;
+  stream->v.any.unget_char = unget_char;
+
+  return stream;
+}
+
+lisp_object_t*
+lisp_make_integer (int value)
+{
+  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_INTEGER);
+
+  obj->v.integer = value;
+
+  return obj;
+}
+
+lisp_object_t*
+lisp_make_real (float value)
+{
+  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_REAL);
+
+  obj->v.real = value;
+
+  return obj;
+}
+
+lisp_object_t*
+lisp_make_symbol (const char *value)
+{
+  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_SYMBOL);
+
+  obj->v.string = strdup(value);
+
+  return obj;
+}
+
+lisp_object_t*
+lisp_make_string (const char *value)
+{
+  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_STRING);
+
+  obj->v.string = strdup(value);
+
+  return obj;
+}
+
+lisp_object_t*
+lisp_make_cons (lisp_object_t *car, lisp_object_t *cdr)
+{
+  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_CONS);
+
+  obj->v.cons.car = car;
+  obj->v.cons.cdr = cdr;
+
+  return obj;
+}
+
+lisp_object_t*
+lisp_make_boolean (int value)
+{
+  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_BOOLEAN);
+
+  obj->v.integer = value ? 1 : 0;
+
+  return obj;
+}
+
+static lisp_object_t*
+lisp_make_pattern_cons (lisp_object_t *car, lisp_object_t *cdr)
+{
+  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_PATTERN_CONS);
+
+  obj->v.cons.car = car;
+  obj->v.cons.cdr = cdr;
+
+  return obj;
+}
+
+static lisp_object_t*
+lisp_make_pattern_var (int type, int index, lisp_object_t *sub)
+{
+  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_PATTERN_VAR);
+
+  obj->v.pattern.type = type;
+  obj->v.pattern.index = index;
+  obj->v.pattern.sub = sub;
+
+  return obj;
+}
+
+lisp_object_t*
+lisp_read (lisp_stream_t *in)
+{
+  int token = _scan(in);
+  lisp_object_t *obj = lisp_nil();
+
+  if (token == TOKEN_EOF)
+    return &end_marker;
+
+  switch (token)
+    {
+    case TOKEN_ERROR :
+      return &error_object;
+
+    case TOKEN_EOF :
+      return &end_marker;
+
+    case TOKEN_OPEN_PAREN :
+    case TOKEN_PATTERN_OPEN_PAREN :
+      {
+        lisp_object_t *last = lisp_nil(), *car;
+
+        do
+          {
+            car = lisp_read(in);
+            if (car == &error_object || car == &end_marker)
+              {
+                lisp_free(obj);
+                return &error_object;
+              }
+            else if (car == &dot_marker)
+              {
+                if (lisp_nil_p(last))
+                  {
+                    lisp_free(obj);
+                    return &error_object;
+                  }
+
+                car = lisp_read(in);
+                if (car == &error_object || car == &end_marker)
+                  {
+                    lisp_free(obj);
+                    return car;
+                  }
+                else
+                  {
+                    last->v.cons.cdr = car;
+
+                    if (_scan(in) != TOKEN_CLOSE_PAREN)
+                      {
+                        lisp_free(obj);
+                        return &error_object;
+                      }
+
+                    car = &close_paren_marker;
+                  }
+              }
+            else if (car != &close_paren_marker)
+              {
+                if (lisp_nil_p(last))
+                  obj = last = (token == TOKEN_OPEN_PAREN ? lisp_make_cons(car, lisp_nil()) : lisp_make_pattern_cons(car, lisp_nil()));
+                else
+                  last = last->v.cons.cdr = lisp_make_cons(car, lisp_nil());
+              }
+          }
+        while (car != &close_paren_marker);
+      }
+      return obj;
+
+    case TOKEN_CLOSE_PAREN :
+      return &close_paren_marker;
+
+    case TOKEN_SYMBOL :
+      return lisp_make_symbol(token_string);
+
+    case TOKEN_STRING :
+      return lisp_make_string(token_string);
+
+    case TOKEN_INTEGER :
+      return lisp_make_integer(atoi(token_string));
+
+    case TOKEN_REAL :
+      return lisp_make_real((float)atof(token_string));
+
+    case TOKEN_DOT :
+      return &dot_marker;
+
+    case TOKEN_TRUE :
+      return lisp_make_boolean(1);
+
+    case TOKEN_FALSE :
+      return lisp_make_boolean(0);
+    }
+
+  throw LispReaderException("lisp_read()", __FILE__, __LINE__);
+  return &error_object;
+}
+
+void
+lisp_free (lisp_object_t *obj)
+{
+  if (obj == 0)
+    return;
+
+  switch (obj->type)
+    {
+    case LISP_TYPE_INTERNAL :
+    case LISP_TYPE_PARSE_ERROR :
+    case LISP_TYPE_EOF :
+      return;
+
+    case LISP_TYPE_SYMBOL :
+    case LISP_TYPE_STRING :
+      free(obj->v.string);
+      break;
+
+    case LISP_TYPE_CONS :
+    case LISP_TYPE_PATTERN_CONS :
+      lisp_free(obj->v.cons.car);
+      lisp_free(obj->v.cons.cdr);
+      break;
+
+    case LISP_TYPE_PATTERN_VAR :
+      lisp_free(obj->v.pattern.sub);
+      break;
+    }
+
+  free(obj);
+}
+
+lisp_object_t*
+lisp_read_from_string (const char *buf)
+{
+  lisp_stream_t stream;
+
+  lisp_stream_init_string(&stream, (char*)buf);
+  return lisp_read(&stream);
+}
+
+static int
+_compile_pattern (lisp_object_t **obj, int *index)
+{
+  if (*obj == 0)
+    return 1;
+
+  switch (lisp_type(*obj))
+    {
+    case LISP_TYPE_PATTERN_CONS :
+      {
+        struct
+          {
+            char *name;
+            int type;
+          }
+        types[] =
+          {
+            { "any", LISP_PATTERN_ANY },
+            { "symbol", LISP_PATTERN_SYMBOL },
+            { "string", LISP_PATTERN_STRING },
+            { "integer", LISP_PATTERN_INTEGER },
+            { "real", LISP_PATTERN_REAL },
+            { "boolean", LISP_PATTERN_BOOLEAN },
+            { "list", LISP_PATTERN_LIST },
+            { "or", LISP_PATTERN_OR },
+            { 0, 0 }
+          };
+        char *type_name;
+        int type;
+        int i;
+        lisp_object_t *pattern;
+        type = -1;
+	
+        if (lisp_type(lisp_car(*obj)) != LISP_TYPE_SYMBOL)
+          return 0;
+
+        type_name = lisp_symbol(lisp_car(*obj));
+        for (i = 0; types[i].name != 0; ++i)
+          {
+            if (strcmp(types[i].name, type_name) == 0)
+              {
+                type = types[i].type;
+                break;
+              }
+          }
+
+        if (types[i].name == 0)
+          return 0;
+
+        if (type != LISP_PATTERN_OR && lisp_cdr(*obj) != 0)
+          return 0;
+
+        pattern = lisp_make_pattern_var(type, (*index)++, lisp_nil());
+
+        if (type == LISP_PATTERN_OR)
+          {
+            lisp_object_t *cdr = lisp_cdr(*obj);
+
+            if (!_compile_pattern(&cdr, index))
+              {
+                lisp_free(pattern);
+                return 0;
+              }
+
+            pattern->v.pattern.sub = cdr;
+
+            (*obj)->v.cons.cdr = lisp_nil();
+          }
+
+        lisp_free(*obj);
+
+        *obj = pattern;
+      }
+      break;
+
+    case LISP_TYPE_CONS :
+      if (!_compile_pattern(&(*obj)->v.cons.car, index))
+        return 0;
+      if (!_compile_pattern(&(*obj)->v.cons.cdr, index))
+        return 0;
+      break;
+    }
+
+  return 1;
+}
+
+int
+lisp_compile_pattern (lisp_object_t **obj, int *num_subs)
+{
+  int index = 0;
+  int result;
+
+  result = _compile_pattern(obj, &index);
+
+  if (result && num_subs != 0)
+    *num_subs = index;
+
+  return result;
+}
+
+static int _match_pattern (lisp_object_t *pattern, lisp_object_t *obj, lisp_object_t **vars);
+
+static int
+_match_pattern_var (lisp_object_t *pattern, lisp_object_t *obj, lisp_object_t **vars)
+{
+  if (lisp_type(pattern) != LISP_TYPE_PATTERN_VAR)
+    throw LispReaderException("_match_pattern_var", __FILE__, __LINE__);
+
+  switch (pattern->v.pattern.type)
+    {
+    case LISP_PATTERN_ANY :
+      break;
+
+    case LISP_PATTERN_SYMBOL :
+      if (obj == 0 || lisp_type(obj) != LISP_TYPE_SYMBOL)
+        return 0;
+      break;
+
+    case LISP_PATTERN_STRING :
+      if (obj == 0 || lisp_type(obj) != LISP_TYPE_STRING)
+        return 0;
+      break;
+
+    case LISP_PATTERN_INTEGER :
+      if (obj == 0 || lisp_type(obj) != LISP_TYPE_INTEGER)
+        return 0;
+      break;
+
+    case LISP_PATTERN_REAL :
+      if (obj == 0 || lisp_type(obj) != LISP_TYPE_REAL)
+        return 0;
+      break;
+
+    case LISP_PATTERN_BOOLEAN :
+      if (obj == 0 || lisp_type(obj) != LISP_TYPE_BOOLEAN)
+        return 0;
+      break;
+
+    case LISP_PATTERN_LIST :
+      if (obj == 0 || lisp_type(obj) != LISP_TYPE_CONS)
+        return 0;
+      break;
+
+    case LISP_PATTERN_OR :
+      {
+        lisp_object_t *sub;
+        int matched = 0;
+
+        for (sub = pattern->v.pattern.sub; sub != 0; sub = lisp_cdr(sub))
+          {
+            if (lisp_type(sub) != LISP_TYPE_CONS)
+              throw LispReaderException("_match_pattern_var()", __FILE__, __LINE__);
+
+            if (_match_pattern(lisp_car(sub), obj, vars))
+              matched = 1;
+          }
+
+        if (!matched)
+          return 0;
+      }
+      break;
+
+    default :
+      throw LispReaderException("_match_pattern_var()", __FILE__, __LINE__);
+    }
+
+  if (vars != 0)
+    vars[pattern->v.pattern.index] = obj;
+
+  return 1;
+}
+
+static int
+_match_pattern (lisp_object_t *pattern, lisp_object_t *obj, lisp_object_t **vars)
+{
+  if (pattern == 0)
+    return obj == 0;
+
+  if (obj == 0)
+    return 0;
+
+  if (lisp_type(pattern) == LISP_TYPE_PATTERN_VAR)
+    return _match_pattern_var(pattern, obj, vars);
+
+  if (lisp_type(pattern) != lisp_type(obj))
+    return 0;
+
+  switch (lisp_type(pattern))
+    {
+    case LISP_TYPE_SYMBOL :
+      return strcmp(lisp_symbol(pattern), lisp_symbol(obj)) == 0;
+
+    case LISP_TYPE_STRING :
+      return strcmp(lisp_string(pattern), lisp_string(obj)) == 0;
+
+    case LISP_TYPE_INTEGER :
+      return lisp_integer(pattern) == lisp_integer(obj);
+
+    case LISP_TYPE_REAL :
+      return lisp_real(pattern) == lisp_real(obj);
+
+    case LISP_TYPE_CONS :
+      {
+        int result1, result2;
+
+        result1 = _match_pattern(lisp_car(pattern), lisp_car(obj), vars);
+        result2 = _match_pattern(lisp_cdr(pattern), lisp_cdr(obj), vars);
+
+        return result1 && result2;
+      }
+      break;
+
+    default :
+      throw LispReaderException("_match_pattern()", __FILE__, __LINE__);
+    }
+
+  return 0;
+}
+
+int
+lisp_match_pattern (lisp_object_t *pattern, lisp_object_t *obj, lisp_object_t **vars, int num_subs)
+{
+  int i;
+
+  if (vars != 0)
+    for (i = 0; i < num_subs; ++i)
+      vars[i] = &error_object;
+
+  return _match_pattern(pattern, obj, vars);
+}
+
+int
+lisp_match_string (const char *pattern_string, lisp_object_t *obj, lisp_object_t **vars)
+{
+  lisp_object_t *pattern;
+  int result;
+  int num_subs;
+
+  pattern = lisp_read_from_string(pattern_string);
+
+  if (pattern != 0 && (lisp_type(pattern) == LISP_TYPE_EOF
+                       || lisp_type(pattern) == LISP_TYPE_PARSE_ERROR))
+    return 0;
+
+  if (!lisp_compile_pattern(&pattern, &num_subs))
+    {
+      lisp_free(pattern);
+      return 0;
+    }
+
+  result = lisp_match_pattern(pattern, obj, vars, num_subs);
+
+  lisp_free(pattern);
+
+  return result;
+}
+
+int
+lisp_type (lisp_object_t *obj)
+{
+  if (obj == 0)
+    return LISP_TYPE_NIL;
+  return obj->type;
+}
+
+int
+lisp_integer (lisp_object_t *obj)
+{
+  if (obj->type != LISP_TYPE_INTEGER)
+    throw LispReaderException("lisp_integer()", __FILE__, __LINE__);
+
+  return obj->v.integer;
+}
+
+char*
+lisp_symbol (lisp_object_t *obj)
+{
+  if (obj->type != LISP_TYPE_SYMBOL)
+    throw LispReaderException("lisp_symbol()", __FILE__, __LINE__);
+
+  return obj->v.string;
+}
+
+char*
+lisp_string (lisp_object_t *obj)
+{
+  if (obj->type != LISP_TYPE_STRING)
+    throw LispReaderException("lisp_string()", __FILE__, __LINE__);
+
+  return obj->v.string;
+}
+
+int
+lisp_boolean (lisp_object_t *obj)
+{
+  if (obj->type != LISP_TYPE_BOOLEAN)
+    throw LispReaderException("lisp_boolean()", __FILE__, __LINE__);
+
+  return obj->v.integer;
+}
+
+float
+lisp_real (lisp_object_t *obj)
+{
+  if (obj->type != LISP_TYPE_REAL && obj->type != LISP_TYPE_INTEGER)
+    throw LispReaderException("lisp_real()", __FILE__, __LINE__);
+
+  if (obj->type == LISP_TYPE_INTEGER)
+    return obj->v.integer;
+  return obj->v.real;
+}
+
+lisp_object_t*
+lisp_car (lisp_object_t *obj)
+{
+  if (obj->type != LISP_TYPE_CONS && obj->type != LISP_TYPE_PATTERN_CONS)
+    throw LispReaderException("lisp_car()", __FILE__, __LINE__);
+
+  return obj->v.cons.car;
+}
+
+lisp_object_t*
+lisp_cdr (lisp_object_t *obj)
+{
+  if (obj->type != LISP_TYPE_CONS && obj->type != LISP_TYPE_PATTERN_CONS)
+    throw LispReaderException("lisp_cdr()", __FILE__, __LINE__);
+
+  return obj->v.cons.cdr;
+}
+
+lisp_object_t*
+lisp_cxr (lisp_object_t *obj, const char *x)
+{
+  int i;
+
+  for (i = strlen(x) - 1; i >= 0; --i)
+    if (x[i] == 'a')
+      obj = lisp_car(obj);
+    else if (x[i] == 'd')
+      obj = lisp_cdr(obj);
+    else
+      throw LispReaderException("lisp_cxr()", __FILE__, __LINE__);
+
+  return obj;
+}
+
+int
+lisp_list_length (lisp_object_t *obj)
+{
+  int length = 0;
+
+  while (obj != 0)
+    {
+      if (obj->type != LISP_TYPE_CONS && obj->type != LISP_TYPE_PATTERN_CONS)
+        throw LispReaderException("lisp_list_length()", __FILE__, __LINE__);
+
+      ++length;
+      obj = obj->v.cons.cdr;
+    }
+
+  return length;
+}
+
+lisp_object_t*
+lisp_list_nth_cdr (lisp_object_t *obj, int index)
+{
+  while (index > 0)
+    {
+      if (obj == 0)
+        throw LispReaderException("lisp_list_nth_cdr()", __FILE__, __LINE__);
+      if (obj->type != LISP_TYPE_CONS && obj->type != LISP_TYPE_PATTERN_CONS)
+        throw LispReaderException("lisp_list_nth_cdr()", __FILE__, __LINE__);
+
+      --index;
+      obj = obj->v.cons.cdr;
+    }
+
+  return obj;
+}
+
+lisp_object_t*
+lisp_list_nth (lisp_object_t *obj, int index)
+{
+  obj = lisp_list_nth_cdr(obj, index);
+
+  if (obj == 0)
+    throw LispReaderException("lisp_list_nth()", __FILE__, __LINE__);
+
+  return obj->v.cons.car;
+}
+
+void
+lisp_dump (lisp_object_t *obj, FILE *out)
+{
+  if (obj == 0)
+    {
+      fprintf(out, "()");
+      return;
+    }
+
+  switch (lisp_type(obj))
+    {
+    case LISP_TYPE_EOF :
+      fputs("#<eof>", out);
+      break;
+
+    case LISP_TYPE_PARSE_ERROR :
+      fputs("#<error>", out);
+      break;
+
+    case LISP_TYPE_INTEGER :
+      fprintf(out, "%d", lisp_integer(obj));
+      break;
+
+    case LISP_TYPE_REAL :
+      fprintf(out, "%f", lisp_real(obj));
+      break;
+
+    case LISP_TYPE_SYMBOL :
+      fputs(lisp_symbol(obj), out);
+      break;
+
+    case LISP_TYPE_STRING :
+      {
+        char *p;
+
+        fputc('"', out);
+        for (p = lisp_string(obj); *p != 0; ++p)
+          {
+            if (*p == '"' || *p == '\\')
+              fputc('\\', out);
+            fputc(*p, out);
+          }
+        fputc('"', out);
+      }
+      break;
+
+    case LISP_TYPE_CONS :
+    case LISP_TYPE_PATTERN_CONS :
+      fputs(lisp_type(obj) == LISP_TYPE_CONS ? "(" : "#?(", out);
+      while (obj != 0)
+        {
+          lisp_dump(lisp_car(obj), out);
+          obj = lisp_cdr(obj);
+          if (obj != 0)
+            {
+              if (lisp_type(obj) != LISP_TYPE_CONS
+                  && lisp_type(obj) != LISP_TYPE_PATTERN_CONS)
+                {
+                  fputs(" . ", out);
+                  lisp_dump(obj, out);
+                  break;
+                }
+              else
+                fputc(' ', out);
+            }
+        }
+      fputc(')', out);
+      break;
+
+    case LISP_TYPE_BOOLEAN :
+      if (lisp_boolean(obj))
+        fputs("#t", out);
+      else
+        fputs("#f", out);
+      break;
+
+    default :
+      throw LispReaderException("lisp_dump()", __FILE__, __LINE__);
+    }
+}
+
+using namespace std;
+
+LispReader::LispReader (lisp_object_t* l)
+    : lst (l)
+{
+  //std::cout << "LispReader: " << std::flush;
+  //lisp_dump(lst, stdout);
+  //std::cout << std::endl;
+}
+
+lisp_object_t*
+LispReader::search_for(const char* name)
+{
+  //std::cout << "LispReader::search_for(" << name << ")" << std::endl;
+  lisp_object_t* cursor = lst;
+
+  while(!lisp_nil_p(cursor))
+    {
+      lisp_object_t* cur = lisp_car(cursor);
+
+      if (!lisp_cons_p(cur) || !lisp_symbol_p (lisp_car(cur)))
+        {
+          lisp_dump(cur, stdout);
+          //throw ConstruoError (std::string("LispReader: Read error in search_for ") + name);
+	  printf("LispReader: Read error in search\n");
+        }
+      else
+        {
+          if (strcmp(lisp_symbol(lisp_car(cur)), name) == 0)
+            {
+              return lisp_cdr(cur);
+            }
+        }
+
+      cursor = lisp_cdr (cursor);
+    }
+  return 0;
+}
+
+bool
+LispReader::read_int (const char* name, int* i)
+{
+  lisp_object_t* obj = search_for (name);
+  if (obj)
+    {
+      if (!lisp_integer_p(lisp_car(obj)))
+      {
+        //st_abort("LispReader expected type integer at token: ", name); /* Instead of giving up, we return with false now. */
+	return false;
+	}
+      *i = lisp_integer(lisp_car(obj));
+      return true;
+    }
+  return false;
+}
+
+bool
+LispReader::read_lisp(const char* name, lisp_object_t** b)
+{
+  lisp_object_t* obj = search_for (name);
+  if (obj)
+    {
+      *b = obj;
+      return true;
+    }
+  else
+    return false;
+}
+
+bool
+LispReader::read_float (const char* name, float* f)
+{
+  lisp_object_t* obj = search_for (name);
+  if (obj)
+    {
+      if (!lisp_real_p(lisp_car(obj)) && !lisp_integer_p(lisp_car(obj)))
+        throw LispReaderException("LispReader expected type real at token: ",
+                                  __FILE__, __LINE__);
+      *f = lisp_real(lisp_car(obj));
+      return true;
+    }
+  return false;
+}
+
+bool
+LispReader::read_string_vector (const char* name, std::vector<std::string>* vec)
+{
+  lisp_object_t* obj = search_for (name);
+  if (obj)
+    {
+      while(!lisp_nil_p(obj))
+        {
+          if (!lisp_string_p(lisp_car(obj)))
+            throw LispReaderException("LispReader expected type string at token: ", name);
+          vec->push_back(lisp_string(lisp_car(obj)));
+          obj = lisp_cdr(obj);
+        }
+      return true;
+    }
+  return false;    
+}
+
+bool
+LispReader::read_int_vector (const char* name, std::vector<int>* vec)
+{
+  lisp_object_t* obj = search_for (name);
+  if (obj)
+    {
+      while(!lisp_nil_p(obj))
+        {
+          if (!lisp_integer_p(lisp_car(obj)))
+            throw LispReaderException("LispReader expected type integer at token: ", name);
+          vec->push_back(lisp_integer(lisp_car(obj)));
+          obj = lisp_cdr(obj);
+        }
+      return true;
+    }
+  return false;    
+}
+
+bool
+LispReader::read_char_vector (const char* name, std::vector<char>* vec)
+{
+  lisp_object_t* obj = search_for (name);
+  if (obj)
+    {
+      while(!lisp_nil_p(obj))
+        {
+          vec->push_back(*lisp_string(lisp_car(obj)));
+          obj = lisp_cdr(obj);
+        }
+      return true;
+    }
+  return false;    
+}
+
+bool
+LispReader::read_string (const char* name, std::string* str)
+{
+  lisp_object_t* obj = search_for (name);
+  if (obj)
+    {
+      if (!lisp_string_p(lisp_car(obj)))
+        throw LispReaderException("LispReader expected type string at token: ", name);
+     *str = lisp_string(lisp_car(obj));
+      return true;
+    }
+  return false;  
+}
+
+bool
+LispReader::read_bool (const char* name, bool* b)
+{
+  lisp_object_t* obj = search_for (name);
+  if (obj)
+    {
+      if (!lisp_boolean_p(lisp_car(obj)))
+        throw LispReaderException("LispReader expected type bool at token: ");
+      *b = lisp_boolean(lisp_car(obj));
+      return true;
+    }
+  return false;
+}
+
+LispWriter::LispWriter (const char* name)
+{
+  lisp_objs.push_back(lisp_make_symbol (name));
+}
+
+void
+LispWriter::append (lisp_object_t* obj)
+{
+  lisp_objs.push_back(obj);
+}
+
+lisp_object_t*
+LispWriter::make_list3 (lisp_object_t* a, lisp_object_t* b, lisp_object_t* c)
+{
+  return lisp_make_cons (a, lisp_make_cons(b, lisp_make_cons(c, lisp_nil())));
+}
+
+lisp_object_t*
+LispWriter::make_list2 (lisp_object_t* a, lisp_object_t* b)
+{
+  return lisp_make_cons (a, lisp_make_cons(b, lisp_nil()));
+}
+
+void
+LispWriter::write_float (const char* name, float f)
+{
+  append(make_list2 (lisp_make_symbol (name),
+                     lisp_make_real(f)));
+}
+
+void
+LispWriter::write_int (const char* name, int i)
+{
+  append(make_list2 (lisp_make_symbol (name),
+                     lisp_make_integer(i)));
+}
+
+void
+LispWriter::write_string (const char* name, const char* str)
+{
+  append(make_list2 (lisp_make_symbol (name),
+                     lisp_make_string(str)));
+}
+
+void
+LispWriter::write_symbol (const char* name, const char* symname)
+{
+  append(make_list2 (lisp_make_symbol (name),
+                     lisp_make_symbol(symname)));
+}
+
+void
+LispWriter::write_lisp_obj(const char* name, lisp_object_t* lst)
+{
+  append(make_list2 (lisp_make_symbol (name),
+                     lst));
+}
+
+void
+LispWriter::write_boolean (const char* name, bool b)
+{
+  append(make_list2 (lisp_make_symbol (name),
+                     lisp_make_boolean(b)));
+}
+
+lisp_object_t*
+LispWriter::create_lisp ()
+{
+  lisp_object_t* lisp_obj = lisp_nil();
+
+  for(std::vector<lisp_object_t*>::reverse_iterator i = lisp_objs.rbegin ();
+      i != lisp_objs.rend (); ++i)
+    {
+      lisp_obj = lisp_make_cons (*i, lisp_obj);
+    }
+  lisp_objs.clear();
+
+  return lisp_obj;
+}
+
+#if 0
+void mygzungetc(char c, void* file)
+{
+  gzungetc(c, file);
+}
+
+lisp_stream_t* lisp_stream_init_gzfile (lisp_stream_t *stream, gzFile file)
+{
+  return lisp_stream_init_any (stream, file, gzgetc, mygzungetc);
+}
+#endif
+
+lisp_object_t* lisp_read_from_gzfile(const char* filename)
+{
+  bool done = false;
+  lisp_object_t* root_obj = 0;
+  int chunk_size = 128 * 1024;
+  int buf_pos = 0;
+  int try_number = 1;
+  char* buf = static_cast<char*>(malloc(chunk_size));
+  if (!buf)
+    throw LispReaderException("lisp_read_from_gzfile()", __FILE__, __LINE__);
+
+  gzFile in = gzopen(filename, "r");
+
+  while (!done)
+    {
+      int ret = gzread(in, buf + buf_pos, chunk_size);
+      if (ret == -1)
+        {
+          free (buf);
+          throw LispReaderException("Error while reading from file", __FILE__, __LINE__);
+        }
+      else if (ret == chunk_size) // buffer got full, eof not yet there so resize
+        {
+          buf_pos = chunk_size * try_number;
+          try_number += 1;
+          buf = static_cast<char*>(realloc(buf, chunk_size * try_number));
+
+          if (!buf)
+            throw LispReaderException("lisp_read_from_gzfile()", __FILE__, __LINE__);
+        }
+      else 
+        {
+          // everything fine, encountered EOF 
+          done = true;
+        }
+    }
+      
+  lisp_stream_t stream;
+  lisp_stream_init_string (&stream, buf);
+  root_obj = lisp_read (&stream);
+      
+  free(buf);
+  gzclose(in);
+
+  return root_obj;
+}
+
+bool has_suffix(const char* data, const char* suffix)
+{
+  int suffix_len = strlen(suffix);
+  int data_len   = strlen(data);
+  
+  const char* data_suffix = (data + data_len - suffix_len);
+
+  if (data_suffix >= data)
+    {
+      return (strcmp(data_suffix, suffix) == 0);
+    }
+  else
+    {
+      return false;
+    }
+}
+
+lisp_object_t* lisp_read_from_file(const std::string& filename)
+{
+  lisp_stream_t stream;
+
+  if (has_suffix(filename.c_str(), ".gz"))
+    {
+      return lisp_read_from_gzfile(filename.c_str());
+    }
+  else
+    {
+      lisp_object_t* obj = 0;
+      FILE* in = fopen(filename.c_str(), "r");
+
+      if (in)
+        {
+          lisp_stream_init_file(&stream, in);
+          obj = lisp_read(&stream);
+          fclose(in);
+        }
+
+      return obj;
+    }
+}
+
+// EOF //

Deleted: trunk/flexlay/lib/lispreader.cxx
===================================================================
--- trunk/flexlay/lib/lispreader.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/lispreader.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,1358 +0,0 @@
-/* $Id: lispreader.cpp,v 1.19 2004/05/11 22:16:12 sik0fewl Exp $ */
-/*
- * lispreader.c
- *
- * Copyright (C) 1998-2000 Mark Probst
- * Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include <iostream>
-#include <string>
-#include <ctype.h>
-#include <stdlib.h>
-#include <string.h>
-#include "lispreader.hxx"
-
-#define TOKEN_ERROR                   -1
-#define TOKEN_EOF                     0
-#define TOKEN_OPEN_PAREN              1
-#define TOKEN_CLOSE_PAREN             2
-#define TOKEN_SYMBOL                  3
-#define TOKEN_STRING                  4
-#define TOKEN_INTEGER                 5
-#define TOKEN_REAL                    6
-#define TOKEN_PATTERN_OPEN_PAREN      7
-#define TOKEN_DOT                     8
-#define TOKEN_TRUE                    9
-#define TOKEN_FALSE                   10
-
-
-#define MAX_TOKEN_LENGTH           1024
-
-static char token_string[MAX_TOKEN_LENGTH + 1] = "";
-static int token_length = 0;
-
-static lisp_object_t end_marker = { LISP_TYPE_EOF, {{0, 0}} };
-static lisp_object_t error_object = { LISP_TYPE_PARSE_ERROR , {{0,0}}  };
-static lisp_object_t close_paren_marker = { LISP_TYPE_PARSE_ERROR , {{0,0}}  };
-static lisp_object_t dot_marker = { LISP_TYPE_PARSE_ERROR , {{0,0}} };
-
-static void
-_token_clear (void)
-{
-  token_string[0] = '\0';
-  token_length = 0;
-}
-
-static void
-_token_append (char c)
-{
-  if (token_length >= MAX_TOKEN_LENGTH)
-    throw LispReaderException("_token_append()", __FILE__, __LINE__);
-
-  token_string[token_length++] = c;
-  token_string[token_length] = '\0';
-}
-
-static int
-_next_char (lisp_stream_t *stream)
-{
-  switch (stream->type)
-    {
-    case LISP_STREAM_FILE :
-      return getc(stream->v.file);
-
-    case LISP_STREAM_STRING :
-      {
-        char c = stream->v.string.buf[stream->v.string.pos];
-
-        if (c == 0)
-          return EOF;
-
-        ++stream->v.string.pos;
-
-        return c;
-      }
-
-    case LISP_STREAM_ANY:
-      return stream->v.any.next_char(stream->v.any.data);
-    }
-
-  throw LispReaderException("_next_char()", __FILE__, __LINE__);
-  return EOF;
-}
-
-static void
-_unget_char (char c, lisp_stream_t *stream)
-{
-  switch (stream->type)
-    {
-    case LISP_STREAM_FILE :
-      ungetc(c, stream->v.file);
-      break;
-
-    case LISP_STREAM_STRING :
-      --stream->v.string.pos;
-      break;
-
-    case LISP_STREAM_ANY:
-      stream->v.any.unget_char(c, stream->v.any.data);
-      break;
-
-    default :
-      throw LispReaderException("_unget_char()", __FILE__, __LINE__);
-    }
-}
-
-static int
-_scan (lisp_stream_t *stream)
-{
-  static char *delims = "\"();";
-
-  int c;
-
-  _token_clear();
-
-  do
-    {
-      c = _next_char(stream);
-      if (c == EOF)
-        return TOKEN_EOF;
-      else if (c == ';')     	 /* comment start */
-        while (1)
-          {
-            c = _next_char(stream);
-            if (c == EOF)
-              return TOKEN_EOF;
-            else if (c == '\n')
-              break;
-          }
-    }
-  while (isspace(c));
-
-  switch (c)
-    {
-    case '(' :
-      return TOKEN_OPEN_PAREN;
-
-    case ')' :
-      return TOKEN_CLOSE_PAREN;
-
-    case '"' :
-      while (1)
-        {
-          c = _next_char(stream);
-          if (c == EOF)
-            return TOKEN_ERROR;
-          if (c == '"')
-            break;
-          if (c == '\\')
-            {
-              c = _next_char(stream);
-
-              switch (c)
-                {
-                case EOF :
-                  return TOKEN_ERROR;
-
-                case 'n' :
-                  c = '\n';
-                  break;
-
-                case 't' :
-                  c = '\t';
-                  break;
-                }
-            }
-
-          _token_append(c);
-        }
-      return TOKEN_STRING;
-
-    case '#' :
-      c = _next_char(stream);
-      if (c == EOF)
-        return TOKEN_ERROR;
-
-      switch (c)
-        {
-        case 't' :
-          return TOKEN_TRUE;
-
-        case 'f' :
-          return TOKEN_FALSE;
-
-        case '?' :
-          c = _next_char(stream);
-          if (c == EOF)
-            return TOKEN_ERROR;
-
-          if (c == '(')
-            return TOKEN_PATTERN_OPEN_PAREN;
-          else
-            return TOKEN_ERROR;
-        }
-      return TOKEN_ERROR;
-
-    default :
-      if (isdigit(c) || c == '-')
-        {
-          int have_nondigits = 0;
-          int have_digits = 0;
-          int have_floating_point = 0;
-
-          do
-            {
-              if (isdigit(c))
-                have_digits = 1;
-              else if (c == '.')
-                have_floating_point++;
-              _token_append(c);
-
-              c = _next_char(stream);
-
-              if (c != EOF && !isdigit(c) && !isspace(c) && c != '.' && !strchr(delims, c))
-                have_nondigits = 1;
-            }
-          while (c != EOF && !isspace(c) && !strchr(delims, c));
-
-          if (c != EOF)
-            _unget_char(c, stream);
-
-          if (have_nondigits || !have_digits || have_floating_point > 1)
-            return TOKEN_SYMBOL;
-          else if (have_floating_point == 1)
-            return TOKEN_REAL;
-          else
-            return TOKEN_INTEGER;
-        }
-      else
-        {
-          if (c == '.')
-            {
-              c = _next_char(stream);
-              if (c != EOF && !isspace(c) && !strchr(delims, c))
-                _token_append('.');
-              else
-                {
-                  _unget_char(c, stream);
-                  return TOKEN_DOT;
-                }
-            }
-          do
-            {
-              _token_append(c);
-              c = _next_char(stream);
-            }
-          while (c != EOF && !isspace(c) && !strchr(delims, c));
-          if (c != EOF)
-            _unget_char(c, stream);
-
-          return TOKEN_SYMBOL;
-        }
-    }
-
-  throw LispReaderException("_scan()", __FILE__, __LINE__);
-  return TOKEN_ERROR;
-}
-
-static lisp_object_t*
-lisp_object_alloc (int type)
-{
-  lisp_object_t *obj = (lisp_object_t*)malloc(sizeof(lisp_object_t));
-
-  obj->type = type;
-
-  return obj;
-}
-
-lisp_stream_t*
-lisp_stream_init_file (lisp_stream_t *stream, FILE *file)
-{
-  stream->type = LISP_STREAM_FILE;
-  stream->v.file = file;
-
-  return stream;
-}
-
-lisp_stream_t*
-lisp_stream_init_string (lisp_stream_t *stream, char *buf)
-{
-  stream->type = LISP_STREAM_STRING;
-  stream->v.string.buf = buf;
-  stream->v.string.pos = 0;
-
-  return stream;
-}
-
-lisp_stream_t*
-lisp_stream_init_any (lisp_stream_t *stream, void *data,
-                      int (*next_char) (void *data),
-                      void (*unget_char) (char c, void *data))
-{
-  if (next_char == 0 || unget_char == 0)
-    throw LispReaderException("lisp_stream_init_any()", __FILE__, __LINE__);
-
-  stream->type = LISP_STREAM_ANY;
-  stream->v.any.data = data;
-  stream->v.any.next_char= next_char;
-  stream->v.any.unget_char = unget_char;
-
-  return stream;
-}
-
-lisp_object_t*
-lisp_make_integer (int value)
-{
-  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_INTEGER);
-
-  obj->v.integer = value;
-
-  return obj;
-}
-
-lisp_object_t*
-lisp_make_real (float value)
-{
-  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_REAL);
-
-  obj->v.real = value;
-
-  return obj;
-}
-
-lisp_object_t*
-lisp_make_symbol (const char *value)
-{
-  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_SYMBOL);
-
-  obj->v.string = strdup(value);
-
-  return obj;
-}
-
-lisp_object_t*
-lisp_make_string (const char *value)
-{
-  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_STRING);
-
-  obj->v.string = strdup(value);
-
-  return obj;
-}
-
-lisp_object_t*
-lisp_make_cons (lisp_object_t *car, lisp_object_t *cdr)
-{
-  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_CONS);
-
-  obj->v.cons.car = car;
-  obj->v.cons.cdr = cdr;
-
-  return obj;
-}
-
-lisp_object_t*
-lisp_make_boolean (int value)
-{
-  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_BOOLEAN);
-
-  obj->v.integer = value ? 1 : 0;
-
-  return obj;
-}
-
-static lisp_object_t*
-lisp_make_pattern_cons (lisp_object_t *car, lisp_object_t *cdr)
-{
-  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_PATTERN_CONS);
-
-  obj->v.cons.car = car;
-  obj->v.cons.cdr = cdr;
-
-  return obj;
-}
-
-static lisp_object_t*
-lisp_make_pattern_var (int type, int index, lisp_object_t *sub)
-{
-  lisp_object_t *obj = lisp_object_alloc(LISP_TYPE_PATTERN_VAR);
-
-  obj->v.pattern.type = type;
-  obj->v.pattern.index = index;
-  obj->v.pattern.sub = sub;
-
-  return obj;
-}
-
-lisp_object_t*
-lisp_read (lisp_stream_t *in)
-{
-  int token = _scan(in);
-  lisp_object_t *obj = lisp_nil();
-
-  if (token == TOKEN_EOF)
-    return &end_marker;
-
-  switch (token)
-    {
-    case TOKEN_ERROR :
-      return &error_object;
-
-    case TOKEN_EOF :
-      return &end_marker;
-
-    case TOKEN_OPEN_PAREN :
-    case TOKEN_PATTERN_OPEN_PAREN :
-      {
-        lisp_object_t *last = lisp_nil(), *car;
-
-        do
-          {
-            car = lisp_read(in);
-            if (car == &error_object || car == &end_marker)
-              {
-                lisp_free(obj);
-                return &error_object;
-              }
-            else if (car == &dot_marker)
-              {
-                if (lisp_nil_p(last))
-                  {
-                    lisp_free(obj);
-                    return &error_object;
-                  }
-
-                car = lisp_read(in);
-                if (car == &error_object || car == &end_marker)
-                  {
-                    lisp_free(obj);
-                    return car;
-                  }
-                else
-                  {
-                    last->v.cons.cdr = car;
-
-                    if (_scan(in) != TOKEN_CLOSE_PAREN)
-                      {
-                        lisp_free(obj);
-                        return &error_object;
-                      }
-
-                    car = &close_paren_marker;
-                  }
-              }
-            else if (car != &close_paren_marker)
-              {
-                if (lisp_nil_p(last))
-                  obj = last = (token == TOKEN_OPEN_PAREN ? lisp_make_cons(car, lisp_nil()) : lisp_make_pattern_cons(car, lisp_nil()));
-                else
-                  last = last->v.cons.cdr = lisp_make_cons(car, lisp_nil());
-              }
-          }
-        while (car != &close_paren_marker);
-      }
-      return obj;
-
-    case TOKEN_CLOSE_PAREN :
-      return &close_paren_marker;
-
-    case TOKEN_SYMBOL :
-      return lisp_make_symbol(token_string);
-
-    case TOKEN_STRING :
-      return lisp_make_string(token_string);
-
-    case TOKEN_INTEGER :
-      return lisp_make_integer(atoi(token_string));
-
-    case TOKEN_REAL :
-      return lisp_make_real((float)atof(token_string));
-
-    case TOKEN_DOT :
-      return &dot_marker;
-
-    case TOKEN_TRUE :
-      return lisp_make_boolean(1);
-
-    case TOKEN_FALSE :
-      return lisp_make_boolean(0);
-    }
-
-  throw LispReaderException("lisp_read()", __FILE__, __LINE__);
-  return &error_object;
-}
-
-void
-lisp_free (lisp_object_t *obj)
-{
-  if (obj == 0)
-    return;
-
-  switch (obj->type)
-    {
-    case LISP_TYPE_INTERNAL :
-    case LISP_TYPE_PARSE_ERROR :
-    case LISP_TYPE_EOF :
-      return;
-
-    case LISP_TYPE_SYMBOL :
-    case LISP_TYPE_STRING :
-      free(obj->v.string);
-      break;
-
-    case LISP_TYPE_CONS :
-    case LISP_TYPE_PATTERN_CONS :
-      lisp_free(obj->v.cons.car);
-      lisp_free(obj->v.cons.cdr);
-      break;
-
-    case LISP_TYPE_PATTERN_VAR :
-      lisp_free(obj->v.pattern.sub);
-      break;
-    }
-
-  free(obj);
-}
-
-lisp_object_t*
-lisp_read_from_string (const char *buf)
-{
-  lisp_stream_t stream;
-
-  lisp_stream_init_string(&stream, (char*)buf);
-  return lisp_read(&stream);
-}
-
-static int
-_compile_pattern (lisp_object_t **obj, int *index)
-{
-  if (*obj == 0)
-    return 1;
-
-  switch (lisp_type(*obj))
-    {
-    case LISP_TYPE_PATTERN_CONS :
-      {
-        struct
-          {
-            char *name;
-            int type;
-          }
-        types[] =
-          {
-            { "any", LISP_PATTERN_ANY },
-            { "symbol", LISP_PATTERN_SYMBOL },
-            { "string", LISP_PATTERN_STRING },
-            { "integer", LISP_PATTERN_INTEGER },
-            { "real", LISP_PATTERN_REAL },
-            { "boolean", LISP_PATTERN_BOOLEAN },
-            { "list", LISP_PATTERN_LIST },
-            { "or", LISP_PATTERN_OR },
-            { 0, 0 }
-          };
-        char *type_name;
-        int type;
-        int i;
-        lisp_object_t *pattern;
-        type = -1;
-	
-        if (lisp_type(lisp_car(*obj)) != LISP_TYPE_SYMBOL)
-          return 0;
-
-        type_name = lisp_symbol(lisp_car(*obj));
-        for (i = 0; types[i].name != 0; ++i)
-          {
-            if (strcmp(types[i].name, type_name) == 0)
-              {
-                type = types[i].type;
-                break;
-              }
-          }
-
-        if (types[i].name == 0)
-          return 0;
-
-        if (type != LISP_PATTERN_OR && lisp_cdr(*obj) != 0)
-          return 0;
-
-        pattern = lisp_make_pattern_var(type, (*index)++, lisp_nil());
-
-        if (type == LISP_PATTERN_OR)
-          {
-            lisp_object_t *cdr = lisp_cdr(*obj);
-
-            if (!_compile_pattern(&cdr, index))
-              {
-                lisp_free(pattern);
-                return 0;
-              }
-
-            pattern->v.pattern.sub = cdr;
-
-            (*obj)->v.cons.cdr = lisp_nil();
-          }
-
-        lisp_free(*obj);
-
-        *obj = pattern;
-      }
-      break;
-
-    case LISP_TYPE_CONS :
-      if (!_compile_pattern(&(*obj)->v.cons.car, index))
-        return 0;
-      if (!_compile_pattern(&(*obj)->v.cons.cdr, index))
-        return 0;
-      break;
-    }
-
-  return 1;
-}
-
-int
-lisp_compile_pattern (lisp_object_t **obj, int *num_subs)
-{
-  int index = 0;
-  int result;
-
-  result = _compile_pattern(obj, &index);
-
-  if (result && num_subs != 0)
-    *num_subs = index;
-
-  return result;
-}
-
-static int _match_pattern (lisp_object_t *pattern, lisp_object_t *obj, lisp_object_t **vars);
-
-static int
-_match_pattern_var (lisp_object_t *pattern, lisp_object_t *obj, lisp_object_t **vars)
-{
-  if (lisp_type(pattern) != LISP_TYPE_PATTERN_VAR)
-    throw LispReaderException("_match_pattern_var", __FILE__, __LINE__);
-
-  switch (pattern->v.pattern.type)
-    {
-    case LISP_PATTERN_ANY :
-      break;
-
-    case LISP_PATTERN_SYMBOL :
-      if (obj == 0 || lisp_type(obj) != LISP_TYPE_SYMBOL)
-        return 0;
-      break;
-
-    case LISP_PATTERN_STRING :
-      if (obj == 0 || lisp_type(obj) != LISP_TYPE_STRING)
-        return 0;
-      break;
-
-    case LISP_PATTERN_INTEGER :
-      if (obj == 0 || lisp_type(obj) != LISP_TYPE_INTEGER)
-        return 0;
-      break;
-
-    case LISP_PATTERN_REAL :
-      if (obj == 0 || lisp_type(obj) != LISP_TYPE_REAL)
-        return 0;
-      break;
-
-    case LISP_PATTERN_BOOLEAN :
-      if (obj == 0 || lisp_type(obj) != LISP_TYPE_BOOLEAN)
-        return 0;
-      break;
-
-    case LISP_PATTERN_LIST :
-      if (obj == 0 || lisp_type(obj) != LISP_TYPE_CONS)
-        return 0;
-      break;
-
-    case LISP_PATTERN_OR :
-      {
-        lisp_object_t *sub;
-        int matched = 0;
-
-        for (sub = pattern->v.pattern.sub; sub != 0; sub = lisp_cdr(sub))
-          {
-            if (lisp_type(sub) != LISP_TYPE_CONS)
-              throw LispReaderException("_match_pattern_var()", __FILE__, __LINE__);
-
-            if (_match_pattern(lisp_car(sub), obj, vars))
-              matched = 1;
-          }
-
-        if (!matched)
-          return 0;
-      }
-      break;
-
-    default :
-      throw LispReaderException("_match_pattern_var()", __FILE__, __LINE__);
-    }
-
-  if (vars != 0)
-    vars[pattern->v.pattern.index] = obj;
-
-  return 1;
-}
-
-static int
-_match_pattern (lisp_object_t *pattern, lisp_object_t *obj, lisp_object_t **vars)
-{
-  if (pattern == 0)
-    return obj == 0;
-
-  if (obj == 0)
-    return 0;
-
-  if (lisp_type(pattern) == LISP_TYPE_PATTERN_VAR)
-    return _match_pattern_var(pattern, obj, vars);
-
-  if (lisp_type(pattern) != lisp_type(obj))
-    return 0;
-
-  switch (lisp_type(pattern))
-    {
-    case LISP_TYPE_SYMBOL :
-      return strcmp(lisp_symbol(pattern), lisp_symbol(obj)) == 0;
-
-    case LISP_TYPE_STRING :
-      return strcmp(lisp_string(pattern), lisp_string(obj)) == 0;
-
-    case LISP_TYPE_INTEGER :
-      return lisp_integer(pattern) == lisp_integer(obj);
-
-    case LISP_TYPE_REAL :
-      return lisp_real(pattern) == lisp_real(obj);
-
-    case LISP_TYPE_CONS :
-      {
-        int result1, result2;
-
-        result1 = _match_pattern(lisp_car(pattern), lisp_car(obj), vars);
-        result2 = _match_pattern(lisp_cdr(pattern), lisp_cdr(obj), vars);
-
-        return result1 && result2;
-      }
-      break;
-
-    default :
-      throw LispReaderException("_match_pattern()", __FILE__, __LINE__);
-    }
-
-  return 0;
-}
-
-int
-lisp_match_pattern (lisp_object_t *pattern, lisp_object_t *obj, lisp_object_t **vars, int num_subs)
-{
-  int i;
-
-  if (vars != 0)
-    for (i = 0; i < num_subs; ++i)
-      vars[i] = &error_object;
-
-  return _match_pattern(pattern, obj, vars);
-}
-
-int
-lisp_match_string (const char *pattern_string, lisp_object_t *obj, lisp_object_t **vars)
-{
-  lisp_object_t *pattern;
-  int result;
-  int num_subs;
-
-  pattern = lisp_read_from_string(pattern_string);
-
-  if (pattern != 0 && (lisp_type(pattern) == LISP_TYPE_EOF
-                       || lisp_type(pattern) == LISP_TYPE_PARSE_ERROR))
-    return 0;
-
-  if (!lisp_compile_pattern(&pattern, &num_subs))
-    {
-      lisp_free(pattern);
-      return 0;
-    }
-
-  result = lisp_match_pattern(pattern, obj, vars, num_subs);
-
-  lisp_free(pattern);
-
-  return result;
-}
-
-int
-lisp_type (lisp_object_t *obj)
-{
-  if (obj == 0)
-    return LISP_TYPE_NIL;
-  return obj->type;
-}
-
-int
-lisp_integer (lisp_object_t *obj)
-{
-  if (obj->type != LISP_TYPE_INTEGER)
-    throw LispReaderException("lisp_integer()", __FILE__, __LINE__);
-
-  return obj->v.integer;
-}
-
-char*
-lisp_symbol (lisp_object_t *obj)
-{
-  if (obj->type != LISP_TYPE_SYMBOL)
-    throw LispReaderException("lisp_symbol()", __FILE__, __LINE__);
-
-  return obj->v.string;
-}
-
-char*
-lisp_string (lisp_object_t *obj)
-{
-  if (obj->type != LISP_TYPE_STRING)
-    throw LispReaderException("lisp_string()", __FILE__, __LINE__);
-
-  return obj->v.string;
-}
-
-int
-lisp_boolean (lisp_object_t *obj)
-{
-  if (obj->type != LISP_TYPE_BOOLEAN)
-    throw LispReaderException("lisp_boolean()", __FILE__, __LINE__);
-
-  return obj->v.integer;
-}
-
-float
-lisp_real (lisp_object_t *obj)
-{
-  if (obj->type != LISP_TYPE_REAL && obj->type != LISP_TYPE_INTEGER)
-    throw LispReaderException("lisp_real()", __FILE__, __LINE__);
-
-  if (obj->type == LISP_TYPE_INTEGER)
-    return obj->v.integer;
-  return obj->v.real;
-}
-
-lisp_object_t*
-lisp_car (lisp_object_t *obj)
-{
-  if (obj->type != LISP_TYPE_CONS && obj->type != LISP_TYPE_PATTERN_CONS)
-    throw LispReaderException("lisp_car()", __FILE__, __LINE__);
-
-  return obj->v.cons.car;
-}
-
-lisp_object_t*
-lisp_cdr (lisp_object_t *obj)
-{
-  if (obj->type != LISP_TYPE_CONS && obj->type != LISP_TYPE_PATTERN_CONS)
-    throw LispReaderException("lisp_cdr()", __FILE__, __LINE__);
-
-  return obj->v.cons.cdr;
-}
-
-lisp_object_t*
-lisp_cxr (lisp_object_t *obj, const char *x)
-{
-  int i;
-
-  for (i = strlen(x) - 1; i >= 0; --i)
-    if (x[i] == 'a')
-      obj = lisp_car(obj);
-    else if (x[i] == 'd')
-      obj = lisp_cdr(obj);
-    else
-      throw LispReaderException("lisp_cxr()", __FILE__, __LINE__);
-
-  return obj;
-}
-
-int
-lisp_list_length (lisp_object_t *obj)
-{
-  int length = 0;
-
-  while (obj != 0)
-    {
-      if (obj->type != LISP_TYPE_CONS && obj->type != LISP_TYPE_PATTERN_CONS)
-        throw LispReaderException("lisp_list_length()", __FILE__, __LINE__);
-
-      ++length;
-      obj = obj->v.cons.cdr;
-    }
-
-  return length;
-}
-
-lisp_object_t*
-lisp_list_nth_cdr (lisp_object_t *obj, int index)
-{
-  while (index > 0)
-    {
-      if (obj == 0)
-        throw LispReaderException("lisp_list_nth_cdr()", __FILE__, __LINE__);
-      if (obj->type != LISP_TYPE_CONS && obj->type != LISP_TYPE_PATTERN_CONS)
-        throw LispReaderException("lisp_list_nth_cdr()", __FILE__, __LINE__);
-
-      --index;
-      obj = obj->v.cons.cdr;
-    }
-
-  return obj;
-}
-
-lisp_object_t*
-lisp_list_nth (lisp_object_t *obj, int index)
-{
-  obj = lisp_list_nth_cdr(obj, index);
-
-  if (obj == 0)
-    throw LispReaderException("lisp_list_nth()", __FILE__, __LINE__);
-
-  return obj->v.cons.car;
-}
-
-void
-lisp_dump (lisp_object_t *obj, FILE *out)
-{
-  if (obj == 0)
-    {
-      fprintf(out, "()");
-      return;
-    }
-
-  switch (lisp_type(obj))
-    {
-    case LISP_TYPE_EOF :
-      fputs("#<eof>", out);
-      break;
-
-    case LISP_TYPE_PARSE_ERROR :
-      fputs("#<error>", out);
-      break;
-
-    case LISP_TYPE_INTEGER :
-      fprintf(out, "%d", lisp_integer(obj));
-      break;
-
-    case LISP_TYPE_REAL :
-      fprintf(out, "%f", lisp_real(obj));
-      break;
-
-    case LISP_TYPE_SYMBOL :
-      fputs(lisp_symbol(obj), out);
-      break;
-
-    case LISP_TYPE_STRING :
-      {
-        char *p;
-
-        fputc('"', out);
-        for (p = lisp_string(obj); *p != 0; ++p)
-          {
-            if (*p == '"' || *p == '\\')
-              fputc('\\', out);
-            fputc(*p, out);
-          }
-        fputc('"', out);
-      }
-      break;
-
-    case LISP_TYPE_CONS :
-    case LISP_TYPE_PATTERN_CONS :
-      fputs(lisp_type(obj) == LISP_TYPE_CONS ? "(" : "#?(", out);
-      while (obj != 0)
-        {
-          lisp_dump(lisp_car(obj), out);
-          obj = lisp_cdr(obj);
-          if (obj != 0)
-            {
-              if (lisp_type(obj) != LISP_TYPE_CONS
-                  && lisp_type(obj) != LISP_TYPE_PATTERN_CONS)
-                {
-                  fputs(" . ", out);
-                  lisp_dump(obj, out);
-                  break;
-                }
-              else
-                fputc(' ', out);
-            }
-        }
-      fputc(')', out);
-      break;
-
-    case LISP_TYPE_BOOLEAN :
-      if (lisp_boolean(obj))
-        fputs("#t", out);
-      else
-        fputs("#f", out);
-      break;
-
-    default :
-      throw LispReaderException("lisp_dump()", __FILE__, __LINE__);
-    }
-}
-
-using namespace std;
-
-LispReader::LispReader (lisp_object_t* l)
-    : lst (l)
-{
-  //std::cout << "LispReader: " << std::flush;
-  //lisp_dump(lst, stdout);
-  //std::cout << std::endl;
-}
-
-lisp_object_t*
-LispReader::search_for(const char* name)
-{
-  //std::cout << "LispReader::search_for(" << name << ")" << std::endl;
-  lisp_object_t* cursor = lst;
-
-  while(!lisp_nil_p(cursor))
-    {
-      lisp_object_t* cur = lisp_car(cursor);
-
-      if (!lisp_cons_p(cur) || !lisp_symbol_p (lisp_car(cur)))
-        {
-          lisp_dump(cur, stdout);
-          //throw ConstruoError (std::string("LispReader: Read error in search_for ") + name);
-	  printf("LispReader: Read error in search\n");
-        }
-      else
-        {
-          if (strcmp(lisp_symbol(lisp_car(cur)), name) == 0)
-            {
-              return lisp_cdr(cur);
-            }
-        }
-
-      cursor = lisp_cdr (cursor);
-    }
-  return 0;
-}
-
-bool
-LispReader::read_int (const char* name, int* i)
-{
-  lisp_object_t* obj = search_for (name);
-  if (obj)
-    {
-      if (!lisp_integer_p(lisp_car(obj)))
-      {
-        //st_abort("LispReader expected type integer at token: ", name); /* Instead of giving up, we return with false now. */
-	return false;
-	}
-      *i = lisp_integer(lisp_car(obj));
-      return true;
-    }
-  return false;
-}
-
-bool
-LispReader::read_lisp(const char* name, lisp_object_t** b)
-{
-  lisp_object_t* obj = search_for (name);
-  if (obj)
-    {
-      *b = obj;
-      return true;
-    }
-  else
-    return false;
-}
-
-bool
-LispReader::read_float (const char* name, float* f)
-{
-  lisp_object_t* obj = search_for (name);
-  if (obj)
-    {
-      if (!lisp_real_p(lisp_car(obj)) && !lisp_integer_p(lisp_car(obj)))
-        throw LispReaderException("LispReader expected type real at token: ",
-                                  __FILE__, __LINE__);
-      *f = lisp_real(lisp_car(obj));
-      return true;
-    }
-  return false;
-}
-
-bool
-LispReader::read_string_vector (const char* name, std::vector<std::string>* vec)
-{
-  lisp_object_t* obj = search_for (name);
-  if (obj)
-    {
-      while(!lisp_nil_p(obj))
-        {
-          if (!lisp_string_p(lisp_car(obj)))
-            throw LispReaderException("LispReader expected type string at token: ", name);
-          vec->push_back(lisp_string(lisp_car(obj)));
-          obj = lisp_cdr(obj);
-        }
-      return true;
-    }
-  return false;    
-}
-
-bool
-LispReader::read_int_vector (const char* name, std::vector<int>* vec)
-{
-  lisp_object_t* obj = search_for (name);
-  if (obj)
-    {
-      while(!lisp_nil_p(obj))
-        {
-          if (!lisp_integer_p(lisp_car(obj)))
-            throw LispReaderException("LispReader expected type integer at token: ", name);
-          vec->push_back(lisp_integer(lisp_car(obj)));
-          obj = lisp_cdr(obj);
-        }
-      return true;
-    }
-  return false;    
-}
-
-bool
-LispReader::read_char_vector (const char* name, std::vector<char>* vec)
-{
-  lisp_object_t* obj = search_for (name);
-  if (obj)
-    {
-      while(!lisp_nil_p(obj))
-        {
-          vec->push_back(*lisp_string(lisp_car(obj)));
-          obj = lisp_cdr(obj);
-        }
-      return true;
-    }
-  return false;    
-}
-
-bool
-LispReader::read_string (const char* name, std::string* str)
-{
-  lisp_object_t* obj = search_for (name);
-  if (obj)
-    {
-      if (!lisp_string_p(lisp_car(obj)))
-        throw LispReaderException("LispReader expected type string at token: ", name);
-     *str = lisp_string(lisp_car(obj));
-      return true;
-    }
-  return false;  
-}
-
-bool
-LispReader::read_bool (const char* name, bool* b)
-{
-  lisp_object_t* obj = search_for (name);
-  if (obj)
-    {
-      if (!lisp_boolean_p(lisp_car(obj)))
-        throw LispReaderException("LispReader expected type bool at token: ");
-      *b = lisp_boolean(lisp_car(obj));
-      return true;
-    }
-  return false;
-}
-
-LispWriter::LispWriter (const char* name)
-{
-  lisp_objs.push_back(lisp_make_symbol (name));
-}
-
-void
-LispWriter::append (lisp_object_t* obj)
-{
-  lisp_objs.push_back(obj);
-}
-
-lisp_object_t*
-LispWriter::make_list3 (lisp_object_t* a, lisp_object_t* b, lisp_object_t* c)
-{
-  return lisp_make_cons (a, lisp_make_cons(b, lisp_make_cons(c, lisp_nil())));
-}
-
-lisp_object_t*
-LispWriter::make_list2 (lisp_object_t* a, lisp_object_t* b)
-{
-  return lisp_make_cons (a, lisp_make_cons(b, lisp_nil()));
-}
-
-void
-LispWriter::write_float (const char* name, float f)
-{
-  append(make_list2 (lisp_make_symbol (name),
-                     lisp_make_real(f)));
-}
-
-void
-LispWriter::write_int (const char* name, int i)
-{
-  append(make_list2 (lisp_make_symbol (name),
-                     lisp_make_integer(i)));
-}
-
-void
-LispWriter::write_string (const char* name, const char* str)
-{
-  append(make_list2 (lisp_make_symbol (name),
-                     lisp_make_string(str)));
-}
-
-void
-LispWriter::write_symbol (const char* name, const char* symname)
-{
-  append(make_list2 (lisp_make_symbol (name),
-                     lisp_make_symbol(symname)));
-}
-
-void
-LispWriter::write_lisp_obj(const char* name, lisp_object_t* lst)
-{
-  append(make_list2 (lisp_make_symbol (name),
-                     lst));
-}
-
-void
-LispWriter::write_boolean (const char* name, bool b)
-{
-  append(make_list2 (lisp_make_symbol (name),
-                     lisp_make_boolean(b)));
-}
-
-lisp_object_t*
-LispWriter::create_lisp ()
-{
-  lisp_object_t* lisp_obj = lisp_nil();
-
-  for(std::vector<lisp_object_t*>::reverse_iterator i = lisp_objs.rbegin ();
-      i != lisp_objs.rend (); ++i)
-    {
-      lisp_obj = lisp_make_cons (*i, lisp_obj);
-    }
-  lisp_objs.clear();
-
-  return lisp_obj;
-}
-
-#if 0
-void mygzungetc(char c, void* file)
-{
-  gzungetc(c, file);
-}
-
-lisp_stream_t* lisp_stream_init_gzfile (lisp_stream_t *stream, gzFile file)
-{
-  return lisp_stream_init_any (stream, file, gzgetc, mygzungetc);
-}
-#endif
-
-lisp_object_t* lisp_read_from_gzfile(const char* filename)
-{
-  bool done = false;
-  lisp_object_t* root_obj = 0;
-  int chunk_size = 128 * 1024;
-  int buf_pos = 0;
-  int try_number = 1;
-  char* buf = static_cast<char*>(malloc(chunk_size));
-  if (!buf)
-    throw LispReaderException("lisp_read_from_gzfile()", __FILE__, __LINE__);
-
-  gzFile in = gzopen(filename, "r");
-
-  while (!done)
-    {
-      int ret = gzread(in, buf + buf_pos, chunk_size);
-      if (ret == -1)
-        {
-          free (buf);
-          throw LispReaderException("Error while reading from file", __FILE__, __LINE__);
-        }
-      else if (ret == chunk_size) // buffer got full, eof not yet there so resize
-        {
-          buf_pos = chunk_size * try_number;
-          try_number += 1;
-          buf = static_cast<char*>(realloc(buf, chunk_size * try_number));
-
-          if (!buf)
-            throw LispReaderException("lisp_read_from_gzfile()", __FILE__, __LINE__);
-        }
-      else 
-        {
-          // everything fine, encountered EOF 
-          done = true;
-        }
-    }
-      
-  lisp_stream_t stream;
-  lisp_stream_init_string (&stream, buf);
-  root_obj = lisp_read (&stream);
-      
-  free(buf);
-  gzclose(in);
-
-  return root_obj;
-}
-
-bool has_suffix(const char* data, const char* suffix)
-{
-  int suffix_len = strlen(suffix);
-  int data_len   = strlen(data);
-  
-  const char* data_suffix = (data + data_len - suffix_len);
-
-  if (data_suffix >= data)
-    {
-      return (strcmp(data_suffix, suffix) == 0);
-    }
-  else
-    {
-      return false;
-    }
-}
-
-lisp_object_t* lisp_read_from_file(const std::string& filename)
-{
-  lisp_stream_t stream;
-
-  if (has_suffix(filename.c_str(), ".gz"))
-    {
-      return lisp_read_from_gzfile(filename.c_str());
-    }
-  else
-    {
-      lisp_object_t* obj = 0;
-      FILE* in = fopen(filename.c_str(), "r");
-
-      if (in)
-        {
-          lisp_stream_init_file(&stream, in);
-          obj = lisp_read(&stream);
-          fclose(in);
-        }
-
-      return obj;
-    }
-}
-
-// EOF //

Copied: trunk/flexlay/lib/lispreader.hpp (from rev 712, trunk/flexlay/lib/lispreader.hxx)

Deleted: trunk/flexlay/lib/lispreader.hxx
===================================================================
--- trunk/flexlay/lib/lispreader.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/lispreader.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,222 +0,0 @@
-/* $Id: lispreader.h,v 1.9 2004/05/11 22:16:12 sik0fewl Exp $ */
-/*
- * lispreader.h
- *
- * Copyright (C) 1998-2000 Mark Probst
- * Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef __LISPREADER_H__
-#define __LISPREADER_H__
-
-#include <stdio.h>
-#include <zlib.h>
-#include <string>
-#include <vector>
-#include <exception>
-
-#define LISP_STREAM_FILE       1
-#define LISP_STREAM_STRING     2
-#define LISP_STREAM_ANY        3
-
-#define LISP_TYPE_INTERNAL      -3
-#define LISP_TYPE_PARSE_ERROR   -2
-#define LISP_TYPE_EOF           -1
-#define LISP_TYPE_NIL           0
-#define LISP_TYPE_SYMBOL        1
-#define LISP_TYPE_INTEGER       2
-#define LISP_TYPE_STRING        3
-#define LISP_TYPE_REAL          4
-#define LISP_TYPE_CONS          5
-#define LISP_TYPE_PATTERN_CONS  6
-#define LISP_TYPE_BOOLEAN       7
-#define LISP_TYPE_PATTERN_VAR   8
-
-#define LISP_PATTERN_ANY        1
-#define LISP_PATTERN_SYMBOL     2
-#define LISP_PATTERN_STRING     3
-#define LISP_PATTERN_INTEGER    4
-#define LISP_PATTERN_REAL       5
-#define LISP_PATTERN_BOOLEAN    6
-#define LISP_PATTERN_LIST       7
-#define LISP_PATTERN_OR         8
-
-class LispReaderException : public std::exception
-{
-  public:
-    LispReaderException(const char* _message, const char* _file = "", const unsigned int _line = 0)
-      : message(_message), file(_file), line(_line) { };
-    virtual ~LispReaderException() throw() { };
-
-    const char* what() const throw() { return message; };
-    const char* what_file() const throw() { return file; };
-    const unsigned int what_line() const throw() { return line; };
-    
-  private:
-    const char* message;
-    const char* file;
-    const unsigned int line;
-};
-
-typedef struct
-{
-  int type;
-
-  union
-  {
-    FILE *file;
-    struct
-    {
-      char *buf;
-      int pos;
-    }
-    string;
-    struct
-    {
-      void *data;
-      int (*next_char) (void *data);
-      void (*unget_char) (char c, void *data);
-    }
-    any;
-  } v;
-}
-lisp_stream_t;
-
-typedef struct _lisp_object_t lisp_object_t;
-struct _lisp_object_t
-{
-  int type;
-
-  union
-  {
-    struct
-    {
-      struct _lisp_object_t *car;
-      struct _lisp_object_t *cdr;
-    }
-    cons;
-
-    char *string;
-    int integer;
-    float real;
-
-    struct
-    {
-      int type;
-      int index;
-      struct _lisp_object_t *sub;
-    }
-    pattern;
-  } v;
-};
-
-lisp_stream_t* lisp_stream_init_gzfile (lisp_stream_t *stream, gzFile file);
-lisp_stream_t* lisp_stream_init_file (lisp_stream_t *stream, FILE *file);
-lisp_stream_t* lisp_stream_init_string (lisp_stream_t *stream, char *buf);
-lisp_stream_t* lisp_stream_init_any (lisp_stream_t *stream, void *data,
-                                     int (*next_char) (void *data),
-                                     void (*unget_char) (char c, void *data));
-
-lisp_object_t* lisp_read (lisp_stream_t *in);
-lisp_object_t* lisp_read_from_file(const std::string& filename);
-void lisp_free (lisp_object_t *obj);
-
-lisp_object_t* lisp_read_from_string (const char *buf);
-
-int lisp_compile_pattern (lisp_object_t **obj, int *num_subs);
-int lisp_match_pattern (lisp_object_t *pattern, lisp_object_t *obj, lisp_object_t **vars, int num_subs);
-int lisp_match_string (const char *pattern_string, lisp_object_t *obj, lisp_object_t **vars);
-
-int lisp_type (lisp_object_t *obj);
-int lisp_integer (lisp_object_t *obj);
-float lisp_real (lisp_object_t *obj);
-char* lisp_symbol (lisp_object_t *obj);
-char* lisp_string (lisp_object_t *obj);
-int lisp_boolean (lisp_object_t *obj);
-lisp_object_t* lisp_car (lisp_object_t *obj);
-lisp_object_t* lisp_cdr (lisp_object_t *obj);
-
-lisp_object_t* lisp_cxr (lisp_object_t *obj, const char *x);
-
-lisp_object_t* lisp_make_integer (int value);
-lisp_object_t* lisp_make_real (float value);
-lisp_object_t* lisp_make_symbol (const char *value);
-lisp_object_t* lisp_make_string (const char *value);
-lisp_object_t* lisp_make_cons (lisp_object_t *car, lisp_object_t *cdr);
-lisp_object_t* lisp_make_boolean (int value);
-
-int lisp_list_length (lisp_object_t *obj);
-lisp_object_t* lisp_list_nth_cdr (lisp_object_t *obj, int index);
-lisp_object_t* lisp_list_nth (lisp_object_t *obj, int index);
-
-void lisp_dump (lisp_object_t *obj, FILE *out);
-
-#define lisp_nil()           ((lisp_object_t*)0)
-
-#define lisp_nil_p(obj)      (obj == 0)
-#define lisp_integer_p(obj)  (lisp_type((obj)) == LISP_TYPE_INTEGER)
-#define lisp_real_p(obj)     (lisp_type((obj)) == LISP_TYPE_REAL)
-#define lisp_symbol_p(obj)   (lisp_type((obj)) == LISP_TYPE_SYMBOL)
-#define lisp_string_p(obj)   (lisp_type((obj)) == LISP_TYPE_STRING)
-#define lisp_cons_p(obj)     (lisp_type((obj)) == LISP_TYPE_CONS)
-#define lisp_boolean_p(obj)  (lisp_type((obj)) == LISP_TYPE_BOOLEAN)
-
-/** */
-class LispReader
-{
-private:
-  lisp_object_t* lst;
-
-  lisp_object_t* search_for(const char* name);
-public:
-  /** cur == ((pos 1 2 3) (id 12 3 4)...) */
-  LispReader (lisp_object_t* l);
-
-  bool read_int_vector (const char* name, std::vector<int>* vec);
-  bool read_char_vector (const char* name, std::vector<char>* vec);
-  bool read_string_vector (const char* name, std::vector<std::string>* vec);
-  bool read_string (const char* name, std::string* str);
-  bool read_int (const char* name, int* i);
-  bool read_float (const char* name, float* f);
-  bool read_bool (const char* name, bool* b);
-  bool read_lisp (const char* name, lisp_object_t** b);
-};
-
-/** */
-class LispWriter
-{
-private:
-  std::vector<lisp_object_t*> lisp_objs;
-
-  void append (lisp_object_t* obj);
-  lisp_object_t* make_list3 (lisp_object_t*, lisp_object_t*, lisp_object_t*);
-  lisp_object_t* make_list2 (lisp_object_t*, lisp_object_t*);
-public:
-  LispWriter (const char* name);
-  void write_float (const char* name, float f);
-  void write_int (const char* name, int i);
-  void write_boolean (const char* name, bool b);
-  void write_string (const char* name, const char* str);
-  void write_symbol (const char* name, const char* symname);
-  void write_lisp_obj(const char* name, lisp_object_t* lst);
-
-  /** caller is responible to free the returned lisp_object_t */
-  lisp_object_t* create_lisp ();
-};
-
-#endif

Copied: trunk/flexlay/lib/marker_stroke_drawer.cpp (from rev 712, trunk/flexlay/lib/marker_stroke_drawer.cxx)
===================================================================
--- trunk/flexlay/lib/marker_stroke_drawer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/marker_stroke_drawer.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,135 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <ClanLib/gl.h>
+#include <ClanLib/Display/display.h>
+#include "stroke_drawer_impl.hpp"
+#include "stroke.hpp"
+#include "drawer_properties.hpp"
+#include "marker_stroke_drawer.hpp"
+
+class MarkerStrokeDrawerImpl : public StrokeDrawerImpl
+{
+public:
+  MarkerStrokeDrawerImpl() {}
+
+  void draw(const Stroke& stroke, CL_GraphicContext* gc)
+  {
+    CL_OpenGLState state(CL_Display::get_current_window()->get_gc());
+    state.set_active();
+    state.setup_2d();
+
+    CL_Color color = DrawerProperties::current()->get_color();
+
+    const Stroke::Dabs& dabs = stroke.get_interpolated_dabs(DrawerProperties::current()->get_spacing(),
+                                                            DrawerProperties::current()->get_spacing());
+
+    if (dabs.size() >= 2)
+      {
+        std::vector<CL_Pointf> normals;
+        
+        if (stroke.get_dab_count() == 2)
+          {
+            normals.push_back(CL_Pointf(1.0f, 1.0f));
+            normals.push_back(CL_Pointf(1.0f, 1.0f));
+          }
+        else if (stroke.get_dab_count() >= 3)
+          {
+            for(Stroke::Dabs::size_type i = 0; i < dabs.size()-1; ++i)
+              {
+                CL_Pointf normal((dabs[i].pos.y - dabs[i+1].pos.y),
+                                 -(dabs[i].pos.x - dabs[i+1].pos.x));
+
+                float length = sqrt(normal.x * normal.x + normal.y * normal.y);
+
+                normal.x /= length;
+                normal.y /= length;
+          
+                normals.push_back(normal);
+              }
+      
+            normals.push_back(CL_Pointf(1.0f, 1.0f));
+          }
+
+        float len  = DrawerProperties::current()->get_size() * 8.0f;
+        float len2 = DrawerProperties::current()->get_size() * 16.0f;
+            
+        glEnable(GL_BLEND);
+        glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );
+
+        glBegin(GL_QUAD_STRIP);
+        for(unsigned int j = 0; j < dabs.size()-2; ++j)
+          {
+            glColor4ub(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
+            glVertex2f(dabs[j].pos.x + normals[j].x * len,
+                       dabs[j].pos.y + normals[j].y * len);
+
+            glColor4ub(color.get_red(), color.get_green(), color.get_blue(), 0);
+            glVertex2f(dabs[j].pos.x + normals[j].x * len2,
+                       dabs[j].pos.y + normals[j].y * len2);
+          }
+        glEnd();
+
+        glBegin(GL_QUAD_STRIP);
+        for(unsigned int j = 0; j < dabs.size()-2; ++j)
+          {
+            glColor4ub(color.get_red(), color.get_green(), color.get_blue(), 0);
+            glVertex2f(dabs[j].pos.x - normals[j].x * len2,
+                       dabs[j].pos.y - normals[j].y * len2);
+
+            glColor4ub(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
+            glVertex2f(dabs[j].pos.x - normals[j].x * len,
+                       dabs[j].pos.y - normals[j].y * len);
+          }
+        glEnd();
+
+        glBegin(GL_QUAD_STRIP);
+        glColor4ub(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
+        for(unsigned int j = 0; j < dabs.size()-2; ++j)
+          {
+            glVertex2f(dabs[j].pos.x + normals[j].x * len,
+                       dabs[j].pos.y + normals[j].y * len);
+            glVertex2f(dabs[j].pos.x - normals[j].x * len,
+                       dabs[j].pos.y - normals[j].y * len);
+          }
+        glEnd();
+      }
+  }
+
+  StrokeDrawerImpl* clone() const 
+  {
+    MarkerStrokeDrawerImpl* drawer = new MarkerStrokeDrawerImpl();
+  
+    *drawer = *this;
+    
+    return drawer;
+  }
+};
+
+MarkerStrokeDrawer::MarkerStrokeDrawer()
+  : impl(new MarkerStrokeDrawerImpl())
+{
+}
+
+StrokeDrawer
+MarkerStrokeDrawer::to_drawer()
+{
+  return StrokeDrawer(impl);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/marker_stroke_drawer.cxx
===================================================================
--- trunk/flexlay/lib/marker_stroke_drawer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/marker_stroke_drawer.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,135 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <ClanLib/gl.h>
-#include <ClanLib/Display/display.h>
-#include "stroke_drawer_impl.hxx"
-#include "stroke.hxx"
-#include "drawer_properties.hxx"
-#include "marker_stroke_drawer.hxx"
-
-class MarkerStrokeDrawerImpl : public StrokeDrawerImpl
-{
-public:
-  MarkerStrokeDrawerImpl() {}
-
-  void draw(const Stroke& stroke, CL_GraphicContext* gc)
-  {
-    CL_OpenGLState state(CL_Display::get_current_window()->get_gc());
-    state.set_active();
-    state.setup_2d();
-
-    CL_Color color = DrawerProperties::current()->get_color();
-
-    const Stroke::Dabs& dabs = stroke.get_interpolated_dabs(DrawerProperties::current()->get_spacing(),
-                                                            DrawerProperties::current()->get_spacing());
-
-    if (dabs.size() >= 2)
-      {
-        std::vector<CL_Pointf> normals;
-        
-        if (stroke.get_dab_count() == 2)
-          {
-            normals.push_back(CL_Pointf(1.0f, 1.0f));
-            normals.push_back(CL_Pointf(1.0f, 1.0f));
-          }
-        else if (stroke.get_dab_count() >= 3)
-          {
-            for(Stroke::Dabs::size_type i = 0; i < dabs.size()-1; ++i)
-              {
-                CL_Pointf normal((dabs[i].pos.y - dabs[i+1].pos.y),
-                                 -(dabs[i].pos.x - dabs[i+1].pos.x));
-
-                float length = sqrt(normal.x * normal.x + normal.y * normal.y);
-
-                normal.x /= length;
-                normal.y /= length;
-          
-                normals.push_back(normal);
-              }
-      
-            normals.push_back(CL_Pointf(1.0f, 1.0f));
-          }
-
-        float len  = DrawerProperties::current()->get_size() * 8.0f;
-        float len2 = DrawerProperties::current()->get_size() * 16.0f;
-            
-        glEnable(GL_BLEND);
-        glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );
-
-        glBegin(GL_QUAD_STRIP);
-        for(unsigned int j = 0; j < dabs.size()-2; ++j)
-          {
-            glColor4ub(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
-            glVertex2f(dabs[j].pos.x + normals[j].x * len,
-                       dabs[j].pos.y + normals[j].y * len);
-
-            glColor4ub(color.get_red(), color.get_green(), color.get_blue(), 0);
-            glVertex2f(dabs[j].pos.x + normals[j].x * len2,
-                       dabs[j].pos.y + normals[j].y * len2);
-          }
-        glEnd();
-
-        glBegin(GL_QUAD_STRIP);
-        for(unsigned int j = 0; j < dabs.size()-2; ++j)
-          {
-            glColor4ub(color.get_red(), color.get_green(), color.get_blue(), 0);
-            glVertex2f(dabs[j].pos.x - normals[j].x * len2,
-                       dabs[j].pos.y - normals[j].y * len2);
-
-            glColor4ub(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
-            glVertex2f(dabs[j].pos.x - normals[j].x * len,
-                       dabs[j].pos.y - normals[j].y * len);
-          }
-        glEnd();
-
-        glBegin(GL_QUAD_STRIP);
-        glColor4ub(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
-        for(unsigned int j = 0; j < dabs.size()-2; ++j)
-          {
-            glVertex2f(dabs[j].pos.x + normals[j].x * len,
-                       dabs[j].pos.y + normals[j].y * len);
-            glVertex2f(dabs[j].pos.x - normals[j].x * len,
-                       dabs[j].pos.y - normals[j].y * len);
-          }
-        glEnd();
-      }
-  }
-
-  StrokeDrawerImpl* clone() const 
-  {
-    MarkerStrokeDrawerImpl* drawer = new MarkerStrokeDrawerImpl();
-  
-    *drawer = *this;
-    
-    return drawer;
-  }
-};
-
-MarkerStrokeDrawer::MarkerStrokeDrawer()
-  : impl(new MarkerStrokeDrawerImpl())
-{
-}
-
-StrokeDrawer
-MarkerStrokeDrawer::to_drawer()
-{
-  return StrokeDrawer(impl);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/marker_stroke_drawer.hpp (from rev 712, trunk/flexlay/lib/marker_stroke_drawer.hxx)
===================================================================
--- trunk/flexlay/lib/marker_stroke_drawer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/marker_stroke_drawer.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,41 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_MARKER_STROKE_DRAWER_HXX
+#define HEADER_MARKER_STROKE_DRAWER_HXX
+
+#include "stroke_drawer.hpp"
+
+class MarkerStrokeDrawerImpl;
+
+/** */
+class MarkerStrokeDrawer
+{
+private:
+public:
+  MarkerStrokeDrawer();
+  
+  StrokeDrawer to_drawer();
+
+private:
+  SharedPtr<MarkerStrokeDrawerImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/marker_stroke_drawer.hxx
===================================================================
--- trunk/flexlay/lib/marker_stroke_drawer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/marker_stroke_drawer.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,41 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_MARKER_STROKE_DRAWER_HXX
-#define HEADER_MARKER_STROKE_DRAWER_HXX
-
-#include "stroke_drawer.hxx"
-
-class MarkerStrokeDrawerImpl;
-
-/** */
-class MarkerStrokeDrawer
-{
-private:
-public:
-  MarkerStrokeDrawer();
-  
-  StrokeDrawer to_drawer();
-
-private:
-  SharedPtr<MarkerStrokeDrawerImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/math.hpp (from rev 712, trunk/flexlay/lib/math.hxx)

Deleted: trunk/flexlay/lib/math.hxx
===================================================================
--- trunk/flexlay/lib/math.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/math.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,52 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_MATH_HXX
-#define HEADER_MATH_HXX
-
-namespace Math {
-
-template<class T> 
-T min (const T& a, const T& b) 
-{
-  if (a < b)
-    return a;
-  else
-    return b;
-}
-
-template<class T> 
-T max (const T& a, const T& b) 
-{
-  if (a > b)
-    return a;
-  else
-    return b;
-}
-
-template<class T> 
-T mid (const T& a, const T& b, const T& c) 
-{
-  return max<T>((a), min<T>((b), (c)));
-}
-
-} // namespace Math
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/menu.cpp (from rev 712, trunk/flexlay/lib/menu.cxx)
===================================================================
--- trunk/flexlay/lib/menu.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/menu.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,292 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include <string>
+#include <ClanLib/Display/display.h>
+#include <ClanLib/Display/sprite.h>
+#include "fonts.hpp"
+#include "box.hpp"
+#include "menu.hpp"
+
+class MenuItem;
+
+class MenuImpl
+{
+public:
+  Menu* parent;
+  std::vector<CL_Slot> slots;
+
+  typedef std::vector<MenuItem*> Items;
+  Items items;
+  
+  int current_item;
+
+  int width;
+  int height;
+
+  MenuImpl() {
+    current_item = -1;
+  }
+
+  void draw();
+  void recalc_size();
+  int  get_width();
+  int  get_height();
+
+  void on_mouse_move(const CL_InputEvent& event);
+  void on_mouse_down(const CL_InputEvent& event);
+};
+
+class MenuItem
+{
+protected:
+  MenuImpl* parent;
+  CL_Signal_v0 on_clicked;
+
+public:
+  MenuItem(MenuImpl* parent_) 
+    : parent(parent_) {}
+
+  virtual ~MenuItem() {}
+
+  virtual void draw(int x, int y, bool active) =0;
+  virtual int get_width() =0;
+  virtual int get_height() =0;
+
+  CL_Signal_v0& sig_clicked() { return on_clicked; }
+};
+
+class SeparatorMenuItem : public MenuItem
+{
+public:
+  SeparatorMenuItem(MenuImpl* parent_) 
+    : MenuItem(parent_)
+  {}
+  virtual ~SeparatorMenuItem() {}
+
+  void draw(int x, int y, bool active) 
+  {
+    CL_Display::fill_rect(CL_Rect(CL_Point(x, y), CL_Size(parent->get_width()-7, 2)), 
+                          CL_Color(150, 150, 150));
+    CL_Display::fill_rect(CL_Rect(CL_Point(x, y+1), CL_Size(parent->get_width()-7, 1)),
+                          CL_Color(255, 255, 255));
+  }
+
+  int get_width()  { return 10; }
+  int get_height() { return 2; }
+};
+
+class TextMenuItem : public MenuItem
+{
+private:
+  CL_Sprite sprite;
+  std::string text;
+
+public:
+  TextMenuItem(const CL_Sprite& sprite_, const std::string& text_, MenuImpl* parent_)
+    : MenuItem(parent_),
+      sprite(sprite_),
+      text(text_) 
+  {
+    if (sprite)
+      sprite.set_alignment(origin_center);
+  }
+
+  virtual ~TextMenuItem() {}
+
+  void draw(int x, int y, bool active) {
+    if (active)
+      CL_Display::fill_rect(CL_Rect(CL_Point(x, y-2), CL_Size(parent->get_width() - 7, 18)), 
+                            CL_Color(255, 255, 255));
+    if (sprite)
+      {
+        sprite.draw(x+10, y+7);
+      }
+    Fonts::verdana11.draw(x+24, y, text);
+  }
+  int get_width()  { return Fonts::verdana11.bounding_rect(0, 0, text).get_width() + 16; }
+  int get_height() { return Fonts::verdana11.get_height(); }
+};
+
+Menu::Menu(const CL_Point& pos, CL_Component* parent)
+  : CL_Component(CL_Rect(pos, CL_Size(1,1)), parent),
+    impl(new MenuImpl())
+{
+  impl->parent = this;
+
+  impl->width  = 1;
+  impl->height = 1;
+
+  impl->slots.push_back(sig_paint().connect(impl.get(), &MenuImpl::draw));
+  impl->slots.push_back(sig_mouse_move().connect(impl.get(), &MenuImpl::on_mouse_move));
+  impl->slots.push_back(sig_mouse_down().connect(impl.get(), &MenuImpl::on_mouse_down));
+
+  show(false);
+}
+
+Menu::~Menu()
+{
+  clear();
+}
+
+void
+Menu::clear()
+{
+  for(MenuImpl::Items::iterator i = impl->items.begin(); i != impl->items.end(); ++i)
+    delete *i;
+  impl->items.clear();
+}
+
+MenuItemHandle
+Menu::add_separator()
+{
+  impl->items.push_back(new SeparatorMenuItem(impl.get()));
+  impl->recalc_size();
+  return impl->items.size()-1;
+}
+
+MenuItemHandle
+Menu::add_item(const std::string& name)
+{
+  impl->items.push_back(new TextMenuItem(CL_Sprite(), name, impl.get()));
+  impl->recalc_size();
+  return impl->items.size()-1;
+}
+
+MenuItemHandle
+Menu::add_item(const CL_Sprite& sprite, const std::string& name)
+{
+  impl->items.push_back(new TextMenuItem(sprite, name, impl.get()));
+  impl->recalc_size();
+  return impl->items.size()-1;
+}
+
+MenuItemHandle
+Menu::add_submenu(const std::string& name, const Menu& submenu)
+{
+  impl->recalc_size();
+  return -1;
+}
+
+void
+MenuImpl::recalc_size()
+{
+  height = 0;
+  width = 0;
+
+  for(Items::iterator i = items.begin(); i != items.end(); ++i)
+    width = std::max(width, (*i)->get_width());
+
+  for(Items::iterator i = items.begin(); i != items.end(); ++i)
+    height += (*i)->get_height() + 6;
+  
+  width  += 12 + 24;
+  height += 8;
+
+  parent->set_size(width, height);
+}
+
+void
+MenuImpl::draw()
+{
+  CL_Display::push_translate(parent->get_screen_x(), parent->get_screen_y());
+
+  Box::draw_window(CL_Rect(CL_Point(0, 0), 
+                           CL_Size(parent->get_width(),
+                                   parent->get_height())));
+  int x_pos = 3;
+  int y_pos = 6;
+
+  for(int i = 0; i < int(items.size()); ++i)
+    {
+      if (i == current_item)
+        items[i]->draw(x_pos, y_pos, true);
+      else
+        items[i]->draw(x_pos, y_pos, false);
+      y_pos += items[i]->get_height() + 6;
+    }
+  CL_Display::pop_modelview();
+}
+
+int
+MenuImpl::get_width()
+{
+  return width;
+}
+
+int
+MenuImpl::get_height()
+{
+  return height;
+}
+
+void
+MenuImpl::on_mouse_down(const CL_InputEvent& event)
+{
+  if (current_item != -1)
+    {
+      items[current_item]->sig_clicked()();
+    }
+  parent->release_mouse();
+  parent->show(false);
+}
+
+void
+MenuImpl::on_mouse_move(const CL_InputEvent& event)
+{
+  if (parent->has_mouse_over())
+    {
+      int y_pos = 6;
+
+      for(int i = 0; i < int(items.size()); ++i)
+        {
+          y_pos += items[i]->get_height() + 6;      
+          if (y_pos > event.mouse_pos.y)
+            {
+              current_item = i;
+              return;
+            }
+        }
+      current_item = -1;
+    }
+  else
+    {
+      current_item = -1;
+    }
+}
+
+CL_Signal_v0&
+Menu::sig_clicked(MenuItemHandle item)
+{
+  return impl->items[item]->sig_clicked();
+}
+
+void
+Menu::run()
+{
+  // FIXME: Make menu act sane on == 0 items
+  if (impl->items.size() > 0)
+    {
+      show(true);
+      capture_mouse();
+      raise();
+    }
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/menu.cxx
===================================================================
--- trunk/flexlay/lib/menu.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/menu.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,292 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <string>
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/sprite.h>
-#include "fonts.hxx"
-#include "box.hxx"
-#include "menu.hxx"
-
-class MenuItem;
-
-class MenuImpl
-{
-public:
-  Menu* parent;
-  std::vector<CL_Slot> slots;
-
-  typedef std::vector<MenuItem*> Items;
-  Items items;
-  
-  int current_item;
-
-  int width;
-  int height;
-
-  MenuImpl() {
-    current_item = -1;
-  }
-
-  void draw();
-  void recalc_size();
-  int  get_width();
-  int  get_height();
-
-  void on_mouse_move(const CL_InputEvent& event);
-  void on_mouse_down(const CL_InputEvent& event);
-};
-
-class MenuItem
-{
-protected:
-  MenuImpl* parent;
-  CL_Signal_v0 on_clicked;
-
-public:
-  MenuItem(MenuImpl* parent_) 
-    : parent(parent_) {}
-
-  virtual ~MenuItem() {}
-
-  virtual void draw(int x, int y, bool active) =0;
-  virtual int get_width() =0;
-  virtual int get_height() =0;
-
-  CL_Signal_v0& sig_clicked() { return on_clicked; }
-};
-
-class SeparatorMenuItem : public MenuItem
-{
-public:
-  SeparatorMenuItem(MenuImpl* parent_) 
-    : MenuItem(parent_)
-  {}
-  virtual ~SeparatorMenuItem() {}
-
-  void draw(int x, int y, bool active) 
-  {
-    CL_Display::fill_rect(CL_Rect(CL_Point(x, y), CL_Size(parent->get_width()-7, 2)), 
-                          CL_Color(150, 150, 150));
-    CL_Display::fill_rect(CL_Rect(CL_Point(x, y+1), CL_Size(parent->get_width()-7, 1)),
-                          CL_Color(255, 255, 255));
-  }
-
-  int get_width()  { return 10; }
-  int get_height() { return 2; }
-};
-
-class TextMenuItem : public MenuItem
-{
-private:
-  CL_Sprite sprite;
-  std::string text;
-
-public:
-  TextMenuItem(const CL_Sprite& sprite_, const std::string& text_, MenuImpl* parent_)
-    : MenuItem(parent_),
-      sprite(sprite_),
-      text(text_) 
-  {
-    if (sprite)
-      sprite.set_alignment(origin_center);
-  }
-
-  virtual ~TextMenuItem() {}
-
-  void draw(int x, int y, bool active) {
-    if (active)
-      CL_Display::fill_rect(CL_Rect(CL_Point(x, y-2), CL_Size(parent->get_width() - 7, 18)), 
-                            CL_Color(255, 255, 255));
-    if (sprite)
-      {
-        sprite.draw(x+10, y+7);
-      }
-    Fonts::verdana11.draw(x+24, y, text);
-  }
-  int get_width()  { return Fonts::verdana11.bounding_rect(0, 0, text).get_width() + 16; }
-  int get_height() { return Fonts::verdana11.get_height(); }
-};
-
-Menu::Menu(const CL_Point& pos, CL_Component* parent)
-  : CL_Component(CL_Rect(pos, CL_Size(1,1)), parent),
-    impl(new MenuImpl())
-{
-  impl->parent = this;
-
-  impl->width  = 1;
-  impl->height = 1;
-
-  impl->slots.push_back(sig_paint().connect(impl.get(), &MenuImpl::draw));
-  impl->slots.push_back(sig_mouse_move().connect(impl.get(), &MenuImpl::on_mouse_move));
-  impl->slots.push_back(sig_mouse_down().connect(impl.get(), &MenuImpl::on_mouse_down));
-
-  show(false);
-}
-
-Menu::~Menu()
-{
-  clear();
-}
-
-void
-Menu::clear()
-{
-  for(MenuImpl::Items::iterator i = impl->items.begin(); i != impl->items.end(); ++i)
-    delete *i;
-  impl->items.clear();
-}
-
-MenuItemHandle
-Menu::add_separator()
-{
-  impl->items.push_back(new SeparatorMenuItem(impl.get()));
-  impl->recalc_size();
-  return impl->items.size()-1;
-}
-
-MenuItemHandle
-Menu::add_item(const std::string& name)
-{
-  impl->items.push_back(new TextMenuItem(CL_Sprite(), name, impl.get()));
-  impl->recalc_size();
-  return impl->items.size()-1;
-}
-
-MenuItemHandle
-Menu::add_item(const CL_Sprite& sprite, const std::string& name)
-{
-  impl->items.push_back(new TextMenuItem(sprite, name, impl.get()));
-  impl->recalc_size();
-  return impl->items.size()-1;
-}
-
-MenuItemHandle
-Menu::add_submenu(const std::string& name, const Menu& submenu)
-{
-  impl->recalc_size();
-  return -1;
-}
-
-void
-MenuImpl::recalc_size()
-{
-  height = 0;
-  width = 0;
-
-  for(Items::iterator i = items.begin(); i != items.end(); ++i)
-    width = std::max(width, (*i)->get_width());
-
-  for(Items::iterator i = items.begin(); i != items.end(); ++i)
-    height += (*i)->get_height() + 6;
-  
-  width  += 12 + 24;
-  height += 8;
-
-  parent->set_size(width, height);
-}
-
-void
-MenuImpl::draw()
-{
-  CL_Display::push_translate(parent->get_screen_x(), parent->get_screen_y());
-
-  Box::draw_window(CL_Rect(CL_Point(0, 0), 
-                           CL_Size(parent->get_width(),
-                                   parent->get_height())));
-  int x_pos = 3;
-  int y_pos = 6;
-
-  for(int i = 0; i < int(items.size()); ++i)
-    {
-      if (i == current_item)
-        items[i]->draw(x_pos, y_pos, true);
-      else
-        items[i]->draw(x_pos, y_pos, false);
-      y_pos += items[i]->get_height() + 6;
-    }
-  CL_Display::pop_modelview();
-}
-
-int
-MenuImpl::get_width()
-{
-  return width;
-}
-
-int
-MenuImpl::get_height()
-{
-  return height;
-}
-
-void
-MenuImpl::on_mouse_down(const CL_InputEvent& event)
-{
-  if (current_item != -1)
-    {
-      items[current_item]->sig_clicked()();
-    }
-  parent->release_mouse();
-  parent->show(false);
-}
-
-void
-MenuImpl::on_mouse_move(const CL_InputEvent& event)
-{
-  if (parent->has_mouse_over())
-    {
-      int y_pos = 6;
-
-      for(int i = 0; i < int(items.size()); ++i)
-        {
-          y_pos += items[i]->get_height() + 6;      
-          if (y_pos > event.mouse_pos.y)
-            {
-              current_item = i;
-              return;
-            }
-        }
-      current_item = -1;
-    }
-  else
-    {
-      current_item = -1;
-    }
-}
-
-CL_Signal_v0&
-Menu::sig_clicked(MenuItemHandle item)
-{
-  return impl->items[item]->sig_clicked();
-}
-
-void
-Menu::run()
-{
-  // FIXME: Make menu act sane on == 0 items
-  if (impl->items.size() > 0)
-    {
-      show(true);
-      capture_mouse();
-      raise();
-    }
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/menu.hpp (from rev 712, trunk/flexlay/lib/menu.hxx)
===================================================================
--- trunk/flexlay/lib/menu.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/menu.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,57 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_MENU_HXX
+#define HEADER_MENU_HXX
+
+#include <string>
+#include <ClanLib/GUI/component.h>
+#include <ClanLib/Core/Math/rect.h>
+#include "shared_ptr.hpp"
+
+class MenuImpl;
+class CL_Sprite;
+
+typedef int MenuItemHandle;
+
+/** */
+class Menu : public CL_Component
+{
+protected:
+  virtual ~Menu();
+
+public:
+  Menu(const CL_Point& pos, CL_Component* parent);
+
+  void clear();
+
+  MenuItemHandle add_item(const std::string& name);
+  MenuItemHandle add_item(const CL_Sprite& sprite, const std::string& name);
+  MenuItemHandle add_submenu(const std::string& name, const Menu& submenu);
+  MenuItemHandle add_separator();
+
+  CL_Signal_v0& sig_clicked(MenuItemHandle item);
+
+  void run();
+private:
+  SharedPtr<MenuImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/menu.hxx
===================================================================
--- trunk/flexlay/lib/menu.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/menu.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,57 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_MENU_HXX
-#define HEADER_MENU_HXX
-
-#include <string>
-#include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/Math/rect.h>
-#include "shared_ptr.hxx"
-
-class MenuImpl;
-class CL_Sprite;
-
-typedef int MenuItemHandle;
-
-/** */
-class Menu : public CL_Component
-{
-protected:
-  virtual ~Menu();
-
-public:
-  Menu(const CL_Point& pos, CL_Component* parent);
-
-  void clear();
-
-  MenuItemHandle add_item(const std::string& name);
-  MenuItemHandle add_item(const CL_Sprite& sprite, const std::string& name);
-  MenuItemHandle add_submenu(const std::string& name, const Menu& submenu);
-  MenuItemHandle add_separator();
-
-  CL_Signal_v0& sig_clicked(MenuItemHandle item);
-
-  void run();
-private:
-  SharedPtr<MenuImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/menubar.cpp (from rev 712, trunk/flexlay/lib/menubar.cxx)
===================================================================
--- trunk/flexlay/lib/menubar.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/menubar.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,52 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "menu.hpp"
+#include "menubar.hpp"
+
+class MenubarItem
+{
+public:
+  MenubarItem(const std::string& name_, Menu* menu_)
+    : name(name_), menu(menu_){}
+
+  std::string name;
+  Menu* menu;
+};
+
+class MenubarImpl
+{
+public:
+  typedef std::vector<MenubarItem> Items;
+  Items items;
+};
+
+Menubar::Menubar(const CL_Point& pos, CL_Component* parent)
+  : CL_Component(CL_Rect(pos, CL_Size(1, 1)), parent),
+    impl(new MenubarImpl())
+{
+  
+}
+
+void
+Menubar::add_submenu(const std::string& name, Menu* menu)
+{
+  impl->items.push_back(MenubarItem(name, menu));
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/menubar.cxx
===================================================================
--- trunk/flexlay/lib/menubar.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/menubar.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,52 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "menu.hxx"
-#include "menubar.hxx"
-
-class MenubarItem
-{
-public:
-  MenubarItem(const std::string& name_, Menu* menu_)
-    : name(name_), menu(menu_){}
-
-  std::string name;
-  Menu* menu;
-};
-
-class MenubarImpl
-{
-public:
-  typedef std::vector<MenubarItem> Items;
-  Items items;
-};
-
-Menubar::Menubar(const CL_Point& pos, CL_Component* parent)
-  : CL_Component(CL_Rect(pos, CL_Size(1, 1)), parent),
-    impl(new MenubarImpl())
-{
-  
-}
-
-void
-Menubar::add_submenu(const std::string& name, Menu* menu)
-{
-  impl->items.push_back(MenubarItem(name, menu));
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/menubar.hpp (from rev 712, trunk/flexlay/lib/menubar.hxx)
===================================================================
--- trunk/flexlay/lib/menubar.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/menubar.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,44 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_MENUBAR_HXX
+#define HEADER_MENUBAR_HXX
+
+#include <ClanLib/GUI/component.h>
+#include <ClanLib/Core/Math/rect.h>
+#include "shared_ptr.hpp"
+
+class Menu;
+class MenubarImpl;
+
+/** */
+class Menubar : public CL_Component
+{
+protected:
+  virtual ~Menubar() {}
+public:
+  Menubar(const CL_Point& pos, CL_Component* parent);
+
+  void add_submenu(const std::string& name, Menu* menu);
+private:
+  SharedPtr<MenubarImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/menubar.hxx
===================================================================
--- trunk/flexlay/lib/menubar.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/menubar.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,44 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_MENUBAR_HXX
-#define HEADER_MENUBAR_HXX
-
-#include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/Math/rect.h>
-#include "shared_ptr.hxx"
-
-class Menu;
-class MenubarImpl;
-
-/** */
-class Menubar : public CL_Component
-{
-protected:
-  virtual ~Menubar() {}
-public:
-  Menubar(const CL_Point& pos, CL_Component* parent);
-
-  void add_submenu(const std::string& name, Menu* menu);
-private:
-  SharedPtr<MenubarImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/meta_data.cpp (from rev 712, trunk/flexlay/lib/meta_data.cxx)
===================================================================
--- trunk/flexlay/lib/meta_data.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/meta_data.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,40 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "meta_data.hpp"
+
+MetaData::MetaData()
+{
+}
+
+MetaData::MetaData(SharedPtr<MetaDataImpl> impl_)
+  : impl(impl_)
+{
+}
+
+MetaData::~MetaData()
+{
+}
+
+SharedPtr<MetaDataImpl>
+MetaData::get_impl() const
+{
+  return impl;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/meta_data.cxx
===================================================================
--- trunk/flexlay/lib/meta_data.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/meta_data.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,40 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "meta_data.hxx"
-
-MetaData::MetaData()
-{
-}
-
-MetaData::MetaData(SharedPtr<MetaDataImpl> impl_)
-  : impl(impl_)
-{
-}
-
-MetaData::~MetaData()
-{
-}
-
-SharedPtr<MetaDataImpl>
-MetaData::get_impl() const
-{
-  return impl;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/meta_data.hpp (from rev 712, trunk/flexlay/lib/meta_data.hxx)
===================================================================
--- trunk/flexlay/lib/meta_data.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/meta_data.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,42 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_META_DATA_HXX
+#define HEADER_META_DATA_HXX
+
+#include "shared_ptr.hpp"
+
+class MetaDataImpl;
+
+/** */
+class MetaData
+{
+private:
+public:
+  MetaData();
+  MetaData(SharedPtr<MetaDataImpl> impl_);
+  ~MetaData();
+  
+  SharedPtr<MetaDataImpl> get_impl() const;
+private:
+  SharedPtr<MetaDataImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/meta_data.hxx
===================================================================
--- trunk/flexlay/lib/meta_data.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/meta_data.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,42 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_META_DATA_HXX
-#define HEADER_META_DATA_HXX
-
-#include "shared_ptr.hxx"
-
-class MetaDataImpl;
-
-/** */
-class MetaData
-{
-private:
-public:
-  MetaData();
-  MetaData(SharedPtr<MetaDataImpl> impl_);
-  ~MetaData();
-  
-  SharedPtr<MetaDataImpl> get_impl() const;
-private:
-  SharedPtr<MetaDataImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/meta_data_impl.hpp (from rev 712, trunk/flexlay/lib/meta_data_impl.hxx)

Deleted: trunk/flexlay/lib/meta_data_impl.hxx
===================================================================
--- trunk/flexlay/lib/meta_data_impl.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/meta_data_impl.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,43 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_META_DATA_IMPL_HXX
-#define HEADER_META_DATA_IMPL_HXX
-
-/** */
-class MetaDataImpl
-{
-private:
-public:
-  MetaDataImpl() {}
-  virtual ~MetaDataImpl() {}
-};
-
-template<class T> 
-class MetaDataGeneric : public MetaDataImpl
-{
-public:
-  T data;
-
-  MetaDataGeneric(const T& d)
-    : data(d) {}
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/minimap.cpp (from rev 712, trunk/flexlay/lib/minimap.cxx)
===================================================================
--- trunk/flexlay/lib/minimap.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/minimap.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,235 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include <ClanLib/Display/display.h>
+#include <ClanLib/Display/pixel_format.h>
+#include <ClanLib/Display/pixel_buffer.h>
+#include "tile.hpp"
+#include "tileset.hpp"
+#include "editor_map.hpp"
+#include "editor_map_component.hpp"
+#include "tilemap_layer.hpp"
+#include "workspace.hpp"
+#include "minimap.hpp"
+
+class MinimapImpl
+{
+public:
+  std::vector<CL_Slot> slots;
+  bool drag_active;
+  
+  int last_serial;
+  EditorMap editor_map;
+
+  EditorMapComponent* parent;
+  CL_Surface minimap_surface;
+
+  MinimapImpl() 
+    : editor_map(false)
+  {}
+  void update_minimap_surface();
+};
+
+Minimap::Minimap(EditorMapComponent* p, const CL_Rect& rect,
+                 CL_Component* parent)
+  : CL_Component(rect, parent), 
+    impl(new MinimapImpl())
+{
+  impl->slots.push_back(sig_paint().connect(this, &Minimap::draw));
+  impl->slots.push_back(sig_mouse_move().connect(this, &Minimap::mouse_move));
+  impl->slots.push_back(sig_mouse_down().connect(this, &Minimap::mouse_down));
+  impl->slots.push_back(sig_mouse_up().connect(this, &Minimap::mouse_up));
+
+  impl->parent = p ? p : EditorMapComponent::current();
+  impl->drag_active = false;
+  impl->last_serial = -1;
+}
+
+void
+Minimap::draw()
+{
+  if (impl->parent->get_workspace().get_map().is_null()) return;
+
+  if (!impl->parent || impl->parent->get_workspace().is_null())
+    return;
+
+  CL_Display::push_cliprect(get_screen_rect());
+  CL_Display::push_translate(get_screen_x(), get_screen_y());
+
+  // FIXME: Do this only on map changes
+  if (impl->last_serial != impl->parent->get_workspace().get_map().get_serial())
+    //      || editor_map != parent->get_workspace().get_map())
+    {
+      impl->update_minimap_surface();
+      impl->last_serial = impl->parent->get_workspace().get_map().get_serial();
+      impl->editor_map  = impl->parent->get_workspace().get_map();
+    }
+
+  if (1)
+    { // Draw background color
+      CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
+                                    CL_Size(get_width(),
+                                            get_height())),
+                            CL_Color(200, 200, 200, 225));
+    }
+
+  // FIXME: This doesn't work all that well
+  TilemapLayer tilemap = TilemapLayer::current();
+
+  if (!tilemap.is_null() && tilemap.get_height() != 0 && tilemap.get_width() != 0)
+    {
+      int tile_size = tilemap.get_tileset().get_tile_size();
+
+      int map_width  = tilemap.get_width()  * tile_size;
+      int map_height = tilemap.get_height() * tile_size;
+
+      CL_Size small_tile(tile_size * get_width() / map_width + 1,
+                         tile_size * get_height() / map_height + 1);
+
+      Field<int>* field = tilemap.get_field();
+
+      // FIXME: No current tileset
+      if (0)
+        {
+          for(int y = 0; y < field->get_height(); ++y)
+            for(int x = 0; x < field->get_width(); ++x)
+              {
+                Tile* tile = tilemap.get_tileset().create(field->at(x, y));
+                if (tile)
+                  CL_Display::fill_rect(CL_Rect(CL_Point((x * tile_size) * get_width() / map_width,
+                                                         (y * tile_size) * get_height() / map_height),
+                                                small_tile),
+                                        tile->get_color());
+                CL_Display::flush();
+              }
+        }
+      impl->minimap_surface.draw(CL_Rect(CL_Point(0, 0),
+                                   CL_Size(get_width(), get_height())));
+
+      // Draw cursor
+      CL_Rect rect(impl->parent->get_clip_rect());
+      CL_Rect screen_rect(CL_Point(rect.left  * get_width()  / map_width,
+                                   rect.top   * get_height() / map_height),
+                          CL_Size(rect.get_width() * get_width() /map_width,
+                                  rect.get_height()* get_height()/map_height));
+      CL_Display::fill_rect(screen_rect,
+                            CL_Color(255, 255, 0, 50));
+      CL_Display::draw_rect(screen_rect,
+                            CL_Color(0, 0, 0));
+    }
+
+  CL_Display::pop_modelview();
+  CL_Display::pop_cliprect();
+}
+
+void
+MinimapImpl::update_minimap_surface()
+{
+  // FIXME: This doesn't work all that well
+  TilemapLayer tilemap = TilemapLayer::current();
+  
+  if (!tilemap.is_null())
+    {
+      Field<int>* field = tilemap.get_field();
+
+      CL_PixelBuffer buffer(tilemap.get_width(), tilemap.get_height(), 
+                            tilemap.get_width()*4, CL_PixelFormat::rgba8888);
+  
+      int map_width  = tilemap.get_width();
+      int map_height = tilemap.get_height();
+
+      // FIXME: No Tileset::current()
+      unsigned char* buf = static_cast<unsigned char*>(buffer.get_data());
+      for(int y = 0; y < map_height; ++y)
+        for(int x = 0; x < map_width; ++x)
+          {
+            Tile* tile = tilemap.get_tileset().create(field->at(x, y));
+            if (tile)
+              {
+                buf[4*(x + y * map_width) + 3] = tile->get_color().get_red();
+                buf[4*(x + y * map_width) + 2] = tile->get_color().get_green();
+                buf[4*(x + y * map_width) + 1] = tile->get_color().get_blue();
+                buf[4*(x + y * map_width) + 0] = tile->get_color().get_alpha();
+              } 
+            else
+              {
+                buf[4*(x + y * map_width) + 0] = 0;
+                buf[4*(x + y * map_width) + 1] = 0;
+                buf[4*(x + y * map_width) + 2] = 0;
+                buf[4*(x + y * map_width) + 3] = 0;
+              }
+          }
+
+      minimap_surface = CL_Surface(buffer);
+    }
+}
+
+void
+Minimap::mouse_move(const CL_InputEvent& event)
+{
+  // FIXME: This doesn't work all that well
+  TilemapLayer tilemap = TilemapLayer::current();
+  if (!tilemap.is_null())
+    {
+      int tile_size  = tilemap.get_tileset().get_tile_size();
+      int map_width  = tilemap.get_width()  * tile_size;
+      int map_height = tilemap.get_height() * tile_size;
+
+      if (impl->drag_active)
+        impl->parent->move_to(event.mouse_pos.x * map_width / get_width(),
+                              event.mouse_pos.y * map_height / get_height());
+    }
+}
+
+void
+Minimap::mouse_down(const CL_InputEvent& event)
+{
+  // FIXME: This doesn't work all that well
+  TilemapLayer tilemap = TilemapLayer::current();
+  if (!tilemap.is_null())
+    {
+      int tile_size  = tilemap.get_tileset().get_tile_size();
+      int map_width  = tilemap.get_width()  * tile_size;
+      int map_height = tilemap.get_height() * tile_size;
+
+      impl->parent->move_to(event.mouse_pos.x * map_width / get_width(),
+                            event.mouse_pos.y * map_height / get_height());
+      impl->drag_active = true;
+      capture_mouse();
+    }
+}
+
+void
+Minimap::mouse_up  (const CL_InputEvent& event)
+{
+  TilemapLayer tilemap = TilemapLayer::current();
+  if (!tilemap.is_null())
+    {
+      impl->drag_active = false;
+      release_mouse();
+    }
+}
+
+void
+Minimap::update_minimap()
+{
+  impl->update_minimap_surface();
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/minimap.cxx
===================================================================
--- trunk/flexlay/lib/minimap.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/minimap.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,235 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/pixel_format.h>
-#include <ClanLib/Display/pixel_buffer.h>
-#include "tile.hxx"
-#include "tileset.hxx"
-#include "editor_map.hxx"
-#include "editor_map_component.hxx"
-#include "tilemap_layer.hxx"
-#include "workspace.hxx"
-#include "minimap.hxx"
-
-class MinimapImpl
-{
-public:
-  std::vector<CL_Slot> slots;
-  bool drag_active;
-  
-  int last_serial;
-  EditorMap editor_map;
-
-  EditorMapComponent* parent;
-  CL_Surface minimap_surface;
-
-  MinimapImpl() 
-    : editor_map(false)
-  {}
-  void update_minimap_surface();
-};
-
-Minimap::Minimap(EditorMapComponent* p, const CL_Rect& rect,
-                 CL_Component* parent)
-  : CL_Component(rect, parent), 
-    impl(new MinimapImpl())
-{
-  impl->slots.push_back(sig_paint().connect(this, &Minimap::draw));
-  impl->slots.push_back(sig_mouse_move().connect(this, &Minimap::mouse_move));
-  impl->slots.push_back(sig_mouse_down().connect(this, &Minimap::mouse_down));
-  impl->slots.push_back(sig_mouse_up().connect(this, &Minimap::mouse_up));
-
-  impl->parent = p ? p : EditorMapComponent::current();
-  impl->drag_active = false;
-  impl->last_serial = -1;
-}
-
-void
-Minimap::draw()
-{
-  if (impl->parent->get_workspace().get_map().is_null()) return;
-
-  if (!impl->parent || impl->parent->get_workspace().is_null())
-    return;
-
-  CL_Display::push_cliprect(get_screen_rect());
-  CL_Display::push_translate(get_screen_x(), get_screen_y());
-
-  // FIXME: Do this only on map changes
-  if (impl->last_serial != impl->parent->get_workspace().get_map().get_serial())
-    //      || editor_map != parent->get_workspace().get_map())
-    {
-      impl->update_minimap_surface();
-      impl->last_serial = impl->parent->get_workspace().get_map().get_serial();
-      impl->editor_map  = impl->parent->get_workspace().get_map();
-    }
-
-  if (1)
-    { // Draw background color
-      CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
-                                    CL_Size(get_width(),
-                                            get_height())),
-                            CL_Color(200, 200, 200, 225));
-    }
-
-  // FIXME: This doesn't work all that well
-  TilemapLayer tilemap = TilemapLayer::current();
-
-  if (!tilemap.is_null() && tilemap.get_height() != 0 && tilemap.get_width() != 0)
-    {
-      int tile_size = tilemap.get_tileset().get_tile_size();
-
-      int map_width  = tilemap.get_width()  * tile_size;
-      int map_height = tilemap.get_height() * tile_size;
-
-      CL_Size small_tile(tile_size * get_width() / map_width + 1,
-                         tile_size * get_height() / map_height + 1);
-
-      Field<int>* field = tilemap.get_field();
-
-      // FIXME: No current tileset
-      if (0)
-        {
-          for(int y = 0; y < field->get_height(); ++y)
-            for(int x = 0; x < field->get_width(); ++x)
-              {
-                Tile* tile = tilemap.get_tileset().create(field->at(x, y));
-                if (tile)
-                  CL_Display::fill_rect(CL_Rect(CL_Point((x * tile_size) * get_width() / map_width,
-                                                         (y * tile_size) * get_height() / map_height),
-                                                small_tile),
-                                        tile->get_color());
-                CL_Display::flush();
-              }
-        }
-      impl->minimap_surface.draw(CL_Rect(CL_Point(0, 0),
-                                   CL_Size(get_width(), get_height())));
-
-      // Draw cursor
-      CL_Rect rect(impl->parent->get_clip_rect());
-      CL_Rect screen_rect(CL_Point(rect.left  * get_width()  / map_width,
-                                   rect.top   * get_height() / map_height),
-                          CL_Size(rect.get_width() * get_width() /map_width,
-                                  rect.get_height()* get_height()/map_height));
-      CL_Display::fill_rect(screen_rect,
-                            CL_Color(255, 255, 0, 50));
-      CL_Display::draw_rect(screen_rect,
-                            CL_Color(0, 0, 0));
-    }
-
-  CL_Display::pop_modelview();
-  CL_Display::pop_cliprect();
-}
-
-void
-MinimapImpl::update_minimap_surface()
-{
-  // FIXME: This doesn't work all that well
-  TilemapLayer tilemap = TilemapLayer::current();
-  
-  if (!tilemap.is_null())
-    {
-      Field<int>* field = tilemap.get_field();
-
-      CL_PixelBuffer buffer(tilemap.get_width(), tilemap.get_height(), 
-                            tilemap.get_width()*4, CL_PixelFormat::rgba8888);
-  
-      int map_width  = tilemap.get_width();
-      int map_height = tilemap.get_height();
-
-      // FIXME: No Tileset::current()
-      unsigned char* buf = static_cast<unsigned char*>(buffer.get_data());
-      for(int y = 0; y < map_height; ++y)
-        for(int x = 0; x < map_width; ++x)
-          {
-            Tile* tile = tilemap.get_tileset().create(field->at(x, y));
-            if (tile)
-              {
-                buf[4*(x + y * map_width) + 3] = tile->get_color().get_red();
-                buf[4*(x + y * map_width) + 2] = tile->get_color().get_green();
-                buf[4*(x + y * map_width) + 1] = tile->get_color().get_blue();
-                buf[4*(x + y * map_width) + 0] = tile->get_color().get_alpha();
-              } 
-            else
-              {
-                buf[4*(x + y * map_width) + 0] = 0;
-                buf[4*(x + y * map_width) + 1] = 0;
-                buf[4*(x + y * map_width) + 2] = 0;
-                buf[4*(x + y * map_width) + 3] = 0;
-              }
-          }
-
-      minimap_surface = CL_Surface(buffer);
-    }
-}
-
-void
-Minimap::mouse_move(const CL_InputEvent& event)
-{
-  // FIXME: This doesn't work all that well
-  TilemapLayer tilemap = TilemapLayer::current();
-  if (!tilemap.is_null())
-    {
-      int tile_size  = tilemap.get_tileset().get_tile_size();
-      int map_width  = tilemap.get_width()  * tile_size;
-      int map_height = tilemap.get_height() * tile_size;
-
-      if (impl->drag_active)
-        impl->parent->move_to(event.mouse_pos.x * map_width / get_width(),
-                              event.mouse_pos.y * map_height / get_height());
-    }
-}
-
-void
-Minimap::mouse_down(const CL_InputEvent& event)
-{
-  // FIXME: This doesn't work all that well
-  TilemapLayer tilemap = TilemapLayer::current();
-  if (!tilemap.is_null())
-    {
-      int tile_size  = tilemap.get_tileset().get_tile_size();
-      int map_width  = tilemap.get_width()  * tile_size;
-      int map_height = tilemap.get_height() * tile_size;
-
-      impl->parent->move_to(event.mouse_pos.x * map_width / get_width(),
-                            event.mouse_pos.y * map_height / get_height());
-      impl->drag_active = true;
-      capture_mouse();
-    }
-}
-
-void
-Minimap::mouse_up  (const CL_InputEvent& event)
-{
-  TilemapLayer tilemap = TilemapLayer::current();
-  if (!tilemap.is_null())
-    {
-      impl->drag_active = false;
-      release_mouse();
-    }
-}
-
-void
-Minimap::update_minimap()
-{
-  impl->update_minimap_surface();
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/minimap.hpp (from rev 712, trunk/flexlay/lib/minimap.hxx)

Deleted: trunk/flexlay/lib/minimap.hxx
===================================================================
--- trunk/flexlay/lib/minimap.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/minimap.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,47 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_MINIMAP_HXX
-#define HEADER_MINIMAP_HXX
-
-#include <ClanLib/GUI/component.h>
-
-class MinimapImpl;
-
-/** */
-class Minimap : public CL_Component
-{
-protected:
-  virtual ~Minimap() {}
-public:
-  Minimap(EditorMapComponent* p, const CL_Rect& rect, CL_Component* parent);
-  
-  void draw();
-  void update_minimap();
-
-  void mouse_move(const CL_InputEvent& event);
-  void mouse_down(const CL_InputEvent& event);
-  void mouse_up  (const CL_InputEvent& event);
-  
-private:
-  SharedPtr<MinimapImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/object_add_command.cpp (from rev 712, trunk/flexlay/lib/object_add_command.cxx)
===================================================================
--- trunk/flexlay/lib/object_add_command.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_add_command.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,93 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "object_layer.hpp"
+#include "objmap_object.hpp"
+#include "object_add_command.hpp"
+
+class ObjectAddCommandImpl : public CommandImpl
+{
+public:
+  ObjectLayer objmap;
+  std::vector<ObjMapObject> objs;
+
+  ObjectAddCommandImpl() {}
+  virtual ~ObjectAddCommandImpl() {}
+
+  void execute();
+  void undo();
+  void redo();
+
+  std::string serialize();
+};
+
+ObjectAddCommand::ObjectAddCommand(const ObjectLayer& objmap_)
+  : impl(new ObjectAddCommandImpl())
+{
+  impl->objmap = objmap_;
+}
+
+ObjectAddCommand::~ObjectAddCommand()
+{
+}
+
+/*int
+ObjectAddCommand::get_handle() const
+{ 
+  return impl->obj->get_handle(); 
+}*/
+
+void
+ObjectAddCommand::add_object(const ObjMapObject& obj)
+{
+  impl->objs.push_back(obj);
+}
+
+void
+ObjectAddCommandImpl::execute()
+{
+  for(std::vector<ObjMapObject>::iterator i = objs.begin(); i != objs.end(); ++i)
+    objmap.add_object(*i);
+}
+
+void
+ObjectAddCommandImpl::undo()
+{
+  for(std::vector<ObjMapObject>::iterator i = objs.begin(); i != objs.end(); ++i)
+    objmap.delete_object(*i);
+}
+
+void
+ObjectAddCommandImpl::redo()
+{
+  execute();
+}
+
+std::string
+ObjectAddCommandImpl::serialize()
+{
+  return "";
+}
+
+Command
+ObjectAddCommand::to_command()
+{
+  return Command(impl);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_add_command.cxx
===================================================================
--- trunk/flexlay/lib/object_add_command.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_add_command.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,93 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "object_layer.hxx"
-#include "objmap_object.hxx"
-#include "object_add_command.hxx"
-
-class ObjectAddCommandImpl : public CommandImpl
-{
-public:
-  ObjectLayer objmap;
-  std::vector<ObjMapObject> objs;
-
-  ObjectAddCommandImpl() {}
-  virtual ~ObjectAddCommandImpl() {}
-
-  void execute();
-  void undo();
-  void redo();
-
-  std::string serialize();
-};
-
-ObjectAddCommand::ObjectAddCommand(const ObjectLayer& objmap_)
-  : impl(new ObjectAddCommandImpl())
-{
-  impl->objmap = objmap_;
-}
-
-ObjectAddCommand::~ObjectAddCommand()
-{
-}
-
-/*int
-ObjectAddCommand::get_handle() const
-{ 
-  return impl->obj->get_handle(); 
-}*/
-
-void
-ObjectAddCommand::add_object(const ObjMapObject& obj)
-{
-  impl->objs.push_back(obj);
-}
-
-void
-ObjectAddCommandImpl::execute()
-{
-  for(std::vector<ObjMapObject>::iterator i = objs.begin(); i != objs.end(); ++i)
-    objmap.add_object(*i);
-}
-
-void
-ObjectAddCommandImpl::undo()
-{
-  for(std::vector<ObjMapObject>::iterator i = objs.begin(); i != objs.end(); ++i)
-    objmap.delete_object(*i);
-}
-
-void
-ObjectAddCommandImpl::redo()
-{
-  execute();
-}
-
-std::string
-ObjectAddCommandImpl::serialize()
-{
-  return "";
-}
-
-Command
-ObjectAddCommand::to_command()
-{
-  return Command(impl);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/object_add_command.hpp (from rev 712, trunk/flexlay/lib/object_add_command.hxx)
===================================================================
--- trunk/flexlay/lib/object_add_command.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_add_command.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,50 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_OBJECT_ADD_COMMAND_HXX
+#define HEADER_OBJECT_ADD_COMMAND_HXX
+
+#include "objmap_object.hpp"
+#include "command.hpp"
+
+class ObjectLayer;
+class ObjectAddCommandImpl;
+
+/** ObjectAddCommand adds on object to an ObjectLayer, the user needs
+    to supply an Object together with the \a ObjectLayer to which it
+    should be added. FIXME: position should be part of the command,
+    not the object */
+class ObjectAddCommand
+{
+public:
+  ObjectAddCommand(const ObjectLayer& layer);
+  virtual ~ObjectAddCommand();
+
+  void add_object(const ObjMapObject& obj);
+
+  //int get_handle() const;
+
+  Command to_command();
+
+private:
+  SharedPtr<ObjectAddCommandImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_add_command.hxx
===================================================================
--- trunk/flexlay/lib/object_add_command.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_add_command.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,50 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_OBJECT_ADD_COMMAND_HXX
-#define HEADER_OBJECT_ADD_COMMAND_HXX
-
-#include "objmap_object.hxx"
-#include "command.hxx"
-
-class ObjectLayer;
-class ObjectAddCommandImpl;
-
-/** ObjectAddCommand adds on object to an ObjectLayer, the user needs
-    to supply an Object together with the \a ObjectLayer to which it
-    should be added. FIXME: position should be part of the command,
-    not the object */
-class ObjectAddCommand
-{
-public:
-  ObjectAddCommand(const ObjectLayer& layer);
-  virtual ~ObjectAddCommand();
-
-  void add_object(const ObjMapObject& obj);
-
-  //int get_handle() const;
-
-  Command to_command();
-
-private:
-  SharedPtr<ObjectAddCommandImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/object_brush.cpp (from rev 712, trunk/flexlay/lib/object_brush.cxx)
===================================================================
--- trunk/flexlay/lib/object_brush.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_brush.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,64 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "objmap_sprite_object.hpp"
+#include "object_add_command.hpp"
+#include "objmap_sprite_object.hpp"
+#include "object_brush.hpp"
+#include "editor_map.hpp"
+
+class ObjectBrushImpl
+{
+public:
+  CL_Sprite sprite;
+  MetaData  data;
+};
+
+ObjectBrush::ObjectBrush()
+{
+  
+}
+
+ObjectBrush::ObjectBrush(const CL_Sprite& sprite_,
+                         const MetaData& data_)
+  : impl(new ObjectBrushImpl())
+{
+  impl->sprite = sprite_;
+  impl->data   = data_;
+}
+
+CL_Sprite
+ObjectBrush::get_sprite()
+{
+  return impl->sprite;
+}
+
+MetaData
+ObjectBrush::get_data()
+{
+  return impl->data;
+}
+
+ObjMapSpriteObject
+ObjectBrush::to_sprite_object(const CL_Pointf& pos)
+{
+  ObjMapSpriteObject obj(impl->sprite, pos, impl->data);  
+  return obj;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_brush.cxx
===================================================================
--- trunk/flexlay/lib/object_brush.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_brush.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,64 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "objmap_sprite_object.hxx"
-#include "object_add_command.hxx"
-#include "objmap_sprite_object.hxx"
-#include "object_brush.hxx"
-#include "editor_map.hxx"
-
-class ObjectBrushImpl
-{
-public:
-  CL_Sprite sprite;
-  MetaData  data;
-};
-
-ObjectBrush::ObjectBrush()
-{
-  
-}
-
-ObjectBrush::ObjectBrush(const CL_Sprite& sprite_,
-                         const MetaData& data_)
-  : impl(new ObjectBrushImpl())
-{
-  impl->sprite = sprite_;
-  impl->data   = data_;
-}
-
-CL_Sprite
-ObjectBrush::get_sprite()
-{
-  return impl->sprite;
-}
-
-MetaData
-ObjectBrush::get_data()
-{
-  return impl->data;
-}
-
-ObjMapSpriteObject
-ObjectBrush::to_sprite_object(const CL_Pointf& pos)
-{
-  ObjMapSpriteObject obj(impl->sprite, pos, impl->data);  
-  return obj;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/object_brush.hpp (from rev 712, trunk/flexlay/lib/object_brush.hxx)
===================================================================
--- trunk/flexlay/lib/object_brush.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_brush.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,48 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_OBJECT_BRUSH_HXX
+#define HEADER_OBJECT_BRUSH_HXX
+
+#include <ClanLib/Display/sprite.h>
+#include <ClanLib/Core/Math/point.h>
+#include "object_layer.hpp"
+#include "objmap_object.hpp"
+#include "objmap_sprite_object.hpp"
+#include "meta_data.hpp"
+
+class ObjectBrushImpl;
+
+class ObjectBrush
+{
+public:
+  ObjectBrush();
+  ObjectBrush(const CL_Sprite& sprite_,
+              const MetaData& data_);
+
+  CL_Sprite get_sprite();
+  MetaData get_data();
+
+  ObjMapSpriteObject to_sprite_object(const CL_Pointf& pos);
+private:
+  SharedPtr<ObjectBrushImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_brush.hxx
===================================================================
--- trunk/flexlay/lib/object_brush.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_brush.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,48 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_OBJECT_BRUSH_HXX
-#define HEADER_OBJECT_BRUSH_HXX
-
-#include <ClanLib/Display/sprite.h>
-#include <ClanLib/Core/Math/point.h>
-#include "object_layer.hxx"
-#include "objmap_object.hxx"
-#include "objmap_sprite_object.hxx"
-#include "meta_data.hxx"
-
-class ObjectBrushImpl;
-
-class ObjectBrush
-{
-public:
-  ObjectBrush();
-  ObjectBrush(const CL_Sprite& sprite_,
-              const MetaData& data_);
-
-  CL_Sprite get_sprite();
-  MetaData get_data();
-
-  ObjMapSpriteObject to_sprite_object(const CL_Pointf& pos);
-private:
-  SharedPtr<ObjectBrushImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/object_delete_command.cpp (from rev 712, trunk/flexlay/lib/object_delete_command.cxx)
===================================================================
--- trunk/flexlay/lib/object_delete_command.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_delete_command.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,83 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "object_layer.hpp"
+#include "objmap_object.hpp"
+#include "command_impl.hpp"
+#include "object_delete_command.hpp"
+
+class ObjectDeleteCommandImpl : public CommandImpl
+{
+public:
+  typedef std::vector<ObjMapObject> Objects;
+
+  ObjectLayer object_layer;
+  Objects objects;
+  
+  ObjectDeleteCommandImpl() {}
+  virtual ~ObjectDeleteCommandImpl() {}
+
+  void execute();
+  void redo();
+  void undo();
+  std::string serialize() { return ""; }
+};
+
+ObjectDeleteCommand::ObjectDeleteCommand(const ObjectLayer& o)
+  : impl(new ObjectDeleteCommandImpl())
+{
+  impl->object_layer = o;
+}
+
+void
+ObjectDeleteCommand::add_object(const ObjMapObject& obj)
+{
+  impl->objects.push_back(obj);
+}
+
+void
+ObjectDeleteCommandImpl::execute()
+{
+  for(Objects::iterator i = objects.begin(); i != objects.end(); ++i)
+    {
+      object_layer.delete_object(*i);
+    }
+}
+
+void
+ObjectDeleteCommandImpl::redo()
+{
+  execute();
+}
+
+void
+ObjectDeleteCommandImpl::undo()
+{
+  for(Objects::iterator i = objects.begin(); i != objects.end(); ++i)
+    {
+      object_layer.add_object(*i);
+    }
+}
+
+Command
+ObjectDeleteCommand::to_command()
+{
+  return Command(impl);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_delete_command.cxx
===================================================================
--- trunk/flexlay/lib/object_delete_command.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_delete_command.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,83 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "object_layer.hxx"
-#include "objmap_object.hxx"
-#include "command_impl.hxx"
-#include "object_delete_command.hxx"
-
-class ObjectDeleteCommandImpl : public CommandImpl
-{
-public:
-  typedef std::vector<ObjMapObject> Objects;
-
-  ObjectLayer object_layer;
-  Objects objects;
-  
-  ObjectDeleteCommandImpl() {}
-  virtual ~ObjectDeleteCommandImpl() {}
-
-  void execute();
-  void redo();
-  void undo();
-  std::string serialize() { return ""; }
-};
-
-ObjectDeleteCommand::ObjectDeleteCommand(const ObjectLayer& o)
-  : impl(new ObjectDeleteCommandImpl())
-{
-  impl->object_layer = o;
-}
-
-void
-ObjectDeleteCommand::add_object(const ObjMapObject& obj)
-{
-  impl->objects.push_back(obj);
-}
-
-void
-ObjectDeleteCommandImpl::execute()
-{
-  for(Objects::iterator i = objects.begin(); i != objects.end(); ++i)
-    {
-      object_layer.delete_object(*i);
-    }
-}
-
-void
-ObjectDeleteCommandImpl::redo()
-{
-  execute();
-}
-
-void
-ObjectDeleteCommandImpl::undo()
-{
-  for(Objects::iterator i = objects.begin(); i != objects.end(); ++i)
-    {
-      object_layer.add_object(*i);
-    }
-}
-
-Command
-ObjectDeleteCommand::to_command()
-{
-  return Command(impl);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/object_delete_command.hpp (from rev 712, trunk/flexlay/lib/object_delete_command.hxx)
===================================================================
--- trunk/flexlay/lib/object_delete_command.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_delete_command.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,45 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_OBJECT_DELETE_COMMAND_HXX
+#define HEADER_OBJECT_DELETE_COMMAND_HXX
+
+#include <vector>
+#include "objmap_object.hpp"
+#include "command.hpp"
+
+class ObjectDeleteCommandImpl;
+class ObjectLayer;
+
+/** Delete all objects added with add_object() on the ObjectLayer
+    given at construction time */
+class ObjectDeleteCommand
+{
+public:
+  ObjectDeleteCommand(const ObjectLayer& o);
+
+  void add_object(const ObjMapObject& obj);
+
+  Command to_command();
+private:
+  SharedPtr<ObjectDeleteCommandImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_delete_command.hxx
===================================================================
--- trunk/flexlay/lib/object_delete_command.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_delete_command.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,45 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_OBJECT_DELETE_COMMAND_HXX
-#define HEADER_OBJECT_DELETE_COMMAND_HXX
-
-#include <vector>
-#include "objmap_object.hxx"
-#include "command.hxx"
-
-class ObjectDeleteCommandImpl;
-class ObjectLayer;
-
-/** Delete all objects added with add_object() on the ObjectLayer
-    given at construction time */
-class ObjectDeleteCommand
-{
-public:
-  ObjectDeleteCommand(const ObjectLayer& o);
-
-  void add_object(const ObjMapObject& obj);
-
-  Command to_command();
-private:
-  SharedPtr<ObjectDeleteCommandImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/object_layer.cpp (from rev 712, trunk/flexlay/lib/object_layer.cxx)
===================================================================
--- trunk/flexlay/lib/object_layer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_layer.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,199 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include <ClanLib/Display/display.h>
+#include <ClanLib/Core/Math/origin.h>
+#include <ClanLib/Core/System/error.h>
+#include "objmap_object.hpp"
+#include "objmap_sprite_object.hpp"
+#include "objmap_control_point.hpp"
+#include "object_layer.hpp"
+#include "editor_map_component.hpp"
+#include "layer_impl.hpp"
+
+ObjectLayer ObjectLayer::current_;
+
+class ObjectLayerImpl : public LayerImpl
+{
+public:
+  ObjectLayer::Objects objects;
+  ObjectLayer::ControlPoints control_points;
+  CL_SlotContainer slots;
+
+  ObjectLayerImpl() {}
+  virtual ~ObjectLayerImpl() {}
+  
+  void draw(EditorMapComponent* parent, CL_GraphicContext* gc);
+  bool has_bounding_rect() const { return false; }
+};
+
+ObjectLayer::ObjectLayer()
+  : impl(new ObjectLayerImpl())
+{
+}
+
+ObjectLayer::~ObjectLayer()
+{
+}
+
+void
+ObjectLayerImpl::draw(EditorMapComponent* parent, CL_GraphicContext* gc)
+{
+  for(ObjectLayer::Objects::iterator i = objects.begin(); i != objects.end(); ++i)
+    {
+      // FIXME: Add clipping here
+      if (parent->get_clip_rect().is_overlapped((*i).get_bound_rect()))
+        (*i).draw(gc);
+    }
+
+  for(ObjectLayer::ControlPoints::iterator i = control_points.begin(); i != control_points.end(); ++i)
+    {
+      (*i).draw(gc);
+    }
+}
+
+ObjMapControlPoint
+ObjectLayer::find_control_point(const CL_Pointf& click_pos)
+{
+  for(ControlPoints::reverse_iterator i = impl->control_points.rbegin(); 
+      i != impl->control_points.rend(); 
+      ++i)
+    {
+      CL_Rect rect = (*i).get_bound_rect();
+     
+      if (rect.is_inside(CL_Point(click_pos)))
+        return *i;
+    }
+  return ObjMapControlPoint(); 
+}
+
+ObjMapObject
+ObjectLayer::find_object(const CL_Pointf& click_pos)
+{
+  for(Objects::reverse_iterator i = impl->objects.rbegin(); i != impl->objects.rend(); ++i)
+    {
+      CL_Rectf rect = (*i).get_bound_rect();
+     
+      if (rect.is_inside(CL_Point(click_pos)))
+        return *i;
+    }
+  return ObjMapObject();
+}
+
+void
+ObjectLayer::delete_object(const ObjMapObject& obj)
+{
+  for(Objects::iterator i = impl->objects.begin(); i != impl->objects.end(); ++i)
+    {
+      if (obj == (*i))
+        {
+          impl->objects.erase(i);
+          break;
+        }
+    }
+}
+
+ObjectLayer::Objects
+ObjectLayer::get_selection(const CL_Rectf& rect)
+{
+  Objects selection;
+
+  for(Objects::iterator i = impl->objects.begin(); i != impl->objects.end(); ++i)
+    {
+      // FIXME:
+      if (rect.is_inside((*i).get_pos()))
+        {
+          selection.push_back(*i);
+        }
+    }
+  
+  return selection;
+}
+
+ObjectLayer::Objects
+ObjectLayer::get_objects()
+{
+  return impl->objects;
+}
+
+void
+ObjectLayer::add_object(const ObjMapObject& obj)
+{
+  impl->objects.push_back(obj);
+}
+
+void
+ObjectLayer::add_control_point(const ObjMapControlPoint& obj)
+{
+  impl->control_points.push_back(obj);
+}
+
+void
+ObjectLayer::delete_control_points()
+{
+  impl->control_points.clear();
+}
+
+Layer
+ObjectLayer::to_layer()
+{
+  return Layer(impl);
+}
+
+int
+ObjectLayer::get_object_index(const ObjMapObject& obj)
+{
+  Objects::size_type i;
+  for(i = 0; i < impl->objects.size(); ++i)
+    {
+      if (impl->objects[i] == obj)
+        {
+          return i;
+        }
+    }
+  return -1;
+}
+
+void
+ObjectLayer::move_to(const ObjMapObject& obj, int height)
+{
+  // FIXME: Implement me
+}
+
+void
+ObjectLayer::raise(const ObjMapObject& obj)
+{
+  int i = get_object_index(obj);
+  if (i != -1 && impl->objects.size() > 1 && i < int(impl->objects.size())-1)
+    {
+      std::swap(impl->objects[i], impl->objects[i+1]);
+    }
+}
+
+void
+ObjectLayer::lower(const ObjMapObject& obj)
+{
+  int i = get_object_index(obj);
+  if (i != -1 && i > 0)
+    {
+      std::swap(impl->objects[i], impl->objects[i-1]);
+    }
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_layer.cxx
===================================================================
--- trunk/flexlay/lib/object_layer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_layer.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,199 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Core/Math/origin.h>
-#include <ClanLib/Core/System/error.h>
-#include "objmap_object.hxx"
-#include "objmap_sprite_object.hxx"
-#include "objmap_control_point.hxx"
-#include "object_layer.hxx"
-#include "editor_map_component.hxx"
-#include "layer_impl.hxx"
-
-ObjectLayer ObjectLayer::current_;
-
-class ObjectLayerImpl : public LayerImpl
-{
-public:
-  ObjectLayer::Objects objects;
-  ObjectLayer::ControlPoints control_points;
-  CL_SlotContainer slots;
-
-  ObjectLayerImpl() {}
-  virtual ~ObjectLayerImpl() {}
-  
-  void draw(EditorMapComponent* parent, CL_GraphicContext* gc);
-  bool has_bounding_rect() const { return false; }
-};
-
-ObjectLayer::ObjectLayer()
-  : impl(new ObjectLayerImpl())
-{
-}
-
-ObjectLayer::~ObjectLayer()
-{
-}
-
-void
-ObjectLayerImpl::draw(EditorMapComponent* parent, CL_GraphicContext* gc)
-{
-  for(ObjectLayer::Objects::iterator i = objects.begin(); i != objects.end(); ++i)
-    {
-      // FIXME: Add clipping here
-      if (parent->get_clip_rect().is_overlapped((*i).get_bound_rect()))
-        (*i).draw(gc);
-    }
-
-  for(ObjectLayer::ControlPoints::iterator i = control_points.begin(); i != control_points.end(); ++i)
-    {
-      (*i).draw(gc);
-    }
-}
-
-ObjMapControlPoint
-ObjectLayer::find_control_point(const CL_Pointf& click_pos)
-{
-  for(ControlPoints::reverse_iterator i = impl->control_points.rbegin(); 
-      i != impl->control_points.rend(); 
-      ++i)
-    {
-      CL_Rect rect = (*i).get_bound_rect();
-     
-      if (rect.is_inside(CL_Point(click_pos)))
-        return *i;
-    }
-  return ObjMapControlPoint(); 
-}
-
-ObjMapObject
-ObjectLayer::find_object(const CL_Pointf& click_pos)
-{
-  for(Objects::reverse_iterator i = impl->objects.rbegin(); i != impl->objects.rend(); ++i)
-    {
-      CL_Rectf rect = (*i).get_bound_rect();
-     
-      if (rect.is_inside(CL_Point(click_pos)))
-        return *i;
-    }
-  return ObjMapObject();
-}
-
-void
-ObjectLayer::delete_object(const ObjMapObject& obj)
-{
-  for(Objects::iterator i = impl->objects.begin(); i != impl->objects.end(); ++i)
-    {
-      if (obj == (*i))
-        {
-          impl->objects.erase(i);
-          break;
-        }
-    }
-}
-
-ObjectLayer::Objects
-ObjectLayer::get_selection(const CL_Rectf& rect)
-{
-  Objects selection;
-
-  for(Objects::iterator i = impl->objects.begin(); i != impl->objects.end(); ++i)
-    {
-      // FIXME:
-      if (rect.is_inside((*i).get_pos()))
-        {
-          selection.push_back(*i);
-        }
-    }
-  
-  return selection;
-}
-
-ObjectLayer::Objects
-ObjectLayer::get_objects()
-{
-  return impl->objects;
-}
-
-void
-ObjectLayer::add_object(const ObjMapObject& obj)
-{
-  impl->objects.push_back(obj);
-}
-
-void
-ObjectLayer::add_control_point(const ObjMapControlPoint& obj)
-{
-  impl->control_points.push_back(obj);
-}
-
-void
-ObjectLayer::delete_control_points()
-{
-  impl->control_points.clear();
-}
-
-Layer
-ObjectLayer::to_layer()
-{
-  return Layer(impl);
-}
-
-int
-ObjectLayer::get_object_index(const ObjMapObject& obj)
-{
-  Objects::size_type i;
-  for(i = 0; i < impl->objects.size(); ++i)
-    {
-      if (impl->objects[i] == obj)
-        {
-          return i;
-        }
-    }
-  return -1;
-}
-
-void
-ObjectLayer::move_to(const ObjMapObject& obj, int height)
-{
-  // FIXME: Implement me
-}
-
-void
-ObjectLayer::raise(const ObjMapObject& obj)
-{
-  int i = get_object_index(obj);
-  if (i != -1 && impl->objects.size() > 1 && i < int(impl->objects.size())-1)
-    {
-      std::swap(impl->objects[i], impl->objects[i+1]);
-    }
-}
-
-void
-ObjectLayer::lower(const ObjMapObject& obj)
-{
-  int i = get_object_index(obj);
-  if (i != -1 && i > 0)
-    {
-      std::swap(impl->objects[i], impl->objects[i-1]);
-    }
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/object_layer.hpp (from rev 712, trunk/flexlay/lib/object_layer.hxx)
===================================================================
--- trunk/flexlay/lib/object_layer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_layer.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,85 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_OBJECT_LAYER_HXX
+#define HEADER_OBJECT_LAYER_HXX
+
+#include <vector>
+#include <ClanLib/Display/sprite.h>
+#include <ClanLib/GUI/component.h>
+#include <ClanLib/Core/Math/point.h>
+#include "meta_data.hpp"
+#include "layer.hpp"
+#include "objmap_object.hpp"
+#include "objmap_control_point.hpp"
+#include "shared_ptr.hpp"
+
+class ObjectLayerImpl;
+
+/** The ObjectLayer provides a simple Layer for holding positioned
+    objects. Objects can consist of a CL_Sprite and some properties
+    accessible from scripting languages or any other thing that is a
+    ObjMapObject. */
+class ObjectLayer
+{
+public:
+  typedef std::vector<ObjMapObject> Objects;
+  typedef std::vector<ObjMapControlPoint> ControlPoints;
+
+  static ObjectLayer current_;
+
+  static ObjectLayer current() { return current_; }
+  static void set_current(ObjectLayer c) { current_ = c; }
+
+  ObjectLayer();
+  ~ObjectLayer();
+
+  void add_object(const ObjMapObject& obj);
+  void delete_object(const ObjMapObject& obj);
+
+  /** Moved the given object one position up in the object stack */
+  void raise(const ObjMapObject& obj);
+
+  /** Moved the given object one position down in the object stack */
+  void lower(const ObjMapObject& obj);
+
+  /** Moves the object to the given height in the object stack (0 is
+      lowest position, size()-1 is highest */
+  void move_to(const ObjMapObject& obj, int height);
+
+  /** Returns the index at which the given object is in the Objects
+      array or -1 if the object couldn't be found */
+  int get_object_index(const ObjMapObject& obj);
+
+  void add_control_point(const ObjMapControlPoint& obj);
+  void delete_control_points();
+
+  ObjMapObject find_object(const CL_Pointf& pos);
+  ObjMapControlPoint find_control_point(const CL_Pointf& pos);
+  std::vector<ObjMapObject> get_selection(const CL_Rectf& rect);
+  std::vector<ObjMapObject> get_objects();
+
+  Layer to_layer();
+
+private:
+  SharedPtr<ObjectLayerImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_layer.hxx
===================================================================
--- trunk/flexlay/lib/object_layer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_layer.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,85 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_OBJECT_LAYER_HXX
-#define HEADER_OBJECT_LAYER_HXX
-
-#include <vector>
-#include <ClanLib/Display/sprite.h>
-#include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/Math/point.h>
-#include "meta_data.hxx"
-#include "layer.hxx"
-#include "objmap_object.hxx"
-#include "objmap_control_point.hxx"
-#include "shared_ptr.hxx"
-
-class ObjectLayerImpl;
-
-/** The ObjectLayer provides a simple Layer for holding positioned
-    objects. Objects can consist of a CL_Sprite and some properties
-    accessible from scripting languages or any other thing that is a
-    ObjMapObject. */
-class ObjectLayer
-{
-public:
-  typedef std::vector<ObjMapObject> Objects;
-  typedef std::vector<ObjMapControlPoint> ControlPoints;
-
-  static ObjectLayer current_;
-
-  static ObjectLayer current() { return current_; }
-  static void set_current(ObjectLayer c) { current_ = c; }
-
-  ObjectLayer();
-  ~ObjectLayer();
-
-  void add_object(const ObjMapObject& obj);
-  void delete_object(const ObjMapObject& obj);
-
-  /** Moved the given object one position up in the object stack */
-  void raise(const ObjMapObject& obj);
-
-  /** Moved the given object one position down in the object stack */
-  void lower(const ObjMapObject& obj);
-
-  /** Moves the object to the given height in the object stack (0 is
-      lowest position, size()-1 is highest */
-  void move_to(const ObjMapObject& obj, int height);
-
-  /** Returns the index at which the given object is in the Objects
-      array or -1 if the object couldn't be found */
-  int get_object_index(const ObjMapObject& obj);
-
-  void add_control_point(const ObjMapControlPoint& obj);
-  void delete_control_points();
-
-  ObjMapObject find_object(const CL_Pointf& pos);
-  ObjMapControlPoint find_control_point(const CL_Pointf& pos);
-  std::vector<ObjMapObject> get_selection(const CL_Rectf& rect);
-  std::vector<ObjMapObject> get_objects();
-
-  Layer to_layer();
-
-private:
-  SharedPtr<ObjectLayerImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/object_move_command.cpp (from rev 712, trunk/flexlay/lib/object_move_command.cxx)
===================================================================
--- trunk/flexlay/lib/object_move_command.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_move_command.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,118 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "object_layer.hpp"
+#include "objmap_object.hpp"
+#include "object_move_command.hpp"
+
+class ObjectMoveCommandImpl : public CommandImpl
+{
+public:
+  ObjectMoveCommandImpl() {}
+  virtual ~ObjectMoveCommandImpl() {}
+
+  ObjectLayer objmap;
+  
+  struct Obj {
+    CL_Pointf old_pos;
+    CL_Pointf new_pos;
+    ObjMapObject obj;
+  };
+  
+  typedef std::vector<Obj> Objects;
+  Objects objects;
+
+  void execute();
+  void redo();
+  void undo();
+
+  std::string serialize();
+};
+
+ObjectMoveCommand::ObjectMoveCommand(const ObjectLayer& o)
+  : impl(new ObjectMoveCommandImpl())
+{
+  impl->objmap = o;
+}
+
+ObjectMoveCommand::~ObjectMoveCommand()
+{
+}
+  
+void
+ObjectMoveCommandImpl::execute()
+{
+}
+
+void
+ObjectMoveCommand::add_obj(const ObjMapObject& obj)
+{
+  ObjectMoveCommandImpl::Obj o;
+  o.obj     = obj;
+  o.old_pos = obj.get_pos();
+  impl->objects.push_back(o);
+}
+
+void
+ObjectMoveCommand::move_by(const CL_Pointf& delta)
+{
+  for(ObjectMoveCommandImpl::Objects::iterator i = impl->objects.begin(); 
+      i != impl->objects.end();
+      ++i)
+    {
+      i->new_pos = i->old_pos + delta;
+      i->obj.set_pos(i->new_pos);
+      i->obj.sig_move()(i->obj);
+    }
+}
+
+void
+ObjectMoveCommandImpl::redo()
+{
+  for(ObjectMoveCommandImpl::Objects::iterator i = objects.begin(); 
+      i != objects.end();
+      ++i)
+    {
+      i->obj.set_pos(i->new_pos);
+    }  
+}
+
+void
+ObjectMoveCommandImpl::undo()
+{
+  for(ObjectMoveCommandImpl::Objects::iterator i = objects.begin(); 
+      i != objects.end();
+      ++i)
+    {
+      i->obj.set_pos(i->old_pos);
+    }
+}
+
+std::string
+ObjectMoveCommandImpl::serialize()
+{
+  return "";
+}
+
+Command
+ObjectMoveCommand::to_command()
+{
+  return Command(impl);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_move_command.cxx
===================================================================
--- trunk/flexlay/lib/object_move_command.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_move_command.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,118 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "object_layer.hxx"
-#include "objmap_object.hxx"
-#include "object_move_command.hxx"
-
-class ObjectMoveCommandImpl : public CommandImpl
-{
-public:
-  ObjectMoveCommandImpl() {}
-  virtual ~ObjectMoveCommandImpl() {}
-
-  ObjectLayer objmap;
-  
-  struct Obj {
-    CL_Pointf old_pos;
-    CL_Pointf new_pos;
-    ObjMapObject obj;
-  };
-  
-  typedef std::vector<Obj> Objects;
-  Objects objects;
-
-  void execute();
-  void redo();
-  void undo();
-
-  std::string serialize();
-};
-
-ObjectMoveCommand::ObjectMoveCommand(const ObjectLayer& o)
-  : impl(new ObjectMoveCommandImpl())
-{
-  impl->objmap = o;
-}
-
-ObjectMoveCommand::~ObjectMoveCommand()
-{
-}
-  
-void
-ObjectMoveCommandImpl::execute()
-{
-}
-
-void
-ObjectMoveCommand::add_obj(const ObjMapObject& obj)
-{
-  ObjectMoveCommandImpl::Obj o;
-  o.obj     = obj;
-  o.old_pos = obj.get_pos();
-  impl->objects.push_back(o);
-}
-
-void
-ObjectMoveCommand::move_by(const CL_Pointf& delta)
-{
-  for(ObjectMoveCommandImpl::Objects::iterator i = impl->objects.begin(); 
-      i != impl->objects.end();
-      ++i)
-    {
-      i->new_pos = i->old_pos + delta;
-      i->obj.set_pos(i->new_pos);
-      i->obj.sig_move()(i->obj);
-    }
-}
-
-void
-ObjectMoveCommandImpl::redo()
-{
-  for(ObjectMoveCommandImpl::Objects::iterator i = objects.begin(); 
-      i != objects.end();
-      ++i)
-    {
-      i->obj.set_pos(i->new_pos);
-    }  
-}
-
-void
-ObjectMoveCommandImpl::undo()
-{
-  for(ObjectMoveCommandImpl::Objects::iterator i = objects.begin(); 
-      i != objects.end();
-      ++i)
-    {
-      i->obj.set_pos(i->old_pos);
-    }
-}
-
-std::string
-ObjectMoveCommandImpl::serialize()
-{
-  return "";
-}
-
-Command
-ObjectMoveCommand::to_command()
-{
-  return Command(impl);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/object_move_command.hpp (from rev 712, trunk/flexlay/lib/object_move_command.hxx)
===================================================================
--- trunk/flexlay/lib/object_move_command.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_move_command.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,46 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_OBJECT_COMMAND_HXX
+#define HEADER_OBJECT_COMMAND_HXX
+
+#include "command.hpp"
+
+class ObjMapObject;
+class ObjectLayer;
+
+class ObjectMoveCommandImpl;
+
+/** */
+class ObjectMoveCommand
+{
+public:
+  ObjectMoveCommand(const ObjectLayer& o);
+  virtual ~ObjectMoveCommand();
+
+  void add_obj(const ObjMapObject& obj);
+  void move_by(const CL_Pointf& delta);
+
+  Command to_command();
+private:
+  SharedPtr<ObjectMoveCommandImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_move_command.hxx
===================================================================
--- trunk/flexlay/lib/object_move_command.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_move_command.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,46 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_OBJECT_COMMAND_HXX
-#define HEADER_OBJECT_COMMAND_HXX
-
-#include "command.hxx"
-
-class ObjMapObject;
-class ObjectLayer;
-
-class ObjectMoveCommandImpl;
-
-/** */
-class ObjectMoveCommand
-{
-public:
-  ObjectMoveCommand(const ObjectLayer& o);
-  virtual ~ObjectMoveCommand();
-
-  void add_obj(const ObjMapObject& obj);
-  void move_by(const CL_Pointf& delta);
-
-  Command to_command();
-private:
-  SharedPtr<ObjectMoveCommandImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/object_selector.cpp (from rev 712, trunk/flexlay/lib/object_selector.cxx)
===================================================================
--- trunk/flexlay/lib/object_selector.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_selector.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,215 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include <ClanLib/Core/core_iostream.h>
+#include <ClanLib/display.h>
+#include "editor_map.hpp"
+#include "editor_map_component.hpp"
+#include "object_selector.hpp"
+#include "object_add_command.hpp"
+
+ObjectSelector::ObjectSelector(const CL_Rect& rect, 
+                               int obj_w, int obj_h,
+                               CL_Component* parent)
+  : CL_Component(rect, parent),
+    width(rect.get_width()/obj_w), height(rect.get_height()/obj_h),
+    obj_width(obj_w), obj_height(obj_h)
+{
+  index = 0;
+
+  slots.push_back(sig_paint().connect(this, &ObjectSelector::draw));
+  slots.push_back(sig_mouse_move().connect(this, &ObjectSelector::mouse_move));
+  slots.push_back(sig_mouse_down().connect(this, &ObjectSelector::mouse_down));
+  slots.push_back(sig_mouse_up().connect(this, &ObjectSelector::mouse_up));
+ 
+  mouse_over_tile = -1;
+  scrolling = false;
+  offset = 0;
+  scale = 1.0f;
+  drag_obj = -1;
+}
+
+ObjectSelector::~ObjectSelector()
+{
+}
+
+void
+ObjectSelector::mouse_up(const CL_InputEvent& event)
+{
+  switch(event.id)
+    {
+    case CL_MOUSE_LEFT:
+      {
+        if (drag_obj != -1)
+          {
+            release_mouse();
+      
+            if (!has_mouse_over())
+              {
+                CL_Point screen(event.mouse_pos.x + get_screen_rect().left,
+                                event.mouse_pos.y + get_screen_rect().top);
+
+                CL_Point target(screen.x - EditorMapComponent::current()->get_screen_rect().left,
+                                screen.y - EditorMapComponent::current()->get_screen_rect().top);
+      
+                // FIXME: Move this to the scripting layer
+                //ObjectAddCommand command(ObjectLayer::current());
+
+                //ObjMapObject obj = brushes[drag_obj].to_sprite_object
+                //(EditorMapComponent::current()->screen2world(target)).to_object();
+
+                //command.add_object(obj);
+                //Workspace::current().get_map().execute(command.to_command());
+                
+                //std::cout << "C++: Calling on_drop" << std::endl;
+                on_drop(brushes[drag_obj], target);
+                //std::cout << "C++: Calling on_drop: done" << std::endl;
+              }
+            drag_obj = -1;
+          }
+      }
+      break;
+
+    case CL_MOUSE_MIDDLE:
+      scrolling = false;
+      release_mouse();
+      break;
+
+    default:
+      break;
+    }
+}
+
+void
+ObjectSelector::mouse_down(const CL_InputEvent& event)
+{
+  switch(event.id)
+    {
+    case CL_MOUSE_LEFT:
+      {
+        if (mouse_over_tile != -1)
+          {
+            drag_obj = mouse_over_tile;
+            capture_mouse();
+          }
+      }
+      break;
+      
+    case CL_MOUSE_MIDDLE:
+      scrolling = true;
+      click_pos = event.mouse_pos;
+      old_offset = offset;
+      capture_mouse();
+      break;
+      
+    case CL_MOUSE_WHEEL_UP:
+      offset -= static_cast<int>(obj_height*scale); 
+      break;
+
+    case CL_MOUSE_WHEEL_DOWN:
+      offset += static_cast<int>(obj_height*scale); 
+      break;
+    }
+}
+
+void
+ObjectSelector::mouse_move(const CL_InputEvent& event)
+{
+  if (scrolling)
+    {
+      offset = old_offset + (click_pos.y - event.mouse_pos.y);
+    }
+
+  mouse_pos = event.mouse_pos;
+
+  int x = (event.mouse_pos.x)/static_cast<int>(obj_width);
+  int y = (event.mouse_pos.y+offset)/static_cast<int>(obj_height);
+
+  mouse_over_tile = y * width + x;
+
+  if (mouse_over_tile < 0 || mouse_over_tile >= (int)brushes.size())
+    mouse_over_tile = -1;
+}
+
+void 
+ObjectSelector::draw()
+{
+  if (offset < 0)
+    offset = 0;
+
+  CL_Display::push_cliprect(get_screen_rect());
+
+  // Handle scrolling in the Component
+  CL_Display::push_modelview();
+  CL_Display::add_translate(0, -offset);
+  CL_Display::add_translate(get_screen_x(), get_screen_y());
+    
+  for(int i = 0; i < (int)brushes.size(); ++i)
+    {
+      int x = i%width;
+      int y = i/width;
+
+      CL_Rectf rect(CL_Pointf(x * obj_width, y * obj_height),
+                    CL_Sizef(obj_width, obj_height));
+
+      CL_Sprite sprite = brushes[i].get_sprite();
+      sprite.set_alignment(origin_center, 0, 0);
+      sprite.set_scale(std::min(1.0f, (float)obj_width/(float)sprite.get_width()),
+                       std::min(1.0f, (float)obj_height/(float)sprite.get_height()));
+        
+      sprite.draw(x * obj_width + obj_width/2, 
+                  y * obj_height + obj_height/2);
+        
+      //CL_Display::draw_rect(rect, CL_Color(0,0,0,128));
+        
+      if (mouse_over_tile == i && has_mouse_over())
+        {
+          CL_Display::fill_rect(rect, CL_Color(0,0,255, 20));
+        }
+    }
+
+  CL_Display::pop_modelview();
+  CL_Display::pop_cliprect();
+ 
+  // Draw drag sprite
+  if (drag_obj != -1)
+    {
+      CL_Display::set_cliprect(CL_Rect(CL_Point(0, 0), 
+                                       CL_Size(CL_Display::get_width(),
+                                               CL_Display::get_height())));
+
+      CL_Sprite sprite = brushes[drag_obj].get_sprite();
+      sprite.set_alpha(0.5f);
+      sprite.draw(mouse_pos.x + get_screen_x(), mouse_pos.y + get_screen_y());
+    }
+}
+
+void
+ObjectSelector::add_brush(const ObjectBrush& brush)
+{
+  brushes.push_back(brush);
+}
+
+CL_Signal_v2<ObjectBrush, CL_Point>&
+ObjectSelector::sig_drop()
+{
+  return on_drop;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_selector.cxx
===================================================================
--- trunk/flexlay/lib/object_selector.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_selector.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,215 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <ClanLib/Core/core_iostream.h>
-#include <ClanLib/display.h>
-#include "editor_map.hxx"
-#include "editor_map_component.hxx"
-#include "object_selector.hxx"
-#include "object_add_command.hxx"
-
-ObjectSelector::ObjectSelector(const CL_Rect& rect, 
-                               int obj_w, int obj_h,
-                               CL_Component* parent)
-  : CL_Component(rect, parent),
-    width(rect.get_width()/obj_w), height(rect.get_height()/obj_h),
-    obj_width(obj_w), obj_height(obj_h)
-{
-  index = 0;
-
-  slots.push_back(sig_paint().connect(this, &ObjectSelector::draw));
-  slots.push_back(sig_mouse_move().connect(this, &ObjectSelector::mouse_move));
-  slots.push_back(sig_mouse_down().connect(this, &ObjectSelector::mouse_down));
-  slots.push_back(sig_mouse_up().connect(this, &ObjectSelector::mouse_up));
- 
-  mouse_over_tile = -1;
-  scrolling = false;
-  offset = 0;
-  scale = 1.0f;
-  drag_obj = -1;
-}
-
-ObjectSelector::~ObjectSelector()
-{
-}
-
-void
-ObjectSelector::mouse_up(const CL_InputEvent& event)
-{
-  switch(event.id)
-    {
-    case CL_MOUSE_LEFT:
-      {
-        if (drag_obj != -1)
-          {
-            release_mouse();
-      
-            if (!has_mouse_over())
-              {
-                CL_Point screen(event.mouse_pos.x + get_screen_rect().left,
-                                event.mouse_pos.y + get_screen_rect().top);
-
-                CL_Point target(screen.x - EditorMapComponent::current()->get_screen_rect().left,
-                                screen.y - EditorMapComponent::current()->get_screen_rect().top);
-      
-                // FIXME: Move this to the scripting layer
-                //ObjectAddCommand command(ObjectLayer::current());
-
-                //ObjMapObject obj = brushes[drag_obj].to_sprite_object
-                //(EditorMapComponent::current()->screen2world(target)).to_object();
-
-                //command.add_object(obj);
-                //Workspace::current().get_map().execute(command.to_command());
-                
-                //std::cout << "C++: Calling on_drop" << std::endl;
-                on_drop(brushes[drag_obj], target);
-                //std::cout << "C++: Calling on_drop: done" << std::endl;
-              }
-            drag_obj = -1;
-          }
-      }
-      break;
-
-    case CL_MOUSE_MIDDLE:
-      scrolling = false;
-      release_mouse();
-      break;
-
-    default:
-      break;
-    }
-}
-
-void
-ObjectSelector::mouse_down(const CL_InputEvent& event)
-{
-  switch(event.id)
-    {
-    case CL_MOUSE_LEFT:
-      {
-        if (mouse_over_tile != -1)
-          {
-            drag_obj = mouse_over_tile;
-            capture_mouse();
-          }
-      }
-      break;
-      
-    case CL_MOUSE_MIDDLE:
-      scrolling = true;
-      click_pos = event.mouse_pos;
-      old_offset = offset;
-      capture_mouse();
-      break;
-      
-    case CL_MOUSE_WHEEL_UP:
-      offset -= static_cast<int>(obj_height*scale); 
-      break;
-
-    case CL_MOUSE_WHEEL_DOWN:
-      offset += static_cast<int>(obj_height*scale); 
-      break;
-    }
-}
-
-void
-ObjectSelector::mouse_move(const CL_InputEvent& event)
-{
-  if (scrolling)
-    {
-      offset = old_offset + (click_pos.y - event.mouse_pos.y);
-    }
-
-  mouse_pos = event.mouse_pos;
-
-  int x = (event.mouse_pos.x)/static_cast<int>(obj_width);
-  int y = (event.mouse_pos.y+offset)/static_cast<int>(obj_height);
-
-  mouse_over_tile = y * width + x;
-
-  if (mouse_over_tile < 0 || mouse_over_tile >= (int)brushes.size())
-    mouse_over_tile = -1;
-}
-
-void 
-ObjectSelector::draw()
-{
-  if (offset < 0)
-    offset = 0;
-
-  CL_Display::push_cliprect(get_screen_rect());
-
-  // Handle scrolling in the Component
-  CL_Display::push_modelview();
-  CL_Display::add_translate(0, -offset);
-  CL_Display::add_translate(get_screen_x(), get_screen_y());
-    
-  for(int i = 0; i < (int)brushes.size(); ++i)
-    {
-      int x = i%width;
-      int y = i/width;
-
-      CL_Rectf rect(CL_Pointf(x * obj_width, y * obj_height),
-                    CL_Sizef(obj_width, obj_height));
-
-      CL_Sprite sprite = brushes[i].get_sprite();
-      sprite.set_alignment(origin_center, 0, 0);
-      sprite.set_scale(std::min(1.0f, (float)obj_width/(float)sprite.get_width()),
-                       std::min(1.0f, (float)obj_height/(float)sprite.get_height()));
-        
-      sprite.draw(x * obj_width + obj_width/2, 
-                  y * obj_height + obj_height/2);
-        
-      //CL_Display::draw_rect(rect, CL_Color(0,0,0,128));
-        
-      if (mouse_over_tile == i && has_mouse_over())
-        {
-          CL_Display::fill_rect(rect, CL_Color(0,0,255, 20));
-        }
-    }
-
-  CL_Display::pop_modelview();
-  CL_Display::pop_cliprect();
- 
-  // Draw drag sprite
-  if (drag_obj != -1)
-    {
-      CL_Display::set_cliprect(CL_Rect(CL_Point(0, 0), 
-                                       CL_Size(CL_Display::get_width(),
-                                               CL_Display::get_height())));
-
-      CL_Sprite sprite = brushes[drag_obj].get_sprite();
-      sprite.set_alpha(0.5f);
-      sprite.draw(mouse_pos.x + get_screen_x(), mouse_pos.y + get_screen_y());
-    }
-}
-
-void
-ObjectSelector::add_brush(const ObjectBrush& brush)
-{
-  brushes.push_back(brush);
-}
-
-CL_Signal_v2<ObjectBrush, CL_Point>&
-ObjectSelector::sig_drop()
-{
-  return on_drop;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/object_selector.hpp (from rev 712, trunk/flexlay/lib/object_selector.hxx)
===================================================================
--- trunk/flexlay/lib/object_selector.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_selector.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,71 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_OBJECTSELECTOR_HXX
+#define HEADER_OBJECTSELECTOR_HXX
+
+#include <ClanLib/GUI/component.h>
+#include <ClanLib/GUI/component.h>
+#include "object_brush.hpp"
+
+/** */
+class ObjectSelector : public CL_Component
+{
+private:
+  std::vector<CL_Slot> slots;
+
+  int width;
+  int height;
+
+  int obj_width;
+  int obj_height;
+
+  int index;
+  
+  int offset;
+  int old_offset;
+  int mouse_over_tile;
+  bool scrolling;
+  CL_Point click_pos;
+  CL_Point mouse_pos;
+  float scale;
+
+  std::vector<ObjectBrush> brushes;
+  int drag_obj;
+
+  CL_Signal_v2<ObjectBrush, CL_Point> on_drop;
+
+protected:
+  virtual ~ObjectSelector();
+
+public:
+  ObjectSelector(const CL_Rect& rect, int obj_w, int obj_h, CL_Component* parent);
+
+  void draw();
+  void add_brush(const ObjectBrush& brush);
+
+  CL_Signal_v2<ObjectBrush, CL_Point>& sig_drop();
+private:
+  void mouse_move(const CL_InputEvent& event);
+  void mouse_down(const CL_InputEvent& event);
+  void mouse_up  (const CL_InputEvent& event); 
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_selector.hxx
===================================================================
--- trunk/flexlay/lib/object_selector.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_selector.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,71 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_OBJECTSELECTOR_HXX
-#define HEADER_OBJECTSELECTOR_HXX
-
-#include <ClanLib/GUI/component.h>
-#include <ClanLib/GUI/component.h>
-#include "object_brush.hxx"
-
-/** */
-class ObjectSelector : public CL_Component
-{
-private:
-  std::vector<CL_Slot> slots;
-
-  int width;
-  int height;
-
-  int obj_width;
-  int obj_height;
-
-  int index;
-  
-  int offset;
-  int old_offset;
-  int mouse_over_tile;
-  bool scrolling;
-  CL_Point click_pos;
-  CL_Point mouse_pos;
-  float scale;
-
-  std::vector<ObjectBrush> brushes;
-  int drag_obj;
-
-  CL_Signal_v2<ObjectBrush, CL_Point> on_drop;
-
-protected:
-  virtual ~ObjectSelector();
-
-public:
-  ObjectSelector(const CL_Rect& rect, int obj_w, int obj_h, CL_Component* parent);
-
-  void draw();
-  void add_brush(const ObjectBrush& brush);
-
-  CL_Signal_v2<ObjectBrush, CL_Point>& sig_drop();
-private:
-  void mouse_move(const CL_InputEvent& event);
-  void mouse_down(const CL_InputEvent& event);
-  void mouse_up  (const CL_InputEvent& event); 
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/object_transform_command.cpp (from rev 712, trunk/flexlay/lib/object_transform_command.cxx)
===================================================================
--- trunk/flexlay/lib/object_transform_command.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_transform_command.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,56 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "object_transform_command.hpp"
+
+class ObjectTransformCommandImpl : public CommandImpl
+{
+public:
+  typedef std::vector<ObjMapObject*> Objects;
+  Objects objects;
+
+  ObjectTransformCommandImpl() {}
+  virtual ~ObjectTransformCommandImpl() {}
+};
+
+ObjectTransformCommand::ObjectTransformCommand()
+{
+}
+
+ObjectTransformCommand::~ObjectTransformCommand()
+{
+}
+  
+void
+ObjectTransformCommand::excute()
+{
+}
+
+void
+ObjectTransformCommand::undo()
+{
+}
+
+void
+ObjectTransformCommand::redo()
+{
+
+    
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_transform_command.cxx
===================================================================
--- trunk/flexlay/lib/object_transform_command.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_transform_command.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,56 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "object_transform_command.hxx"
-
-class ObjectTransformCommandImpl : public CommandImpl
-{
-public:
-  typedef std::vector<ObjMapObject*> Objects;
-  Objects objects;
-
-  ObjectTransformCommandImpl() {}
-  virtual ~ObjectTransformCommandImpl() {}
-};
-
-ObjectTransformCommand::ObjectTransformCommand()
-{
-}
-
-ObjectTransformCommand::~ObjectTransformCommand()
-{
-}
-  
-void
-ObjectTransformCommand::excute()
-{
-}
-
-void
-ObjectTransformCommand::undo()
-{
-}
-
-void
-ObjectTransformCommand::redo()
-{
-
-    
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/object_transform_command.hpp (from rev 712, trunk/flexlay/lib/object_transform_command.hxx)
===================================================================
--- trunk/flexlay/lib/object_transform_command.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_transform_command.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,41 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_OBJECT_TRANSFORM_COMMAND_HXX
+#define HEADER_OBJECT_TRANSFORM_COMMAND_HXX
+
+#include <vector>
+#include "command.hpp"
+
+class ObjMapObject;
+
+/** */
+class ObjectTransformCommand
+{
+public:
+  ObjectTransformCommand();
+  virtual ~ObjectTransformCommand();
+  
+  void excute();
+  void undo();
+  void redo();
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/object_transform_command.hxx
===================================================================
--- trunk/flexlay/lib/object_transform_command.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/object_transform_command.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,41 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_OBJECT_TRANSFORM_COMMAND_HXX
-#define HEADER_OBJECT_TRANSFORM_COMMAND_HXX
-
-#include <vector>
-#include "command.hxx"
-
-class ObjMapObject;
-
-/** */
-class ObjectTransformCommand
-{
-public:
-  ObjectTransformCommand();
-  virtual ~ObjectTransformCommand();
-  
-  void excute();
-  void undo();
-  void redo();
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/objmap_control_point.cpp (from rev 712, trunk/flexlay/lib/objmap_control_point.cxx)
===================================================================
--- trunk/flexlay/lib/objmap_control_point.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_control_point.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,99 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "objmap_control_point.hpp"
+
+class ObjMapControlPointImpl
+{
+public:
+  CL_Sprite sprite;
+  CL_Pointf  pos;
+  MetaData  data;
+
+  void draw(CL_GraphicContext* gc);
+  CL_Rect get_bound_rect() const;
+  CL_Signal_v1<CL_Pointf> on_set_pos;
+};
+
+CL_Signal_v1<CL_Pointf>& 
+ObjMapControlPoint::sig_set_pos()
+{
+  return impl->on_set_pos;
+}
+
+ObjMapControlPoint::ObjMapControlPoint(CL_Sprite sprite_, CL_Pointf pos_, MetaData data_)
+  : impl(new ObjMapControlPointImpl)
+{
+  impl->sprite = sprite_;
+  impl->pos    = pos_;
+  impl->data   = data_;
+}
+
+void
+ObjMapControlPoint::draw(CL_GraphicContext* gc)
+{
+  impl->draw(gc);
+}
+
+void
+ObjMapControlPointImpl::draw(CL_GraphicContext* gc)
+{
+  sprite.draw(static_cast<int>(pos.x), static_cast<int>(pos.y), gc);
+}
+
+void
+ObjMapControlPoint::set_pos_raw(const CL_Pointf& p)
+{
+  impl->pos = p;
+}
+
+void
+ObjMapControlPoint::set_pos(const CL_Pointf& p)
+{
+  impl->on_set_pos(p);
+}
+
+CL_Pointf
+ObjMapControlPoint::get_pos() const
+{
+  return impl->pos;
+}
+
+CL_Rect
+ObjMapControlPoint::get_bound_rect() const
+{
+  return impl->get_bound_rect();
+}
+
+CL_Rect
+ObjMapControlPointImpl::get_bound_rect() const
+{
+  CL_Point  align = CL_Point(0, 0);
+  CL_Origin origin_e;
+
+  sprite.get_alignment(origin_e, align.x, align.y);
+
+  CL_Point origin = calc_origin(origin_e, CL_Size(sprite.get_width(),
+                                                  sprite.get_height()));
+  align.x = -align.x;
+      
+  return CL_Rect(CL_Point(pos) - origin - align,
+                 CL_Size(sprite.get_width(), sprite.get_height()));
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/objmap_control_point.cxx
===================================================================
--- trunk/flexlay/lib/objmap_control_point.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_control_point.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,99 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "objmap_control_point.hxx"
-
-class ObjMapControlPointImpl
-{
-public:
-  CL_Sprite sprite;
-  CL_Pointf  pos;
-  MetaData  data;
-
-  void draw(CL_GraphicContext* gc);
-  CL_Rect get_bound_rect() const;
-  CL_Signal_v1<CL_Pointf> on_set_pos;
-};
-
-CL_Signal_v1<CL_Pointf>& 
-ObjMapControlPoint::sig_set_pos()
-{
-  return impl->on_set_pos;
-}
-
-ObjMapControlPoint::ObjMapControlPoint(CL_Sprite sprite_, CL_Pointf pos_, MetaData data_)
-  : impl(new ObjMapControlPointImpl)
-{
-  impl->sprite = sprite_;
-  impl->pos    = pos_;
-  impl->data   = data_;
-}
-
-void
-ObjMapControlPoint::draw(CL_GraphicContext* gc)
-{
-  impl->draw(gc);
-}
-
-void
-ObjMapControlPointImpl::draw(CL_GraphicContext* gc)
-{
-  sprite.draw(static_cast<int>(pos.x), static_cast<int>(pos.y), gc);
-}
-
-void
-ObjMapControlPoint::set_pos_raw(const CL_Pointf& p)
-{
-  impl->pos = p;
-}
-
-void
-ObjMapControlPoint::set_pos(const CL_Pointf& p)
-{
-  impl->on_set_pos(p);
-}
-
-CL_Pointf
-ObjMapControlPoint::get_pos() const
-{
-  return impl->pos;
-}
-
-CL_Rect
-ObjMapControlPoint::get_bound_rect() const
-{
-  return impl->get_bound_rect();
-}
-
-CL_Rect
-ObjMapControlPointImpl::get_bound_rect() const
-{
-  CL_Point  align = CL_Point(0, 0);
-  CL_Origin origin_e;
-
-  sprite.get_alignment(origin_e, align.x, align.y);
-
-  CL_Point origin = calc_origin(origin_e, CL_Size(sprite.get_width(),
-                                                  sprite.get_height()));
-  align.x = -align.x;
-      
-  return CL_Rect(CL_Point(pos) - origin - align,
-                 CL_Size(sprite.get_width(), sprite.get_height()));
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/objmap_control_point.hpp (from rev 712, trunk/flexlay/lib/objmap_control_point.hxx)
===================================================================
--- trunk/flexlay/lib/objmap_control_point.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_control_point.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,56 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_OBJMAP_CONTROL_POINT_HXX
+#define HEADER_OBJMAP_CONTROL_POINT_HXX
+
+#include <ClanLib/Display/sprite.h>
+#include <ClanLib/Core/Math/point.h>
+#include "meta_data.hpp"
+#include "shared_ptr.hpp"
+
+class ObjMapControlPointImpl;
+
+/** An ObjMapControlPoint is used to control a property of an object,
+    such as size, rotation or scaling. ControlPoints get drawn around
+    the object in a size which is independend of the current zoom
+    level and can be draged around with the mous. */
+class ObjMapControlPoint
+{
+private:
+public:
+  ObjMapControlPoint() : impl(0) {}
+  ObjMapControlPoint(CL_Sprite sprite_, CL_Pointf pos_, MetaData data_);
+
+  CL_Pointf get_pos() const;
+  void     set_pos(const CL_Pointf& p);
+  void     set_pos_raw(const CL_Pointf& p);
+  void     draw(CL_GraphicContext* gc);
+
+  CL_Rect get_bound_rect() const;
+
+  CL_Signal_v1<CL_Pointf>& sig_set_pos();
+
+  bool is_null() const { return !impl.get(); }
+private:
+  SharedPtr<ObjMapControlPointImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/objmap_control_point.hxx
===================================================================
--- trunk/flexlay/lib/objmap_control_point.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_control_point.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,56 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_OBJMAP_CONTROL_POINT_HXX
-#define HEADER_OBJMAP_CONTROL_POINT_HXX
-
-#include <ClanLib/Display/sprite.h>
-#include <ClanLib/Core/Math/point.h>
-#include "meta_data.hxx"
-#include "shared_ptr.hxx"
-
-class ObjMapControlPointImpl;
-
-/** An ObjMapControlPoint is used to control a property of an object,
-    such as size, rotation or scaling. ControlPoints get drawn around
-    the object in a size which is independend of the current zoom
-    level and can be draged around with the mous. */
-class ObjMapControlPoint
-{
-private:
-public:
-  ObjMapControlPoint() : impl(0) {}
-  ObjMapControlPoint(CL_Sprite sprite_, CL_Pointf pos_, MetaData data_);
-
-  CL_Pointf get_pos() const;
-  void     set_pos(const CL_Pointf& p);
-  void     set_pos_raw(const CL_Pointf& p);
-  void     draw(CL_GraphicContext* gc);
-
-  CL_Rect get_bound_rect() const;
-
-  CL_Signal_v1<CL_Pointf>& sig_set_pos();
-
-  bool is_null() const { return !impl.get(); }
-private:
-  SharedPtr<ObjMapControlPointImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/objmap_object.cpp (from rev 712, trunk/flexlay/lib/objmap_object.cxx)
===================================================================
--- trunk/flexlay/lib/objmap_object.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_object.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,129 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "objmap_object_impl.hpp"
+#include "objmap_object.hpp"
+
+ObjMapObject::ObjMapObject()
+{
+}
+
+ObjMapObject::ObjMapObject(const SharedPtr<ObjMapObjectImpl>& impl_)
+  : impl(impl_)
+{
+}
+
+CL_Pointf
+ObjMapObject::get_pos() const 
+{
+  if (impl.get())
+    return impl->pos; 
+  else
+    return CL_Pointf();
+}
+
+void
+ObjMapObject::set_pos(const CL_Pointf& p) 
+{
+  if (impl.get())
+    {
+      impl->pos = p; 
+    }
+}
+
+MetaData
+ObjMapObject::get_metadata() const
+{
+  if (impl.get())
+    return impl->data; 
+  else
+    return MetaData();
+}
+
+void
+ObjMapObject::set_metadata(const MetaData& data_)
+{
+  if (impl.get())
+    impl->data = data_;
+}
+
+void
+ObjMapObject::draw(CL_GraphicContext* gc)
+{
+  if (impl.get())
+    impl->draw(gc);
+}
+
+CL_Rectf
+ObjMapObject::get_bound_rect() const
+{
+  if (impl.get())
+    return impl->get_bound_rect();
+  else
+    return CL_Rect();
+}
+
+bool
+ObjMapObject::is_null() const
+{
+  return !impl.get();
+}
+
+bool
+ObjMapObject::operator==(const ObjMapObject& obj) const
+{
+  return impl.get() == obj.impl.get();
+}
+
+bool
+ObjMapObject::operator<(const ObjMapObject& obj) const
+{
+  return impl.get() < obj.impl.get();
+}
+
+CL_Signal_v1<ObjMapObject>&
+ObjMapObject::sig_select()
+{
+  return impl->on_select;
+}
+
+CL_Signal_v1<ObjMapObject>&
+ObjMapObject::sig_deselect()
+{
+  return impl->on_deselect;
+}
+
+CL_Signal_v1<ObjMapObject>&
+ObjMapObject::sig_move()
+{
+  return impl->on_move;
+}
+
+void
+ObjMapObject::add_control_points()
+{
+  impl->add_control_points();
+}
+
+void
+ObjMapObject::update_control_points()
+{
+  impl->update_control_points();
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/objmap_object.cxx
===================================================================
--- trunk/flexlay/lib/objmap_object.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_object.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,129 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "objmap_object_impl.hxx"
-#include "objmap_object.hxx"
-
-ObjMapObject::ObjMapObject()
-{
-}
-
-ObjMapObject::ObjMapObject(const SharedPtr<ObjMapObjectImpl>& impl_)
-  : impl(impl_)
-{
-}
-
-CL_Pointf
-ObjMapObject::get_pos() const 
-{
-  if (impl.get())
-    return impl->pos; 
-  else
-    return CL_Pointf();
-}
-
-void
-ObjMapObject::set_pos(const CL_Pointf& p) 
-{
-  if (impl.get())
-    {
-      impl->pos = p; 
-    }
-}
-
-MetaData
-ObjMapObject::get_metadata() const
-{
-  if (impl.get())
-    return impl->data; 
-  else
-    return MetaData();
-}
-
-void
-ObjMapObject::set_metadata(const MetaData& data_)
-{
-  if (impl.get())
-    impl->data = data_;
-}
-
-void
-ObjMapObject::draw(CL_GraphicContext* gc)
-{
-  if (impl.get())
-    impl->draw(gc);
-}
-
-CL_Rectf
-ObjMapObject::get_bound_rect() const
-{
-  if (impl.get())
-    return impl->get_bound_rect();
-  else
-    return CL_Rect();
-}
-
-bool
-ObjMapObject::is_null() const
-{
-  return !impl.get();
-}
-
-bool
-ObjMapObject::operator==(const ObjMapObject& obj) const
-{
-  return impl.get() == obj.impl.get();
-}
-
-bool
-ObjMapObject::operator<(const ObjMapObject& obj) const
-{
-  return impl.get() < obj.impl.get();
-}
-
-CL_Signal_v1<ObjMapObject>&
-ObjMapObject::sig_select()
-{
-  return impl->on_select;
-}
-
-CL_Signal_v1<ObjMapObject>&
-ObjMapObject::sig_deselect()
-{
-  return impl->on_deselect;
-}
-
-CL_Signal_v1<ObjMapObject>&
-ObjMapObject::sig_move()
-{
-  return impl->on_move;
-}
-
-void
-ObjMapObject::add_control_points()
-{
-  impl->add_control_points();
-}
-
-void
-ObjMapObject::update_control_points()
-{
-  impl->update_control_points();
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/objmap_object.hpp (from rev 712, trunk/flexlay/lib/objmap_object.hxx)
===================================================================
--- trunk/flexlay/lib/objmap_object.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_object.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,64 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_OBJMAP_OBJECT_HXX
+#define HEADER_OBJMAP_OBJECT_HXX
+
+#include <ClanLib/signals.h>
+#include <ClanLib/Display/graphic_context.h>
+#include <ClanLib/Core/Math/point.h>
+#include <ClanLib/Core/Math/rect.h>
+#include "meta_data.hpp"
+
+class ObjMapObjectImpl;
+
+/** */
+class ObjMapObject
+{
+public:
+  ObjMapObject();
+  ObjMapObject(const SharedPtr<ObjMapObjectImpl>& impl_);
+  virtual ~ObjMapObject() {}
+
+  CL_Pointf get_pos() const;
+  void     set_pos(const CL_Pointf& p);
+
+  MetaData get_metadata() const;
+  void     set_metadata(const MetaData& data_);
+
+  CL_Signal_v1<ObjMapObject>& sig_move();
+  CL_Signal_v1<ObjMapObject>& sig_select();
+  CL_Signal_v1<ObjMapObject>& sig_deselect();
+
+  void draw(CL_GraphicContext* gc);
+  CL_Rectf get_bound_rect() const;
+
+  void add_control_points();
+  void update_control_points();
+
+  bool is_null() const;
+
+  bool operator==(const ObjMapObject& obj) const;
+  bool operator<(const ObjMapObject& obj) const;
+private:
+  SharedPtr<ObjMapObjectImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/objmap_object.hxx
===================================================================
--- trunk/flexlay/lib/objmap_object.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_object.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,64 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_OBJMAP_OBJECT_HXX
-#define HEADER_OBJMAP_OBJECT_HXX
-
-#include <ClanLib/signals.h>
-#include <ClanLib/Display/graphic_context.h>
-#include <ClanLib/Core/Math/point.h>
-#include <ClanLib/Core/Math/rect.h>
-#include "meta_data.hxx"
-
-class ObjMapObjectImpl;
-
-/** */
-class ObjMapObject
-{
-public:
-  ObjMapObject();
-  ObjMapObject(const SharedPtr<ObjMapObjectImpl>& impl_);
-  virtual ~ObjMapObject() {}
-
-  CL_Pointf get_pos() const;
-  void     set_pos(const CL_Pointf& p);
-
-  MetaData get_metadata() const;
-  void     set_metadata(const MetaData& data_);
-
-  CL_Signal_v1<ObjMapObject>& sig_move();
-  CL_Signal_v1<ObjMapObject>& sig_select();
-  CL_Signal_v1<ObjMapObject>& sig_deselect();
-
-  void draw(CL_GraphicContext* gc);
-  CL_Rectf get_bound_rect() const;
-
-  void add_control_points();
-  void update_control_points();
-
-  bool is_null() const;
-
-  bool operator==(const ObjMapObject& obj) const;
-  bool operator<(const ObjMapObject& obj) const;
-private:
-  SharedPtr<ObjMapObjectImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/objmap_object_impl.cpp (from rev 712, trunk/flexlay/lib/objmap_object_impl.cxx)
===================================================================
--- trunk/flexlay/lib/objmap_object_impl.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_object_impl.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,42 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include "objmap_object_impl.hpp"
+
+ObjMapObjectImpl::ObjMapObjectImpl()
+{
+}
+
+ObjMapObjectImpl::~ObjMapObjectImpl()
+{
+}
+
+void
+ObjMapObjectImpl::update_control_points()
+{
+  //std::cout << "Object doesn't have control points to upadate" << std::endl;
+}
+
+void
+ObjMapObjectImpl::add_control_points()
+{
+  //std::cout << "Object doesn't have control points" << std::endl;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/objmap_object_impl.cxx
===================================================================
--- trunk/flexlay/lib/objmap_object_impl.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_object_impl.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,42 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include "objmap_object_impl.hxx"
-
-ObjMapObjectImpl::ObjMapObjectImpl()
-{
-}
-
-ObjMapObjectImpl::~ObjMapObjectImpl()
-{
-}
-
-void
-ObjMapObjectImpl::update_control_points()
-{
-  //std::cout << "Object doesn't have control points to upadate" << std::endl;
-}
-
-void
-ObjMapObjectImpl::add_control_points()
-{
-  //std::cout << "Object doesn't have control points" << std::endl;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/objmap_object_impl.hpp (from rev 712, trunk/flexlay/lib/objmap_object_impl.hxx)
===================================================================
--- trunk/flexlay/lib/objmap_object_impl.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_object_impl.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,49 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_OBJMAP_OBJECT_IMPL_HXX
+#define HEADER_OBJMAP_OBJECT_IMPL_HXX
+
+#include <ClanLib/Core/Math/point.h>
+#include <ClanLib/Core/Math/rect.h>
+#include "objmap_object.hpp"
+#include "meta_data.hpp"
+
+class ObjMapObjectImpl 
+{
+public:
+  CL_Pointf  pos;
+  MetaData  data;
+
+  CL_Signal_v1<ObjMapObject> on_move;
+  CL_Signal_v1<ObjMapObject> on_select;
+  CL_Signal_v1<ObjMapObject> on_deselect;
+
+  ObjMapObjectImpl();
+  virtual ~ObjMapObjectImpl();
+
+  virtual void draw(CL_GraphicContext* gc) =0;
+  virtual CL_Rectf get_bound_rect() const  =0;
+
+  virtual void add_control_points();
+  virtual void update_control_points();
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/objmap_object_impl.hxx
===================================================================
--- trunk/flexlay/lib/objmap_object_impl.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_object_impl.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,49 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_OBJMAP_OBJECT_IMPL_HXX
-#define HEADER_OBJMAP_OBJECT_IMPL_HXX
-
-#include <ClanLib/Core/Math/point.h>
-#include <ClanLib/Core/Math/rect.h>
-#include "objmap_object.hxx"
-#include "meta_data.hxx"
-
-class ObjMapObjectImpl 
-{
-public:
-  CL_Pointf  pos;
-  MetaData  data;
-
-  CL_Signal_v1<ObjMapObject> on_move;
-  CL_Signal_v1<ObjMapObject> on_select;
-  CL_Signal_v1<ObjMapObject> on_deselect;
-
-  ObjMapObjectImpl();
-  virtual ~ObjMapObjectImpl();
-
-  virtual void draw(CL_GraphicContext* gc) =0;
-  virtual CL_Rectf get_bound_rect() const  =0;
-
-  virtual void add_control_points();
-  virtual void update_control_points();
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/objmap_path_node.cpp (from rev 712, trunk/flexlay/lib/objmap_path_node.cxx)
===================================================================
--- trunk/flexlay/lib/objmap_path_node.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_path_node.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,107 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <ClanLib/Display/display.h>
+#include "objmap_object_impl.hpp"
+#include "objmap_path_node.hpp"
+
+class ObjMapPathNodeImpl : public ObjMapObjectImpl
+{
+public:
+  ObjMapPathNodeImpl* prev;
+  ObjMapPathNodeImpl* next;
+  
+  ObjMapPathNodeImpl();
+
+  void draw(CL_GraphicContext* gc);
+  CL_Rectf get_bound_rect() const;
+};
+
+ObjMapPathNodeImpl::ObjMapPathNodeImpl()
+{
+  next = 0;
+  prev = 0;
+}
+
+void
+ObjMapPathNodeImpl::draw(CL_GraphicContext* gc)
+{
+  gc->fill_rect(CL_Rect(CL_Point(pos) - CL_Point(16,16), CL_Size(32, 32)), 
+                CL_Color(200, 255, 200));
+  if (next)
+    {
+      gc->draw_line(static_cast<int>(pos.x), static_cast<int>(pos.y),
+                    static_cast<int>((pos.x + next->pos.x)/2),
+                    static_cast<int>((pos.y+next->pos.y)/2),
+                    CL_Color(255, 255, 0));
+
+      gc->draw_line(static_cast<int>((pos.x + next->pos.x)/2), 
+                    static_cast<int>((pos.y+next->pos.y)/2),
+                    static_cast<int>(next->pos.x),
+                    static_cast<int>(next->pos.y), 
+                    CL_Color(255, 0, 0));
+    }
+}
+
+CL_Rectf
+ObjMapPathNodeImpl::get_bound_rect() const
+{
+  return CL_Rectf(pos - CL_Pointf(16,16), CL_Sizef(32, 32));
+}
+
+ObjMapPathNode::ObjMapPathNode(const CL_Pointf& pos_, 
+                               const MetaData& data_)
+  : impl(new ObjMapPathNodeImpl())
+{  
+  impl->pos  = pos_;
+  impl->data = data_;
+}
+
+void
+ObjMapPathNode::disconnect()
+{
+  impl->next = 0;
+  impl->prev = 0;
+
+  impl->next->prev = 0;
+  impl->prev->next = 0;
+}
+
+void
+ObjMapPathNode::connect(ObjMapPathNode next)
+{
+  if (next.impl->next != impl.get()) // avoid circular link between two nodes
+    {
+      if (next.impl->prev) // ensure that each node links exactly to one prev and one next node 
+        {
+          next.impl->prev->next = 0;
+          next.impl->prev = 0;
+        }
+
+      impl->next = next.impl.get();
+      next.impl->prev = impl.get();
+    }
+}
+
+ObjMapObject
+ObjMapPathNode::to_object()
+{
+  return ObjMapObject(impl);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/objmap_path_node.cxx
===================================================================
--- trunk/flexlay/lib/objmap_path_node.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_path_node.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,107 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <ClanLib/Display/display.h>
-#include "objmap_object_impl.hxx"
-#include "objmap_path_node.hxx"
-
-class ObjMapPathNodeImpl : public ObjMapObjectImpl
-{
-public:
-  ObjMapPathNodeImpl* prev;
-  ObjMapPathNodeImpl* next;
-  
-  ObjMapPathNodeImpl();
-
-  void draw(CL_GraphicContext* gc);
-  CL_Rectf get_bound_rect() const;
-};
-
-ObjMapPathNodeImpl::ObjMapPathNodeImpl()
-{
-  next = 0;
-  prev = 0;
-}
-
-void
-ObjMapPathNodeImpl::draw(CL_GraphicContext* gc)
-{
-  gc->fill_rect(CL_Rect(CL_Point(pos) - CL_Point(16,16), CL_Size(32, 32)), 
-                CL_Color(200, 255, 200));
-  if (next)
-    {
-      gc->draw_line(static_cast<int>(pos.x), static_cast<int>(pos.y),
-                    static_cast<int>((pos.x + next->pos.x)/2),
-                    static_cast<int>((pos.y+next->pos.y)/2),
-                    CL_Color(255, 255, 0));
-
-      gc->draw_line(static_cast<int>((pos.x + next->pos.x)/2), 
-                    static_cast<int>((pos.y+next->pos.y)/2),
-                    static_cast<int>(next->pos.x),
-                    static_cast<int>(next->pos.y), 
-                    CL_Color(255, 0, 0));
-    }
-}
-
-CL_Rectf
-ObjMapPathNodeImpl::get_bound_rect() const
-{
-  return CL_Rectf(pos - CL_Pointf(16,16), CL_Sizef(32, 32));
-}
-
-ObjMapPathNode::ObjMapPathNode(const CL_Pointf& pos_, 
-                               const MetaData& data_)
-  : impl(new ObjMapPathNodeImpl())
-{  
-  impl->pos  = pos_;
-  impl->data = data_;
-}
-
-void
-ObjMapPathNode::disconnect()
-{
-  impl->next = 0;
-  impl->prev = 0;
-
-  impl->next->prev = 0;
-  impl->prev->next = 0;
-}
-
-void
-ObjMapPathNode::connect(ObjMapPathNode next)
-{
-  if (next.impl->next != impl.get()) // avoid circular link between two nodes
-    {
-      if (next.impl->prev) // ensure that each node links exactly to one prev and one next node 
-        {
-          next.impl->prev->next = 0;
-          next.impl->prev = 0;
-        }
-
-      impl->next = next.impl.get();
-      next.impl->prev = impl.get();
-    }
-}
-
-ObjMapObject
-ObjMapPathNode::to_object()
-{
-  return ObjMapObject(impl);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/objmap_path_node.hpp (from rev 712, trunk/flexlay/lib/objmap_path_node.hxx)
===================================================================
--- trunk/flexlay/lib/objmap_path_node.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_path_node.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,43 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_OBJMAP_PATH_NODE_HXX
+#define HEADER_OBJMAP_PATH_NODE_HXX
+
+#include "objmap_object.hpp"
+
+class ObjMapPathNodeImpl;
+
+/** */
+class ObjMapPathNode
+{
+public:
+  ObjMapPathNode(const CL_Pointf& pos_, 
+                 const MetaData& data_);
+  
+  void connect(ObjMapPathNode next);
+  void disconnect();
+
+  ObjMapObject to_object();
+private:
+  SharedPtr<ObjMapPathNodeImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/objmap_path_node.hxx
===================================================================
--- trunk/flexlay/lib/objmap_path_node.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_path_node.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,43 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_OBJMAP_PATH_NODE_HXX
-#define HEADER_OBJMAP_PATH_NODE_HXX
-
-#include "objmap_object.hxx"
-
-class ObjMapPathNodeImpl;
-
-/** */
-class ObjMapPathNode
-{
-public:
-  ObjMapPathNode(const CL_Pointf& pos_, 
-                 const MetaData& data_);
-  
-  void connect(ObjMapPathNode next);
-  void disconnect();
-
-  ObjMapObject to_object();
-private:
-  SharedPtr<ObjMapPathNodeImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/objmap_rect_object.cpp (from rev 712, trunk/flexlay/lib/objmap_rect_object.cxx)
===================================================================
--- trunk/flexlay/lib/objmap_rect_object.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_rect_object.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,250 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include <ClanLib/Core/core_iostream.h>
+#include <ClanLib/Display/display.h>
+#include <ClanLib/Display/sprite.h>
+#include "object_layer.hpp"
+#include "objmap_control_point.hpp"
+#include "objmap_rect_object.hpp"
+#include "flexlay.hpp"
+
+class ObjMapRectObjectImpl : public ObjMapObjectImpl
+{
+public:
+  std::vector<CL_Slot> slots;
+  CL_Sizef size;
+  CL_Color color;
+
+  ObjMapControlPoint cp_top_left;
+  ObjMapControlPoint cp_top_right;
+  ObjMapControlPoint cp_bottom_left;
+  ObjMapControlPoint cp_bottom_right;
+  ObjMapControlPoint cp_top_middle;
+  ObjMapControlPoint cp_bottom_middle;  
+  ObjMapControlPoint cp_middle_left;
+  ObjMapControlPoint cp_middle_right;  
+
+  void set_rect(CL_Rect rect) {
+    pos  = CL_Pointf(rect.left, rect.top);
+    size = CL_Sizef(rect.get_width(), rect.get_height());
+  }
+
+  void cp_top_left_move(CL_Pointf pos_) {
+    size.width  += pos.x - pos_.x;
+    size.height += pos.y - pos_.y;
+    pos = pos_;
+
+    normalize_rect();
+    update_control_points();
+  }
+
+  void cp_top_right_move(CL_Pointf pos_) {
+    size.width  += pos_.x - (pos.x + size.width);
+    size.height += pos.y - pos_.y;
+    
+    pos.y = pos_.y;
+
+    normalize_rect();
+    update_control_points();
+  }
+
+  void cp_bottom_left_move(CL_Pointf pos_) {
+    size.width  += pos.x - pos_.x;
+    size.height += pos_.y - (pos.y + size.height);
+    pos.x = pos_.x;
+
+    normalize_rect();
+    update_control_points();
+  }
+  void cp_bottom_right_move(CL_Pointf pos_) {
+    size.width  += pos_.x - (pos.x + size.width);
+    size.height += pos_.y - (pos.y + size.height);
+
+    normalize_rect();
+    update_control_points();
+  }
+
+  void cp_top_middle_move(CL_Pointf pos_) {
+    size.height += pos.y - pos_.y;  
+    pos.y = pos_.y;
+
+    normalize_rect();
+    update_control_points();
+  }
+  void cp_bottom_middle_move(CL_Pointf pos_) {
+    size.height += pos_.y - (pos.y + size.height);
+
+    normalize_rect();
+    update_control_points();
+  }
+  void cp_middle_left_move(CL_Pointf pos_) {
+    size.width  += pos.x - pos_.x;
+    pos.x = pos_.x;
+
+    normalize_rect();
+    update_control_points();
+  }
+  void cp_middle_right_move(CL_Pointf pos_) {
+    size.width  += pos_.x - (pos.x + size.width);
+
+    normalize_rect();
+    update_control_points();
+  }
+
+  void normalize_rect() {
+    if (size.width < 0) {
+      pos.x     += size.width;
+      size.width = -size.width;
+    }
+
+    if (size.height < 0) {
+      pos.y      += size.height;
+      size.height = -size.height;
+    }
+  }
+
+  void draw(CL_GraphicContext* gc);
+  CL_Rectf get_bound_rect() const;
+  void add_control_points();
+  void update_control_points();
+};
+
+CL_Rectf
+ObjMapRectObject::get_rect() const
+{
+  return impl->get_bound_rect();
+}
+
+void
+ObjMapRectObject::set_color(const CL_Color& color)
+{
+  impl->color = color;
+}
+
+void
+ObjMapRectObject::set_rect(const CL_Rect& rect)
+{
+  impl->pos  = CL_Pointf(rect.left, rect.top);
+  impl->size = CL_Sizef(rect.get_width(), rect.get_height());
+}
+
+void
+ObjMapRectObjectImpl::update_control_points()
+{
+  cp_top_left.set_pos_raw(pos);
+  cp_top_right.set_pos_raw(pos + CL_Pointf(size.width, 0));
+  cp_bottom_left.set_pos_raw(pos + CL_Pointf(0, size.height));
+  cp_bottom_right.set_pos_raw(pos + CL_Pointf(size.width, size.height));
+  cp_top_middle.set_pos_raw(pos + CL_Pointf(size.width/2, 0));
+  cp_bottom_middle.set_pos_raw(pos + CL_Pointf(size.width/2, size.height));
+  cp_middle_left.set_pos_raw(pos + CL_Pointf(0, size.height/2));
+  cp_middle_right.set_pos_raw(pos + CL_Pointf(size.width, size.height/2));
+}
+
+ObjMapRectObject::ObjMapRectObject(const CL_Rect&  rect_,
+                                   const CL_Color& color_,
+                                   const MetaData& data_)  
+  : impl(new ObjMapRectObjectImpl)
+{
+  impl->pos   = CL_Pointf(rect_.left, rect_.top);
+  impl->size  = CL_Sizef(rect_.get_width(), rect_.get_height());
+  impl->color = color_;
+  impl->data  = data_;
+
+  impl->cp_top_left = ObjMapControlPoint(CL_Sprite("resize1", &(Flexlay::current()->resources)), 
+                                         CL_Pointf(),
+                                         MetaData());
+  
+  impl->cp_bottom_right = ObjMapControlPoint(CL_Sprite("resize1", &(Flexlay::current()->resources)), 
+                                             CL_Pointf(),
+                                             MetaData());
+ 
+  impl->cp_top_right = ObjMapControlPoint(CL_Sprite("resize2", &(Flexlay::current()->resources)), 
+                                             CL_Pointf(),
+                                          MetaData());
+  
+  impl->cp_bottom_left = ObjMapControlPoint(CL_Sprite("resize2", &(Flexlay::current()->resources)), 
+                                                   CL_Pointf(),
+                                                   MetaData());
+  
+  impl->cp_middle_left = ObjMapControlPoint(CL_Sprite("resize_horz", &(Flexlay::current()->resources)), 
+                                            CL_Pointf(),
+                                            MetaData());
+  impl->cp_middle_right  = ObjMapControlPoint(CL_Sprite("resize_horz", &(Flexlay::current()->resources)), 
+                                              CL_Pointf(),
+                                              MetaData());
+  impl->cp_top_middle = ObjMapControlPoint(CL_Sprite("resize_vert", &(Flexlay::current()->resources)), 
+                                           CL_Pointf(),
+                                           MetaData());
+  
+  impl->cp_bottom_middle = ObjMapControlPoint(CL_Sprite("resize_vert", &(Flexlay::current()->resources)), 
+                                              CL_Pointf(),
+                                              MetaData());
+
+
+  impl->slots.push_back(impl->cp_top_right.sig_set_pos().connect(impl.get(), &ObjMapRectObjectImpl::cp_top_right_move));
+  impl->slots.push_back(impl->cp_bottom_right.sig_set_pos().connect(impl.get(), &ObjMapRectObjectImpl::cp_bottom_right_move));
+
+  impl->slots.push_back(impl->cp_top_left.sig_set_pos().connect(impl.get(), &ObjMapRectObjectImpl::cp_top_left_move));
+  impl->slots.push_back(impl->cp_bottom_left.sig_set_pos().connect(impl.get(), &ObjMapRectObjectImpl::cp_bottom_left_move));
+
+  impl->slots.push_back(impl->cp_middle_left.sig_set_pos().connect(impl.get(), &ObjMapRectObjectImpl::cp_middle_left_move));
+  impl->slots.push_back(impl->cp_middle_right.sig_set_pos().connect(impl.get(), &ObjMapRectObjectImpl::cp_middle_right_move));
+
+  impl->slots.push_back(impl->cp_top_middle.sig_set_pos().connect(impl.get(), &ObjMapRectObjectImpl::cp_top_middle_move));
+  impl->slots.push_back(impl->cp_bottom_middle.sig_set_pos().connect(impl.get(), &ObjMapRectObjectImpl::cp_bottom_middle_move));
+}
+
+void
+ObjMapRectObjectImpl::draw(CL_GraphicContext* gc)
+{
+  gc->fill_rect(get_bound_rect(), color);
+}
+
+CL_Rectf
+ObjMapRectObjectImpl::get_bound_rect() const
+{
+  return CL_Rectf(pos, size);
+}
+
+ObjMapObject
+ObjMapRectObject::to_object()
+{
+  return ObjMapObject(SharedPtr<ObjMapObjectImpl>(impl));
+}
+
+void
+ObjMapRectObjectImpl::add_control_points()
+{
+  update_control_points();
+  //std::cout << "Adding control poinst..." << std::endl;
+  ObjectLayer objmap = ObjectLayer::current();
+
+  objmap.add_control_point(cp_top_left);
+  objmap.add_control_point(cp_top_right);
+  objmap.add_control_point(cp_bottom_left);
+  objmap.add_control_point(cp_bottom_right);
+  objmap.add_control_point(cp_top_middle);
+  objmap.add_control_point(cp_bottom_middle);
+  objmap.add_control_point(cp_middle_left);
+  objmap.add_control_point(cp_middle_right);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/objmap_rect_object.cxx
===================================================================
--- trunk/flexlay/lib/objmap_rect_object.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_rect_object.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,250 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <ClanLib/Core/core_iostream.h>
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/sprite.h>
-#include "object_layer.hxx"
-#include "objmap_control_point.hxx"
-#include "objmap_rect_object.hxx"
-#include "flexlay.hxx"
-
-class ObjMapRectObjectImpl : public ObjMapObjectImpl
-{
-public:
-  std::vector<CL_Slot> slots;
-  CL_Sizef size;
-  CL_Color color;
-
-  ObjMapControlPoint cp_top_left;
-  ObjMapControlPoint cp_top_right;
-  ObjMapControlPoint cp_bottom_left;
-  ObjMapControlPoint cp_bottom_right;
-  ObjMapControlPoint cp_top_middle;
-  ObjMapControlPoint cp_bottom_middle;  
-  ObjMapControlPoint cp_middle_left;
-  ObjMapControlPoint cp_middle_right;  
-
-  void set_rect(CL_Rect rect) {
-    pos  = CL_Pointf(rect.left, rect.top);
-    size = CL_Sizef(rect.get_width(), rect.get_height());
-  }
-
-  void cp_top_left_move(CL_Pointf pos_) {
-    size.width  += pos.x - pos_.x;
-    size.height += pos.y - pos_.y;
-    pos = pos_;
-
-    normalize_rect();
-    update_control_points();
-  }
-
-  void cp_top_right_move(CL_Pointf pos_) {
-    size.width  += pos_.x - (pos.x + size.width);
-    size.height += pos.y - pos_.y;
-    
-    pos.y = pos_.y;
-
-    normalize_rect();
-    update_control_points();
-  }
-
-  void cp_bottom_left_move(CL_Pointf pos_) {
-    size.width  += pos.x - pos_.x;
-    size.height += pos_.y - (pos.y + size.height);
-    pos.x = pos_.x;
-
-    normalize_rect();
-    update_control_points();
-  }
-  void cp_bottom_right_move(CL_Pointf pos_) {
-    size.width  += pos_.x - (pos.x + size.width);
-    size.height += pos_.y - (pos.y + size.height);
-
-    normalize_rect();
-    update_control_points();
-  }
-
-  void cp_top_middle_move(CL_Pointf pos_) {
-    size.height += pos.y - pos_.y;  
-    pos.y = pos_.y;
-
-    normalize_rect();
-    update_control_points();
-  }
-  void cp_bottom_middle_move(CL_Pointf pos_) {
-    size.height += pos_.y - (pos.y + size.height);
-
-    normalize_rect();
-    update_control_points();
-  }
-  void cp_middle_left_move(CL_Pointf pos_) {
-    size.width  += pos.x - pos_.x;
-    pos.x = pos_.x;
-
-    normalize_rect();
-    update_control_points();
-  }
-  void cp_middle_right_move(CL_Pointf pos_) {
-    size.width  += pos_.x - (pos.x + size.width);
-
-    normalize_rect();
-    update_control_points();
-  }
-
-  void normalize_rect() {
-    if (size.width < 0) {
-      pos.x     += size.width;
-      size.width = -size.width;
-    }
-
-    if (size.height < 0) {
-      pos.y      += size.height;
-      size.height = -size.height;
-    }
-  }
-
-  void draw(CL_GraphicContext* gc);
-  CL_Rectf get_bound_rect() const;
-  void add_control_points();
-  void update_control_points();
-};
-
-CL_Rectf
-ObjMapRectObject::get_rect() const
-{
-  return impl->get_bound_rect();
-}
-
-void
-ObjMapRectObject::set_color(const CL_Color& color)
-{
-  impl->color = color;
-}
-
-void
-ObjMapRectObject::set_rect(const CL_Rect& rect)
-{
-  impl->pos  = CL_Pointf(rect.left, rect.top);
-  impl->size = CL_Sizef(rect.get_width(), rect.get_height());
-}
-
-void
-ObjMapRectObjectImpl::update_control_points()
-{
-  cp_top_left.set_pos_raw(pos);
-  cp_top_right.set_pos_raw(pos + CL_Pointf(size.width, 0));
-  cp_bottom_left.set_pos_raw(pos + CL_Pointf(0, size.height));
-  cp_bottom_right.set_pos_raw(pos + CL_Pointf(size.width, size.height));
-  cp_top_middle.set_pos_raw(pos + CL_Pointf(size.width/2, 0));
-  cp_bottom_middle.set_pos_raw(pos + CL_Pointf(size.width/2, size.height));
-  cp_middle_left.set_pos_raw(pos + CL_Pointf(0, size.height/2));
-  cp_middle_right.set_pos_raw(pos + CL_Pointf(size.width, size.height/2));
-}
-
-ObjMapRectObject::ObjMapRectObject(const CL_Rect&  rect_,
-                                   const CL_Color& color_,
-                                   const MetaData& data_)  
-  : impl(new ObjMapRectObjectImpl)
-{
-  impl->pos   = CL_Pointf(rect_.left, rect_.top);
-  impl->size  = CL_Sizef(rect_.get_width(), rect_.get_height());
-  impl->color = color_;
-  impl->data  = data_;
-
-  impl->cp_top_left = ObjMapControlPoint(CL_Sprite("resize1", &(Flexlay::current()->resources)), 
-                                         CL_Pointf(),
-                                         MetaData());
-  
-  impl->cp_bottom_right = ObjMapControlPoint(CL_Sprite("resize1", &(Flexlay::current()->resources)), 
-                                             CL_Pointf(),
-                                             MetaData());
- 
-  impl->cp_top_right = ObjMapControlPoint(CL_Sprite("resize2", &(Flexlay::current()->resources)), 
-                                             CL_Pointf(),
-                                          MetaData());
-  
-  impl->cp_bottom_left = ObjMapControlPoint(CL_Sprite("resize2", &(Flexlay::current()->resources)), 
-                                                   CL_Pointf(),
-                                                   MetaData());
-  
-  impl->cp_middle_left = ObjMapControlPoint(CL_Sprite("resize_horz", &(Flexlay::current()->resources)), 
-                                            CL_Pointf(),
-                                            MetaData());
-  impl->cp_middle_right  = ObjMapControlPoint(CL_Sprite("resize_horz", &(Flexlay::current()->resources)), 
-                                              CL_Pointf(),
-                                              MetaData());
-  impl->cp_top_middle = ObjMapControlPoint(CL_Sprite("resize_vert", &(Flexlay::current()->resources)), 
-                                           CL_Pointf(),
-                                           MetaData());
-  
-  impl->cp_bottom_middle = ObjMapControlPoint(CL_Sprite("resize_vert", &(Flexlay::current()->resources)), 
-                                              CL_Pointf(),
-                                              MetaData());
-
-
-  impl->slots.push_back(impl->cp_top_right.sig_set_pos().connect(impl.get(), &ObjMapRectObjectImpl::cp_top_right_move));
-  impl->slots.push_back(impl->cp_bottom_right.sig_set_pos().connect(impl.get(), &ObjMapRectObjectImpl::cp_bottom_right_move));
-
-  impl->slots.push_back(impl->cp_top_left.sig_set_pos().connect(impl.get(), &ObjMapRectObjectImpl::cp_top_left_move));
-  impl->slots.push_back(impl->cp_bottom_left.sig_set_pos().connect(impl.get(), &ObjMapRectObjectImpl::cp_bottom_left_move));
-
-  impl->slots.push_back(impl->cp_middle_left.sig_set_pos().connect(impl.get(), &ObjMapRectObjectImpl::cp_middle_left_move));
-  impl->slots.push_back(impl->cp_middle_right.sig_set_pos().connect(impl.get(), &ObjMapRectObjectImpl::cp_middle_right_move));
-
-  impl->slots.push_back(impl->cp_top_middle.sig_set_pos().connect(impl.get(), &ObjMapRectObjectImpl::cp_top_middle_move));
-  impl->slots.push_back(impl->cp_bottom_middle.sig_set_pos().connect(impl.get(), &ObjMapRectObjectImpl::cp_bottom_middle_move));
-}
-
-void
-ObjMapRectObjectImpl::draw(CL_GraphicContext* gc)
-{
-  gc->fill_rect(get_bound_rect(), color);
-}
-
-CL_Rectf
-ObjMapRectObjectImpl::get_bound_rect() const
-{
-  return CL_Rectf(pos, size);
-}
-
-ObjMapObject
-ObjMapRectObject::to_object()
-{
-  return ObjMapObject(SharedPtr<ObjMapObjectImpl>(impl));
-}
-
-void
-ObjMapRectObjectImpl::add_control_points()
-{
-  update_control_points();
-  //std::cout << "Adding control poinst..." << std::endl;
-  ObjectLayer objmap = ObjectLayer::current();
-
-  objmap.add_control_point(cp_top_left);
-  objmap.add_control_point(cp_top_right);
-  objmap.add_control_point(cp_bottom_left);
-  objmap.add_control_point(cp_bottom_right);
-  objmap.add_control_point(cp_top_middle);
-  objmap.add_control_point(cp_bottom_middle);
-  objmap.add_control_point(cp_middle_left);
-  objmap.add_control_point(cp_middle_right);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/objmap_rect_object.hpp (from rev 712, trunk/flexlay/lib/objmap_rect_object.hxx)
===================================================================
--- trunk/flexlay/lib/objmap_rect_object.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_rect_object.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,48 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_OBJMAP_RECT_OBJECT_HXX
+#define HEADER_OBJMAP_RECT_OBJECT_HXX
+
+#include <ClanLib/Core/Math/rect.h>
+#include <ClanLib/Display/color.h>
+#include "objmap_object.hpp"
+#include "objmap_object_impl.hpp"
+
+class ObjMapRectObjectImpl;
+
+class ObjMapRectObject
+{
+public:
+  ObjMapRectObject(const CL_Rect&  rect_,
+                   const CL_Color& color_,
+                   const MetaData& data_);
+    
+  void set_color(const CL_Color& color);
+
+  void set_rect(const CL_Rect& rect);
+  CL_Rectf get_rect() const;
+
+  ObjMapObject to_object();
+private:
+  SharedPtr<ObjMapRectObjectImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/objmap_rect_object.hxx
===================================================================
--- trunk/flexlay/lib/objmap_rect_object.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_rect_object.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,48 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_OBJMAP_RECT_OBJECT_HXX
-#define HEADER_OBJMAP_RECT_OBJECT_HXX
-
-#include <ClanLib/Core/Math/rect.h>
-#include <ClanLib/Display/color.h>
-#include "objmap_object.hxx"
-#include "objmap_object_impl.hxx"
-
-class ObjMapRectObjectImpl;
-
-class ObjMapRectObject
-{
-public:
-  ObjMapRectObject(const CL_Rect&  rect_,
-                   const CL_Color& color_,
-                   const MetaData& data_);
-    
-  void set_color(const CL_Color& color);
-
-  void set_rect(const CL_Rect& rect);
-  CL_Rectf get_rect() const;
-
-  ObjMapObject to_object();
-private:
-  SharedPtr<ObjMapRectObjectImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/objmap_sprite_object.cpp (from rev 712, trunk/flexlay/lib/objmap_sprite_object.cxx)
===================================================================
--- trunk/flexlay/lib/objmap_sprite_object.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_sprite_object.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,127 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <ClanLib/Display/display.h>
+#include "objmap_object_impl.hpp"
+#include "objmap_sprite_object.hpp"
+
+class ObjMapSpriteObjectImpl : public ObjMapObjectImpl
+{
+public:
+  CL_Sprite sprite;
+
+  void draw(CL_GraphicContext* gc);
+  CL_Rectf get_bound_rect() const;
+
+  ObjMapObject*  duplicate(int handle_);
+};
+
+ObjMapSpriteObject::ObjMapSpriteObject()
+{
+}
+
+ObjMapSpriteObject::ObjMapSpriteObject(const CL_Sprite& sprite_,
+                                       const CL_Pointf& pos_, 
+                                       const MetaData& data_)
+  : impl(new ObjMapSpriteObjectImpl())
+{
+  impl->pos    = pos_;
+  impl->data   = data_;
+  impl->sprite = sprite_;
+}
+
+void
+ObjMapSpriteObjectImpl::draw(CL_GraphicContext* gc)
+{
+  sprite.draw(pos.x, pos.y, gc);
+}
+
+CL_Rectf
+ObjMapSpriteObjectImpl::get_bound_rect() const
+{
+  CL_Point  align = CL_Point(0, 0);
+  CL_Origin origin_e;
+  
+  sprite.get_alignment(origin_e, align.x, align.y);
+
+  CL_Point origin = calc_origin(origin_e, CL_Size(sprite.get_width(),
+                                                  sprite.get_height()));
+  align.x = -align.x;
+
+  // FIXME: This looks a bit hacky
+  float scale_x, scale_y;
+  sprite.get_scale(scale_x, scale_y);
+
+  if (scale_x < 0)
+    align.x += sprite.get_width();
+  
+  if (scale_y < 0)
+    align.y += sprite.get_height();
+      
+  //  if (scale_x > 1.0f && scale_y > 1.0f)
+  //    return CL_Rectf(pos - origin - align,
+  //                   CL_Sizef(sprite.get_width() * scale_x, sprite.get_height() * scale_y));
+//  else
+  return CL_Rectf(pos - origin - align,
+                  CL_Sizef(sprite.get_width(), sprite.get_height()));  
+}
+
+void
+ObjMapSpriteObject::flip_vertical()
+{
+  float scale_x, scale_y;
+
+  impl->sprite.get_scale(scale_x, scale_y);
+  impl->sprite.set_scale(scale_x, -scale_y);
+  if (scale_y < 0)
+    impl->pos.y -= impl->sprite.get_height();
+  else
+    impl->pos.y += impl->sprite.get_height();
+}
+
+void
+ObjMapSpriteObject::flip_horizontal()
+{
+  float scale_x, scale_y;
+  impl->sprite.get_scale(scale_x, scale_y);
+  impl->sprite.set_scale(-scale_x, scale_y);
+  if (scale_x < 0)
+    impl->pos.x -= impl->sprite.get_width();
+  else
+    impl->pos.x += impl->sprite.get_width();
+}
+
+void
+ObjMapSpriteObject::set_sprite(const CL_Sprite& sprite)
+{
+  impl->sprite = sprite;
+}
+
+void
+ObjMapSpriteObject::set_rotate(float angle)
+{
+  impl->sprite.set_angle(angle);
+}
+
+ObjMapObject
+ObjMapSpriteObject::to_object()
+{
+  return ObjMapObject(SharedPtr<ObjMapObjectImpl>(impl));
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/objmap_sprite_object.cxx
===================================================================
--- trunk/flexlay/lib/objmap_sprite_object.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_sprite_object.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,127 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <ClanLib/Display/display.h>
-#include "objmap_object_impl.hxx"
-#include "objmap_sprite_object.hxx"
-
-class ObjMapSpriteObjectImpl : public ObjMapObjectImpl
-{
-public:
-  CL_Sprite sprite;
-
-  void draw(CL_GraphicContext* gc);
-  CL_Rectf get_bound_rect() const;
-
-  ObjMapObject*  duplicate(int handle_);
-};
-
-ObjMapSpriteObject::ObjMapSpriteObject()
-{
-}
-
-ObjMapSpriteObject::ObjMapSpriteObject(const CL_Sprite& sprite_,
-                                       const CL_Pointf& pos_, 
-                                       const MetaData& data_)
-  : impl(new ObjMapSpriteObjectImpl())
-{
-  impl->pos    = pos_;
-  impl->data   = data_;
-  impl->sprite = sprite_;
-}
-
-void
-ObjMapSpriteObjectImpl::draw(CL_GraphicContext* gc)
-{
-  sprite.draw(pos.x, pos.y, gc);
-}
-
-CL_Rectf
-ObjMapSpriteObjectImpl::get_bound_rect() const
-{
-  CL_Point  align = CL_Point(0, 0);
-  CL_Origin origin_e;
-  
-  sprite.get_alignment(origin_e, align.x, align.y);
-
-  CL_Point origin = calc_origin(origin_e, CL_Size(sprite.get_width(),
-                                                  sprite.get_height()));
-  align.x = -align.x;
-
-  // FIXME: This looks a bit hacky
-  float scale_x, scale_y;
-  sprite.get_scale(scale_x, scale_y);
-
-  if (scale_x < 0)
-    align.x += sprite.get_width();
-  
-  if (scale_y < 0)
-    align.y += sprite.get_height();
-      
-  //  if (scale_x > 1.0f && scale_y > 1.0f)
-  //    return CL_Rectf(pos - origin - align,
-  //                   CL_Sizef(sprite.get_width() * scale_x, sprite.get_height() * scale_y));
-//  else
-  return CL_Rectf(pos - origin - align,
-                  CL_Sizef(sprite.get_width(), sprite.get_height()));  
-}
-
-void
-ObjMapSpriteObject::flip_vertical()
-{
-  float scale_x, scale_y;
-
-  impl->sprite.get_scale(scale_x, scale_y);
-  impl->sprite.set_scale(scale_x, -scale_y);
-  if (scale_y < 0)
-    impl->pos.y -= impl->sprite.get_height();
-  else
-    impl->pos.y += impl->sprite.get_height();
-}
-
-void
-ObjMapSpriteObject::flip_horizontal()
-{
-  float scale_x, scale_y;
-  impl->sprite.get_scale(scale_x, scale_y);
-  impl->sprite.set_scale(-scale_x, scale_y);
-  if (scale_x < 0)
-    impl->pos.x -= impl->sprite.get_width();
-  else
-    impl->pos.x += impl->sprite.get_width();
-}
-
-void
-ObjMapSpriteObject::set_sprite(const CL_Sprite& sprite)
-{
-  impl->sprite = sprite;
-}
-
-void
-ObjMapSpriteObject::set_rotate(float angle)
-{
-  impl->sprite.set_angle(angle);
-}
-
-ObjMapObject
-ObjMapSpriteObject::to_object()
-{
-  return ObjMapObject(SharedPtr<ObjMapObjectImpl>(impl));
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/objmap_sprite_object.hpp (from rev 712, trunk/flexlay/lib/objmap_sprite_object.hxx)
===================================================================
--- trunk/flexlay/lib/objmap_sprite_object.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_sprite_object.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,51 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_OBJMAP_SPRITE_OBJECT_HXX
+#define HEADER_OBJMAP_SPRITE_OBJECT_HXX
+
+#include <ClanLib/Display/sprite.h>
+#include <ClanLib/Core/Math/point.h>
+#include "shared_ptr.hpp"
+#include "meta_data.hpp"
+#include "objmap_object.hpp"
+
+class ObjMapSpriteObjectImpl;
+
+/** */
+class ObjMapSpriteObject
+{
+public:
+  ObjMapSpriteObject();
+  ObjMapSpriteObject(const CL_Sprite& s,
+                     const CL_Pointf& pos_, 
+                     const MetaData& data_);
+
+  void set_rotate(float angle);
+  void flip_horizontal();
+  void flip_vertical();
+  void set_sprite(const CL_Sprite& s);
+  
+  ObjMapObject to_object();
+private:
+  SharedPtr<ObjMapSpriteObjectImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/objmap_sprite_object.hxx
===================================================================
--- trunk/flexlay/lib/objmap_sprite_object.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/objmap_sprite_object.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,51 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_OBJMAP_SPRITE_OBJECT_HXX
-#define HEADER_OBJMAP_SPRITE_OBJECT_HXX
-
-#include <ClanLib/Display/sprite.h>
-#include <ClanLib/Core/Math/point.h>
-#include "shared_ptr.hxx"
-#include "meta_data.hxx"
-#include "objmap_object.hxx"
-
-class ObjMapSpriteObjectImpl;
-
-/** */
-class ObjMapSpriteObject
-{
-public:
-  ObjMapSpriteObject();
-  ObjMapSpriteObject(const CL_Sprite& s,
-                     const CL_Pointf& pos_, 
-                     const MetaData& data_);
-
-  void set_rotate(float angle);
-  void flip_horizontal();
-  void flip_vertical();
-  void set_sprite(const CL_Sprite& s);
-  
-  ObjMapObject to_object();
-private:
-  SharedPtr<ObjMapSpriteObjectImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/onion_skin_layer.cpp (from rev 712, trunk/flexlay/lib/onion_skin_layer.cxx)
===================================================================
--- trunk/flexlay/lib/onion_skin_layer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/onion_skin_layer.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,131 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include <vector>
+#include <ClanLib/Core/System/error.h>
+#include <ClanLib/Display/pixel_buffer.h>
+#include <ClanLib/Display/pixel_format.h>
+#include <ClanLib/Display/surface.h>
+#include <ClanLib/Display/canvas.h>
+#include "editor_map_component.hpp"
+#include "layer_impl.hpp"
+#include "onion_skin_layer.hpp"
+
+#define SCALE 4
+
+class OnionSkinLayerImpl : public LayerImpl
+{
+public:
+  CL_Surface  surface;
+  CL_Canvas*  canvas;
+
+  CL_Surface  surface2;
+  CL_Canvas*  canvas2;
+
+  std::vector<EditorMap> editormaps;
+  std::vector<CL_Color>  color;
+
+  void draw(EditorMapComponent* parent, CL_GraphicContext* gc) 
+  {
+    // FIXME: We need to stop onion layer to draw onto itself
+    surface.set_blend_func(blend_one, blend_one_minus_src_alpha);
+    surface.set_scale(SCALE, SCALE);
+    surface.draw(0, 0);
+  }
+
+  bool has_bounding_rect() const
+  {
+    return false;
+  }
+};
+
+OnionSkinLayer::OnionSkinLayer(Layer layer)
+  : impl(dynamic_cast<OnionSkinLayerImpl*>(layer.impl.get())) // FIXME: WONT WORK WITH REAL SMARTPTR!!!
+{
+}
+
+OnionSkinLayer::OnionSkinLayer(int width, int height)
+  : impl(new OnionSkinLayerImpl())
+{
+  impl->surface  = CL_Surface(CL_PixelBuffer(width/SCALE, height/SCALE, width*4/SCALE, CL_PixelFormat::rgba8888));
+  impl->surface2 = CL_Surface(CL_PixelBuffer(width/SCALE, height/SCALE, width*4/SCALE, CL_PixelFormat::rgba8888));
+
+  try
+    {
+      impl->canvas = new CL_Canvas(impl->surface);
+      impl->canvas->get_gc()->clear(CL_Color(0, 0, 0, 0));
+      impl->canvas->get_gc()->flush();
+      impl->canvas->sync_surface();
+
+      impl->canvas2 = new CL_Canvas(impl->surface2);
+      impl->canvas2->get_gc()->clear(CL_Color(0, 0, 0, 0));
+      impl->canvas2->get_gc()->flush();
+      impl->canvas2->sync_surface();
+    }
+  catch(CL_Error& err) 
+    {
+      std::cout << "CL_Error: " << err.message << std::endl;
+      throw err;
+    }
+}
+
+void
+OnionSkinLayer::clear()
+{
+  impl->canvas->get_gc()->clear(CL_Color(0, 0, 0, 0));
+  impl->canvas->sync_surface();
+}
+
+void
+OnionSkinLayer::add_map(EditorMap editor_map, const CL_Color& color)
+{
+  impl->editormaps.push_back(editor_map);
+  impl->color.push_back(color);
+}
+
+void
+OnionSkinLayer::update()
+{
+  impl->canvas->get_gc()->clear(CL_Color(0, 0, 0, 0));
+  for (std::vector<EditorMap>::size_type i = 0; i < impl->editormaps.size(); ++i)
+    {
+      impl->canvas2->get_gc()->clear(CL_Color(0, 0, 0, 0));
+      impl->canvas2->get_gc()->push_modelview();
+      impl->canvas2->get_gc()->add_scale(1.0f/SCALE, 1.0f/SCALE);
+
+      impl->editormaps[i].draw(EditorMapComponent::current(), impl->canvas2->get_gc());
+
+      impl->canvas2->get_gc()->pop_modelview();
+
+      impl->canvas2->sync_surface();
+
+      impl->surface2.set_color(impl->color[i]);
+      impl->surface2.draw(0, 0, impl->canvas->get_gc());
+      impl->canvas->sync_surface();
+    }
+}
+
+Layer
+OnionSkinLayer::to_layer()
+{
+  return Layer(impl);
+}
+
+/* EOF */
+

Deleted: trunk/flexlay/lib/onion_skin_layer.cxx
===================================================================
--- trunk/flexlay/lib/onion_skin_layer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/onion_skin_layer.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,131 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <vector>
-#include <ClanLib/Core/System/error.h>
-#include <ClanLib/Display/pixel_buffer.h>
-#include <ClanLib/Display/pixel_format.h>
-#include <ClanLib/Display/surface.h>
-#include <ClanLib/Display/canvas.h>
-#include "editor_map_component.hxx"
-#include "layer_impl.hxx"
-#include "onion_skin_layer.hxx"
-
-#define SCALE 4
-
-class OnionSkinLayerImpl : public LayerImpl
-{
-public:
-  CL_Surface  surface;
-  CL_Canvas*  canvas;
-
-  CL_Surface  surface2;
-  CL_Canvas*  canvas2;
-
-  std::vector<EditorMap> editormaps;
-  std::vector<CL_Color>  color;
-
-  void draw(EditorMapComponent* parent, CL_GraphicContext* gc) 
-  {
-    // FIXME: We need to stop onion layer to draw onto itself
-    surface.set_blend_func(blend_one, blend_one_minus_src_alpha);
-    surface.set_scale(SCALE, SCALE);
-    surface.draw(0, 0);
-  }
-
-  bool has_bounding_rect() const
-  {
-    return false;
-  }
-};
-
-OnionSkinLayer::OnionSkinLayer(Layer layer)
-  : impl(dynamic_cast<OnionSkinLayerImpl*>(layer.impl.get())) // FIXME: WONT WORK WITH REAL SMARTPTR!!!
-{
-}
-
-OnionSkinLayer::OnionSkinLayer(int width, int height)
-  : impl(new OnionSkinLayerImpl())
-{
-  impl->surface  = CL_Surface(CL_PixelBuffer(width/SCALE, height/SCALE, width*4/SCALE, CL_PixelFormat::rgba8888));
-  impl->surface2 = CL_Surface(CL_PixelBuffer(width/SCALE, height/SCALE, width*4/SCALE, CL_PixelFormat::rgba8888));
-
-  try
-    {
-      impl->canvas = new CL_Canvas(impl->surface);
-      impl->canvas->get_gc()->clear(CL_Color(0, 0, 0, 0));
-      impl->canvas->get_gc()->flush();
-      impl->canvas->sync_surface();
-
-      impl->canvas2 = new CL_Canvas(impl->surface2);
-      impl->canvas2->get_gc()->clear(CL_Color(0, 0, 0, 0));
-      impl->canvas2->get_gc()->flush();
-      impl->canvas2->sync_surface();
-    }
-  catch(CL_Error& err) 
-    {
-      std::cout << "CL_Error: " << err.message << std::endl;
-      throw err;
-    }
-}
-
-void
-OnionSkinLayer::clear()
-{
-  impl->canvas->get_gc()->clear(CL_Color(0, 0, 0, 0));
-  impl->canvas->sync_surface();
-}
-
-void
-OnionSkinLayer::add_map(EditorMap editor_map, const CL_Color& color)
-{
-  impl->editormaps.push_back(editor_map);
-  impl->color.push_back(color);
-}
-
-void
-OnionSkinLayer::update()
-{
-  impl->canvas->get_gc()->clear(CL_Color(0, 0, 0, 0));
-  for (std::vector<EditorMap>::size_type i = 0; i < impl->editormaps.size(); ++i)
-    {
-      impl->canvas2->get_gc()->clear(CL_Color(0, 0, 0, 0));
-      impl->canvas2->get_gc()->push_modelview();
-      impl->canvas2->get_gc()->add_scale(1.0f/SCALE, 1.0f/SCALE);
-
-      impl->editormaps[i].draw(EditorMapComponent::current(), impl->canvas2->get_gc());
-
-      impl->canvas2->get_gc()->pop_modelview();
-
-      impl->canvas2->sync_surface();
-
-      impl->surface2.set_color(impl->color[i]);
-      impl->surface2.draw(0, 0, impl->canvas->get_gc());
-      impl->canvas->sync_surface();
-    }
-}
-
-Layer
-OnionSkinLayer::to_layer()
-{
-  return Layer(impl);
-}
-
-/* EOF */
-

Copied: trunk/flexlay/lib/onion_skin_layer.hpp (from rev 712, trunk/flexlay/lib/onion_skin_layer.hxx)
===================================================================
--- trunk/flexlay/lib/onion_skin_layer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/onion_skin_layer.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,56 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_ONION_SKIN_LAYER_HXX
+#define HEADER_ONION_SKIN_LAYER_HXX
+
+#include "editor_map.hpp"
+
+class OnionSkinLayerImpl;
+
+/** The OnionSkinLayer is used to render one or multiple EditorMap
+    renderings in a transparent fashion onto another EditorMap. This
+    is usefull for animation programms and the like where one might
+    need to see the previous or next frames together with the current
+    frame. Might also be usefull for games which have shadow worlds,
+    which reassamble the normal world in a darker fashion. */
+class OnionSkinLayer
+{
+public:
+  /** FIXME: Should probally be CL_Rect instead of just
+      width/height */
+  OnionSkinLayer(int width, int height);
+  OnionSkinLayer(Layer layer);
+  
+  /** Adds an EditorMap to the OnionSkin */
+  void add_map(EditorMap editor_map, const CL_Color& color);
+
+  void clear();
+
+  /** Refreshes the content of the OnionSkin */
+  void update();
+  
+  bool is_null() const { return !impl.get(); }
+  Layer to_layer();
+private:
+  SharedPtr<OnionSkinLayerImpl> impl;  
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/onion_skin_layer.hxx
===================================================================
--- trunk/flexlay/lib/onion_skin_layer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/onion_skin_layer.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,56 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_ONION_SKIN_LAYER_HXX
-#define HEADER_ONION_SKIN_LAYER_HXX
-
-#include "editor_map.hxx"
-
-class OnionSkinLayerImpl;
-
-/** The OnionSkinLayer is used to render one or multiple EditorMap
-    renderings in a transparent fashion onto another EditorMap. This
-    is usefull for animation programms and the like where one might
-    need to see the previous or next frames together with the current
-    frame. Might also be usefull for games which have shadow worlds,
-    which reassamble the normal world in a darker fashion. */
-class OnionSkinLayer
-{
-public:
-  /** FIXME: Should probally be CL_Rect instead of just
-      width/height */
-  OnionSkinLayer(int width, int height);
-  OnionSkinLayer(Layer layer);
-  
-  /** Adds an EditorMap to the OnionSkin */
-  void add_map(EditorMap editor_map, const CL_Color& color);
-
-  void clear();
-
-  /** Refreshes the content of the OnionSkin */
-  void update();
-  
-  bool is_null() const { return !impl.get(); }
-  Layer to_layer();
-private:
-  SharedPtr<OnionSkinLayerImpl> impl;  
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/paint_command.cpp (from rev 712, trunk/flexlay/lib/paint_command.cxx)
===================================================================
--- trunk/flexlay/lib/paint_command.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/paint_command.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,149 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <assert.h>
+#include <iostream>
+#include <sstream>
+#include <vector>
+#include <ClanLib/Core/core_iostream.h>
+#include <ClanLib/Core/Math/rect.h>
+#include "field.hpp"
+#include "tilemap_layer.hpp"
+#include "paint_command.hpp"
+
+class PaintCommandImpl : public CommandImpl
+{
+public:
+  typedef std::vector<CL_Point> Points;
+  Points points;
+  
+  TilemapLayer tilemap;
+  TileBrush    brush;
+
+  /** Copy of the field used to generate undo informations */
+  Field<int>   undo_field;
+
+  CL_Point     pos;
+  TileBrush*   redo_brush;
+  TileBrush*   undo_brush;
+
+  PaintCommandImpl() {}
+  virtual ~PaintCommandImpl() {}
+
+  void execute();
+  
+  void redo();
+  void undo();
+
+  std::string serialize();
+};
+
+PaintCommand::PaintCommand(TilemapLayer t, const TileBrush& b)
+  : impl(new PaintCommandImpl())
+{  
+  impl->tilemap = t;
+  impl->brush   = b;
+
+  impl->undo_field = *(impl->tilemap.get_field());
+
+  impl->redo_brush = 0;
+  impl->undo_brush = 0;
+}
+
+PaintCommand::~PaintCommand()
+{
+  delete impl->redo_brush;
+  delete impl->undo_brush;
+}
+
+void
+PaintCommand::add_point(const CL_Point& pos)
+{
+  // FIXME: undo_field is unneeded, should just record the overwritten color
+  impl->points.push_back(pos);
+  impl->tilemap.draw_tile(impl->brush, pos);
+}
+
+void
+PaintCommandImpl::execute()
+{
+  assert(!points.empty());
+  
+  // Calc bounding rect
+  CL_Rect rect(points.front().x, 
+               points.front().y, 
+               points.front().x + brush.get_width(),
+               points.front().y + brush.get_height());
+
+  for(PaintCommandImpl::Points::iterator i = points.begin(); i != points.end(); ++i)
+    {
+      rect.left   = std::min(rect.left,   (*i).x);
+      rect.top    = std::min(rect.top,    (*i).y);
+      rect.right  = std::max(rect.right,  (*i).x + brush.get_width());
+      rect.bottom = std::max(rect.bottom, (*i).y + brush.get_height());
+    }
+  
+  pos.x = rect.left;
+  pos.y = rect.top;
+
+  redo_brush = new TileBrush(*(tilemap.get_field()), rect.get_width(), rect.get_height(),
+                             -pos.x, -pos.y);
+  // FIXME: undo_field is unneeded, should just record the overwritten color
+  undo_brush = new TileBrush(undo_field, rect.get_width(), rect.get_height(), 
+                             -pos.x, -pos.y);
+  
+  redo_brush->set_opaque();
+  undo_brush->set_opaque();
+
+  undo_field.clear();
+}
+
+void
+PaintCommandImpl::redo()
+{
+  TilemapLayer::draw_tiles(tilemap.get_field(), *redo_brush, pos);
+}
+
+void
+PaintCommandImpl::undo()
+{
+  TilemapLayer::draw_tiles(tilemap.get_field(), *undo_brush, pos);
+}
+
+std::string
+PaintCommandImpl::serialize()
+{
+  std::stringstream s;
+
+  s << "_ = PaintCommand(" << &tilemap << ", " << &brush << ")" << std::endl;
+  for(PaintCommandImpl::Points::iterator i = points.begin(); i != points.end(); ++i)
+    {
+      s << "_.add_paint(" << i->x << ", " << i->y << ")"  << std::endl;
+    }
+  s << "_ = None" << std::endl;
+
+  return s.str();
+}
+
+Command
+PaintCommand::to_command()
+{
+  return Command(impl);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/paint_command.cxx
===================================================================
--- trunk/flexlay/lib/paint_command.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/paint_command.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,149 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <assert.h>
-#include <iostream>
-#include <sstream>
-#include <vector>
-#include <ClanLib/Core/core_iostream.h>
-#include <ClanLib/Core/Math/rect.h>
-#include "field.hxx"
-#include "tilemap_layer.hxx"
-#include "paint_command.hxx"
-
-class PaintCommandImpl : public CommandImpl
-{
-public:
-  typedef std::vector<CL_Point> Points;
-  Points points;
-  
-  TilemapLayer tilemap;
-  TileBrush    brush;
-
-  /** Copy of the field used to generate undo informations */
-  Field<int>   undo_field;
-
-  CL_Point     pos;
-  TileBrush*   redo_brush;
-  TileBrush*   undo_brush;
-
-  PaintCommandImpl() {}
-  virtual ~PaintCommandImpl() {}
-
-  void execute();
-  
-  void redo();
-  void undo();
-
-  std::string serialize();
-};
-
-PaintCommand::PaintCommand(TilemapLayer t, const TileBrush& b)
-  : impl(new PaintCommandImpl())
-{  
-  impl->tilemap = t;
-  impl->brush   = b;
-
-  impl->undo_field = *(impl->tilemap.get_field());
-
-  impl->redo_brush = 0;
-  impl->undo_brush = 0;
-}
-
-PaintCommand::~PaintCommand()
-{
-  delete impl->redo_brush;
-  delete impl->undo_brush;
-}
-
-void
-PaintCommand::add_point(const CL_Point& pos)
-{
-  // FIXME: undo_field is unneeded, should just record the overwritten color
-  impl->points.push_back(pos);
-  impl->tilemap.draw_tile(impl->brush, pos);
-}
-
-void
-PaintCommandImpl::execute()
-{
-  assert(!points.empty());
-  
-  // Calc bounding rect
-  CL_Rect rect(points.front().x, 
-               points.front().y, 
-               points.front().x + brush.get_width(),
-               points.front().y + brush.get_height());
-
-  for(PaintCommandImpl::Points::iterator i = points.begin(); i != points.end(); ++i)
-    {
-      rect.left   = std::min(rect.left,   (*i).x);
-      rect.top    = std::min(rect.top,    (*i).y);
-      rect.right  = std::max(rect.right,  (*i).x + brush.get_width());
-      rect.bottom = std::max(rect.bottom, (*i).y + brush.get_height());
-    }
-  
-  pos.x = rect.left;
-  pos.y = rect.top;
-
-  redo_brush = new TileBrush(*(tilemap.get_field()), rect.get_width(), rect.get_height(),
-                             -pos.x, -pos.y);
-  // FIXME: undo_field is unneeded, should just record the overwritten color
-  undo_brush = new TileBrush(undo_field, rect.get_width(), rect.get_height(), 
-                             -pos.x, -pos.y);
-  
-  redo_brush->set_opaque();
-  undo_brush->set_opaque();
-
-  undo_field.clear();
-}
-
-void
-PaintCommandImpl::redo()
-{
-  TilemapLayer::draw_tiles(tilemap.get_field(), *redo_brush, pos);
-}
-
-void
-PaintCommandImpl::undo()
-{
-  TilemapLayer::draw_tiles(tilemap.get_field(), *undo_brush, pos);
-}
-
-std::string
-PaintCommandImpl::serialize()
-{
-  std::stringstream s;
-
-  s << "_ = PaintCommand(" << &tilemap << ", " << &brush << ")" << std::endl;
-  for(PaintCommandImpl::Points::iterator i = points.begin(); i != points.end(); ++i)
-    {
-      s << "_.add_paint(" << i->x << ", " << i->y << ")"  << std::endl;
-    }
-  s << "_ = None" << std::endl;
-
-  return s.str();
-}
-
-Command
-PaintCommand::to_command()
-{
-  return Command(impl);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/paint_command.hpp (from rev 712, trunk/flexlay/lib/paint_command.hxx)
===================================================================
--- trunk/flexlay/lib/paint_command.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/paint_command.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,49 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_PAINT_COMMAND_HXX
+#define HEADER_PAINT_COMMAND_HXX
+
+#include <ClanLib/Core/Math/point.h>
+#include "tile_brush.hpp"
+#include "shared_ptr.hpp"
+#include "tilemap_layer.hpp"
+#include "command.hpp"
+
+class PaintCommandImpl;
+
+/** The PaintCommand provides functionality to draw onto an TileMap.
+    The user needs to supply a brush and a map to draw to and the
+    points to which should be drawn, undo, redo and the internals of
+    drawing are handled by the PaintCommand itself. */
+class PaintCommand
+{
+public:
+  PaintCommand(TilemapLayer t, const TileBrush& b);
+  ~PaintCommand();
+  
+  void add_point(const CL_Point& pos);
+
+  Command to_command();
+private:
+  SharedPtr<PaintCommandImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/paint_command.hxx
===================================================================
--- trunk/flexlay/lib/paint_command.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/paint_command.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,49 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_PAINT_COMMAND_HXX
-#define HEADER_PAINT_COMMAND_HXX
-
-#include <ClanLib/Core/Math/point.h>
-#include "tile_brush.hxx"
-#include "shared_ptr.hxx"
-#include "tilemap_layer.hxx"
-#include "command.hxx"
-
-class PaintCommandImpl;
-
-/** The PaintCommand provides functionality to draw onto an TileMap.
-    The user needs to supply a brush and a map to draw to and the
-    points to which should be drawn, undo, redo and the internals of
-    drawing are handled by the PaintCommand itself. */
-class PaintCommand
-{
-public:
-  PaintCommand(TilemapLayer t, const TileBrush& b);
-  ~PaintCommand();
-  
-  void add_point(const CL_Point& pos);
-
-  Command to_command();
-private:
-  SharedPtr<PaintCommandImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/paned.cpp (from rev 712, trunk/flexlay/lib/paned.cxx)
===================================================================
--- trunk/flexlay/lib/paned.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/paned.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,47 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "paned.hpp"
+
+class PanedImpl
+{
+public:
+  CL_Component* first;
+  CL_Component* second;
+};
+
+Paned::Paned(CL_Component* parent)
+  : impl(new PanedImpl())
+{
+  impl->first  = 0;
+  impl->second = 0;
+}
+
+void
+Paned::set_first(CL_Component* first)
+{
+  impl->first = first;
+}
+
+void
+Paned::set_second(CL_Component* second)
+{
+  impl->second = second;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/paned.cxx
===================================================================
--- trunk/flexlay/lib/paned.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/paned.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,47 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "paned.hxx"
-
-class PanedImpl
-{
-public:
-  CL_Component* first;
-  CL_Component* second;
-};
-
-Paned::Paned(CL_Component* parent)
-  : impl(new PanedImpl())
-{
-  impl->first  = 0;
-  impl->second = 0;
-}
-
-void
-Paned::set_first(CL_Component* first)
-{
-  impl->first = first;
-}
-
-void
-Paned::set_second(CL_Component* second)
-{
-  impl->second = second;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/paned.hpp (from rev 712, trunk/flexlay/lib/paned.hxx)

Deleted: trunk/flexlay/lib/paned.hxx
===================================================================
--- trunk/flexlay/lib/paned.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/paned.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,38 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_PANED_HXX
-#define HEADER_PANED_HXX
-
-/** */
-class Paned : public CL_Component
-{
-protected:
-  virtual Paned() {}
-public:
-  Paned(CL_Component* parent);
-  
-  void set_first(CL_Component* );
-  void set_second(CL_Component* );
-private:
-  SharedPtr<PanedImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/panel.cpp (from rev 712, trunk/flexlay/lib/panel.cxx)
===================================================================
--- trunk/flexlay/lib/panel.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/panel.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,50 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <vector>
+#include <ClanLib/Signals/slot.h>
+#include <ClanLib/Display/display.h>
+#include "box.hpp"
+#include "panel.hpp"
+
+class PanelImpl
+{
+public:
+  std::vector<CL_Slot> slots;
+  CL_Component* parent;
+
+  void draw();
+};
+
+Panel::Panel(const CL_Rect& rect, CL_Component* parent)
+  : CL_Component(rect, parent), impl(new PanelImpl())
+{
+  impl->parent = this;
+  impl->slots.push_back(sig_paint().connect(impl.get(), &PanelImpl::draw));
+}
+
+void
+PanelImpl::draw()
+{
+  CL_Display::push_translate(parent->get_screen_x(), parent->get_screen_y());
+  CL_Rect rect = parent->get_position();
+  Box::draw_panel(CL_Rect(CL_Point(0, 0), CL_Size(rect.get_width()-1, rect.get_height()-1)));
+  CL_Display::pop_modelview();
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/panel.cxx
===================================================================
--- trunk/flexlay/lib/panel.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/panel.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,50 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <vector>
-#include <ClanLib/Signals/slot.h>
-#include <ClanLib/Display/display.h>
-#include "box.hxx"
-#include "panel.hxx"
-
-class PanelImpl
-{
-public:
-  std::vector<CL_Slot> slots;
-  CL_Component* parent;
-
-  void draw();
-};
-
-Panel::Panel(const CL_Rect& rect, CL_Component* parent)
-  : CL_Component(rect, parent), impl(new PanelImpl())
-{
-  impl->parent = this;
-  impl->slots.push_back(sig_paint().connect(impl.get(), &PanelImpl::draw));
-}
-
-void
-PanelImpl::draw()
-{
-  CL_Display::push_translate(parent->get_screen_x(), parent->get_screen_y());
-  CL_Rect rect = parent->get_position();
-  Box::draw_panel(CL_Rect(CL_Point(0, 0), CL_Size(rect.get_width()-1, rect.get_height()-1)));
-  CL_Display::pop_modelview();
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/panel.hpp (from rev 712, trunk/flexlay/lib/panel.hxx)
===================================================================
--- trunk/flexlay/lib/panel.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/panel.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,39 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_PANEL_HXX
+#define HEADER_PANEL_HXX
+
+#include <ClanLib/GUI/component.h>
+#include <ClanLib/Core/Math/rect.h>
+#include "shared_ptr.hpp"
+
+class PanelImpl;
+
+/** */
+class Panel : public CL_Component
+{
+public:
+  Panel(const CL_Rect& rect, CL_Component* parent);
+private:
+  SharedPtr<PanelImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/panel.hxx
===================================================================
--- trunk/flexlay/lib/panel.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/panel.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,39 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_PANEL_HXX
-#define HEADER_PANEL_HXX
-
-#include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/Math/rect.h>
-#include "shared_ptr.hxx"
-
-class PanelImpl;
-
-/** */
-class Panel : public CL_Component
-{
-public:
-  Panel(const CL_Rect& rect, CL_Component* parent);
-private:
-  SharedPtr<PanelImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/popup_menu.cpp (from rev 712, trunk/flexlay/lib/popup_menu.cxx)
===================================================================
--- trunk/flexlay/lib/popup_menu.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/popup_menu.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,55 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include <ClanLib/Display/mouse.h>
+#include "popup_menu.hpp"
+
+PopupMenu::PopupMenu(const CL_Point& pos,  CL_Component* parent)
+{
+  menu = new CL_Menu(CL_Point(pos.x, pos.y), parent, NULL, true);
+  
+  menu->open();
+  
+  slots.push_back(CL_Mouse::sig_key_down().connect(this, &PopupMenu::on_mouse_up));
+}
+
+PopupMenu::~PopupMenu()
+{
+  //menu->release_mouse();
+  delete menu;
+}
+
+void
+PopupMenu::on_mouse_up(const CL_InputEvent& event)
+{
+  if (!menu->has_mouse_over() && !menu->has_mouse_in_submenus())
+    {
+      menu->collapse();
+      // FIXME: *yuck*
+      delete this;
+    }
+  else
+    {
+      // FIXME: this should be in the constructor, but doesn't work
+      // there since the menu collapses then instantly
+      menu->set_root_collapsing(true); 
+    }
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/popup_menu.cxx
===================================================================
--- trunk/flexlay/lib/popup_menu.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/popup_menu.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,55 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <ClanLib/Display/mouse.h>
-#include "popup_menu.hxx"
-
-PopupMenu::PopupMenu(const CL_Point& pos,  CL_Component* parent)
-{
-  menu = new CL_Menu(CL_Point(pos.x, pos.y), parent, NULL, true);
-  
-  menu->open();
-  
-  slots.push_back(CL_Mouse::sig_key_down().connect(this, &PopupMenu::on_mouse_up));
-}
-
-PopupMenu::~PopupMenu()
-{
-  //menu->release_mouse();
-  delete menu;
-}
-
-void
-PopupMenu::on_mouse_up(const CL_InputEvent& event)
-{
-  if (!menu->has_mouse_over() && !menu->has_mouse_in_submenus())
-    {
-      menu->collapse();
-      // FIXME: *yuck*
-      delete this;
-    }
-  else
-    {
-      // FIXME: this should be in the constructor, but doesn't work
-      // there since the menu collapses then instantly
-      menu->set_root_collapsing(true); 
-    }
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/popup_menu.hpp (from rev 712, trunk/flexlay/lib/popup_menu.hxx)

Deleted: trunk/flexlay/lib/popup_menu.hxx
===================================================================
--- trunk/flexlay/lib/popup_menu.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/popup_menu.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,47 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_POPUP_MENU_HXX
-#define HEADER_POPUP_MENU_HXX
-
-#include <vector>
-#include <ClanLib/Signals/slot.h>
-#include <ClanLib/GUI/component.h>
-#include <ClanLib/GUI/menu.h>
-
-/** */
-class PopupMenu
-{
-private:
-  std::vector<CL_Slot> slots;
-  CL_Menu* menu;
-public:
-  PopupMenu(const CL_Point& pos, CL_Component* parent);
-  ~PopupMenu();
-
-  CL_Menu* get_menu() { return menu; }
-
-  void on_mouse_up(const CL_InputEvent& event);
-private:
-  PopupMenu (const PopupMenu&);
-  PopupMenu& operator= (const PopupMenu&);
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/scrollbar.cpp (from rev 712, trunk/flexlay/lib/scrollbar.cxx)
===================================================================
--- trunk/flexlay/lib/scrollbar.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/scrollbar.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,180 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <ClanLib/Display/display.h>
+#include <ClanLib/Display/keys.h>
+#include "scrollbar.hpp"
+
+class ScrollbarImpl
+{
+public:
+  std::vector<CL_Slot> slots;
+
+  ScrollbarImpl(Scrollbar* parent_) : parent(parent_) {}
+
+  Scrollbar* parent;
+  float min;
+  float max;
+  float pagesize;
+  float pos;
+  Scrollbar::Orientation orientation;
+
+  CL_Signal_v1<float> on_scrollbar_move;
+
+  float old_pos;
+  
+  bool pressed;
+  CL_Point click_pos;
+  
+  void draw();
+  void on_mouse_up(const CL_InputEvent& event);
+  void on_mouse_down(const CL_InputEvent& event);
+  void on_mouse_move(const CL_InputEvent& event);
+};
+
+Scrollbar::Scrollbar(const CL_Rect& rect, Orientation orientation, CL_Component* parent)
+  : CL_Component(rect, parent),
+    impl(new ScrollbarImpl(this))
+{
+  impl->min = 0;
+  impl->max = 100;
+  impl->pagesize = 10;
+  impl->pos  = 0;
+  impl->pressed = false;
+  impl->orientation = orientation;
+
+  impl->slots.push_back(sig_paint().connect(impl.get(), &ScrollbarImpl::draw));
+
+  impl->slots.push_back(sig_mouse_down().connect(impl.get(), &ScrollbarImpl::on_mouse_down));
+  impl->slots.push_back(sig_mouse_up().connect(impl.get(), &ScrollbarImpl::on_mouse_up));
+  impl->slots.push_back(sig_mouse_move().connect(impl.get(), &ScrollbarImpl::on_mouse_move));
+}
+  
+void
+Scrollbar::set_range(float min, float max)
+{
+  impl->min = min;
+  impl->max = max;
+}
+
+void
+Scrollbar::set_pagesize(float size)
+{
+  impl->pagesize = size;  
+}
+
+void
+Scrollbar::set_pos(float pos)
+{
+  impl->pos = pos;
+}
+
+void 
+ScrollbarImpl::draw()
+{
+  CL_Display::push_cliprect(parent->get_screen_rect());
+  CL_Display::push_translate(parent->get_screen_x(), parent->get_screen_y());
+
+  CL_Rect rect = CL_Rect(CL_Point(0, 0), 
+                         CL_Size(parent->get_width()-1,
+                                 parent->get_height()-1));
+  CL_Display::fill_rect(rect,
+                        CL_Color(255, 255, 255));
+
+  if (orientation == Scrollbar::HORIZONTAL)
+    {
+      float scale = parent->get_width()/(max - min);
+      CL_Display::fill_rect(CL_Rect(CL_Point(int((pos-min-(pagesize/2)) * scale), 2), 
+                                    CL_Size(int(pagesize*scale), 
+                                            parent->get_height()-5)),
+                            CL_Color(0, 0, 0));
+    }
+  else if (orientation == Scrollbar::VERTICAL)
+    {
+      float scale = parent->get_height()/(max - min);
+      CL_Display::fill_rect(CL_Rect(CL_Point(2, int((pos-min-(pagesize/2)) * scale)), 
+                                    CL_Size(parent->get_width()-5,
+                                            int(pagesize*scale))),
+                            CL_Color(0, 0, 0));     
+    }
+
+  CL_Display::draw_rect(rect,
+                        CL_Color(155, 155, 155));
+
+  CL_Display::pop_modelview();
+  CL_Display::pop_cliprect();
+}
+
+void
+ScrollbarImpl::on_mouse_up(const CL_InputEvent& event)
+{
+  if (event.id == CL_MOUSE_LEFT)
+    {
+      pressed = false;
+      parent->release_mouse();
+    }
+}
+
+void
+ScrollbarImpl::on_mouse_down(const CL_InputEvent& event)
+{
+  if (event.id == CL_MOUSE_LEFT)
+    {
+      pressed   = true;
+      click_pos = event.mouse_pos;
+      
+      parent->capture_mouse();
+
+      float scale = ((orientation == Scrollbar::VERTICAL)
+                     ? parent->get_height() : parent->get_width())/(max - min);
+      old_pos = pos * scale;
+
+      click_pos.x += parent->get_position().left;
+      click_pos.y += parent->get_position().top;
+    }
+}
+
+void
+ScrollbarImpl::on_mouse_move(const CL_InputEvent& event)
+{
+  if(pressed)
+    {
+      CL_Rect rect = parent->get_position();
+      
+      float scale = ((orientation == Scrollbar::VERTICAL)
+                     ? parent->get_height() : parent->get_width())/(max - min);
+      
+      if (orientation == Scrollbar::VERTICAL)
+        {
+          pos = (old_pos - (click_pos.y - (rect.top + event.mouse_pos.y)))/scale;
+        }
+      else if (orientation == Scrollbar::HORIZONTAL)
+        {
+          pos = (old_pos - (click_pos.x - (rect.left + event.mouse_pos.x)))/scale;
+        }
+      on_scrollbar_move(pos);
+    }
+}
+
+CL_Signal_v1<float>&
+Scrollbar::sig_scrollbar_move()
+{
+  return impl->on_scrollbar_move;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/scrollbar.cxx
===================================================================
--- trunk/flexlay/lib/scrollbar.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/scrollbar.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,180 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/keys.h>
-#include "scrollbar.hxx"
-
-class ScrollbarImpl
-{
-public:
-  std::vector<CL_Slot> slots;
-
-  ScrollbarImpl(Scrollbar* parent_) : parent(parent_) {}
-
-  Scrollbar* parent;
-  float min;
-  float max;
-  float pagesize;
-  float pos;
-  Scrollbar::Orientation orientation;
-
-  CL_Signal_v1<float> on_scrollbar_move;
-
-  float old_pos;
-  
-  bool pressed;
-  CL_Point click_pos;
-  
-  void draw();
-  void on_mouse_up(const CL_InputEvent& event);
-  void on_mouse_down(const CL_InputEvent& event);
-  void on_mouse_move(const CL_InputEvent& event);
-};
-
-Scrollbar::Scrollbar(const CL_Rect& rect, Orientation orientation, CL_Component* parent)
-  : CL_Component(rect, parent),
-    impl(new ScrollbarImpl(this))
-{
-  impl->min = 0;
-  impl->max = 100;
-  impl->pagesize = 10;
-  impl->pos  = 0;
-  impl->pressed = false;
-  impl->orientation = orientation;
-
-  impl->slots.push_back(sig_paint().connect(impl.get(), &ScrollbarImpl::draw));
-
-  impl->slots.push_back(sig_mouse_down().connect(impl.get(), &ScrollbarImpl::on_mouse_down));
-  impl->slots.push_back(sig_mouse_up().connect(impl.get(), &ScrollbarImpl::on_mouse_up));
-  impl->slots.push_back(sig_mouse_move().connect(impl.get(), &ScrollbarImpl::on_mouse_move));
-}
-  
-void
-Scrollbar::set_range(float min, float max)
-{
-  impl->min = min;
-  impl->max = max;
-}
-
-void
-Scrollbar::set_pagesize(float size)
-{
-  impl->pagesize = size;  
-}
-
-void
-Scrollbar::set_pos(float pos)
-{
-  impl->pos = pos;
-}
-
-void 
-ScrollbarImpl::draw()
-{
-  CL_Display::push_cliprect(parent->get_screen_rect());
-  CL_Display::push_translate(parent->get_screen_x(), parent->get_screen_y());
-
-  CL_Rect rect = CL_Rect(CL_Point(0, 0), 
-                         CL_Size(parent->get_width()-1,
-                                 parent->get_height()-1));
-  CL_Display::fill_rect(rect,
-                        CL_Color(255, 255, 255));
-
-  if (orientation == Scrollbar::HORIZONTAL)
-    {
-      float scale = parent->get_width()/(max - min);
-      CL_Display::fill_rect(CL_Rect(CL_Point(int((pos-min-(pagesize/2)) * scale), 2), 
-                                    CL_Size(int(pagesize*scale), 
-                                            parent->get_height()-5)),
-                            CL_Color(0, 0, 0));
-    }
-  else if (orientation == Scrollbar::VERTICAL)
-    {
-      float scale = parent->get_height()/(max - min);
-      CL_Display::fill_rect(CL_Rect(CL_Point(2, int((pos-min-(pagesize/2)) * scale)), 
-                                    CL_Size(parent->get_width()-5,
-                                            int(pagesize*scale))),
-                            CL_Color(0, 0, 0));     
-    }
-
-  CL_Display::draw_rect(rect,
-                        CL_Color(155, 155, 155));
-
-  CL_Display::pop_modelview();
-  CL_Display::pop_cliprect();
-}
-
-void
-ScrollbarImpl::on_mouse_up(const CL_InputEvent& event)
-{
-  if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed = false;
-      parent->release_mouse();
-    }
-}
-
-void
-ScrollbarImpl::on_mouse_down(const CL_InputEvent& event)
-{
-  if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed   = true;
-      click_pos = event.mouse_pos;
-      
-      parent->capture_mouse();
-
-      float scale = ((orientation == Scrollbar::VERTICAL)
-                     ? parent->get_height() : parent->get_width())/(max - min);
-      old_pos = pos * scale;
-
-      click_pos.x += parent->get_position().left;
-      click_pos.y += parent->get_position().top;
-    }
-}
-
-void
-ScrollbarImpl::on_mouse_move(const CL_InputEvent& event)
-{
-  if(pressed)
-    {
-      CL_Rect rect = parent->get_position();
-      
-      float scale = ((orientation == Scrollbar::VERTICAL)
-                     ? parent->get_height() : parent->get_width())/(max - min);
-      
-      if (orientation == Scrollbar::VERTICAL)
-        {
-          pos = (old_pos - (click_pos.y - (rect.top + event.mouse_pos.y)))/scale;
-        }
-      else if (orientation == Scrollbar::HORIZONTAL)
-        {
-          pos = (old_pos - (click_pos.x - (rect.left + event.mouse_pos.x)))/scale;
-        }
-      on_scrollbar_move(pos);
-    }
-}
-
-CL_Signal_v1<float>&
-Scrollbar::sig_scrollbar_move()
-{
-  return impl->on_scrollbar_move;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/scrollbar.hpp (from rev 712, trunk/flexlay/lib/scrollbar.hxx)
===================================================================
--- trunk/flexlay/lib/scrollbar.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/scrollbar.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,49 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_SCROLLBAR_HXX
+#define HEADER_SCROLLBAR_HXX
+
+#include <ClanLib/GUI/component.h>
+#include <ClanLib/Core/Math/rect.h>
+#include "shared_ptr.hpp"
+
+class ScrollbarImpl;
+
+/** */
+class Scrollbar : public CL_Component
+{
+protected:
+  virtual ~Scrollbar() {}
+public:
+  enum Orientation { HORIZONTAL, VERTICAL };
+
+  Scrollbar(const CL_Rect& rect, Orientation orientation, CL_Component* parent);
+  
+  void set_range(float min, float max);
+  void set_pagesize(float size);
+  void set_pos(float pos);
+  
+  CL_Signal_v1<float>& sig_scrollbar_move();
+private:
+  SharedPtr<ScrollbarImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/scrollbar.hxx
===================================================================
--- trunk/flexlay/lib/scrollbar.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/scrollbar.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,49 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_SCROLLBAR_HXX
-#define HEADER_SCROLLBAR_HXX
-
-#include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/Math/rect.h>
-#include "shared_ptr.hxx"
-
-class ScrollbarImpl;
-
-/** */
-class Scrollbar : public CL_Component
-{
-protected:
-  virtual ~Scrollbar() {}
-public:
-  enum Orientation { HORIZONTAL, VERTICAL };
-
-  Scrollbar(const CL_Rect& rect, Orientation orientation, CL_Component* parent);
-  
-  void set_range(float min, float max);
-  void set_pagesize(float size);
-  void set_pos(float pos);
-  
-  CL_Signal_v1<float>& sig_scrollbar_move();
-private:
-  SharedPtr<ScrollbarImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/serializer.cpp (from rev 712, trunk/flexlay/lib/serializer.cxx)
===================================================================
--- trunk/flexlay/lib/serializer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/serializer.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,41 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "serializer.hpp"
+
+Serializer
+Serializer::register_group (const char* name)
+{
+}
+
+void
+Serializer::register_float (const char* name, float& value)
+{
+}
+
+void
+Serializer::register_int   (const char* name, int& value)
+{
+}
+
+void
+Serializer::register_string(const char* name, std::string& value)
+{
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/serializer.cxx
===================================================================
--- trunk/flexlay/lib/serializer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/serializer.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,41 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "serializer.hxx"
-
-Serializer
-Serializer::register_group (const char* name)
-{
-}
-
-void
-Serializer::register_float (const char* name, float& value)
-{
-}
-
-void
-Serializer::register_int   (const char* name, int& value)
-{
-}
-
-void
-Serializer::register_string(const char* name, std::string& value)
-{
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/serializer.hpp (from rev 712, trunk/flexlay/lib/serializer.hxx)

Deleted: trunk/flexlay/lib/serializer.hxx
===================================================================
--- trunk/flexlay/lib/serializer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/serializer.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,43 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_SERIALIZER_HXX
-#define HEADER_SERIALIZER_HXX
-
-/** */
-class Serializer
-{
-private:
-public:
-  Serializer() {}
-  
-  voi  register_group_start (const char* name) =0;
-  voi  register_group_end   () =0;
-
-  void register_float (const char* name, float& value) =0;
-  void register_int   (const char* name, int& value)   =0;
-  void register_string(const char* name, std::string& value) =0;
-
-private:
-  Serializer (const Serializer&);
-  Serializer& operator= (const Serializer&);
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/sexpr_serializer.cpp (from rev 712, trunk/flexlay/lib/sexpr_serializer.cxx)
===================================================================
--- trunk/flexlay/lib/sexpr_serializer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sexpr_serializer.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,52 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "sexpr_serializer.hpp"
+
+SexprSerializer::SexprSerializer() 
+{
+}
+  
+void
+SexprSerializer::register_group_start (const char* name)
+{
+  
+}
+
+void
+SexprSerializer::register_group_end   ()
+{
+}
+
+void
+SexprSerializer::register_float (const char* name, float& value)
+{
+  
+}
+
+void
+SexprSerializer::register_int   (const char* name, int& value)
+{
+}
+
+void
+SexprSerializer::register_string(const char* name, std::string& value)
+{
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/sexpr_serializer.cxx
===================================================================
--- trunk/flexlay/lib/sexpr_serializer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sexpr_serializer.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,52 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "sexpr_serializer.hxx"
-
-SexprSerializer::SexprSerializer() 
-{
-}
-  
-void
-SexprSerializer::register_group_start (const char* name)
-{
-  
-}
-
-void
-SexprSerializer::register_group_end   ()
-{
-}
-
-void
-SexprSerializer::register_float (const char* name, float& value)
-{
-  
-}
-
-void
-SexprSerializer::register_int   (const char* name, int& value)
-{
-}
-
-void
-SexprSerializer::register_string(const char* name, std::string& value)
-{
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/sexpr_serializer.hpp (from rev 712, trunk/flexlay/lib/sexpr_serializer.hxx)

Deleted: trunk/flexlay/lib/sexpr_serializer.hxx
===================================================================
--- trunk/flexlay/lib/sexpr_serializer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sexpr_serializer.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,43 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_SEXPR_SERIALIZER_HXX
-#define HEADER_SEXPR_SERIALIZER_HXX
-
-/** */
-class SexprSerializer
-{
-private:
-  
-public:
-  SexprSerializer() {}
-  
-  voi  register_group_start (const char* name);
-  voi  register_group_end   ();
-
-  void register_float (const char* name, float& value);
-  void register_int   (const char* name, int& value);
-  void register_string(const char* name, std::string& value);
-
-  /** Return a string representing the serialized objects */
-  std::string get_string();
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/shared_ptr.hpp (from rev 712, trunk/flexlay/lib/shared_ptr.hxx)

Deleted: trunk/flexlay/lib/shared_ptr.hxx
===================================================================
--- trunk/flexlay/lib/shared_ptr.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/shared_ptr.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,50 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_SHARED_PTR_HXX
-#define HEADER_SHARED_PTR_HXX
-
-#include <assert.h>
-
-/** */
-template<typename T>
-class SharedPtr
-{
-private:
-  T* ptr;
-public:
-  template<typename Parent> friend class SharedPtr;
-
-  SharedPtr() : ptr(0) {}
-  SharedPtr(T* p) : ptr(p) {}
-  
-  template <typename Parent>
-  SharedPtr(const SharedPtr<Parent>& p) : ptr(p.ptr) {}
-
-  T& operator*() { assert(ptr); return *ptr; }
-  T const& operator*() const { assert(ptr); return *ptr; }
-
-  T* operator->() { assert(ptr); return ptr; }
-  T const* operator->() const { assert(ptr); return ptr; }
-
-  T* get() const { return ptr; }
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/shared_ptr_comp.hpp (from rev 712, trunk/flexlay/lib/shared_ptr_comp.hxx)

Deleted: trunk/flexlay/lib/shared_ptr_comp.hxx
===================================================================
--- trunk/flexlay/lib/shared_ptr_comp.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/shared_ptr_comp.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,260 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_SHARED_PTR_HXX
-#define HEADER_SHARED_PTR_HXX
-
-#include <iostream>
-#include <typeinfo>
-
-template<class T>
-class SharedPtrDeleter
-{
-public:
-  T* ptr; 
-
-  SharedPtrDeleter(T* p) : ptr(p) {}
-  virtual ~SharedPtrDeleter() {}
-  
-  virtual void del() =0;
-};
-
-template<class T>
-class SharedPtrDeleterImpl : public SharedPtrDeleter<T>
-{
-public:
-  SharedPtrDeleterImpl(T* p)
-    : SharedPtrDeleter<T>(p) {}
-
-  ~SharedPtrDeleterImpl()
-  {
-  }  
-
-  void del() {
-    //if (ptr)
-    //  delete ptr;
-    ptr = 0;
-  }
-};
-
-template<class T>
-class SharedPtr
-{
-private:
-  SharedPtrDeleter<T>* deleter;
-  int* ref_count;
-
-  void inc() {
-#ifdef DEBUG
-    std::cout << "SharedPtr: inc: " << (ref_count ? *ref_count : -45) << std::endl;
-#endif
-    if (ref_count)
-      {
-        *ref_count += 1;
-      }
-  }
-  
-  void dec() {
-#ifdef DEBUG
-    std::cout << "SharedPtr: dec: " << (ref_count ? *ref_count : -45) << std::endl;
-#endif
-    if (ref_count)
-      {
-        *ref_count -= 1;
-        if (*ref_count == 0) {
-#ifdef DEBUG
-          std::cout << "SharedPtr: deleting: type: "
-                    << typeid(deleter->ptr).name()
-                    << " ptr: " << deleter->ptr
-                    << std::endl;
-#endif
-          deleter->del();
-          
-          delete ref_count; ref_count = 0;
-          delete deleter;   deleter   = 0;
-        }
-      }
-    else
-      {
-#ifdef DEBUG
-        std::cout << "SharedPtr: null delete" << std::endl;
-#endif
-      }
-  }
-public:
-  template<class Base> friend class SharedPtr;
-
-  // Constructors
-  SharedPtr()
-    : deleter(0),
-      ref_count(0)
-  {
-#ifdef DEBUG
-    std::cout << "SharedPtr: ctor null" << std::endl;
-#endif
-  }
-
-  template<typename D>
-  SharedPtr(D* p)
-    : deleter(new SharedPtrDeleterImpl<T>(p)), 
-      ref_count(new int(1))
-  {
-#ifdef DEBUG
-    std::cout << "SharedPtr: ctor: type: "
-              << typeid(deleter->ptr).name()
-              << " ptr: " << deleter->ptr
-              << std::endl;
-#endif
-  }
-  
-  template<class Base>
-  SharedPtr(const SharedPtr<Base>& copy)
-    : deleter(0), ref_count(0)
-  {
-    if (copy.deleter)
-      {
-        deleter   = new SharedPtrDeleterImpl<T>(copy.deleter->ptr);
-        ref_count = copy.ref_count;
-        inc();
-      }
-
-#ifdef DEBUG
-    if (deleter)
-      {
-        std::cout << "SharedPtr: copy-ctor template: type: "
-                  << typeid(deleter->ptr).name()
-                  << " ptr: " << deleter->ptr
-                  << std::endl;
-      }
-    else
-      {
-        std::cout << "SharedPtr: copy-ctor template null" << std::endl;
-      }
-#endif
-  }
-
-  // Assign
-  template<class Base>
-  SharedPtr<T>& operator= (const SharedPtr<Base>& copy) 
-  {
-#ifdef DEBUG
-    std::cout << "SharedPtr<T>& operator= (const SharedPtr<Base>& copy)" << std::endl;
-#endif
-    if (ref_count != copy.ref_count)
-      {
-        dec();
-
-        if (copy.deleter)
-          {
-            deleter   = new SharedPtrDeleterImpl<T>(copy.deleter->ptr);
-            ref_count = copy.ref_count;
-            inc();
-          }
-
-#ifdef DEBUG
-        if (deleter)
-          {
-            std::cout << "SharedPtr: assign template: type: "
-                      << typeid(deleter->ptr).name()
-                      << " ptr: " << deleter->ptr
-                      << std::endl;
-          }
-        else
-          {
-            std::cout << "SharedPtr: assign template: null: " << std::endl;
-          }
-#endif
-      }
-
-    return *this;
-  }
-
-  SharedPtr<T>& operator= (const SharedPtr<T>& copy) 
-  {
-    if (this != &copy)
-      {
-        dec();
-
-        if (copy.deleter)
-          {
-            deleter   = new SharedPtrDeleterImpl<T>(copy.deleter->ptr);
-            ref_count = copy.ref_count;
-            inc();
-          }
-
-#ifdef DEBUG
-        if (deleter)
-          {
-            std::cout << "SharedPtr: assign normal: type: "
-                      << typeid(deleter->ptr).name()
-                      << " ptr: " << deleter->ptr
-                      << std::endl;
-          }
-        else
-          {
-            std::cout << "SharedPtr: assign normal null" << std::endl;
-          }
-#endif
-      }
-    else
-      {
-#ifdef DEBUG
-        if (deleter)
-          {
-            std::cout << "SharedPtr: self assin: type: "
-                      << typeid(deleter->ptr).name()
-                      << " ptr: " << deleter->ptr
-                      << std::endl;
-          }
-        else
-          {
-            std::cout << "SharedPtr: assign normal null" << std::endl;
-          }
-#endif
-      }
-
-    return *this;
-  }
-  
-  ~SharedPtr()
-  {
-    dec();
-  }
-
-  //: Dereferencing operator.
-  T& operator*() { return *deleter->ptr; }
-
-  T const& operator*() const { return *deleter->ptr; }
-	
-  //: Indirect member access operator.
-  T* operator->() { return deleter->ptr; }
-
-  T const* operator->() const { return deleter->ptr; }
-
-  T* get() const 
-  {
-    if (deleter) 
-      return deleter->ptr;
-    else
-      return 0; 
-  }
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/sharedptrtest.cpp (from rev 712, trunk/flexlay/lib/sharedptrtest.cxx)
===================================================================
--- trunk/flexlay/lib/sharedptrtest.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sharedptrtest.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,92 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include <ClanLib/Core/System/sharedptr.h>
+#include <boost/shared_ptr.hpp>
+#include "sharedptrtest.hpp"
+
+#define SharedPtr boost::shared_ptr
+
+class B
+{
+public:
+  B() { std::cout << "B(" << this << ")" << std::endl; }
+  virtual ~B() { std::cout << "~B(" << this << ")" << std::endl; }
+
+  virtual void do_something()
+  {
+    std::cout << "B: do_something" << std::endl;
+  }
+};
+
+class A : public B
+{
+public:
+  A() { std::cout << "A(" << this << ")" << std::endl; }
+  virtual ~A() { std::cout << "~A(" << this << ")" << std::endl; }
+  
+  void do_something()
+  {
+    std::cout << "A: do_something" << std::endl;
+  }
+};
+
+class C;
+
+int main()
+{
+  SharedPtr<A> p0_;
+  SharedPtr<A> p1_;
+  SharedPtr<B> p2_(p0_);
+  SharedPtr<B> p3_(p1_);
+
+  SharedPtr<B> p0(new B());
+  {
+    SharedPtr<B> ptr0(new A());
+  }
+  {
+    SharedPtr<A> aptr0(new A());
+    {
+      p0_ = p1_;
+      SharedPtr<B> ptr1(new B());
+      {
+        SharedPtr<B> ptr2 = ptr1;
+        SharedPtr<B> ptr1 = ptr2;
+        ptr1 = aptr0;
+        p0   = aptr0;
+      }
+    }
+  }
+
+  std::cout << "\nInteresting part: " << std::endl;
+  {
+    std::cout << "### SharedPtr<A> p1;" << std::endl;
+    SharedPtr<A> p1;
+    {
+      std::cout << "### SharedPtr<A> p(new A());" << std::endl;
+      SharedPtr<A> p(new A());
+      std::cout << "### p1 = p;" << std::endl;
+      p1 = p;
+    }
+    std::cout << "### p1->do_something()" << std::endl;
+    p1->do_something();
+  }
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/sharedptrtest.cxx
===================================================================
--- trunk/flexlay/lib/sharedptrtest.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sharedptrtest.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,92 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <ClanLib/Core/System/sharedptr.h>
-#include <boost/shared_ptr.hpp>
-#include "sharedptrtest.hxx"
-
-#define SharedPtr boost::shared_ptr
-
-class B
-{
-public:
-  B() { std::cout << "B(" << this << ")" << std::endl; }
-  virtual ~B() { std::cout << "~B(" << this << ")" << std::endl; }
-
-  virtual void do_something()
-  {
-    std::cout << "B: do_something" << std::endl;
-  }
-};
-
-class A : public B
-{
-public:
-  A() { std::cout << "A(" << this << ")" << std::endl; }
-  virtual ~A() { std::cout << "~A(" << this << ")" << std::endl; }
-  
-  void do_something()
-  {
-    std::cout << "A: do_something" << std::endl;
-  }
-};
-
-class C;
-
-int main()
-{
-  SharedPtr<A> p0_;
-  SharedPtr<A> p1_;
-  SharedPtr<B> p2_(p0_);
-  SharedPtr<B> p3_(p1_);
-
-  SharedPtr<B> p0(new B());
-  {
-    SharedPtr<B> ptr0(new A());
-  }
-  {
-    SharedPtr<A> aptr0(new A());
-    {
-      p0_ = p1_;
-      SharedPtr<B> ptr1(new B());
-      {
-        SharedPtr<B> ptr2 = ptr1;
-        SharedPtr<B> ptr1 = ptr2;
-        ptr1 = aptr0;
-        p0   = aptr0;
-      }
-    }
-  }
-
-  std::cout << "\nInteresting part: " << std::endl;
-  {
-    std::cout << "### SharedPtr<A> p1;" << std::endl;
-    SharedPtr<A> p1;
-    {
-      std::cout << "### SharedPtr<A> p(new A());" << std::endl;
-      SharedPtr<A> p(new A());
-      std::cout << "### p1 = p;" << std::endl;
-      p1 = p;
-    }
-    std::cout << "### p1->do_something()" << std::endl;
-    p1->do_something();
-  }
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/sharedptrtest.hpp (from rev 712, trunk/flexlay/lib/sharedptrtest.hxx)

Deleted: trunk/flexlay/lib/sharedptrtest.hxx
===================================================================
--- trunk/flexlay/lib/sharedptrtest.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sharedptrtest.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,25 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_SHAREDPTRTEST_HXX
-#define HEADER_SHAREDPTRTEST_HXX
-
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/simpleed.cpp (from rev 712, trunk/flexlay/lib/simpleed.cxx)
===================================================================
--- trunk/flexlay/lib/simpleed.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/simpleed.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,67 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include <string>
+#include <ClanLib/core.h>
+#include <ClanLib/gui.h>
+#include "workspace.hpp"
+#include "tileset.hpp"
+#include "editor_map_component.hpp"
+#include "gui_manager.hpp"
+#include "layer.hpp"
+#include "tilemap_layer.hpp"
+#include "flexlay.hpp"
+#include "editor_map.hpp"
+
+int main()
+{
+  Flexlay flexlay;
+  flexlay.init();
+
+  Editor editor;
+
+  GUIManager* gui = editor.get_gui_manager();
+
+  new CL_Button(CL_Rect(CL_Point(50, 50), 
+                        CL_Size(100, 25)),
+                "Hello World", gui->get_component());
+
+  EditorMap m;
+  Tileset tileset(32);
+  TilemapLayer tilemap(tileset, 20, 10);
+  
+  m.add_layer(tilemap.to_layer());
+
+  TilemapLayer::set_current(tilemap);
+
+  EditorMapComponent editor_map(CL_Rect(0, 0, 799, 599), gui->get_component());
+  Workspace workspace(799, 599);
+  editor_map.set_workspace(workspace);
+  workspace.set_map(m);
+ 
+  new CL_Button(CL_Rect(CL_Point(50, 150), 
+                        CL_Size(100, 25)),
+                "Quit", gui->get_component());
+
+  gui->run();
+ 
+  flexlay.deinit();
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/simpleed.cxx
===================================================================
--- trunk/flexlay/lib/simpleed.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/simpleed.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,67 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <string>
-#include <ClanLib/core.h>
-#include <ClanLib/gui.h>
-#include "workspace.hxx"
-#include "tileset.hxx"
-#include "editor_map_component.hxx"
-#include "gui_manager.hxx"
-#include "layer.hxx"
-#include "tilemap_layer.hxx"
-#include "flexlay.hxx"
-#include "editor_map.hxx"
-
-int main()
-{
-  Flexlay flexlay;
-  flexlay.init();
-
-  Editor editor;
-
-  GUIManager* gui = editor.get_gui_manager();
-
-  new CL_Button(CL_Rect(CL_Point(50, 50), 
-                        CL_Size(100, 25)),
-                "Hello World", gui->get_component());
-
-  EditorMap m;
-  Tileset tileset(32);
-  TilemapLayer tilemap(tileset, 20, 10);
-  
-  m.add_layer(tilemap.to_layer());
-
-  TilemapLayer::set_current(tilemap);
-
-  EditorMapComponent editor_map(CL_Rect(0, 0, 799, 599), gui->get_component());
-  Workspace workspace(799, 599);
-  editor_map.set_workspace(workspace);
-  workspace.set_map(m);
- 
-  new CL_Button(CL_Rect(CL_Point(50, 150), 
-                        CL_Size(100, 25)),
-                "Quit", gui->get_component());
-
-  gui->run();
- 
-  flexlay.deinit();
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/simpleed.hpp (from rev 712, trunk/flexlay/lib/simpleed.hxx)

Deleted: trunk/flexlay/lib/simpleed.hxx
===================================================================
--- trunk/flexlay/lib/simpleed.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/simpleed.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,26 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_SIMPLEED_HXX
-#define HEADER_SIMPLEED_HXX
-
-
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/sketch_layer.cpp (from rev 712, trunk/flexlay/lib/sketch_layer.cxx)
===================================================================
--- trunk/flexlay/lib/sketch_layer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sketch_layer.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,179 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include <ClanLib/gl.h>
+#include <ClanLib/Core/core_iostream.h>
+#include <ClanLib/Core/System/error.h>
+#include <ClanLib/Display/display.h>
+#include <ClanLib/Display/sprite.h>
+#include <ClanLib/Display/pixel_buffer.h>
+#include <ClanLib/Display/canvas.h>
+#include <ClanLib/Display/blend_func.h>
+#include <ClanLib/Display/graphic_context.h>
+#include <ClanLib/Display/display_window.h>
+#include "flexlay.hpp"
+#include "editor_map_component.hpp"
+#include "layer_impl.hpp"
+#include "sketch_layer.hpp"
+#include "math.hpp"
+
+SketchLayer* SketchLayer::current_ = 0;
+
+class SketchLayerImpl : public LayerImpl
+{
+public:
+  typedef std::vector<Stroke> Strokes;
+  Strokes strokes;
+
+  /** Used to cache drawings */
+  CL_Surface  surface;
+  CL_Canvas*  canvas;
+  float       last_zoom;
+  float       last_rot;
+  CL_Pointf   last_pos;
+  
+  SketchLayerImpl() 
+    : surface(CL_PixelBuffer(CL_Display::get_width(), CL_Display::get_height(), 
+                             CL_Display::get_width()*4, CL_PixelFormat::rgba8888)),
+      canvas(0),
+      last_zoom(0.0f),
+      last_rot(0)
+  {
+    try {
+      canvas = new CL_Canvas(surface);
+    } catch(CL_Error& err) {
+      std::cout << "CL_Error: " << err.message << std::endl;
+    }
+  }
+
+  ~SketchLayerImpl() {
+    delete canvas;
+  }
+
+  void add_stroke(const Stroke& stroke)
+  {
+    strokes.push_back(stroke);
+
+    if (canvas)
+      {
+        EditorMapComponent* parent = EditorMapComponent::current();
+        parent->get_gc_state().push(canvas->get_gc());
+        stroke.draw(canvas->get_gc());
+        parent->get_gc_state().pop(canvas->get_gc());
+        canvas->sync_surface();
+      }
+  }
+  
+  void draw(EditorMapComponent* parent, CL_GraphicContext* gc) 
+  {
+    // Nothing to draw, so we go byebye
+    if (strokes.empty()) 
+      return;
+
+    if (canvas)
+      {
+        // Draw to canvas
+        if (last_zoom != parent->get_gc_state().get_zoom() ||
+            last_pos  != parent->get_gc_state().get_pos()  ||
+            last_rot  != parent->get_gc_state().get_rotation())
+          {
+            // Rerender the image
+            last_zoom   = parent->get_gc_state().get_zoom();
+            last_pos    = parent->get_gc_state().get_pos();
+            last_rot    = parent->get_gc_state().get_rotation();
+
+            parent->get_gc_state().push(canvas->get_gc());
+            canvas->get_gc()->clear(CL_Color(0, 0, 0, 0));
+            //canvas->get_gc()->clear(CL_Color::white);
+
+            CL_Rectf visible_area = parent->get_clip_rect();
+
+            for(Strokes::iterator i = strokes.begin(); i != strokes.end(); ++i)
+              {
+                // canvas->get_gc()->draw_rect(i->get_bounding_rect(), CL_Color(0, 255, 0));
+                // canvas->get_gc()->flush();
+
+                if (visible_area.is_overlapped(i->get_bounding_rect()))
+                  {
+                    i->draw(canvas->get_gc());
+                  }
+              }
+            parent->get_gc_state().pop(canvas->get_gc());
+
+            canvas->sync_surface();
+          }
+        
+        surface.set_blend_func(blend_one, blend_one_minus_src_alpha);
+
+        CL_Matrix4x4 matrix = CL_Display::get_modelview();
+        CL_Display::pop_modelview();
+        surface.draw();
+        CL_Display::set_modelview(matrix);
+        // FIXME: I think we need the line below, however with it it
+        //doesn't work, without it, it does, ClanLib bug or just
+        //consfusing function names?
+        //CL_Display::push_modelview();
+      }
+    else
+      { 
+        // Direct Drawing, slow
+        for(Strokes::iterator i = strokes.begin(); i != strokes.end(); ++i)
+          {
+            i->draw(0);
+          }
+      }
+  }
+
+  bool has_bounding_rect() const { 
+    return false;
+  }
+};
+
+SketchLayer::SketchLayer()
+  : impl(new SketchLayerImpl())
+{
+  current_ = this;
+}
+
+void
+SketchLayer::add_stroke(const Stroke& stroke)
+{
+  if (stroke.get_dab_count() > 0)
+    impl->add_stroke(stroke);
+}
+
+Layer
+SketchLayer::to_layer()
+{
+   return Layer(impl);
+}
+
+std::vector<Stroke>
+SketchLayer::get_strokes()
+{
+  return impl->strokes;
+}
+
+CL_Surface
+SketchLayer::get_background_surface()
+{
+  return impl->surface;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/sketch_layer.cxx
===================================================================
--- trunk/flexlay/lib/sketch_layer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sketch_layer.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,179 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <ClanLib/gl.h>
-#include <ClanLib/Core/core_iostream.h>
-#include <ClanLib/Core/System/error.h>
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/sprite.h>
-#include <ClanLib/Display/pixel_buffer.h>
-#include <ClanLib/Display/canvas.h>
-#include <ClanLib/Display/blend_func.h>
-#include <ClanLib/Display/graphic_context.h>
-#include <ClanLib/Display/display_window.h>
-#include "flexlay.hxx"
-#include "editor_map_component.hxx"
-#include "layer_impl.hxx"
-#include "sketch_layer.hxx"
-#include "math.hxx"
-
-SketchLayer* SketchLayer::current_ = 0;
-
-class SketchLayerImpl : public LayerImpl
-{
-public:
-  typedef std::vector<Stroke> Strokes;
-  Strokes strokes;
-
-  /** Used to cache drawings */
-  CL_Surface  surface;
-  CL_Canvas*  canvas;
-  float       last_zoom;
-  float       last_rot;
-  CL_Pointf   last_pos;
-  
-  SketchLayerImpl() 
-    : surface(CL_PixelBuffer(CL_Display::get_width(), CL_Display::get_height(), 
-                             CL_Display::get_width()*4, CL_PixelFormat::rgba8888)),
-      canvas(0),
-      last_zoom(0.0f),
-      last_rot(0)
-  {
-    try {
-      canvas = new CL_Canvas(surface);
-    } catch(CL_Error& err) {
-      std::cout << "CL_Error: " << err.message << std::endl;
-    }
-  }
-
-  ~SketchLayerImpl() {
-    delete canvas;
-  }
-
-  void add_stroke(const Stroke& stroke)
-  {
-    strokes.push_back(stroke);
-
-    if (canvas)
-      {
-        EditorMapComponent* parent = EditorMapComponent::current();
-        parent->get_gc_state().push(canvas->get_gc());
-        stroke.draw(canvas->get_gc());
-        parent->get_gc_state().pop(canvas->get_gc());
-        canvas->sync_surface();
-      }
-  }
-  
-  void draw(EditorMapComponent* parent, CL_GraphicContext* gc) 
-  {
-    // Nothing to draw, so we go byebye
-    if (strokes.empty()) 
-      return;
-
-    if (canvas)
-      {
-        // Draw to canvas
-        if (last_zoom != parent->get_gc_state().get_zoom() ||
-            last_pos  != parent->get_gc_state().get_pos()  ||
-            last_rot  != parent->get_gc_state().get_rotation())
-          {
-            // Rerender the image
-            last_zoom   = parent->get_gc_state().get_zoom();
-            last_pos    = parent->get_gc_state().get_pos();
-            last_rot    = parent->get_gc_state().get_rotation();
-
-            parent->get_gc_state().push(canvas->get_gc());
-            canvas->get_gc()->clear(CL_Color(0, 0, 0, 0));
-            //canvas->get_gc()->clear(CL_Color::white);
-
-            CL_Rectf visible_area = parent->get_clip_rect();
-
-            for(Strokes::iterator i = strokes.begin(); i != strokes.end(); ++i)
-              {
-                // canvas->get_gc()->draw_rect(i->get_bounding_rect(), CL_Color(0, 255, 0));
-                // canvas->get_gc()->flush();
-
-                if (visible_area.is_overlapped(i->get_bounding_rect()))
-                  {
-                    i->draw(canvas->get_gc());
-                  }
-              }
-            parent->get_gc_state().pop(canvas->get_gc());
-
-            canvas->sync_surface();
-          }
-        
-        surface.set_blend_func(blend_one, blend_one_minus_src_alpha);
-
-        CL_Matrix4x4 matrix = CL_Display::get_modelview();
-        CL_Display::pop_modelview();
-        surface.draw();
-        CL_Display::set_modelview(matrix);
-        // FIXME: I think we need the line below, however with it it
-        //doesn't work, without it, it does, ClanLib bug or just
-        //consfusing function names?
-        //CL_Display::push_modelview();
-      }
-    else
-      { 
-        // Direct Drawing, slow
-        for(Strokes::iterator i = strokes.begin(); i != strokes.end(); ++i)
-          {
-            i->draw(0);
-          }
-      }
-  }
-
-  bool has_bounding_rect() const { 
-    return false;
-  }
-};
-
-SketchLayer::SketchLayer()
-  : impl(new SketchLayerImpl())
-{
-  current_ = this;
-}
-
-void
-SketchLayer::add_stroke(const Stroke& stroke)
-{
-  if (stroke.get_dab_count() > 0)
-    impl->add_stroke(stroke);
-}
-
-Layer
-SketchLayer::to_layer()
-{
-   return Layer(impl);
-}
-
-std::vector<Stroke>
-SketchLayer::get_strokes()
-{
-  return impl->strokes;
-}
-
-CL_Surface
-SketchLayer::get_background_surface()
-{
-  return impl->surface;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/sketch_layer.hpp (from rev 712, trunk/flexlay/lib/sketch_layer.hxx)
===================================================================
--- trunk/flexlay/lib/sketch_layer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sketch_layer.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,58 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_SKETCH_LAYER_HXX
+#define HEADER_SKETCH_LAYER_HXX
+
+#include <vector>
+#include <ClanLib/Core/Math/point.h>
+#include <ClanLib/Display/color.h>
+#include "layer.hpp"
+#include "stroke.hpp"
+
+class SketchLayerImpl;
+
+/** A drawing layer that holds strokes and renders them more or less
+    efficently to the screen, for larger number of strokes this has
+    serious performance impact, use BitmapLayer instead */
+class SketchLayer
+{
+private:
+  static SketchLayer* current_;
+public:
+  static SketchLayer* current() { return current_; }
+  static void set_current(SketchLayer* c) { current_ = c; }
+
+  SketchLayer();
+  
+  void add_stroke(const Stroke&);
+
+  std::vector<Stroke> get_strokes();
+
+  CL_Surface get_background_surface();
+
+  bool is_null() const { return !impl.get(); }
+  Layer to_layer();
+
+private:
+  SharedPtr<SketchLayerImpl> impl;  
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/sketch_layer.hxx
===================================================================
--- trunk/flexlay/lib/sketch_layer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sketch_layer.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,58 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_SKETCH_LAYER_HXX
-#define HEADER_SKETCH_LAYER_HXX
-
-#include <vector>
-#include <ClanLib/Core/Math/point.h>
-#include <ClanLib/Display/color.h>
-#include "layer.hxx"
-#include "stroke.hxx"
-
-class SketchLayerImpl;
-
-/** A drawing layer that holds strokes and renders them more or less
-    efficently to the screen, for larger number of strokes this has
-    serious performance impact, use BitmapLayer instead */
-class SketchLayer
-{
-private:
-  static SketchLayer* current_;
-public:
-  static SketchLayer* current() { return current_; }
-  static void set_current(SketchLayer* c) { current_ = c; }
-
-  SketchLayer();
-  
-  void add_stroke(const Stroke&);
-
-  std::vector<Stroke> get_strokes();
-
-  CL_Surface get_background_surface();
-
-  bool is_null() const { return !impl.get(); }
-  Layer to_layer();
-
-private:
-  SharedPtr<SketchLayerImpl> impl;  
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/slider.cpp (from rev 712, trunk/flexlay/lib/slider.cxx)
===================================================================
--- trunk/flexlay/lib/slider.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/slider.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,116 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <ClanLib/Display/display.h>
+#include <ClanLib/Display/keys.h>
+#include "math.hpp"
+#include "slider.hpp"
+
+Slider::Slider(const CL_Rect& rect, CL_Component* parent)
+  : CL_Component(rect, parent)
+{
+  start = 0.0f;
+  end   = 100.0f;
+  value = 50.0f;
+  pressed = false;
+
+  slots.push_back(sig_mouse_down().connect(this, &Slider::on_mouse_down));
+  slots.push_back(sig_mouse_up().connect(this, &Slider::on_mouse_up));
+  slots.push_back(sig_mouse_move().connect(this, &Slider::on_mouse_move));
+  slots.push_back(sig_paint().connect(this, &Slider::draw));
+}
+
+Slider::~Slider()
+{
+}
+
+void
+Slider::draw()
+{
+  CL_Display::push_modelview();
+  CL_Display::add_translate(get_screen_x(), get_screen_y());
+    
+  CL_Display::fill_rect(CL_Rect(CL_Point(0, get_height()/2 - 2),
+                                CL_Size(get_width(), 5)),
+                        CL_Color(255, 255, 255, 255));
+
+  CL_Display::fill_rect(CL_Rect(CL_Point(int(-2 + (value/(end-start)) * get_width()), 0),
+                                CL_Size(5, get_height())),
+                        CL_Color(0, 0, 0, 255));
+
+  CL_Display::pop_modelview();    
+}
+
+void
+Slider::set_range(float start_, float end_)
+{
+  start = start_;
+  end   = end_;
+}
+
+CL_Signal_v1<float>&
+Slider::sig_on_change()
+{
+  return on_change;
+}
+
+void
+Slider::set_value(float value_)
+{
+  value = value_;
+  on_change(value);
+}
+
+void
+Slider::update_mouse(const CL_InputEvent& event)
+{
+  set_value(Math::mid(start, (float(event.mouse_pos.x) / get_width()) * (end - start), end));
+}
+
+void
+Slider::on_mouse_down(const CL_InputEvent& event)
+{
+  if (event.id == CL_MOUSE_LEFT)
+    {
+      pressed = true;
+      capture_mouse();
+      update_mouse(event);
+    }
+}
+
+void
+Slider::on_mouse_up  (const CL_InputEvent& event)
+{
+  if (event.id == CL_MOUSE_LEFT)
+    {
+      pressed = false;
+      release_mouse();
+      update_mouse(event);
+    }
+}
+
+void
+Slider::on_mouse_move(const CL_InputEvent& event)
+{
+  if (pressed)
+    {
+      update_mouse(event);
+    }
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/slider.cxx
===================================================================
--- trunk/flexlay/lib/slider.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/slider.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,116 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/keys.h>
-#include "math.hxx"
-#include "slider.hxx"
-
-Slider::Slider(const CL_Rect& rect, CL_Component* parent)
-  : CL_Component(rect, parent)
-{
-  start = 0.0f;
-  end   = 100.0f;
-  value = 50.0f;
-  pressed = false;
-
-  slots.push_back(sig_mouse_down().connect(this, &Slider::on_mouse_down));
-  slots.push_back(sig_mouse_up().connect(this, &Slider::on_mouse_up));
-  slots.push_back(sig_mouse_move().connect(this, &Slider::on_mouse_move));
-  slots.push_back(sig_paint().connect(this, &Slider::draw));
-}
-
-Slider::~Slider()
-{
-}
-
-void
-Slider::draw()
-{
-  CL_Display::push_modelview();
-  CL_Display::add_translate(get_screen_x(), get_screen_y());
-    
-  CL_Display::fill_rect(CL_Rect(CL_Point(0, get_height()/2 - 2),
-                                CL_Size(get_width(), 5)),
-                        CL_Color(255, 255, 255, 255));
-
-  CL_Display::fill_rect(CL_Rect(CL_Point(int(-2 + (value/(end-start)) * get_width()), 0),
-                                CL_Size(5, get_height())),
-                        CL_Color(0, 0, 0, 255));
-
-  CL_Display::pop_modelview();    
-}
-
-void
-Slider::set_range(float start_, float end_)
-{
-  start = start_;
-  end   = end_;
-}
-
-CL_Signal_v1<float>&
-Slider::sig_on_change()
-{
-  return on_change;
-}
-
-void
-Slider::set_value(float value_)
-{
-  value = value_;
-  on_change(value);
-}
-
-void
-Slider::update_mouse(const CL_InputEvent& event)
-{
-  set_value(Math::mid(start, (float(event.mouse_pos.x) / get_width()) * (end - start), end));
-}
-
-void
-Slider::on_mouse_down(const CL_InputEvent& event)
-{
-  if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed = true;
-      capture_mouse();
-      update_mouse(event);
-    }
-}
-
-void
-Slider::on_mouse_up  (const CL_InputEvent& event)
-{
-  if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed = false;
-      release_mouse();
-      update_mouse(event);
-    }
-}
-
-void
-Slider::on_mouse_move(const CL_InputEvent& event)
-{
-  if (pressed)
-    {
-      update_mouse(event);
-    }
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/slider.hpp (from rev 712, trunk/flexlay/lib/slider.hxx)

Deleted: trunk/flexlay/lib/slider.hxx
===================================================================
--- trunk/flexlay/lib/slider.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/slider.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,58 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_SLIDER_HXX
-#define HEADER_SLIDER_HXX
-
-#include <vector>
-#include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/Math/rect.h>
-
-/** Little Slider GUI component */
-class Slider : public CL_Component
-{
-protected:
-  virtual ~Slider();
-private:
-  std::vector<CL_Slot> slots;
-  float start;
-  float end;
-  float value;
-  bool pressed;
-
-  CL_Signal_v1<float> on_change;
-  
-  void update_mouse(const CL_InputEvent& event);
-public:
-  Slider(const CL_Rect& rect, CL_Component* parent);
-
-  CL_Signal_v1<float>& sig_on_change();
-
-  void set_range(float start, float end);
-  void set_value(float value);
-
-  void draw();
-  
-  void on_mouse_down(const CL_InputEvent& event);
-  void on_mouse_up  (const CL_InputEvent& event);
-  void on_mouse_move(const CL_InputEvent& event);
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/sprite_brush.cpp (from rev 712, trunk/flexlay/lib/sprite_brush.cxx)
===================================================================
--- trunk/flexlay/lib/sprite_brush.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sprite_brush.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,59 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "brush_impl.hpp"
+#include "sprite_brush.hpp"
+
+class SpriteBrushImpl : public BrushImpl
+{
+public:
+  CL_Sprite sprite;
+  
+  SpriteBrushImpl(const CL_Sprite& sprite_)
+    : sprite(sprite_)
+  {
+    sprite.set_alignment (origin_center, 0, 0);
+  }
+
+  virtual ~SpriteBrushImpl()
+  {
+  }
+
+  CL_Sprite get_sprite() 
+  {
+    return sprite;
+  }
+
+  BrushImpl* clone() const 
+  {
+    return new SpriteBrushImpl(sprite);
+  }
+};
+
+SpriteBrush::SpriteBrush(const CL_Sprite& sprite_)
+  : impl(new SpriteBrushImpl(sprite_))
+{
+}
+
+Brush
+SpriteBrush::to_brush()
+{
+  return Brush(impl);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/sprite_brush.cxx
===================================================================
--- trunk/flexlay/lib/sprite_brush.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sprite_brush.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,59 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "brush_impl.hxx"
-#include "sprite_brush.hxx"
-
-class SpriteBrushImpl : public BrushImpl
-{
-public:
-  CL_Sprite sprite;
-  
-  SpriteBrushImpl(const CL_Sprite& sprite_)
-    : sprite(sprite_)
-  {
-    sprite.set_alignment (origin_center, 0, 0);
-  }
-
-  virtual ~SpriteBrushImpl()
-  {
-  }
-
-  CL_Sprite get_sprite() 
-  {
-    return sprite;
-  }
-
-  BrushImpl* clone() const 
-  {
-    return new SpriteBrushImpl(sprite);
-  }
-};
-
-SpriteBrush::SpriteBrush(const CL_Sprite& sprite_)
-  : impl(new SpriteBrushImpl(sprite_))
-{
-}
-
-Brush
-SpriteBrush::to_brush()
-{
-  return Brush(impl);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/sprite_brush.hpp (from rev 712, trunk/flexlay/lib/sprite_brush.hxx)
===================================================================
--- trunk/flexlay/lib/sprite_brush.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sprite_brush.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,41 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_SPRITE_BRUSH_HXX
+#define HEADER_SPRITE_BRUSH_HXX
+
+#include <ClanLib/Display/sprite.h>
+#include "brush.hpp"
+#include "shared_ptr.hpp"
+
+class SpriteBrushImpl;
+
+class SpriteBrush
+{
+public:
+  SpriteBrush(const CL_Sprite& sprite_);
+
+  Brush to_brush();
+private:
+  SharedPtr<SpriteBrushImpl> impl;
+};
+
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/sprite_brush.hxx
===================================================================
--- trunk/flexlay/lib/sprite_brush.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sprite_brush.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,41 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_SPRITE_BRUSH_HXX
-#define HEADER_SPRITE_BRUSH_HXX
-
-#include <ClanLib/Display/sprite.h>
-#include "brush.hxx"
-#include "shared_ptr.hxx"
-
-class SpriteBrushImpl;
-
-class SpriteBrush
-{
-public:
-  SpriteBrush(const CL_Sprite& sprite_);
-
-  Brush to_brush();
-private:
-  SharedPtr<SpriteBrushImpl> impl;
-};
-
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/sprite_stroke_drawer.cpp (from rev 712, trunk/flexlay/lib/sprite_stroke_drawer.cxx)
===================================================================
--- trunk/flexlay/lib/sprite_stroke_drawer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sprite_stroke_drawer.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,287 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include <assert.h>
+#include <ClanLib/Display/blend_func.h>
+#include <ClanLib/Display/canvas.h>
+#include <ClanLib/gl.h>
+#include <ClanLib/GL/opengl_wrap.h>
+#include "stroke.hpp"
+#include "flexlay.hpp"
+#include "stroke_drawer_impl.hpp"
+#include "sprite_stroke_drawer.hpp"
+#include "drawer_properties.hpp"
+#include "bitmap_layer.hpp"
+#include "sketch_layer.hpp"
+
+CL_ProgramObject* program = 0;
+
+class SpriteStrokeDrawerImpl : public StrokeDrawerImpl
+{
+public:
+  SpriteStrokeDrawer::DrawMode mode;
+  
+  SpriteStrokeDrawerImpl() {}
+
+  void draw(const Stroke& stroke, CL_GraphicContext* gc);
+
+  StrokeDrawerImpl* clone() const;
+};
+
+SpriteStrokeDrawer::SpriteStrokeDrawer(StrokeDrawer drawer)
+{
+  // FIXME: THIS WON'T WORK WITH A REAL SMARTPTR!!!!
+  impl = dynamic_cast<SpriteStrokeDrawerImpl*>(drawer.impl.get());
+  assert(impl.get());
+}
+
+SpriteStrokeDrawer::SpriteStrokeDrawer()
+  : impl(new SpriteStrokeDrawerImpl())
+{
+  impl->mode      = SpriteStrokeDrawer::DM_NORMAL;
+}
+
+void
+SpriteStrokeDrawerImpl::draw(const Stroke& stroke, CL_GraphicContext* gc)
+{
+  if (DrawerProperties::current()->get_brush().is_null() || stroke.get_dab_count() == 0)
+    return;
+  
+  Stroke::Dabs dabs = stroke.get_interpolated_dabs(DrawerProperties::current()->get_spacing()
+                                                   * DrawerProperties::current()->get_size(),
+                                                   DrawerProperties::current()->get_spacing()
+                                                   * DrawerProperties::current()->get_size());
+
+  for(Stroke::Dabs::iterator i = dabs.begin(); i != dabs.end(); ++i)
+    {
+      Dab& dab = *i;
+
+      CL_Sprite sprite = DrawerProperties::current()->get_brush().get_sprite();
+
+      CL_Color color = DrawerProperties::current()->get_color();
+      sprite.set_color(color);
+      sprite.set_alpha((color.get_alpha()/255.0f) * dab.pressure);
+      sprite.set_scale(DrawerProperties::current()->get_size() * dab.pressure,
+                       DrawerProperties::current()->get_size() * dab.pressure);
+
+      if (gc != 0)
+        {
+          /* Correct function:
+             1: dest
+             2: src
+             
+             R = R1 A1 (1 - A2) + R2 A2
+             G = G1 A1 (1 - A2) + G2 A2
+             B = B1 A1 (1 - A2) + B2 A2
+             A = A1 (1 - A2) + A2
+
+             // This is currently used, leads to premultiplied alpha
+             Aout  = Afgd + (1 - Afgd) * Abkg 
+             Cout' = Cfgd' + (1 - Afgd) * Cbkg' 
+             where
+             Cfgd' = Cfgd * Afgd
+             Cbkg' = Cbkg * Abkg
+             Cout' = Cout * Aout
+
+             Aout = (1 - (1 - Afgd) * (1 - Abkg)) 
+             Cout = (Cfgd * Afgd) + (1 - Afgd * Cbkg * Abkg) / Aout 
+             where
+             Cfgd = red, green, blue of foreground
+             Cbkg = red, green, blue of background
+             Afgd = alpha of foreground
+             Abkg = alpha of background
+          */
+
+          // DO Multipass:
+          // 1: GL_ZERO, GL_DST_ALPHA
+          // 2: GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA
+          /*brush.set_blend_func_separate(blend_zero, blend_dst_alpha,
+            blend_zero, blend_one);
+            brush.draw(dab.pos.x, dab.pos.y, gc);*/
+          
+          switch (mode)
+            {
+            case SpriteStrokeDrawer::DM_NORMAL:
+              sprite.set_blend_func_separate(blend_src_alpha, blend_one_minus_src_alpha,
+                                             blend_one, blend_one_minus_src_alpha);
+              sprite.draw(dab.pos.x, dab.pos.y, gc);
+              break;
+
+            case SpriteStrokeDrawer::DM_ADDITION:
+              sprite.set_blend_func_separate(blend_src_alpha, blend_one,
+                                             blend_zero, blend_one);
+              //blend_one, blend_one_minus_src_alpha);
+              sprite.draw(dab.pos.x, dab.pos.y, gc);
+              break;
+              
+            case SpriteStrokeDrawer::DM_ERASE:
+              sprite.set_blend_func(blend_zero, blend_one_minus_src_alpha);
+              sprite.draw(dab.pos.x, dab.pos.y, gc);
+              break;
+          
+            case SpriteStrokeDrawer::DM_SMUDGE:
+              {
+                if (i != dabs.begin())
+                  {
+                    CL_Canvas* canvas = BitmapLayer::current()->get_canvas();
+                    CL_PixelBuffer buffer = canvas->get_pixeldata(CL_Rect(CL_Point(static_cast<int>((i-1)->pos.x) - sprite.get_width()/2,
+                                                                                   static_cast<int>((i-1)->pos.y) - sprite.get_height()/2),
+                                                                          CL_Size(sprite.get_width(), sprite.get_height())));
+                    CL_Surface surface(buffer);
+                    //surface.set_blend_func_separate(blend_src_alpha, blend_one_minus_src_alpha,
+                    //                                blend_one, blend_zero);
+                    surface.set_alignment(origin_center);
+                    surface.set_alpha(0.5);
+                    //surface.set_scale(DrawerProperties::current()->get_size(),
+                    //                 DrawerProperties::current()->get_size());
+                    surface.draw(dab.pos.x, dab.pos.y, gc);
+                  }
+              }
+              break;
+
+            case SpriteStrokeDrawer::DM_SHADER:
+              {
+#if 0 
+                CL_OpenGLState state(gc);
+                state.set_active();
+                state.setup_2d();
+
+                if (program == 0)
+                  {
+                    program = new CL_ProgramObject();
+                
+                    CL_ShaderObject shader("shader", &(Flexlay::current()->resources));
+                    std::cout << "Shader status: " << (shader.get_compile_status() ? "true" : "false") << std::endl;
+                    std::cout << "Shader log: " << shader.get_info_log() << std::endl;
+                    std::cout << "Shader handle: " << shader.get_handle() << std::endl;
+
+                    program->attach(shader);
+                    program->link();
+                    std::cout << "Program status: " << (program->get_link_status() ? "true" : "false") << std::endl;
+                    std::cout << "Program log: " << program->get_info_log() << std::endl;
+                    std::cout << "Program handle: " << program->get_handle() << std::endl;
+
+                    clUseProgram(program->get_handle());
+                  }
+                else
+                  {
+                    clUseProgram(program->get_handle());
+                  }
+            
+                CL_OpenGLSurface glsurface(sprite.get_frame_surface(0));
+                glActiveTexture(GL_TEXTURE0);
+                glsurface.bind();
+                glEnable(GL_TEXTURE_2D);
+
+                /*CL_OpenGLSurface glsurface2(SketchLayer::current()->get_background_surface());
+                  glActiveTexture(GL_TEXTURE1);
+                  glsurface2.bind();
+                  glEnable(GL_TEXTURE_2D);*/
+            
+                clUniform1i(program->get_attribute_location("mytex"), 0);
+                //clUniform1i(program->get_attribute_location("background"), 1);
+                //program->validate();
+                //std::cout << "Program validate status: " << (program->get_validate_status() ? "true" : "false") << std::endl;
+                //std::cout << "Program log: " << program->get_info_log() << std::endl;
+
+                clBegin(CL_QUADS);
+                clColor4b(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
+                float size = base_size * dab.pressure;
+                clVertex2f((dab.pos.x - sprite.get_width()/2) * size, (dab.pos.y - sprite.get_height()/2) * size);
+                clTexCoord2d(0.0, 0.0);
+                clVertex2f((dab.pos.x + sprite.get_width()/2) * size, (dab.pos.y - sprite.get_height()/2) * size);
+                clTexCoord2d(1.0, 0.0);
+                clVertex2f((dab.pos.x + sprite.get_width()/2) * size, (dab.pos.y + sprite.get_height()/2) * size);
+                clTexCoord2d(1.0, 1.0);
+                clVertex2f((dab.pos.x - sprite.get_width()/2) * size, (dab.pos.y + sprite.get_height()/2) * size);
+                clTexCoord2d(0.0, 1.0);
+                clEnd();
+            
+                state.set_active();
+                clUseProgram(0);
+#endif
+              }
+              break;
+              
+            default:
+              std::cout << "Error: SpriteStrokeDrawer: Unknown draw mode: " << mode << std::endl;
+              break;
+            }
+        }
+      else
+        {
+          switch (mode)
+            {
+            case SpriteStrokeDrawer::DM_NORMAL:  
+              sprite.set_blend_func(blend_src_alpha, blend_one_minus_src_alpha);
+              sprite.draw(dab.pos.x, dab.pos.y, gc);
+              break;
+              
+            case SpriteStrokeDrawer::DM_ADDITION:
+              sprite.set_blend_func(blend_src_alpha, blend_one);
+              sprite.draw(dab.pos.x, dab.pos.y, gc); 
+              break;
+            
+            case SpriteStrokeDrawer::DM_ERASE:
+              sprite.set_blend_func(blend_zero, blend_one_minus_src_alpha);
+              sprite.draw(dab.pos.x, dab.pos.y, gc);
+              break; 
+          
+            case SpriteStrokeDrawer::DM_SMUDGE:
+              sprite.set_blend_func(blend_src_alpha, blend_one_minus_src_alpha);
+              sprite.draw(dab.pos.x, dab.pos.y, gc);          
+              break;
+
+            default:
+              std::cout << "Error: SpriteStrokeDrawer: Unknown draw mode: " << mode << std::endl;
+              break;
+            }
+        }
+    }
+}
+
+void
+SpriteStrokeDrawer::set_mode(DrawMode mode)
+{
+  impl->mode = mode;
+}
+
+SpriteStrokeDrawer::DrawMode
+SpriteStrokeDrawer::get_mode()
+{
+  return impl->mode;
+}
+
+StrokeDrawerImpl*
+SpriteStrokeDrawerImpl::clone() const
+{
+  SpriteStrokeDrawerImpl* drawer = new SpriteStrokeDrawerImpl();
+  
+  *drawer = *this;
+    
+  return drawer;
+}
+
+StrokeDrawer
+SpriteStrokeDrawer::to_drawer()
+{
+  return StrokeDrawer(impl);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/sprite_stroke_drawer.cxx
===================================================================
--- trunk/flexlay/lib/sprite_stroke_drawer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sprite_stroke_drawer.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,287 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <assert.h>
-#include <ClanLib/Display/blend_func.h>
-#include <ClanLib/Display/canvas.h>
-#include <ClanLib/gl.h>
-#include <ClanLib/GL/opengl_wrap.h>
-#include "stroke.hxx"
-#include "flexlay.hxx"
-#include "stroke_drawer_impl.hxx"
-#include "sprite_stroke_drawer.hxx"
-#include "drawer_properties.hxx"
-#include "bitmap_layer.hxx"
-#include "sketch_layer.hxx"
-
-CL_ProgramObject* program = 0;
-
-class SpriteStrokeDrawerImpl : public StrokeDrawerImpl
-{
-public:
-  SpriteStrokeDrawer::DrawMode mode;
-  
-  SpriteStrokeDrawerImpl() {}
-
-  void draw(const Stroke& stroke, CL_GraphicContext* gc);
-
-  StrokeDrawerImpl* clone() const;
-};
-
-SpriteStrokeDrawer::SpriteStrokeDrawer(StrokeDrawer drawer)
-{
-  // FIXME: THIS WON'T WORK WITH A REAL SMARTPTR!!!!
-  impl = dynamic_cast<SpriteStrokeDrawerImpl*>(drawer.impl.get());
-  assert(impl.get());
-}
-
-SpriteStrokeDrawer::SpriteStrokeDrawer()
-  : impl(new SpriteStrokeDrawerImpl())
-{
-  impl->mode      = SpriteStrokeDrawer::DM_NORMAL;
-}
-
-void
-SpriteStrokeDrawerImpl::draw(const Stroke& stroke, CL_GraphicContext* gc)
-{
-  if (DrawerProperties::current()->get_brush().is_null() || stroke.get_dab_count() == 0)
-    return;
-  
-  Stroke::Dabs dabs = stroke.get_interpolated_dabs(DrawerProperties::current()->get_spacing()
-                                                   * DrawerProperties::current()->get_size(),
-                                                   DrawerProperties::current()->get_spacing()
-                                                   * DrawerProperties::current()->get_size());
-
-  for(Stroke::Dabs::iterator i = dabs.begin(); i != dabs.end(); ++i)
-    {
-      Dab& dab = *i;
-
-      CL_Sprite sprite = DrawerProperties::current()->get_brush().get_sprite();
-
-      CL_Color color = DrawerProperties::current()->get_color();
-      sprite.set_color(color);
-      sprite.set_alpha((color.get_alpha()/255.0f) * dab.pressure);
-      sprite.set_scale(DrawerProperties::current()->get_size() * dab.pressure,
-                       DrawerProperties::current()->get_size() * dab.pressure);
-
-      if (gc != 0)
-        {
-          /* Correct function:
-             1: dest
-             2: src
-             
-             R = R1 A1 (1 - A2) + R2 A2
-             G = G1 A1 (1 - A2) + G2 A2
-             B = B1 A1 (1 - A2) + B2 A2
-             A = A1 (1 - A2) + A2
-
-             // This is currently used, leads to premultiplied alpha
-             Aout  = Afgd + (1 - Afgd) * Abkg 
-             Cout' = Cfgd' + (1 - Afgd) * Cbkg' 
-             where
-             Cfgd' = Cfgd * Afgd
-             Cbkg' = Cbkg * Abkg
-             Cout' = Cout * Aout
-
-             Aout = (1 - (1 - Afgd) * (1 - Abkg)) 
-             Cout = (Cfgd * Afgd) + (1 - Afgd * Cbkg * Abkg) / Aout 
-             where
-             Cfgd = red, green, blue of foreground
-             Cbkg = red, green, blue of background
-             Afgd = alpha of foreground
-             Abkg = alpha of background
-          */
-
-          // DO Multipass:
-          // 1: GL_ZERO, GL_DST_ALPHA
-          // 2: GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA
-          /*brush.set_blend_func_separate(blend_zero, blend_dst_alpha,
-            blend_zero, blend_one);
-            brush.draw(dab.pos.x, dab.pos.y, gc);*/
-          
-          switch (mode)
-            {
-            case SpriteStrokeDrawer::DM_NORMAL:
-              sprite.set_blend_func_separate(blend_src_alpha, blend_one_minus_src_alpha,
-                                             blend_one, blend_one_minus_src_alpha);
-              sprite.draw(dab.pos.x, dab.pos.y, gc);
-              break;
-
-            case SpriteStrokeDrawer::DM_ADDITION:
-              sprite.set_blend_func_separate(blend_src_alpha, blend_one,
-                                             blend_zero, blend_one);
-              //blend_one, blend_one_minus_src_alpha);
-              sprite.draw(dab.pos.x, dab.pos.y, gc);
-              break;
-              
-            case SpriteStrokeDrawer::DM_ERASE:
-              sprite.set_blend_func(blend_zero, blend_one_minus_src_alpha);
-              sprite.draw(dab.pos.x, dab.pos.y, gc);
-              break;
-          
-            case SpriteStrokeDrawer::DM_SMUDGE:
-              {
-                if (i != dabs.begin())
-                  {
-                    CL_Canvas* canvas = BitmapLayer::current()->get_canvas();
-                    CL_PixelBuffer buffer = canvas->get_pixeldata(CL_Rect(CL_Point(static_cast<int>((i-1)->pos.x) - sprite.get_width()/2,
-                                                                                   static_cast<int>((i-1)->pos.y) - sprite.get_height()/2),
-                                                                          CL_Size(sprite.get_width(), sprite.get_height())));
-                    CL_Surface surface(buffer);
-                    //surface.set_blend_func_separate(blend_src_alpha, blend_one_minus_src_alpha,
-                    //                                blend_one, blend_zero);
-                    surface.set_alignment(origin_center);
-                    surface.set_alpha(0.5);
-                    //surface.set_scale(DrawerProperties::current()->get_size(),
-                    //                 DrawerProperties::current()->get_size());
-                    surface.draw(dab.pos.x, dab.pos.y, gc);
-                  }
-              }
-              break;
-
-            case SpriteStrokeDrawer::DM_SHADER:
-              {
-#if 0 
-                CL_OpenGLState state(gc);
-                state.set_active();
-                state.setup_2d();
-
-                if (program == 0)
-                  {
-                    program = new CL_ProgramObject();
-                
-                    CL_ShaderObject shader("shader", &(Flexlay::current()->resources));
-                    std::cout << "Shader status: " << (shader.get_compile_status() ? "true" : "false") << std::endl;
-                    std::cout << "Shader log: " << shader.get_info_log() << std::endl;
-                    std::cout << "Shader handle: " << shader.get_handle() << std::endl;
-
-                    program->attach(shader);
-                    program->link();
-                    std::cout << "Program status: " << (program->get_link_status() ? "true" : "false") << std::endl;
-                    std::cout << "Program log: " << program->get_info_log() << std::endl;
-                    std::cout << "Program handle: " << program->get_handle() << std::endl;
-
-                    clUseProgram(program->get_handle());
-                  }
-                else
-                  {
-                    clUseProgram(program->get_handle());
-                  }
-            
-                CL_OpenGLSurface glsurface(sprite.get_frame_surface(0));
-                glActiveTexture(GL_TEXTURE0);
-                glsurface.bind();
-                glEnable(GL_TEXTURE_2D);
-
-                /*CL_OpenGLSurface glsurface2(SketchLayer::current()->get_background_surface());
-                  glActiveTexture(GL_TEXTURE1);
-                  glsurface2.bind();
-                  glEnable(GL_TEXTURE_2D);*/
-            
-                clUniform1i(program->get_attribute_location("mytex"), 0);
-                //clUniform1i(program->get_attribute_location("background"), 1);
-                //program->validate();
-                //std::cout << "Program validate status: " << (program->get_validate_status() ? "true" : "false") << std::endl;
-                //std::cout << "Program log: " << program->get_info_log() << std::endl;
-
-                clBegin(CL_QUADS);
-                clColor4b(color.get_red(), color.get_green(), color.get_blue(), color.get_alpha());
-                float size = base_size * dab.pressure;
-                clVertex2f((dab.pos.x - sprite.get_width()/2) * size, (dab.pos.y - sprite.get_height()/2) * size);
-                clTexCoord2d(0.0, 0.0);
-                clVertex2f((dab.pos.x + sprite.get_width()/2) * size, (dab.pos.y - sprite.get_height()/2) * size);
-                clTexCoord2d(1.0, 0.0);
-                clVertex2f((dab.pos.x + sprite.get_width()/2) * size, (dab.pos.y + sprite.get_height()/2) * size);
-                clTexCoord2d(1.0, 1.0);
-                clVertex2f((dab.pos.x - sprite.get_width()/2) * size, (dab.pos.y + sprite.get_height()/2) * size);
-                clTexCoord2d(0.0, 1.0);
-                clEnd();
-            
-                state.set_active();
-                clUseProgram(0);
-#endif
-              }
-              break;
-              
-            default:
-              std::cout << "Error: SpriteStrokeDrawer: Unknown draw mode: " << mode << std::endl;
-              break;
-            }
-        }
-      else
-        {
-          switch (mode)
-            {
-            case SpriteStrokeDrawer::DM_NORMAL:  
-              sprite.set_blend_func(blend_src_alpha, blend_one_minus_src_alpha);
-              sprite.draw(dab.pos.x, dab.pos.y, gc);
-              break;
-              
-            case SpriteStrokeDrawer::DM_ADDITION:
-              sprite.set_blend_func(blend_src_alpha, blend_one);
-              sprite.draw(dab.pos.x, dab.pos.y, gc); 
-              break;
-            
-            case SpriteStrokeDrawer::DM_ERASE:
-              sprite.set_blend_func(blend_zero, blend_one_minus_src_alpha);
-              sprite.draw(dab.pos.x, dab.pos.y, gc);
-              break; 
-          
-            case SpriteStrokeDrawer::DM_SMUDGE:
-              sprite.set_blend_func(blend_src_alpha, blend_one_minus_src_alpha);
-              sprite.draw(dab.pos.x, dab.pos.y, gc);          
-              break;
-
-            default:
-              std::cout << "Error: SpriteStrokeDrawer: Unknown draw mode: " << mode << std::endl;
-              break;
-            }
-        }
-    }
-}
-
-void
-SpriteStrokeDrawer::set_mode(DrawMode mode)
-{
-  impl->mode = mode;
-}
-
-SpriteStrokeDrawer::DrawMode
-SpriteStrokeDrawer::get_mode()
-{
-  return impl->mode;
-}
-
-StrokeDrawerImpl*
-SpriteStrokeDrawerImpl::clone() const
-{
-  SpriteStrokeDrawerImpl* drawer = new SpriteStrokeDrawerImpl();
-  
-  *drawer = *this;
-    
-  return drawer;
-}
-
-StrokeDrawer
-SpriteStrokeDrawer::to_drawer()
-{
-  return StrokeDrawer(impl);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/sprite_stroke_drawer.hpp (from rev 712, trunk/flexlay/lib/sprite_stroke_drawer.hxx)
===================================================================
--- trunk/flexlay/lib/sprite_stroke_drawer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sprite_stroke_drawer.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,50 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_SPRITE_STROKE_DRAWER_HXX
+#define HEADER_SPRITE_STROKE_DRAWER_HXX
+
+#include <ClanLib/Display/color.h>
+#include <ClanLib/Display/sprite.h>
+#include "stroke_drawer.hpp"
+#include "brush.hpp"
+
+class Stroke;
+class SpriteStrokeDrawerImpl;
+
+/** */
+class SpriteStrokeDrawer
+{
+public:
+  enum DrawMode { DM_NORMAL, DM_ERASE, DM_ADDITION, DM_SHADER, DM_SMUDGE  };
+
+  SpriteStrokeDrawer(StrokeDrawer drawer);
+  SpriteStrokeDrawer();
+
+  /** The modus in which the drawing affects the image (normal, erase, addition, color, etc.) */
+  void set_mode(DrawMode mode);
+  DrawMode get_mode();
+
+  StrokeDrawer to_drawer();
+private:
+  SharedPtr<SpriteStrokeDrawerImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/sprite_stroke_drawer.hxx
===================================================================
--- trunk/flexlay/lib/sprite_stroke_drawer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/sprite_stroke_drawer.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,50 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_SPRITE_STROKE_DRAWER_HXX
-#define HEADER_SPRITE_STROKE_DRAWER_HXX
-
-#include <ClanLib/Display/color.h>
-#include <ClanLib/Display/sprite.h>
-#include "stroke_drawer.hxx"
-#include "brush.hxx"
-
-class Stroke;
-class SpriteStrokeDrawerImpl;
-
-/** */
-class SpriteStrokeDrawer
-{
-public:
-  enum DrawMode { DM_NORMAL, DM_ERASE, DM_ADDITION, DM_SHADER, DM_SMUDGE  };
-
-  SpriteStrokeDrawer(StrokeDrawer drawer);
-  SpriteStrokeDrawer();
-
-  /** The modus in which the drawing affects the image (normal, erase, addition, color, etc.) */
-  void set_mode(DrawMode mode);
-  DrawMode get_mode();
-
-  StrokeDrawer to_drawer();
-private:
-  SharedPtr<SpriteStrokeDrawerImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/string_converter.hpp (from rev 712, trunk/flexlay/lib/string_converter.hxx)
===================================================================
--- trunk/flexlay/lib/string_converter.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/string_converter.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,61 @@
+//  $Id: string_converter.hpp,v 1.3 2003/11/04 22:48:51 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2000 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef STRINGCONVERTER_HXX
+#define STRINGCONVERTER_HXX
+
+#include <stdexcept>
+#include <sstream>
+#include "config.h"
+
+template <class T>
+std::string to_string(const T& any)
+{
+  std::ostringstream oss;
+  oss << any;
+  return oss.str();
+}
+
+template <class T>
+bool from_string(const std::string& rep, T& x)
+{
+  // this is necessary so that if "x" is not modified if the conversion fails
+  T temp;
+  std::istringstream iss(rep);
+
+  iss >> temp;
+
+  if (iss.fail()) {
+    return false;
+  } else {
+    x = temp;
+    return true;
+  }
+}
+
+inline bool has_suffix(const std::string& data, const std::string& suffix)
+{
+  if (data.length() >= suffix.length())
+    return data.compare(data.length() - suffix.length(), suffix.length(), suffix) == 0;
+  else
+    return false;
+}
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/string_converter.hxx
===================================================================
--- trunk/flexlay/lib/string_converter.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/string_converter.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,61 +0,0 @@
-//  $Id: string_converter.hxx,v 1.3 2003/11/04 22:48:51 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2000 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef STRINGCONVERTER_HXX
-#define STRINGCONVERTER_HXX
-
-#include <stdexcept>
-#include <sstream>
-#include "config.h"
-
-template <class T>
-std::string to_string(const T& any)
-{
-  std::ostringstream oss;
-  oss << any;
-  return oss.str();
-}
-
-template <class T>
-bool from_string(const std::string& rep, T& x)
-{
-  // this is necessary so that if "x" is not modified if the conversion fails
-  T temp;
-  std::istringstream iss(rep);
-
-  iss >> temp;
-
-  if (iss.fail()) {
-    return false;
-  } else {
-    x = temp;
-    return true;
-  }
-}
-
-inline bool has_suffix(const std::string& data, const std::string& suffix)
-{
-  if (data.length() >= suffix.length())
-    return data.compare(data.length() - suffix.length(), suffix.length(), suffix) == 0;
-  else
-    return false;
-}
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/stroke.cpp (from rev 712, trunk/flexlay/lib/stroke.cxx)
===================================================================
--- trunk/flexlay/lib/stroke.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/stroke.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,235 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include "stroke.hpp"
+#include "stroke_drawer.hpp"
+
+class StrokeImpl
+{
+public:
+  Stroke::Dabs dabs;
+  StrokeDrawer drawer;
+
+  // Additional data which should be moved to the StrokeDrawer, since
+  // its for caching only and can be generated
+  //typedef std::vector<CL_Pointf> Normals;
+  //Normals normals;
+
+  mutable bool bounding_rect_needs_recalc;
+  mutable CL_Rectf bounding_rect;
+
+  CL_Rectf calc_bounding_rect() const
+  {
+    CL_Rectf rect;
+
+    // FIXME: Keep the drawer into account (ie. brushsize)
+    if (dabs.size() > 0)
+      {
+        rect.left = rect.right  = dabs.front().pos.x;
+        rect.top  = rect.bottom = dabs.front().pos.y;
+
+        for(Stroke::Dabs::const_iterator i = dabs.begin()+1; i != dabs.end(); ++i)
+          {
+            rect.left = std::min(i->pos.x, rect.left);
+            rect.top  = std::min(i->pos.y, rect.top);
+
+            rect.right  = std::max(i->pos.x, rect.right);
+            rect.bottom = std::max(i->pos.y, rect.bottom);
+          }
+      }
+    
+    return rect;
+  }
+
+  StrokeImpl() 
+    : bounding_rect_needs_recalc(true)
+  {
+  }
+};
+
+Stroke::Stroke() 
+  : impl(new StrokeImpl())
+{
+}
+
+void
+Stroke::set_drawer(const StrokeDrawer& drawer_)
+{
+  impl->drawer = drawer_;
+}
+
+StrokeDrawer
+Stroke::get_drawer()
+{
+  return impl->drawer;
+}
+
+Stroke::Dabs
+Stroke::get_interpolated_dabs(float x_spacing, float y_spacing) const
+{
+  if (impl->dabs.size() > 0)
+    {
+      Dabs interpolated_dabs;
+
+      interpolated_dabs.push_back(impl->dabs.front());
+
+      // The following code basically takes all the event dabs as recieved
+      // by from the InputDevice and interpolates new dabs inbetween to
+      // give them an equal spacing (ie. every dab is only 'spacing' away
+      // from the next)
+      float overspace = 0.0f;
+      const Stroke::Dabs& dabs = impl->dabs;
+      for(unsigned int j = 0; j < dabs.size()-1; ++j)
+        {
+          CL_Pointf dist = dabs[j+1].pos - dabs[j].pos;
+          float length = sqrt(dist.x * dist.x + dist.y * dist.y);
+          int n = 1;
+    
+          // Spacing is keep relative to the brush size
+          // FIXME: This is specific to a Sprite based drawer, might not work for others
+          // FIXME: y_spacing isn't taken into account either
+          float local_spacing = x_spacing * dabs[j].pressure;
+
+          while (length + overspace > (local_spacing * n))
+            {
+              float factor = (local_spacing/length) * n - (overspace/length);
+          
+              // FIXME: Interpolate tilting, pressure, etc. along the line
+              interpolated_dabs.push_back(Dab(dabs[j].pos.x + dist.x * factor,
+                                              dabs[j].pos.y + dist.y * factor,
+                                              dabs[j].pressure));
+              n += 1;
+            }
+
+          // calculate the space that wasn't used in the last iteration
+          overspace = (length + overspace) - (local_spacing * (n-1));
+        }
+      return interpolated_dabs;
+    }
+  else
+    {
+      // No dabs available, so nothing to interpolate
+      return impl->dabs;
+    }
+}
+
+Stroke::Dabs
+Stroke::get_dabs() const
+{
+  return impl->dabs; 
+}
+
+int
+Stroke::get_dab_count() const
+{
+  return impl->dabs.size();
+}
+
+void 
+Stroke::draw(CL_GraphicContext* gc) const
+{
+  if (!impl->drawer.is_null())
+    {
+      const_cast<StrokeDrawer&>(impl->drawer).draw(*this, gc);
+    }
+  else
+    {
+      std::cout << "No drawer set!" << std::endl;
+    }
+}
+
+void
+Stroke::add_dab(const Dab& dab) 
+{
+  impl->dabs.push_back(dab);
+}
+
+/* // calc normals
+  assert(normals.size() == 0);
+
+  if (points.size() == 1)
+    {
+      normals.push_back(CL_Pointf(1.0f, 1.0f));
+    }
+  else if (points.size() == 2)
+    {
+      normals.push_back(CL_Pointf(1.0f, 1.0f));
+      normals.push_back(CL_Pointf(1.0f, 1.0f));
+    }
+  else if (points.size() >= 3)
+    {
+      for(Points::size_type i = 0; i < int(points.size())-1; ++i)
+        {
+          CL_Pointf normal((points[i].y - points[i+1].y),
+                           -(points[i].x - points[i+1].x));
+
+          float length = sqrt(normal.x * normal.x + normal.y * normal.y);
+
+          normal.x /= length;
+          normal.y /= length;
+          
+          normals.push_back(normal);
+        }
+      
+      normals.push_back(CL_Pointf(1.0f, 1.0f));
+    }
+
+  //std::cout << normals.size() << " == " <<  points.size() << std::endl;
+  assert(normals.size() == points.size());
+
+ */
+
+/*
+  // Calc bounding rect
+  if (points.size() >= 1)
+    {
+      bounding_rect.left = bounding_rect.right  = points.front().x;
+      bounding_rect.top  = bounding_rect.bottom = points.front().y;
+
+      for(Points::iterator i = points.begin()+1; i != points.end(); ++i)
+        {
+          bounding_rect.left   = Math::min(bounding_rect.left,   i->x);
+          bounding_rect.right  = Math::max(bounding_rect.right,  i->x);;
+          bounding_rect.top    = Math::min(bounding_rect.top,    i->y);
+          bounding_rect.bottom = Math::min(bounding_rect.bottom, i->y);
+        }
+
+      // FIXME: Need to take brush size into account
+    }
+*/
+
+CL_Rectf
+Stroke::get_bounding_rect() const
+{
+  if (impl->bounding_rect_needs_recalc)
+    {
+      impl->bounding_rect = impl->calc_bounding_rect();
+      impl->bounding_rect_needs_recalc = false;
+    }
+  
+  return impl->bounding_rect;
+}
+
+bool
+Stroke::empty() const
+{
+  return (impl->dabs.size() == 0);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/stroke.cxx
===================================================================
--- trunk/flexlay/lib/stroke.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/stroke.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,235 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include "stroke.hxx"
-#include "stroke_drawer.hxx"
-
-class StrokeImpl
-{
-public:
-  Stroke::Dabs dabs;
-  StrokeDrawer drawer;
-
-  // Additional data which should be moved to the StrokeDrawer, since
-  // its for caching only and can be generated
-  //typedef std::vector<CL_Pointf> Normals;
-  //Normals normals;
-
-  mutable bool bounding_rect_needs_recalc;
-  mutable CL_Rectf bounding_rect;
-
-  CL_Rectf calc_bounding_rect() const
-  {
-    CL_Rectf rect;
-
-    // FIXME: Keep the drawer into account (ie. brushsize)
-    if (dabs.size() > 0)
-      {
-        rect.left = rect.right  = dabs.front().pos.x;
-        rect.top  = rect.bottom = dabs.front().pos.y;
-
-        for(Stroke::Dabs::const_iterator i = dabs.begin()+1; i != dabs.end(); ++i)
-          {
-            rect.left = std::min(i->pos.x, rect.left);
-            rect.top  = std::min(i->pos.y, rect.top);
-
-            rect.right  = std::max(i->pos.x, rect.right);
-            rect.bottom = std::max(i->pos.y, rect.bottom);
-          }
-      }
-    
-    return rect;
-  }
-
-  StrokeImpl() 
-    : bounding_rect_needs_recalc(true)
-  {
-  }
-};
-
-Stroke::Stroke() 
-  : impl(new StrokeImpl())
-{
-}
-
-void
-Stroke::set_drawer(const StrokeDrawer& drawer_)
-{
-  impl->drawer = drawer_;
-}
-
-StrokeDrawer
-Stroke::get_drawer()
-{
-  return impl->drawer;
-}
-
-Stroke::Dabs
-Stroke::get_interpolated_dabs(float x_spacing, float y_spacing) const
-{
-  if (impl->dabs.size() > 0)
-    {
-      Dabs interpolated_dabs;
-
-      interpolated_dabs.push_back(impl->dabs.front());
-
-      // The following code basically takes all the event dabs as recieved
-      // by from the InputDevice and interpolates new dabs inbetween to
-      // give them an equal spacing (ie. every dab is only 'spacing' away
-      // from the next)
-      float overspace = 0.0f;
-      const Stroke::Dabs& dabs = impl->dabs;
-      for(unsigned int j = 0; j < dabs.size()-1; ++j)
-        {
-          CL_Pointf dist = dabs[j+1].pos - dabs[j].pos;
-          float length = sqrt(dist.x * dist.x + dist.y * dist.y);
-          int n = 1;
-    
-          // Spacing is keep relative to the brush size
-          // FIXME: This is specific to a Sprite based drawer, might not work for others
-          // FIXME: y_spacing isn't taken into account either
-          float local_spacing = x_spacing * dabs[j].pressure;
-
-          while (length + overspace > (local_spacing * n))
-            {
-              float factor = (local_spacing/length) * n - (overspace/length);
-          
-              // FIXME: Interpolate tilting, pressure, etc. along the line
-              interpolated_dabs.push_back(Dab(dabs[j].pos.x + dist.x * factor,
-                                              dabs[j].pos.y + dist.y * factor,
-                                              dabs[j].pressure));
-              n += 1;
-            }
-
-          // calculate the space that wasn't used in the last iteration
-          overspace = (length + overspace) - (local_spacing * (n-1));
-        }
-      return interpolated_dabs;
-    }
-  else
-    {
-      // No dabs available, so nothing to interpolate
-      return impl->dabs;
-    }
-}
-
-Stroke::Dabs
-Stroke::get_dabs() const
-{
-  return impl->dabs; 
-}
-
-int
-Stroke::get_dab_count() const
-{
-  return impl->dabs.size();
-}
-
-void 
-Stroke::draw(CL_GraphicContext* gc) const
-{
-  if (!impl->drawer.is_null())
-    {
-      const_cast<StrokeDrawer&>(impl->drawer).draw(*this, gc);
-    }
-  else
-    {
-      std::cout << "No drawer set!" << std::endl;
-    }
-}
-
-void
-Stroke::add_dab(const Dab& dab) 
-{
-  impl->dabs.push_back(dab);
-}
-
-/* // calc normals
-  assert(normals.size() == 0);
-
-  if (points.size() == 1)
-    {
-      normals.push_back(CL_Pointf(1.0f, 1.0f));
-    }
-  else if (points.size() == 2)
-    {
-      normals.push_back(CL_Pointf(1.0f, 1.0f));
-      normals.push_back(CL_Pointf(1.0f, 1.0f));
-    }
-  else if (points.size() >= 3)
-    {
-      for(Points::size_type i = 0; i < int(points.size())-1; ++i)
-        {
-          CL_Pointf normal((points[i].y - points[i+1].y),
-                           -(points[i].x - points[i+1].x));
-
-          float length = sqrt(normal.x * normal.x + normal.y * normal.y);
-
-          normal.x /= length;
-          normal.y /= length;
-          
-          normals.push_back(normal);
-        }
-      
-      normals.push_back(CL_Pointf(1.0f, 1.0f));
-    }
-
-  //std::cout << normals.size() << " == " <<  points.size() << std::endl;
-  assert(normals.size() == points.size());
-
- */
-
-/*
-  // Calc bounding rect
-  if (points.size() >= 1)
-    {
-      bounding_rect.left = bounding_rect.right  = points.front().x;
-      bounding_rect.top  = bounding_rect.bottom = points.front().y;
-
-      for(Points::iterator i = points.begin()+1; i != points.end(); ++i)
-        {
-          bounding_rect.left   = Math::min(bounding_rect.left,   i->x);
-          bounding_rect.right  = Math::max(bounding_rect.right,  i->x);;
-          bounding_rect.top    = Math::min(bounding_rect.top,    i->y);
-          bounding_rect.bottom = Math::min(bounding_rect.bottom, i->y);
-        }
-
-      // FIXME: Need to take brush size into account
-    }
-*/
-
-CL_Rectf
-Stroke::get_bounding_rect() const
-{
-  if (impl->bounding_rect_needs_recalc)
-    {
-      impl->bounding_rect = impl->calc_bounding_rect();
-      impl->bounding_rect_needs_recalc = false;
-    }
-  
-  return impl->bounding_rect;
-}
-
-bool
-Stroke::empty() const
-{
-  return (impl->dabs.size() == 0);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/stroke.hpp (from rev 712, trunk/flexlay/lib/stroke.hxx)
===================================================================
--- trunk/flexlay/lib/stroke.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/stroke.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,99 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_STROKE_HXX
+#define HEADER_STROKE_HXX
+
+#include <vector>
+#include <ClanLib/Core/Math/point.h>
+#include <ClanLib/Core/Math/rect.h>
+#include <ClanLib/Core/System/system.h>
+#include "shared_ptr.hpp"
+
+class StrokeImpl;
+class StrokeDrawer;
+class CL_GraphicContext;
+
+/** A dab is basically an event send from the mouse to the drawing
+    canvas, it consists of time, position, tilt, pressure and possible
+    additional information that is needed */
+class Dab
+{
+public:
+  /** Time at which the dot was placed */
+  unsigned int time;
+
+  /** Position at which the dot is placed */
+  CL_Pointf pos;
+
+  /** The pressure with which the dot was drawn (can be interpreted as
+      size, opacity or similar things by the StrokeDrawer */
+  float pressure;
+
+  /** Tilting of the pen while painting the dot */
+  CL_Pointf tilt;
+
+  Dab()
+    : time(CL_System::get_time()), pos(0, 0), pressure(1.0f), tilt(0, 0)
+  {}
+
+  Dab(float x, float y) 
+    : time(CL_System::get_time()), pos(x, y), pressure(1.0f), tilt(0.0f, 0.0f)
+  {}
+
+  Dab(float x_, float y_, float pressure_)
+    : time(CL_System::get_time()), pos(x_, y_), pressure(pressure_), tilt(0.0f, 0.0f)
+  {}
+};
+
+/** A Stroke is a series of Dabs */
+class Stroke
+{
+public:
+  typedef std::vector<Dab> Dabs;
+  
+  Stroke();
+
+  /** Return true if the Stroke doesn't contain any dabs */
+  bool empty() const;
+
+  void draw(CL_GraphicContext* gc) const;
+
+  void  set_drawer(const StrokeDrawer& drawer_);
+  StrokeDrawer get_drawer();
+  void  add_dab(const Dab& dab);
+  
+  /** Returns the real dabs as recieved by the InputDevice */
+  Dabs  get_dabs()  const;
+
+  /** Returns interpolated dabs, meaning the holes in get_dabs() are
+      closed with interpolated dabs so that all dabs are equally
+      spread (ie. every dab is 'spacing' away from the next) */
+  Dabs  get_interpolated_dabs(float x_spacing, float y_spacing) const;
+
+  int get_dab_count() const;
+
+  CL_Rectf get_bounding_rect() const;
+private:
+  SharedPtr<StrokeImpl> impl;
+};
+
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/stroke.hxx
===================================================================
--- trunk/flexlay/lib/stroke.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/stroke.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,99 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_STROKE_HXX
-#define HEADER_STROKE_HXX
-
-#include <vector>
-#include <ClanLib/Core/Math/point.h>
-#include <ClanLib/Core/Math/rect.h>
-#include <ClanLib/Core/System/system.h>
-#include "shared_ptr.hxx"
-
-class StrokeImpl;
-class StrokeDrawer;
-class CL_GraphicContext;
-
-/** A dab is basically an event send from the mouse to the drawing
-    canvas, it consists of time, position, tilt, pressure and possible
-    additional information that is needed */
-class Dab
-{
-public:
-  /** Time at which the dot was placed */
-  unsigned int time;
-
-  /** Position at which the dot is placed */
-  CL_Pointf pos;
-
-  /** The pressure with which the dot was drawn (can be interpreted as
-      size, opacity or similar things by the StrokeDrawer */
-  float pressure;
-
-  /** Tilting of the pen while painting the dot */
-  CL_Pointf tilt;
-
-  Dab()
-    : time(CL_System::get_time()), pos(0, 0), pressure(1.0f), tilt(0, 0)
-  {}
-
-  Dab(float x, float y) 
-    : time(CL_System::get_time()), pos(x, y), pressure(1.0f), tilt(0.0f, 0.0f)
-  {}
-
-  Dab(float x_, float y_, float pressure_)
-    : time(CL_System::get_time()), pos(x_, y_), pressure(pressure_), tilt(0.0f, 0.0f)
-  {}
-};
-
-/** A Stroke is a series of Dabs */
-class Stroke
-{
-public:
-  typedef std::vector<Dab> Dabs;
-  
-  Stroke();
-
-  /** Return true if the Stroke doesn't contain any dabs */
-  bool empty() const;
-
-  void draw(CL_GraphicContext* gc) const;
-
-  void  set_drawer(const StrokeDrawer& drawer_);
-  StrokeDrawer get_drawer();
-  void  add_dab(const Dab& dab);
-  
-  /** Returns the real dabs as recieved by the InputDevice */
-  Dabs  get_dabs()  const;
-
-  /** Returns interpolated dabs, meaning the holes in get_dabs() are
-      closed with interpolated dabs so that all dabs are equally
-      spread (ie. every dab is 'spacing' away from the next) */
-  Dabs  get_interpolated_dabs(float x_spacing, float y_spacing) const;
-
-  int get_dab_count() const;
-
-  CL_Rectf get_bounding_rect() const;
-private:
-  SharedPtr<StrokeImpl> impl;
-};
-
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/stroke_drawer.cpp (from rev 712, trunk/flexlay/lib/stroke_drawer.cxx)
===================================================================
--- trunk/flexlay/lib/stroke_drawer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/stroke_drawer.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,46 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "stroke.hpp"
+#include "stroke_drawer_impl.hpp"
+#include "stroke_drawer.hpp"
+
+StrokeDrawer::StrokeDrawer()
+{
+}
+
+StrokeDrawer::StrokeDrawer(SharedPtr<StrokeDrawerImpl> impl_)
+  :impl(impl_)
+{
+  
+}
+
+void
+StrokeDrawer::draw(const Stroke& stroke, CL_GraphicContext* gc)
+{
+  if (impl.get() != 0)
+    impl->draw(stroke, gc);
+}
+
+StrokeDrawer
+StrokeDrawer::clone() const
+{
+  return StrokeDrawer(impl->clone());
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/stroke_drawer.cxx
===================================================================
--- trunk/flexlay/lib/stroke_drawer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/stroke_drawer.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,46 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "stroke.hxx"
-#include "stroke_drawer_impl.hxx"
-#include "stroke_drawer.hxx"
-
-StrokeDrawer::StrokeDrawer()
-{
-}
-
-StrokeDrawer::StrokeDrawer(SharedPtr<StrokeDrawerImpl> impl_)
-  :impl(impl_)
-{
-  
-}
-
-void
-StrokeDrawer::draw(const Stroke& stroke, CL_GraphicContext* gc)
-{
-  if (impl.get() != 0)
-    impl->draw(stroke, gc);
-}
-
-StrokeDrawer
-StrokeDrawer::clone() const
-{
-  return StrokeDrawer(impl->clone());
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/stroke_drawer.hpp (from rev 712, trunk/flexlay/lib/stroke_drawer.hxx)
===================================================================
--- trunk/flexlay/lib/stroke_drawer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/stroke_drawer.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,47 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_STROKE_DRAWER_HXX
+#define HEADER_STROKE_DRAWER_HXX
+
+#include "shared_ptr.hpp"
+
+class Stroke;
+class StrokeDrawerImpl;
+class CL_GraphicContext;
+
+/** Abstract class which handles the drawing of a Stroke
+ */
+class StrokeDrawer
+{
+private:
+public:
+  StrokeDrawer();
+  StrokeDrawer(SharedPtr<StrokeDrawerImpl> impl);
+  
+  void draw(const Stroke& stroke, CL_GraphicContext* gc);
+
+  bool is_null() const { return !impl.get(); }
+  StrokeDrawer clone() const;
+public:
+  SharedPtr<StrokeDrawerImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/stroke_drawer.hxx
===================================================================
--- trunk/flexlay/lib/stroke_drawer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/stroke_drawer.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,47 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_STROKE_DRAWER_HXX
-#define HEADER_STROKE_DRAWER_HXX
-
-#include "shared_ptr.hxx"
-
-class Stroke;
-class StrokeDrawerImpl;
-class CL_GraphicContext;
-
-/** Abstract class which handles the drawing of a Stroke
- */
-class StrokeDrawer
-{
-private:
-public:
-  StrokeDrawer();
-  StrokeDrawer(SharedPtr<StrokeDrawerImpl> impl);
-  
-  void draw(const Stroke& stroke, CL_GraphicContext* gc);
-
-  bool is_null() const { return !impl.get(); }
-  StrokeDrawer clone() const;
-public:
-  SharedPtr<StrokeDrawerImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/stroke_drawer_impl.hpp (from rev 712, trunk/flexlay/lib/stroke_drawer_impl.hxx)

Deleted: trunk/flexlay/lib/stroke_drawer_impl.hxx
===================================================================
--- trunk/flexlay/lib/stroke_drawer_impl.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/stroke_drawer_impl.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,39 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_STROKE_DRAWER_IMPL_HXX
-#define HEADER_STROKE_DRAWER_IMPL_HXX
-
-class CL_GraphicContext;
-class Stroke;
-
-/** Abstract class which handles the drawing of a Stroke
- */
-class StrokeDrawerImpl
-{
-private:
-public:
-  virtual ~StrokeDrawerImpl() {}
-
-  virtual void draw(const Stroke& stroke, CL_GraphicContext* gc) =0;
-  virtual StrokeDrawerImpl* clone() const =0;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tile.cpp (from rev 712, trunk/flexlay/lib/tile.cxx)
===================================================================
--- trunk/flexlay/lib/tile.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,257 @@
+//  $Id: tile.cxx,v 1.4 2003/09/22 18:37:05 grumbel Exp $
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <ClanLib/Core/System/error.h>
+#include <ClanLib/Display/sprite_description.h>
+#include <ClanLib/Display/pixel_buffer.h>
+#include <ClanLib/Display/pixel_format.h>
+#include <ClanLib/Display/palette.h>
+#include <ClanLib/Display/Providers/provider_factory.h>
+#include <iostream>
+#include "string_converter.hpp"
+#include "tile_provider.hpp"
+#include "tile.hpp"
+
+class TileImpl
+{
+public:
+  TileProvider   provider;
+
+  CL_Sprite      sprite;
+  CL_PixelBuffer pixelbuffer;
+
+  bool transparent;
+  bool has_color;
+
+  /** Color used for the minimap to represent this tile */
+  CL_Color  color;
+
+  /** Color used on 'Show Attributes', ie. to represent walkable areas
+      and such */
+  CL_Color  attribute_color;
+
+  // FIXME: old windstille stuff
+  unsigned char colmap[8];
+
+  std::string filename;
+};
+
+Tile::Tile(const TileProvider& provider)
+  : impl(new TileImpl())
+{
+  impl->provider  = provider;
+  impl->has_color = false; 
+}
+
+Tile::Tile(const CL_PixelBuffer& pixelbuffer,
+           const CL_Sprite& sprite)
+  : impl(new TileImpl())
+{
+  impl->pixelbuffer = pixelbuffer;
+  impl->sprite      = sprite;
+  impl->has_color   = false;
+}
+
+Tile::Tile(const CL_PixelBuffer& pixelbuffer)
+  : impl(new TileImpl())
+{
+  impl->pixelbuffer = pixelbuffer;
+  impl->has_color   = false;
+}
+
+Tile::Tile(const std::string& filename_, 
+           const CL_Color& attribute_color_)
+  : impl(new TileImpl())
+{
+  impl->has_color = false;
+  impl->attribute_color = attribute_color_;
+  impl->filename = filename_;
+}
+
+Tile::~Tile()
+{
+}
+
+CL_Color
+Tile::get_color()
+{
+  if (impl->has_color)
+    {
+      return impl->color;
+    }
+  else
+    {
+      impl->color = calc_color();
+      impl->has_color = true;
+      return impl->color;
+    }
+}
+
+CL_Color
+Tile::get_attribute_color()
+{
+  return impl->attribute_color;
+}
+
+CL_Sprite&
+Tile::get_sprite()
+{
+  if (impl->sprite)
+    {
+      return impl->sprite;
+    }
+  else
+    {
+      if (impl->provider)
+        {
+          impl->sprite = impl->provider.get_sprite();
+        }
+      else
+        {
+          CL_SpriteDescription desc;
+          desc.add_frame(CL_PixelBuffer(get_pixelbuffer()));
+          impl->sprite = CL_Sprite(desc);
+        }
+
+      return impl->sprite;
+    }
+}
+
+CL_PixelBuffer
+Tile::get_pixelbuffer()
+{
+  if (impl->pixelbuffer)
+    {
+      return impl->pixelbuffer;
+    }
+  else 
+    {
+      if (impl->provider)
+        {
+          impl->pixelbuffer = impl->provider.get_pixelbuffer();
+          return impl->pixelbuffer;
+        }
+      else
+        {
+          // FIXME: Move all this into a special provider
+
+          try {
+            if (has_suffix(impl->filename, ".png") || has_suffix(impl->filename, ".jpg"))
+              {
+                impl->pixelbuffer = CL_PixelBuffer(CL_ProviderFactory::load(impl->filename));
+              }
+            else
+              {
+                //CL_SpriteDescription descr(impl->filename, resources);
+                //impl->pixelbuffer = CL_PixelBuffer(*(descr.get_frames().begin()->first));
+                std::cout << "Error: not a png or jpg file: " << impl->filename << std::endl;
+                assert(0);
+              }
+            return impl->pixelbuffer;
+          
+          } catch(CL_Error& err) {
+            std::cout << "CL_Error: " << err.message << std::endl;
+            std::cout << "          filename = " << impl->filename << std::endl;
+            return CL_PixelBuffer();
+          }
+        }
+    }
+}
+
+CL_Color
+Tile::calc_color()
+{
+  CL_PixelBuffer buffer = get_pixelbuffer();
+  buffer.lock();
+  unsigned char* buf = static_cast<unsigned char*>(buffer.get_data());
+  int len = buffer.get_height() * buffer.get_width();
+
+  int red   = 0;
+  int green = 0;
+  int blue  = 0;
+  int alpha = 0;
+  
+  switch (buffer.get_format().get_depth())
+    {
+    case 8:
+      {
+        CL_Palette palette = buffer.get_palette();
+        for(int i = 0; i < len; ++i)
+          {
+            red   += palette.colors[buf[i]].get_red();
+            green += palette.colors[buf[i]].get_green();
+            blue  += palette.colors[buf[i]].get_blue();
+            alpha += 255;
+          }
+      }
+      break;
+    case 24:
+      for(int i = 0; i < len; ++i)
+        {
+          red   += buf[3*i + 0];
+          green += buf[3*i + 1];
+          blue  += buf[3*i + 2];
+          alpha += 255;
+        }
+      break;
+    case 32:
+      for(int i = 0; i < len; ++i)
+        {
+          int a = buf[4*i + 0];
+          alpha += a;
+          red   += buf[4*i + 3]*a/255;;
+          green += buf[4*i + 2]*a/255;;
+          blue  += buf[4*i + 1]*a/255;;
+        }
+      break;
+    }
+
+  buffer.unlock();
+
+  return CL_Color(static_cast<int>(red   / len),
+                  static_cast<int>(green / len),
+                  static_cast<int>(blue  / len),
+                  static_cast<int>(alpha / len));
+}
+
+bool
+Tile::get_col(unsigned char x, unsigned char  y)
+{
+  assert(x < 8);
+  assert(y < 8);
+  return (impl->colmap[y] & (1 << (7-x)));
+}
+
+void
+Tile::set_col(unsigned char x, unsigned char  y, bool val)
+{
+  assert(x < 8);
+  assert(y < 8);
+  if (val)
+    impl->colmap[y] |= (1 << (7-x));
+  else
+    impl->colmap[y] &= ~(1 << (7-x));
+}
+
+std::string
+Tile::get_filename() const
+{
+  return impl->filename; 
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tile.cxx
===================================================================
--- trunk/flexlay/lib/tile.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,257 +0,0 @@
-//  $Id: tile.cxx,v 1.4 2003/09/22 18:37:05 grumbel Exp $
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <ClanLib/Core/System/error.h>
-#include <ClanLib/Display/sprite_description.h>
-#include <ClanLib/Display/pixel_buffer.h>
-#include <ClanLib/Display/pixel_format.h>
-#include <ClanLib/Display/palette.h>
-#include <ClanLib/Display/Providers/provider_factory.h>
-#include <iostream>
-#include "string_converter.hxx"
-#include "tile_provider.hxx"
-#include "tile.hxx"
-
-class TileImpl
-{
-public:
-  TileProvider   provider;
-
-  CL_Sprite      sprite;
-  CL_PixelBuffer pixelbuffer;
-
-  bool transparent;
-  bool has_color;
-
-  /** Color used for the minimap to represent this tile */
-  CL_Color  color;
-
-  /** Color used on 'Show Attributes', ie. to represent walkable areas
-      and such */
-  CL_Color  attribute_color;
-
-  // FIXME: old windstille stuff
-  unsigned char colmap[8];
-
-  std::string filename;
-};
-
-Tile::Tile(const TileProvider& provider)
-  : impl(new TileImpl())
-{
-  impl->provider  = provider;
-  impl->has_color = false; 
-}
-
-Tile::Tile(const CL_PixelBuffer& pixelbuffer,
-           const CL_Sprite& sprite)
-  : impl(new TileImpl())
-{
-  impl->pixelbuffer = pixelbuffer;
-  impl->sprite      = sprite;
-  impl->has_color   = false;
-}
-
-Tile::Tile(const CL_PixelBuffer& pixelbuffer)
-  : impl(new TileImpl())
-{
-  impl->pixelbuffer = pixelbuffer;
-  impl->has_color   = false;
-}
-
-Tile::Tile(const std::string& filename_, 
-           const CL_Color& attribute_color_)
-  : impl(new TileImpl())
-{
-  impl->has_color = false;
-  impl->attribute_color = attribute_color_;
-  impl->filename = filename_;
-}
-
-Tile::~Tile()
-{
-}
-
-CL_Color
-Tile::get_color()
-{
-  if (impl->has_color)
-    {
-      return impl->color;
-    }
-  else
-    {
-      impl->color = calc_color();
-      impl->has_color = true;
-      return impl->color;
-    }
-}
-
-CL_Color
-Tile::get_attribute_color()
-{
-  return impl->attribute_color;
-}
-
-CL_Sprite&
-Tile::get_sprite()
-{
-  if (impl->sprite)
-    {
-      return impl->sprite;
-    }
-  else
-    {
-      if (impl->provider)
-        {
-          impl->sprite = impl->provider.get_sprite();
-        }
-      else
-        {
-          CL_SpriteDescription desc;
-          desc.add_frame(CL_PixelBuffer(get_pixelbuffer()));
-          impl->sprite = CL_Sprite(desc);
-        }
-
-      return impl->sprite;
-    }
-}
-
-CL_PixelBuffer
-Tile::get_pixelbuffer()
-{
-  if (impl->pixelbuffer)
-    {
-      return impl->pixelbuffer;
-    }
-  else 
-    {
-      if (impl->provider)
-        {
-          impl->pixelbuffer = impl->provider.get_pixelbuffer();
-          return impl->pixelbuffer;
-        }
-      else
-        {
-          // FIXME: Move all this into a special provider
-
-          try {
-            if (has_suffix(impl->filename, ".png") || has_suffix(impl->filename, ".jpg"))
-              {
-                impl->pixelbuffer = CL_PixelBuffer(CL_ProviderFactory::load(impl->filename));
-              }
-            else
-              {
-                //CL_SpriteDescription descr(impl->filename, resources);
-                //impl->pixelbuffer = CL_PixelBuffer(*(descr.get_frames().begin()->first));
-                std::cout << "Error: not a png or jpg file: " << impl->filename << std::endl;
-                assert(0);
-              }
-            return impl->pixelbuffer;
-          
-          } catch(CL_Error& err) {
-            std::cout << "CL_Error: " << err.message << std::endl;
-            std::cout << "          filename = " << impl->filename << std::endl;
-            return CL_PixelBuffer();
-          }
-        }
-    }
-}
-
-CL_Color
-Tile::calc_color()
-{
-  CL_PixelBuffer buffer = get_pixelbuffer();
-  buffer.lock();
-  unsigned char* buf = static_cast<unsigned char*>(buffer.get_data());
-  int len = buffer.get_height() * buffer.get_width();
-
-  int red   = 0;
-  int green = 0;
-  int blue  = 0;
-  int alpha = 0;
-  
-  switch (buffer.get_format().get_depth())
-    {
-    case 8:
-      {
-        CL_Palette palette = buffer.get_palette();
-        for(int i = 0; i < len; ++i)
-          {
-            red   += palette.colors[buf[i]].get_red();
-            green += palette.colors[buf[i]].get_green();
-            blue  += palette.colors[buf[i]].get_blue();
-            alpha += 255;
-          }
-      }
-      break;
-    case 24:
-      for(int i = 0; i < len; ++i)
-        {
-          red   += buf[3*i + 0];
-          green += buf[3*i + 1];
-          blue  += buf[3*i + 2];
-          alpha += 255;
-        }
-      break;
-    case 32:
-      for(int i = 0; i < len; ++i)
-        {
-          int a = buf[4*i + 0];
-          alpha += a;
-          red   += buf[4*i + 3]*a/255;;
-          green += buf[4*i + 2]*a/255;;
-          blue  += buf[4*i + 1]*a/255;;
-        }
-      break;
-    }
-
-  buffer.unlock();
-
-  return CL_Color(static_cast<int>(red   / len),
-                  static_cast<int>(green / len),
-                  static_cast<int>(blue  / len),
-                  static_cast<int>(alpha / len));
-}
-
-bool
-Tile::get_col(unsigned char x, unsigned char  y)
-{
-  assert(x < 8);
-  assert(y < 8);
-  return (impl->colmap[y] & (1 << (7-x)));
-}
-
-void
-Tile::set_col(unsigned char x, unsigned char  y, bool val)
-{
-  assert(x < 8);
-  assert(y < 8);
-  if (val)
-    impl->colmap[y] |= (1 << (7-x));
-  else
-    impl->colmap[y] &= ~(1 << (7-x));
-}
-
-std::string
-Tile::get_filename() const
-{
-  return impl->filename; 
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tile.hpp (from rev 712, trunk/flexlay/lib/tile.hxx)
===================================================================
--- trunk/flexlay/lib/tile.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,71 @@
+//  $Id: tile.hpp,v 1.6 2003/09/22 18:37:05 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_TILE_HXX
+#define HEADER_TILE_HXX
+
+#include <assert.h>
+#include <ClanLib/Display/sprite.h>
+#include <ClanLib/Display/pixel_buffer.h>
+#include "shared_ptr.hpp"
+
+class TileImpl;
+class TileProvider;
+
+/** A Tile is a surface or sprite together with meta information for
+    collision (aka colmap), walkability or such. */
+class Tile
+{
+public:
+  Tile(const TileProvider& provider);
+  
+  Tile(const CL_PixelBuffer& pixelbuffer);
+
+  Tile(const CL_PixelBuffer& pixelbuffer,
+       const CL_Sprite& sprite);
+
+  /** @param filename Surface to use 
+   *  @param arg_colmap a 8 char long array */
+  Tile(const std::string& filename, 
+       const CL_Color& attribute_color);
+  ~Tile();
+
+  CL_Sprite& get_sprite();
+
+  /** Return a pixelbuffer associated with this tile, caller must not
+      delete the pixelbuffer, the Tile will take care of that */
+  CL_PixelBuffer get_pixelbuffer();
+
+  // FIXME: Document all those functions
+  CL_Color   get_color();
+  CL_Color   get_attribute_color();
+
+  std::string get_filename() const;
+
+  bool get_col(unsigned char x, unsigned char  y);
+  void set_col(unsigned char x, unsigned char  y, bool val);
+
+  CL_Color calc_color();
+
+private:
+  SharedPtr<TileImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tile.hxx
===================================================================
--- trunk/flexlay/lib/tile.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,71 +0,0 @@
-//  $Id: tile.hxx,v 1.6 2003/09/22 18:37:05 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_TILE_HXX
-#define HEADER_TILE_HXX
-
-#include <assert.h>
-#include <ClanLib/Display/sprite.h>
-#include <ClanLib/Display/pixel_buffer.h>
-#include "shared_ptr.hxx"
-
-class TileImpl;
-class TileProvider;
-
-/** A Tile is a surface or sprite together with meta information for
-    collision (aka colmap), walkability or such. */
-class Tile
-{
-public:
-  Tile(const TileProvider& provider);
-  
-  Tile(const CL_PixelBuffer& pixelbuffer);
-
-  Tile(const CL_PixelBuffer& pixelbuffer,
-       const CL_Sprite& sprite);
-
-  /** @param filename Surface to use 
-   *  @param arg_colmap a 8 char long array */
-  Tile(const std::string& filename, 
-       const CL_Color& attribute_color);
-  ~Tile();
-
-  CL_Sprite& get_sprite();
-
-  /** Return a pixelbuffer associated with this tile, caller must not
-      delete the pixelbuffer, the Tile will take care of that */
-  CL_PixelBuffer get_pixelbuffer();
-
-  // FIXME: Document all those functions
-  CL_Color   get_color();
-  CL_Color   get_attribute_color();
-
-  std::string get_filename() const;
-
-  bool get_col(unsigned char x, unsigned char  y);
-  void set_col(unsigned char x, unsigned char  y, bool val);
-
-  CL_Color calc_color();
-
-private:
-  SharedPtr<TileImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tile_brush.cpp (from rev 712, trunk/flexlay/lib/tile_brush.cxx)
===================================================================
--- trunk/flexlay/lib/tile_brush.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_brush.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,105 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <ClanLib/Core/Math/rect.h>
+#include <iostream>
+#include <ClanLib/Core/core_iostream.h>
+#include "tile_brush.hpp"
+
+TileBrush::TileBrush()
+{
+  opaque = false;
+}
+
+TileBrush::TileBrush(const Field<int>& f, int w, int h, int pos_x, int pos_y)
+  : data(f, w, h, pos_x, pos_y)
+{
+  opaque = false;
+}
+
+TileBrush::TileBrush(int w, int h)
+  : data(w, h)
+{
+  opaque = false;
+}
+
+void
+TileBrush::auto_crop()
+{
+  CL_Rect rect(CL_Point(0, 0), CL_Size(0, 0));
+
+  for(int y = 0; y < get_height(); ++y)
+    for(int x = 0; x < get_width(); ++x)
+      if (at(x, y) != 0)
+        {
+          rect.top = y;
+          goto bottom;
+        }
+
+ bottom:
+  for(int y = get_height()-1; y >= 0; --y)
+    for(int x = 0; x < get_width(); ++x)
+      if (at(x, y) != 0)
+        {
+          rect.bottom = y + 1;
+          goto left;
+        }
+
+ left:
+  for(int x = 0; x < get_width(); ++x)
+    for(int y = 0; y < get_height(); ++y)
+      if (at(x, y) != 0)
+        {
+          rect.left = x;
+          goto right;
+        }
+
+ right:
+  for(int x = get_width() - 1; x >= 0; --x)
+    for(int y = 0; y < get_height(); ++y)
+      if (at(x, y) != 0)
+        {
+          rect.right = x + 1;
+          goto end;
+        }
+
+ end:
+  if (rect.get_width() != 0)
+    resize(rect.get_width(), rect.get_height(), 
+           -rect.left, -rect.top);
+  else
+    {
+      (*this) = TileBrush(1, 1);
+      at(0, 0) = 0;
+      set_opaque();
+    }
+}
+
+void
+TileBrush::set_data(const std::vector<int>& data_)
+{
+  return data.set_data(data_);
+}
+
+std::vector<int>
+TileBrush::get_data()
+{
+  return data.get_data();
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tile_brush.cxx
===================================================================
--- trunk/flexlay/lib/tile_brush.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_brush.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,105 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <ClanLib/Core/Math/rect.h>
-#include <iostream>
-#include <ClanLib/Core/core_iostream.h>
-#include "tile_brush.hxx"
-
-TileBrush::TileBrush()
-{
-  opaque = false;
-}
-
-TileBrush::TileBrush(const Field<int>& f, int w, int h, int pos_x, int pos_y)
-  : data(f, w, h, pos_x, pos_y)
-{
-  opaque = false;
-}
-
-TileBrush::TileBrush(int w, int h)
-  : data(w, h)
-{
-  opaque = false;
-}
-
-void
-TileBrush::auto_crop()
-{
-  CL_Rect rect(CL_Point(0, 0), CL_Size(0, 0));
-
-  for(int y = 0; y < get_height(); ++y)
-    for(int x = 0; x < get_width(); ++x)
-      if (at(x, y) != 0)
-        {
-          rect.top = y;
-          goto bottom;
-        }
-
- bottom:
-  for(int y = get_height()-1; y >= 0; --y)
-    for(int x = 0; x < get_width(); ++x)
-      if (at(x, y) != 0)
-        {
-          rect.bottom = y + 1;
-          goto left;
-        }
-
- left:
-  for(int x = 0; x < get_width(); ++x)
-    for(int y = 0; y < get_height(); ++y)
-      if (at(x, y) != 0)
-        {
-          rect.left = x;
-          goto right;
-        }
-
- right:
-  for(int x = get_width() - 1; x >= 0; --x)
-    for(int y = 0; y < get_height(); ++y)
-      if (at(x, y) != 0)
-        {
-          rect.right = x + 1;
-          goto end;
-        }
-
- end:
-  if (rect.get_width() != 0)
-    resize(rect.get_width(), rect.get_height(), 
-           -rect.left, -rect.top);
-  else
-    {
-      (*this) = TileBrush(1, 1);
-      at(0, 0) = 0;
-      set_opaque();
-    }
-}
-
-void
-TileBrush::set_data(const std::vector<int>& data_)
-{
-  return data.set_data(data_);
-}
-
-std::vector<int>
-TileBrush::get_data()
-{
-  return data.get_data();
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tile_brush.hpp (from rev 712, trunk/flexlay/lib/tile_brush.hxx)
===================================================================
--- trunk/flexlay/lib/tile_brush.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_brush.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,63 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_EDITOR_TILE_BRUSH_HXX
+#define HEADER_EDITOR_TILE_BRUSH_HXX
+
+#include "field.hpp"
+
+/** */
+class TileBrush
+{
+private:
+  Field<int> data;
+
+  /** if true transparent tiles are drawn the same as opaque tiles, ie
+      erasing tiles formaly on the map and replacing them. If false
+      transparent tiles are not drawn at all, thus letting the old
+      tiles stay in place */
+  bool opaque;
+
+public:
+  TileBrush();
+  TileBrush(int w, int h);
+  TileBrush(const Field<int>& f, int w, int h, int pos_x, int pos_y);
+
+  int get_width() const  { return data.get_width(); }
+  int get_height() const { return data.get_height(); }
+
+  void set_data(const std::vector<int>& data);
+  std::vector<int> get_data();
+
+  const int& at(int x, int y) const { return data.at(x, y); }
+  int& at(int x, int y) { return data.at(x, y); }
+
+  void resize(int w, int h, int pos_x = 0, int pos_y = 0) { data.resize(w, h, pos_x, pos_y); }
+
+  void set_opaque() { opaque = true; }
+  void set_transparent() { opaque = false; }
+
+  bool is_opaque() const { return opaque; }
+  
+  /** Removes unneeded transparent bordering */
+  void auto_crop();
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tile_brush.hxx
===================================================================
--- trunk/flexlay/lib/tile_brush.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_brush.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,63 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_EDITOR_TILE_BRUSH_HXX
-#define HEADER_EDITOR_TILE_BRUSH_HXX
-
-#include "field.hxx"
-
-/** */
-class TileBrush
-{
-private:
-  Field<int> data;
-
-  /** if true transparent tiles are drawn the same as opaque tiles, ie
-      erasing tiles formaly on the map and replacing them. If false
-      transparent tiles are not drawn at all, thus letting the old
-      tiles stay in place */
-  bool opaque;
-
-public:
-  TileBrush();
-  TileBrush(int w, int h);
-  TileBrush(const Field<int>& f, int w, int h, int pos_x, int pos_y);
-
-  int get_width() const  { return data.get_width(); }
-  int get_height() const { return data.get_height(); }
-
-  void set_data(const std::vector<int>& data);
-  std::vector<int> get_data();
-
-  const int& at(int x, int y) const { return data.at(x, y); }
-  int& at(int x, int y) { return data.at(x, y); }
-
-  void resize(int w, int h, int pos_x = 0, int pos_y = 0) { data.resize(w, h, pos_x, pos_y); }
-
-  void set_opaque() { opaque = true; }
-  void set_transparent() { opaque = false; }
-
-  bool is_opaque() const { return opaque; }
-  
-  /** Removes unneeded transparent bordering */
-  void auto_crop();
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tile_editor.cpp (from rev 712, trunk/flexlay/lib/tile_editor.cxx)
===================================================================
--- trunk/flexlay/lib/tile_editor.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_editor.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,139 @@
+//  $Id: tile_editor.cxx,v 1.1 2003/09/22 18:37:05 grumbel Exp $
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include <ClanLib/gui.h>
+#include <ClanLib/Display/display.h>
+#include <ClanLib/Display/keys.h>
+#include <ClanLib/Display/mouse.h>
+#include "tile.hpp"
+#include "globals.hpp"
+#include "tile_editor.hpp"
+
+TileEditor::TileEditor(int x, int y, int w, int h, CL_Component* parent)
+  : CL_Component(CL_Rect(CL_Rect(CL_Point(x, y), 
+                                 CL_Size(w, h))), // FIXME: make this editable via script
+                 parent)
+{
+  tile = 0;
+  slots.connect(sig_paint(),      this, &TileEditor::draw);
+  slots.connect(sig_mouse_move(), this, &TileEditor::mouse_move);
+  slots.connect(sig_mouse_down(), this, &TileEditor::mouse_down);
+  slots.connect(sig_mouse_up  (), this, &TileEditor::mouse_up);
+}
+
+TileEditor::~TileEditor()
+{
+}
+  
+void
+TileEditor::draw()
+{
+  CL_Display::push_translate(get_screen_x(), get_screen_x());
+
+  //no_tile.draw(0, 0);
+  CL_Display::fill_rect(CL_Rect(0, 0, 32, 32), CL_Color(155, 0, 155));
+
+  if (tile)
+    {
+      tile->get_sprite().draw(0, 0);
+      CL_Display::flush();
+      for(int tile_y = 0; tile_y < 8; ++tile_y)
+        for(int tile_x = 0; tile_x < 8; ++tile_x)
+          {
+            if (tile->get_col(tile_x, tile_y))
+              {
+                CL_Display::fill_rect(CL_Rect(tile_x*16, tile_y*16,
+                                              tile_x*16 + 16, tile_y*16 + 16),
+                                      CL_Color(255, 0, 0, 128));
+              }
+          }
+      CL_Display::flush();
+      if (has_mouse_over())
+        {
+          CL_Display::fill_rect(CL_Rect(CL_Point(int(mouse_pos.x)/16 * 16, 
+                                                 int(mouse_pos.y)/16 * 16),
+                                        CL_Size(16, 16)),
+                                CL_Color(255, 255, 255, 128));
+        }
+    }
+  else
+    {
+    }
+
+  CL_Display::pop_modelview();
+}
+
+void
+TileEditor::mouse_move(const CL_InputEvent& event)
+{
+  mouse_pos = event.mouse_pos;
+  
+  if (CL_Mouse::get_keycode(CL_MOUSE_LEFT))
+    paint(event.mouse_pos, true);
+  else if (CL_Mouse::get_keycode(CL_MOUSE_RIGHT))
+    paint(event.mouse_pos, false);
+}
+
+void
+TileEditor::mouse_down(const CL_InputEvent& event)
+{
+  if (tile)
+    {
+      switch (event.id)
+        {
+        case CL_MOUSE_LEFT:
+          paint(event.mouse_pos, true);
+          break;
+              
+        case CL_MOUSE_RIGHT:
+          paint(event.mouse_pos, false);
+          break;
+        
+        }
+    }
+}
+
+void
+TileEditor::paint(CL_Point pos, bool val)
+{
+  if (tile)
+    {
+      int x = int(pos.x) / 16;
+      int y = int(pos.y) / 16;
+
+      if (x >= 0 && y >= 0
+          && x < 8 && y < 8)
+        {
+          tile->set_col(x, y, val);
+        }
+    }
+}
+
+void
+TileEditor::mouse_up(const CL_InputEvent& event)
+{
+}
+
+void
+TileEditor::set_tile(Tile* t)
+{
+  tile = t;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tile_editor.cxx
===================================================================
--- trunk/flexlay/lib/tile_editor.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_editor.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,139 +0,0 @@
-//  $Id: tile_editor.cxx,v 1.1 2003/09/22 18:37:05 grumbel Exp $
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <ClanLib/gui.h>
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/keys.h>
-#include <ClanLib/Display/mouse.h>
-#include "tile.hxx"
-#include "globals.hxx"
-#include "tile_editor.hxx"
-
-TileEditor::TileEditor(int x, int y, int w, int h, CL_Component* parent)
-  : CL_Component(CL_Rect(CL_Rect(CL_Point(x, y), 
-                                 CL_Size(w, h))), // FIXME: make this editable via script
-                 parent)
-{
-  tile = 0;
-  slots.connect(sig_paint(),      this, &TileEditor::draw);
-  slots.connect(sig_mouse_move(), this, &TileEditor::mouse_move);
-  slots.connect(sig_mouse_down(), this, &TileEditor::mouse_down);
-  slots.connect(sig_mouse_up  (), this, &TileEditor::mouse_up);
-}
-
-TileEditor::~TileEditor()
-{
-}
-  
-void
-TileEditor::draw()
-{
-  CL_Display::push_translate(get_screen_x(), get_screen_x());
-
-  //no_tile.draw(0, 0);
-  CL_Display::fill_rect(CL_Rect(0, 0, 32, 32), CL_Color(155, 0, 155));
-
-  if (tile)
-    {
-      tile->get_sprite().draw(0, 0);
-      CL_Display::flush();
-      for(int tile_y = 0; tile_y < 8; ++tile_y)
-        for(int tile_x = 0; tile_x < 8; ++tile_x)
-          {
-            if (tile->get_col(tile_x, tile_y))
-              {
-                CL_Display::fill_rect(CL_Rect(tile_x*16, tile_y*16,
-                                              tile_x*16 + 16, tile_y*16 + 16),
-                                      CL_Color(255, 0, 0, 128));
-              }
-          }
-      CL_Display::flush();
-      if (has_mouse_over())
-        {
-          CL_Display::fill_rect(CL_Rect(CL_Point(int(mouse_pos.x)/16 * 16, 
-                                                 int(mouse_pos.y)/16 * 16),
-                                        CL_Size(16, 16)),
-                                CL_Color(255, 255, 255, 128));
-        }
-    }
-  else
-    {
-    }
-
-  CL_Display::pop_modelview();
-}
-
-void
-TileEditor::mouse_move(const CL_InputEvent& event)
-{
-  mouse_pos = event.mouse_pos;
-  
-  if (CL_Mouse::get_keycode(CL_MOUSE_LEFT))
-    paint(event.mouse_pos, true);
-  else if (CL_Mouse::get_keycode(CL_MOUSE_RIGHT))
-    paint(event.mouse_pos, false);
-}
-
-void
-TileEditor::mouse_down(const CL_InputEvent& event)
-{
-  if (tile)
-    {
-      switch (event.id)
-        {
-        case CL_MOUSE_LEFT:
-          paint(event.mouse_pos, true);
-          break;
-              
-        case CL_MOUSE_RIGHT:
-          paint(event.mouse_pos, false);
-          break;
-        
-        }
-    }
-}
-
-void
-TileEditor::paint(CL_Point pos, bool val)
-{
-  if (tile)
-    {
-      int x = int(pos.x) / 16;
-      int y = int(pos.y) / 16;
-
-      if (x >= 0 && y >= 0
-          && x < 8 && y < 8)
-        {
-          tile->set_col(x, y, val);
-        }
-    }
-}
-
-void
-TileEditor::mouse_up(const CL_InputEvent& event)
-{
-}
-
-void
-TileEditor::set_tile(Tile* t)
-{
-  tile = t;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tile_editor.hpp (from rev 712, trunk/flexlay/lib/tile_editor.hxx)
===================================================================
--- trunk/flexlay/lib/tile_editor.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_editor.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,55 @@
+//  $Id: tile_editor.hpp,v 1.1 2003/09/22 18:37:05 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_TILE_EDITOR_HXX
+#define HEADER_TILE_EDITOR_HXX
+
+#include <ClanLib/GUI/component.h>
+#include <ClanLib/Signals/slot_container.h>
+#include <ClanLib/Core/Math/point.h>
+
+class Tile;
+
+/** */
+class TileEditor : public CL_Component
+{
+private:
+  Tile* tile;
+  CL_SlotContainer slots;
+  CL_Point mouse_pos;
+protected:
+  virtual ~TileEditor();
+public:
+  TileEditor(int x, int y, int w, int h, CL_Component* parent);
+  
+  void draw();
+  void mouse_move(const CL_InputEvent& event);
+  void mouse_down(const CL_InputEvent& event);
+  void mouse_up  (const CL_InputEvent& event);
+
+  void set_tile(Tile* tile);
+private:
+  void paint(CL_Point pos, bool val);
+
+  TileEditor (const TileEditor&);
+  TileEditor& operator= (const TileEditor&);
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tile_editor.hxx
===================================================================
--- trunk/flexlay/lib/tile_editor.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_editor.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,55 +0,0 @@
-//  $Id: tile_editor.hxx,v 1.1 2003/09/22 18:37:05 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_TILE_EDITOR_HXX
-#define HEADER_TILE_EDITOR_HXX
-
-#include <ClanLib/GUI/component.h>
-#include <ClanLib/Signals/slot_container.h>
-#include <ClanLib/Core/Math/point.h>
-
-class Tile;
-
-/** */
-class TileEditor : public CL_Component
-{
-private:
-  Tile* tile;
-  CL_SlotContainer slots;
-  CL_Point mouse_pos;
-protected:
-  virtual ~TileEditor();
-public:
-  TileEditor(int x, int y, int w, int h, CL_Component* parent);
-  
-  void draw();
-  void mouse_move(const CL_InputEvent& event);
-  void mouse_down(const CL_InputEvent& event);
-  void mouse_up  (const CL_InputEvent& event);
-
-  void set_tile(Tile* tile);
-private:
-  void paint(CL_Point pos, bool val);
-
-  TileEditor (const TileEditor&);
-  TileEditor& operator= (const TileEditor&);
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tile_provider.cpp (from rev 712, trunk/flexlay/lib/tile_provider.cxx)
===================================================================
--- trunk/flexlay/lib/tile_provider.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_provider.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,39 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "tile_provider_impl.hpp"
+#include "tile_provider.hpp"
+
+TileProvider::TileProvider(TileProviderImpl* impl_)
+  : impl(impl_)
+{
+}
+
+CL_Sprite
+TileProvider::get_sprite() const
+{
+  return impl->get_sprite();
+}
+
+CL_PixelBuffer
+TileProvider::get_pixelbuffer() const
+{
+  return impl->get_pixelbuffer();
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tile_provider.cxx
===================================================================
--- trunk/flexlay/lib/tile_provider.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_provider.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,39 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "tile_provider_impl.hxx"
-#include "tile_provider.hxx"
-
-TileProvider::TileProvider(TileProviderImpl* impl_)
-  : impl(impl_)
-{
-}
-
-CL_Sprite
-TileProvider::get_sprite() const
-{
-  return impl->get_sprite();
-}
-
-CL_PixelBuffer
-TileProvider::get_pixelbuffer() const
-{
-  return impl->get_pixelbuffer();
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tile_provider.hpp (from rev 712, trunk/flexlay/lib/tile_provider.hxx)
===================================================================
--- trunk/flexlay/lib/tile_provider.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_provider.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,45 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_TILE_PROVIDER_HXX
+#define HEADER_TILE_PROVIDER_HXX
+
+#include <ClanLib/Display/sprite.h>
+#include <ClanLib/Display/pixel_buffer.h>
+#include "shared_ptr.hpp"
+
+class TileProviderImpl;
+
+/** TileProvider provides a flexible way to perform load-on-demand for Tiles */
+class TileProvider
+{
+public:
+  TileProvider() {}
+  TileProvider(TileProviderImpl* impl);
+
+  CL_Sprite      get_sprite() const;
+  CL_PixelBuffer get_pixelbuffer() const;
+
+  operator bool() const { return impl.get(); }
+private:
+  SharedPtr<TileProviderImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tile_provider.hxx
===================================================================
--- trunk/flexlay/lib/tile_provider.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_provider.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,45 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_TILE_PROVIDER_HXX
-#define HEADER_TILE_PROVIDER_HXX
-
-#include <ClanLib/Display/sprite.h>
-#include <ClanLib/Display/pixel_buffer.h>
-#include "shared_ptr.hxx"
-
-class TileProviderImpl;
-
-/** TileProvider provides a flexible way to perform load-on-demand for Tiles */
-class TileProvider
-{
-public:
-  TileProvider() {}
-  TileProvider(TileProviderImpl* impl);
-
-  CL_Sprite      get_sprite() const;
-  CL_PixelBuffer get_pixelbuffer() const;
-
-  operator bool() const { return impl.get(); }
-private:
-  SharedPtr<TileProviderImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tile_provider_impl.hpp (from rev 712, trunk/flexlay/lib/tile_provider_impl.hxx)

Deleted: trunk/flexlay/lib/tile_provider_impl.hxx
===================================================================
--- trunk/flexlay/lib/tile_provider_impl.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_provider_impl.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,38 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_TILE_PROVIDER_IMPL_HXX
-#define HEADER_TILE_PROVIDER_IMPL_HXX
-
-#include <ClanLib/Display/sprite.h>
-#include <ClanLib/Display/pixel_buffer.h>
-
-class TileProviderImpl
-{
-public:
-  TileProviderImpl() {}
-  virtual ~TileProviderImpl()
-  { }
-
-  virtual CL_Sprite      get_sprite()      const =0;
-  virtual CL_PixelBuffer get_pixelbuffer() const =0;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tile_selection.cpp (from rev 712, trunk/flexlay/lib/tile_selection.cxx)
===================================================================
--- trunk/flexlay/lib/tile_selection.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_selection.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,138 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <ClanLib/Display/display.h>
+#include <iostream>
+#include <ClanLib/Core/core_iostream.h>
+#include "math.hpp"
+#include "tilemap_layer.hpp"
+#include "tileset.hpp"
+#include "tile_selection.hpp"
+
+class TileSelectionImpl
+{
+public:
+  TilemapLayer tilemap;
+  CL_Point start_pos;
+  CL_Rect  selection;
+  bool active;
+};
+
+TileSelection::TileSelection()
+  : impl(new TileSelectionImpl())
+{
+  impl->active = false;
+}
+
+TileSelection::~TileSelection()
+{
+}
+
+void
+TileSelection::start(TilemapLayer tilemap_, const CL_Point& pos)
+{
+  impl->tilemap = tilemap_;
+  impl->active = true;
+  impl->start_pos = pos;
+  update(impl->start_pos);
+}
+
+void
+TileSelection::update(const CL_Point& pos)
+{
+  impl->selection = CL_Rect(std::min(impl->start_pos.x, pos.x),
+                            std::min(impl->start_pos.y, pos.y),
+                            std::max(impl->start_pos.x, pos.x) + 1,
+                            std::max(impl->start_pos.y, pos.y) + 1);
+}
+
+bool
+TileSelection::is_active()
+{
+  return impl->active;
+}
+
+void
+TileSelection::clear()
+{
+  impl->selection = CL_Rect();
+  impl->active = false;
+}
+
+void
+TileSelection::draw(const CL_Color& color)
+{
+  int tile_size = impl->tilemap.get_tileset().get_tile_size();
+
+  CL_Display::fill_rect(CL_Rect(impl->selection.left   * tile_size, 
+                                impl->selection.top    * tile_size,
+                                impl->selection.right  * tile_size, 
+                                impl->selection.bottom * tile_size),
+                        color);
+}
+
+TileBrush
+TileSelection::get_brush(const Field<int>& field) const
+{
+  CL_Rect sel = impl->selection;
+
+  sel.normalize();
+
+  if (sel.left     > field.get_width() - 1
+      || sel.top   > field.get_height() - 1
+      || sel.right  <= 0
+      || sel.bottom <= 0)
+    { // Selection is empty
+      std::cout << "Error: Invalid selection" << std::endl;
+      TileBrush brush(1, 1);
+      brush.at(0, 0) = 0;
+      brush.set_opaque();
+      return brush;
+    }
+  else
+    { // Selection is valid
+      // Cut the selection to the field size
+      sel.left = Math::max(0, sel.left);
+      sel.top  = Math::max(0, sel.top);
+
+      sel.right  = Math::min(sel.right,  field.get_width()); 
+      sel.bottom = Math::min(sel.bottom, field.get_height()); 
+
+      TileBrush brush(sel.get_width(), 
+                      sel.get_height());
+
+      for(int y = sel.top; y < sel.bottom; ++y)
+        for(int x = sel.left; x < sel.right; ++x)
+          {
+            brush.at(x - sel.left, 
+                     y - sel.top) = field.at(x, y);
+          }
+
+      return brush;
+    }
+}
+
+CL_Rect
+TileSelection::get_rect() const
+{
+  CL_Rect sel = impl->selection;
+  sel.normalize();
+  return sel;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tile_selection.cxx
===================================================================
--- trunk/flexlay/lib/tile_selection.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_selection.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,138 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <ClanLib/Display/display.h>
-#include <iostream>
-#include <ClanLib/Core/core_iostream.h>
-#include "math.hxx"
-#include "tilemap_layer.hxx"
-#include "tileset.hxx"
-#include "tile_selection.hxx"
-
-class TileSelectionImpl
-{
-public:
-  TilemapLayer tilemap;
-  CL_Point start_pos;
-  CL_Rect  selection;
-  bool active;
-};
-
-TileSelection::TileSelection()
-  : impl(new TileSelectionImpl())
-{
-  impl->active = false;
-}
-
-TileSelection::~TileSelection()
-{
-}
-
-void
-TileSelection::start(TilemapLayer tilemap_, const CL_Point& pos)
-{
-  impl->tilemap = tilemap_;
-  impl->active = true;
-  impl->start_pos = pos;
-  update(impl->start_pos);
-}
-
-void
-TileSelection::update(const CL_Point& pos)
-{
-  impl->selection = CL_Rect(std::min(impl->start_pos.x, pos.x),
-                            std::min(impl->start_pos.y, pos.y),
-                            std::max(impl->start_pos.x, pos.x) + 1,
-                            std::max(impl->start_pos.y, pos.y) + 1);
-}
-
-bool
-TileSelection::is_active()
-{
-  return impl->active;
-}
-
-void
-TileSelection::clear()
-{
-  impl->selection = CL_Rect();
-  impl->active = false;
-}
-
-void
-TileSelection::draw(const CL_Color& color)
-{
-  int tile_size = impl->tilemap.get_tileset().get_tile_size();
-
-  CL_Display::fill_rect(CL_Rect(impl->selection.left   * tile_size, 
-                                impl->selection.top    * tile_size,
-                                impl->selection.right  * tile_size, 
-                                impl->selection.bottom * tile_size),
-                        color);
-}
-
-TileBrush
-TileSelection::get_brush(const Field<int>& field) const
-{
-  CL_Rect sel = impl->selection;
-
-  sel.normalize();
-
-  if (sel.left     > field.get_width() - 1
-      || sel.top   > field.get_height() - 1
-      || sel.right  <= 0
-      || sel.bottom <= 0)
-    { // Selection is empty
-      std::cout << "Error: Invalid selection" << std::endl;
-      TileBrush brush(1, 1);
-      brush.at(0, 0) = 0;
-      brush.set_opaque();
-      return brush;
-    }
-  else
-    { // Selection is valid
-      // Cut the selection to the field size
-      sel.left = Math::max(0, sel.left);
-      sel.top  = Math::max(0, sel.top);
-
-      sel.right  = Math::min(sel.right,  field.get_width()); 
-      sel.bottom = Math::min(sel.bottom, field.get_height()); 
-
-      TileBrush brush(sel.get_width(), 
-                      sel.get_height());
-
-      for(int y = sel.top; y < sel.bottom; ++y)
-        for(int x = sel.left; x < sel.right; ++x)
-          {
-            brush.at(x - sel.left, 
-                     y - sel.top) = field.at(x, y);
-          }
-
-      return brush;
-    }
-}
-
-CL_Rect
-TileSelection::get_rect() const
-{
-  CL_Rect sel = impl->selection;
-  sel.normalize();
-  return sel;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tile_selection.hpp (from rev 712, trunk/flexlay/lib/tile_selection.hxx)
===================================================================
--- trunk/flexlay/lib/tile_selection.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_selection.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,57 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_TILE_SELECTION_HXX
+#define HEADER_TILE_SELECTION_HXX
+
+#include <ClanLib/Core/Math/rect.h>
+#include <ClanLib/Display/color.h>
+#include <ClanLib/Core/Math/point.h>
+#include "tile_brush.hpp"
+#include "tilemap_layer.hpp"
+
+class TileSelectionImpl;
+
+/** The TileSelection is a little helper class to manage rectangular
+    selections of tiles and provides a way to convert this selection
+    to a Brush which then can be used for either serialisation or be
+    used for painting on the map itself */
+class TileSelection
+{
+public:
+  TileSelection();
+  ~TileSelection();
+
+  void start (TilemapLayer tilemap, const CL_Point& pos);
+  void update(const CL_Point& pos);
+
+  void clear();
+  bool is_active();
+
+  CL_Rect get_rect() const;
+
+  void draw(const CL_Color& color = CL_Color(255, 255, 255, 100));
+
+  TileBrush get_brush(const Field<int>& field) const;
+private:
+  SharedPtr<TileSelectionImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tile_selection.hxx
===================================================================
--- trunk/flexlay/lib/tile_selection.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_selection.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,57 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_TILE_SELECTION_HXX
-#define HEADER_TILE_SELECTION_HXX
-
-#include <ClanLib/Core/Math/rect.h>
-#include <ClanLib/Display/color.h>
-#include <ClanLib/Core/Math/point.h>
-#include "tile_brush.hxx"
-#include "tilemap_layer.hxx"
-
-class TileSelectionImpl;
-
-/** The TileSelection is a little helper class to manage rectangular
-    selections of tiles and provides a way to convert this selection
-    to a Brush which then can be used for either serialisation or be
-    used for painting on the map itself */
-class TileSelection
-{
-public:
-  TileSelection();
-  ~TileSelection();
-
-  void start (TilemapLayer tilemap, const CL_Point& pos);
-  void update(const CL_Point& pos);
-
-  void clear();
-  bool is_active();
-
-  CL_Rect get_rect() const;
-
-  void draw(const CL_Color& color = CL_Color(255, 255, 255, 100));
-
-  TileBrush get_brush(const Field<int>& field) const;
-private:
-  SharedPtr<TileSelectionImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tile_selector.cpp (from rev 712, trunk/flexlay/lib/tile_selector.cxx)
===================================================================
--- trunk/flexlay/lib/tile_selector.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_selector.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,261 @@
+//  $Id: tile_selector.cxx,v 1.7 2003/09/23 19:10:05 grumbel Exp $
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include <ClanLib/display.h>
+#include <ClanLib/core.h>
+#include "math.hpp"
+#include "tileset.hpp"
+#include "tile.hpp"
+#include "tile_selector.hpp"
+#include "tools/tilemap_paint_tool.hpp"
+
+TileSelector::TileSelector(const CL_Rect& rect, CL_Component* parent)
+  : CL_Component(rect, parent),
+    width(1)
+{
+  index = 0;
+
+  slots.connect(sig_paint(),      this, &TileSelector::draw);
+  slots.connect(sig_mouse_move(), this, &TileSelector::mouse_move);
+  slots.connect(sig_mouse_down(), this, &TileSelector::mouse_down);
+  slots.connect(sig_mouse_up  (), this, &TileSelector::mouse_up);
+ 
+  scale = 1.0f;
+  mouse_over_tile = -1;
+  scrolling = false;
+  region_select = false;
+  offset = 0;
+}
+
+TileSelector::~TileSelector()
+{
+  std::cout << "~TileSelector()" << std::endl;
+}
+
+CL_Rect 
+TileSelector::get_selection()
+{
+  CL_Rect selection(current_pos.x, current_pos.y, 
+                    region_select_start.x, region_select_start.y);
+
+  selection.normalize();
+  selection.right  += 1;
+  selection.bottom += 1;
+
+  selection.left  = Math::mid(0, selection.left, width);
+  selection.right = Math::mid(0, selection.right, width);
+
+  selection.top    = Math::max(0, selection.top);
+  
+  return selection;
+}
+
+void
+TileSelector::mouse_up(const CL_InputEvent& event)
+{
+  if (event.id == CL_MOUSE_MIDDLE)
+    {
+      scrolling = false;
+      release_mouse();
+    }
+  else if (event.id == CL_MOUSE_RIGHT)
+    {
+      release_mouse();
+      region_select = false;
+
+      CL_Rect selection = get_selection();
+      //selection.bottom = Math::mid(0, selection.right, width);
+
+      TileBrush brush(selection.get_width(), selection.get_height());
+      brush.set_transparent();
+
+      for(int y = 0; y < selection.get_height(); ++y)
+        for(int x = 0; x < selection.get_width(); ++x)
+          {
+            int tile = (selection.top + y) * width + (selection.left + x);
+
+            if (tile >= 0 && tile < int(tiles.size()))
+              brush.at(x, y) = tiles[tile];
+            else
+              brush.at(x, y) = 0;
+          }
+
+      TileMapPaintTool::current().set_brush(brush);
+    }
+}
+
+void
+TileSelector::mouse_down(const CL_InputEvent& event)
+{
+  if (event.id == CL_MOUSE_LEFT)
+    {
+      TileBrush brush(1, 1);
+
+      brush.set_opaque();
+      if (mouse_over_tile >= 0 && mouse_over_tile < int(tiles.size()))
+        brush.at(0, 0) = tiles[mouse_over_tile];
+      else
+        brush.at(0, 0) = 0;
+
+      TileMapPaintTool::current().set_brush(brush);
+    }
+  else if (event.id == CL_MOUSE_RIGHT) 
+    {
+      region_select = true;
+      region_select_start = current_pos;
+      capture_mouse();
+    }
+  else if (event.id == CL_MOUSE_MIDDLE)
+    {
+      scrolling = true;
+      mouse_pos = event.mouse_pos;
+      old_offset = offset;
+      capture_mouse();
+    }
+  else if (event.id == CL_MOUSE_WHEEL_UP)
+    {
+      offset -= static_cast<int>(tileset.get_tile_size()*scale);
+      if (offset < 0)
+        offset = 0;
+    }
+  else if (event.id == CL_MOUSE_WHEEL_DOWN)
+    {
+      offset += static_cast<int>(tileset.get_tile_size()*scale);
+    }
+}
+
+CL_Point
+TileSelector::get_mouse_tile_pos(const CL_InputEvent& event)
+{
+  return CL_Point(event.mouse_pos.x/static_cast<int>(tileset.get_tile_size()*scale),
+                  (event.mouse_pos.y+offset)/static_cast<int>(tileset.get_tile_size()*scale));
+}
+
+void
+TileSelector::mouse_move(const CL_InputEvent& event)
+{
+  CL_Point pos = get_mouse_tile_pos(event);
+  current_pos = pos;
+  mouse_over_tile = pos.y * width + pos.x;
+
+  if (scrolling)
+    {
+      offset = old_offset + (mouse_pos.y - event.mouse_pos.y);
+      if (offset < 0)
+        offset = 0;
+    }
+}
+
+void 
+TileSelector::draw()
+{
+  CL_Display::push_cliprect(get_screen_rect());
+  CL_Display::push_modelview();
+  CL_Display::add_translate(get_screen_x(), get_screen_y());
+  CL_Display::add_translate(0, -offset);
+
+  const TileBrush& brush = TileMapPaintTool::current().get_brush();
+
+  int start_row = offset / int(tileset.get_tile_size() * scale);
+  int end_row   = start_row + (get_screen_rect().get_height() / int(tileset.get_tile_size() * scale));
+  int end_index = std::min(end_row*width, int(tiles.size())); 
+  
+  // Draw tiles
+  for(int i = (start_row*width); i < end_index; ++i)
+    {
+      int x = i % width;
+      int y = i / width;
+
+      Tile* tile = tileset.create(tiles[i]);
+
+      CL_Rect rect(CL_Point(static_cast<int>(x * tileset.get_tile_size()*scale),
+                            static_cast<int>(y * tileset.get_tile_size()*scale)),
+                   CL_Size(static_cast<int>(tileset.get_tile_size()*scale),
+                           static_cast<int>(tileset.get_tile_size()*scale)));
+
+      if (tile)
+        {
+          CL_Sprite sprite = tile->get_sprite();
+
+          sprite.set_scale(scale, scale);
+
+          sprite.draw(static_cast<int>(x * tileset.get_tile_size()*scale), 
+                      static_cast<int>(y * tileset.get_tile_size()*scale));
+
+          // Use grid in the tileselector
+          //CL_Display::draw_rect(rect, CL_Color(0,0,0,128));
+        }
+
+      if (brush.get_width() == 1 && brush.get_height() == 1
+          && brush.at(0, 0) == tiles[i])
+        {
+          CL_Display::fill_rect(rect,
+                                CL_Color(0,0,255, 100));
+        }
+      else if (mouse_over_tile == int(i) && has_mouse_over())
+        {
+          CL_Display::fill_rect(rect, CL_Color(0,0,255, 20));
+        }
+    }
+
+  if (region_select)
+    {
+      CL_Rect rect = get_selection();
+
+      rect.top    *= static_cast<int>(tileset.get_tile_size()*scale);
+      rect.bottom *= static_cast<int>(tileset.get_tile_size()*scale);
+      rect.left   *= static_cast<int>(tileset.get_tile_size()*scale);
+      rect.right  *= static_cast<int>(tileset.get_tile_size()*scale);
+
+      CL_Display::fill_rect(rect, CL_Color(0,0,255, 100));
+    }
+  
+  CL_Display::pop_modelview();
+  CL_Display::pop_cliprect();
+}
+
+void
+TileSelector::set_scale(float s)
+{
+  scale = s;
+  width  = static_cast<int>(get_width()/(tileset.get_tile_size() * scale));
+}
+
+TileSelector::Tiles
+TileSelector::get_tiles() const
+{
+  return tiles;
+}
+
+void
+TileSelector::set_tileset(Tileset t)
+{
+  tileset = t;
+  // Recalc the number of tiles in a row
+  width  = static_cast<int>(get_width()/(tileset.get_tile_size() * scale));
+}
+
+void
+TileSelector::set_tiles(const Tiles& t)
+{
+  tiles = t;
+  offset = 0;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tile_selector.cxx
===================================================================
--- trunk/flexlay/lib/tile_selector.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_selector.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,261 +0,0 @@
-//  $Id: tile_selector.cxx,v 1.7 2003/09/23 19:10:05 grumbel Exp $
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <ClanLib/display.h>
-#include <ClanLib/core.h>
-#include "math.hxx"
-#include "tileset.hxx"
-#include "tile.hxx"
-#include "tile_selector.hxx"
-#include "tools/tilemap_paint_tool.hxx"
-
-TileSelector::TileSelector(const CL_Rect& rect, CL_Component* parent)
-  : CL_Component(rect, parent),
-    width(1)
-{
-  index = 0;
-
-  slots.connect(sig_paint(),      this, &TileSelector::draw);
-  slots.connect(sig_mouse_move(), this, &TileSelector::mouse_move);
-  slots.connect(sig_mouse_down(), this, &TileSelector::mouse_down);
-  slots.connect(sig_mouse_up  (), this, &TileSelector::mouse_up);
- 
-  scale = 1.0f;
-  mouse_over_tile = -1;
-  scrolling = false;
-  region_select = false;
-  offset = 0;
-}
-
-TileSelector::~TileSelector()
-{
-  std::cout << "~TileSelector()" << std::endl;
-}
-
-CL_Rect 
-TileSelector::get_selection()
-{
-  CL_Rect selection(current_pos.x, current_pos.y, 
-                    region_select_start.x, region_select_start.y);
-
-  selection.normalize();
-  selection.right  += 1;
-  selection.bottom += 1;
-
-  selection.left  = Math::mid(0, selection.left, width);
-  selection.right = Math::mid(0, selection.right, width);
-
-  selection.top    = Math::max(0, selection.top);
-  
-  return selection;
-}
-
-void
-TileSelector::mouse_up(const CL_InputEvent& event)
-{
-  if (event.id == CL_MOUSE_MIDDLE)
-    {
-      scrolling = false;
-      release_mouse();
-    }
-  else if (event.id == CL_MOUSE_RIGHT)
-    {
-      release_mouse();
-      region_select = false;
-
-      CL_Rect selection = get_selection();
-      //selection.bottom = Math::mid(0, selection.right, width);
-
-      TileBrush brush(selection.get_width(), selection.get_height());
-      brush.set_transparent();
-
-      for(int y = 0; y < selection.get_height(); ++y)
-        for(int x = 0; x < selection.get_width(); ++x)
-          {
-            int tile = (selection.top + y) * width + (selection.left + x);
-
-            if (tile >= 0 && tile < int(tiles.size()))
-              brush.at(x, y) = tiles[tile];
-            else
-              brush.at(x, y) = 0;
-          }
-
-      TileMapPaintTool::current().set_brush(brush);
-    }
-}
-
-void
-TileSelector::mouse_down(const CL_InputEvent& event)
-{
-  if (event.id == CL_MOUSE_LEFT)
-    {
-      TileBrush brush(1, 1);
-
-      brush.set_opaque();
-      if (mouse_over_tile >= 0 && mouse_over_tile < int(tiles.size()))
-        brush.at(0, 0) = tiles[mouse_over_tile];
-      else
-        brush.at(0, 0) = 0;
-
-      TileMapPaintTool::current().set_brush(brush);
-    }
-  else if (event.id == CL_MOUSE_RIGHT) 
-    {
-      region_select = true;
-      region_select_start = current_pos;
-      capture_mouse();
-    }
-  else if (event.id == CL_MOUSE_MIDDLE)
-    {
-      scrolling = true;
-      mouse_pos = event.mouse_pos;
-      old_offset = offset;
-      capture_mouse();
-    }
-  else if (event.id == CL_MOUSE_WHEEL_UP)
-    {
-      offset -= static_cast<int>(tileset.get_tile_size()*scale);
-      if (offset < 0)
-        offset = 0;
-    }
-  else if (event.id == CL_MOUSE_WHEEL_DOWN)
-    {
-      offset += static_cast<int>(tileset.get_tile_size()*scale);
-    }
-}
-
-CL_Point
-TileSelector::get_mouse_tile_pos(const CL_InputEvent& event)
-{
-  return CL_Point(event.mouse_pos.x/static_cast<int>(tileset.get_tile_size()*scale),
-                  (event.mouse_pos.y+offset)/static_cast<int>(tileset.get_tile_size()*scale));
-}
-
-void
-TileSelector::mouse_move(const CL_InputEvent& event)
-{
-  CL_Point pos = get_mouse_tile_pos(event);
-  current_pos = pos;
-  mouse_over_tile = pos.y * width + pos.x;
-
-  if (scrolling)
-    {
-      offset = old_offset + (mouse_pos.y - event.mouse_pos.y);
-      if (offset < 0)
-        offset = 0;
-    }
-}
-
-void 
-TileSelector::draw()
-{
-  CL_Display::push_cliprect(get_screen_rect());
-  CL_Display::push_modelview();
-  CL_Display::add_translate(get_screen_x(), get_screen_y());
-  CL_Display::add_translate(0, -offset);
-
-  const TileBrush& brush = TileMapPaintTool::current().get_brush();
-
-  int start_row = offset / int(tileset.get_tile_size() * scale);
-  int end_row   = start_row + (get_screen_rect().get_height() / int(tileset.get_tile_size() * scale));
-  int end_index = std::min(end_row*width, int(tiles.size())); 
-  
-  // Draw tiles
-  for(int i = (start_row*width); i < end_index; ++i)
-    {
-      int x = i % width;
-      int y = i / width;
-
-      Tile* tile = tileset.create(tiles[i]);
-
-      CL_Rect rect(CL_Point(static_cast<int>(x * tileset.get_tile_size()*scale),
-                            static_cast<int>(y * tileset.get_tile_size()*scale)),
-                   CL_Size(static_cast<int>(tileset.get_tile_size()*scale),
-                           static_cast<int>(tileset.get_tile_size()*scale)));
-
-      if (tile)
-        {
-          CL_Sprite sprite = tile->get_sprite();
-
-          sprite.set_scale(scale, scale);
-
-          sprite.draw(static_cast<int>(x * tileset.get_tile_size()*scale), 
-                      static_cast<int>(y * tileset.get_tile_size()*scale));
-
-          // Use grid in the tileselector
-          //CL_Display::draw_rect(rect, CL_Color(0,0,0,128));
-        }
-
-      if (brush.get_width() == 1 && brush.get_height() == 1
-          && brush.at(0, 0) == tiles[i])
-        {
-          CL_Display::fill_rect(rect,
-                                CL_Color(0,0,255, 100));
-        }
-      else if (mouse_over_tile == int(i) && has_mouse_over())
-        {
-          CL_Display::fill_rect(rect, CL_Color(0,0,255, 20));
-        }
-    }
-
-  if (region_select)
-    {
-      CL_Rect rect = get_selection();
-
-      rect.top    *= static_cast<int>(tileset.get_tile_size()*scale);
-      rect.bottom *= static_cast<int>(tileset.get_tile_size()*scale);
-      rect.left   *= static_cast<int>(tileset.get_tile_size()*scale);
-      rect.right  *= static_cast<int>(tileset.get_tile_size()*scale);
-
-      CL_Display::fill_rect(rect, CL_Color(0,0,255, 100));
-    }
-  
-  CL_Display::pop_modelview();
-  CL_Display::pop_cliprect();
-}
-
-void
-TileSelector::set_scale(float s)
-{
-  scale = s;
-  width  = static_cast<int>(get_width()/(tileset.get_tile_size() * scale));
-}
-
-TileSelector::Tiles
-TileSelector::get_tiles() const
-{
-  return tiles;
-}
-
-void
-TileSelector::set_tileset(Tileset t)
-{
-  tileset = t;
-  // Recalc the number of tiles in a row
-  width  = static_cast<int>(get_width()/(tileset.get_tile_size() * scale));
-}
-
-void
-TileSelector::set_tiles(const Tiles& t)
-{
-  tiles = t;
-  offset = 0;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tile_selector.hpp (from rev 712, trunk/flexlay/lib/tile_selector.hxx)
===================================================================
--- trunk/flexlay/lib/tile_selector.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_selector.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,81 @@
+//  $Id: tile_selector.hpp,v 1.2 2003/09/10 13:53:11 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2000 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef TILESELECTOR_HXX
+#define TILESELECTOR_HXX
+
+#include <ClanLib/gui.h>
+#include "tileset.hpp"
+
+class Tileset;
+
+class TileSelector : public CL_Component
+{
+public:
+  typedef std::vector<int> Tiles;
+  
+private:
+  CL_SlotContainer slots;
+  int width;
+  int index;
+  
+  int offset;
+  int old_offset;
+  int mouse_over_tile;
+  bool scrolling;
+  bool region_select;
+  CL_Point current_pos;
+  CL_Point region_select_start;
+  CL_Point mouse_pos;
+  float scale;
+  
+  /** set of tiles that should be available in the TileSelector */
+  Tiles tiles;
+
+  Tileset tileset;
+
+protected:
+  virtual ~TileSelector();
+public:
+  /** width and height in number of tiles */
+  TileSelector(const CL_Rect& rect, CL_Component* parent);
+  
+  void set_tileset(Tileset t);
+  void set_tiles(const Tiles& t);
+  Tiles get_tiles() const;
+  
+  /** Set the factor by which tiles are scaled down in the selector
+      widged (ie. for better overview) */
+  void set_scale(float s);
+
+  void draw();
+
+  /** Return the position of the mouse in x/y in tilesize */
+  CL_Point get_mouse_tile_pos(const CL_InputEvent& event);
+
+private:
+  CL_Rect get_selection();
+
+  void mouse_move(const CL_InputEvent& event);
+  void mouse_down(const CL_InputEvent& event);
+  void mouse_up  (const CL_InputEvent& event);
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tile_selector.hxx
===================================================================
--- trunk/flexlay/lib/tile_selector.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tile_selector.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,81 +0,0 @@
-//  $Id: tile_selector.hxx,v 1.2 2003/09/10 13:53:11 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2000 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef TILESELECTOR_HXX
-#define TILESELECTOR_HXX
-
-#include <ClanLib/gui.h>
-#include "tileset.hxx"
-
-class Tileset;
-
-class TileSelector : public CL_Component
-{
-public:
-  typedef std::vector<int> Tiles;
-  
-private:
-  CL_SlotContainer slots;
-  int width;
-  int index;
-  
-  int offset;
-  int old_offset;
-  int mouse_over_tile;
-  bool scrolling;
-  bool region_select;
-  CL_Point current_pos;
-  CL_Point region_select_start;
-  CL_Point mouse_pos;
-  float scale;
-  
-  /** set of tiles that should be available in the TileSelector */
-  Tiles tiles;
-
-  Tileset tileset;
-
-protected:
-  virtual ~TileSelector();
-public:
-  /** width and height in number of tiles */
-  TileSelector(const CL_Rect& rect, CL_Component* parent);
-  
-  void set_tileset(Tileset t);
-  void set_tiles(const Tiles& t);
-  Tiles get_tiles() const;
-  
-  /** Set the factor by which tiles are scaled down in the selector
-      widged (ie. for better overview) */
-  void set_scale(float s);
-
-  void draw();
-
-  /** Return the position of the mouse in x/y in tilesize */
-  CL_Point get_mouse_tile_pos(const CL_InputEvent& event);
-
-private:
-  CL_Rect get_selection();
-
-  void mouse_move(const CL_InputEvent& event);
-  void mouse_down(const CL_InputEvent& event);
-  void mouse_up  (const CL_InputEvent& event);
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tilemap_layer.cpp (from rev 712, trunk/flexlay/lib/tilemap_layer.cxx)
===================================================================
--- trunk/flexlay/lib/tilemap_layer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tilemap_layer.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,423 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <math.h>
+#include <ClanLib/Display/display.h>
+#include <ClanLib/Display/pixel_buffer.h>
+#include <ClanLib/Display/pixel_format.h>
+#include <ClanLib/Display/palette.h>
+#include <ClanLib/gl.h>
+#include "tile.hpp"
+#include "tileset.hpp"
+#include "editor_map.hpp"
+#include "tile_brush.hpp"
+#include "editor_map_component.hpp"
+#include "editor_map_component.hpp"
+#include "blitter.hpp"
+#include "layer_impl.hpp"
+#include "editor_map_component.hpp"
+#include "tilemap_layer.hpp"
+
+TilemapLayer TilemapLayer::current_;
+
+class TilemapLayerImpl : public LayerImpl
+{
+public:
+  Tileset tileset;
+  CL_Color background_color;
+  CL_Color foreground_color;
+  bool hex_mode;
+
+  Field<int> field;
+
+  bool draw_grid;
+  bool draw_attribute;
+
+  MetaData metadata;
+
+  TilemapLayerImpl() {}
+  virtual ~TilemapLayerImpl() {}
+
+  bool has_bounding_rect() const;
+  CL_Rect get_bounding_rect();
+  void draw(EditorMapComponent* parent, CL_GraphicContext* gc);
+};
+
+TilemapLayer::TilemapLayer()
+{
+}
+
+/*TilemapLayer::TilemapLayer(const SharedPtr<TilemapLayerImpl>& i)
+  : impl(i)
+{
+}*/
+
+TilemapLayer::TilemapLayer(Tileset tileset_, int w,  int h)
+  : impl(new TilemapLayerImpl())
+{
+  impl->field = Field<int>(w, h);
+
+  // FIXME: Move this to the widget or to some more generic
+  // map-properties thingy
+  impl->draw_grid      = false;
+  impl->draw_attribute = false;
+  impl->hex_mode = false;
+
+  for (int y = 0; y < impl->field.get_height(); ++y) 
+    for (int x = 0; x < impl->field.get_width(); ++x)
+      impl->field.at(x, y) = 0;
+
+  impl->background_color = CL_Color(0, 0, 0, 0);
+  impl->foreground_color = CL_Color(255, 255, 255, 255);
+  
+  impl->tileset = tileset_;
+}
+
+TilemapLayer::~TilemapLayer()
+{
+}
+
+void
+TilemapLayer::draw(EditorMapComponent* parent, CL_GraphicContext* gc)
+{
+  impl->draw(parent, gc);
+}
+
+void
+TilemapLayerImpl::draw(EditorMapComponent* parent, CL_GraphicContext* gc)
+{
+  int tile_size = this->tileset.get_tile_size();
+
+  if (this->background_color.get_alpha() != 0)
+    CL_Display::fill_rect(CL_Rect(CL_Point(0,0),
+                                  CL_Size(this->field.get_width()  * tile_size,
+                                          this->field.get_height() * tile_size)),
+                          this->background_color);
+  CL_Display::flush();
+
+  CL_Rect rect(parent->get_clip_rect());
+
+  int start_x = std::max(0, rect.left / tile_size);
+  int start_y = std::max(0, rect.top  / tile_size);
+  int end_x   = std::min(this->field.get_width(),  rect.right  / tile_size + 1);
+  int end_y   = std::min(this->field.get_height(), rect.bottom / tile_size + 1);
+
+  if (foreground_color != CL_Color(255, 255, 255, 255))
+    {
+      for (int y = start_y; y < end_y; ++y)
+        for (int x = start_x; x < end_x; ++x)
+          {
+            int tile_id = this->field.at(x, y);
+            if (tile_id)
+              {
+                Tile* tile = tileset.create(tile_id);
+                if (tile) // skip transparent tile for faster draw
+                  {           
+                    CL_Sprite sprite = tile->get_sprite();
+                    sprite.set_color(foreground_color);
+                    sprite.draw(x * tile_size, y * tile_size, gc);
+      
+                    if (draw_attribute)
+                      CL_Display::fill_rect(CL_Rect(CL_Point(x, y), CL_Size(tileset.get_tile_size(),
+                                                                            tileset.get_tile_size())),
+                                            tile->get_attribute_color());
+                  }
+              }
+          }
+    }
+  else
+    {
+      for (int y = start_y; y < end_y; ++y)
+        for (int x = start_x; x < end_x; ++x)
+          {
+            int tile_id = this->field.at(x, y);
+            if (tile_id) // skip transparent tile for faster draw
+              {
+                Tile* tile = tileset.create(this->field.at(x, y));
+                if (tile)
+                  {           
+                    tile->get_sprite().draw(x * tile_size, y * tile_size, gc);
+      
+                    if (draw_attribute)
+                      CL_Display::fill_rect(CL_Rect(CL_Point(x, y), CL_Size(tileset.get_tile_size(),
+                                                                            tileset.get_tile_size())),
+                                            tile->get_attribute_color());
+                  }
+              }
+          }
+    }
+
+  if (this->draw_grid)
+    {
+      for (int y = start_y; y <= end_y; ++y)
+        CL_Display::draw_line(start_x * tile_size,
+                              y       * tile_size,
+                              end_x   * tile_size,
+                              y       * tile_size, 
+                              y % 2 ? CL_Color(150, 150, 150) : CL_Color(255, 255, 255));
+  
+      for (int x = start_x; x <= end_x; ++x)
+        CL_Display::draw_line(x       * tile_size,
+                              start_y * tile_size,
+                              x       * tile_size,
+                              end_y   * tile_size, 
+                              x % 2 ? CL_Color(150, 150, 150) : CL_Color(255, 255, 255));
+    }
+
+  CL_Display::flush();
+}
+
+int
+TilemapLayer::get_tile (int x, int y)
+{
+  if (x >= 0 && x < (int)impl->field.get_width() &&
+      y >= 0 && y < (int)impl->field.get_height())
+    return impl->field.at(x, y);
+  else
+    return 0;
+}
+
+void
+TilemapLayer::resize(const CL_Size& size, const CL_Point& point)
+{
+  impl->field.resize(size.width, size.height, point.x, point.y);
+}
+
+void
+TilemapLayer::draw_tile(int id, const CL_Point& pos)
+{
+  if (pos.x >= 0 && pos.x < impl->field.get_width()
+      && pos.y >= 0 && pos.y < impl->field.get_height())
+    {
+      impl->field.at(pos.x, pos.y) = id;
+    }
+}
+
+void
+TilemapLayer::draw_tile(const TileBrush& brush, const CL_Point& pos)
+{
+  draw_tiles(&impl->field, brush, pos);
+}
+
+void
+TilemapLayer::draw_tiles(Field<int>* field, const TileBrush& brush, const CL_Point& pos)
+{
+  int start_x = std::max(0, -pos.x);
+  int start_y = std::max(0, -pos.y);
+
+  int end_x = std::min(brush.get_width(),  field->get_width()  - pos.x);
+  int end_y = std::min(brush.get_height(), field->get_height() - pos.y);
+
+  for (int y = start_y; y < end_y; ++y)
+    for (int x = start_x; x < end_x; ++x)
+      {
+        if (brush.is_opaque() || brush.at(x, y) != 0)
+          {
+            field->at(pos.x + x, pos.y + y) = brush.at(x, y);
+          }
+      }
+}
+
+void
+TilemapLayer::set_draw_attribute(bool t)
+{
+  impl->draw_attribute = t;
+}
+
+bool
+TilemapLayer::get_draw_attribute() const
+{
+  return impl->draw_attribute;
+}
+
+void
+TilemapLayer::set_draw_grid(bool t)
+{
+  impl->draw_grid = t;
+}
+
+bool
+TilemapLayer::get_draw_grid() const
+{
+  return impl->draw_grid;
+}
+
+CL_PixelBuffer
+TilemapLayer::create_pixelbuffer()
+{
+  int tile_size = impl->tileset.get_tile_size();
+
+  CL_PixelBuffer pixelbuffer(get_width()  * tile_size,
+                             get_height() * tile_size,
+                             get_width()  * tile_size * 4,
+                             CL_PixelFormat::rgba8888);
+
+  {
+    pixelbuffer.lock();
+    unsigned char* buf = static_cast<unsigned char*>(pixelbuffer.get_data());
+
+    int width  = pixelbuffer.get_width();
+    int height = pixelbuffer.get_height();
+
+    // Draw a nice gradient
+    for(int y = 0; y < height; ++y)
+      {
+        for (int x = 0; x < width; ++x)
+          {
+            buf[4*(y*width + x) + 0] = 255;
+            buf[4*(y*width + x) + 1] = 255;
+            buf[4*(y*width + x) + 2] = 255*y/height;
+            buf[4*(y*width + x) + 3] = 255*y/height;
+          }
+      }
+    pixelbuffer.unlock();
+  }
+
+  for (int y = 0; y < get_height(); ++y)
+    for (int x = 0; x < get_width(); ++x)
+      {
+        Tile* tile = impl->tileset.create(impl->field.at(x, y));
+
+        if (tile)
+          {
+            CL_PixelBuffer buf = tile->get_pixelbuffer();
+            if (buf)
+              {
+                blit(pixelbuffer, buf, x*tile_size, y*tile_size);
+              }
+          }
+      }
+
+  return pixelbuffer;
+}
+
+CL_Rect
+TilemapLayer::get_bounding_rect()
+{
+  return impl->get_bounding_rect();
+}
+
+CL_Rect
+TilemapLayerImpl::get_bounding_rect()
+{
+  return CL_Rect(CL_Point(0, 0),
+                 CL_Size(field.get_width()  * tileset.get_tile_size(), 
+                         field.get_height() * tileset.get_tile_size()));
+}
+
+CL_Point
+TilemapLayer::world2tile(const CL_Pointf& pos) const
+{
+  int x = static_cast<int>(pos.x / impl->tileset.get_tile_size());
+  int y = static_cast<int>(pos.y / impl->tileset.get_tile_size());
+
+  return CL_Point(pos.x < 0 ? x-1 : x,
+                  pos.y < 0 ? y-1 : y);
+}
+
+Field<int>*
+TilemapLayer::get_field()
+{
+  return &impl->field; 
+}
+
+TilemapLayer
+TilemapLayer::current()
+{
+  return current_; 
+}
+
+void
+TilemapLayer::set_current(TilemapLayer t) 
+{
+  current_ = t;
+}
+
+Tileset
+TilemapLayer::get_tileset()
+{
+  return impl->tileset;
+}
+
+const std::vector<int>&
+TilemapLayer::get_data()
+{
+  return impl->field.get_data();
+}
+
+void
+TilemapLayer::set_data(std::vector<int> d)
+{
+  impl->field.set_data(d);
+}
+
+void 
+TilemapLayer::set_background_color(const CL_Color& color)
+{
+  impl->background_color = color;
+}
+
+void 
+TilemapLayer::set_foreground_color(const CL_Color& color)
+{
+  impl->foreground_color = color;
+}
+
+int
+TilemapLayer::get_width()  const
+{
+  return impl->field.get_width();
+}
+
+int
+TilemapLayer::get_height() const
+{
+  return impl->field.get_height();
+}
+
+bool
+TilemapLayer::has_bounding_rect() const
+{
+  return impl->has_bounding_rect();
+}
+
+bool
+TilemapLayerImpl::has_bounding_rect() const
+{
+  return true;
+}
+
+Layer
+TilemapLayer::to_layer()
+{
+   return Layer(impl);
+}
+
+void
+TilemapLayer::set_metadata(const MetaData& metadata)
+{
+  impl->metadata = metadata;
+}
+
+MetaData
+TilemapLayer::get_metadata() const
+{
+  return impl->metadata;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tilemap_layer.cxx
===================================================================
--- trunk/flexlay/lib/tilemap_layer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tilemap_layer.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,423 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <math.h>
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/pixel_buffer.h>
-#include <ClanLib/Display/pixel_format.h>
-#include <ClanLib/Display/palette.h>
-#include <ClanLib/gl.h>
-#include "tile.hxx"
-#include "tileset.hxx"
-#include "editor_map.hxx"
-#include "tile_brush.hxx"
-#include "editor_map_component.hxx"
-#include "editor_map_component.hxx"
-#include "blitter.hxx"
-#include "layer_impl.hxx"
-#include "editor_map_component.hxx"
-#include "tilemap_layer.hxx"
-
-TilemapLayer TilemapLayer::current_;
-
-class TilemapLayerImpl : public LayerImpl
-{
-public:
-  Tileset tileset;
-  CL_Color background_color;
-  CL_Color foreground_color;
-  bool hex_mode;
-
-  Field<int> field;
-
-  bool draw_grid;
-  bool draw_attribute;
-
-  MetaData metadata;
-
-  TilemapLayerImpl() {}
-  virtual ~TilemapLayerImpl() {}
-
-  bool has_bounding_rect() const;
-  CL_Rect get_bounding_rect();
-  void draw(EditorMapComponent* parent, CL_GraphicContext* gc);
-};
-
-TilemapLayer::TilemapLayer()
-{
-}
-
-/*TilemapLayer::TilemapLayer(const SharedPtr<TilemapLayerImpl>& i)
-  : impl(i)
-{
-}*/
-
-TilemapLayer::TilemapLayer(Tileset tileset_, int w,  int h)
-  : impl(new TilemapLayerImpl())
-{
-  impl->field = Field<int>(w, h);
-
-  // FIXME: Move this to the widget or to some more generic
-  // map-properties thingy
-  impl->draw_grid      = false;
-  impl->draw_attribute = false;
-  impl->hex_mode = false;
-
-  for (int y = 0; y < impl->field.get_height(); ++y) 
-    for (int x = 0; x < impl->field.get_width(); ++x)
-      impl->field.at(x, y) = 0;
-
-  impl->background_color = CL_Color(0, 0, 0, 0);
-  impl->foreground_color = CL_Color(255, 255, 255, 255);
-  
-  impl->tileset = tileset_;
-}
-
-TilemapLayer::~TilemapLayer()
-{
-}
-
-void
-TilemapLayer::draw(EditorMapComponent* parent, CL_GraphicContext* gc)
-{
-  impl->draw(parent, gc);
-}
-
-void
-TilemapLayerImpl::draw(EditorMapComponent* parent, CL_GraphicContext* gc)
-{
-  int tile_size = this->tileset.get_tile_size();
-
-  if (this->background_color.get_alpha() != 0)
-    CL_Display::fill_rect(CL_Rect(CL_Point(0,0),
-                                  CL_Size(this->field.get_width()  * tile_size,
-                                          this->field.get_height() * tile_size)),
-                          this->background_color);
-  CL_Display::flush();
-
-  CL_Rect rect(parent->get_clip_rect());
-
-  int start_x = std::max(0, rect.left / tile_size);
-  int start_y = std::max(0, rect.top  / tile_size);
-  int end_x   = std::min(this->field.get_width(),  rect.right  / tile_size + 1);
-  int end_y   = std::min(this->field.get_height(), rect.bottom / tile_size + 1);
-
-  if (foreground_color != CL_Color(255, 255, 255, 255))
-    {
-      for (int y = start_y; y < end_y; ++y)
-        for (int x = start_x; x < end_x; ++x)
-          {
-            int tile_id = this->field.at(x, y);
-            if (tile_id)
-              {
-                Tile* tile = tileset.create(tile_id);
-                if (tile) // skip transparent tile for faster draw
-                  {           
-                    CL_Sprite sprite = tile->get_sprite();
-                    sprite.set_color(foreground_color);
-                    sprite.draw(x * tile_size, y * tile_size, gc);
-      
-                    if (draw_attribute)
-                      CL_Display::fill_rect(CL_Rect(CL_Point(x, y), CL_Size(tileset.get_tile_size(),
-                                                                            tileset.get_tile_size())),
-                                            tile->get_attribute_color());
-                  }
-              }
-          }
-    }
-  else
-    {
-      for (int y = start_y; y < end_y; ++y)
-        for (int x = start_x; x < end_x; ++x)
-          {
-            int tile_id = this->field.at(x, y);
-            if (tile_id) // skip transparent tile for faster draw
-              {
-                Tile* tile = tileset.create(this->field.at(x, y));
-                if (tile)
-                  {           
-                    tile->get_sprite().draw(x * tile_size, y * tile_size, gc);
-      
-                    if (draw_attribute)
-                      CL_Display::fill_rect(CL_Rect(CL_Point(x, y), CL_Size(tileset.get_tile_size(),
-                                                                            tileset.get_tile_size())),
-                                            tile->get_attribute_color());
-                  }
-              }
-          }
-    }
-
-  if (this->draw_grid)
-    {
-      for (int y = start_y; y <= end_y; ++y)
-        CL_Display::draw_line(start_x * tile_size,
-                              y       * tile_size,
-                              end_x   * tile_size,
-                              y       * tile_size, 
-                              y % 2 ? CL_Color(150, 150, 150) : CL_Color(255, 255, 255));
-  
-      for (int x = start_x; x <= end_x; ++x)
-        CL_Display::draw_line(x       * tile_size,
-                              start_y * tile_size,
-                              x       * tile_size,
-                              end_y   * tile_size, 
-                              x % 2 ? CL_Color(150, 150, 150) : CL_Color(255, 255, 255));
-    }
-
-  CL_Display::flush();
-}
-
-int
-TilemapLayer::get_tile (int x, int y)
-{
-  if (x >= 0 && x < (int)impl->field.get_width() &&
-      y >= 0 && y < (int)impl->field.get_height())
-    return impl->field.at(x, y);
-  else
-    return 0;
-}
-
-void
-TilemapLayer::resize(const CL_Size& size, const CL_Point& point)
-{
-  impl->field.resize(size.width, size.height, point.x, point.y);
-}
-
-void
-TilemapLayer::draw_tile(int id, const CL_Point& pos)
-{
-  if (pos.x >= 0 && pos.x < impl->field.get_width()
-      && pos.y >= 0 && pos.y < impl->field.get_height())
-    {
-      impl->field.at(pos.x, pos.y) = id;
-    }
-}
-
-void
-TilemapLayer::draw_tile(const TileBrush& brush, const CL_Point& pos)
-{
-  draw_tiles(&impl->field, brush, pos);
-}
-
-void
-TilemapLayer::draw_tiles(Field<int>* field, const TileBrush& brush, const CL_Point& pos)
-{
-  int start_x = std::max(0, -pos.x);
-  int start_y = std::max(0, -pos.y);
-
-  int end_x = std::min(brush.get_width(),  field->get_width()  - pos.x);
-  int end_y = std::min(brush.get_height(), field->get_height() - pos.y);
-
-  for (int y = start_y; y < end_y; ++y)
-    for (int x = start_x; x < end_x; ++x)
-      {
-        if (brush.is_opaque() || brush.at(x, y) != 0)
-          {
-            field->at(pos.x + x, pos.y + y) = brush.at(x, y);
-          }
-      }
-}
-
-void
-TilemapLayer::set_draw_attribute(bool t)
-{
-  impl->draw_attribute = t;
-}
-
-bool
-TilemapLayer::get_draw_attribute() const
-{
-  return impl->draw_attribute;
-}
-
-void
-TilemapLayer::set_draw_grid(bool t)
-{
-  impl->draw_grid = t;
-}
-
-bool
-TilemapLayer::get_draw_grid() const
-{
-  return impl->draw_grid;
-}
-
-CL_PixelBuffer
-TilemapLayer::create_pixelbuffer()
-{
-  int tile_size = impl->tileset.get_tile_size();
-
-  CL_PixelBuffer pixelbuffer(get_width()  * tile_size,
-                             get_height() * tile_size,
-                             get_width()  * tile_size * 4,
-                             CL_PixelFormat::rgba8888);
-
-  {
-    pixelbuffer.lock();
-    unsigned char* buf = static_cast<unsigned char*>(pixelbuffer.get_data());
-
-    int width  = pixelbuffer.get_width();
-    int height = pixelbuffer.get_height();
-
-    // Draw a nice gradient
-    for(int y = 0; y < height; ++y)
-      {
-        for (int x = 0; x < width; ++x)
-          {
-            buf[4*(y*width + x) + 0] = 255;
-            buf[4*(y*width + x) + 1] = 255;
-            buf[4*(y*width + x) + 2] = 255*y/height;
-            buf[4*(y*width + x) + 3] = 255*y/height;
-          }
-      }
-    pixelbuffer.unlock();
-  }
-
-  for (int y = 0; y < get_height(); ++y)
-    for (int x = 0; x < get_width(); ++x)
-      {
-        Tile* tile = impl->tileset.create(impl->field.at(x, y));
-
-        if (tile)
-          {
-            CL_PixelBuffer buf = tile->get_pixelbuffer();
-            if (buf)
-              {
-                blit(pixelbuffer, buf, x*tile_size, y*tile_size);
-              }
-          }
-      }
-
-  return pixelbuffer;
-}
-
-CL_Rect
-TilemapLayer::get_bounding_rect()
-{
-  return impl->get_bounding_rect();
-}
-
-CL_Rect
-TilemapLayerImpl::get_bounding_rect()
-{
-  return CL_Rect(CL_Point(0, 0),
-                 CL_Size(field.get_width()  * tileset.get_tile_size(), 
-                         field.get_height() * tileset.get_tile_size()));
-}
-
-CL_Point
-TilemapLayer::world2tile(const CL_Pointf& pos) const
-{
-  int x = static_cast<int>(pos.x / impl->tileset.get_tile_size());
-  int y = static_cast<int>(pos.y / impl->tileset.get_tile_size());
-
-  return CL_Point(pos.x < 0 ? x-1 : x,
-                  pos.y < 0 ? y-1 : y);
-}
-
-Field<int>*
-TilemapLayer::get_field()
-{
-  return &impl->field; 
-}
-
-TilemapLayer
-TilemapLayer::current()
-{
-  return current_; 
-}
-
-void
-TilemapLayer::set_current(TilemapLayer t) 
-{
-  current_ = t;
-}
-
-Tileset
-TilemapLayer::get_tileset()
-{
-  return impl->tileset;
-}
-
-const std::vector<int>&
-TilemapLayer::get_data()
-{
-  return impl->field.get_data();
-}
-
-void
-TilemapLayer::set_data(std::vector<int> d)
-{
-  impl->field.set_data(d);
-}
-
-void 
-TilemapLayer::set_background_color(const CL_Color& color)
-{
-  impl->background_color = color;
-}
-
-void 
-TilemapLayer::set_foreground_color(const CL_Color& color)
-{
-  impl->foreground_color = color;
-}
-
-int
-TilemapLayer::get_width()  const
-{
-  return impl->field.get_width();
-}
-
-int
-TilemapLayer::get_height() const
-{
-  return impl->field.get_height();
-}
-
-bool
-TilemapLayer::has_bounding_rect() const
-{
-  return impl->has_bounding_rect();
-}
-
-bool
-TilemapLayerImpl::has_bounding_rect() const
-{
-  return true;
-}
-
-Layer
-TilemapLayer::to_layer()
-{
-   return Layer(impl);
-}
-
-void
-TilemapLayer::set_metadata(const MetaData& metadata)
-{
-  impl->metadata = metadata;
-}
-
-MetaData
-TilemapLayer::get_metadata() const
-{
-  return impl->metadata;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tilemap_layer.hpp (from rev 712, trunk/flexlay/lib/tilemap_layer.hxx)
===================================================================
--- trunk/flexlay/lib/tilemap_layer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tilemap_layer.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,103 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_TILEMAP_LAYER_HXX
+#define HEADER_TILEMAP_LAYER_HXX
+
+#include <ClanLib/Display/pixel_buffer.h>
+#include "field.hpp"
+#include "meta_data.hpp"
+#include "shared_ptr.hpp"
+#include "layer.hpp"
+
+class Tileset;
+class TileBrush;
+class TilemapLayerImpl;
+class EditorMapComponent;
+
+/** */
+class TilemapLayer
+{
+private:
+  static TilemapLayer current_;
+public:
+  static TilemapLayer current();
+  static void set_current(TilemapLayer t);
+
+  TilemapLayer(); 
+  TilemapLayer(Tileset tileset, int w,  int h);
+  ~TilemapLayer();
+
+  void draw(EditorMapComponent* parent, CL_GraphicContext* gc);
+
+  Tileset get_tileset();
+
+  int  get_tile (int, int);
+
+  Field<int>* get_field();
+
+  /** @param pos position of the old map in the new resized one
+      @param size height of the new map */
+ void resize(const CL_Size& size, const CL_Point& point);
+
+  const std::vector<int>& get_data();
+  void set_data(std::vector<int> d);
+
+  void   set_metadata(const MetaData& obj);
+  MetaData get_metadata() const;
+
+  /** Draw the gives brush to the map */
+  void draw_tile(const TileBrush& brush, const CL_Point& pos);
+
+  /** Draw the given single tile to the map */
+  void draw_tile(int id, const CL_Point& pos);
+
+  int get_width()  const;
+  int get_height() const;
+
+  void set_background_color(const CL_Color& color);
+  void set_foreground_color(const CL_Color& color);
+
+  void set_draw_attribute(bool t);
+  bool get_draw_attribute() const;
+
+  void set_draw_grid(bool t);
+  bool get_draw_grid() const;
+
+  CL_PixelBuffer create_pixelbuffer();
+
+  static void draw_tiles(Field<int>* field, const TileBrush& brush, const CL_Point& pos);
+
+  bool has_bounding_rect() const;
+  CL_Rect get_bounding_rect();
+
+  /** Convert a coordinate given in world position into a tile
+      coordinate */
+  CL_Point world2tile(const CL_Pointf& pos) const;
+
+  bool is_null() const { return !impl.get(); }
+
+  Layer to_layer();
+
+private:
+  SharedPtr<TilemapLayerImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tilemap_layer.hxx
===================================================================
--- trunk/flexlay/lib/tilemap_layer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tilemap_layer.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,103 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_TILEMAP_LAYER_HXX
-#define HEADER_TILEMAP_LAYER_HXX
-
-#include <ClanLib/Display/pixel_buffer.h>
-#include "field.hxx"
-#include "meta_data.hxx"
-#include "shared_ptr.hxx"
-#include "layer.hxx"
-
-class Tileset;
-class TileBrush;
-class TilemapLayerImpl;
-class EditorMapComponent;
-
-/** */
-class TilemapLayer
-{
-private:
-  static TilemapLayer current_;
-public:
-  static TilemapLayer current();
-  static void set_current(TilemapLayer t);
-
-  TilemapLayer(); 
-  TilemapLayer(Tileset tileset, int w,  int h);
-  ~TilemapLayer();
-
-  void draw(EditorMapComponent* parent, CL_GraphicContext* gc);
-
-  Tileset get_tileset();
-
-  int  get_tile (int, int);
-
-  Field<int>* get_field();
-
-  /** @param pos position of the old map in the new resized one
-      @param size height of the new map */
- void resize(const CL_Size& size, const CL_Point& point);
-
-  const std::vector<int>& get_data();
-  void set_data(std::vector<int> d);
-
-  void   set_metadata(const MetaData& obj);
-  MetaData get_metadata() const;
-
-  /** Draw the gives brush to the map */
-  void draw_tile(const TileBrush& brush, const CL_Point& pos);
-
-  /** Draw the given single tile to the map */
-  void draw_tile(int id, const CL_Point& pos);
-
-  int get_width()  const;
-  int get_height() const;
-
-  void set_background_color(const CL_Color& color);
-  void set_foreground_color(const CL_Color& color);
-
-  void set_draw_attribute(bool t);
-  bool get_draw_attribute() const;
-
-  void set_draw_grid(bool t);
-  bool get_draw_grid() const;
-
-  CL_PixelBuffer create_pixelbuffer();
-
-  static void draw_tiles(Field<int>* field, const TileBrush& brush, const CL_Point& pos);
-
-  bool has_bounding_rect() const;
-  CL_Rect get_bounding_rect();
-
-  /** Convert a coordinate given in world position into a tile
-      coordinate */
-  CL_Point world2tile(const CL_Pointf& pos) const;
-
-  bool is_null() const { return !impl.get(); }
-
-  Layer to_layer();
-
-private:
-  SharedPtr<TilemapLayerImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tilemap_minimap.hpp (from rev 712, trunk/flexlay/lib/tilemap_minimap.hxx)

Deleted: trunk/flexlay/lib/tilemap_minimap.hxx
===================================================================
--- trunk/flexlay/lib/tilemap_minimap.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tilemap_minimap.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,35 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_TILEMAP_MINIMAP_HXX
-#define HEADER_TILEMAP_MINIMAP_HXX
-
-/** */
-class TilemapMinimap
-{
-private:
-public:
-
-private:
-  TilemapMinimap (const TilemapMinimap&);
-  TilemapMinimap& operator= (const TilemapMinimap&);
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tileset.cpp (from rev 712, trunk/flexlay/lib/tileset.cxx)
===================================================================
--- trunk/flexlay/lib/tileset.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tileset.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,105 @@
+//  $Id: tile_factory.cxx,v 1.10 2003/09/22 18:37:05 grumbel Exp $
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2000 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <string>
+#include <ClanLib/Core/System/system.h>
+#include <assert.h>
+#include <iostream>
+#include "globals.hpp"
+#include "string_converter.hpp"
+#include "tile.hpp"
+#include "tileset.hpp"
+
+typedef std::vector<Tile*> Tiles;
+typedef std::vector<int> TileIds;
+typedef Tiles::iterator iterator;
+  
+class TilesetImpl 
+{
+public:
+  TilesetImpl()
+  {
+  }
+
+  ~TilesetImpl()
+  {
+    for(Tiles::iterator i = tiles.begin(); i != tiles.end(); ++i)
+      {
+        delete *i;
+      }
+  }
+
+  TileIds tile_ids;
+  Tiles tiles;
+  int tile_size;
+};
+
+Tileset::Tileset()
+  : impl(new TilesetImpl())
+{
+  impl->tile_size = 1;
+}
+
+Tileset::Tileset(int tile_size_)
+  : impl(new TilesetImpl())
+{
+  assert(tile_size_ > 0);
+  impl->tile_size = tile_size_;
+}
+
+Tileset::~Tileset()
+{
+}
+
+void
+Tileset::add_tile(int id, Tile* tile)
+{
+  // FIXME: Check for tile-id dups
+  if (id >= int(impl->tiles.size()))
+    impl->tiles.resize(id+1, 0);
+
+  if (tile)
+    impl->tiles[id] = new Tile(*tile);
+  else
+    impl->tiles[id] = 0;
+
+  impl->tile_ids.push_back(id);
+}
+
+Tile* 
+Tileset::create (int id)
+{
+  if (id >= 0 && id < int(impl->tiles.size()))
+    return impl->tiles[id];
+  else
+    return 0;
+}
+
+int
+Tileset::get_tile_size() const 
+{
+  return impl->tile_size; 
+}
+
+std::vector<int> 
+Tileset::get_tiles() const
+{
+  return impl->tile_ids;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tileset.cxx
===================================================================
--- trunk/flexlay/lib/tileset.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tileset.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,105 +0,0 @@
-//  $Id: tile_factory.cxx,v 1.10 2003/09/22 18:37:05 grumbel Exp $
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2000 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <string>
-#include <ClanLib/Core/System/system.h>
-#include <assert.h>
-#include <iostream>
-#include "globals.hxx"
-#include "string_converter.hxx"
-#include "tile.hxx"
-#include "tileset.hxx"
-
-typedef std::vector<Tile*> Tiles;
-typedef std::vector<int> TileIds;
-typedef Tiles::iterator iterator;
-  
-class TilesetImpl 
-{
-public:
-  TilesetImpl()
-  {
-  }
-
-  ~TilesetImpl()
-  {
-    for(Tiles::iterator i = tiles.begin(); i != tiles.end(); ++i)
-      {
-        delete *i;
-      }
-  }
-
-  TileIds tile_ids;
-  Tiles tiles;
-  int tile_size;
-};
-
-Tileset::Tileset()
-  : impl(new TilesetImpl())
-{
-  impl->tile_size = 1;
-}
-
-Tileset::Tileset(int tile_size_)
-  : impl(new TilesetImpl())
-{
-  assert(tile_size_ > 0);
-  impl->tile_size = tile_size_;
-}
-
-Tileset::~Tileset()
-{
-}
-
-void
-Tileset::add_tile(int id, Tile* tile)
-{
-  // FIXME: Check for tile-id dups
-  if (id >= int(impl->tiles.size()))
-    impl->tiles.resize(id+1, 0);
-
-  if (tile)
-    impl->tiles[id] = new Tile(*tile);
-  else
-    impl->tiles[id] = 0;
-
-  impl->tile_ids.push_back(id);
-}
-
-Tile* 
-Tileset::create (int id)
-{
-  if (id >= 0 && id < int(impl->tiles.size()))
-    return impl->tiles[id];
-  else
-    return 0;
-}
-
-int
-Tileset::get_tile_size() const 
-{
-  return impl->tile_size; 
-}
-
-std::vector<int> 
-Tileset::get_tiles() const
-{
-  return impl->tile_ids;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tileset.hpp (from rev 712, trunk/flexlay/lib/tileset.hxx)
===================================================================
--- trunk/flexlay/lib/tileset.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tileset.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,64 @@
+//  $Id: tile_factory.hpp,v 1.8 2003/09/22 18:37:05 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2000 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef TILESET_HXX
+#define TILESET_HXX
+
+#include <vector>
+#include <string>
+#include <ClanLib/Core/System/sharedptr.h>
+
+class Tile;
+class TilesetImpl;
+
+/** A \a Tileset provides the mapping from an \a id to a \a Tile
+    structure. It also contains information of the tile_size and other
+    necesarry information that are needed to display a TileMap */
+class Tileset
+{
+public:
+  explicit Tileset();
+
+  /** Create an empty Tileset, so that the user can add stuff via
+      scripting to it */
+  explicit Tileset(int tile_size_);
+
+  ~Tileset();
+
+  /** Check if the tile is already loaded and return it. If it is not
+   *  already loaded, load it 
+   *
+   *  @param id The id of the tile to create as defined in the def. file
+   *
+   *  @return on success the tile is returned, on failure 0 */
+  Tile* create(int id);
+
+  int get_tile_size() const;
+  
+  void add_tile(int id, Tile* tile);
+
+  /** Return the tiles which are available in this tileset */
+  std::vector<int> get_tiles() const;
+
+private:
+  CL_SharedPtr<TilesetImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tileset.hxx
===================================================================
--- trunk/flexlay/lib/tileset.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tileset.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,64 +0,0 @@
-//  $Id: tile_factory.hxx,v 1.8 2003/09/22 18:37:05 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2000 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef TILESET_HXX
-#define TILESET_HXX
-
-#include <vector>
-#include <string>
-#include <ClanLib/Core/System/sharedptr.h>
-
-class Tile;
-class TilesetImpl;
-
-/** A \a Tileset provides the mapping from an \a id to a \a Tile
-    structure. It also contains information of the tile_size and other
-    necesarry information that are needed to display a TileMap */
-class Tileset
-{
-public:
-  explicit Tileset();
-
-  /** Create an empty Tileset, so that the user can add stuff via
-      scripting to it */
-  explicit Tileset(int tile_size_);
-
-  ~Tileset();
-
-  /** Check if the tile is already loaded and return it. If it is not
-   *  already loaded, load it 
-   *
-   *  @param id The id of the tile to create as defined in the def. file
-   *
-   *  @return on success the tile is returned, on failure 0 */
-  Tile* create(int id);
-
-  int get_tile_size() const;
-  
-  void add_tile(int id, Tile* tile);
-
-  /** Return the tiles which are available in this tileset */
-  std::vector<int> get_tiles() const;
-
-private:
-  CL_SharedPtr<TilesetImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/titlebar.cpp (from rev 712, trunk/flexlay/lib/titlebar.cxx)
===================================================================
--- trunk/flexlay/lib/titlebar.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/titlebar.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,125 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include <ClanLib/Display/display.h>
+#include <ClanLib/Display/keys.h>
+#include <ClanLib/Display/mouse.h>
+#include "fonts.hpp"
+#include "titlebar.hpp"
+
+class TitlebarImpl
+{
+public:
+  CL_Component* window;
+  Titlebar* parent;
+  CL_Point click_pos;
+  CL_Rect old_pos;
+  std::string title;
+  std::vector<CL_Slot> slots;
+  bool pressed;
+
+  TitlebarImpl(Titlebar* parent_) : parent(parent_) {}
+
+  void on_mouse_move(const CL_InputEvent& event);
+  void on_mouse_down(const CL_InputEvent& event);
+  void on_mouse_up(const CL_InputEvent& event);
+  void draw();
+};
+
+Titlebar::Titlebar(const CL_Rect& rect, const std::string& title, CL_Component* parent)
+  : CL_Component(rect, parent),
+    impl(new TitlebarImpl(this))
+{
+  impl->title = title;
+  impl->pressed = false;
+  impl->window = parent;
+
+  impl->slots.push_back(sig_mouse_down().connect(impl.get(), &TitlebarImpl::on_mouse_down));
+  impl->slots.push_back(sig_mouse_move().connect(impl.get(), &TitlebarImpl::on_mouse_move));
+  impl->slots.push_back(sig_mouse_up().connect(impl.get(), &TitlebarImpl::on_mouse_up));
+  impl->slots.push_back(sig_paint().connect(impl.get(), &TitlebarImpl::draw));
+}
+
+void
+TitlebarImpl::on_mouse_up(const CL_InputEvent& event)
+{
+  if (event.id == CL_MOUSE_LEFT)
+    {
+      pressed = false;
+      parent->release_mouse();
+    }
+}
+
+void
+TitlebarImpl::on_mouse_down(const CL_InputEvent& event)
+{
+  if (event.id == CL_MOUSE_LEFT)
+    {
+      pressed   = true;
+      click_pos = event.mouse_pos;
+      parent->capture_mouse();
+      window->raise();
+
+      old_pos = window->get_position();
+      click_pos.x += old_pos.left;
+      click_pos.y += old_pos.top;
+    } 
+}
+
+void
+TitlebarImpl::on_mouse_move(const CL_InputEvent& event)
+{
+  if(pressed)
+    {
+      CL_Rect rect = window->get_position();
+
+      CL_Point move(old_pos.left - (click_pos.x - (rect.left + event.mouse_pos.x)), 
+                    old_pos.top  - (click_pos.y - (rect.top  + event.mouse_pos.y)));
+
+      window->set_position(move.x, move.y);
+    }
+}
+
+void
+TitlebarImpl::draw()
+{
+  CL_Display::push_translate(parent->get_screen_x(), parent->get_screen_y());
+
+  // FIXME: Hack should be done via has_mouse_over(), but that doesn't include child components
+  if (parent->get_parent()->get_position().is_inside(CL_Point(CL_Mouse::get_x(), 
+                                                              CL_Mouse::get_y())))
+      //parent->get_parent()->has_mouse_over())
+    {
+      CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
+                                    CL_Size(parent->get_width()-1, parent->get_height())), 
+                            CL_Color(250, 250, 250));
+    }
+  else
+    {
+      CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
+                                    CL_Size(parent->get_width()-1, parent->get_height())), 
+                            CL_Color(240, 240, 240));
+    }
+
+  Fonts::verdana11.draw(4, 0, title);
+
+  CL_Display::pop_modelview();
+}
+                  
+/* EOF */

Deleted: trunk/flexlay/lib/titlebar.cxx
===================================================================
--- trunk/flexlay/lib/titlebar.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/titlebar.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,125 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/keys.h>
-#include <ClanLib/Display/mouse.h>
-#include "fonts.hxx"
-#include "titlebar.hxx"
-
-class TitlebarImpl
-{
-public:
-  CL_Component* window;
-  Titlebar* parent;
-  CL_Point click_pos;
-  CL_Rect old_pos;
-  std::string title;
-  std::vector<CL_Slot> slots;
-  bool pressed;
-
-  TitlebarImpl(Titlebar* parent_) : parent(parent_) {}
-
-  void on_mouse_move(const CL_InputEvent& event);
-  void on_mouse_down(const CL_InputEvent& event);
-  void on_mouse_up(const CL_InputEvent& event);
-  void draw();
-};
-
-Titlebar::Titlebar(const CL_Rect& rect, const std::string& title, CL_Component* parent)
-  : CL_Component(rect, parent),
-    impl(new TitlebarImpl(this))
-{
-  impl->title = title;
-  impl->pressed = false;
-  impl->window = parent;
-
-  impl->slots.push_back(sig_mouse_down().connect(impl.get(), &TitlebarImpl::on_mouse_down));
-  impl->slots.push_back(sig_mouse_move().connect(impl.get(), &TitlebarImpl::on_mouse_move));
-  impl->slots.push_back(sig_mouse_up().connect(impl.get(), &TitlebarImpl::on_mouse_up));
-  impl->slots.push_back(sig_paint().connect(impl.get(), &TitlebarImpl::draw));
-}
-
-void
-TitlebarImpl::on_mouse_up(const CL_InputEvent& event)
-{
-  if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed = false;
-      parent->release_mouse();
-    }
-}
-
-void
-TitlebarImpl::on_mouse_down(const CL_InputEvent& event)
-{
-  if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed   = true;
-      click_pos = event.mouse_pos;
-      parent->capture_mouse();
-      window->raise();
-
-      old_pos = window->get_position();
-      click_pos.x += old_pos.left;
-      click_pos.y += old_pos.top;
-    } 
-}
-
-void
-TitlebarImpl::on_mouse_move(const CL_InputEvent& event)
-{
-  if(pressed)
-    {
-      CL_Rect rect = window->get_position();
-
-      CL_Point move(old_pos.left - (click_pos.x - (rect.left + event.mouse_pos.x)), 
-                    old_pos.top  - (click_pos.y - (rect.top  + event.mouse_pos.y)));
-
-      window->set_position(move.x, move.y);
-    }
-}
-
-void
-TitlebarImpl::draw()
-{
-  CL_Display::push_translate(parent->get_screen_x(), parent->get_screen_y());
-
-  // FIXME: Hack should be done via has_mouse_over(), but that doesn't include child components
-  if (parent->get_parent()->get_position().is_inside(CL_Point(CL_Mouse::get_x(), 
-                                                              CL_Mouse::get_y())))
-      //parent->get_parent()->has_mouse_over())
-    {
-      CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
-                                    CL_Size(parent->get_width()-1, parent->get_height())), 
-                            CL_Color(250, 250, 250));
-    }
-  else
-    {
-      CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
-                                    CL_Size(parent->get_width()-1, parent->get_height())), 
-                            CL_Color(240, 240, 240));
-    }
-
-  Fonts::verdana11.draw(4, 0, title);
-
-  CL_Display::pop_modelview();
-}
-                  
-/* EOF */

Copied: trunk/flexlay/lib/titlebar.hpp (from rev 712, trunk/flexlay/lib/titlebar.hxx)
===================================================================
--- trunk/flexlay/lib/titlebar.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/titlebar.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,42 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_TITLEBAR_HXX
+#define HEADER_TITLEBAR_HXX
+
+#include <ClanLib/GUI/component.h>
+#include <ClanLib/Core/Math/rect.h>
+#include "shared_ptr.hpp"
+
+class TitlebarImpl;
+
+/** */
+class Titlebar : public CL_Component
+{
+protected:
+  virtual ~Titlebar() {}
+public:
+  Titlebar(const CL_Rect& rect, const std::string& title, CL_Component* parent);
+
+private:
+  SharedPtr<TitlebarImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/titlebar.hxx
===================================================================
--- trunk/flexlay/lib/titlebar.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/titlebar.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,42 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_TITLEBAR_HXX
-#define HEADER_TITLEBAR_HXX
-
-#include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/Math/rect.h>
-#include "shared_ptr.hxx"
-
-class TitlebarImpl;
-
-/** */
-class Titlebar : public CL_Component
-{
-protected:
-  virtual ~Titlebar() {}
-public:
-  Titlebar(const CL_Rect& rect, const std::string& title, CL_Component* parent);
-
-private:
-  SharedPtr<TitlebarImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/layer_move_tool.cpp (from rev 712, trunk/flexlay/lib/tools/layer_move_tool.cxx)
===================================================================
--- trunk/flexlay/lib/tools/layer_move_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/layer_move_tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,133 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2004 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#include <ClanLib/Core/Math/point.h>
+#include <ClanLib/Display/display.h>
+#include "workspace.hpp"
+#include "tool_impl.hpp"
+#include "editor_map_component.hpp"
+#include "editor_map.hpp"
+#include "layer.hpp"
+#include "layer_move_tool.hpp"
+
+class LayerMoveToolImpl : public ToolImpl
+{
+public:
+  bool scrolling;
+  CL_Pointf click_pos;
+
+  /** Position of the center */
+  CL_Pointf old_trans_offset;
+  Layer layer;
+  
+  Layer find_closed_layer(const CL_Pointf& pos)
+  {
+    Layer layer; 
+
+    EditorMap parent = EditorMapComponent::current()->get_workspace().get_map();
+
+    for(int i = 0; i < parent.get_layer_count(); ++i)
+      {
+        if (parent.get_layer(i).get_bounding_rect().is_inside(CL_Point(pos)))
+          layer = parent.get_layer(i);
+      }
+
+    return layer;
+  }
+
+  void draw() 
+  {
+    for(int i = 0; i < EditorMapComponent::current()->get_workspace().get_map().get_layer_count(); ++i)
+      {
+        Layer layer = EditorMapComponent::current()->get_workspace().get_map().get_layer(i);
+        if (layer.has_bounding_rect())
+          {
+            CL_Rect rect = layer.get_bounding_rect();
+            CL_Display::draw_line(rect.left, rect.top, rect.right, rect.bottom,
+                                  CL_Color(0, 255, 255));
+            CL_Display::draw_line(rect.left, rect.bottom, rect.right, rect.top,
+                                  CL_Color(0, 255, 255));
+          }
+      }
+  }
+
+  void on_mouse_up  (const CL_InputEvent& event) 
+  {
+    if (!layer.is_null())
+      {
+        scrolling = false;
+        update(event);
+        EditorMapComponent::current()->release_mouse();
+        layer = Layer();
+      }
+  }
+
+  void on_mouse_down(const CL_InputEvent& event)
+  {
+    EditorMapComponent* parent = EditorMapComponent::current();
+    CL_Pointf pos = parent->screen2world(event.mouse_pos);
+
+    layer = find_closed_layer(pos);
+    if (!layer.is_null())
+      {
+        scrolling = true;
+        old_trans_offset = layer.get_pos();
+        click_pos = pos;
+        EditorMapComponent::current()->capture_mouse();
+      }
+  }
+
+  void on_mouse_move(const CL_InputEvent& event)
+  {
+    if (!layer.is_null())
+      {
+        if (scrolling)
+          {
+            update(event);
+          }
+      }    
+  }
+
+  void update(const CL_InputEvent& event)
+  {
+    if (!layer.is_null())
+      {
+        EditorMapComponent* parent = EditorMapComponent::current();
+        CL_Pointf pos = parent->screen2world(event.mouse_pos);
+        layer.set_pos(old_trans_offset + (pos - click_pos));
+      }
+  }
+};
+
+LayerMoveTool::LayerMoveTool()
+  : impl(new LayerMoveToolImpl())
+{
+  impl->scrolling = false;
+  impl->click_pos = CL_Point(0, 0);
+  impl->old_trans_offset = CL_Pointf(0,0);
+}
+
+Tool
+LayerMoveTool::to_tool()
+{
+  return Tool(impl);
+}
+
+/* EOF */
+

Deleted: trunk/flexlay/lib/tools/layer_move_tool.cxx
===================================================================
--- trunk/flexlay/lib/tools/layer_move_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/layer_move_tool.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,133 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2004 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#include <ClanLib/Core/Math/point.h>
-#include <ClanLib/Display/display.h>
-#include "workspace.hxx"
-#include "tool_impl.hxx"
-#include "editor_map_component.hxx"
-#include "editor_map.hxx"
-#include "layer.hxx"
-#include "layer_move_tool.hxx"
-
-class LayerMoveToolImpl : public ToolImpl
-{
-public:
-  bool scrolling;
-  CL_Pointf click_pos;
-
-  /** Position of the center */
-  CL_Pointf old_trans_offset;
-  Layer layer;
-  
-  Layer find_closed_layer(const CL_Pointf& pos)
-  {
-    Layer layer; 
-
-    EditorMap parent = EditorMapComponent::current()->get_workspace().get_map();
-
-    for(int i = 0; i < parent.get_layer_count(); ++i)
-      {
-        if (parent.get_layer(i).get_bounding_rect().is_inside(CL_Point(pos)))
-          layer = parent.get_layer(i);
-      }
-
-    return layer;
-  }
-
-  void draw() 
-  {
-    for(int i = 0; i < EditorMapComponent::current()->get_workspace().get_map().get_layer_count(); ++i)
-      {
-        Layer layer = EditorMapComponent::current()->get_workspace().get_map().get_layer(i);
-        if (layer.has_bounding_rect())
-          {
-            CL_Rect rect = layer.get_bounding_rect();
-            CL_Display::draw_line(rect.left, rect.top, rect.right, rect.bottom,
-                                  CL_Color(0, 255, 255));
-            CL_Display::draw_line(rect.left, rect.bottom, rect.right, rect.top,
-                                  CL_Color(0, 255, 255));
-          }
-      }
-  }
-
-  void on_mouse_up  (const CL_InputEvent& event) 
-  {
-    if (!layer.is_null())
-      {
-        scrolling = false;
-        update(event);
-        EditorMapComponent::current()->release_mouse();
-        layer = Layer();
-      }
-  }
-
-  void on_mouse_down(const CL_InputEvent& event)
-  {
-    EditorMapComponent* parent = EditorMapComponent::current();
-    CL_Pointf pos = parent->screen2world(event.mouse_pos);
-
-    layer = find_closed_layer(pos);
-    if (!layer.is_null())
-      {
-        scrolling = true;
-        old_trans_offset = layer.get_pos();
-        click_pos = pos;
-        EditorMapComponent::current()->capture_mouse();
-      }
-  }
-
-  void on_mouse_move(const CL_InputEvent& event)
-  {
-    if (!layer.is_null())
-      {
-        if (scrolling)
-          {
-            update(event);
-          }
-      }    
-  }
-
-  void update(const CL_InputEvent& event)
-  {
-    if (!layer.is_null())
-      {
-        EditorMapComponent* parent = EditorMapComponent::current();
-        CL_Pointf pos = parent->screen2world(event.mouse_pos);
-        layer.set_pos(old_trans_offset + (pos - click_pos));
-      }
-  }
-};
-
-LayerMoveTool::LayerMoveTool()
-  : impl(new LayerMoveToolImpl())
-{
-  impl->scrolling = false;
-  impl->click_pos = CL_Point(0, 0);
-  impl->old_trans_offset = CL_Pointf(0,0);
-}
-
-Tool
-LayerMoveTool::to_tool()
-{
-  return Tool(impl);
-}
-
-/* EOF */
-

Copied: trunk/flexlay/lib/tools/layer_move_tool.hpp (from rev 712, trunk/flexlay/lib/tools/layer_move_tool.hxx)
===================================================================
--- trunk/flexlay/lib/tools/layer_move_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/layer_move_tool.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,40 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2004 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#ifndef HEADER_LAYER_MOVE_TOOL_HXX
+#define HEADER_LAYER_MOVE_TOOL_HXX
+
+#include "tool.hpp"
+
+class LayerMoveToolImpl;
+
+/** */
+class LayerMoveTool : public Tool
+{
+public:
+  LayerMoveTool();
+
+  Tool to_tool();
+private:
+  SharedPtr<LayerMoveToolImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/layer_move_tool.hxx
===================================================================
--- trunk/flexlay/lib/tools/layer_move_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/layer_move_tool.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,40 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2004 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#ifndef HEADER_LAYER_MOVE_TOOL_HXX
-#define HEADER_LAYER_MOVE_TOOL_HXX
-
-#include "tool.hxx"
-
-class LayerMoveToolImpl;
-
-/** */
-class LayerMoveTool : public Tool
-{
-public:
-  LayerMoveTool();
-
-  Tool to_tool();
-private:
-  SharedPtr<LayerMoveToolImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/objmap_select_tool.cpp (from rev 712, trunk/flexlay/lib/tools/objmap_select_tool.cxx)
===================================================================
--- trunk/flexlay/lib/tools/objmap_select_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/objmap_select_tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,325 @@
+//  $Id: tilemap_object_tool.cxx,v 1.1 2003/09/23 22:10:40 grumbel Exp $
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#include <algorithm>
+#include <ClanLib/Display/keys.h>
+#include <ClanLib/Display/keyboard.h>
+#include <ClanLib/Display/display.h>
+#include "editor_map_component.hpp"
+#include "editor_map.hpp"
+#include "editor_map_component.hpp"
+#include "gui_manager.hpp"
+#include "editor_names.hpp"
+#include "popup_menu.hpp"
+#include "objmap_object.hpp"
+#include "objmap_control_point.hpp"
+#include "object_move_command.hpp"
+#include "object_delete_command.hpp"
+#include "tool_impl.hpp"
+#include "objmap_select_tool.hpp"
+
+class ObjMapSelectToolImpl : public ToolImpl
+{
+public:
+  CL_Signal_v1<CL_Menu*> on_popup_menu_display;
+  CL_Signal_v2<int, int> on_right_click;
+
+  enum { DRAG, SELECT, NONE } state;
+
+  /** the position on which the object was clicked, relative to the
+      object */
+  CL_Pointf offset;
+
+  CL_Pointf drag_start;
+  CL_Rectf selection_rect;
+
+  ObjMapControlPoint control_point;
+  ObjMapSelectTool::Selection selection;
+  ObjectMoveCommand*   move_command;
+  ObjectDeleteCommand* delete_command;
+
+  void draw();
+
+  void on_mouse_up  (const CL_InputEvent& event);
+  void on_mouse_down(const CL_InputEvent& event);
+  void on_mouse_move(const CL_InputEvent& event);
+
+  void on_selection_change();
+};
+
+ObjMapSelectTool::ObjMapSelectTool()
+  : impl(new ObjMapSelectToolImpl())
+{
+  impl->state = ObjMapSelectToolImpl::NONE;
+  impl->offset = CL_Pointf(0, 0);
+  impl->move_command = 0;
+}
+
+ObjMapSelectTool::~ObjMapSelectTool()
+{
+}
+ 
+void
+ObjMapSelectTool::clear_selection()
+{
+  impl->selection.clear(); 
+  impl->on_selection_change();
+}
+
+ObjMapSelectTool::Selection
+ObjMapSelectTool::get_selection() const 
+{ 
+  return impl->selection;
+}
+
+void
+ObjMapSelectTool::set_selection(const Selection& sel) 
+{ 
+  impl->selection = sel; 
+}
+
+CL_Signal_v1<CL_Menu*>& 
+ObjMapSelectTool::sig_on_popup_menu_display()
+{
+  return impl->on_popup_menu_display; 
+}
+
+CL_Signal_v2<int, int>&
+ObjMapSelectTool::sig_on_right_click()
+{
+  return impl->on_right_click;
+}
+
+void
+ObjMapSelectToolImpl::draw()
+{
+  for (ObjMapSelectTool::Selection::iterator i = selection.begin(); i != selection.end(); ++i)
+    {
+      //      (*i).draw();
+      CL_Display::draw_rect((*i).get_bound_rect(), CL_Color(255, 0, 0));
+    }
+
+  switch(state)
+    {
+    case DRAG:
+      break;
+    case SELECT:
+      CL_Display::draw_rect(selection_rect,
+                            CL_Color(255, 255, 255));
+      break;
+    default:
+      break;
+    }
+}
+
+void
+ObjMapSelectToolImpl::on_mouse_up(const CL_InputEvent& event)
+{
+  ObjectLayer objmap = ObjectLayer::current();
+
+  EditorMapComponent* parent = EditorMapComponent::current();
+
+  CL_Pointf pos = parent->screen2world(event.mouse_pos);
+
+  switch (event.id)
+    {
+    case CL_MOUSE_LEFT:
+      switch(state)
+        {
+        case DRAG:
+          if (move_command)
+            {
+              Workspace::current().get_map().execute(move_command->to_command());
+              move_command = 0;
+            }
+          state = NONE;
+          parent->release_mouse();
+          break;
+
+        case SELECT:
+          state = NONE;
+          
+          selection_rect.right  = pos.x;
+          selection_rect.bottom = pos.y;
+          selection_rect.normalize();
+
+          selection = objmap.get_selection(selection_rect);
+          on_selection_change();
+          parent->release_mouse();
+          break;
+
+        default:
+          break;
+        }
+      break;
+
+    case CL_MOUSE_RIGHT:
+      {
+        on_right_click(event.mouse_pos.x + parent->get_screen_rect().left,
+                       event.mouse_pos.y + parent->get_screen_rect().top);
+        /*
+        PopupMenu* menu = new PopupMenu(CL_Point(event.mouse_pos.x + parent->get_screen_rect().left,
+                                                 event.mouse_pos.y + parent->get_screen_rect().top), 
+                                        GUIManager::current()->get_component());
+
+                                        on_popup_menu_display(menu->get_menu());*/
+      }
+      break;
+    }
+}
+
+void
+ObjMapSelectToolImpl::on_mouse_down(const CL_InputEvent& event)
+{
+  ObjectLayer objmap = ObjectLayer::current();
+
+  EditorMapComponent* parent = EditorMapComponent::current();
+  CL_Pointf pos = parent->screen2world(event.mouse_pos);
+      
+  switch (event.id)
+    {
+    case CL_MOUSE_LEFT:
+      switch(state)
+        {
+        default:
+          control_point = objmap.find_control_point(pos);
+
+          if (!control_point.is_null())
+            {
+              state = DRAG;
+              parent->capture_mouse();
+              offset = pos - control_point.get_pos();
+              drag_start = pos;
+            }
+          else
+            {
+              ObjMapObject obj = objmap.find_object(pos);
+
+              if (!obj.is_null())
+                {
+                  if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT))
+                    {
+                      ObjMapSelectTool::Selection::iterator i
+                        = std::find(selection.begin(), selection.end(), obj);
+                      if (i == selection.end())
+                        selection.push_back(obj);
+                      else
+                        selection.erase(i);
+
+                      on_selection_change();
+                    }
+                  else
+                    {
+                      state = DRAG;
+                      parent->capture_mouse();
+                      offset = pos - obj.get_pos();
+                      drag_start = pos;
+
+                      if (std::find(selection.begin(), selection.end(), obj) == selection.end())
+                        { // Clicked object is not in the selection, so we add it
+                          selection.clear();
+                          objmap.delete_control_points();
+                          selection.push_back(obj);
+                          on_selection_change();
+                        }
+
+                      move_command = new ObjectMoveCommand(objmap);
+                      for (ObjMapSelectTool::Selection::iterator i = selection.begin();
+                           i != selection.end(); ++i)
+                        {
+                          move_command->add_obj(*i);
+                        }
+                    }
+                }
+              else
+                {
+                  state = SELECT;
+                  selection_rect = CL_Rectf(pos.x, pos.y, pos.x, pos.y);
+                  parent->capture_mouse();
+                }
+            }
+          break;
+        }
+      break;
+
+    case CL_MOUSE_RIGHT:
+      break;
+    }
+}
+
+void
+ObjMapSelectToolImpl::on_mouse_move(const CL_InputEvent& event)
+{
+  EditorMapComponent* parent = EditorMapComponent::current();
+  CL_Pointf pos = parent->screen2world(event.mouse_pos);
+
+  switch(state)
+    {
+    case DRAG:
+      if (!control_point.is_null())
+        {
+          control_point.set_pos(pos - offset);
+        }
+      else
+        {
+          move_command->move_by(pos - drag_start);
+          if (selection.size() == 1)
+            selection.front().update_control_points();
+        }
+      /*
+      for (ObjMapSelectTool::Selection::iterator i = selection.begin(); 
+           i != selection.end(); ++i)
+        {
+          (*i).set_pos((*i).get_pos() + (pos - drag_start));
+          // FIXME: Move this into ObjMapObject
+          (*i).sig_move()(*i);
+        }*/
+      //drag_start = pos;
+      break;
+
+    case SELECT:
+      selection_rect.right  = pos.x;
+      selection_rect.bottom = pos.y;
+      break;
+
+    default:
+      // FIXME: Add some kind of highlighting here if mouse is over an object
+      break;
+    }
+}
+
+Tool
+ObjMapSelectTool::to_tool()
+{
+  return Tool(impl); 
+}
+
+void
+ObjMapSelectToolImpl::on_selection_change()
+{
+  ObjectLayer objmap = ObjectLayer::current();
+  objmap.delete_control_points();
+
+  if (selection.size() == 1)
+    {
+      selection.front().add_control_points();
+    } 
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/objmap_select_tool.cxx
===================================================================
--- trunk/flexlay/lib/tools/objmap_select_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/objmap_select_tool.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,325 +0,0 @@
-//  $Id: tilemap_object_tool.cxx,v 1.1 2003/09/23 22:10:40 grumbel Exp $
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#include <algorithm>
-#include <ClanLib/Display/keys.h>
-#include <ClanLib/Display/keyboard.h>
-#include <ClanLib/Display/display.h>
-#include "editor_map_component.hxx"
-#include "editor_map.hxx"
-#include "editor_map_component.hxx"
-#include "gui_manager.hxx"
-#include "editor_names.hxx"
-#include "popup_menu.hxx"
-#include "objmap_object.hxx"
-#include "objmap_control_point.hxx"
-#include "object_move_command.hxx"
-#include "object_delete_command.hxx"
-#include "tool_impl.hxx"
-#include "objmap_select_tool.hxx"
-
-class ObjMapSelectToolImpl : public ToolImpl
-{
-public:
-  CL_Signal_v1<CL_Menu*> on_popup_menu_display;
-  CL_Signal_v2<int, int> on_right_click;
-
-  enum { DRAG, SELECT, NONE } state;
-
-  /** the position on which the object was clicked, relative to the
-      object */
-  CL_Pointf offset;
-
-  CL_Pointf drag_start;
-  CL_Rectf selection_rect;
-
-  ObjMapControlPoint control_point;
-  ObjMapSelectTool::Selection selection;
-  ObjectMoveCommand*   move_command;
-  ObjectDeleteCommand* delete_command;
-
-  void draw();
-
-  void on_mouse_up  (const CL_InputEvent& event);
-  void on_mouse_down(const CL_InputEvent& event);
-  void on_mouse_move(const CL_InputEvent& event);
-
-  void on_selection_change();
-};
-
-ObjMapSelectTool::ObjMapSelectTool()
-  : impl(new ObjMapSelectToolImpl())
-{
-  impl->state = ObjMapSelectToolImpl::NONE;
-  impl->offset = CL_Pointf(0, 0);
-  impl->move_command = 0;
-}
-
-ObjMapSelectTool::~ObjMapSelectTool()
-{
-}
- 
-void
-ObjMapSelectTool::clear_selection()
-{
-  impl->selection.clear(); 
-  impl->on_selection_change();
-}
-
-ObjMapSelectTool::Selection
-ObjMapSelectTool::get_selection() const 
-{ 
-  return impl->selection;
-}
-
-void
-ObjMapSelectTool::set_selection(const Selection& sel) 
-{ 
-  impl->selection = sel; 
-}
-
-CL_Signal_v1<CL_Menu*>& 
-ObjMapSelectTool::sig_on_popup_menu_display()
-{
-  return impl->on_popup_menu_display; 
-}
-
-CL_Signal_v2<int, int>&
-ObjMapSelectTool::sig_on_right_click()
-{
-  return impl->on_right_click;
-}
-
-void
-ObjMapSelectToolImpl::draw()
-{
-  for (ObjMapSelectTool::Selection::iterator i = selection.begin(); i != selection.end(); ++i)
-    {
-      //      (*i).draw();
-      CL_Display::draw_rect((*i).get_bound_rect(), CL_Color(255, 0, 0));
-    }
-
-  switch(state)
-    {
-    case DRAG:
-      break;
-    case SELECT:
-      CL_Display::draw_rect(selection_rect,
-                            CL_Color(255, 255, 255));
-      break;
-    default:
-      break;
-    }
-}
-
-void
-ObjMapSelectToolImpl::on_mouse_up(const CL_InputEvent& event)
-{
-  ObjectLayer objmap = ObjectLayer::current();
-
-  EditorMapComponent* parent = EditorMapComponent::current();
-
-  CL_Pointf pos = parent->screen2world(event.mouse_pos);
-
-  switch (event.id)
-    {
-    case CL_MOUSE_LEFT:
-      switch(state)
-        {
-        case DRAG:
-          if (move_command)
-            {
-              Workspace::current().get_map().execute(move_command->to_command());
-              move_command = 0;
-            }
-          state = NONE;
-          parent->release_mouse();
-          break;
-
-        case SELECT:
-          state = NONE;
-          
-          selection_rect.right  = pos.x;
-          selection_rect.bottom = pos.y;
-          selection_rect.normalize();
-
-          selection = objmap.get_selection(selection_rect);
-          on_selection_change();
-          parent->release_mouse();
-          break;
-
-        default:
-          break;
-        }
-      break;
-
-    case CL_MOUSE_RIGHT:
-      {
-        on_right_click(event.mouse_pos.x + parent->get_screen_rect().left,
-                       event.mouse_pos.y + parent->get_screen_rect().top);
-        /*
-        PopupMenu* menu = new PopupMenu(CL_Point(event.mouse_pos.x + parent->get_screen_rect().left,
-                                                 event.mouse_pos.y + parent->get_screen_rect().top), 
-                                        GUIManager::current()->get_component());
-
-                                        on_popup_menu_display(menu->get_menu());*/
-      }
-      break;
-    }
-}
-
-void
-ObjMapSelectToolImpl::on_mouse_down(const CL_InputEvent& event)
-{
-  ObjectLayer objmap = ObjectLayer::current();
-
-  EditorMapComponent* parent = EditorMapComponent::current();
-  CL_Pointf pos = parent->screen2world(event.mouse_pos);
-      
-  switch (event.id)
-    {
-    case CL_MOUSE_LEFT:
-      switch(state)
-        {
-        default:
-          control_point = objmap.find_control_point(pos);
-
-          if (!control_point.is_null())
-            {
-              state = DRAG;
-              parent->capture_mouse();
-              offset = pos - control_point.get_pos();
-              drag_start = pos;
-            }
-          else
-            {
-              ObjMapObject obj = objmap.find_object(pos);
-
-              if (!obj.is_null())
-                {
-                  if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT))
-                    {
-                      ObjMapSelectTool::Selection::iterator i
-                        = std::find(selection.begin(), selection.end(), obj);
-                      if (i == selection.end())
-                        selection.push_back(obj);
-                      else
-                        selection.erase(i);
-
-                      on_selection_change();
-                    }
-                  else
-                    {
-                      state = DRAG;
-                      parent->capture_mouse();
-                      offset = pos - obj.get_pos();
-                      drag_start = pos;
-
-                      if (std::find(selection.begin(), selection.end(), obj) == selection.end())
-                        { // Clicked object is not in the selection, so we add it
-                          selection.clear();
-                          objmap.delete_control_points();
-                          selection.push_back(obj);
-                          on_selection_change();
-                        }
-
-                      move_command = new ObjectMoveCommand(objmap);
-                      for (ObjMapSelectTool::Selection::iterator i = selection.begin();
-                           i != selection.end(); ++i)
-                        {
-                          move_command->add_obj(*i);
-                        }
-                    }
-                }
-              else
-                {
-                  state = SELECT;
-                  selection_rect = CL_Rectf(pos.x, pos.y, pos.x, pos.y);
-                  parent->capture_mouse();
-                }
-            }
-          break;
-        }
-      break;
-
-    case CL_MOUSE_RIGHT:
-      break;
-    }
-}
-
-void
-ObjMapSelectToolImpl::on_mouse_move(const CL_InputEvent& event)
-{
-  EditorMapComponent* parent = EditorMapComponent::current();
-  CL_Pointf pos = parent->screen2world(event.mouse_pos);
-
-  switch(state)
-    {
-    case DRAG:
-      if (!control_point.is_null())
-        {
-          control_point.set_pos(pos - offset);
-        }
-      else
-        {
-          move_command->move_by(pos - drag_start);
-          if (selection.size() == 1)
-            selection.front().update_control_points();
-        }
-      /*
-      for (ObjMapSelectTool::Selection::iterator i = selection.begin(); 
-           i != selection.end(); ++i)
-        {
-          (*i).set_pos((*i).get_pos() + (pos - drag_start));
-          // FIXME: Move this into ObjMapObject
-          (*i).sig_move()(*i);
-        }*/
-      //drag_start = pos;
-      break;
-
-    case SELECT:
-      selection_rect.right  = pos.x;
-      selection_rect.bottom = pos.y;
-      break;
-
-    default:
-      // FIXME: Add some kind of highlighting here if mouse is over an object
-      break;
-    }
-}
-
-Tool
-ObjMapSelectTool::to_tool()
-{
-  return Tool(impl); 
-}
-
-void
-ObjMapSelectToolImpl::on_selection_change()
-{
-  ObjectLayer objmap = ObjectLayer::current();
-  objmap.delete_control_points();
-
-  if (selection.size() == 1)
-    {
-      selection.front().add_control_points();
-    } 
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/objmap_select_tool.hpp (from rev 712, trunk/flexlay/lib/tools/objmap_select_tool.hxx)
===================================================================
--- trunk/flexlay/lib/tools/objmap_select_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/objmap_select_tool.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,53 @@
+//  $Id: tilemap_object_tool.hpp,v 1.1 2003/09/23 22:10:40 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#ifndef HEADER_OBJMAP_SELECT_TOOL_HXX
+#define HEADER_OBJMAP_SELECT_TOOL_HXX
+
+#include "object_layer.hpp"
+#include "object_brush.hpp"
+#include "tool.hpp"
+
+class CL_Menu;
+class ObjMapSelectToolImpl;
+
+/** */
+class ObjMapSelectTool
+{
+public:
+  typedef std::vector<ObjMapObject> Selection; 
+
+  ObjMapSelectTool();
+  ~ObjMapSelectTool();
+
+  void clear_selection();
+  Selection get_selection() const;
+  void set_selection(const Selection& sel);
+
+  CL_Signal_v2<int, int>& sig_on_right_click();
+  CL_Signal_v1<CL_Menu*>& sig_on_popup_menu_display();
+
+  Tool to_tool();
+private:
+  SharedPtr<ObjMapSelectToolImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/objmap_select_tool.hxx
===================================================================
--- trunk/flexlay/lib/tools/objmap_select_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/objmap_select_tool.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,53 +0,0 @@
-//  $Id: tilemap_object_tool.hxx,v 1.1 2003/09/23 22:10:40 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#ifndef HEADER_OBJMAP_SELECT_TOOL_HXX
-#define HEADER_OBJMAP_SELECT_TOOL_HXX
-
-#include "object_layer.hxx"
-#include "object_brush.hxx"
-#include "tool.hxx"
-
-class CL_Menu;
-class ObjMapSelectToolImpl;
-
-/** */
-class ObjMapSelectTool
-{
-public:
-  typedef std::vector<ObjMapObject> Selection; 
-
-  ObjMapSelectTool();
-  ~ObjMapSelectTool();
-
-  void clear_selection();
-  Selection get_selection() const;
-  void set_selection(const Selection& sel);
-
-  CL_Signal_v2<int, int>& sig_on_right_click();
-  CL_Signal_v1<CL_Menu*>& sig_on_popup_menu_display();
-
-  Tool to_tool();
-private:
-  SharedPtr<ObjMapSelectToolImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/sketch_stroke_tool.cpp (from rev 712, trunk/flexlay/lib/tools/sketch_stroke_tool.cxx)
===================================================================
--- trunk/flexlay/lib/tools/sketch_stroke_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/sketch_stroke_tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,166 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#include <iostream>
+#include <assert.h>
+#include <ClanLib/gl.h>
+#include <ClanLib/Display/input_event.h>
+#include <ClanLib/Display/keys.h>
+#include <ClanLib/Display/mouse.h>
+#include <ClanLib/Display/display.h>
+#include <ClanLib/Display/input_context.h>
+#include "editor_map_component.hpp"
+#include "tool.hpp"
+#include "bitmap_layer.hpp"
+#include "sketch_stroke_tool.hpp"
+#include "sprite_stroke_drawer.hpp"
+#include "marker_stroke_drawer.hpp"
+#include "stroke.hpp"
+#include "stroke_drawer.hpp"
+#include "drawer_properties.hpp"
+#include "flexlay.hpp"
+
+class SketchStrokeToolImpl : public ToolImpl
+{
+public:
+  bool drawing;
+  Stroke   stroke;
+  StrokeDrawer   drawer;
+  
+  SketchStrokeToolImpl()
+    : drawing(false)
+  {
+    drawer = SpriteStrokeDrawer().to_drawer();
+    //drawer = MarkerStrokeDrawer().to_drawer();
+  }
+
+  void draw() 
+  {
+    if (drawing)
+      {
+        // FIXME: This translation is a bit ugly, layer position should be handled somewhat different
+        CL_Display::push_modelview();
+        CL_Display::add_translate(BitmapLayer::current()->to_object().get_pos().x,
+                                  BitmapLayer::current()->to_object().get_pos().y);
+        stroke.draw(0);
+        CL_Display::pop_modelview();
+      }
+    else
+      {
+        EditorMapComponent* parent = EditorMapComponent::current();
+        CL_Pointf p = parent->screen2world(CL_Point(CL_Mouse::get_x() - parent->get_screen_x(), 
+                                                    CL_Mouse::get_y() - parent->get_screen_y()));
+        CL_Sprite s = DrawerProperties::current()->get_brush().get_sprite();
+        s.set_color(DrawerProperties::current()->get_color());
+        // FIXME: when using mouse 1.0, when tablet .5f
+        s.set_scale(DrawerProperties::current()->get_size()*0.5f, DrawerProperties::current()->get_size()*0.5f);
+        s.set_alpha(0.5);
+        s.draw(p.x, p.y);
+      }
+  }
+
+  void on_mouse_up  (const CL_InputEvent& event) 
+  {
+    if (event.id == CL_MOUSE_LEFT && drawing)
+      {
+        drawing = false;
+        EditorMapComponent* parent = EditorMapComponent::current();
+        parent->release_mouse();
+        
+        add_dab(event);
+
+        BitmapLayer::current()->add_stroke(stroke);
+      }    
+  }
+
+  void on_mouse_down(const CL_InputEvent& event) {
+    if (event.id == CL_MOUSE_LEFT)
+      {
+        drawing = true;
+        EditorMapComponent* parent = EditorMapComponent::current();
+        parent->capture_mouse();
+        stroke = Stroke();
+        stroke.set_drawer(drawer.clone());
+        add_dab(event);
+      }
+  }
+
+  void add_dab(const CL_InputEvent& event)
+  {
+    EditorMapComponent* parent = EditorMapComponent::current();
+    CL_Pointf p = parent->screen2world(event.mouse_pos);    
+    
+    // FIXME: This is ugly, events relative to the layer should be handled somewhat differently
+    Dab dab(p.x - BitmapLayer::current()->to_object().get_pos().x,
+            p.y - BitmapLayer::current()->to_object().get_pos().y);
+
+    // FIXME: Make tablet configurable
+    if (CL_Display::get_current_window()->get_ic()->get_mouse_count() >= 4)
+      {
+        CL_InputDevice tablet = CL_Display::get_current_window()->get_ic()->get_mouse(5);
+
+        if (0)
+          {
+            std::cout << "Mouse Count: " << CL_Display::get_current_window()->get_ic()->get_mouse_count() << std::endl;
+            std::cout << tablet.get_name() << ": ";
+            for(int i = 0; i < tablet.get_axis_count(); ++i)
+              std::cout << tablet.get_axis(i) << " ";
+            std::cout << std::endl;
+          }
+
+        dab.pressure = tablet.get_axis(2);
+        dab.tilt.x   = tablet.get_axis(3);
+        dab.tilt.y   = tablet.get_axis(4);
+      }
+
+    //std::cout << dab.pressure << " " << dab.tilt.x << " " << dab.tilt.y << std::endl;
+
+    if (dab.pressure == 0) // most likly we are using the mouse
+      dab.pressure = 1.0f;
+
+    stroke.add_dab(dab);
+  }
+
+  void on_mouse_move(const CL_InputEvent& event) 
+  {
+    if (drawing)
+      {
+        add_dab(event);
+      }
+  }
+};
+
+SketchStrokeTool::SketchStrokeTool()
+  : impl(new SketchStrokeToolImpl()) 
+{
+}
+
+Tool
+SketchStrokeTool::to_tool()
+{
+  return Tool(impl);
+}
+
+StrokeDrawer
+SketchStrokeTool::get_drawer()
+{
+  return impl->drawer;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/sketch_stroke_tool.cxx
===================================================================
--- trunk/flexlay/lib/tools/sketch_stroke_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/sketch_stroke_tool.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,166 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#include <iostream>
-#include <assert.h>
-#include <ClanLib/gl.h>
-#include <ClanLib/Display/input_event.h>
-#include <ClanLib/Display/keys.h>
-#include <ClanLib/Display/mouse.h>
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/input_context.h>
-#include "editor_map_component.hxx"
-#include "tool.hxx"
-#include "bitmap_layer.hxx"
-#include "sketch_stroke_tool.hxx"
-#include "sprite_stroke_drawer.hxx"
-#include "marker_stroke_drawer.hxx"
-#include "stroke.hxx"
-#include "stroke_drawer.hxx"
-#include "drawer_properties.hxx"
-#include "flexlay.hxx"
-
-class SketchStrokeToolImpl : public ToolImpl
-{
-public:
-  bool drawing;
-  Stroke   stroke;
-  StrokeDrawer   drawer;
-  
-  SketchStrokeToolImpl()
-    : drawing(false)
-  {
-    drawer = SpriteStrokeDrawer().to_drawer();
-    //drawer = MarkerStrokeDrawer().to_drawer();
-  }
-
-  void draw() 
-  {
-    if (drawing)
-      {
-        // FIXME: This translation is a bit ugly, layer position should be handled somewhat different
-        CL_Display::push_modelview();
-        CL_Display::add_translate(BitmapLayer::current()->to_object().get_pos().x,
-                                  BitmapLayer::current()->to_object().get_pos().y);
-        stroke.draw(0);
-        CL_Display::pop_modelview();
-      }
-    else
-      {
-        EditorMapComponent* parent = EditorMapComponent::current();
-        CL_Pointf p = parent->screen2world(CL_Point(CL_Mouse::get_x() - parent->get_screen_x(), 
-                                                    CL_Mouse::get_y() - parent->get_screen_y()));
-        CL_Sprite s = DrawerProperties::current()->get_brush().get_sprite();
-        s.set_color(DrawerProperties::current()->get_color());
-        // FIXME: when using mouse 1.0, when tablet .5f
-        s.set_scale(DrawerProperties::current()->get_size()*0.5f, DrawerProperties::current()->get_size()*0.5f);
-        s.set_alpha(0.5);
-        s.draw(p.x, p.y);
-      }
-  }
-
-  void on_mouse_up  (const CL_InputEvent& event) 
-  {
-    if (event.id == CL_MOUSE_LEFT && drawing)
-      {
-        drawing = false;
-        EditorMapComponent* parent = EditorMapComponent::current();
-        parent->release_mouse();
-        
-        add_dab(event);
-
-        BitmapLayer::current()->add_stroke(stroke);
-      }    
-  }
-
-  void on_mouse_down(const CL_InputEvent& event) {
-    if (event.id == CL_MOUSE_LEFT)
-      {
-        drawing = true;
-        EditorMapComponent* parent = EditorMapComponent::current();
-        parent->capture_mouse();
-        stroke = Stroke();
-        stroke.set_drawer(drawer.clone());
-        add_dab(event);
-      }
-  }
-
-  void add_dab(const CL_InputEvent& event)
-  {
-    EditorMapComponent* parent = EditorMapComponent::current();
-    CL_Pointf p = parent->screen2world(event.mouse_pos);    
-    
-    // FIXME: This is ugly, events relative to the layer should be handled somewhat differently
-    Dab dab(p.x - BitmapLayer::current()->to_object().get_pos().x,
-            p.y - BitmapLayer::current()->to_object().get_pos().y);
-
-    // FIXME: Make tablet configurable
-    if (CL_Display::get_current_window()->get_ic()->get_mouse_count() >= 4)
-      {
-        CL_InputDevice tablet = CL_Display::get_current_window()->get_ic()->get_mouse(5);
-
-        if (0)
-          {
-            std::cout << "Mouse Count: " << CL_Display::get_current_window()->get_ic()->get_mouse_count() << std::endl;
-            std::cout << tablet.get_name() << ": ";
-            for(int i = 0; i < tablet.get_axis_count(); ++i)
-              std::cout << tablet.get_axis(i) << " ";
-            std::cout << std::endl;
-          }
-
-        dab.pressure = tablet.get_axis(2);
-        dab.tilt.x   = tablet.get_axis(3);
-        dab.tilt.y   = tablet.get_axis(4);
-      }
-
-    //std::cout << dab.pressure << " " << dab.tilt.x << " " << dab.tilt.y << std::endl;
-
-    if (dab.pressure == 0) // most likly we are using the mouse
-      dab.pressure = 1.0f;
-
-    stroke.add_dab(dab);
-  }
-
-  void on_mouse_move(const CL_InputEvent& event) 
-  {
-    if (drawing)
-      {
-        add_dab(event);
-      }
-  }
-};
-
-SketchStrokeTool::SketchStrokeTool()
-  : impl(new SketchStrokeToolImpl()) 
-{
-}
-
-Tool
-SketchStrokeTool::to_tool()
-{
-  return Tool(impl);
-}
-
-StrokeDrawer
-SketchStrokeTool::get_drawer()
-{
-  return impl->drawer;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/sketch_stroke_tool.hpp (from rev 712, trunk/flexlay/lib/tools/sketch_stroke_tool.hxx)
===================================================================
--- trunk/flexlay/lib/tools/sketch_stroke_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/sketch_stroke_tool.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,44 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#ifndef HEADER_SKETCH_STROKE_TOOL_HXX
+#define HEADER_SKETCH_STROKE_TOOL_HXX
+
+#include "tool_impl.hpp"
+#include "stroke_drawer.hpp"
+
+class SketchStrokeToolImpl;
+
+/** */
+class SketchStrokeTool
+{
+private:
+public:
+  SketchStrokeTool();
+
+  StrokeDrawer get_drawer();
+
+  Tool to_tool();
+private:
+  SharedPtr<SketchStrokeToolImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/sketch_stroke_tool.hxx
===================================================================
--- trunk/flexlay/lib/tools/sketch_stroke_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/sketch_stroke_tool.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,44 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#ifndef HEADER_SKETCH_STROKE_TOOL_HXX
-#define HEADER_SKETCH_STROKE_TOOL_HXX
-
-#include "tool_impl.hxx"
-#include "stroke_drawer.hxx"
-
-class SketchStrokeToolImpl;
-
-/** */
-class SketchStrokeTool
-{
-private:
-public:
-  SketchStrokeTool();
-
-  StrokeDrawer get_drawer();
-
-  Tool to_tool();
-private:
-  SharedPtr<SketchStrokeToolImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/tilemap_paint_tool.cpp (from rev 712, trunk/flexlay/lib/tools/tilemap_paint_tool.cxx)
===================================================================
--- trunk/flexlay/lib/tools/tilemap_paint_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tilemap_paint_tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,288 @@
+//  $Id: tilemap_paint_tool.cxx,v 1.2 2003/09/23 22:07:32 grumbel Exp $
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#include <iostream>
+#include <ClanLib/Display/mouse.h>
+#include <ClanLib/Display/keyboard.h>
+#include <ClanLib/Display/keys.h>
+#include <ClanLib/Display/display.h>
+
+#include "globals.hpp"
+#include "tilemap_layer.hpp"
+#include "tileset.hpp"
+#include "editor_map.hpp"
+#include "editor_map_component.hpp"
+#include "tile.hpp"
+#include "workspace.hpp"
+#include "paint_command.hpp"
+#include "editor_names.hpp"
+#include "tile_selection.hpp"
+#include "tool_impl.hpp"
+#include "tilemap_paint_tool.hpp"
+
+TileMapPaintTool TileMapPaintTool::current_;
+
+class TileMapPaintToolImpl : public ToolImpl
+{
+public:
+  enum { PAINTING, SELECTING, NONE } mode;
+
+  TileSelection selection;
+  TileBrush brush;
+  CL_Point last_draw;
+  CL_Point current_tile;
+
+  PaintCommand* command;
+
+  void draw();
+
+  void on_mouse_down(const CL_InputEvent& event);
+  void on_mouse_move(const CL_InputEvent& event);
+  void on_mouse_up  (const CL_InputEvent& event);
+};
+
+TileMapPaintTool::TileMapPaintTool()
+  : impl(new TileMapPaintToolImpl())
+{
+  impl->last_draw = CL_Point(-1, -1);
+
+  current_  = *this;
+  
+  impl->brush = TileBrush(1, 1);
+  impl->brush.at(0, 0) = 0;
+  impl->brush.set_opaque();
+  impl->current_tile = CL_Point(0,0);
+
+  impl->command = 0;
+
+  impl->mode = TileMapPaintToolImpl::NONE;
+}
+
+TileMapPaintTool::~TileMapPaintTool()
+{
+}
+
+void
+TileMapPaintToolImpl::draw()
+{
+  TilemapLayer tilemap = TilemapLayer::current();
+
+  if (tilemap.is_null())
+    return;
+
+  switch(mode)
+    {
+    case TileMapPaintToolImpl::SELECTING:
+      if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT))
+        selection.draw(CL_Color(255,  128, 128, 100));
+      else 
+        selection.draw();
+      break;
+      
+    default:
+      int tile_size = tilemap.get_tileset().get_tile_size();
+
+      // Draw the brush:
+      for(int y = 0; y < brush.get_height(); ++y)
+        for(int x = 0; x < brush.get_width(); ++x)
+          {
+            Tile* tile = tilemap.get_tileset().create(brush.at(x, y));
+                
+            if (tile)
+              {
+                CL_Sprite sprite = tile->get_sprite();
+                sprite.set_alpha(0.5f);
+                sprite.draw((current_tile.x + x) * tile_size, 
+                            (current_tile.y + y) * tile_size);
+
+                CL_Display::fill_rect(CL_Rect(CL_Point((current_tile.x + x) * tile_size, 
+                                                       (current_tile.y + y) * tile_size),
+                                              CL_Size(tile_size, tile_size)),
+                                      CL_Color(255, 255, 255, 100));
+              }
+            else if (brush.is_opaque())
+              {
+                CL_Display::fill_rect(CL_Rect(CL_Point((current_tile.x + x) * tile_size, 
+                                                       (current_tile.y + y) * tile_size),
+                                              CL_Size(tile_size, tile_size)),
+                                      CL_Color(255, 255, 255, 100));
+              }
+            else
+              {
+                CL_Display::fill_rect(CL_Rect(CL_Point((current_tile.x + x) * tile_size, 
+                                                       (current_tile.y + y) * tile_size),
+                                              CL_Size(tile_size, tile_size)),
+                                      CL_Color(255, 255, 255, 50));
+              }
+          }
+      break;
+    }
+}
+
+const TileBrush& 
+TileMapPaintTool::get_brush() 
+{
+  return impl->brush; 
+}
+
+void
+TileMapPaintToolImpl::on_mouse_down(const CL_InputEvent& event)
+{
+  TilemapLayer tilemap = TilemapLayer::current();
+
+  if (!tilemap.is_null())
+    {
+      EditorMapComponent* parent = EditorMapComponent::current();
+      CL_Point pos = tilemap.world2tile(parent->screen2world(event.mouse_pos));
+
+      switch (mode)
+        {
+        case TileMapPaintToolImpl::NONE:
+          switch (event.id)
+            {
+            case CL_MOUSE_LEFT:
+              mode = TileMapPaintToolImpl::PAINTING;
+              parent->capture_mouse();
+              command = new PaintCommand(tilemap, brush);
+              command->add_point(pos);
+              last_draw = pos;
+              break;
+    
+            case CL_MOUSE_RIGHT:
+              mode = TileMapPaintToolImpl::SELECTING;
+              parent->capture_mouse();
+
+              selection.start(tilemap, pos);
+              break;
+            }
+          break;
+
+        default:
+          break;
+        }
+    }
+}
+ 
+void
+TileMapPaintToolImpl::on_mouse_move(const CL_InputEvent& event)
+{
+  TilemapLayer tilemap = TilemapLayer::current();
+
+  if (!tilemap.is_null())
+    {
+      EditorMapComponent* parent = EditorMapComponent::current();
+      current_tile = tilemap.world2tile(parent->screen2world(event.mouse_pos));
+
+      switch (mode)
+        {
+        case PAINTING:
+          if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT) ||
+              (current_tile.x % brush.get_width()) == (last_draw.x % brush.get_width()) &&
+              (current_tile.y % brush.get_height() == (last_draw.y % brush.get_height())))
+            {
+              command->add_point(current_tile);
+              last_draw = current_tile;
+            }
+          break;
+    
+        case SELECTING:
+          selection.update(current_tile);
+          break;
+      
+        default:
+          break;
+        }
+    }
+}
+
+void
+TileMapPaintToolImpl::on_mouse_up  (const CL_InputEvent& event)
+{
+  TilemapLayer tilemap = TilemapLayer::current();
+
+  if (!tilemap.is_null())
+    {
+      EditorMapComponent::current()->get_workspace().get_map().modify();
+
+      EditorMapComponent* parent = EditorMapComponent::current();
+      current_tile = tilemap.world2tile(parent->screen2world(event.mouse_pos));
+
+      switch (event.id)
+        {
+        case CL_MOUSE_LEFT:
+          if (mode == PAINTING)
+            {
+              parent->release_mouse();
+              mode = NONE;
+
+              if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT) ||
+                  (current_tile.x % brush.get_width()) == (last_draw.x % brush.get_width()) &&
+                  (current_tile.y % brush.get_height() == (last_draw.y % brush.get_height())))
+                {
+                  command->add_point(current_tile);
+                }
+
+              Workspace::current().get_map().execute(command->to_command());
+              command = 0;
+
+              tilemap.draw_tile(brush, current_tile);
+              last_draw = CL_Point(-1, -1);
+            }
+          break;
+    
+        case CL_MOUSE_RIGHT:
+          if (mode == SELECTING)
+            {
+              parent->release_mouse();
+              mode = NONE;
+
+              selection.update(current_tile);
+              brush = selection.get_brush(*tilemap.get_field());
+
+              if ((brush.get_width() > 1 || brush.get_height() > 1)
+                  && !CL_Keyboard::get_keycode(CL_KEY_LSHIFT))
+                {
+                  brush.set_transparent();
+                  brush.auto_crop();
+                }
+              else
+                {
+                  brush.set_opaque();
+                }
+
+              selection.clear();
+            }
+          break;
+        }
+    }
+}
+
+void
+TileMapPaintTool::set_brush(const TileBrush& b)
+{
+  impl->brush = b;
+}
+
+Tool
+TileMapPaintTool::to_tool()
+{ 
+  return Tool(impl);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/tilemap_paint_tool.cxx
===================================================================
--- trunk/flexlay/lib/tools/tilemap_paint_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tilemap_paint_tool.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,288 +0,0 @@
-//  $Id: tilemap_paint_tool.cxx,v 1.2 2003/09/23 22:07:32 grumbel Exp $
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#include <iostream>
-#include <ClanLib/Display/mouse.h>
-#include <ClanLib/Display/keyboard.h>
-#include <ClanLib/Display/keys.h>
-#include <ClanLib/Display/display.h>
-
-#include "globals.hxx"
-#include "tilemap_layer.hxx"
-#include "tileset.hxx"
-#include "editor_map.hxx"
-#include "editor_map_component.hxx"
-#include "tile.hxx"
-#include "workspace.hxx"
-#include "paint_command.hxx"
-#include "editor_names.hxx"
-#include "tile_selection.hxx"
-#include "tool_impl.hxx"
-#include "tilemap_paint_tool.hxx"
-
-TileMapPaintTool TileMapPaintTool::current_;
-
-class TileMapPaintToolImpl : public ToolImpl
-{
-public:
-  enum { PAINTING, SELECTING, NONE } mode;
-
-  TileSelection selection;
-  TileBrush brush;
-  CL_Point last_draw;
-  CL_Point current_tile;
-
-  PaintCommand* command;
-
-  void draw();
-
-  void on_mouse_down(const CL_InputEvent& event);
-  void on_mouse_move(const CL_InputEvent& event);
-  void on_mouse_up  (const CL_InputEvent& event);
-};
-
-TileMapPaintTool::TileMapPaintTool()
-  : impl(new TileMapPaintToolImpl())
-{
-  impl->last_draw = CL_Point(-1, -1);
-
-  current_  = *this;
-  
-  impl->brush = TileBrush(1, 1);
-  impl->brush.at(0, 0) = 0;
-  impl->brush.set_opaque();
-  impl->current_tile = CL_Point(0,0);
-
-  impl->command = 0;
-
-  impl->mode = TileMapPaintToolImpl::NONE;
-}
-
-TileMapPaintTool::~TileMapPaintTool()
-{
-}
-
-void
-TileMapPaintToolImpl::draw()
-{
-  TilemapLayer tilemap = TilemapLayer::current();
-
-  if (tilemap.is_null())
-    return;
-
-  switch(mode)
-    {
-    case TileMapPaintToolImpl::SELECTING:
-      if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT))
-        selection.draw(CL_Color(255,  128, 128, 100));
-      else 
-        selection.draw();
-      break;
-      
-    default:
-      int tile_size = tilemap.get_tileset().get_tile_size();
-
-      // Draw the brush:
-      for(int y = 0; y < brush.get_height(); ++y)
-        for(int x = 0; x < brush.get_width(); ++x)
-          {
-            Tile* tile = tilemap.get_tileset().create(brush.at(x, y));
-                
-            if (tile)
-              {
-                CL_Sprite sprite = tile->get_sprite();
-                sprite.set_alpha(0.5f);
-                sprite.draw((current_tile.x + x) * tile_size, 
-                            (current_tile.y + y) * tile_size);
-
-                CL_Display::fill_rect(CL_Rect(CL_Point((current_tile.x + x) * tile_size, 
-                                                       (current_tile.y + y) * tile_size),
-                                              CL_Size(tile_size, tile_size)),
-                                      CL_Color(255, 255, 255, 100));
-              }
-            else if (brush.is_opaque())
-              {
-                CL_Display::fill_rect(CL_Rect(CL_Point((current_tile.x + x) * tile_size, 
-                                                       (current_tile.y + y) * tile_size),
-                                              CL_Size(tile_size, tile_size)),
-                                      CL_Color(255, 255, 255, 100));
-              }
-            else
-              {
-                CL_Display::fill_rect(CL_Rect(CL_Point((current_tile.x + x) * tile_size, 
-                                                       (current_tile.y + y) * tile_size),
-                                              CL_Size(tile_size, tile_size)),
-                                      CL_Color(255, 255, 255, 50));
-              }
-          }
-      break;
-    }
-}
-
-const TileBrush& 
-TileMapPaintTool::get_brush() 
-{
-  return impl->brush; 
-}
-
-void
-TileMapPaintToolImpl::on_mouse_down(const CL_InputEvent& event)
-{
-  TilemapLayer tilemap = TilemapLayer::current();
-
-  if (!tilemap.is_null())
-    {
-      EditorMapComponent* parent = EditorMapComponent::current();
-      CL_Point pos = tilemap.world2tile(parent->screen2world(event.mouse_pos));
-
-      switch (mode)
-        {
-        case TileMapPaintToolImpl::NONE:
-          switch (event.id)
-            {
-            case CL_MOUSE_LEFT:
-              mode = TileMapPaintToolImpl::PAINTING;
-              parent->capture_mouse();
-              command = new PaintCommand(tilemap, brush);
-              command->add_point(pos);
-              last_draw = pos;
-              break;
-    
-            case CL_MOUSE_RIGHT:
-              mode = TileMapPaintToolImpl::SELECTING;
-              parent->capture_mouse();
-
-              selection.start(tilemap, pos);
-              break;
-            }
-          break;
-
-        default:
-          break;
-        }
-    }
-}
- 
-void
-TileMapPaintToolImpl::on_mouse_move(const CL_InputEvent& event)
-{
-  TilemapLayer tilemap = TilemapLayer::current();
-
-  if (!tilemap.is_null())
-    {
-      EditorMapComponent* parent = EditorMapComponent::current();
-      current_tile = tilemap.world2tile(parent->screen2world(event.mouse_pos));
-
-      switch (mode)
-        {
-        case PAINTING:
-          if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT) ||
-              (current_tile.x % brush.get_width()) == (last_draw.x % brush.get_width()) &&
-              (current_tile.y % brush.get_height() == (last_draw.y % brush.get_height())))
-            {
-              command->add_point(current_tile);
-              last_draw = current_tile;
-            }
-          break;
-    
-        case SELECTING:
-          selection.update(current_tile);
-          break;
-      
-        default:
-          break;
-        }
-    }
-}
-
-void
-TileMapPaintToolImpl::on_mouse_up  (const CL_InputEvent& event)
-{
-  TilemapLayer tilemap = TilemapLayer::current();
-
-  if (!tilemap.is_null())
-    {
-      EditorMapComponent::current()->get_workspace().get_map().modify();
-
-      EditorMapComponent* parent = EditorMapComponent::current();
-      current_tile = tilemap.world2tile(parent->screen2world(event.mouse_pos));
-
-      switch (event.id)
-        {
-        case CL_MOUSE_LEFT:
-          if (mode == PAINTING)
-            {
-              parent->release_mouse();
-              mode = NONE;
-
-              if (CL_Keyboard::get_keycode(CL_KEY_LSHIFT) ||
-                  (current_tile.x % brush.get_width()) == (last_draw.x % brush.get_width()) &&
-                  (current_tile.y % brush.get_height() == (last_draw.y % brush.get_height())))
-                {
-                  command->add_point(current_tile);
-                }
-
-              Workspace::current().get_map().execute(command->to_command());
-              command = 0;
-
-              tilemap.draw_tile(brush, current_tile);
-              last_draw = CL_Point(-1, -1);
-            }
-          break;
-    
-        case CL_MOUSE_RIGHT:
-          if (mode == SELECTING)
-            {
-              parent->release_mouse();
-              mode = NONE;
-
-              selection.update(current_tile);
-              brush = selection.get_brush(*tilemap.get_field());
-
-              if ((brush.get_width() > 1 || brush.get_height() > 1)
-                  && !CL_Keyboard::get_keycode(CL_KEY_LSHIFT))
-                {
-                  brush.set_transparent();
-                  brush.auto_crop();
-                }
-              else
-                {
-                  brush.set_opaque();
-                }
-
-              selection.clear();
-            }
-          break;
-        }
-    }
-}
-
-void
-TileMapPaintTool::set_brush(const TileBrush& b)
-{
-  impl->brush = b;
-}
-
-Tool
-TileMapPaintTool::to_tool()
-{ 
-  return Tool(impl);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/tilemap_paint_tool.hpp (from rev 712, trunk/flexlay/lib/tools/tilemap_paint_tool.hxx)
===================================================================
--- trunk/flexlay/lib/tools/tilemap_paint_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tilemap_paint_tool.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,50 @@
+//  $Id: tilemap_paint_tool.hpp,v 1.1 2003/09/23 19:10:05 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#ifndef HEADER_TILEMAP_PAINT_TOOL_HXX
+#define HEADER_TILEMAP_PAINT_TOOL_HXX
+
+#include "tool.hpp"
+#include "tile_brush.hpp"
+#include "tilemap_layer.hpp"
+
+class TileMapPaintToolImpl;
+
+/** */
+class TileMapPaintTool
+{
+private:
+  static TileMapPaintTool current_; 
+public:
+  static TileMapPaintTool current() { return current_; } 
+
+  TileMapPaintTool();
+  ~TileMapPaintTool();
+  
+  const TileBrush& get_brush();
+  void set_brush(const TileBrush& b);
+
+  Tool to_tool();
+private:
+  SharedPtr<TileMapPaintToolImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/tilemap_paint_tool.hxx
===================================================================
--- trunk/flexlay/lib/tools/tilemap_paint_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tilemap_paint_tool.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,50 +0,0 @@
-//  $Id: tilemap_paint_tool.hxx,v 1.1 2003/09/23 19:10:05 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#ifndef HEADER_TILEMAP_PAINT_TOOL_HXX
-#define HEADER_TILEMAP_PAINT_TOOL_HXX
-
-#include "tool.hxx"
-#include "tile_brush.hxx"
-#include "tilemap_layer.hxx"
-
-class TileMapPaintToolImpl;
-
-/** */
-class TileMapPaintTool
-{
-private:
-  static TileMapPaintTool current_; 
-public:
-  static TileMapPaintTool current() { return current_; } 
-
-  TileMapPaintTool();
-  ~TileMapPaintTool();
-  
-  const TileBrush& get_brush();
-  void set_brush(const TileBrush& b);
-
-  Tool to_tool();
-private:
-  SharedPtr<TileMapPaintToolImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/tilemap_select_tool.cpp (from rev 712, trunk/flexlay/lib/tools/tilemap_select_tool.cxx)
===================================================================
--- trunk/flexlay/lib/tools/tilemap_select_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tilemap_select_tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,133 @@
+//  $Id: tilemap_select_tool.cxx,v 1.1 2003/09/23 22:10:40 grumbel Exp $
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#include <ClanLib/Display/display.h>
+#include <ClanLib/Display/keys.h>
+#include <ClanLib/Display/input_event.h>
+#include "globals.hpp"
+#include "tilemap_layer.hpp"
+#include "tool_impl.hpp"
+#include "editor_map.hpp"
+#include "editor_map_component.hpp"
+#include "tile_brush.hpp"
+#include "editor_names.hpp"
+#include "tilemap_select_tool.hpp"
+
+class TileMapSelectToolImpl : public ToolImpl
+{
+public:
+  TileSelection  selection;
+  bool creating_selection;
+
+  void draw();
+  
+  void on_mouse_up  (const CL_InputEvent& event);
+  void on_mouse_down(const CL_InputEvent& event);
+  void on_mouse_move(const CL_InputEvent& event);
+};
+
+TileMapSelectTool::TileMapSelectTool()
+  : impl(new TileMapSelectToolImpl())
+{
+  impl->creating_selection = false;
+}
+
+TileMapSelectTool::~TileMapSelectTool()
+{
+}
+
+void
+TileMapSelectToolImpl::draw()
+{
+  if (selection.is_active())
+    {
+      selection.draw();
+    }
+}
+
+void
+TileMapSelectToolImpl::on_mouse_up  (const CL_InputEvent& event)
+{
+  EditorMapComponent* parent = EditorMapComponent::current();
+
+  switch (event.id)
+    {
+    case CL_MOUSE_LEFT:
+      creating_selection = false;
+      parent->release_mouse();
+
+      selection.update(TilemapLayer::current().world2tile(parent->screen2world(event.mouse_pos)));
+      break;
+    }
+}
+
+void
+TileMapSelectToolImpl::on_mouse_down(const CL_InputEvent& event)
+{
+  EditorMapComponent* parent = EditorMapComponent::current();
+
+  switch (event.id)
+    {
+    case CL_MOUSE_LEFT:
+      {
+        creating_selection = true;
+        parent->capture_mouse();
+        TilemapLayer tilemap = TilemapLayer::current();
+        selection.start(tilemap, tilemap.world2tile(parent->screen2world(event.mouse_pos)));
+      }
+      break;
+      
+    case CL_MOUSE_RIGHT:
+      if (!creating_selection)
+        selection.clear();
+      break;
+    }
+}
+
+void
+TileMapSelectToolImpl::on_mouse_move(const CL_InputEvent& event)
+{ 
+  EditorMapComponent* parent = EditorMapComponent::current();
+
+  if (creating_selection)
+    {
+      selection.update(TilemapLayer::current().world2tile(parent->screen2world(event.mouse_pos)));
+    }
+}
+
+TileBrush
+TileMapSelectTool::get_selection() const
+{
+  TilemapLayer tilemap = TilemapLayer::current();
+  return impl->selection.get_brush(*tilemap.get_field());
+}
+
+CL_Rect
+TileMapSelectTool::get_selection_rect() const
+{
+  return impl->selection.get_rect();
+}
+
+Tool
+TileMapSelectTool::to_tool()
+{
+  return Tool(impl); 
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/tilemap_select_tool.cxx
===================================================================
--- trunk/flexlay/lib/tools/tilemap_select_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tilemap_select_tool.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,133 +0,0 @@
-//  $Id: tilemap_select_tool.cxx,v 1.1 2003/09/23 22:10:40 grumbel Exp $
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/keys.h>
-#include <ClanLib/Display/input_event.h>
-#include "globals.hxx"
-#include "tilemap_layer.hxx"
-#include "tool_impl.hxx"
-#include "editor_map.hxx"
-#include "editor_map_component.hxx"
-#include "tile_brush.hxx"
-#include "editor_names.hxx"
-#include "tilemap_select_tool.hxx"
-
-class TileMapSelectToolImpl : public ToolImpl
-{
-public:
-  TileSelection  selection;
-  bool creating_selection;
-
-  void draw();
-  
-  void on_mouse_up  (const CL_InputEvent& event);
-  void on_mouse_down(const CL_InputEvent& event);
-  void on_mouse_move(const CL_InputEvent& event);
-};
-
-TileMapSelectTool::TileMapSelectTool()
-  : impl(new TileMapSelectToolImpl())
-{
-  impl->creating_selection = false;
-}
-
-TileMapSelectTool::~TileMapSelectTool()
-{
-}
-
-void
-TileMapSelectToolImpl::draw()
-{
-  if (selection.is_active())
-    {
-      selection.draw();
-    }
-}
-
-void
-TileMapSelectToolImpl::on_mouse_up  (const CL_InputEvent& event)
-{
-  EditorMapComponent* parent = EditorMapComponent::current();
-
-  switch (event.id)
-    {
-    case CL_MOUSE_LEFT:
-      creating_selection = false;
-      parent->release_mouse();
-
-      selection.update(TilemapLayer::current().world2tile(parent->screen2world(event.mouse_pos)));
-      break;
-    }
-}
-
-void
-TileMapSelectToolImpl::on_mouse_down(const CL_InputEvent& event)
-{
-  EditorMapComponent* parent = EditorMapComponent::current();
-
-  switch (event.id)
-    {
-    case CL_MOUSE_LEFT:
-      {
-        creating_selection = true;
-        parent->capture_mouse();
-        TilemapLayer tilemap = TilemapLayer::current();
-        selection.start(tilemap, tilemap.world2tile(parent->screen2world(event.mouse_pos)));
-      }
-      break;
-      
-    case CL_MOUSE_RIGHT:
-      if (!creating_selection)
-        selection.clear();
-      break;
-    }
-}
-
-void
-TileMapSelectToolImpl::on_mouse_move(const CL_InputEvent& event)
-{ 
-  EditorMapComponent* parent = EditorMapComponent::current();
-
-  if (creating_selection)
-    {
-      selection.update(TilemapLayer::current().world2tile(parent->screen2world(event.mouse_pos)));
-    }
-}
-
-TileBrush
-TileMapSelectTool::get_selection() const
-{
-  TilemapLayer tilemap = TilemapLayer::current();
-  return impl->selection.get_brush(*tilemap.get_field());
-}
-
-CL_Rect
-TileMapSelectTool::get_selection_rect() const
-{
-  return impl->selection.get_rect();
-}
-
-Tool
-TileMapSelectTool::to_tool()
-{
-  return Tool(impl); 
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/tilemap_select_tool.hpp (from rev 712, trunk/flexlay/lib/tools/tilemap_select_tool.hxx)
===================================================================
--- trunk/flexlay/lib/tools/tilemap_select_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tilemap_select_tool.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,49 @@
+//  $Id: tilemap_select_tool.hpp,v 1.1 2003/09/23 22:10:40 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#ifndef HEADER_TILEMAP_SELECT_TOOL_HXX
+#define HEADER_TILEMAP_SELECT_TOOL_HXX
+
+#include <ClanLib/Core/Math/rect.h>
+#include <ClanLib/Core/Math/point.h>
+#include "tool.hpp"
+#include "tile_selection.hpp"
+
+class TileMapSelectToolImpl;
+
+/** */
+class TileMapSelectTool
+{
+public:
+  TileMapSelectTool();
+  ~TileMapSelectTool();
+
+  /** Convert the selection into a TileBrush */
+  TileBrush get_selection() const;
+
+  CL_Rect get_selection_rect() const;
+
+  Tool to_tool();
+private:
+  SharedPtr<TileMapSelectToolImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/tilemap_select_tool.hxx
===================================================================
--- trunk/flexlay/lib/tools/tilemap_select_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tilemap_select_tool.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,49 +0,0 @@
-//  $Id: tilemap_select_tool.hxx,v 1.1 2003/09/23 22:10:40 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#ifndef HEADER_TILEMAP_SELECT_TOOL_HXX
-#define HEADER_TILEMAP_SELECT_TOOL_HXX
-
-#include <ClanLib/Core/Math/rect.h>
-#include <ClanLib/Core/Math/point.h>
-#include "tool.hxx"
-#include "tile_selection.hxx"
-
-class TileMapSelectToolImpl;
-
-/** */
-class TileMapSelectTool
-{
-public:
-  TileMapSelectTool();
-  ~TileMapSelectTool();
-
-  /** Convert the selection into a TileBrush */
-  TileBrush get_selection() const;
-
-  CL_Rect get_selection_rect() const;
-
-  Tool to_tool();
-private:
-  SharedPtr<TileMapSelectToolImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/tool.cpp (from rev 712, trunk/flexlay/lib/tools/tool.cxx)
===================================================================
--- trunk/flexlay/lib/tools/tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,64 @@
+//  $Id: tilemap_tool.cxx,v 1.1 2003/09/23 19:10:05 grumbel Exp $
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#include "tool_impl.hpp"
+#include "tool.hpp"
+
+Tool::Tool()
+{
+}
+
+Tool::Tool(SharedPtr<ToolImpl> impl_)
+  : impl(impl_)
+{
+}
+
+Tool::~Tool() 
+{
+}
+
+void
+Tool::draw()
+{
+  if (impl.get())
+    impl->draw();
+}
+
+void
+Tool::on_mouse_up  (const CL_InputEvent& event)
+{
+  if (impl.get())
+    impl->on_mouse_up(event);
+}
+
+void
+Tool::on_mouse_down(const CL_InputEvent& event)
+{
+  if (impl.get())
+    impl->on_mouse_down(event);
+}
+
+void
+Tool::on_mouse_move(const CL_InputEvent& event)
+{
+  if (impl.get())
+    impl->on_mouse_move(event);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/tool.cxx
===================================================================
--- trunk/flexlay/lib/tools/tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tool.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,64 +0,0 @@
-//  $Id: tilemap_tool.cxx,v 1.1 2003/09/23 19:10:05 grumbel Exp $
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#include "tool_impl.hxx"
-#include "tool.hxx"
-
-Tool::Tool()
-{
-}
-
-Tool::Tool(SharedPtr<ToolImpl> impl_)
-  : impl(impl_)
-{
-}
-
-Tool::~Tool() 
-{
-}
-
-void
-Tool::draw()
-{
-  if (impl.get())
-    impl->draw();
-}
-
-void
-Tool::on_mouse_up  (const CL_InputEvent& event)
-{
-  if (impl.get())
-    impl->on_mouse_up(event);
-}
-
-void
-Tool::on_mouse_down(const CL_InputEvent& event)
-{
-  if (impl.get())
-    impl->on_mouse_down(event);
-}
-
-void
-Tool::on_mouse_move(const CL_InputEvent& event)
-{
-  if (impl.get())
-    impl->on_mouse_move(event);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/tool.hpp (from rev 712, trunk/flexlay/lib/tools/tool.hxx)
===================================================================
--- trunk/flexlay/lib/tools/tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tool.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,52 @@
+//  $Id: tilemap_tool.hpp,v 1.1 2003/09/23 19:10:05 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#ifndef HEADER_TILEMAP_TOOL_HXX
+#define HEADER_TILEMAP_TOOL_HXX
+
+class EditorMapComponent;
+class CL_InputEvent;
+
+#include "shared_ptr.hpp"
+
+class ToolImpl;
+
+/** */
+class Tool
+{
+protected:
+
+public:
+  Tool();
+  Tool(SharedPtr<ToolImpl> impl_);
+  ~Tool();
+
+  void draw();
+
+  void on_mouse_up  (const CL_InputEvent& event);
+  void on_mouse_down(const CL_InputEvent& event);
+  void on_mouse_move(const CL_InputEvent& event);
+
+private:
+  SharedPtr<ToolImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/tool.hxx
===================================================================
--- trunk/flexlay/lib/tools/tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tool.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,52 +0,0 @@
-//  $Id: tilemap_tool.hxx,v 1.1 2003/09/23 19:10:05 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#ifndef HEADER_TILEMAP_TOOL_HXX
-#define HEADER_TILEMAP_TOOL_HXX
-
-class EditorMapComponent;
-class CL_InputEvent;
-
-#include "shared_ptr.hxx"
-
-class ToolImpl;
-
-/** */
-class Tool
-{
-protected:
-
-public:
-  Tool();
-  Tool(SharedPtr<ToolImpl> impl_);
-  ~Tool();
-
-  void draw();
-
-  void on_mouse_up  (const CL_InputEvent& event);
-  void on_mouse_down(const CL_InputEvent& event);
-  void on_mouse_move(const CL_InputEvent& event);
-
-private:
-  SharedPtr<ToolImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/tool_impl.hpp (from rev 712, trunk/flexlay/lib/tools/tool_impl.hxx)
===================================================================
--- trunk/flexlay/lib/tools/tool_impl.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tool_impl.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,43 @@
+//  $Id: tilemap_tool.hpp,v 1.1 2003/09/23 19:10:05 grumbel Exp $
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#ifndef HEADER_TOOL_IMPL_HXX
+#define HEADER_TOOL_IMPL_HXX
+
+class CL_InputEvent;
+
+/** */
+class ToolImpl
+{
+protected:
+
+public:
+  ToolImpl() {}
+  virtual ~ToolImpl() {}
+
+  virtual void draw() {}
+
+  virtual void on_mouse_up  (const CL_InputEvent& event) {}
+  virtual void on_mouse_down(const CL_InputEvent& event) {}
+  virtual void on_mouse_move(const CL_InputEvent& event) {}
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/tool_impl.hxx
===================================================================
--- trunk/flexlay/lib/tools/tool_impl.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/tool_impl.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,43 +0,0 @@
-//  $Id: tilemap_tool.hxx,v 1.1 2003/09/23 19:10:05 grumbel Exp $
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#ifndef HEADER_TOOL_IMPL_HXX
-#define HEADER_TOOL_IMPL_HXX
-
-class CL_InputEvent;
-
-/** */
-class ToolImpl
-{
-protected:
-
-public:
-  ToolImpl() {}
-  virtual ~ToolImpl() {}
-
-  virtual void draw() {}
-
-  virtual void on_mouse_up  (const CL_InputEvent& event) {}
-  virtual void on_mouse_down(const CL_InputEvent& event) {}
-  virtual void on_mouse_move(const CL_InputEvent& event) {}
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/workspace_move_tool.cpp (from rev 712, trunk/flexlay/lib/tools/workspace_move_tool.cxx)
===================================================================
--- trunk/flexlay/lib/tools/workspace_move_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/workspace_move_tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,102 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#include <ClanLib/Core/Math/point.h>
+#include <ClanLib/Core/Math/rect.h>
+#include "tool_impl.hpp"
+#include "editor_map_component.hpp"
+#include "workspace.hpp"
+#include "workspace_move_tool.hpp"
+
+class WorkspaceMoveToolImpl : public ToolImpl
+{
+public:
+  bool scrolling;
+  CL_Point click_pos;
+
+  /** Position of the center */
+  CL_Pointf old_trans_offset;
+  
+  virtual void draw() {}
+
+  void on_mouse_up  (const CL_InputEvent& event);
+  void on_mouse_down(const CL_InputEvent& event);
+  void on_mouse_move(const CL_InputEvent& event);
+  void update(const CL_InputEvent& event);
+};
+
+void
+WorkspaceMoveToolImpl::on_mouse_down(const CL_InputEvent& event)
+{
+  scrolling = true;
+  old_trans_offset = EditorMapComponent::current()->get_gc_state().get_pos();
+  click_pos = event.mouse_pos;
+  EditorMapComponent::current()->capture_mouse();
+}
+
+void
+WorkspaceMoveToolImpl::on_mouse_up(const CL_InputEvent& event)
+{
+  scrolling = false;
+  update(event);
+  old_trans_offset = EditorMapComponent::current()->get_gc_state().get_pos();
+  EditorMapComponent::current()->release_mouse();
+}
+
+void
+WorkspaceMoveToolImpl::on_mouse_move(const CL_InputEvent& event)
+{
+  if (scrolling)
+    {
+      update(event);
+    } 
+}
+
+void
+WorkspaceMoveToolImpl::update(const CL_InputEvent& event)
+{
+  GraphicContextState& gc_state = EditorMapComponent::current()->get_gc_state();
+
+  float sa = sin(-gc_state.get_rotation()/180.0f*M_PI);
+  float ca = cos(-gc_state.get_rotation()/180.0f*M_PI);
+
+  float dx = ca * (click_pos.x - event.mouse_pos.x) - sa * (click_pos.y - event.mouse_pos.y);
+  float dy = sa * (click_pos.x - event.mouse_pos.x) + ca * (click_pos.y - event.mouse_pos.y);
+
+  gc_state.set_pos(CL_Pointf(old_trans_offset.x
+                             + dx / EditorMapComponent::current()->get_gc_state().get_zoom(),
+                             old_trans_offset.y
+                             + dy / EditorMapComponent::current()->get_gc_state().get_zoom()));
+}
+
+WorkspaceMoveTool::WorkspaceMoveTool()
+  : impl(new WorkspaceMoveToolImpl())
+{
+  impl->scrolling = false;
+  impl->click_pos = CL_Point(0, 0);
+  impl->old_trans_offset = CL_Pointf(0,0);
+}
+
+Tool
+WorkspaceMoveTool::to_tool()
+{
+  return Tool(impl);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/workspace_move_tool.cxx
===================================================================
--- trunk/flexlay/lib/tools/workspace_move_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/workspace_move_tool.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,102 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#include <ClanLib/Core/Math/point.h>
-#include <ClanLib/Core/Math/rect.h>
-#include "tool_impl.hxx"
-#include "editor_map_component.hxx"
-#include "workspace.hxx"
-#include "workspace_move_tool.hxx"
-
-class WorkspaceMoveToolImpl : public ToolImpl
-{
-public:
-  bool scrolling;
-  CL_Point click_pos;
-
-  /** Position of the center */
-  CL_Pointf old_trans_offset;
-  
-  virtual void draw() {}
-
-  void on_mouse_up  (const CL_InputEvent& event);
-  void on_mouse_down(const CL_InputEvent& event);
-  void on_mouse_move(const CL_InputEvent& event);
-  void update(const CL_InputEvent& event);
-};
-
-void
-WorkspaceMoveToolImpl::on_mouse_down(const CL_InputEvent& event)
-{
-  scrolling = true;
-  old_trans_offset = EditorMapComponent::current()->get_gc_state().get_pos();
-  click_pos = event.mouse_pos;
-  EditorMapComponent::current()->capture_mouse();
-}
-
-void
-WorkspaceMoveToolImpl::on_mouse_up(const CL_InputEvent& event)
-{
-  scrolling = false;
-  update(event);
-  old_trans_offset = EditorMapComponent::current()->get_gc_state().get_pos();
-  EditorMapComponent::current()->release_mouse();
-}
-
-void
-WorkspaceMoveToolImpl::on_mouse_move(const CL_InputEvent& event)
-{
-  if (scrolling)
-    {
-      update(event);
-    } 
-}
-
-void
-WorkspaceMoveToolImpl::update(const CL_InputEvent& event)
-{
-  GraphicContextState& gc_state = EditorMapComponent::current()->get_gc_state();
-
-  float sa = sin(-gc_state.get_rotation()/180.0f*M_PI);
-  float ca = cos(-gc_state.get_rotation()/180.0f*M_PI);
-
-  float dx = ca * (click_pos.x - event.mouse_pos.x) - sa * (click_pos.y - event.mouse_pos.y);
-  float dy = sa * (click_pos.x - event.mouse_pos.x) + ca * (click_pos.y - event.mouse_pos.y);
-
-  gc_state.set_pos(CL_Pointf(old_trans_offset.x
-                             + dx / EditorMapComponent::current()->get_gc_state().get_zoom(),
-                             old_trans_offset.y
-                             + dy / EditorMapComponent::current()->get_gc_state().get_zoom()));
-}
-
-WorkspaceMoveTool::WorkspaceMoveTool()
-  : impl(new WorkspaceMoveToolImpl())
-{
-  impl->scrolling = false;
-  impl->click_pos = CL_Point(0, 0);
-  impl->old_trans_offset = CL_Pointf(0,0);
-}
-
-Tool
-WorkspaceMoveTool::to_tool()
-{
-  return Tool(impl);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/workspace_move_tool.hpp (from rev 712, trunk/flexlay/lib/tools/workspace_move_tool.hxx)
===================================================================
--- trunk/flexlay/lib/tools/workspace_move_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/workspace_move_tool.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,40 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#ifndef HEADER_WORKSPACE_MOVE_TOOL_HXX
+#define HEADER_WORKSPACE_MOVE_TOOL_HXX
+
+#include "tool.hpp"
+
+class WorkspaceMoveToolImpl;
+
+/** */
+class WorkspaceMoveTool
+{
+public:
+  WorkspaceMoveTool();
+
+  Tool to_tool();
+private:
+  SharedPtr<WorkspaceMoveToolImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/workspace_move_tool.hxx
===================================================================
--- trunk/flexlay/lib/tools/workspace_move_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/workspace_move_tool.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,40 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#ifndef HEADER_WORKSPACE_MOVE_TOOL_HXX
-#define HEADER_WORKSPACE_MOVE_TOOL_HXX
-
-#include "tool.hxx"
-
-class WorkspaceMoveToolImpl;
-
-/** */
-class WorkspaceMoveTool
-{
-public:
-  WorkspaceMoveTool();
-
-  Tool to_tool();
-private:
-  SharedPtr<WorkspaceMoveToolImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/zoom2_tool.cpp (from rev 712, trunk/flexlay/lib/tools/zoom2_tool.cxx)
===================================================================
--- trunk/flexlay/lib/tools/zoom2_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/zoom2_tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,96 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#include <ClanLib/Display/keys.h>
+#include <ClanLib/Display/display.h>
+#include "editor_map_component.hpp"
+#include "tool_impl.hpp"
+#include "zoom2_tool.hpp"
+
+class Zoom2ToolImpl : public ToolImpl
+{
+public:
+  bool active;
+  CL_Point click_pos;
+  float old_zoom;
+  void draw();
+  
+  void on_mouse_up  (const CL_InputEvent& event);
+  void on_mouse_down(const CL_InputEvent& event);
+  void on_mouse_move(const CL_InputEvent& event);
+};
+
+Zoom2Tool::Zoom2Tool()
+  : impl(new Zoom2ToolImpl())
+{
+  impl->active = false;
+}
+
+Zoom2Tool::~Zoom2Tool()
+{
+}
+
+void
+Zoom2ToolImpl::draw()
+{
+}
+
+void
+Zoom2ToolImpl::on_mouse_up  (const CL_InputEvent& event)
+{
+  active = false;
+}
+
+void
+Zoom2ToolImpl::on_mouse_down(const CL_InputEvent& event)
+{
+  active = true;
+  click_pos = event.mouse_pos;
+
+  GraphicContextState& gc = EditorMapComponent::current()->get_gc_state();
+  old_zoom = gc.get_zoom();
+}
+
+void
+Zoom2ToolImpl::on_mouse_move(const CL_InputEvent& event)
+{
+  if (active)
+    {
+      GraphicContextState& gc = EditorMapComponent::current()->get_gc_state();
+
+      CL_Point zoom_pos(gc.get_width()/2,
+                        gc.get_height()/2);
+      
+      float factor = (event.mouse_pos.y - click_pos.y) / 20.0f;
+      if (factor > 0)
+        gc.set_zoom(zoom_pos, old_zoom * pow(1.25f, factor));
+      else if (factor < 0)
+        gc.set_zoom(zoom_pos, old_zoom / pow(1.25f, -factor));
+      else
+        gc.set_zoom(zoom_pos, old_zoom);
+    }
+}
+
+Tool
+Zoom2Tool::to_tool()
+{
+  return Tool(impl); 
+}  
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/zoom2_tool.cxx
===================================================================
--- trunk/flexlay/lib/tools/zoom2_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/zoom2_tool.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,96 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#include <ClanLib/Display/keys.h>
-#include <ClanLib/Display/display.h>
-#include "editor_map_component.hxx"
-#include "tool_impl.hxx"
-#include "zoom2_tool.hxx"
-
-class Zoom2ToolImpl : public ToolImpl
-{
-public:
-  bool active;
-  CL_Point click_pos;
-  float old_zoom;
-  void draw();
-  
-  void on_mouse_up  (const CL_InputEvent& event);
-  void on_mouse_down(const CL_InputEvent& event);
-  void on_mouse_move(const CL_InputEvent& event);
-};
-
-Zoom2Tool::Zoom2Tool()
-  : impl(new Zoom2ToolImpl())
-{
-  impl->active = false;
-}
-
-Zoom2Tool::~Zoom2Tool()
-{
-}
-
-void
-Zoom2ToolImpl::draw()
-{
-}
-
-void
-Zoom2ToolImpl::on_mouse_up  (const CL_InputEvent& event)
-{
-  active = false;
-}
-
-void
-Zoom2ToolImpl::on_mouse_down(const CL_InputEvent& event)
-{
-  active = true;
-  click_pos = event.mouse_pos;
-
-  GraphicContextState& gc = EditorMapComponent::current()->get_gc_state();
-  old_zoom = gc.get_zoom();
-}
-
-void
-Zoom2ToolImpl::on_mouse_move(const CL_InputEvent& event)
-{
-  if (active)
-    {
-      GraphicContextState& gc = EditorMapComponent::current()->get_gc_state();
-
-      CL_Point zoom_pos(gc.get_width()/2,
-                        gc.get_height()/2);
-      
-      float factor = (event.mouse_pos.y - click_pos.y) / 20.0f;
-      if (factor > 0)
-        gc.set_zoom(zoom_pos, old_zoom * pow(1.25f, factor));
-      else if (factor < 0)
-        gc.set_zoom(zoom_pos, old_zoom / pow(1.25f, -factor));
-      else
-        gc.set_zoom(zoom_pos, old_zoom);
-    }
-}
-
-Tool
-Zoom2Tool::to_tool()
-{
-  return Tool(impl); 
-}  
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/zoom2_tool.hpp (from rev 712, trunk/flexlay/lib/tools/zoom2_tool.hxx)
===================================================================
--- trunk/flexlay/lib/tools/zoom2_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/zoom2_tool.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,43 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#ifndef HEADER_ZOOM2_TOOL_HXX
+#define HEADER_ZOOM2_TOOL_HXX
+
+#include <ClanLib/Core/Math/rect.h>
+#include <ClanLib/Display/input_event.h>
+#include "tool.hpp"
+
+class Zoom2ToolImpl;
+
+/** */
+class Zoom2Tool
+{
+public:
+  Zoom2Tool();
+  ~Zoom2Tool();
+
+  Tool to_tool();
+private:
+  SharedPtr<Zoom2ToolImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/zoom2_tool.hxx
===================================================================
--- trunk/flexlay/lib/tools/zoom2_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/zoom2_tool.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,43 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#ifndef HEADER_ZOOM2_TOOL_HXX
-#define HEADER_ZOOM2_TOOL_HXX
-
-#include <ClanLib/Core/Math/rect.h>
-#include <ClanLib/Display/input_event.h>
-#include "tool.hxx"
-
-class Zoom2ToolImpl;
-
-/** */
-class Zoom2Tool
-{
-public:
-  Zoom2Tool();
-  ~Zoom2Tool();
-
-  Tool to_tool();
-private:
-  SharedPtr<Zoom2ToolImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/zoom_tool.cpp (from rev 712, trunk/flexlay/lib/tools/zoom_tool.cxx)
===================================================================
--- trunk/flexlay/lib/tools/zoom_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/zoom_tool.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,160 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#include <ClanLib/Display/keys.h>
+#include <ClanLib/Display/display.h>
+#include "editor_map_component.hpp"
+#include "tool_impl.hpp"
+#include "zoom_tool.hpp"
+
+class ZoomToolImpl : public ToolImpl
+{
+public:
+  enum { CREATE_ZOOM_RECT, NONE } state;
+
+  CL_Rectf zoom_rect;
+
+  void draw();
+  
+  void on_mouse_up  (const CL_InputEvent& event);
+  void on_mouse_down(const CL_InputEvent& event);
+  void on_mouse_move(const CL_InputEvent& event);
+};
+
+ZoomTool::ZoomTool()
+  : impl(new ZoomToolImpl())
+{
+  impl->state = ZoomToolImpl::NONE;
+}
+
+ZoomTool::~ZoomTool()
+{
+}
+
+void
+ZoomToolImpl::draw()
+{
+  switch (state)
+    {
+    case CREATE_ZOOM_RECT:
+      {
+        CL_Rectf tmp(zoom_rect);
+        tmp.normalize();
+        CL_Display::fill_rect(tmp, CL_Color(255, 255, 0, 50));
+        CL_Display::draw_rect(tmp, CL_Color(255, 255, 0, 200));
+      }
+    case NONE:
+      break;
+    }
+}
+
+void
+ZoomToolImpl::on_mouse_up  (const CL_InputEvent& event)
+{
+  EditorMapComponent* parent = EditorMapComponent::current();
+
+  if (event.id != CL_MOUSE_RIGHT)
+    {
+      switch (state)
+        {
+        case CREATE_ZOOM_RECT:
+          {
+            state = NONE;
+            parent->release_mouse();
+
+            CL_Pointf pos = parent->screen2world(event.mouse_pos);
+            zoom_rect.right  = pos.x;
+            zoom_rect.bottom = pos.y;
+            zoom_rect.normalize();
+            if (zoom_rect.get_width() > 10 && zoom_rect.get_height() > 10)
+              {
+                parent->zoom_to(zoom_rect);
+              }
+          }
+        }
+    }
+}
+
+void
+ZoomToolImpl::on_mouse_down(const CL_InputEvent& event)
+{
+  EditorMapComponent* parent = EditorMapComponent::current();
+
+  switch(event.id)
+    {
+    case CL_MOUSE_RIGHT:
+      switch (state)
+        {
+        case NONE:
+          parent->zoom_out(event.mouse_pos);
+          parent->zoom_out(event.mouse_pos);
+          break;
+        default:
+          break;
+        }
+      break;
+
+    default:
+      switch (state)
+        {
+        case NONE:
+          {
+            state = CREATE_ZOOM_RECT;
+            parent->capture_mouse();
+
+            CL_Pointf pos = parent->screen2world(event.mouse_pos);
+            zoom_rect.left   = pos.x;
+            zoom_rect.top    = pos.y;
+            zoom_rect.right  = pos.x;
+            zoom_rect.bottom = pos.y;
+          }
+          break;
+        default:
+          break;
+        }
+      break;
+    }
+}
+
+void
+ZoomToolImpl::on_mouse_move(const CL_InputEvent& event)
+{
+  EditorMapComponent* parent = EditorMapComponent::current();
+
+  switch (state)
+    {
+    case CREATE_ZOOM_RECT:
+      {
+        CL_Pointf pos = parent->screen2world(event.mouse_pos);
+        zoom_rect.right  = pos.x;
+        zoom_rect.bottom = pos.y;  
+      }
+      break;
+    default:
+      break;
+    }
+}
+
+Tool
+ZoomTool::to_tool()
+{
+  return Tool(impl); 
+}  
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/zoom_tool.cxx
===================================================================
--- trunk/flexlay/lib/tools/zoom_tool.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/zoom_tool.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,160 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#include <ClanLib/Display/keys.h>
-#include <ClanLib/Display/display.h>
-#include "editor_map_component.hxx"
-#include "tool_impl.hxx"
-#include "zoom_tool.hxx"
-
-class ZoomToolImpl : public ToolImpl
-{
-public:
-  enum { CREATE_ZOOM_RECT, NONE } state;
-
-  CL_Rectf zoom_rect;
-
-  void draw();
-  
-  void on_mouse_up  (const CL_InputEvent& event);
-  void on_mouse_down(const CL_InputEvent& event);
-  void on_mouse_move(const CL_InputEvent& event);
-};
-
-ZoomTool::ZoomTool()
-  : impl(new ZoomToolImpl())
-{
-  impl->state = ZoomToolImpl::NONE;
-}
-
-ZoomTool::~ZoomTool()
-{
-}
-
-void
-ZoomToolImpl::draw()
-{
-  switch (state)
-    {
-    case CREATE_ZOOM_RECT:
-      {
-        CL_Rectf tmp(zoom_rect);
-        tmp.normalize();
-        CL_Display::fill_rect(tmp, CL_Color(255, 255, 0, 50));
-        CL_Display::draw_rect(tmp, CL_Color(255, 255, 0, 200));
-      }
-    case NONE:
-      break;
-    }
-}
-
-void
-ZoomToolImpl::on_mouse_up  (const CL_InputEvent& event)
-{
-  EditorMapComponent* parent = EditorMapComponent::current();
-
-  if (event.id != CL_MOUSE_RIGHT)
-    {
-      switch (state)
-        {
-        case CREATE_ZOOM_RECT:
-          {
-            state = NONE;
-            parent->release_mouse();
-
-            CL_Pointf pos = parent->screen2world(event.mouse_pos);
-            zoom_rect.right  = pos.x;
-            zoom_rect.bottom = pos.y;
-            zoom_rect.normalize();
-            if (zoom_rect.get_width() > 10 && zoom_rect.get_height() > 10)
-              {
-                parent->zoom_to(zoom_rect);
-              }
-          }
-        }
-    }
-}
-
-void
-ZoomToolImpl::on_mouse_down(const CL_InputEvent& event)
-{
-  EditorMapComponent* parent = EditorMapComponent::current();
-
-  switch(event.id)
-    {
-    case CL_MOUSE_RIGHT:
-      switch (state)
-        {
-        case NONE:
-          parent->zoom_out(event.mouse_pos);
-          parent->zoom_out(event.mouse_pos);
-          break;
-        default:
-          break;
-        }
-      break;
-
-    default:
-      switch (state)
-        {
-        case NONE:
-          {
-            state = CREATE_ZOOM_RECT;
-            parent->capture_mouse();
-
-            CL_Pointf pos = parent->screen2world(event.mouse_pos);
-            zoom_rect.left   = pos.x;
-            zoom_rect.top    = pos.y;
-            zoom_rect.right  = pos.x;
-            zoom_rect.bottom = pos.y;
-          }
-          break;
-        default:
-          break;
-        }
-      break;
-    }
-}
-
-void
-ZoomToolImpl::on_mouse_move(const CL_InputEvent& event)
-{
-  EditorMapComponent* parent = EditorMapComponent::current();
-
-  switch (state)
-    {
-    case CREATE_ZOOM_RECT:
-      {
-        CL_Pointf pos = parent->screen2world(event.mouse_pos);
-        zoom_rect.right  = pos.x;
-        zoom_rect.bottom = pos.y;  
-      }
-      break;
-    default:
-      break;
-    }
-}
-
-Tool
-ZoomTool::to_tool()
-{
-  return Tool(impl); 
-}  
-
-/* EOF */

Copied: trunk/flexlay/lib/tools/zoom_tool.hpp (from rev 712, trunk/flexlay/lib/tools/zoom_tool.hxx)
===================================================================
--- trunk/flexlay/lib/tools/zoom_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/zoom_tool.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,43 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU General Public License
+//  as published by the Free Software Foundation; either version 2
+//  of the License, or (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+#ifndef HEADER_ZOOM_TOOL_HXX
+#define HEADER_ZOOM_TOOL_HXX
+
+#include <ClanLib/Core/Math/rect.h>
+#include <ClanLib/Display/input_event.h>
+#include "tool.hpp"
+
+class ZoomToolImpl;
+
+/** */
+class ZoomTool
+{
+public:
+  ZoomTool();
+  ~ZoomTool();
+
+  Tool to_tool();
+private:
+  SharedPtr<ZoomToolImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/tools/zoom_tool.hxx
===================================================================
--- trunk/flexlay/lib/tools/zoom_tool.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/tools/zoom_tool.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,43 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-// 
-//  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-#ifndef HEADER_ZOOM_TOOL_HXX
-#define HEADER_ZOOM_TOOL_HXX
-
-#include <ClanLib/Core/Math/rect.h>
-#include <ClanLib/Display/input_event.h>
-#include "tool.hxx"
-
-class ZoomToolImpl;
-
-/** */
-class ZoomTool
-{
-public:
-  ZoomTool();
-  ~ZoomTool();
-
-  Tool to_tool();
-private:
-  SharedPtr<ZoomToolImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/viewport.cpp (from rev 712, trunk/flexlay/lib/viewport.cxx)
===================================================================
--- trunk/flexlay/lib/viewport.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/viewport.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,49 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "graphic_context_state.hpp"
+#include "viewport.hpp"
+
+class ViewportImpl
+{
+public:
+  CL_Component* child;
+  GraphicContextState gc_state;
+};
+
+Viewport::Viewport(CL_Component* child, const CL_Rect& rect, CL_Component* parent)
+  : CL_Component(rect, parent),
+    impl(new ViewportImpl())
+{
+  impl->child = child;
+  impl->gc_state.set_size(rect.get_width(), rect.get_height());
+}
+
+void
+Viewport::set_pos(const CL_Pointf& pos)
+{
+  impl->gc_state.set_pos(pos);
+}
+
+CL_Pointf
+Viewport::get_pos() const
+{
+  return impl->gc_state.get_pos();
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/viewport.cxx
===================================================================
--- trunk/flexlay/lib/viewport.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/viewport.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,49 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "graphic_context_state.hxx"
-#include "viewport.hxx"
-
-class ViewportImpl
-{
-public:
-  CL_Component* child;
-  GraphicContextState gc_state;
-};
-
-Viewport::Viewport(CL_Component* child, const CL_Rect& rect, CL_Component* parent)
-  : CL_Component(rect, parent),
-    impl(new ViewportImpl())
-{
-  impl->child = child;
-  impl->gc_state.set_size(rect.get_width(), rect.get_height());
-}
-
-void
-Viewport::set_pos(const CL_Pointf& pos)
-{
-  impl->gc_state.set_pos(pos);
-}
-
-CL_Pointf
-Viewport::get_pos() const
-{
-  return impl->gc_state.get_pos();
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/viewport.hpp (from rev 712, trunk/flexlay/lib/viewport.hxx)
===================================================================
--- trunk/flexlay/lib/viewport.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/viewport.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,44 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_VIEWPORT_HXX
+#define HEADER_VIEWPORT_HXX
+
+#include <ClanLib/GUI/component.h>
+#include <ClanLib/Core/Math/rect.h>
+#include "shared_ptr.hpp"
+
+class ViewportImpl;
+
+/** */
+class Viewport : public CL_Component
+{
+protected:
+  virtual ~Viewport() {}
+public:
+  Viewport(CL_Component* child, const CL_Rect& rect, CL_Component* parent);
+  
+  void set_pos(const CL_Pointf& pos);
+  CL_Pointf get_pos() const;
+private:
+  SharedPtr<ViewportImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/viewport.hxx
===================================================================
--- trunk/flexlay/lib/viewport.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/viewport.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,44 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_VIEWPORT_HXX
-#define HEADER_VIEWPORT_HXX
-
-#include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/Math/rect.h>
-#include "shared_ptr.hxx"
-
-class ViewportImpl;
-
-/** */
-class Viewport : public CL_Component
-{
-protected:
-  virtual ~Viewport() {}
-public:
-  Viewport(CL_Component* child, const CL_Rect& rect, CL_Component* parent);
-  
-  void set_pos(const CL_Pointf& pos);
-  CL_Pointf get_pos() const;
-private:
-  SharedPtr<ViewportImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/window.cpp (from rev 712, trunk/flexlay/lib/window.cxx)
===================================================================
--- trunk/flexlay/lib/window.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/window.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,176 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include <ClanLib/Core/core_iostream.h>
+#include <ClanLib/Display/display.h>
+#include <ClanLib/Display/keys.h>
+#include <ClanLib/Display/sprite_description.h>
+#include <ClanLib/Display/Providers/provider_factory.h>
+#include <ClanLib/GUI/gui_manager.h>
+#include "box.hpp"
+#include "fonts.hpp"
+#include "icon.hpp"
+#include "helper.hpp"
+#include "titlebar.hpp"
+#include "window.hpp"
+
+class WindowImpl
+{
+public:
+  CL_Component* client_area;
+  CL_Component* parent;
+
+  CL_Rect old_position;
+  bool is_maximized;
+
+  Titlebar* titlebar;
+  Icon* close;
+  Icon* minimize;
+  Icon* maximize;
+
+  std::vector<CL_Slot> slots;
+
+  void draw();
+  void do_maximize();
+  void do_close();
+  void on_resize(int, int);
+};
+
+Window::Window(const CL_Rect& rect, const std::string& title, CL_Component* parent)
+  : CL_Component(rect, parent), impl(new WindowImpl())
+{
+  impl->titlebar = new Titlebar(CL_Rect(CL_Point(3+16,3), 
+                                        CL_Size(get_width()-6-18-18-18, 12+3)), title,
+                                this);
+  //Fonts::verdana11.draw(8+15, 3, title);
+
+  impl->close = new Icon(CL_Rect(CL_Point(3, 3), CL_Size(18,18)), 
+                        make_sprite("../data/images/window/close.png"),
+                        "", this);
+  impl->minimize = new Icon(CL_Rect(CL_Point(get_width()-3-18-18, 3), CL_Size(18,18)), 
+                            make_sprite("../data/images/window/minimize.png"),
+                            "", this);
+  impl->maximize = new Icon(CL_Rect(CL_Point(get_width()-3-18, 3), CL_Size(18,18)), 
+                            make_sprite("../data/images/window/maximize.png"),
+                            "", this);
+
+  impl->client_area = new CL_Component(CL_Rect(CL_Point(4, 3+12+7), 
+                                               CL_Size(rect.get_width()-10,
+                                                       rect.get_height()-28)), this);
+  impl->parent  = this;
+  impl->is_maximized = false;
+
+  impl->slots.push_back(sig_resize().connect(impl.get(),      &WindowImpl::on_resize));
+
+  impl->slots.push_back(sig_paint().connect(impl.get(),      &WindowImpl::draw));
+  impl->slots.push_back(impl->maximize->sig_clicked().connect(impl.get(), &WindowImpl::do_maximize));
+  impl->slots.push_back(impl->close->sig_clicked().connect(impl.get(), &WindowImpl::do_close));
+}
+
+Window::~Window()
+{
+  std::cout << "deleting: Window" << std::endl;
+}
+
+void
+WindowImpl::on_resize(int, int)
+{
+  titlebar->set_position(CL_Rect(CL_Point(3+16,3), CL_Size(parent->get_width()-6-18-18-18, 12+3)));
+  close->set_position(3, 3);
+  minimize->set_position(parent->get_width()-3-18-18, 3);
+  maximize->set_position(parent->get_width()-3-18, 3);
+  CL_Rect rect = parent->get_position();
+  client_area->set_position(CL_Rect(CL_Point(4, 3+12+7), 
+                                   CL_Size(rect.get_width()-10,
+                                           rect.get_height()-28)));
+}
+
+void
+WindowImpl::draw()
+{
+  CL_Display::push_translate (parent->get_screen_x(), parent->get_screen_y());
+
+  CL_Color highlight(255, 255, 255);
+  CL_Color midtone(150, 150, 150);
+
+  CL_Rect rect = parent->get_position() ;
+
+  Box::draw_window(CL_Rect(CL_Point(0, 0), CL_Size(rect.get_width()-1, rect.get_height()-1)));
+  Box::draw_panel_down(client_area->get_position());
+
+  /*
+    CL_Display::fill_rect(CL_Rect(CL_Point(0, 0), rect.get_size()), CL_Color(220, 220, 220));
+    CL_Display::draw_rect(CL_Rect(CL_Point(0, 0), rect.get_size()), CL_Color(0, 0, 0));
+ 
+    CL_Display::draw_line(1, rect.get_height()-2,
+    rect.get_width()-2, rect.get_height()-2, midtone);
+    CL_Display::draw_line(rect.get_width()-2, 1,
+    rect.get_width()-2, rect.get_height()-2, midtone);
+
+    CL_Display::draw_line(1, 1,
+    rect.get_width()-2, 1, highlight);
+    CL_Display::draw_line(1, 1,
+    1, rect.get_height()-2, highlight);
+  */
+
+  CL_Display::pop_modelview();
+}
+
+void
+WindowImpl::do_close()
+{
+  parent->show(false);
+}
+
+void
+WindowImpl::do_maximize()
+{
+  // FIXME: Move this to scripting language
+  if (!is_maximized)
+    {
+      is_maximized = true;
+      old_position = parent->get_position();
+      parent->set_position(parent->get_parent()->get_position());
+    }
+  else
+    {
+      is_maximized = false;
+      parent->set_position(old_position);
+    }
+}
+
+CL_Component*
+Window::get_client_area()
+{
+  return impl->client_area;
+}
+
+void
+Window::hide()
+{
+  CL_Component::show(false);
+}
+
+void
+Window::show()
+{
+  CL_Component::show(true);
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/window.cxx
===================================================================
--- trunk/flexlay/lib/window.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/window.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,176 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <ClanLib/Core/core_iostream.h>
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/keys.h>
-#include <ClanLib/Display/sprite_description.h>
-#include <ClanLib/Display/Providers/provider_factory.h>
-#include <ClanLib/GUI/gui_manager.h>
-#include "box.hxx"
-#include "fonts.hxx"
-#include "icon.hxx"
-#include "helper.hxx"
-#include "titlebar.hxx"
-#include "window.hxx"
-
-class WindowImpl
-{
-public:
-  CL_Component* client_area;
-  CL_Component* parent;
-
-  CL_Rect old_position;
-  bool is_maximized;
-
-  Titlebar* titlebar;
-  Icon* close;
-  Icon* minimize;
-  Icon* maximize;
-
-  std::vector<CL_Slot> slots;
-
-  void draw();
-  void do_maximize();
-  void do_close();
-  void on_resize(int, int);
-};
-
-Window::Window(const CL_Rect& rect, const std::string& title, CL_Component* parent)
-  : CL_Component(rect, parent), impl(new WindowImpl())
-{
-  impl->titlebar = new Titlebar(CL_Rect(CL_Point(3+16,3), 
-                                        CL_Size(get_width()-6-18-18-18, 12+3)), title,
-                                this);
-  //Fonts::verdana11.draw(8+15, 3, title);
-
-  impl->close = new Icon(CL_Rect(CL_Point(3, 3), CL_Size(18,18)), 
-                        make_sprite("../data/images/window/close.png"),
-                        "", this);
-  impl->minimize = new Icon(CL_Rect(CL_Point(get_width()-3-18-18, 3), CL_Size(18,18)), 
-                            make_sprite("../data/images/window/minimize.png"),
-                            "", this);
-  impl->maximize = new Icon(CL_Rect(CL_Point(get_width()-3-18, 3), CL_Size(18,18)), 
-                            make_sprite("../data/images/window/maximize.png"),
-                            "", this);
-
-  impl->client_area = new CL_Component(CL_Rect(CL_Point(4, 3+12+7), 
-                                               CL_Size(rect.get_width()-10,
-                                                       rect.get_height()-28)), this);
-  impl->parent  = this;
-  impl->is_maximized = false;
-
-  impl->slots.push_back(sig_resize().connect(impl.get(),      &WindowImpl::on_resize));
-
-  impl->slots.push_back(sig_paint().connect(impl.get(),      &WindowImpl::draw));
-  impl->slots.push_back(impl->maximize->sig_clicked().connect(impl.get(), &WindowImpl::do_maximize));
-  impl->slots.push_back(impl->close->sig_clicked().connect(impl.get(), &WindowImpl::do_close));
-}
-
-Window::~Window()
-{
-  std::cout << "deleting: Window" << std::endl;
-}
-
-void
-WindowImpl::on_resize(int, int)
-{
-  titlebar->set_position(CL_Rect(CL_Point(3+16,3), CL_Size(parent->get_width()-6-18-18-18, 12+3)));
-  close->set_position(3, 3);
-  minimize->set_position(parent->get_width()-3-18-18, 3);
-  maximize->set_position(parent->get_width()-3-18, 3);
-  CL_Rect rect = parent->get_position();
-  client_area->set_position(CL_Rect(CL_Point(4, 3+12+7), 
-                                   CL_Size(rect.get_width()-10,
-                                           rect.get_height()-28)));
-}
-
-void
-WindowImpl::draw()
-{
-  CL_Display::push_translate (parent->get_screen_x(), parent->get_screen_y());
-
-  CL_Color highlight(255, 255, 255);
-  CL_Color midtone(150, 150, 150);
-
-  CL_Rect rect = parent->get_position() ;
-
-  Box::draw_window(CL_Rect(CL_Point(0, 0), CL_Size(rect.get_width()-1, rect.get_height()-1)));
-  Box::draw_panel_down(client_area->get_position());
-
-  /*
-    CL_Display::fill_rect(CL_Rect(CL_Point(0, 0), rect.get_size()), CL_Color(220, 220, 220));
-    CL_Display::draw_rect(CL_Rect(CL_Point(0, 0), rect.get_size()), CL_Color(0, 0, 0));
- 
-    CL_Display::draw_line(1, rect.get_height()-2,
-    rect.get_width()-2, rect.get_height()-2, midtone);
-    CL_Display::draw_line(rect.get_width()-2, 1,
-    rect.get_width()-2, rect.get_height()-2, midtone);
-
-    CL_Display::draw_line(1, 1,
-    rect.get_width()-2, 1, highlight);
-    CL_Display::draw_line(1, 1,
-    1, rect.get_height()-2, highlight);
-  */
-
-  CL_Display::pop_modelview();
-}
-
-void
-WindowImpl::do_close()
-{
-  parent->show(false);
-}
-
-void
-WindowImpl::do_maximize()
-{
-  // FIXME: Move this to scripting language
-  if (!is_maximized)
-    {
-      is_maximized = true;
-      old_position = parent->get_position();
-      parent->set_position(parent->get_parent()->get_position());
-    }
-  else
-    {
-      is_maximized = false;
-      parent->set_position(old_position);
-    }
-}
-
-CL_Component*
-Window::get_client_area()
-{
-  return impl->client_area;
-}
-
-void
-Window::hide()
-{
-  CL_Component::show(false);
-}
-
-void
-Window::show()
-{
-  CL_Component::show(true);
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/window.hpp (from rev 712, trunk/flexlay/lib/window.hxx)
===================================================================
--- trunk/flexlay/lib/window.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/window.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,49 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_WINDOW_HXX
+#define HEADER_WINDOW_HXX
+
+#include <ClanLib/GUI/component.h>
+#include <ClanLib/Core/Math/rect.h>
+#include "shared_ptr.hpp"
+
+class WindowImpl;
+
+/** */
+class Window : public CL_Component
+{
+protected:
+  virtual ~Window();
+public:
+  Window(const CL_Rect& rect, const std::string& title, CL_Component* parent);
+  
+  void hide();
+  void show();
+
+  CL_Component* get_client_area();
+private:
+  Window (const Window&);
+  Window& operator= (const Window&);
+
+  SharedPtr<WindowImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/window.hxx
===================================================================
--- trunk/flexlay/lib/window.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/window.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,49 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_WINDOW_HXX
-#define HEADER_WINDOW_HXX
-
-#include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/Math/rect.h>
-#include "shared_ptr.hxx"
-
-class WindowImpl;
-
-/** */
-class Window : public CL_Component
-{
-protected:
-  virtual ~Window();
-public:
-  Window(const CL_Rect& rect, const std::string& title, CL_Component* parent);
-  
-  void hide();
-  void show();
-
-  CL_Component* get_client_area();
-private:
-  Window (const Window&);
-  Window& operator= (const Window&);
-
-  SharedPtr<WindowImpl> impl;
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/lib/workspace.cpp (from rev 712, trunk/flexlay/lib/workspace.cxx)
===================================================================
--- trunk/flexlay/lib/workspace.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/workspace.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,161 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include <map>
+#include <ClanLib/Display/display.h>
+#include <ClanLib/Display/display_window.h>
+#include <ClanLib/Display/keys.h>
+#include "editor_map.hpp"
+#include "editor_map_component.hpp"
+#include "editor_names.hpp"
+#include "tools/tool.hpp"
+#include "tileset.hpp"
+#include "workspace.hpp"
+
+Workspace Workspace::current_(false);
+
+class WorkspaceImpl
+{
+public:
+  EditorMap editor_map;
+
+  typedef std::map<int, Tool> Tools;
+  Tools tools;
+};
+
+Workspace::Workspace(bool create)
+  : impl(0)
+{
+  if (create)
+    {
+      impl = new WorkspaceImpl();
+      current_ = *this;
+      std::cout << "Workspace()" << std::endl;
+    }
+}
+
+void
+Workspace::draw()
+{
+  assert(impl.get());
+
+  CL_Display::clear(CL_Color(100, 0, 100));
+
+  impl->editor_map.draw_gui(CL_Display::get_current_window()->get_gc());
+  impl->editor_map.draw(EditorMapComponent::current(), CL_Display::get_current_window()->get_gc());
+  
+  // FIXME: Only draw active tool?!
+  for(WorkspaceImpl::Tools::iterator it = impl->tools.begin();
+      it != impl->tools.end(); ++it)
+    it->second.draw();
+    
+  CL_Display::flush();
+}
+
+void
+Workspace::mouse_up(const CL_InputEvent& event)
+{
+  assert(impl.get());
+
+  WorkspaceImpl::Tools::iterator it = impl->tools.find(event.id);
+  if (it != impl->tools.end())
+    it->second.on_mouse_up(event);
+}
+
+void
+Workspace::mouse_move(const CL_InputEvent& event)
+{
+  assert(impl.get());
+
+  for(WorkspaceImpl::Tools::iterator it = impl->tools.begin();
+      it != impl->tools.end(); ++it)
+    {
+      it->second.on_mouse_move(event);
+    }
+}
+
+void
+Workspace::mouse_down(const CL_InputEvent& event)
+{
+  assert(impl.get());
+
+  WorkspaceImpl::Tools::iterator it = impl->tools.find(event.id);
+  if (it != impl->tools.end())
+    it->second.on_mouse_down(event);
+
+  switch (event.id)
+    {
+    case CL_MOUSE_WHEEL_UP:
+      EditorMapComponent::current()->zoom_in(event.mouse_pos);
+      break;
+      
+    case CL_MOUSE_WHEEL_DOWN:
+      EditorMapComponent::current()->zoom_out(event.mouse_pos);
+      break;
+    }
+}
+
+void
+Workspace::key_up(const CL_InputEvent& event)
+{
+  assert(impl.get());
+
+  WorkspaceImpl::Tools::iterator it = impl->tools.find(event.id);
+  if (it != impl->tools.end())
+    it->second.on_mouse_up(event);
+}
+
+void
+Workspace::key_down(const CL_InputEvent& event)
+{
+  assert(impl.get());
+
+  WorkspaceImpl::Tools::iterator it = impl->tools.find(event.id);
+  if (it != impl->tools.end())
+    it->second.on_mouse_down(event);
+  else
+    std::cout << "Workspace: " << event.id << std::endl;
+}
+
+EditorMap
+Workspace::get_map()
+{
+  assert(impl.get());
+
+  return impl->editor_map;
+}
+
+void
+Workspace::set_map(const EditorMap& m)
+{
+  assert(impl.get());
+
+  impl->editor_map = m;
+  std::cout << "Workspace:set_map" << std::endl;
+}
+
+void
+Workspace::set_tool(int button, const Tool& tool)
+{
+  assert(impl.get());
+
+  impl->tools[button] = tool;
+}
+
+/* EOF */

Deleted: trunk/flexlay/lib/workspace.cxx
===================================================================
--- trunk/flexlay/lib/workspace.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/workspace.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,161 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <map>
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/display_window.h>
-#include <ClanLib/Display/keys.h>
-#include "editor_map.hxx"
-#include "editor_map_component.hxx"
-#include "editor_names.hxx"
-#include "tools/tool.hxx"
-#include "tileset.hxx"
-#include "workspace.hxx"
-
-Workspace Workspace::current_(false);
-
-class WorkspaceImpl
-{
-public:
-  EditorMap editor_map;
-
-  typedef std::map<int, Tool> Tools;
-  Tools tools;
-};
-
-Workspace::Workspace(bool create)
-  : impl(0)
-{
-  if (create)
-    {
-      impl = new WorkspaceImpl();
-      current_ = *this;
-      std::cout << "Workspace()" << std::endl;
-    }
-}
-
-void
-Workspace::draw()
-{
-  assert(impl.get());
-
-  CL_Display::clear(CL_Color(100, 0, 100));
-
-  impl->editor_map.draw_gui(CL_Display::get_current_window()->get_gc());
-  impl->editor_map.draw(EditorMapComponent::current(), CL_Display::get_current_window()->get_gc());
-  
-  // FIXME: Only draw active tool?!
-  for(WorkspaceImpl::Tools::iterator it = impl->tools.begin();
-      it != impl->tools.end(); ++it)
-    it->second.draw();
-    
-  CL_Display::flush();
-}
-
-void
-Workspace::mouse_up(const CL_InputEvent& event)
-{
-  assert(impl.get());
-
-  WorkspaceImpl::Tools::iterator it = impl->tools.find(event.id);
-  if (it != impl->tools.end())
-    it->second.on_mouse_up(event);
-}
-
-void
-Workspace::mouse_move(const CL_InputEvent& event)
-{
-  assert(impl.get());
-
-  for(WorkspaceImpl::Tools::iterator it = impl->tools.begin();
-      it != impl->tools.end(); ++it)
-    {
-      it->second.on_mouse_move(event);
-    }
-}
-
-void
-Workspace::mouse_down(const CL_InputEvent& event)
-{
-  assert(impl.get());
-
-  WorkspaceImpl::Tools::iterator it = impl->tools.find(event.id);
-  if (it != impl->tools.end())
-    it->second.on_mouse_down(event);
-
-  switch (event.id)
-    {
-    case CL_MOUSE_WHEEL_UP:
-      EditorMapComponent::current()->zoom_in(event.mouse_pos);
-      break;
-      
-    case CL_MOUSE_WHEEL_DOWN:
-      EditorMapComponent::current()->zoom_out(event.mouse_pos);
-      break;
-    }
-}
-
-void
-Workspace::key_up(const CL_InputEvent& event)
-{
-  assert(impl.get());
-
-  WorkspaceImpl::Tools::iterator it = impl->tools.find(event.id);
-  if (it != impl->tools.end())
-    it->second.on_mouse_up(event);
-}
-
-void
-Workspace::key_down(const CL_InputEvent& event)
-{
-  assert(impl.get());
-
-  WorkspaceImpl::Tools::iterator it = impl->tools.find(event.id);
-  if (it != impl->tools.end())
-    it->second.on_mouse_down(event);
-  else
-    std::cout << "Workspace: " << event.id << std::endl;
-}
-
-EditorMap
-Workspace::get_map()
-{
-  assert(impl.get());
-
-  return impl->editor_map;
-}
-
-void
-Workspace::set_map(const EditorMap& m)
-{
-  assert(impl.get());
-
-  impl->editor_map = m;
-  std::cout << "Workspace:set_map" << std::endl;
-}
-
-void
-Workspace::set_tool(int button, const Tool& tool)
-{
-  assert(impl.get());
-
-  impl->tools[button] = tool;
-}
-
-/* EOF */

Copied: trunk/flexlay/lib/workspace.hpp (from rev 712, trunk/flexlay/lib/workspace.hxx)
===================================================================
--- trunk/flexlay/lib/workspace.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/workspace.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,63 @@
+//  $Id$
+// 
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_WORKSPACE_HXX
+#define HEADER_WORKSPACE_HXX
+
+#include <ClanLib/Core/System/sharedptr.h>
+#include <ClanLib/Display/input_event.h>
+#include "graphic_context_state.hpp"
+
+class WorkspaceImpl;
+class EditorMap;
+class Tool;
+
+/** */
+class Workspace
+{
+private:
+  static Workspace current_;
+
+public:
+  static void set_current(Workspace w) { current_ = w; }
+  static Workspace current() { return current_; }
+
+  Workspace(bool create = false);
+
+  void draw();
+
+  void mouse_up  (const CL_InputEvent& event);
+  void mouse_down(const CL_InputEvent& event);
+  void mouse_move(const CL_InputEvent& event);
+
+  void key_up(const CL_InputEvent& event);
+  void key_down(const CL_InputEvent& event);
+
+  EditorMap get_map();
+  void set_map(const EditorMap& m);
+
+  void set_tool(int button, const Tool& tool);
+
+  bool is_null() const { return !impl.get(); }
+private:
+  CL_SharedPtr<WorkspaceImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/lib/workspace.hxx
===================================================================
--- trunk/flexlay/lib/workspace.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/lib/workspace.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,63 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_WORKSPACE_HXX
-#define HEADER_WORKSPACE_HXX
-
-#include <ClanLib/Core/System/sharedptr.h>
-#include <ClanLib/Display/input_event.h>
-#include "graphic_context_state.hxx"
-
-class WorkspaceImpl;
-class EditorMap;
-class Tool;
-
-/** */
-class Workspace
-{
-private:
-  static Workspace current_;
-
-public:
-  static void set_current(Workspace w) { current_ = w; }
-  static Workspace current() { return current_; }
-
-  Workspace(bool create = false);
-
-  void draw();
-
-  void mouse_up  (const CL_InputEvent& event);
-  void mouse_down(const CL_InputEvent& event);
-  void mouse_move(const CL_InputEvent& event);
-
-  void key_up(const CL_InputEvent& event);
-  void key_down(const CL_InputEvent& event);
-
-  EditorMap get_map();
-  void set_map(const EditorMap& m);
-
-  void set_tool(int button, const Tool& tool);
-
-  bool is_null() const { return !impl.get(); }
-private:
-  CL_SharedPtr<WorkspaceImpl> impl;
-};
-
-#endif
-
-/* EOF */

Modified: trunk/flexlay/netpanzer/SConscript
===================================================================
--- trunk/flexlay/netpanzer/SConscript	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/netpanzer/SConscript	2009-11-22 03:02:03 UTC (rev 713)
@@ -23,7 +23,7 @@
 
 Import('clanLib_env')
 
-opts = Options('custom.py')
+opts = Variables('custom.py')
 opts.Add('CXX', 'The C++ compiler.', 'g++')
 opts.Add('CXXFLAGS', 'The C++ compiler flags.', '-g -O2 -Wall -fPIC')
 opts.Add('CPPPATH', 'additional header path', '')
@@ -38,16 +38,16 @@
                   options=opts)
 Help(opts.GenerateHelpText(env))
 
-Depends('netpanzer.i', ['netpanzer.hxx'])
-env.Command('netpanzer_wrap.cxx', 'netpanzer.i',
+Depends('netpanzer.i', ['netpanzer.hpp'])
+env.Command('netpanzer_wrap.cpp', 'netpanzer.i',
             "swig -c++ -ruby -o $TARGET $SOURCE")
 
 libflexlay_ruby_env = env.Clone()
 flexlay_ruby_lib = libflexlay_ruby_env.SharedLibrary(
     target = 'netpanzer_wrap.so',
     source = [
-    'netpanzer_wrap.cxx',
-    'netpanzer.cxx'
+    'netpanzer_wrap.cpp',
+    'netpanzer.cpp'
     ],
     CPPPATH=['$USER_CPPPATH','$RUBYDIR','../lib/'] + clanLib_env['CPPPATH'],
     LINKFLAGS = clanLib_env['LINKFLAGS'],

Copied: trunk/flexlay/netpanzer/averagecolor.cpp (from rev 712, trunk/flexlay/netpanzer/averagecolor.cxx)

Deleted: trunk/flexlay/netpanzer/averagecolor.cxx
===================================================================
--- trunk/flexlay/netpanzer/averagecolor.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/netpanzer/averagecolor.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,47 +0,0 @@
-#include <ClanLib/display.h>
-#include <ClanLib/core.h>
-
-CL_Color
-calc_average_color(const char* filename)
-{
-  // FIXME: Works only from indexed images
-  CL_PNGProvider buffer(filename);
-  int len = buffer.get_pitch() * buffer.get_height();
-  unsigned char* buf = static_cast<unsigned char*>(buffer.get_data());
-  CL_Palette palette = buffer.get_palette();
-  float red   = 0;
-  float green = 0;
-  float blue  = 0;
-
-  for(int i = 0; i < len; ++i)
-    {
-      red   += palette.colors[buf[i]].get_red();
-      green += palette.colors[buf[i]].get_green();
-      blue  += palette.colors[buf[i]].get_blue();
-    }
-
-  return CL_Color(int(red/len),
-                  int(green/len),
-                  int(blue/len));
-}
-
-int main(int argc, char** argv)
-{
-  CL_SetupCore::init();
-  CL_SetupDisplay::init(true);
-
-  for(int i = 1; i < argc; ++i)
-    {
-      CL_Color color = calc_average_color(argv[i]);
-      std::cout << argv[i] 
-                << " " << color.get_red()
-                << " " << color.get_green()
-                << " " << color.get_blue()
-                << std::endl;
-    }
-
-  CL_SetupDisplay::deinit();
-  CL_SetupCore::deinit();
-}
-
-/* EOF */

Copied: trunk/flexlay/netpanzer/netpanzer.cpp (from rev 712, trunk/flexlay/netpanzer/netpanzer.cxx)
===================================================================
--- trunk/flexlay/netpanzer/netpanzer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/netpanzer/netpanzer.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,553 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include <sstream>
+#include <fstream>
+#include <ClanLib/core.h>
+#include <ClanLib/Display/palette.h>
+#include <ClanLib/Display/sprite.h>
+#include <ClanLib/Display/pixel_format.h>
+#include <ClanLib/Display/pixel_format_type.h>
+#include <ClanLib/Display/sprite_description.h>
+#include <ClanLib/Display/Providers/provider_factory.h>
+#include "globals.hpp"
+#include "tile_provider.hpp"
+#include "tile_provider_impl.hpp"
+#include "tile.hpp"
+#include "tileset.hpp"
+#include "blitter.hpp"
+#include "tilemap_layer.hpp"
+#include "editor_map.hpp"
+#include "netpanzer.hpp"
+
+NetPanzerData* NetPanzerData::instance_ = 0;
+
+class NetPanzerTileProviderImpl : public TileProviderImpl
+{
+private:
+  int id;
+  mutable CL_Sprite sprite;
+  mutable CL_PixelBuffer buffer;
+
+public:
+  NetPanzerTileProviderImpl(int id_)
+    : id(id_)
+  {    
+  }
+
+  virtual ~NetPanzerTileProviderImpl()
+  {
+  }
+
+  CL_Sprite get_sprite() const
+  {
+    if (sprite)
+      {
+        return sprite;
+      }
+    else
+      {
+        NetPanzerTileGroup& tilegroup = NetPanzerData::instance()->find_tilegroup(id);
+        int dist = id - tilegroup.start;
+
+        CL_Rect rect(CL_Point((dist % tilegroup.width) * 32,
+                              (dist / tilegroup.width) * 32),
+                     CL_Size(32, 32));
+        sprite.add_frame(tilegroup.get_surface(), rect);
+        return sprite;
+      }
+  }
+
+  CL_PixelBuffer get_pixelbuffer() const
+  {
+    if (buffer)
+      {
+        return buffer;
+      }
+    else
+      {
+        // FIXME: ClanLibs indexed handling seems broken, so we do
+        // the conversion ourself
+        const CL_Palette& palette = NetPanzerData::instance()->get_palette();
+        unsigned char* data = NetPanzerData::instance()->get_tiledata() + (32*32) * id;
+        buffer = CL_PixelBuffer(32, 32, 32*3, CL_PixelFormat::rgb888);
+
+        buffer.lock();
+        unsigned char* target = static_cast<unsigned char*>(buffer.get_data());
+
+        for(int i = 0; i < 32*32; ++i)
+          {
+            target[3*i+0] = palette[data[i]].get_blue();
+            target[3*i+1] = palette[data[i]].get_green();
+            target[3*i+2] = palette[data[i]].get_red();
+          }
+        buffer.unlock();
+                
+        return buffer;
+      }
+  }
+};
+
+NetPanzerData::NetPanzerData() 
+{
+}
+
+void
+NetPanzerData::register_tilegroup(int start, int width, int height)
+{
+  NetPanzerTileGroup group;
+
+  group.start  = start;
+  group.width  = width;
+  group.height = height;
+
+  tilegroups.push_back(group);
+}
+
+void
+NetPanzerData::load_data(const std::string& datadir_)
+{
+  datadir = datadir_;
+  std::cout << "NetPanzerData: Loading data from '" << datadir << "'" << std::endl;
+  palette = load_palette(datadir + "/" + "wads/netp.act");
+  load_tileset(datadir + "/" + "wads/summer12mb.tls");
+}
+
+CL_Surface
+NetPanzerTileGroup::get_surface()
+{
+  if (!surface)
+    {
+      CL_PixelBuffer buffer(width*32, height*32, width*32*4, CL_PixelFormat::rgba8888);
+
+      for(int y = 0; y < height; ++y)
+        for(int x = 0; x < width; ++x)
+          {
+            const CL_Palette& palette = NetPanzerData::instance()->get_palette();
+            unsigned char* data = NetPanzerData::instance()->get_tiledata() + (32*32) * (start + width*y + x);
+
+            NetPanzerTileHeader header = NetPanzerData::instance()->get_tile_headers()[start + width*y + x]; 
+           
+            CL_PixelBuffer tile(32, 32, 32*3, CL_PixelFormat::rgb888);
+
+            tile.lock();
+            unsigned char* target = static_cast<unsigned char*>(tile.get_data());
+
+            float r = 1.0f;
+            float g = 1.0f;
+            float b = 1.0f;
+
+            switch (header.move_value)
+              {
+              case 0: // streets, allowing faster movement
+                r = 1.0f;
+                g = 1.0f;
+                b = 0.0f;
+                break;
+
+              case 1: // normal ground which allows to move
+                r = 1.0f;
+                g = 1.0f;
+                b = 1.0f;
+                break;
+
+              case 4: // unpassable terrain
+                r = 0.0f;
+                g = 1.0;
+                b = 0.0f;
+                break;
+
+              case 5: // water
+                r = 0.0f;
+                g = 0.0f;
+                b = 1.0f;
+                break;
+
+              default:
+                std::cout << "Unknown header value: " << int(header.move_value) << std::endl;
+                break;
+              }
+
+            for(int i = 0; i < 32*32; ++i)
+              {
+                target[3*i+0] = int(palette[data[i]].get_blue()  * b);
+                target[3*i+1] = int(palette[data[i]].get_green() * g);
+                target[3*i+2] = int(palette[data[i]].get_red()   * r);
+              }
+            tile.unlock();
+                
+            blit(buffer, tile, x * 32, y * 32);
+          }
+      
+      surface = CL_Surface(buffer);
+    }
+
+  return surface;
+}
+
+CL_Sprite
+NetPanzerData::get_tilegroup_sprite(int index)
+{
+  for(TileGroups::iterator i = tilegroups.begin(); i != tilegroups.end(); ++i)
+    {
+      if (index == i->start)
+        {
+          CL_Sprite sprite;
+          sprite.add_frame(i->get_surface(), CL_Rect(CL_Point(0, 0),
+                                                     CL_Size(i->get_surface().get_width(),
+                                                             i->get_surface().get_height())));
+          return sprite;
+        }
+    }
+
+  std::cout << "NetPanzerData: Couldn't get tilegroup_sprite for '" << index << "'" << std::endl;
+  return CL_Sprite();
+}
+
+NetPanzerTileGroup&
+NetPanzerData::find_tilegroup(int index)
+{
+  for(TileGroups::iterator i = tilegroups.begin(); i != tilegroups.end(); ++i)
+    {
+      if (i->start <= index && index < i->start + (i->width*i->height))
+        {
+          return *i;
+        }
+    }
+
+  std::cout << "NetPanzerData: Couldn't find tilegroup for '" << index << "'" << std::endl;
+  // return some junk just to keep it running
+  return tilegroups.front();
+}
+
+const Tileset&
+NetPanzerData::get_tileset() const
+{
+  return tileset;
+}
+
+const CL_Palette&
+NetPanzerData::get_palette() const
+{
+  return palette;
+}
+
+const std::vector<NetPanzerTileHeader>&
+NetPanzerData::get_tile_headers() const
+{
+  return tile_headers;
+}
+
+unsigned char*
+NetPanzerData::get_tiledata() const
+{
+  return tiledata;
+}
+
+CL_Palette
+NetPanzerData::load_palette(const std::string& filename)
+{
+  CL_Palette palette;
+  unsigned char color_array[256 * 3];
+  
+  std::ifstream in(filename.c_str());
+  
+  if (!in)
+    {
+      std::cout << "Couldn't load palette" << std::endl;
+      return palette;
+    }
+
+  in.read(reinterpret_cast<char*>(color_array), sizeof(color_array));
+
+  for(int i = 0; i < 256; ++i)
+    {
+      palette.colors[i].set_red  (color_array[3*i + 0]);
+      palette.colors[i].set_green(color_array[3*i + 1]);
+      palette.colors[i].set_blue (color_array[3*i + 2]);
+    }
+
+  return palette;
+}
+
+void
+NetPanzerData::load_tileset(const std::string& filename)
+{
+  unsigned char	netp_id_header[64];
+  unsigned short	version;
+  unsigned short	width;
+  unsigned short	height;
+  unsigned short	tile_count;
+  unsigned char	raw_palette[768];
+
+  std::ifstream file(filename.c_str());  
+
+  if (!file)
+    {
+      std::cout << "Couldn't load " << filename << std::endl;
+    }
+  else
+    {
+      file.read(reinterpret_cast<char*>(netp_id_header), sizeof(netp_id_header));
+      file.read(reinterpret_cast<char*>(&version), sizeof(version));
+      file.read(reinterpret_cast<char*>(&width), sizeof(width));
+      file.read(reinterpret_cast<char*>(&height), sizeof(height));
+      file.read(reinterpret_cast<char*>(&tile_count), sizeof(tile_count));
+      file.read(reinterpret_cast<char*>(raw_palette), sizeof(raw_palette));
+
+      tile_headers.resize(tile_count);
+
+      file.read(reinterpret_cast<char*>(&*tile_headers.begin()), 
+                sizeof(NetPanzerTileHeader)*tile_count);
+
+      cl_uint32 tilesize = width * height;
+      // FIXME: Delete this somewhere!
+      unsigned char* tiledata = new unsigned char[tilesize*tile_count];
+      file.read(reinterpret_cast<char*>(tiledata), tilesize*tile_count);
+      file.close();
+
+      // FIXME: The palette in the netpanzer 'summer12mb.tls' file
+      // is either broken or otherwise corrupt, so we ignore it
+      // and use the seperate palette file 'netp.act' which works
+      // fine.
+      
+      NetPanzerData::instance()->tiledata = tiledata;
+      
+      tileset = Tileset(width);
+
+      for(int i = 0; i < tile_count; ++i)
+        {
+          Tile tile(TileProvider(new NetPanzerTileProviderImpl(i)));
+          tileset.add_tile(i, &tile);
+        }
+    }
+}
+
+unsigned char find_nearest_color(const CL_Palette& palette, const CL_Color& rgb)
+{ // Copyright (C) 1998 Pyrosoft Inc. (www.pyrosoftgames.com), Matthew Bogue
+  float bestDist = 10000000.0f;
+  int   best     = 0;
+
+  float vPic = sqrt(rgb.get_red() * rgb.get_red() 
+                    + rgb.get_green() * rgb.get_green()
+                    + rgb.get_blue() * rgb.get_blue()) * 0.57735027;
+ 
+  for (int i = 0; i < 256; i++) {
+    float vPal = sqrt(palette.colors[i].get_red()     * palette.colors[i].get_red()
+                      + palette.colors[i].get_green() * palette.colors[i].get_green()
+                      + palette.colors[i].get_blue()  * palette.colors[i].get_blue()) * 0.57735027;
+
+    float dr = palette.colors[i].get_red()   - rgb.get_red();
+    float dg = palette.colors[i].get_green() - rgb.get_green();
+    float db = palette.colors[i].get_blue()  - rgb.get_blue();
+    float dv = vPal-vPic;
+    float dist = dr * dr * 0.3 + dg * dg * 0.59 + db * db * 0.11 + dv * dv * 0.7;
+
+    if (dist < bestDist) {
+      bestDist = dist;
+      best = i;
+    }
+  }
+
+  return best;
+}
+
+class NetPanzerFileStructImpl
+{
+public:
+  std::string id_header;
+  std::string name;
+  std::string description;
+  TilemapLayer tilemap; 
+  Tileset tileset;
+};
+
+std::string
+NetPanzerFileStruct::get_id_header()
+{
+  return impl->id_header;
+}
+
+std::string
+NetPanzerFileStruct::get_name()
+{
+  return impl->name;
+}
+
+std::string
+NetPanzerFileStruct::get_description()
+{
+  return impl->description;
+}
+
+TilemapLayer
+NetPanzerFileStruct::get_tilemap()
+{
+  return impl->tilemap;
+}
+
+void
+NetPanzerFileStruct::set_id_header(const std::string& id)
+{
+  impl->id_header = id;
+}
+
+void
+NetPanzerFileStruct::set_name(const std::string& name)
+{
+  impl->name = name;
+}
+
+void
+NetPanzerFileStruct::set_description(const std::string& description)
+{
+  impl->description = description;
+}
+
+void
+NetPanzerFileStruct::set_tilemap(TilemapLayer l)
+{
+  impl->tilemap = l;
+}
+
+
+void
+NetPanzerFileStruct::save(const std::string& filename)
+{
+  if (impl->tilemap.is_null())
+    return;
+    
+  unsigned char   netp_id_header[64];
+  strcpy(reinterpret_cast<char*>(netp_id_header), impl->id_header.c_str());
+  unsigned short  id       = 0; // ?
+  char   name[256];
+  strcpy(name, impl->name.c_str());
+  char   description[1024];
+  strcpy(description, impl->description.c_str());
+  unsigned short  x_size   = impl->tilemap.get_width();
+  unsigned short  y_size   = impl->tilemap.get_height();
+  char            tile_set[256] = "summer12mb.tls";
+ 
+  unsigned short  thumbnail_x_pix = impl->tilemap.get_width();
+  unsigned short  thumbnail_y_pix = impl->tilemap.get_height();
+    
+  std::ofstream out(filename.c_str());
+
+  // FIXME: Not endian clean
+  out.write(reinterpret_cast<char*>(&netp_id_header), sizeof(netp_id_header));
+  out.write(reinterpret_cast<char*>(&id), sizeof(short));
+  out.write(reinterpret_cast<char*>(&name), sizeof(name));
+  out.write(reinterpret_cast<char*>(&description), sizeof(description));
+  out.write(reinterpret_cast<char*>(&x_size), sizeof(short));
+  out.write(reinterpret_cast<char*>(&y_size), sizeof(short));
+  out.write(reinterpret_cast<char*>(&tile_set), sizeof(tile_set));
+  out.write(reinterpret_cast<char*>(&thumbnail_x_pix), sizeof(short));
+  out.write(reinterpret_cast<char*>(&thumbnail_y_pix), sizeof(short));
+
+  std::vector<unsigned short> vec(x_size * y_size);
+
+  int tile_count = impl->tilemap.get_tileset().get_tiles().size();
+  Field<int>* field = impl->tilemap.get_field();
+  for(int i = 0; i < x_size * y_size; ++i)
+    {
+      // Fill everything that isn't a valid tile with grass
+      if ((*field)[i] >= 0 && (*field)[i] < tile_count)
+        vec[i] = (*field)[i];
+      else
+        vec[i] = 8097 + rand()%16;
+    }
+  out.write(reinterpret_cast<char*>(&(*vec.begin())), 
+            sizeof(unsigned short)*vec.size());
+
+  // Generate thumbnail
+  std::vector<unsigned char> thumbnail(x_size * y_size);
+  for(int i = 0; i < int(thumbnail.size()); ++i)
+    {
+      Tile* tile = impl->tileset.create((*field)[i]);
+      if (tile)
+        thumbnail[i] = find_nearest_color(NetPanzerData::instance()->get_palette(), tile->get_color());
+    }
+
+  out.write(reinterpret_cast<char*>(&(*thumbnail.begin())), 
+            sizeof(unsigned char)*thumbnail.size());
+}
+
+NetPanzerFileStruct::NetPanzerFileStruct(Tileset tileset, int w, int h)
+  : impl(new NetPanzerFileStructImpl())
+{
+  impl->tileset = tileset;
+  impl->id_header = "<Id Header>";
+  impl->name = "<Name>";
+  impl->description = "<Description>";
+  impl->tilemap = TilemapLayer(tileset, w, h);
+}
+
+NetPanzerFileStruct::NetPanzerFileStruct(Tileset tileset, const std::string& filename)
+  : impl(new NetPanzerFileStructImpl())
+{
+  impl->tileset = tileset;
+  
+  // FIXME: endian issues
+  unsigned char   netp_id_header[64]; // Copyright PyroSoft Inc.
+  unsigned short  id; // What is this?
+  char            name[256];
+  char            description[1024];
+  unsigned short  x_size; // width
+  unsigned short  y_size; // height
+  char            tile_set[256]; // name of the tileset: "summer12mb.tls"
+ 
+  unsigned short  thumbnail_x_pix;
+  unsigned short  thumbnail_y_pix;
+
+  std::ifstream file(filename.c_str());
+
+  if (!file)
+    {
+      std::cout << "NetPanzerFileStructImpl: Error: " << filename << std::endl;
+    }
+
+  file.read(reinterpret_cast<char*>(&netp_id_header), sizeof(netp_id_header));
+  file.read(reinterpret_cast<char*>(&id), sizeof(short));
+  file.read(reinterpret_cast<char*>(&name), sizeof(name));
+  file.read(reinterpret_cast<char*>(&description), sizeof(description));
+  file.read(reinterpret_cast<char*>(&x_size), sizeof(short));
+  file.read(reinterpret_cast<char*>(&y_size), sizeof(short));
+  file.read(reinterpret_cast<char*>(&tile_set), sizeof(tile_set));
+  file.read(reinterpret_cast<char*>(&thumbnail_x_pix), sizeof(short));
+  file.read(reinterpret_cast<char*>(&thumbnail_y_pix), sizeof(short));
+
+  TilemapLayer tilemap(tileset, x_size, y_size);
+  Field<int>* field      = tilemap.get_field();
+
+  std::vector<unsigned short> vec;
+  vec.resize(x_size * y_size);
+  file.read(reinterpret_cast<char*>(&(*vec.begin())), sizeof(unsigned short)*vec.size());
+
+  for(int i = 0; i < x_size*y_size; ++i)
+    (*field)[i] = vec[i];
+
+  std::cout << "Thumbnail: " << thumbnail_x_pix << " " << thumbnail_y_pix << std::endl;
+
+  impl->tilemap     = tilemap;
+  impl->id_header   = reinterpret_cast<char*>(netp_id_header);
+  impl->name        = name;
+  impl->description = description;
+}
+
+/* EOF */

Deleted: trunk/flexlay/netpanzer/netpanzer.cxx
===================================================================
--- trunk/flexlay/netpanzer/netpanzer.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/netpanzer/netpanzer.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,553 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <sstream>
-#include <fstream>
-#include <ClanLib/core.h>
-#include <ClanLib/Display/palette.h>
-#include <ClanLib/Display/sprite.h>
-#include <ClanLib/Display/pixel_format.h>
-#include <ClanLib/Display/pixel_format_type.h>
-#include <ClanLib/Display/sprite_description.h>
-#include <ClanLib/Display/Providers/provider_factory.h>
-#include "globals.hxx"
-#include "tile_provider.hxx"
-#include "tile_provider_impl.hxx"
-#include "tile.hxx"
-#include "tileset.hxx"
-#include "blitter.hxx"
-#include "tilemap_layer.hxx"
-#include "editor_map.hxx"
-#include "netpanzer.hxx"
-
-NetPanzerData* NetPanzerData::instance_ = 0;
-
-class NetPanzerTileProviderImpl : public TileProviderImpl
-{
-private:
-  int id;
-  mutable CL_Sprite sprite;
-  mutable CL_PixelBuffer buffer;
-
-public:
-  NetPanzerTileProviderImpl(int id_)
-    : id(id_)
-  {    
-  }
-
-  virtual ~NetPanzerTileProviderImpl()
-  {
-  }
-
-  CL_Sprite get_sprite() const
-  {
-    if (sprite)
-      {
-        return sprite;
-      }
-    else
-      {
-        NetPanzerTileGroup& tilegroup = NetPanzerData::instance()->find_tilegroup(id);
-        int dist = id - tilegroup.start;
-
-        CL_Rect rect(CL_Point((dist % tilegroup.width) * 32,
-                              (dist / tilegroup.width) * 32),
-                     CL_Size(32, 32));
-        sprite.add_frame(tilegroup.get_surface(), rect);
-        return sprite;
-      }
-  }
-
-  CL_PixelBuffer get_pixelbuffer() const
-  {
-    if (buffer)
-      {
-        return buffer;
-      }
-    else
-      {
-        // FIXME: ClanLibs indexed handling seems broken, so we do
-        // the conversion ourself
-        const CL_Palette& palette = NetPanzerData::instance()->get_palette();
-        unsigned char* data = NetPanzerData::instance()->get_tiledata() + (32*32) * id;
-        buffer = CL_PixelBuffer(32, 32, 32*3, CL_PixelFormat::rgb888);
-
-        buffer.lock();
-        unsigned char* target = static_cast<unsigned char*>(buffer.get_data());
-
-        for(int i = 0; i < 32*32; ++i)
-          {
-            target[3*i+0] = palette[data[i]].get_blue();
-            target[3*i+1] = palette[data[i]].get_green();
-            target[3*i+2] = palette[data[i]].get_red();
-          }
-        buffer.unlock();
-                
-        return buffer;
-      }
-  }
-};
-
-NetPanzerData::NetPanzerData() 
-{
-}
-
-void
-NetPanzerData::register_tilegroup(int start, int width, int height)
-{
-  NetPanzerTileGroup group;
-
-  group.start  = start;
-  group.width  = width;
-  group.height = height;
-
-  tilegroups.push_back(group);
-}
-
-void
-NetPanzerData::load_data(const std::string& datadir_)
-{
-  datadir = datadir_;
-  std::cout << "NetPanzerData: Loading data from '" << datadir << "'" << std::endl;
-  palette = load_palette(datadir + "/" + "wads/netp.act");
-  load_tileset(datadir + "/" + "wads/summer12mb.tls");
-}
-
-CL_Surface
-NetPanzerTileGroup::get_surface()
-{
-  if (!surface)
-    {
-      CL_PixelBuffer buffer(width*32, height*32, width*32*4, CL_PixelFormat::rgba8888);
-
-      for(int y = 0; y < height; ++y)
-        for(int x = 0; x < width; ++x)
-          {
-            const CL_Palette& palette = NetPanzerData::instance()->get_palette();
-            unsigned char* data = NetPanzerData::instance()->get_tiledata() + (32*32) * (start + width*y + x);
-
-            NetPanzerTileHeader header = NetPanzerData::instance()->get_tile_headers()[start + width*y + x]; 
-           
-            CL_PixelBuffer tile(32, 32, 32*3, CL_PixelFormat::rgb888);
-
-            tile.lock();
-            unsigned char* target = static_cast<unsigned char*>(tile.get_data());
-
-            float r = 1.0f;
-            float g = 1.0f;
-            float b = 1.0f;
-
-            switch (header.move_value)
-              {
-              case 0: // streets, allowing faster movement
-                r = 1.0f;
-                g = 1.0f;
-                b = 0.0f;
-                break;
-
-              case 1: // normal ground which allows to move
-                r = 1.0f;
-                g = 1.0f;
-                b = 1.0f;
-                break;
-
-              case 4: // unpassable terrain
-                r = 0.0f;
-                g = 1.0;
-                b = 0.0f;
-                break;
-
-              case 5: // water
-                r = 0.0f;
-                g = 0.0f;
-                b = 1.0f;
-                break;
-
-              default:
-                std::cout << "Unknown header value: " << int(header.move_value) << std::endl;
-                break;
-              }
-
-            for(int i = 0; i < 32*32; ++i)
-              {
-                target[3*i+0] = int(palette[data[i]].get_blue()  * b);
-                target[3*i+1] = int(palette[data[i]].get_green() * g);
-                target[3*i+2] = int(palette[data[i]].get_red()   * r);
-              }
-            tile.unlock();
-                
-            blit(buffer, tile, x * 32, y * 32);
-          }
-      
-      surface = CL_Surface(buffer);
-    }
-
-  return surface;
-}
-
-CL_Sprite
-NetPanzerData::get_tilegroup_sprite(int index)
-{
-  for(TileGroups::iterator i = tilegroups.begin(); i != tilegroups.end(); ++i)
-    {
-      if (index == i->start)
-        {
-          CL_Sprite sprite;
-          sprite.add_frame(i->get_surface(), CL_Rect(CL_Point(0, 0),
-                                                     CL_Size(i->get_surface().get_width(),
-                                                             i->get_surface().get_height())));
-          return sprite;
-        }
-    }
-
-  std::cout << "NetPanzerData: Couldn't get tilegroup_sprite for '" << index << "'" << std::endl;
-  return CL_Sprite();
-}
-
-NetPanzerTileGroup&
-NetPanzerData::find_tilegroup(int index)
-{
-  for(TileGroups::iterator i = tilegroups.begin(); i != tilegroups.end(); ++i)
-    {
-      if (i->start <= index && index < i->start + (i->width*i->height))
-        {
-          return *i;
-        }
-    }
-
-  std::cout << "NetPanzerData: Couldn't find tilegroup for '" << index << "'" << std::endl;
-  // return some junk just to keep it running
-  return tilegroups.front();
-}
-
-const Tileset&
-NetPanzerData::get_tileset() const
-{
-  return tileset;
-}
-
-const CL_Palette&
-NetPanzerData::get_palette() const
-{
-  return palette;
-}
-
-const std::vector<NetPanzerTileHeader>&
-NetPanzerData::get_tile_headers() const
-{
-  return tile_headers;
-}
-
-unsigned char*
-NetPanzerData::get_tiledata() const
-{
-  return tiledata;
-}
-
-CL_Palette
-NetPanzerData::load_palette(const std::string& filename)
-{
-  CL_Palette palette;
-  unsigned char color_array[256 * 3];
-  
-  std::ifstream in(filename.c_str());
-  
-  if (!in)
-    {
-      std::cout << "Couldn't load palette" << std::endl;
-      return palette;
-    }
-
-  in.read(reinterpret_cast<char*>(color_array), sizeof(color_array));
-
-  for(int i = 0; i < 256; ++i)
-    {
-      palette.colors[i].set_red  (color_array[3*i + 0]);
-      palette.colors[i].set_green(color_array[3*i + 1]);
-      palette.colors[i].set_blue (color_array[3*i + 2]);
-    }
-
-  return palette;
-}
-
-void
-NetPanzerData::load_tileset(const std::string& filename)
-{
-  unsigned char	netp_id_header[64];
-  unsigned short	version;
-  unsigned short	width;
-  unsigned short	height;
-  unsigned short	tile_count;
-  unsigned char	raw_palette[768];
-
-  std::ifstream file(filename.c_str());  
-
-  if (!file)
-    {
-      std::cout << "Couldn't load " << filename << std::endl;
-    }
-  else
-    {
-      file.read(reinterpret_cast<char*>(netp_id_header), sizeof(netp_id_header));
-      file.read(reinterpret_cast<char*>(&version), sizeof(version));
-      file.read(reinterpret_cast<char*>(&width), sizeof(width));
-      file.read(reinterpret_cast<char*>(&height), sizeof(height));
-      file.read(reinterpret_cast<char*>(&tile_count), sizeof(tile_count));
-      file.read(reinterpret_cast<char*>(raw_palette), sizeof(raw_palette));
-
-      tile_headers.resize(tile_count);
-
-      file.read(reinterpret_cast<char*>(&*tile_headers.begin()), 
-                sizeof(NetPanzerTileHeader)*tile_count);
-
-      cl_uint32 tilesize = width * height;
-      // FIXME: Delete this somewhere!
-      unsigned char* tiledata = new unsigned char[tilesize*tile_count];
-      file.read(reinterpret_cast<char*>(tiledata), tilesize*tile_count);
-      file.close();
-
-      // FIXME: The palette in the netpanzer 'summer12mb.tls' file
-      // is either broken or otherwise corrupt, so we ignore it
-      // and use the seperate palette file 'netp.act' which works
-      // fine.
-      
-      NetPanzerData::instance()->tiledata = tiledata;
-      
-      tileset = Tileset(width);
-
-      for(int i = 0; i < tile_count; ++i)
-        {
-          Tile tile(TileProvider(new NetPanzerTileProviderImpl(i)));
-          tileset.add_tile(i, &tile);
-        }
-    }
-}
-
-unsigned char find_nearest_color(const CL_Palette& palette, const CL_Color& rgb)
-{ // Copyright (C) 1998 Pyrosoft Inc. (www.pyrosoftgames.com), Matthew Bogue
-  float bestDist = 10000000.0f;
-  int   best     = 0;
-
-  float vPic = sqrt(rgb.get_red() * rgb.get_red() 
-                    + rgb.get_green() * rgb.get_green()
-                    + rgb.get_blue() * rgb.get_blue()) * 0.57735027;
- 
-  for (int i = 0; i < 256; i++) {
-    float vPal = sqrt(palette.colors[i].get_red()     * palette.colors[i].get_red()
-                      + palette.colors[i].get_green() * palette.colors[i].get_green()
-                      + palette.colors[i].get_blue()  * palette.colors[i].get_blue()) * 0.57735027;
-
-    float dr = palette.colors[i].get_red()   - rgb.get_red();
-    float dg = palette.colors[i].get_green() - rgb.get_green();
-    float db = palette.colors[i].get_blue()  - rgb.get_blue();
-    float dv = vPal-vPic;
-    float dist = dr * dr * 0.3 + dg * dg * 0.59 + db * db * 0.11 + dv * dv * 0.7;
-
-    if (dist < bestDist) {
-      bestDist = dist;
-      best = i;
-    }
-  }
-
-  return best;
-}
-
-class NetPanzerFileStructImpl
-{
-public:
-  std::string id_header;
-  std::string name;
-  std::string description;
-  TilemapLayer tilemap; 
-  Tileset tileset;
-};
-
-std::string
-NetPanzerFileStruct::get_id_header()
-{
-  return impl->id_header;
-}
-
-std::string
-NetPanzerFileStruct::get_name()
-{
-  return impl->name;
-}
-
-std::string
-NetPanzerFileStruct::get_description()
-{
-  return impl->description;
-}
-
-TilemapLayer
-NetPanzerFileStruct::get_tilemap()
-{
-  return impl->tilemap;
-}
-
-void
-NetPanzerFileStruct::set_id_header(const std::string& id)
-{
-  impl->id_header = id;
-}
-
-void
-NetPanzerFileStruct::set_name(const std::string& name)
-{
-  impl->name = name;
-}
-
-void
-NetPanzerFileStruct::set_description(const std::string& description)
-{
-  impl->description = description;
-}
-
-void
-NetPanzerFileStruct::set_tilemap(TilemapLayer l)
-{
-  impl->tilemap = l;
-}
-
-
-void
-NetPanzerFileStruct::save(const std::string& filename)
-{
-  if (impl->tilemap.is_null())
-    return;
-    
-  unsigned char   netp_id_header[64];
-  strcpy(reinterpret_cast<char*>(netp_id_header), impl->id_header.c_str());
-  unsigned short  id       = 0; // ?
-  char   name[256];
-  strcpy(name, impl->name.c_str());
-  char   description[1024];
-  strcpy(description, impl->description.c_str());
-  unsigned short  x_size   = impl->tilemap.get_width();
-  unsigned short  y_size   = impl->tilemap.get_height();
-  char            tile_set[256] = "summer12mb.tls";
- 
-  unsigned short  thumbnail_x_pix = impl->tilemap.get_width();
-  unsigned short  thumbnail_y_pix = impl->tilemap.get_height();
-    
-  std::ofstream out(filename.c_str());
-
-  // FIXME: Not endian clean
-  out.write(reinterpret_cast<char*>(&netp_id_header), sizeof(netp_id_header));
-  out.write(reinterpret_cast<char*>(&id), sizeof(short));
-  out.write(reinterpret_cast<char*>(&name), sizeof(name));
-  out.write(reinterpret_cast<char*>(&description), sizeof(description));
-  out.write(reinterpret_cast<char*>(&x_size), sizeof(short));
-  out.write(reinterpret_cast<char*>(&y_size), sizeof(short));
-  out.write(reinterpret_cast<char*>(&tile_set), sizeof(tile_set));
-  out.write(reinterpret_cast<char*>(&thumbnail_x_pix), sizeof(short));
-  out.write(reinterpret_cast<char*>(&thumbnail_y_pix), sizeof(short));
-
-  std::vector<unsigned short> vec(x_size * y_size);
-
-  int tile_count = impl->tilemap.get_tileset().get_tiles().size();
-  Field<int>* field = impl->tilemap.get_field();
-  for(int i = 0; i < x_size * y_size; ++i)
-    {
-      // Fill everything that isn't a valid tile with grass
-      if ((*field)[i] >= 0 && (*field)[i] < tile_count)
-        vec[i] = (*field)[i];
-      else
-        vec[i] = 8097 + rand()%16;
-    }
-  out.write(reinterpret_cast<char*>(&(*vec.begin())), 
-            sizeof(unsigned short)*vec.size());
-
-  // Generate thumbnail
-  std::vector<unsigned char> thumbnail(x_size * y_size);
-  for(int i = 0; i < int(thumbnail.size()); ++i)
-    {
-      Tile* tile = impl->tileset.create((*field)[i]);
-      if (tile)
-        thumbnail[i] = find_nearest_color(NetPanzerData::instance()->get_palette(), tile->get_color());
-    }
-
-  out.write(reinterpret_cast<char*>(&(*thumbnail.begin())), 
-            sizeof(unsigned char)*thumbnail.size());
-}
-
-NetPanzerFileStruct::NetPanzerFileStruct(Tileset tileset, int w, int h)
-  : impl(new NetPanzerFileStructImpl())
-{
-  impl->tileset = tileset;
-  impl->id_header = "<Id Header>";
-  impl->name = "<Name>";
-  impl->description = "<Description>";
-  impl->tilemap = TilemapLayer(tileset, w, h);
-}
-
-NetPanzerFileStruct::NetPanzerFileStruct(Tileset tileset, const std::string& filename)
-  : impl(new NetPanzerFileStructImpl())
-{
-  impl->tileset = tileset;
-  
-  // FIXME: endian issues
-  unsigned char   netp_id_header[64]; // Copyright PyroSoft Inc.
-  unsigned short  id; // What is this?
-  char            name[256];
-  char            description[1024];
-  unsigned short  x_size; // width
-  unsigned short  y_size; // height
-  char            tile_set[256]; // name of the tileset: "summer12mb.tls"
- 
-  unsigned short  thumbnail_x_pix;
-  unsigned short  thumbnail_y_pix;
-
-  std::ifstream file(filename.c_str());
-
-  if (!file)
-    {
-      std::cout << "NetPanzerFileStructImpl: Error: " << filename << std::endl;
-    }
-
-  file.read(reinterpret_cast<char*>(&netp_id_header), sizeof(netp_id_header));
-  file.read(reinterpret_cast<char*>(&id), sizeof(short));
-  file.read(reinterpret_cast<char*>(&name), sizeof(name));
-  file.read(reinterpret_cast<char*>(&description), sizeof(description));
-  file.read(reinterpret_cast<char*>(&x_size), sizeof(short));
-  file.read(reinterpret_cast<char*>(&y_size), sizeof(short));
-  file.read(reinterpret_cast<char*>(&tile_set), sizeof(tile_set));
-  file.read(reinterpret_cast<char*>(&thumbnail_x_pix), sizeof(short));
-  file.read(reinterpret_cast<char*>(&thumbnail_y_pix), sizeof(short));
-
-  TilemapLayer tilemap(tileset, x_size, y_size);
-  Field<int>* field      = tilemap.get_field();
-
-  std::vector<unsigned short> vec;
-  vec.resize(x_size * y_size);
-  file.read(reinterpret_cast<char*>(&(*vec.begin())), sizeof(unsigned short)*vec.size());
-
-  for(int i = 0; i < x_size*y_size; ++i)
-    (*field)[i] = vec[i];
-
-  std::cout << "Thumbnail: " << thumbnail_x_pix << " " << thumbnail_y_pix << std::endl;
-
-  impl->tilemap     = tilemap;
-  impl->id_header   = reinterpret_cast<char*>(netp_id_header);
-  impl->name        = name;
-  impl->description = description;
-}
-
-/* EOF */

Copied: trunk/flexlay/netpanzer/netpanzer.hpp (from rev 712, trunk/flexlay/netpanzer/netpanzer.hxx)
===================================================================
--- trunk/flexlay/netpanzer/netpanzer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/netpanzer/netpanzer.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,128 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_SCRIPTING_NETPANZER_HXX
+#define HEADER_SCRIPTING_NETPANZER_HXX
+
+#include <string>
+#include <ClanLib/Display/palette.h>
+#include <ClanLib/Display/surface.h>
+#include <ClanLib/Display/sprite.h>
+#include "../lib/tileset.hpp"
+#include "../lib/tilemap_layer.hpp"
+#include "../lib/shared_ptr.hpp"
+
+void load_netpanzer_tileset(Tileset tileset, const char* filename);
+
+class NetPanzerFileStructImpl;
+
+struct NetPanzerTileHeader
+{
+public:
+  char	attrib;
+  char	move_value;
+  char	avg_color;
+};
+
+struct NetPanzerTileGroup
+{
+  int start;
+  int width;
+  int height;
+  
+  CL_Surface get_surface(); 
+
+private:
+  /** Surface holding the tilegroups image */
+  CL_Surface surface;
+};
+
+class NetPanzerData
+{
+private:
+  static NetPanzerData* instance_;
+public:
+  static NetPanzerData* instance() 
+  {
+    if (instance_)
+      return (instance_);
+    else
+      return (instance_ = new NetPanzerData());
+  }
+
+private:
+  std::string    datadir;
+  CL_Palette     palette;
+  Tileset        tileset;
+  unsigned char* tiledata;
+  typedef std::vector<NetPanzerTileGroup> TileGroups;
+  TileGroups tilegroups;
+  std::vector<NetPanzerTileHeader> tile_headers;
+public:
+  NetPanzerData();
+
+  /** Register a tilegroup, ie. a section of tiles that belong
+      together and form an building, lake, a section of trees, etc.
+
+      \param start the tile-id for the upper/left tile
+      \param width the width of tilegroup
+      \param height the height of the tilegroup
+  */
+  void register_tilegroup(int start, int width, int height);
+
+  void load_data(const std::string& datadir_);
+  const CL_Palette& get_palette() const;
+  const Tileset&    get_tileset() const;
+  const std::vector<NetPanzerTileHeader>& get_tile_headers() const;
+  unsigned char*    get_tiledata() const;
+
+  CL_Palette load_palette(const std::string& filename);
+  CL_Sprite  get_tilegroup_sprite(int index);
+
+  /** Locate the tilegroup in which the tile with \a tileindex is
+      located */
+  NetPanzerTileGroup& find_tilegroup(int tileindex);
+
+private:
+  void       load_tileset(const std::string& filename);
+};
+
+class NetPanzerFileStruct
+{
+public:
+  NetPanzerFileStruct(Tileset tileset, int w, int h);
+  NetPanzerFileStruct(Tileset tileset, const std::string& filename);
+
+  std::string get_id_header();
+  std::string get_name();
+  std::string get_description();
+  TilemapLayer get_tilemap(); 
+
+  void set_id_header(const std::string& id);
+  void set_name(const std::string& name);
+  void set_description(const std::string& description);
+  void set_tilemap(TilemapLayer l); 
+
+  void save(const std::string& filename);
+private:
+  SharedPtr<NetPanzerFileStructImpl> impl;
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/netpanzer/netpanzer.hxx
===================================================================
--- trunk/flexlay/netpanzer/netpanzer.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/netpanzer/netpanzer.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,128 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_SCRIPTING_NETPANZER_HXX
-#define HEADER_SCRIPTING_NETPANZER_HXX
-
-#include <string>
-#include <ClanLib/Display/palette.h>
-#include <ClanLib/Display/surface.h>
-#include <ClanLib/Display/sprite.h>
-#include "../lib/tileset.hxx"
-#include "../lib/tilemap_layer.hxx"
-#include "../lib/shared_ptr.hxx"
-
-void load_netpanzer_tileset(Tileset tileset, const char* filename);
-
-class NetPanzerFileStructImpl;
-
-struct NetPanzerTileHeader
-{
-public:
-  char	attrib;
-  char	move_value;
-  char	avg_color;
-};
-
-struct NetPanzerTileGroup
-{
-  int start;
-  int width;
-  int height;
-  
-  CL_Surface get_surface(); 
-
-private:
-  /** Surface holding the tilegroups image */
-  CL_Surface surface;
-};
-
-class NetPanzerData
-{
-private:
-  static NetPanzerData* instance_;
-public:
-  static NetPanzerData* instance() 
-  {
-    if (instance_)
-      return (instance_);
-    else
-      return (instance_ = new NetPanzerData());
-  }
-
-private:
-  std::string    datadir;
-  CL_Palette     palette;
-  Tileset        tileset;
-  unsigned char* tiledata;
-  typedef std::vector<NetPanzerTileGroup> TileGroups;
-  TileGroups tilegroups;
-  std::vector<NetPanzerTileHeader> tile_headers;
-public:
-  NetPanzerData();
-
-  /** Register a tilegroup, ie. a section of tiles that belong
-      together and form an building, lake, a section of trees, etc.
-
-      \param start the tile-id for the upper/left tile
-      \param width the width of tilegroup
-      \param height the height of the tilegroup
-  */
-  void register_tilegroup(int start, int width, int height);
-
-  void load_data(const std::string& datadir_);
-  const CL_Palette& get_palette() const;
-  const Tileset&    get_tileset() const;
-  const std::vector<NetPanzerTileHeader>& get_tile_headers() const;
-  unsigned char*    get_tiledata() const;
-
-  CL_Palette load_palette(const std::string& filename);
-  CL_Sprite  get_tilegroup_sprite(int index);
-
-  /** Locate the tilegroup in which the tile with \a tileindex is
-      located */
-  NetPanzerTileGroup& find_tilegroup(int tileindex);
-
-private:
-  void       load_tileset(const std::string& filename);
-};
-
-class NetPanzerFileStruct
-{
-public:
-  NetPanzerFileStruct(Tileset tileset, int w, int h);
-  NetPanzerFileStruct(Tileset tileset, const std::string& filename);
-
-  std::string get_id_header();
-  std::string get_name();
-  std::string get_description();
-  TilemapLayer get_tilemap(); 
-
-  void set_id_header(const std::string& id);
-  void set_name(const std::string& name);
-  void set_description(const std::string& description);
-  void set_tilemap(TilemapLayer l); 
-
-  void save(const std::string& filename);
-private:
-  SharedPtr<NetPanzerFileStructImpl> impl;
-};
-
-#endif
-
-/* EOF */

Modified: trunk/flexlay/netpanzer/netpanzer.i
===================================================================
--- trunk/flexlay/netpanzer/netpanzer.i	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/netpanzer/netpanzer.i	2009-11-22 03:02:03 UTC (rev 713)
@@ -5,11 +5,11 @@
 #include <iostream>
 #include <ClanLib/Core/System/error.h>
 #include <ClanLib/Display/sprite.h>
-#include "netpanzer.hxx"
+#include "netpanzer.hpp"
 %}
 
 %import  "../lib/flexlay_wrap.i"
-%include "netpanzer.hxx"
+%include "netpanzer.hpp"
 
 
 // EOF //

Modified: trunk/flexlay/ruby/SConscript
===================================================================
--- trunk/flexlay/ruby/SConscript	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/SConscript	2009-11-22 03:02:03 UTC (rev 713)
@@ -52,20 +52,20 @@
     return lst            
 
 #Depends('../lib/flexlay_wrap.i', gen_i_depends(Dir("../lib").abspath, File("../lib/flexlay_wrap.i").abspath))
-#env.Command('flexlay_ruby_wrap.cxx', '../lib/flexlay_wrap.i',
+#env.Command('flexlay_ruby_wrap.cpp', '../lib/flexlay_wrap.i',
 #            "swig -c++ -ruby -o $TARGET $SOURCE")
 
 libflexlay_ruby_env = env.Clone()
 flexlay_ruby_lib = libflexlay_ruby_env.SharedLibrary(
     target = 'flexlay_wrap.so',
     source = [
-    env.CXXFile(target='flexlay_ruby_wrap.cxx', source='../lib/flexlay_wrap.i',
-      SWIGFLAGS="-ruby -c++", CXXFILESUFFIX=".cxx"),
-    'ruby_functor.cxx',
-    'ruby_meta_data.cxx',
-    'ruby_sexpr_parser.cxx',
-    'ruby_object.cxx',
-    'ruby_converter.cxx'
+    env.CXXFile(target='flexlay_ruby_wrap.cpp', source='../lib/flexlay_wrap.i',
+      SWIGFLAGS="-ruby -c++", CXXFILESUFFIX=".cpp"),
+    'ruby_functor.cpp',
+    'ruby_meta_data.cpp',
+    'ruby_sexpr_parser.cpp',
+    'ruby_object.cpp',
+    'ruby_converter.cpp'
     ],
     CPPPATH=[".",'$USER_CPPPATH','$RUBYDIR','../lib/'] + clanLib_env['CPPPATH'],
     LINKFLAGS = clanLib_env['LINKFLAGS'],

Copied: trunk/flexlay/ruby/flexlay_wrap.hpp (from rev 712, trunk/flexlay/ruby/flexlay_wrap.hxx)

Deleted: trunk/flexlay/ruby/flexlay_wrap.hxx
===================================================================
--- trunk/flexlay/ruby/flexlay_wrap.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/flexlay_wrap.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,49 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_FLEXLAY_WRAP_HXX
-#define HEADER_FLEXLAY_WRAP_HXX
-
-#include <ClanLib/Display/color.h>
-#include <iostream>
-#include <typeinfo>
-#include "ruby.h"
-
-class CL_Point;
-class CL_Pointf;
-class ObjectBrush;
-class ObjMapObject;
-
-template<class C>
-VALUE convert_to_ruby_value(const C& c)
-{
-  std::cout << "Error: conversion for type '" << typeid(c).name() << "' missing" << std::endl;
-  return Qnil;
-}
-
-template<> VALUE convert_to_ruby_value<ObjMapObject>(const ObjMapObject& arg);
-template<> VALUE convert_to_ruby_value<ObjectBrush>(const ObjectBrush& arg);
-template<> VALUE convert_to_ruby_value<CL_Color>(const CL_Color& arg);
-template<> VALUE convert_to_ruby_value<CL_Point>(const CL_Point& arg);
-template<> VALUE convert_to_ruby_value<CL_Pointf>(const CL_Pointf& arg);
-template<> VALUE convert_to_ruby_value<int>(const int& arg);
-template<> VALUE convert_to_ruby_value<float>(const float& arg);
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/ruby/ruby_converter.cpp (from rev 712, trunk/flexlay/ruby/ruby_converter.cxx)
===================================================================
--- trunk/flexlay/ruby/ruby_converter.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_converter.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,74 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_RUBY_CONVERTER_HXX
+#define HEADER_RUBY_CONVERTER_HXX
+
+#include "flexlay_wrap.hpp"
+
+// The following functions are defined in flexlay_wrap.i, a bit hacky but seems to work
+VALUE ObjMapObject2Value(const ObjMapObject& arg);
+VALUE ObjectBrush2Value(const ObjectBrush& arg);
+VALUE CL_Point2Value(const CL_Point& arg);
+VALUE CL_Pointf2Value(const CL_Pointf& arg);
+VALUE CL_Color2Value(const CL_Color& arg);
+
+template<> VALUE convert_to_ruby_value<float>(const float& arg)
+{
+  return rb_float_new(arg);
+}
+
+template<>
+VALUE convert_to_ruby_value<ObjMapObject>(const ObjMapObject& arg)
+{
+  return ObjMapObject2Value(arg);
+}
+
+template<>
+VALUE convert_to_ruby_value<ObjectBrush>(const ObjectBrush& arg)
+{
+  return ObjectBrush2Value(arg);
+}
+
+template<>
+VALUE convert_to_ruby_value<CL_Color>(const CL_Color& arg)
+{
+  return CL_Color2Value(arg);
+}
+
+template<>
+VALUE convert_to_ruby_value<CL_Point>(const CL_Point& arg)
+{
+  return CL_Point2Value(arg);
+}
+
+template<>
+VALUE convert_to_ruby_value<CL_Pointf>(const CL_Pointf& arg)
+{
+  return CL_Pointf2Value(arg);
+}
+
+template<>
+VALUE convert_to_ruby_value<int>(const int& arg)
+{
+  return INT2FIX(arg);
+}
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/ruby/ruby_converter.cxx
===================================================================
--- trunk/flexlay/ruby/ruby_converter.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_converter.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,74 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_RUBY_CONVERTER_HXX
-#define HEADER_RUBY_CONVERTER_HXX
-
-#include "flexlay_wrap.hxx"
-
-// The following functions are defined in flexlay_wrap.i, a bit hacky but seems to work
-VALUE ObjMapObject2Value(const ObjMapObject& arg);
-VALUE ObjectBrush2Value(const ObjectBrush& arg);
-VALUE CL_Point2Value(const CL_Point& arg);
-VALUE CL_Pointf2Value(const CL_Pointf& arg);
-VALUE CL_Color2Value(const CL_Color& arg);
-
-template<> VALUE convert_to_ruby_value<float>(const float& arg)
-{
-  return rb_float_new(arg);
-}
-
-template<>
-VALUE convert_to_ruby_value<ObjMapObject>(const ObjMapObject& arg)
-{
-  return ObjMapObject2Value(arg);
-}
-
-template<>
-VALUE convert_to_ruby_value<ObjectBrush>(const ObjectBrush& arg)
-{
-  return ObjectBrush2Value(arg);
-}
-
-template<>
-VALUE convert_to_ruby_value<CL_Color>(const CL_Color& arg)
-{
-  return CL_Color2Value(arg);
-}
-
-template<>
-VALUE convert_to_ruby_value<CL_Point>(const CL_Point& arg)
-{
-  return CL_Point2Value(arg);
-}
-
-template<>
-VALUE convert_to_ruby_value<CL_Pointf>(const CL_Pointf& arg)
-{
-  return CL_Pointf2Value(arg);
-}
-
-template<>
-VALUE convert_to_ruby_value<int>(const int& arg)
-{
-  return INT2FIX(arg);
-}
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/ruby/ruby_functor.cpp (from rev 712, trunk/flexlay/ruby/ruby_functor.cxx)
===================================================================
--- trunk/flexlay/ruby/ruby_functor.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_functor.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,110 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include "flexlay_wrap.hpp"
+#include "ruby_functor.hpp"
+
+void
+RubyFunctor::print_error() 
+{
+  // FIXME: Potential memory leak
+  std::cout << "######################################################" << std::endl;
+  std::cout << "RubyException: " 
+            << rb_str2cstr(rb_inspect(ruby_errinfo), 0) 
+            << std::endl;
+
+  VALUE trace = rb_funcall(ruby_errinfo, rb_intern("backtrace"), 0);
+  for (int i = 0; i < RARRAY(trace)->len; ++i)
+    std::cout << rb_str2cstr(rb_ary_entry(trace, i), 0) << std::endl;
+  std::cout << "######################################################" << std::endl;
+  ruby_errinfo = Qnil;
+}
+
+VALUE
+RubyFunctor::funcall_protect(VALUE self)
+{
+  return rb_funcall(reinterpret_cast<RubyFunctor*>(self)->val.ptr(), rb_intern("call"), 0);
+}
+
+VALUE
+RubyFunctor::funcall_protect1(VALUE self)
+{
+  VALUE* args = reinterpret_cast<VALUE*>(self);
+  return rb_funcall(reinterpret_cast<RubyFunctor*>(args[0])->val.ptr(), rb_intern("call"), 1,
+                    args[1]);
+}
+
+VALUE
+RubyFunctor::funcall_protect2(VALUE self)
+{
+  VALUE* args = reinterpret_cast<VALUE*>(self);
+  return rb_funcall(reinterpret_cast<RubyFunctor*>(args[0])->val.ptr(), rb_intern("call"), 2,
+                    args[1], args[2]);
+}
+
+RubyFunctor::RubyFunctor(const RubyObject& val_)
+  : val(val_)
+{
+}
+
+RubyFunctor::~RubyFunctor()
+{
+}
+
+void
+RubyFunctor::operator()()
+{
+  int state = 0;
+  rb_protect(&RubyFunctor::funcall_protect, reinterpret_cast<VALUE>(this), &state);
+  if (state)
+    print_error();
+}
+
+// FIXME: Protect the function calls with arguments too
+
+void
+RubyFunctor::operator()(int i)
+{
+  //rb_funcall(val.ptr(), rb_intern("call"), 1, INT2FIX(i));
+  int state = 0;
+  VALUE args[2];
+  args[0] = reinterpret_cast<VALUE>(this);
+  args[1] = INT2FIX(i);
+  rb_protect(&RubyFunctor::funcall_protect1, reinterpret_cast<VALUE>(args), &state);
+
+  if (state)
+    print_error();
+}
+
+void
+RubyFunctor::operator()(int x, int y)
+{
+  //  rb_funcall(val.ptr(), rb_intern("call"), 2, INT2FIX(x), INT2FIX(y));
+  int state = 0;
+  VALUE args[3];
+  args[0] = reinterpret_cast<VALUE>(this);
+  args[1] = INT2FIX(x);
+  args[2] = INT2FIX(y);
+  rb_protect(&RubyFunctor::funcall_protect2, reinterpret_cast<VALUE>(args), &state);
+
+  if (state)
+    print_error();
+}
+
+/* EOF */

Deleted: trunk/flexlay/ruby/ruby_functor.cxx
===================================================================
--- trunk/flexlay/ruby/ruby_functor.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_functor.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,110 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include "flexlay_wrap.hxx"
-#include "ruby_functor.hxx"
-
-void
-RubyFunctor::print_error() 
-{
-  // FIXME: Potential memory leak
-  std::cout << "######################################################" << std::endl;
-  std::cout << "RubyException: " 
-            << rb_str2cstr(rb_inspect(ruby_errinfo), 0) 
-            << std::endl;
-
-  VALUE trace = rb_funcall(ruby_errinfo, rb_intern("backtrace"), 0);
-  for (int i = 0; i < RARRAY(trace)->len; ++i)
-    std::cout << rb_str2cstr(rb_ary_entry(trace, i), 0) << std::endl;
-  std::cout << "######################################################" << std::endl;
-  ruby_errinfo = Qnil;
-}
-
-VALUE
-RubyFunctor::funcall_protect(VALUE self)
-{
-  return rb_funcall(reinterpret_cast<RubyFunctor*>(self)->val.ptr(), rb_intern("call"), 0);
-}
-
-VALUE
-RubyFunctor::funcall_protect1(VALUE self)
-{
-  VALUE* args = reinterpret_cast<VALUE*>(self);
-  return rb_funcall(reinterpret_cast<RubyFunctor*>(args[0])->val.ptr(), rb_intern("call"), 1,
-                    args[1]);
-}
-
-VALUE
-RubyFunctor::funcall_protect2(VALUE self)
-{
-  VALUE* args = reinterpret_cast<VALUE*>(self);
-  return rb_funcall(reinterpret_cast<RubyFunctor*>(args[0])->val.ptr(), rb_intern("call"), 2,
-                    args[1], args[2]);
-}
-
-RubyFunctor::RubyFunctor(const RubyObject& val_)
-  : val(val_)
-{
-}
-
-RubyFunctor::~RubyFunctor()
-{
-}
-
-void
-RubyFunctor::operator()()
-{
-  int state = 0;
-  rb_protect(&RubyFunctor::funcall_protect, reinterpret_cast<VALUE>(this), &state);
-  if (state)
-    print_error();
-}
-
-// FIXME: Protect the function calls with arguments too
-
-void
-RubyFunctor::operator()(int i)
-{
-  //rb_funcall(val.ptr(), rb_intern("call"), 1, INT2FIX(i));
-  int state = 0;
-  VALUE args[2];
-  args[0] = reinterpret_cast<VALUE>(this);
-  args[1] = INT2FIX(i);
-  rb_protect(&RubyFunctor::funcall_protect1, reinterpret_cast<VALUE>(args), &state);
-
-  if (state)
-    print_error();
-}
-
-void
-RubyFunctor::operator()(int x, int y)
-{
-  //  rb_funcall(val.ptr(), rb_intern("call"), 2, INT2FIX(x), INT2FIX(y));
-  int state = 0;
-  VALUE args[3];
-  args[0] = reinterpret_cast<VALUE>(this);
-  args[1] = INT2FIX(x);
-  args[2] = INT2FIX(y);
-  rb_protect(&RubyFunctor::funcall_protect2, reinterpret_cast<VALUE>(args), &state);
-
-  if (state)
-    print_error();
-}
-
-/* EOF */

Copied: trunk/flexlay/ruby/ruby_functor.hpp (from rev 712, trunk/flexlay/ruby/ruby_functor.hxx)
===================================================================
--- trunk/flexlay/ruby/ruby_functor.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_functor.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,89 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_RUBY_FUNCTOR_HXX
+#define HEADER_RUBY_FUNCTOR_HXX
+
+#include <iostream>
+#include "ruby.h"
+#include "ruby_object.hpp"
+#include "flexlay_wrap.hpp"
+
+/** */
+class RubyFunctor
+{
+private:
+  RubyObject val;
+
+public:
+  RubyFunctor(const RubyObject& val_);  
+  ~RubyFunctor();
+
+  void operator()();
+  void operator()(int i);
+  void operator()(int x, int y);
+
+  /** Print backtrace in case of error */
+  static void print_error();
+
+  // FIXME: Protect these function calls somehow
+  template<class C> void operator()(const C& c)
+  {
+    if (1) {
+      rb_funcall(val.ptr(), rb_intern("call"), 1,
+                 convert_to_ruby_value(c));
+    } else {
+      //VALUE arg1 = convert_to_ruby_value(c);
+      //rb_funcall(val.ptr(), rb_intern("call"), 1, arg1);
+      int state = 0;
+      VALUE args[2];
+      args[0] = reinterpret_cast<VALUE>(this);
+      args[1] = convert_to_ruby_value(c);
+      rb_protect(&RubyFunctor::funcall_protect1, reinterpret_cast<VALUE>(args), &state);
+      if (state)
+        print_error();
+    }
+  }
+
+  template<class C, class D> void operator()(const C& c, const D& d)
+  {
+    if (1) {
+      rb_funcall(val.ptr(), rb_intern("call"), 2,
+                 convert_to_ruby_value(c),
+                 convert_to_ruby_value(d));
+    } else {
+      std::cout << "Calling operator() with two args" << std::endl;
+      int state = 0;
+      VALUE args[2];
+      args[0] = reinterpret_cast<VALUE>(this);
+      args[1] = convert_to_ruby_value(c);
+      args[2] = convert_to_ruby_value(d);
+      rb_protect(&RubyFunctor::funcall_protect2, reinterpret_cast<VALUE>(args), &state);
+      if (state)
+        print_error();
+    }
+  }
+  
+  static VALUE funcall_protect(VALUE self);
+  static VALUE funcall_protect1(VALUE self);
+  static VALUE funcall_protect2(VALUE self);
+};
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/ruby/ruby_functor.hxx
===================================================================
--- trunk/flexlay/ruby/ruby_functor.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_functor.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,89 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_RUBY_FUNCTOR_HXX
-#define HEADER_RUBY_FUNCTOR_HXX
-
-#include <iostream>
-#include "ruby.h"
-#include "ruby_object.hxx"
-#include "flexlay_wrap.hxx"
-
-/** */
-class RubyFunctor
-{
-private:
-  RubyObject val;
-
-public:
-  RubyFunctor(const RubyObject& val_);  
-  ~RubyFunctor();
-
-  void operator()();
-  void operator()(int i);
-  void operator()(int x, int y);
-
-  /** Print backtrace in case of error */
-  static void print_error();
-
-  // FIXME: Protect these function calls somehow
-  template<class C> void operator()(const C& c)
-  {
-    if (1) {
-      rb_funcall(val.ptr(), rb_intern("call"), 1,
-                 convert_to_ruby_value(c));
-    } else {
-      //VALUE arg1 = convert_to_ruby_value(c);
-      //rb_funcall(val.ptr(), rb_intern("call"), 1, arg1);
-      int state = 0;
-      VALUE args[2];
-      args[0] = reinterpret_cast<VALUE>(this);
-      args[1] = convert_to_ruby_value(c);
-      rb_protect(&RubyFunctor::funcall_protect1, reinterpret_cast<VALUE>(args), &state);
-      if (state)
-        print_error();
-    }
-  }
-
-  template<class C, class D> void operator()(const C& c, const D& d)
-  {
-    if (1) {
-      rb_funcall(val.ptr(), rb_intern("call"), 2,
-                 convert_to_ruby_value(c),
-                 convert_to_ruby_value(d));
-    } else {
-      std::cout << "Calling operator() with two args" << std::endl;
-      int state = 0;
-      VALUE args[2];
-      args[0] = reinterpret_cast<VALUE>(this);
-      args[1] = convert_to_ruby_value(c);
-      args[2] = convert_to_ruby_value(d);
-      rb_protect(&RubyFunctor::funcall_protect2, reinterpret_cast<VALUE>(args), &state);
-      if (state)
-        print_error();
-    }
-  }
-  
-  static VALUE funcall_protect(VALUE self);
-  static VALUE funcall_protect1(VALUE self);
-  static VALUE funcall_protect2(VALUE self);
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/ruby/ruby_meta_data.cpp (from rev 712, trunk/flexlay/ruby/ruby_meta_data.cxx)
===================================================================
--- trunk/flexlay/ruby/ruby_meta_data.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_meta_data.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,95 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <iostream>
+#include <ClanLib/Signals/signal_v0.h>
+#include "ruby_object.hpp"
+#include "meta_data_impl.hpp"
+#include "ruby_functor.hpp"
+#include "ruby_meta_data.hpp"
+
+typedef MetaDataGeneric<RubyObject> RubyMetaData;
+
+MetaData  make_metadata(VALUE obj)
+{
+  return MetaData(SharedPtr<MetaDataImpl>(new RubyMetaData(RubyObject(obj))));
+}
+
+VALUE get_ruby_object(const MetaData& data_obj)
+{
+  MetaDataImpl* data = data_obj.get_impl().get();
+
+  if (data)
+    {
+      RubyMetaData* rbdata = dynamic_cast<RubyMetaData*>(data);
+      if (rbdata)
+        {
+          return rbdata->data.ptr();
+        }
+    }
+  return Qnil;
+}
+
+void connect(CL_Signal_v0& sig, VALUE obj)
+{
+  sig = CL_Signal_v0();
+  new CL_Slot(sig.connect_functor(RubyFunctor(obj)));
+}
+
+void connect_v1_float(CL_Signal_v1<float>& sig, VALUE obj)
+{
+  sig = CL_Signal_v1<float>();
+  new CL_Slot(sig.connect_functor(RubyFunctor(obj)));
+}
+
+void connect_v1(CL_Signal_v1<int>& sig, VALUE obj)
+{
+  sig = CL_Signal_v1<int>();
+  new CL_Slot(sig.connect_functor(RubyFunctor(obj)));
+}
+
+void connect_v2(CL_Signal_v2<int, int>& sig, VALUE obj)
+{
+  sig = CL_Signal_v2<int, int>();
+  new CL_Slot(sig.connect_functor(RubyFunctor(obj)));
+}
+
+void connect_v2_graceful(CL_Signal_v2<int, int>& sig, VALUE obj)
+{
+  new CL_Slot(sig.connect_functor(RubyFunctor(obj)));
+}
+
+void connect_v1_Color(CL_Signal_v1<CL_Color>& sig, VALUE func)
+{
+  sig = CL_Signal_v1<CL_Color>();
+  new CL_Slot(sig.connect_functor(RubyFunctor(func)));
+}
+
+void connect_v1_ObjMapObject(CL_Signal_v1<ObjMapObject>& sig, VALUE func)
+{
+  sig = CL_Signal_v1<ObjMapObject>();
+  new CL_Slot(sig.connect_functor(RubyFunctor(func)));
+}
+
+void connect_v2_ObjectBrush_Point(CL_Signal_v2<ObjectBrush, CL_Point>& sig, VALUE func)
+{
+  sig = CL_Signal_v2<ObjectBrush, CL_Point>();
+  new CL_Slot(sig.connect_functor(RubyFunctor(func)));
+}
+
+/* EOF */

Deleted: trunk/flexlay/ruby/ruby_meta_data.cxx
===================================================================
--- trunk/flexlay/ruby/ruby_meta_data.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_meta_data.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,95 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <ClanLib/Signals/signal_v0.h>
-#include "ruby_object.hxx"
-#include "meta_data_impl.hxx"
-#include "ruby_functor.hxx"
-#include "ruby_meta_data.hxx"
-
-typedef MetaDataGeneric<RubyObject> RubyMetaData;
-
-MetaData  make_metadata(VALUE obj)
-{
-  return MetaData(SharedPtr<MetaDataImpl>(new RubyMetaData(RubyObject(obj))));
-}
-
-VALUE get_ruby_object(const MetaData& data_obj)
-{
-  MetaDataImpl* data = data_obj.get_impl().get();
-
-  if (data)
-    {
-      RubyMetaData* rbdata = dynamic_cast<RubyMetaData*>(data);
-      if (rbdata)
-        {
-          return rbdata->data.ptr();
-        }
-    }
-  return Qnil;
-}
-
-void connect(CL_Signal_v0& sig, VALUE obj)
-{
-  sig = CL_Signal_v0();
-  new CL_Slot(sig.connect_functor(RubyFunctor(obj)));
-}
-
-void connect_v1_float(CL_Signal_v1<float>& sig, VALUE obj)
-{
-  sig = CL_Signal_v1<float>();
-  new CL_Slot(sig.connect_functor(RubyFunctor(obj)));
-}
-
-void connect_v1(CL_Signal_v1<int>& sig, VALUE obj)
-{
-  sig = CL_Signal_v1<int>();
-  new CL_Slot(sig.connect_functor(RubyFunctor(obj)));
-}
-
-void connect_v2(CL_Signal_v2<int, int>& sig, VALUE obj)
-{
-  sig = CL_Signal_v2<int, int>();
-  new CL_Slot(sig.connect_functor(RubyFunctor(obj)));
-}
-
-void connect_v2_graceful(CL_Signal_v2<int, int>& sig, VALUE obj)
-{
-  new CL_Slot(sig.connect_functor(RubyFunctor(obj)));
-}
-
-void connect_v1_Color(CL_Signal_v1<CL_Color>& sig, VALUE func)
-{
-  sig = CL_Signal_v1<CL_Color>();
-  new CL_Slot(sig.connect_functor(RubyFunctor(func)));
-}
-
-void connect_v1_ObjMapObject(CL_Signal_v1<ObjMapObject>& sig, VALUE func)
-{
-  sig = CL_Signal_v1<ObjMapObject>();
-  new CL_Slot(sig.connect_functor(RubyFunctor(func)));
-}
-
-void connect_v2_ObjectBrush_Point(CL_Signal_v2<ObjectBrush, CL_Point>& sig, VALUE func)
-{
-  sig = CL_Signal_v2<ObjectBrush, CL_Point>();
-  new CL_Slot(sig.connect_functor(RubyFunctor(func)));
-}
-
-/* EOF */

Copied: trunk/flexlay/ruby/ruby_meta_data.hpp (from rev 712, trunk/flexlay/ruby/ruby_meta_data.hxx)
===================================================================
--- trunk/flexlay/ruby/ruby_meta_data.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_meta_data.hpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,44 @@
+//  $Id$
+// 
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_RUBY_META_DATA_HXX
+#define HEADER_RUBY_META_DATA_HXX
+
+#include <ClanLib/signals.h>
+#include <ClanLib/Display/color.h>
+#include "ruby.h"
+#include "meta_data.hpp"
+#include "objmap_object.hpp"
+#include "object_brush.hpp"
+
+MetaData  make_metadata(VALUE obj);
+VALUE get_ruby_object(const MetaData& data);
+
+void connect(CL_Signal_v0& sig, VALUE obj);
+void connect_v1(CL_Signal_v1<int>& sig, VALUE obj);
+void connect_v1_float(CL_Signal_v1<float>& sig, VALUE obj);
+void connect_v2(CL_Signal_v2<int, int>& sig, VALUE obj);
+void connect_v2_graceful(CL_Signal_v2<int, int>& sig, VALUE obj);
+
+void connect_v1_Color(CL_Signal_v1<CL_Color>& sig, VALUE func);
+void connect_v1_ObjMapObject(CL_Signal_v1<ObjMapObject>& sig, VALUE func);
+void connect_v2_ObjectBrush_Point(CL_Signal_v2<ObjectBrush, CL_Point>& sig, VALUE func);
+
+#endif
+
+/* EOF */

Deleted: trunk/flexlay/ruby/ruby_meta_data.hxx
===================================================================
--- trunk/flexlay/ruby/ruby_meta_data.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_meta_data.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,44 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_RUBY_META_DATA_HXX
-#define HEADER_RUBY_META_DATA_HXX
-
-#include <ClanLib/signals.h>
-#include <ClanLib/Display/color.h>
-#include "ruby.h"
-#include "meta_data.hxx"
-#include "objmap_object.hxx"
-#include "object_brush.hxx"
-
-MetaData  make_metadata(VALUE obj);
-VALUE get_ruby_object(const MetaData& data);
-
-void connect(CL_Signal_v0& sig, VALUE obj);
-void connect_v1(CL_Signal_v1<int>& sig, VALUE obj);
-void connect_v1_float(CL_Signal_v1<float>& sig, VALUE obj);
-void connect_v2(CL_Signal_v2<int, int>& sig, VALUE obj);
-void connect_v2_graceful(CL_Signal_v2<int, int>& sig, VALUE obj);
-
-void connect_v1_Color(CL_Signal_v1<CL_Color>& sig, VALUE func);
-void connect_v1_ObjMapObject(CL_Signal_v1<ObjMapObject>& sig, VALUE func);
-void connect_v2_ObjectBrush_Point(CL_Signal_v2<ObjectBrush, CL_Point>& sig, VALUE func);
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/ruby/ruby_object.cpp (from rev 712, trunk/flexlay/ruby/ruby_object.cxx)
===================================================================
--- trunk/flexlay/ruby/ruby_object.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_object.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,56 @@
+//  $Id$
+//
+//  Pingus - A free Lemmings clone
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "ruby_object.hpp"
+
+RubyObject::RubyObject(VALUE val_)
+  : val(val_)
+{
+  rb_gc_register_address(&val);
+}
+
+RubyObject::RubyObject(const RubyObject& copy)
+  : val(copy.val)
+{
+  rb_gc_register_address(&val);
+}
+
+RubyObject&
+RubyObject::operator= (const RubyObject& copy)
+{
+  if (this != &copy)
+    {
+      rb_gc_unregister_address(&val);
+      val = copy.val;
+      rb_gc_register_address(&val);
+    }
+  return *this;
+}
+
+RubyObject::~RubyObject()
+{
+  rb_gc_unregister_address(&val);
+}
+
+VALUE
+RubyObject::ptr() 
+{
+  return val; 
+}
+
+/* EOF */

Deleted: trunk/flexlay/ruby/ruby_object.cxx
===================================================================
--- trunk/flexlay/ruby/ruby_object.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_object.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,56 +0,0 @@
-//  $Id$
-//
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "ruby_object.hxx"
-
-RubyObject::RubyObject(VALUE val_)
-  : val(val_)
-{
-  rb_gc_register_address(&val);
-}
-
-RubyObject::RubyObject(const RubyObject& copy)
-  : val(copy.val)
-{
-  rb_gc_register_address(&val);
-}
-
-RubyObject&
-RubyObject::operator= (const RubyObject& copy)
-{
-  if (this != &copy)
-    {
-      rb_gc_unregister_address(&val);
-      val = copy.val;
-      rb_gc_register_address(&val);
-    }
-  return *this;
-}
-
-RubyObject::~RubyObject()
-{
-  rb_gc_unregister_address(&val);
-}
-
-VALUE
-RubyObject::ptr() 
-{
-  return val; 
-}
-
-/* EOF */

Copied: trunk/flexlay/ruby/ruby_object.hpp (from rev 712, trunk/flexlay/ruby/ruby_object.hxx)

Deleted: trunk/flexlay/ruby/ruby_object.hxx
===================================================================
--- trunk/flexlay/ruby/ruby_object.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_object.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,41 +0,0 @@
-//  $Id$
-// 
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_RUBY_OBJECT_HXX
-#define HEADER_RUBY_OBJECT_HXX
-
-#include "ruby.h"
-
-/** */
-class RubyObject
-{
-private:
-  VALUE val;
-
-public:
-  RubyObject(VALUE val_);
-  RubyObject(const RubyObject&);
-  RubyObject& operator= (const RubyObject&);
-  ~RubyObject();
-  
-  VALUE ptr();
-};
-
-#endif
-
-/* EOF */

Copied: trunk/flexlay/ruby/ruby_sexpr_parser.cpp (from rev 712, trunk/flexlay/ruby/ruby_sexpr_parser.cxx)
===================================================================
--- trunk/flexlay/ruby/ruby_sexpr_parser.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_sexpr_parser.cpp	2009-11-22 03:02:03 UTC (rev 713)
@@ -0,0 +1,82 @@
+//  $Id$
+//
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "lispreader.hpp"
+#include "ruby_sexpr_parser.hpp"
+
+VALUE
+build_py_sexpr(lisp_object_t* cur)
+{
+  if (lisp_cons_p(cur))
+    {
+      VALUE lst = rb_ary_new();
+  
+      while (cur)
+        {
+          rb_ary_push(lst, build_py_sexpr(lisp_car(cur)));
+          cur = lisp_cdr(cur);
+        }
+      
+      return lst;
+    }
+  else if (lisp_string_p(cur))
+    {
+      return rb_str_new2(lisp_string(cur));
+    }
+  else if (lisp_symbol_p(cur))
+    {
+      return ID2SYM(rb_intern(lisp_symbol(cur)));
+    }
+  else if (lisp_integer_p(cur))
+    {
+      return INT2NUM(lisp_integer(cur));
+    }
+  else if (lisp_real_p(cur))
+    {
+      return rb_float_new(lisp_real(cur));
+    }
+  else if (lisp_boolean_p(cur))
+    {
+      if (lisp_boolean(cur))
+        return Qtrue;
+      else
+        return Qfalse;
+    }
+  else
+    {
+      return Qnil;
+    }
+}
+
+VALUE sexpr_read_from_file(const char* filename)
+{
+  lisp_object_t* cur = lisp_read_from_file(filename);
+
+  if (cur)
+    {
+      VALUE obj = build_py_sexpr(cur);
+      lisp_free(cur);
+      return obj;
+    }
+  else
+    {
+      return Qnil;
+    }
+}
+
+/* EOF */

Deleted: trunk/flexlay/ruby/ruby_sexpr_parser.cxx
===================================================================
--- trunk/flexlay/ruby/ruby_sexpr_parser.cxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_sexpr_parser.cxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,82 +0,0 @@
-//  $Id$
-//
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "lispreader.hxx"
-#include "ruby_sexpr_parser.hxx"
-
-VALUE
-build_py_sexpr(lisp_object_t* cur)
-{
-  if (lisp_cons_p(cur))
-    {
-      VALUE lst = rb_ary_new();
-  
-      while (cur)
-        {
-          rb_ary_push(lst, build_py_sexpr(lisp_car(cur)));
-          cur = lisp_cdr(cur);
-        }
-      
-      return lst;
-    }
-  else if (lisp_string_p(cur))
-    {
-      return rb_str_new2(lisp_string(cur));
-    }
-  else if (lisp_symbol_p(cur))
-    {
-      return ID2SYM(rb_intern(lisp_symbol(cur)));
-    }
-  else if (lisp_integer_p(cur))
-    {
-      return INT2NUM(lisp_integer(cur));
-    }
-  else if (lisp_real_p(cur))
-    {
-      return rb_float_new(lisp_real(cur));
-    }
-  else if (lisp_boolean_p(cur))
-    {
-      if (lisp_boolean(cur))
-        return Qtrue;
-      else
-        return Qfalse;
-    }
-  else
-    {
-      return Qnil;
-    }
-}
-
-VALUE sexpr_read_from_file(const char* filename)
-{
-  lisp_object_t* cur = lisp_read_from_file(filename);
-
-  if (cur)
-    {
-      VALUE obj = build_py_sexpr(cur);
-      lisp_free(cur);
-      return obj;
-    }
-  else
-    {
-      return Qnil;
-    }
-}
-
-/* EOF */

Copied: trunk/flexlay/ruby/ruby_sexpr_parser.hpp (from rev 712, trunk/flexlay/ruby/ruby_sexpr_parser.hxx)

Deleted: trunk/flexlay/ruby/ruby_sexpr_parser.hxx
===================================================================
--- trunk/flexlay/ruby/ruby_sexpr_parser.hxx	2009-08-01 18:25:52 UTC (rev 712)
+++ trunk/flexlay/ruby/ruby_sexpr_parser.hxx	2009-11-22 03:02:03 UTC (rev 713)
@@ -1,28 +0,0 @@
-//  $Id$
-// 
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_RUBY_SEXPR_PARSER_HXX
-#define HEADER_RUBY_SEXPR_PARSER_HXX
-
-#include "ruby.h"
-
-VALUE sexpr_read_from_file(const char* filename);
-
-#endif
-
-/* EOF */



From grumbel at mail.berlios.de  Sun Nov 22 15:40:21 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 22 Nov 2009 15:40:21 +0100
Subject: [Flexlay-commit] r728 - in trunk/flexlay/lib: . gui tools
Message-ID: <200911221440.nAMEeL3h008979@sheep.berlios.de>

Author: grumbel
Date: 2009-11-22 15:40:18 +0100 (Sun, 22 Nov 2009)
New Revision: 728

Added:
   trunk/flexlay/lib/gui/
   trunk/flexlay/lib/gui/colorpicker.cpp
   trunk/flexlay/lib/gui/colorpicker.hpp
   trunk/flexlay/lib/gui/console.cpp
   trunk/flexlay/lib/gui/console.hpp
   trunk/flexlay/lib/gui/directory_view.cpp
   trunk/flexlay/lib/gui/directory_view.hpp
   trunk/flexlay/lib/gui/editor_map_component.cpp
   trunk/flexlay/lib/gui/editor_map_component.hpp
   trunk/flexlay/lib/gui/icon.cpp
   trunk/flexlay/lib/gui/icon.hpp
   trunk/flexlay/lib/gui/menubar.cpp
   trunk/flexlay/lib/gui/menubar.hpp
   trunk/flexlay/lib/gui/minimap.cpp
   trunk/flexlay/lib/gui/minimap.hpp
   trunk/flexlay/lib/gui/object_selector.cpp
   trunk/flexlay/lib/gui/object_selector.hpp
   trunk/flexlay/lib/gui/panel.cpp
   trunk/flexlay/lib/gui/panel.hpp
   trunk/flexlay/lib/gui/scrollbar.cpp
   trunk/flexlay/lib/gui/scrollbar.hpp
   trunk/flexlay/lib/gui/slider.cpp
   trunk/flexlay/lib/gui/slider.hpp
   trunk/flexlay/lib/gui/tile_editor.cpp
   trunk/flexlay/lib/gui/tile_editor.hpp
   trunk/flexlay/lib/gui/tile_selection.cpp
   trunk/flexlay/lib/gui/tile_selection.hpp
   trunk/flexlay/lib/gui/titlebar.cpp
   trunk/flexlay/lib/gui/titlebar.hpp
   trunk/flexlay/lib/gui/viewport.cpp
   trunk/flexlay/lib/gui/viewport.hpp
   trunk/flexlay/lib/gui/window.cpp
   trunk/flexlay/lib/gui/window.hpp
Removed:
   trunk/flexlay/lib/colorpicker.cpp
   trunk/flexlay/lib/colorpicker.hpp
   trunk/flexlay/lib/console.cpp
   trunk/flexlay/lib/console.hpp
   trunk/flexlay/lib/directory_view.cpp
   trunk/flexlay/lib/directory_view.hpp
   trunk/flexlay/lib/editor_map_component.cpp
   trunk/flexlay/lib/editor_map_component.hpp
   trunk/flexlay/lib/icon.cpp
   trunk/flexlay/lib/icon.hpp
   trunk/flexlay/lib/menubar.cpp
   trunk/flexlay/lib/menubar.hpp
   trunk/flexlay/lib/minimap.cpp
   trunk/flexlay/lib/minimap.hpp
   trunk/flexlay/lib/object_selector.cpp
   trunk/flexlay/lib/object_selector.hpp
   trunk/flexlay/lib/panel.cpp
   trunk/flexlay/lib/panel.hpp
   trunk/flexlay/lib/scrollbar.cpp
   trunk/flexlay/lib/scrollbar.hpp
   trunk/flexlay/lib/slider.cpp
   trunk/flexlay/lib/slider.hpp
   trunk/flexlay/lib/tile_editor.cpp
   trunk/flexlay/lib/tile_editor.hpp
   trunk/flexlay/lib/tile_selection.cpp
   trunk/flexlay/lib/tile_selection.hpp
   trunk/flexlay/lib/titlebar.cpp
   trunk/flexlay/lib/titlebar.hpp
   trunk/flexlay/lib/viewport.cpp
   trunk/flexlay/lib/viewport.hpp
   trunk/flexlay/lib/window.cpp
   trunk/flexlay/lib/window.hpp
Modified:
   trunk/flexlay/lib/bitmap_layer.cpp
   trunk/flexlay/lib/flexlay_wrap.i
   trunk/flexlay/lib/layer.hpp
   trunk/flexlay/lib/object_layer.cpp
   trunk/flexlay/lib/onion_skin_layer.cpp
   trunk/flexlay/lib/sketch_layer.cpp
   trunk/flexlay/lib/sketch_layer.hpp
   trunk/flexlay/lib/tilemap_layer.cpp
   trunk/flexlay/lib/tools/layer_move_tool.cpp
   trunk/flexlay/lib/tools/objmap_select_tool.cpp
   trunk/flexlay/lib/tools/sketch_stroke_tool.cpp
   trunk/flexlay/lib/tools/sketch_stroke_tool.hpp
   trunk/flexlay/lib/tools/tilemap_paint_tool.cpp
   trunk/flexlay/lib/tools/tilemap_select_tool.cpp
   trunk/flexlay/lib/tools/tilemap_select_tool.hpp
   trunk/flexlay/lib/tools/workspace_move_tool.cpp
   trunk/flexlay/lib/tools/zoom2_tool.cpp
   trunk/flexlay/lib/tools/zoom_tool.cpp
   trunk/flexlay/lib/workspace.cpp
Log:
Moved CL_Component classes to gui/

Modified: trunk/flexlay/lib/bitmap_layer.cpp
===================================================================
--- trunk/flexlay/lib/bitmap_layer.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/bitmap_layer.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -26,8 +26,8 @@
 #include <ClanLib/Display/blend_func.h>
 #include <ClanLib/Display/graphic_context.h>
 #include <ClanLib/Display/display_window.h>
+
 #include "flexlay.hpp"
-#include "editor_map_component.hpp"
 #include "layer_impl.hpp"
 #include "bitmap_layer.hpp"
 #include "objmap_object_impl.hpp"

Deleted: trunk/flexlay/lib/colorpicker.cpp
===================================================================
--- trunk/flexlay/lib/colorpicker.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/colorpicker.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,401 +0,0 @@
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <ClanLib/Display/keys.h>
-#include <ClanLib/GUI/component.h>
-#include "colorpicker.hpp"
-#include "math.hpp"
-
-class ColorPickerHue : public CL_Component
-{
-public:
-  std::vector<CL_Slot> slots;
-  typedef std::vector<CL_Color> Colors;
-  Colors  colors;
-  bool pressed;
-  CL_Signal_v1<CL_Color> on_color_change;
-  
-  ColorPickerHue(const CL_Rect& rect, CL_Component* parent) 
-    : CL_Component(rect, parent),
-      pressed(false)
-  {
-    colors.push_back(CL_Color(255,   0,   0));
-    colors.push_back(CL_Color(255,   0, 255));
-    colors.push_back(CL_Color(  0,   0, 255));
-    colors.push_back(CL_Color(  0, 255, 255));
-    colors.push_back(CL_Color(  0, 255,   0));
-    colors.push_back(CL_Color(255, 255,   0));
-    colors.push_back(CL_Color(255,   0,   0));
-
-    slots.push_back(sig_paint().connect(this, &ColorPickerHue::draw));
-
-    slots.push_back(sig_mouse_down().connect(this, &ColorPickerHue::on_mouse_down));
-    slots.push_back(sig_mouse_up().connect(this, &ColorPickerHue::on_mouse_up));
-    slots.push_back(sig_mouse_move().connect(this, &ColorPickerHue::on_mouse_move));
-  }
-
-  void update_pointer(const CL_InputEvent& event)
-  {
-    CL_Color new_color; 
-
-    if (event.mouse_pos.y >= get_height() || event.mouse_pos.y < 0)
-    {
-      new_color = colors[0];
-    }
-    else
-    {
-      float factor  = (float(event.mouse_pos.y) / get_height()) * (colors.size()-1);
-      int   prevcol = int(factor);
-      int   nextcol = prevcol+1;
-
-      float val  = factor - prevcol;
-      float ival = 1.0f - val;
-
-
-      if (val >= 0 && val < 1.0f)
-      {
-        new_color = CL_Color(int(val * colors[nextcol].get_red()   + ival * colors[prevcol].get_red()),
-                             int(val * colors[nextcol].get_green() + ival * colors[prevcol].get_green()),
-                             int(val * colors[nextcol].get_blue()  + ival * colors[prevcol].get_blue()),
-                             int(val * colors[nextcol].get_alpha() + ival * colors[prevcol].get_alpha()));
-      }
-      else
-      {
-        std::cout << "Out of range" << std::endl;
-        new_color = colors[0];
-      }
-    }
-    on_color_change(new_color);
-
-    /*
-      std::cout << new_color.get_red() << ", "
-      << new_color.get_green() << ", "
-      << new_color.get_blue() << ", "
-      << new_color.get_alpha()
-      << std::endl;*/
-  }
-  
-  void on_mouse_up(const CL_InputEvent& event)
-  {
-    if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed = false;
-      release_mouse();
-      update_pointer(event);
-    }
-  }
-
-  void on_mouse_down(const CL_InputEvent& event)
-  {
-    if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed = true;
-      capture_mouse();
-      update_pointer(event);
-    }  
-  }
-  
-  void on_mouse_move(const CL_InputEvent& event)
-  {
-    if (pressed)
-    {
-      update_pointer(event);
-    }
-  }
-
-  void draw()
-  {
-    CL_Display::push_modelview();
-    CL_Display::add_translate(get_screen_x(), get_screen_y());
-    
-    int psize = get_height()/6;
-    
-    for(Colors::size_type i = 0; i < colors.size()-1; ++i)
-    {
-      CL_Display::fill_rect(CL_Rect(CL_Point(0, i*psize),
-                                    CL_Size(get_width(), psize)),
-                            CL_Gradient(colors[i],
-                                        colors[i],
-                                        colors[i+1],
-                                        colors[i+1]));
-    }
-
-    CL_Display::pop_modelview();    
-  }
-};
-
-class ColorPickerAlpha : public CL_Component
-{
-public:
-  std::vector<CL_Slot> slots;
-  bool pressed;
-  CL_Signal_v1<float> on_color_change;
-  float alpha;
-
-  ColorPickerAlpha(const CL_Rect& rect, CL_Component* parent) 
-    : CL_Component(rect, parent),
-      pressed(false),
-      alpha(0.5f)
-  {
-    slots.push_back(sig_paint().connect(this, &ColorPickerAlpha::draw));
-
-    slots.push_back(sig_mouse_down().connect(this, &ColorPickerAlpha::on_mouse_down));
-    slots.push_back(sig_mouse_up().connect(this, &ColorPickerAlpha::on_mouse_up));
-    slots.push_back(sig_mouse_move().connect(this, &ColorPickerAlpha::on_mouse_move));
-  }
-
-  void set_alpha(float alpha_)
-  {
-    alpha = alpha_;
-    on_color_change(alpha);
-  }  
-
-  void draw()
-  {
-    CL_Display::push_modelview();
-    CL_Display::add_translate(get_screen_x(), get_screen_y());    
-   
-    CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
-                                  CL_Size(get_width(), get_height())),
-                          CL_Gradient(CL_Color(0, 0, 0),
-                                      CL_Color(255, 255, 255),
-                                      CL_Color(0, 0, 0),
-                                      CL_Color(255, 255, 255)));
-
-    CL_Display::pop_modelview();
-  }
-
-  void update_pointer(const CL_InputEvent& event)
-  {
-    alpha = 1.0f - (Math::mid(0.0f, float(event.mouse_pos.x) / get_width(), 1.0f));
-    on_color_change(alpha);
-  }
-
-  void on_mouse_up(const CL_InputEvent& event)
-  {
-    if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed = false;
-      release_mouse();
-      update_pointer(event);
-    }
-  }
-
-  void on_mouse_down(const CL_InputEvent& event)
-  {
-    if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed = true;
-      capture_mouse();
-      update_pointer(event);
-    }
-  }
-
-  void on_mouse_move(const CL_InputEvent& event)
-  {
-    if (pressed)
-    {
-      update_pointer(event);    
-    }
-  }
-};
-
-class ColorPickerBrightness : public CL_Component
-{
-public:
-  std::vector<CL_Slot> slots;
-  CL_Color color;
-  bool pressed;
-  CL_Signal_v1<CL_Color> on_color_change;
-  float factor_x;
-  float factor_y;
-  ColorPickerBrightness(const CL_Rect& rect, CL_Component* parent) 
-    : CL_Component(rect, parent),
-      pressed(false),
-      factor_x(1.0f),
-      factor_y(1.0f)
-  {
-    color = CL_Color(255, 0, 0);
-    slots.push_back(sig_paint().connect(this, &ColorPickerBrightness::draw));
-
-    slots.push_back(sig_mouse_down().connect(this, &ColorPickerBrightness::on_mouse_down));
-    slots.push_back(sig_mouse_up().connect(this, &ColorPickerBrightness::on_mouse_up));
-    slots.push_back(sig_mouse_move().connect(this, &ColorPickerBrightness::on_mouse_move));
-  }
-
-  void draw()
-  {
-    CL_Display::push_modelview();
-    CL_Display::add_translate(get_screen_x(), get_screen_y());
-
-    CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
-                                  CL_Size(get_width(), get_height())),
-                          CL_Gradient(CL_Color(0, 0, 0),
-                                      color,
-                                      CL_Color(0, 0, 0),
-                                      CL_Color(255, 255, 255)));
-
-    CL_Display::draw_line(factor_x * get_width(),
-                          0,
-                          factor_x * get_width(),
-                          get_height(),
-                          CL_Color(255, 255, 255));
-
-    CL_Display::draw_line(0,
-                          factor_y * get_height(),
-                          get_width(),
-                          factor_y * get_height(),
-                          CL_Color(255, 255, 255));
-
-    CL_Display::pop_modelview();
-  }
-
-  void set_color(CL_Color color_) {
-    color = color_;
-    update_color();
-  }
-
-  void update_color()
-  {
-    CL_Color new_color(Math::mid(0, int(factor_x * color.get_red()   * (1.0f - factor_y) + factor_x * 255 * (factor_y)), 255),
-                       Math::mid(0, int(factor_x * color.get_green() * (1.0f - factor_y) + factor_x * 255 * (factor_y)), 255),   
-                       Math::mid(0, int(factor_x * color.get_blue()  * (1.0f - factor_y) + factor_x * 255 * (factor_y)), 255),
-                       color.get_alpha());
-    on_color_change(new_color);
-    /*
-      std::cout << new_color.get_red() << ", "
-      << new_color.get_green() << ", "
-      << new_color.get_blue() << ", "
-      << new_color.get_alpha()
-      << std::endl;
-    */
-  }
-
-  void update_pointer(const CL_InputEvent& event)
-  {
-    factor_x = Math::mid(0.0f, float(event.mouse_pos.x)/get_width(), 1.0f);
-    factor_y = Math::mid(0.0f, float(event.mouse_pos.y)/get_height(), 1.0f);
-
-    update_color();
-  }
-
-  void on_mouse_up(const CL_InputEvent& event)
-  {
-    if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed = false;
-      release_mouse();
-      update_pointer(event);
-    }    
-  }
-
-  void on_mouse_down(const CL_InputEvent& event)
-  {
-    if (event.id == CL_MOUSE_LEFT)
-    {
-      pressed = true;
-      capture_mouse();
-      update_pointer(event);
-    }
-  }
-
-  void on_mouse_move(const CL_InputEvent& event)
-  {
-    if (pressed)
-    {
-      update_pointer(event);
-    }
-  }
-};
-
-ColorPicker::ColorPicker(const CL_Rect& rect, CL_Component* parent)
-  : CL_Component(rect, parent)
-{
-  float pwidth  = rect.get_width()/11.0;
-  float pheight = rect.get_height()/11.0;
-
-  brightness = new ColorPickerBrightness(CL_Rect(CL_Point(0, 0),
-                                                 CL_Size(int(pwidth*10), int(pheight*10))), 
-                                         this);
-  
-  hue        = new ColorPickerHue(CL_Rect(CL_Point(int(pwidth*10), 0),
-                                          CL_Size(int(pwidth*1), int(pheight*10))),
-                                  this);
-
-  alpha      = new ColorPickerAlpha(CL_Rect(CL_Point(0, int(pheight*10)),
-                                            CL_Size(int(pwidth*10), int(pheight*1))),
-                                    this);
-
-  slots.push_back(hue->on_color_change.connect(brightness, &ColorPickerBrightness::set_color));
-  slots.push_back(brightness->on_color_change.connect(this, &ColorPicker::update_brightness_color));
-  slots.push_back(alpha->on_color_change.connect(this, &ColorPicker::update_alpha_color));
-  slots.push_back(sig_paint().connect(this, &ColorPicker::draw));
-
-  brightness->set_color(CL_Color(255, 0, 0));
-  alpha->set_alpha(0.5f);
-}
-
-void
-ColorPicker::update_alpha_color(float alpha)
-{
-  color.set_alpha(int(255 * alpha));
-  on_color_change(color);  
-}
-
-void
-ColorPicker::update_brightness_color(CL_Color color_)
-{
-  color.set_red(color_.get_red());
-  color.set_green(color_.get_green());
-  color.set_blue(color_.get_blue());
-  on_color_change(color);
-}
-
-void
-ColorPicker::draw()
-{
-  CL_Display::push_modelview();
-  CL_Display::add_translate(get_screen_x(), get_screen_y());
-  
-  float pwidth  = get_width()/11.0;
-  float pheight = get_height()/11.0;
-  CL_Display::fill_rect(CL_Rect(CL_Point(int(pwidth*10), int(pheight*10)),
-                                CL_Size(int(pwidth), int(pheight))),
-                        color);
-
-  CL_Display::pop_modelview();
-}
-
-CL_Signal_v1<CL_Color>&
-ColorPicker::sig_color_change()
-{
-  return on_color_change;
-}
-
-CL_Color
-ColorPicker::get_color()
-{
-  return color;
-}
-
-void
-ColorPicker::set_color(const CL_Color& color_)
-{
-  color = color_;
-}
-
-/* EOF */

Deleted: trunk/flexlay/lib/colorpicker.hpp
===================================================================
--- trunk/flexlay/lib/colorpicker.hpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/colorpicker.hpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,55 +0,0 @@
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_FLEXLAY_COLORPICKER_HPP
-#define HEADER_FLEXLAY_COLORPICKER_HPP
-
-#include <ClanLib/Display/display.h>
-
-class ColorPickerHue;
-class ColorPickerAlpha;
-class ColorPickerBrightness;
-
-/** */
-class ColorPicker : public CL_Component
-{
-protected:
-  ~ColorPicker() {}
-private:
-  CL_Signal_v1<CL_Color> on_color_change;
-  std::vector<CL_Slot> slots;
-  CL_Color color;
-
-  ColorPickerHue*     hue;
-  ColorPickerBrightness* brightness;
-  ColorPickerAlpha*      alpha;
-
-  void update_brightness_color(CL_Color color);
-  void update_alpha_color(float alpha);
-public:
-  ColorPicker(const CL_Rect& rect, CL_Component* parent);
-  
-  void draw();
-
-  CL_Signal_v1<CL_Color>& sig_color_change();
-
-  CL_Color get_color();
-  void set_color(const CL_Color& color);
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/flexlay/lib/console.cpp
===================================================================
--- trunk/flexlay/lib/console.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/console.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,124 +0,0 @@
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include "fonts.hpp"
-#include "field.hpp"
-#include "console.hpp"
-
-class ConsoleImpl
-{
-public:
-  std::vector<CL_Slot> slots;
-
-  CL_Size size;
-
-  /** Complete log of everything that got written to the console */
-  std::string full_buffer;
-
-  /** Buffer of the stuff currently visible on the screen */
-  Field<char> screen;
-
-  CL_Point cursor_pos;
-
-  CL_Font font;
-
-  ConsoleImpl(int w, int h);
-  void putchar(char c);
-  void draw();
-};
-
-ConsoleImpl::ConsoleImpl(int w, int h)
-  : size(w, h),
-    screen(w, h),
-    cursor_pos(0, 0)
-{
-}
-
-void
-ConsoleImpl::draw()
-{
-  //std::cout << "ConsoleImpl::draw()" << std::endl;
-
-  int font_w = font.get_width("W");
-  int font_h = font.get_height();
-
-  for(int y = 0; y < size.height; ++y)
-    for(int x = 0; x < size.width; ++x)
-    {
-      font.draw_character(x * font_w, y * font_h, screen.at(x, y));
-    }
-}
-
-Console::Console(/*const CL_Font& font,*/ const CL_Rect& rect, CL_Component* parent)
-  : CL_Component(rect, parent),
-    impl(new ConsoleImpl(40, 24))
-{
-  impl->font = Fonts::verdana11_yellow;
-  impl->slots.push_back(sig_paint().connect(impl.get(), &ConsoleImpl::draw));
-}
-
-Console::~Console()
-{
-  
-}
-
-void
-Console::clearscr()
-{
-  for(int y = 0; y < impl->size.height; ++y)
-    for(int x = 0; x < impl->size.width; ++x)
-      impl->screen.at(x, y) = 0;
-}
-
-void
-ConsoleImpl::putchar(char c)
-{
-  full_buffer += c; 
-
-  if (c == '\n')
-  {
-    cursor_pos.x = 0;
-    cursor_pos.y += 1;
-  }
-  else
-  {
-    screen.at(cursor_pos.x, cursor_pos.y) = c;
-
-    cursor_pos.x += 1;
-
-    if (cursor_pos.x >= size.width)
-      cursor_pos.x = 0;
-  }
-
-  // Move all content one line up
-  if (cursor_pos.y >= size.height)
-    screen.resize(size.width, size.height, 0, -1);
-}
-
-void
-Console::write(const std::string& str)
-{
-  std::cout << str << std::flush;
-
-  for(std::string::const_iterator i = str.begin(); i != str.end(); ++i)
-  {
-    if (*i != 0)
-      impl->putchar(*i);
-  }
-}
-
-/* EOF */

Deleted: trunk/flexlay/lib/console.hpp
===================================================================
--- trunk/flexlay/lib/console.hpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/console.hpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,44 +0,0 @@
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_FLEXLAY_CONSOLE_HPP
-#define HEADER_FLEXLAY_CONSOLE_HPP
-
-#include <ClanLib/GUI/component.h>
-#include <boost/shared_ptr.hpp>
-
-class CL_Font;
-class CL_Size;
-class ConsoleImpl;
-
-/** */
-class Console : public CL_Component
-{
-protected:
-  virtual ~Console();
-public:
-  Console(/*const CL_Font& font, */const CL_Rect& rect, CL_Component* parent);
-
-  /** Write something to the console */
-  void write(const std::string& );
-  void clearscr();
-private:
-  boost::shared_ptr<ConsoleImpl> impl;
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/flexlay/lib/directory_view.cpp
===================================================================
--- trunk/flexlay/lib/directory_view.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/directory_view.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,204 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <ClanLib/Core/IOData/directory_scanner.h>
-#include <ClanLib/Display/display.h>
-#include "fonts.hpp"
-#include "directory_view.hpp"
-
-class DirectoryViewEntry
-{
-public:
-  std::string name;
-  bool directory;
-  bool hidden;
-};
-
-struct DirectoryViewSorter
-{
-  bool operator()(const DirectoryViewEntry& lhs, const DirectoryViewEntry& rhs)
-  {
-    if (lhs.directory > rhs.directory)
-      return true;
-    else if (lhs.directory < rhs.directory)
-      return false;
-    else
-      return lhs.name < rhs.name;
-  }
-};
-
-class DirectoryViewImpl
-{
-public:
-  DirectoryView* parent;
-
-  std::vector<CL_Slot> slots;
-
-  std::string path;
-  CL_Signal_v1<std::string> sig_on_click;
-  typedef std::vector<DirectoryViewEntry> Items;
-  Items items;
-  int current_item;
-  int column_width;
-  int num_columns;
-
-  void update_items();
-  void draw();
-  int get_item(const CL_Point& pos);
-  void on_mouse_move(const CL_InputEvent& event);
-  void on_mouse_down(const CL_InputEvent& event);
-};
-
-DirectoryView::DirectoryView(const CL_Rect& rect, CL_Component* parent)
-  : CL_Component(rect, parent),
-    impl(new DirectoryViewImpl())
-{ 
-  impl->parent = this;
-
-  //  impl->slots.push_back(sig_mouse_down().connect(impl.get(), &DirectoryViewImpl::draw));
-  impl->slots.push_back(sig_paint().connect(impl.get(), &DirectoryViewImpl::draw));
-  impl->slots.push_back(sig_mouse_move().connect(impl.get(), &DirectoryViewImpl::on_mouse_move));
-  impl->slots.push_back(sig_mouse_down().connect(impl.get(), &DirectoryViewImpl::on_mouse_down));
-
-  impl->current_item = -1;
-}
-
-DirectoryView::~DirectoryView()
-{
-}
-
-void
-DirectoryView::set_directory(const std::string& path_)
-{
-  impl->path = path_;
-  impl->update_items();
-}
-
-CL_Signal_v1<std::string>&
-DirectoryView::sig_on_click()
-{
-  return impl->sig_on_click;
-}
-
-void 
-DirectoryViewImpl::draw()
-{
-  CL_Font font = Fonts::verdana11; 
-
-  int horizontal_spacing = 10;
-  int vertical_spacing   = 5;
-  int x_pos = 0;
-  int y_pos = 0;
-
-  CL_Display::clear(CL_Color(255, 255, 0));
-
-  int j = 0;
-  for(Items::iterator i = items.begin(); i != items.begin()+50 && i != items.end(); ++i)
-  {
-    if (current_item && current_item < int(items.size()) && j == current_item)
-    {
-      CL_Rect rect = font.bounding_rect(x_pos * (column_width + horizontal_spacing) + 1, 
-                                        y_pos * (font.get_height() + vertical_spacing) + 1,
-                                        i->name);
-      CL_Display::fill_rect(CL_Rect(rect.left-5, rect.top-3,
-                                    rect.left+5+column_width, rect.bottom+3),
-                            CL_Color(250, 200, 0));
-    }
-
-    // draw item
-    if (!i->directory)
-    {
-      font.draw(x_pos * (column_width + horizontal_spacing), 
-                y_pos * (font.get_height() + vertical_spacing),
-                i->name);
-    }
-    else
-    {
-      font.draw(x_pos * (column_width + horizontal_spacing), 
-                y_pos * (font.get_height() + vertical_spacing),
-                "[" + i->name + "]");
-    }
-
-    x_pos += 1;
-    if (x_pos >= num_columns)
-    {
-      x_pos = 0;
-      y_pos += 1;
-    }
-    ++j;
-  }
-}
-
-int
-DirectoryViewImpl::get_item(const CL_Point& pos)
-{
-  CL_Font font = Fonts::verdana11; 
-
-  int horizontal_spacing = 10;
-  int vertical_spacing   = 5;
-
-  return (pos.x / (column_width + horizontal_spacing))
-    + num_columns * (pos.y / (font.get_height() + vertical_spacing));    
-}
-
-void 
-DirectoryViewImpl::on_mouse_down(const CL_InputEvent& event)
-{
-  current_item = get_item(event.mouse_pos);
-  if (current_item >= 0 && current_item < int(items.size()))
-  {
-    if (items[current_item].directory)
-      parent->set_directory(path + "/" + items[current_item].name);
-  }
-}
-
-void 
-DirectoryViewImpl::on_mouse_move(const CL_InputEvent& event)
-{
-  current_item = get_item(event.mouse_pos);
-}
-
-void
-DirectoryViewImpl::update_items()
-{
-  items.clear();
-  CL_DirectoryScanner scanner;
-
-  scanner.scan(path);
-  while(scanner.next())
-  {
-    DirectoryViewEntry entry;
-    entry.name = scanner.get_name();
-    entry.hidden = (scanner.get_name()[0] == '.');
-    entry.directory = scanner.is_directory();
-    items.push_back(entry);
-  }
-
-  std::sort(items.begin(), items.end(), DirectoryViewSorter());
-
-  CL_Font font = Fonts::verdana11; 
-
-  column_width = 60; // min_colum_width
-  for(Items::iterator i = items.begin(); i != items.end(); ++i)
-  {
-    CL_Rect rect = font.bounding_rect(0, 0, i->name + "[]");
-    column_width = std::max(column_width, rect.get_width());
-  }
-
-  num_columns = parent->get_width()/column_width;
-}
-
-/* EOF */

Deleted: trunk/flexlay/lib/directory_view.hpp
===================================================================
--- trunk/flexlay/lib/directory_view.hpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/directory_view.hpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,46 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_FLEXLAY_DIRECTORY_VIEW_HPP
-#define HEADER_FLEXLAY_DIRECTORY_VIEW_HPP
-
-#include <ClanLib/GUI/component.h>
-#include <boost/shared_ptr.hpp>
-
-class DirectoryViewImpl;
-
-/** */
-class DirectoryView : public CL_Component
-{
-private:
-protected:
-  virtual ~DirectoryView();
-public:
-  DirectoryView(const CL_Rect& rect, CL_Component* parent);
-
-  /** Set the directory which should be shown */
-  void set_directory(const std::string& path_);
-
-  /** Call the callback on click on a directory item */
-  CL_Signal_v1<std::string>& sig_on_click();
-
-private:
-  boost::shared_ptr<DirectoryViewImpl> impl;
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/flexlay/lib/editor_map_component.cpp
===================================================================
--- trunk/flexlay/lib/editor_map_component.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/editor_map_component.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,267 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <ClanLib/Display/keyboard.h>
-#include <ClanLib/Display/mouse.h>
-#include <ClanLib/Display/display.h>
-#include "editor_map.hpp"
-#include "scrollbar.hpp"
-#include "editor_map_component.hpp"
-
-EditorMapComponent* EditorMapComponent::current_ = 0; 
-
-class EditorMapComponentImpl
-{
-public:
-  EditorMapComponent* parent;
-  GraphicContextState gc_state;
-  Scrollbar* scrollbar_h;
-  Scrollbar* scrollbar_v;
-  CL_SlotContainer slots;
-  Workspace workspace;
-  CL_Signal_v2<int, int> key_bindings[256];
-
-  EditorMapComponentImpl()
-    :workspace(true) 
-  {}
-
-  void draw();
-  void mouse_up  (const CL_InputEvent& event);
-  void mouse_down(const CL_InputEvent& event);
-  void mouse_move(const CL_InputEvent& event);
-  void on_key_up(const CL_InputEvent& event);
-  void on_key_down(const CL_InputEvent& event);
-  void on_resize(int old_w, int old_h);
-};
-
-EditorMapComponent::EditorMapComponent(const CL_Rect& rect, CL_Component* parent)
-  : CL_Component(rect, parent),
-    impl(new EditorMapComponentImpl())
-{
-  impl->parent = this;
-  impl->gc_state  = GraphicContextState(rect.get_width(), rect.get_height());
-
-  current_ = this;
-
-  impl->scrollbar_v = new Scrollbar(CL_Rect(CL_Point(rect.get_width() - 14, 2) + CL_Point(rect.left, rect.top), 
-                                            CL_Size(12, rect.get_height() - 4 - 14)),
-                                    Scrollbar::VERTICAL,
-                                    parent);
-
-  impl->scrollbar_h = new Scrollbar(CL_Rect(CL_Point(2, rect.get_height() - 14) + CL_Point(rect.left, rect.top), 
-                                            CL_Size(rect.get_width() - 4 - 14, 12)),
-                                    Scrollbar::HORIZONTAL,
-                                    parent);
-
-  impl->slots.connect(impl->scrollbar_h->sig_scrollbar_move(), this, &EditorMapComponent::move_to_x);
-  impl->slots.connect(impl->scrollbar_v->sig_scrollbar_move(), this, &EditorMapComponent::move_to_y);
-
-  impl->slots.connect(sig_paint(),      impl.get(), &EditorMapComponentImpl::draw);
-  impl->slots.connect(sig_mouse_up(),   impl.get(), &EditorMapComponentImpl::mouse_up);
-  impl->slots.connect(sig_mouse_down(), impl.get(), &EditorMapComponentImpl::mouse_down);
-  impl->slots.connect(sig_mouse_move(), impl.get(), &EditorMapComponentImpl::mouse_move);
-  impl->slots.connect(sig_key_down(),   impl.get(), &EditorMapComponentImpl::on_key_down);
-  impl->slots.connect(sig_key_up(),     impl.get(), &EditorMapComponentImpl::on_key_up);
-  impl->slots.connect(sig_resize(),     impl.get(), &EditorMapComponentImpl::on_resize);
-}
-
-EditorMapComponent::~EditorMapComponent()
-{
-  std::cout << "~EditorMapComponent()" << std::endl;
-}
-
-Workspace
-EditorMapComponent::get_workspace() const
-{
-  return impl->workspace;
-}
-
-void
-EditorMapComponent::set_workspace(Workspace m)
-{
-  impl->workspace = m;
-}
-
-void
-EditorMapComponentImpl::on_key_down(const CL_InputEvent& event)
-{
-  if (event.id >= 0 && event.id < 256)
-  { 
-    CL_Rect rect = parent->get_position();
-    key_bindings[event.id](CL_Mouse::get_x() - rect.left,
-                           CL_Mouse::get_y() - rect.top);
-  }
-
-  if (event.repeat_count == 0)
-  {
-    CL_Rect rect = parent->get_position();
-    CL_InputEvent ev2 = event;
-    ev2.mouse_pos = CL_Point(CL_Mouse::get_x() - rect.left,
-                             CL_Mouse::get_y() - rect.top);
-    workspace.key_down(ev2);
-  }
-}
-
-void
-EditorMapComponentImpl::on_key_up(const CL_InputEvent& event)
-{
-  CL_Rect rect = parent->get_position();
-  CL_InputEvent ev2 = event;
-  ev2.mouse_pos = CL_Point(CL_Mouse::get_x() - rect.left,
-                           CL_Mouse::get_y() - rect.top);
-  workspace.key_up(ev2);
-}
-
-void
-EditorMapComponentImpl::mouse_up(const CL_InputEvent& event)
-{
-  workspace.mouse_up(event);
-}
-
-void
-EditorMapComponentImpl::mouse_move(const CL_InputEvent& event)
-{
-  workspace.mouse_move(event);
-}
-
-void
-EditorMapComponentImpl::mouse_down(const CL_InputEvent& event)
-{
-  workspace.mouse_down(event);
-}
-  
-void
-EditorMapComponentImpl::draw ()
-{
-  if (workspace.get_map().is_null()) return;
-
-  CL_Display::push_cliprect(parent->get_screen_rect());
-
-  CL_Display::push_translate(parent->get_screen_x(), parent->get_screen_y());
-
-  // Update scrollbars (FIXME: move me to function)
-  scrollbar_v->set_range(0, workspace.get_map().get_bounding_rect().get_height());
-  scrollbar_v->set_pagesize(parent->get_height()/gc_state.get_zoom());
-  scrollbar_v->set_pos(gc_state.get_pos().y);
-
-  scrollbar_h->set_range(0, workspace.get_map().get_bounding_rect().get_width());
-  scrollbar_h->set_pagesize(parent->get_width()/gc_state.get_zoom());
-  scrollbar_h->set_pos(gc_state.get_pos().x);
-
-  gc_state.push();
-  workspace.draw();
-  gc_state.pop();
-
-  CL_Display::pop_modelview();
-  CL_Display::pop_cliprect();
-}
-
-CL_Pointf
-EditorMapComponent::screen2world(const CL_Point& pos)
-{
-  return impl->gc_state.screen2world(pos);
-}
-
-void
-EditorMapComponent::set_zoom(float z)
-{
-  impl->gc_state.set_zoom(z);
-}
-
-void
-EditorMapComponent::zoom_out(CL_Point pos)
-{
-  impl->gc_state.set_zoom(CL_Pointf(pos.x, pos.y),
-                          impl->gc_state.get_zoom()/1.25f);
-}
-
-void
-EditorMapComponent::zoom_in(CL_Point pos)
-{
-  impl->gc_state.set_zoom(CL_Pointf(pos.x, pos.y), 
-                          impl->gc_state.get_zoom()*1.25f);
-}
-
-void
-EditorMapComponent::zoom_to(CL_Rectf rect)
-{
-  impl->gc_state.zoom_to(rect);
-}
-
-CL_Rectf
-EditorMapComponent::get_clip_rect()
-{
-  return impl->gc_state.get_clip_rect();
-}
-
-void
-EditorMapComponent::move_to(int x, int y)
-{
-  impl->gc_state.set_pos(CL_Pointf(x, y));
-}
-
-void
-EditorMapComponent::move_to_x(float x)
-{
-  impl->gc_state.set_pos(CL_Pointf(x, impl->gc_state.get_pos().y));
-}
-
-void
-EditorMapComponent::move_to_y(float y)
-{
-  impl->gc_state.set_pos(CL_Pointf(impl->gc_state.get_pos().x, y));
-}
-
-void
-EditorMapComponentImpl::on_resize(int old_w, int old_h)
-{
-  CL_Rect rect = parent->get_screen_rect();
-
-  scrollbar_v->set_position(rect.get_width() - 14 + rect.left,  2 + rect.top);
-  scrollbar_v->set_size(12, rect.get_height() - 4 - 14);
-  
-  scrollbar_h->set_position(2 + rect.left, rect.get_height() - 14 + rect.top);
-  scrollbar_h->set_size(rect.get_width() - 4 - 14, 12);
-
-  gc_state.set_size(rect.get_width(), rect.get_height());
-}
-
-CL_Signal_v2<int, int>&
-EditorMapComponent::sig_on_key(const std::string& str)
-{
-  int id = CL_Keyboard::get_device().string_to_keyid(str);
-
-  //std::cout << str << " => " << id << std::endl;
-
-  if (id > 0 && id < 256)
-  {
-    return impl->key_bindings[id];
-  }
-  else
-  {
-    std::cout << "EditorMapComponent::sig_on_key: invalid key id: " << id << std::endl;
-    return impl->key_bindings[0];
-  }
-}
-
-GraphicContextState&
-EditorMapComponent::get_gc_state()
-{
-  return impl->gc_state;
-}
-
-/* EOF */

Deleted: trunk/flexlay/lib/editor_map_component.hpp
===================================================================
--- trunk/flexlay/lib/editor_map_component.hpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/editor_map_component.hpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,65 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_FLEXLAY_EDITOR_MAP_COMPONENT_HPP
-#define HEADER_FLEXLAY_EDITOR_MAP_COMPONENT_HPP
-
-#include <ClanLib/GUI/component.h>
-#include "workspace.hpp"
-
-class Scrollbar;
-class EditorMapComponentImpl;
-
-/** Object which represents a level, quirled together with the GUI
-    stuff */
-class EditorMapComponent : public CL_Component
-{
-private:
-  static EditorMapComponent* current_; 
-protected:
-  virtual ~EditorMapComponent();
-public:
-  static EditorMapComponent* current() { return current_; } 
-
-  EditorMapComponent(const CL_Rect& rect, CL_Component* parent);
- 
-  Workspace get_workspace() const;
-  void      set_workspace(Workspace m);
-
-  void  set_zoom(float z);
-  void  zoom_to(CL_Rectf rect);
-  void  zoom_out(CL_Point pos);
-  void  zoom_in (CL_Point pos);
-
-  void move_to(int x, int y);
-  void move_to_x(float x);
-  void move_to_y(float y);
-
-  CL_Signal_v2<int, int>& sig_on_key(const std::string& str);
-
-  CL_Pointf screen2world(const CL_Point& pos);
-
-  CL_Rectf get_clip_rect();
-
-  GraphicContextState& get_gc_state();
-
-private:
-  boost::shared_ptr<EditorMapComponentImpl> impl;
-};
-
-#endif
-
-/* EOF */

Modified: trunk/flexlay/lib/flexlay_wrap.i
===================================================================
--- trunk/flexlay/lib/flexlay_wrap.i	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/flexlay_wrap.i	2009-11-22 14:40:18 UTC (rev 728)
@@ -30,7 +30,7 @@
 #include "tile.hpp"
 #include "tile_brush.hpp"
 #include "meta_data.hpp"
-#include "console.hpp"
+#include "gui/console.hpp"
 #include "blitter.hpp"
 
 #include "layer.hpp"
@@ -38,24 +38,24 @@
 #include "object_layer.hpp"
 #include "onion_skin_layer.hpp"
 
-#include "minimap.hpp"
+#include "gui/minimap.hpp"
 #include "editor_map.hpp"
 #include "workspace.hpp"
 #include "tileset.hpp"
-#include "editor_map_component.hpp"
+#include "gui/editor_map_component.hpp"
 #include "flexlay.hpp"
 #include "globals.hpp"
 #include "gui_manager.hpp"
 #include "tile_selector.hpp"
 #include "object_brush.hpp"
-#include "object_selector.hpp"
-#include "icon.hpp"
-#include "window.hpp"
-#include "panel.hpp"
-#include "directory_view.hpp"
+#include "gui/object_selector.hpp"
+#include "gui/icon.hpp"
+#include "gui/window.hpp"
+#include "gui/panel.hpp"
+#include "gui/directory_view.hpp"
 #include "menu.hpp"
-#include "menubar.hpp"
-#include "scrollbar.hpp"
+#include "gui/menubar.hpp"
+#include "gui/scrollbar.hpp"
 #include "graphic_context_state.hpp"
  
 #include "tools/workspace_move_tool.hpp"
@@ -73,8 +73,8 @@
 #include "generated_brush.hpp"
 #include "sprite_brush.hpp"
 
-#include "colorpicker.hpp"
-#include "slider.hpp"
+#include "gui/colorpicker.hpp"
+#include "gui/slider.hpp"
 #include "tools/tilemap_paint_tool.hpp"
 #include "tools/tilemap_select_tool.hpp"
 #include "tools/objmap_select_tool.hpp"
@@ -145,7 +145,7 @@
 %include "tile.hpp"
 %include "tile_brush.hpp"
 %include "meta_data.hpp"
-%include "console.hpp"
+%include "gui/console.hpp"
 %include "blitter.hpp"
  
 %include "layer.hpp"
@@ -156,21 +156,21 @@
 %include "editor_map.hpp"
 %include "workspace.hpp"
 %include "tileset.hpp"
-%include "editor_map_component.hpp"
+%include "gui/editor_map_component.hpp"
 %include "flexlay.hpp"
 %include "globals.hpp"
 %include "gui_manager.hpp"
 %include "tile_selector.hpp"
 %include "object_brush.hpp"
-%include "object_selector.hpp"
-%include "icon.hpp"
-%include "window.hpp"
-%include "panel.hpp"
-%include "minimap.hpp"
-%include "directory_view.hpp"
+%include "gui/object_selector.hpp"
+%include "gui/icon.hpp"
+%include "gui/window.hpp"
+%include "gui/panel.hpp"
+%include "gui/minimap.hpp"
+%include "gui/directory_view.hpp"
 %include "menu.hpp"
-%include "menubar.hpp"
-%include "scrollbar.hpp"
+%include "gui/menubar.hpp"
+%include "gui/scrollbar.hpp"
 
 %include "tools/workspace_move_tool.hpp"
 %include "tools/layer_move_tool.hpp"
@@ -187,8 +187,8 @@
 %include "generated_brush.hpp"
 %include "sprite_brush.hpp"
 
-%include "colorpicker.hpp"
-%include "slider.hpp"
+%include "gui/colorpicker.hpp"
+%include "gui/slider.hpp"
 %include "tools/tilemap_paint_tool.hpp"
 %include "tools/tilemap_select_tool.hpp"
 %include "tools/objmap_select_tool.hpp"

Copied: trunk/flexlay/lib/gui/colorpicker.cpp (from rev 723, trunk/flexlay/lib/colorpicker.cpp)

Copied: trunk/flexlay/lib/gui/colorpicker.hpp (from rev 723, trunk/flexlay/lib/colorpicker.hpp)

Copied: trunk/flexlay/lib/gui/console.cpp (from rev 723, trunk/flexlay/lib/console.cpp)

Copied: trunk/flexlay/lib/gui/console.hpp (from rev 724, trunk/flexlay/lib/console.hpp)

Copied: trunk/flexlay/lib/gui/directory_view.cpp (from rev 723, trunk/flexlay/lib/directory_view.cpp)

Copied: trunk/flexlay/lib/gui/directory_view.hpp (from rev 724, trunk/flexlay/lib/directory_view.hpp)

Copied: trunk/flexlay/lib/gui/editor_map_component.cpp (from rev 723, trunk/flexlay/lib/editor_map_component.cpp)

Copied: trunk/flexlay/lib/gui/editor_map_component.hpp (from rev 724, trunk/flexlay/lib/editor_map_component.hpp)

Copied: trunk/flexlay/lib/gui/icon.cpp (from rev 723, trunk/flexlay/lib/icon.cpp)

Copied: trunk/flexlay/lib/gui/icon.hpp (from rev 724, trunk/flexlay/lib/icon.hpp)

Copied: trunk/flexlay/lib/gui/menubar.cpp (from rev 723, trunk/flexlay/lib/menubar.cpp)

Copied: trunk/flexlay/lib/gui/menubar.hpp (from rev 724, trunk/flexlay/lib/menubar.hpp)

Copied: trunk/flexlay/lib/gui/minimap.cpp (from rev 723, trunk/flexlay/lib/minimap.cpp)

Copied: trunk/flexlay/lib/gui/minimap.hpp (from rev 724, trunk/flexlay/lib/minimap.hpp)

Copied: trunk/flexlay/lib/gui/object_selector.cpp (from rev 722, trunk/flexlay/lib/object_selector.cpp)

Copied: trunk/flexlay/lib/gui/object_selector.hpp (from rev 722, trunk/flexlay/lib/object_selector.hpp)

Copied: trunk/flexlay/lib/gui/panel.cpp (from rev 723, trunk/flexlay/lib/panel.cpp)

Copied: trunk/flexlay/lib/gui/panel.hpp (from rev 724, trunk/flexlay/lib/panel.hpp)

Copied: trunk/flexlay/lib/gui/scrollbar.cpp (from rev 722, trunk/flexlay/lib/scrollbar.cpp)

Copied: trunk/flexlay/lib/gui/scrollbar.hpp (from rev 724, trunk/flexlay/lib/scrollbar.hpp)

Copied: trunk/flexlay/lib/gui/slider.cpp (from rev 722, trunk/flexlay/lib/slider.cpp)

Copied: trunk/flexlay/lib/gui/slider.hpp (from rev 723, trunk/flexlay/lib/slider.hpp)

Copied: trunk/flexlay/lib/gui/tile_editor.cpp (from rev 723, trunk/flexlay/lib/tile_editor.cpp)

Copied: trunk/flexlay/lib/gui/tile_editor.hpp (from rev 723, trunk/flexlay/lib/tile_editor.hpp)

Copied: trunk/flexlay/lib/gui/tile_selection.cpp (from rev 723, trunk/flexlay/lib/tile_selection.cpp)

Copied: trunk/flexlay/lib/gui/tile_selection.hpp (from rev 724, trunk/flexlay/lib/tile_selection.hpp)
===================================================================
--- trunk/flexlay/lib/tile_selection.hpp	2009-11-22 04:59:25 UTC (rev 724)
+++ trunk/flexlay/lib/gui/tile_selection.hpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -0,0 +1,54 @@
+//  Flexlay - A Generic 2D Game Editor
+//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//  
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef HEADER_FLEXLAY_TILE_SELECTION_HPP
+#define HEADER_FLEXLAY_TILE_SELECTION_HPP
+
+#include <ClanLib/Display/color.h>
+
+#include "tile_brush.hpp"
+#include "tilemap_layer.hpp"
+
+class TileSelectionImpl;
+
+/** The TileSelection is a little helper class to manage rectangular
+    selections of tiles and provides a way to convert this selection
+    to a Brush which then can be used for either serialisation or be
+    used for painting on the map itself */
+class TileSelection
+{
+public:
+  TileSelection();
+  ~TileSelection();
+
+  void start (TilemapLayer tilemap, const CL_Point& pos);
+  void update(const CL_Point& pos);
+
+  void clear();
+  bool is_active();
+
+  CL_Rect get_rect() const;
+
+  void draw(const CL_Color& color = CL_Color(255, 255, 255, 100));
+
+  TileBrush get_brush(const Field<int>& field) const;
+private:
+  boost::shared_ptr<TileSelectionImpl> impl;
+};
+
+#endif
+
+/* EOF */

Copied: trunk/flexlay/lib/gui/titlebar.cpp (from rev 723, trunk/flexlay/lib/titlebar.cpp)

Copied: trunk/flexlay/lib/gui/titlebar.hpp (from rev 724, trunk/flexlay/lib/titlebar.hpp)

Copied: trunk/flexlay/lib/gui/viewport.cpp (from rev 722, trunk/flexlay/lib/viewport.cpp)

Copied: trunk/flexlay/lib/gui/viewport.hpp (from rev 724, trunk/flexlay/lib/viewport.hpp)

Copied: trunk/flexlay/lib/gui/window.cpp (from rev 723, trunk/flexlay/lib/window.cpp)

Copied: trunk/flexlay/lib/gui/window.hpp (from rev 724, trunk/flexlay/lib/window.hpp)

Deleted: trunk/flexlay/lib/icon.cpp
===================================================================
--- trunk/flexlay/lib/icon.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/icon.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,163 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <ClanLib/Display/display.h>
-#include "box.hpp"
-#include "icon.hpp"
-
-class IconImpl
-{
-public:
-  IconImpl(Icon* p) : parent(p) {}
-
-  Icon* parent;
-
-  std::vector<CL_Slot> slots;
-  CL_Sprite sprite;
-  std::string tooltip;
-  bool draw_tooltip;
-  bool down;
-
-  /** Parameter to keep the button down all the time, aka togglebutton
-      like */
-  bool is_down;
-
-  bool is_enabled;
-  CL_Signal_v0 sig_on_click;
-
-  void draw();
-
-  void mouse_up  (const CL_InputEvent& event);
-  void mouse_down(const CL_InputEvent& event);
-  void mouse_move(const CL_InputEvent& event);
-};
-
-Icon::Icon(const CL_Rect& rect, const CL_Sprite& sprite, const std::string& tooltip, 
-           CL_Component* parent)
-  : CL_Component(rect, parent),
-    impl(new IconImpl(this))
-{
-  impl->sprite       = sprite;
-  impl->tooltip      = tooltip;
-  impl->draw_tooltip = true;
-  impl->down         = false;
-  impl->is_down      = false;
-  impl->is_enabled   = true;
-
-  impl->slots.push_back(sig_paint().connect(impl.get(), &IconImpl::draw));
-  impl->slots.push_back(sig_mouse_down().connect(impl.get(), &IconImpl::mouse_down));
-  impl->slots.push_back(sig_mouse_up().connect(impl.get(),   &IconImpl::mouse_up));
-}
-
-CL_Signal_v0&
-Icon::sig_clicked()
-{
-  return impl->sig_on_click;
-}
-  
-void
-IconImpl::draw()
-{
-  CL_Display::push_translate(parent->get_screen_x(), parent->get_screen_y());
-  CL_Rect rect(CL_Point(0, 0), CL_Size(parent->get_width()-4, parent->get_height()-4));
-
-  sprite.set_alignment(origin_center);
-
-  if (is_enabled)
-  {
-    if (is_down)
-    {
-      Box::draw_button_down(rect);
-    }
-    else
-    {
-      if (parent->has_mouse_over())
-      {
-        if (down)
-          Box::draw_button_down(rect);
-        else
-          Box::draw_button_up(rect);
-      }
-      else
-        Box::draw_button_neutral(rect);
-    }
-    sprite.set_alpha(1.0f);
-  }
-  else
-  {
-    Box::draw_button_neutral(rect);
-    sprite.set_alpha(0.3f);
-  }
-  sprite.draw((rect.get_width()+1)/2, (rect.get_height()+1)/2);
-  CL_Display::pop_modelview();
-}
-
-void
-IconImpl::mouse_up  (const CL_InputEvent& event)
-{
-  if (is_enabled)
-  {
-    down         = false;
-    parent->release_mouse();  
-
-    if (parent->has_mouse_over())
-    {
-      sig_on_click();
-    }
-  }
-}
-
-void
-IconImpl::mouse_down(const CL_InputEvent& event)
-{
-  if (is_enabled)
-  {
-    down         = true;
-    parent->capture_mouse();
-  }
-}
-
-void 
-IconImpl::mouse_move(const CL_InputEvent& event)
-{
-  //std::cout << "icon: mouse_move: " << event << std::endl;
-}
-
-void
-Icon::disable()
-{
-  impl->is_enabled = false;
-}
-
-void
-Icon::enable()
-{
-  impl->is_enabled = true;
-}
-
-void
-Icon::set_up()
-{
-  impl->is_down = false;
-}
-
-void
-Icon::set_down()
-{
-  impl->is_down = true;
-}
-
-/* EOF */

Deleted: trunk/flexlay/lib/icon.hpp
===================================================================
--- trunk/flexlay/lib/icon.hpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/icon.hpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,51 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_FLEXLAY_ICON_HPP
-#define HEADER_FLEXLAY_ICON_HPP
-
-#include <ClanLib/GUI/component.h>
-#include <ClanLib/Display/sprite.h>
-#include <boost/shared_ptr.hpp>
-
-class IconImpl;
-
-/** */
-class Icon : public CL_Component
-{
-protected:
-  virtual ~Icon() {}
-public:
-  Icon(const CL_Rect& rect, const CL_Sprite& sprite, const std::string& tooltip, CL_Component* parent);
-
-  void disable();
-  void enable();
-
-  void set_up();
-  void set_down();
-  
-  CL_Signal_v0& sig_clicked();
-
-private:
-  Icon (const Icon&);
-  Icon& operator= (const Icon&);
-
-  boost::shared_ptr<IconImpl> impl;
-};
-
-#endif
-
-/* EOF */

Modified: trunk/flexlay/lib/layer.hpp
===================================================================
--- trunk/flexlay/lib/layer.hpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/layer.hpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -21,6 +21,7 @@
 
 #include "meta_data.hpp"
 
+class CL_Rect;
 class EditorMapComponent;
 class LayerImpl;
 class CL_GraphicContext;

Deleted: trunk/flexlay/lib/menubar.cpp
===================================================================
--- trunk/flexlay/lib/menubar.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/menubar.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,49 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "menubar.hpp"
-
-class MenubarItem
-{
-public:
-  MenubarItem(const std::string& name_, Menu* menu_)
-    : name(name_), menu(menu_){}
-
-  std::string name;
-  Menu* menu;
-};
-
-class MenubarImpl
-{
-public:
-  typedef std::vector<MenubarItem> Items;
-  Items items;
-};
-
-Menubar::Menubar(const CL_Point& pos, CL_Component* parent)
-  : CL_Component(CL_Rect(pos, CL_Size(1, 1)), parent),
-    impl(new MenubarImpl())
-{
-  
-}
-
-void
-Menubar::add_submenu(const std::string& name, Menu* menu)
-{
-  impl->items.push_back(MenubarItem(name, menu));
-}
-
-/* EOF */

Deleted: trunk/flexlay/lib/menubar.hpp
===================================================================
--- trunk/flexlay/lib/menubar.hpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/menubar.hpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,41 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_FLEXLAY_MENUBAR_HPP
-#define HEADER_FLEXLAY_MENUBAR_HPP
-
-#include <ClanLib/GUI/component.h>
-#include <boost/shared_ptr.hpp>
-
-class Menu;
-class MenubarImpl;
-
-/** */
-class Menubar : public CL_Component
-{
-protected:
-  virtual ~Menubar() {}
-public:
-  Menubar(const CL_Point& pos, CL_Component* parent);
-
-  void add_submenu(const std::string& name, Menu* menu);
-private:
-  boost::shared_ptr<MenubarImpl> impl;
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/flexlay/lib/minimap.cpp
===================================================================
--- trunk/flexlay/lib/minimap.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/minimap.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,236 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "minimap.hpp"
-
-#include <iostream>
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/surface.h>
-#include <ClanLib/Display/pixel_format.h>
-#include <ClanLib/Display/pixel_buffer.h>
-
-#include "tile.hpp"
-#include "tileset.hpp"
-#include "editor_map.hpp"
-#include "editor_map_component.hpp"
-#include "tilemap_layer.hpp"
-#include "workspace.hpp"
-
-class MinimapImpl
-{
-public:
-  std::vector<CL_Slot> slots;
-  bool drag_active;
-  
-  int last_serial;
-  EditorMap editor_map;
-
-  EditorMapComponent* parent;
-  CL_Surface minimap_surface;
-
-  MinimapImpl() 
-    : editor_map(false)
-  {}
-  void update_minimap_surface();
-};
-
-Minimap::Minimap(EditorMapComponent* p, const CL_Rect& rect,
-                 CL_Component* parent)
-  : CL_Component(rect, parent), 
-    impl(new MinimapImpl())
-{
-  impl->slots.push_back(sig_paint().connect(this, &Minimap::draw));
-  impl->slots.push_back(sig_mouse_move().connect(this, &Minimap::mouse_move));
-  impl->slots.push_back(sig_mouse_down().connect(this, &Minimap::mouse_down));
-  impl->slots.push_back(sig_mouse_up().connect(this, &Minimap::mouse_up));
-
-  impl->parent = p ? p : EditorMapComponent::current();
-  impl->drag_active = false;
-  impl->last_serial = -1;
-}
-
-void
-Minimap::draw()
-{
-  if (impl->parent->get_workspace().get_map().is_null()) return;
-
-  if (!impl->parent || impl->parent->get_workspace().is_null())
-    return;
-
-  CL_Display::push_cliprect(get_screen_rect());
-  CL_Display::push_translate(get_screen_x(), get_screen_y());
-
-  // FIXME: Do this only on map changes
-  if (impl->last_serial != impl->parent->get_workspace().get_map().get_serial())
-    //      || editor_map != parent->get_workspace().get_map())
-  {
-    impl->update_minimap_surface();
-    impl->last_serial = impl->parent->get_workspace().get_map().get_serial();
-    impl->editor_map  = impl->parent->get_workspace().get_map();
-  }
-
-  if (1)
-  { // Draw background color
-    CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
-                                  CL_Size(get_width(),
-                                          get_height())),
-                          CL_Color(200, 200, 200, 225));
-  }
-
-  // FIXME: This doesn't work all that well
-  TilemapLayer tilemap = TilemapLayer::current();
-
-  if (!tilemap.is_null() && tilemap.get_height() != 0 && tilemap.get_width() != 0)
-  {
-    int tile_size = tilemap.get_tileset().get_tile_size();
-
-    int map_width  = tilemap.get_width()  * tile_size;
-    int map_height = tilemap.get_height() * tile_size;
-
-    CL_Size small_tile(tile_size * get_width() / map_width + 1,
-                       tile_size * get_height() / map_height + 1);
-
-    Field<int>* field = tilemap.get_field();
-
-    // FIXME: No current tileset
-    if (0)
-    {
-      for(int y = 0; y < field->get_height(); ++y)
-        for(int x = 0; x < field->get_width(); ++x)
-        {
-          Tile* tile = tilemap.get_tileset().create(field->at(x, y));
-          if (tile)
-            CL_Display::fill_rect(CL_Rect(CL_Point((x * tile_size) * get_width() / map_width,
-                                                   (y * tile_size) * get_height() / map_height),
-                                          small_tile),
-                                  tile->get_color());
-          CL_Display::flush();
-        }
-    }
-    impl->minimap_surface.draw(CL_Rect(CL_Point(0, 0),
-                                       CL_Size(get_width(), get_height())));
-
-    // Draw cursor
-    CL_Rect rect(impl->parent->get_clip_rect());
-    CL_Rect screen_rect(CL_Point(rect.left  * get_width()  / map_width,
-                                 rect.top   * get_height() / map_height),
-                        CL_Size(rect.get_width() * get_width() /map_width,
-                                rect.get_height()* get_height()/map_height));
-    CL_Display::fill_rect(screen_rect,
-                          CL_Color(255, 255, 0, 50));
-    CL_Display::draw_rect(screen_rect,
-                          CL_Color(0, 0, 0));
-  }
-
-  CL_Display::pop_modelview();
-  CL_Display::pop_cliprect();
-}
-
-void
-MinimapImpl::update_minimap_surface()
-{
-  // FIXME: This doesn't work all that well
-  TilemapLayer tilemap = TilemapLayer::current();
-  
-  if (!tilemap.is_null())
-  {
-    Field<int>* field = tilemap.get_field();
-
-    CL_PixelBuffer buffer(tilemap.get_width(), tilemap.get_height(), 
-                          tilemap.get_width()*4, CL_PixelFormat::rgba8888);
-  
-    int map_width  = tilemap.get_width();
-    int map_height = tilemap.get_height();
-
-    // FIXME: No Tileset::current()
-    unsigned char* buf = static_cast<unsigned char*>(buffer.get_data());
-    for(int y = 0; y < map_height; ++y)
-      for(int x = 0; x < map_width; ++x)
-      {
-        Tile* tile = tilemap.get_tileset().create(field->at(x, y));
-        if (tile)
-        {
-          buf[4*(x + y * map_width) + 3] = tile->get_color().get_red();
-          buf[4*(x + y * map_width) + 2] = tile->get_color().get_green();
-          buf[4*(x + y * map_width) + 1] = tile->get_color().get_blue();
-          buf[4*(x + y * map_width) + 0] = tile->get_color().get_alpha();
-        } 
-        else
-        {
-          buf[4*(x + y * map_width) + 0] = 0;
-          buf[4*(x + y * map_width) + 1] = 0;
-          buf[4*(x + y * map_width) + 2] = 0;
-          buf[4*(x + y * map_width) + 3] = 0;
-        }
-      }
-
-    minimap_surface = CL_Surface(buffer);
-  }
-}
-
-void
-Minimap::mouse_move(const CL_InputEvent& event)
-{
-  // FIXME: This doesn't work all that well
-  TilemapLayer tilemap = TilemapLayer::current();
-  if (!tilemap.is_null())
-  {
-    int tile_size  = tilemap.get_tileset().get_tile_size();
-    int map_width  = tilemap.get_width()  * tile_size;
-    int map_height = tilemap.get_height() * tile_size;
-
-    if (impl->drag_active)
-      impl->parent->move_to(event.mouse_pos.x * map_width / get_width(),
-                            event.mouse_pos.y * map_height / get_height());
-  }
-}
-
-void
-Minimap::mouse_down(const CL_InputEvent& event)
-{
-  // FIXME: This doesn't work all that well
-  TilemapLayer tilemap = TilemapLayer::current();
-  if (!tilemap.is_null())
-  {
-    int tile_size  = tilemap.get_tileset().get_tile_size();
-    int map_width  = tilemap.get_width()  * tile_size;
-    int map_height = tilemap.get_height() * tile_size;
-
-    impl->parent->move_to(event.mouse_pos.x * map_width / get_width(),
-                          event.mouse_pos.y * map_height / get_height());
-    impl->drag_active = true;
-    capture_mouse();
-  }
-}
-
-void
-Minimap::mouse_up  (const CL_InputEvent& event)
-{
-  TilemapLayer tilemap = TilemapLayer::current();
-  if (!tilemap.is_null())
-  {
-    impl->drag_active = false;
-    release_mouse();
-  }
-}
-
-void
-Minimap::update_minimap()
-{
-  impl->update_minimap_surface();
-}
-
-/* EOF */

Deleted: trunk/flexlay/lib/minimap.hpp
===================================================================
--- trunk/flexlay/lib/minimap.hpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/minimap.hpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,49 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_FLEXLAY_MINIMAP_HPP
-#define HEADER_FLEXLAY_MINIMAP_HPP
-
-#include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/System/sharedptr.h>
-
-#include <boost/shared_ptr.hpp>
-
-class MinimapImpl;
-class EditorMapComponent;
-
-/** */
-class Minimap : public CL_Component
-{
-protected:
-  virtual ~Minimap() {}
-public:
-  Minimap(EditorMapComponent* p, const CL_Rect& rect, CL_Component* parent);
-  
-  void draw();
-  void update_minimap();
-
-  void mouse_move(const CL_InputEvent& event);
-  void mouse_down(const CL_InputEvent& event);
-  void mouse_up  (const CL_InputEvent& event);
-  
-private:
-  boost::shared_ptr<MinimapImpl> impl;
-};
-
-#endif
-
-/* EOF */

Modified: trunk/flexlay/lib/object_layer.cpp
===================================================================
--- trunk/flexlay/lib/object_layer.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/object_layer.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -15,7 +15,8 @@
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "object_layer.hpp"
-#include "editor_map_component.hpp"
+
+#include "gui/editor_map_component.hpp"
 #include "layer_impl.hpp"
 
 ObjectLayer ObjectLayer::current_;

Deleted: trunk/flexlay/lib/object_selector.cpp
===================================================================
--- trunk/flexlay/lib/object_selector.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/object_selector.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,213 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <ClanLib/Core/core_iostream.h>
-#include <ClanLib/display.h>
-#include "editor_map.hpp"
-#include "editor_map_component.hpp"
-#include "object_selector.hpp"
-#include "object_add_command.hpp"
-
-ObjectSelector::ObjectSelector(const CL_Rect& rect, 
-                               int obj_w, int obj_h,
-                               CL_Component* parent)
-  : CL_Component(rect, parent),
-    width(rect.get_width()/obj_w), height(rect.get_height()/obj_h),
-    obj_width(obj_w), obj_height(obj_h)
-{
-  index = 0;
-
-  slots.push_back(sig_paint().connect(this, &ObjectSelector::draw));
-  slots.push_back(sig_mouse_move().connect(this, &ObjectSelector::mouse_move));
-  slots.push_back(sig_mouse_down().connect(this, &ObjectSelector::mouse_down));
-  slots.push_back(sig_mouse_up().connect(this, &ObjectSelector::mouse_up));
- 
-  mouse_over_tile = -1;
-  scrolling = false;
-  offset = 0;
-  scale = 1.0f;
-  drag_obj = -1;
-}
-
-ObjectSelector::~ObjectSelector()
-{
-}
-
-void
-ObjectSelector::mouse_up(const CL_InputEvent& event)
-{
-  switch(event.id)
-  {
-    case CL_MOUSE_LEFT:
-    {
-      if (drag_obj != -1)
-      {
-        release_mouse();
-      
-        if (!has_mouse_over())
-        {
-          CL_Point screen(event.mouse_pos.x + get_screen_rect().left,
-                          event.mouse_pos.y + get_screen_rect().top);
-
-          CL_Point target(screen.x - EditorMapComponent::current()->get_screen_rect().left,
-                          screen.y - EditorMapComponent::current()->get_screen_rect().top);
-      
-          // FIXME: Move this to the scripting layer
-          //ObjectAddCommand command(ObjectLayer::current());
-
-          //ObjMapObject obj = brushes[drag_obj].to_sprite_object
-          //(EditorMapComponent::current()->screen2world(target)).to_object();
-
-          //command.add_object(obj);
-          //Workspace::current().get_map().execute(command.to_command());
-                
-          //std::cout << "C++: Calling on_drop" << std::endl;
-          on_drop(brushes[drag_obj], target);
-          //std::cout << "C++: Calling on_drop: done" << std::endl;
-        }
-        drag_obj = -1;
-      }
-    }
-    break;
-
-    case CL_MOUSE_MIDDLE:
-      scrolling = false;
-      release_mouse();
-      break;
-
-    default:
-      break;
-  }
-}
-
-void
-ObjectSelector::mouse_down(const CL_InputEvent& event)
-{
-  switch(event.id)
-  {
-    case CL_MOUSE_LEFT:
-    {
-      if (mouse_over_tile != -1)
-      {
-        drag_obj = mouse_over_tile;
-        capture_mouse();
-      }
-    }
-    break;
-      
-    case CL_MOUSE_MIDDLE:
-      scrolling = true;
-      click_pos = event.mouse_pos;
-      old_offset = offset;
-      capture_mouse();
-      break;
-      
-    case CL_MOUSE_WHEEL_UP:
-      offset -= static_cast<int>(obj_height*scale); 
-      break;
-
-    case CL_MOUSE_WHEEL_DOWN:
-      offset += static_cast<int>(obj_height*scale); 
-      break;
-  }
-}
-
-void
-ObjectSelector::mouse_move(const CL_InputEvent& event)
-{
-  if (scrolling)
-  {
-    offset = old_offset + (click_pos.y - event.mouse_pos.y);
-  }
-
-  mouse_pos = event.mouse_pos;
-
-  int x = (event.mouse_pos.x)/static_cast<int>(obj_width);
-  int y = (event.mouse_pos.y+offset)/static_cast<int>(obj_height);
-
-  mouse_over_tile = y * width + x;
-
-  if (mouse_over_tile < 0 || mouse_over_tile >= (int)brushes.size())
-    mouse_over_tile = -1;
-}
-
-void 
-ObjectSelector::draw()
-{
-  if (offset < 0)
-    offset = 0;
-
-  CL_Display::push_cliprect(get_screen_rect());
-
-  // Handle scrolling in the Component
-  CL_Display::push_modelview();
-  CL_Display::add_translate(0, -offset);
-  CL_Display::add_translate(get_screen_x(), get_screen_y());
-    
-  for(int i = 0; i < (int)brushes.size(); ++i)
-  {
-    int x = i%width;
-    int y = i/width;
-
-    CL_Rectf rect(CL_Pointf(x * obj_width, y * obj_height),
-                  CL_Sizef(obj_width, obj_height));
-
-    CL_Sprite sprite = brushes[i].get_sprite();
-    sprite.set_alignment(origin_center, 0, 0);
-    sprite.set_scale(std::min(1.0f, (float)obj_width/(float)sprite.get_width()),
-                     std::min(1.0f, (float)obj_height/(float)sprite.get_height()));
-        
-    sprite.draw(x * obj_width + obj_width/2, 
-                y * obj_height + obj_height/2);
-        
-    //CL_Display::draw_rect(rect, CL_Color(0,0,0,128));
-        
-    if (mouse_over_tile == i && has_mouse_over())
-    {
-      CL_Display::fill_rect(rect, CL_Color(0,0,255, 20));
-    }
-  }
-
-  CL_Display::pop_modelview();
-  CL_Display::pop_cliprect();
- 
-  // Draw drag sprite
-  if (drag_obj != -1)
-  {
-    CL_Display::set_cliprect(CL_Rect(CL_Point(0, 0), 
-                                     CL_Size(CL_Display::get_width(),
-                                             CL_Display::get_height())));
-
-    CL_Sprite sprite = brushes[drag_obj].get_sprite();
-    sprite.set_alpha(0.5f);
-    sprite.draw(mouse_pos.x + get_screen_x(), mouse_pos.y + get_screen_y());
-  }
-}
-
-void
-ObjectSelector::add_brush(const ObjectBrush& brush)
-{
-  brushes.push_back(brush);
-}
-
-CL_Signal_v2<ObjectBrush, CL_Point>&
-ObjectSelector::sig_drop()
-{
-  return on_drop;
-}
-
-/* EOF */

Deleted: trunk/flexlay/lib/object_selector.hpp
===================================================================
--- trunk/flexlay/lib/object_selector.hpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/object_selector.hpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,69 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_FLEXLAY_OBJECT_SELECTOR_HPP
-#define HEADER_FLEXLAY_OBJECT_SELECTOR_HPP
-
-#include <ClanLib/GUI/component.h>
-#include <ClanLib/GUI/component.h>
-#include "object_brush.hpp"
-
-/** */
-class ObjectSelector : public CL_Component
-{
-private:
-  std::vector<CL_Slot> slots;
-
-  int width;
-  int height;
-
-  int obj_width;
-  int obj_height;
-
-  int index;
-  
-  int offset;
-  int old_offset;
-  int mouse_over_tile;
-  bool scrolling;
-  CL_Point click_pos;
-  CL_Point mouse_pos;
-  float scale;
-
-  std::vector<ObjectBrush> brushes;
-  int drag_obj;
-
-  CL_Signal_v2<ObjectBrush, CL_Point> on_drop;
-
-protected:
-  virtual ~ObjectSelector();
-
-public:
-  ObjectSelector(const CL_Rect& rect, int obj_w, int obj_h, CL_Component* parent);
-
-  void draw();
-  void add_brush(const ObjectBrush& brush);
-
-  CL_Signal_v2<ObjectBrush, CL_Point>& sig_drop();
-private:
-  void mouse_move(const CL_InputEvent& event);
-  void mouse_down(const CL_InputEvent& event);
-  void mouse_up  (const CL_InputEvent& event); 
-};
-
-#endif
-
-/* EOF */

Modified: trunk/flexlay/lib/onion_skin_layer.cpp
===================================================================
--- trunk/flexlay/lib/onion_skin_layer.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/onion_skin_layer.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -14,6 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
+#include "onion_skin_layer.hpp"
+
 #include <iostream>
 #include <vector>
 #include <ClanLib/Core/System/error.h>
@@ -21,9 +23,9 @@
 #include <ClanLib/Display/pixel_format.h>
 #include <ClanLib/Display/surface.h>
 #include <ClanLib/Display/canvas.h>
-#include "editor_map_component.hpp"
+
+#include "gui/editor_map_component.hpp"
 #include "layer_impl.hpp"
-#include "onion_skin_layer.hpp"
 
 #define SCALE 4
 

Deleted: trunk/flexlay/lib/panel.cpp
===================================================================
--- trunk/flexlay/lib/panel.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/panel.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,46 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <ClanLib/Display/display.h>
-#include "box.hpp"
-#include "panel.hpp"
-
-class PanelImpl
-{
-public:
-  std::vector<CL_Slot> slots;
-  CL_Component* parent;
-
-  void draw();
-};
-
-Panel::Panel(const CL_Rect& rect, CL_Component* parent)
-  : CL_Component(rect, parent), impl(new PanelImpl())
-{
-  impl->parent = this;
-  impl->slots.push_back(sig_paint().connect(impl.get(), &PanelImpl::draw));
-}
-
-void
-PanelImpl::draw()
-{
-  CL_Display::push_translate(parent->get_screen_x(), parent->get_screen_y());
-  CL_Rect rect = parent->get_position();
-  Box::draw_panel(CL_Rect(CL_Point(0, 0), CL_Size(rect.get_width()-1, rect.get_height()-1)));
-  CL_Display::pop_modelview();
-}
-
-/* EOF */

Deleted: trunk/flexlay/lib/panel.hpp
===================================================================
--- trunk/flexlay/lib/panel.hpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/panel.hpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,36 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_FLEXLAY_PANEL_HPP
-#define HEADER_FLEXLAY_PANEL_HPP
-
-#include <ClanLib/GUI/component.h>
-#include <boost/shared_ptr.hpp>
-
-class PanelImpl;
-
-/** */
-class Panel : public CL_Component
-{
-public:
-  Panel(const CL_Rect& rect, CL_Component* parent);
-private:
-  boost::shared_ptr<PanelImpl> impl;
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/flexlay/lib/scrollbar.cpp
===================================================================
--- trunk/flexlay/lib/scrollbar.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/scrollbar.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,178 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/keys.h>
-#include "scrollbar.hpp"
-
-class ScrollbarImpl
-{
-public:
-  std::vector<CL_Slot> slots;
-
-  ScrollbarImpl(Scrollbar* parent_) : parent(parent_) {}
-
-  Scrollbar* parent;
-  float min;
-  float max;
-  float pagesize;
-  float pos;
-  Scrollbar::Orientation orientation;
-
-  CL_Signal_v1<float> on_scrollbar_move;
-
-  float old_pos;
-  
-  bool pressed;
-  CL_Point click_pos;
-  
-  void draw();
-  void on_mouse_up(const CL_InputEvent& event);
-  void on_mouse_down(const CL_InputEvent& event);
-  void on_mouse_move(const CL_InputEvent& event);
-};
-
-Scrollbar::Scrollbar(const CL_Rect& rect, Orientation orientation, CL_Component* parent)
-  : CL_Component(rect, parent),
-    impl(new ScrollbarImpl(this))
-{
-  impl->min = 0;
-  impl->max = 100;
-  impl->pagesize = 10;
-  impl->pos  = 0;
-  impl->pressed = false;
-  impl->orientation = orientation;
-
-  impl->slots.push_back(sig_paint().connect(impl.get(), &ScrollbarImpl::draw));
-
-  impl->slots.push_back(sig_mouse_down().connect(impl.get(), &ScrollbarImpl::on_mouse_down));
-  impl->slots.push_back(sig_mouse_up().connect(impl.get(), &ScrollbarImpl::on_mouse_up));
-  impl->slots.push_back(sig_mouse_move().connect(impl.get(), &ScrollbarImpl::on_mouse_move));
-}
-  
-void
-Scrollbar::set_range(float min, float max)
-{
-  impl->min = min;
-  impl->max = max;
-}
-
-void
-Scrollbar::set_pagesize(float size)
-{
-  impl->pagesize = size;  
-}
-
-void
-Scrollbar::set_pos(float pos)
-{
-  impl->pos = pos;
-}
-
-void 
-ScrollbarImpl::draw()
-{
-  CL_Display::push_cliprect(parent->get_screen_rect());
-  CL_Display::push_translate(parent->get_screen_x(), parent->get_screen_y());
-
-  CL_Rect rect = CL_Rect(CL_Point(0, 0), 
-                         CL_Size(parent->get_width()-1,
-                                 parent->get_height()-1));
-  CL_Display::fill_rect(rect,
-                        CL_Color(255, 255, 255));
-
-  if (orientation == Scrollbar::HORIZONTAL)
-  {
-    float scale = parent->get_width()/(max - min);
-    CL_Display::fill_rect(CL_Rect(CL_Point(int((pos-min-(pagesize/2)) * scale), 2), 
-                                  CL_Size(int(pagesize*scale), 
-                                          parent->get_height()-5)),
-                          CL_Color(0, 0, 0));
-  }
-  else if (orientation == Scrollbar::VERTICAL)
-  {
-    float scale = parent->get_height()/(max - min);
-    CL_Display::fill_rect(CL_Rect(CL_Point(2, int((pos-min-(pagesize/2)) * scale)), 
-                                  CL_Size(parent->get_width()-5,
-                                          int(pagesize*scale))),
-                          CL_Color(0, 0, 0));     
-  }
-
-  CL_Display::draw_rect(rect,
-                        CL_Color(155, 155, 155));
-
-  CL_Display::pop_modelview();
-  CL_Display::pop_cliprect();
-}
-
-void
-ScrollbarImpl::on_mouse_up(const CL_InputEvent& event)
-{
-  if (event.id == CL_MOUSE_LEFT)
-  {
-    pressed = false;
-    parent->release_mouse();
-  }
-}
-
-void
-ScrollbarImpl::on_mouse_down(const CL_InputEvent& event)
-{
-  if (event.id == CL_MOUSE_LEFT)
-  {
-    pressed   = true;
-    click_pos = event.mouse_pos;
-      
-    parent->capture_mouse();
-
-    float scale = ((orientation == Scrollbar::VERTICAL)
-                   ? parent->get_height() : parent->get_width())/(max - min);
-    old_pos = pos * scale;
-
-    click_pos.x += parent->get_position().left;
-    click_pos.y += parent->get_position().top;
-  }
-}
-
-void
-ScrollbarImpl::on_mouse_move(const CL_InputEvent& event)
-{
-  if(pressed)
-  {
-    CL_Rect rect = parent->get_position();
-      
-    float scale = ((orientation == Scrollbar::VERTICAL)
-                   ? parent->get_height() : parent->get_width())/(max - min);
-      
-    if (orientation == Scrollbar::VERTICAL)
-    {
-      pos = (old_pos - (click_pos.y - (rect.top + event.mouse_pos.y)))/scale;
-    }
-    else if (orientation == Scrollbar::HORIZONTAL)
-    {
-      pos = (old_pos - (click_pos.x - (rect.left + event.mouse_pos.x)))/scale;
-    }
-    on_scrollbar_move(pos);
-  }
-}
-
-CL_Signal_v1<float>&
-Scrollbar::sig_scrollbar_move()
-{
-  return impl->on_scrollbar_move;
-}
-
-/* EOF */

Deleted: trunk/flexlay/lib/scrollbar.hpp
===================================================================
--- trunk/flexlay/lib/scrollbar.hpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/scrollbar.hpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,46 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_FLEXLAY_SCROLLBAR_HPP
-#define HEADER_FLEXLAY_SCROLLBAR_HPP
-
-#include <ClanLib/GUI/component.h>
-#include <boost/shared_ptr.hpp>
-
-class ScrollbarImpl;
-
-/** */
-class Scrollbar : public CL_Component
-{
-protected:
-  virtual ~Scrollbar() {}
-public:
-  enum Orientation { HORIZONTAL, VERTICAL };
-
-  Scrollbar(const CL_Rect& rect, Orientation orientation, CL_Component* parent);
-  
-  void set_range(float min, float max);
-  void set_pagesize(float size);
-  void set_pos(float pos);
-  
-  CL_Signal_v1<float>& sig_scrollbar_move();
-private:
-  boost::shared_ptr<ScrollbarImpl> impl;
-};
-
-#endif
-
-/* EOF */

Modified: trunk/flexlay/lib/sketch_layer.cpp
===================================================================
--- trunk/flexlay/lib/sketch_layer.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/sketch_layer.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -14,6 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
+#include "sketch_layer.hpp"
+
 #include <iostream>
 #include <ClanLib/gl.h>
 #include <ClanLib/Core/core_iostream.h>
@@ -25,10 +27,10 @@
 #include <ClanLib/Display/blend_func.h>
 #include <ClanLib/Display/graphic_context.h>
 #include <ClanLib/Display/display_window.h>
+
 #include "flexlay.hpp"
-#include "editor_map_component.hpp"
+#include "gui/editor_map_component.hpp"
 #include "layer_impl.hpp"
-#include "sketch_layer.hpp"
 #include "math.hpp"
 
 SketchLayer* SketchLayer::current_ = 0;

Modified: trunk/flexlay/lib/sketch_layer.hpp
===================================================================
--- trunk/flexlay/lib/sketch_layer.hpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/sketch_layer.hpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -20,6 +20,7 @@
 #include <vector>
 #include <ClanLib/Core/Math/point.h>
 #include <ClanLib/Display/color.h>
+#include <ClanLib/Display/surface.h>
 #include "layer.hpp"
 #include "stroke.hpp"
 

Deleted: trunk/flexlay/lib/slider.cpp
===================================================================
--- trunk/flexlay/lib/slider.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/slider.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,114 +0,0 @@
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/keys.h>
-#include "math.hpp"
-#include "slider.hpp"
-
-Slider::Slider(const CL_Rect& rect, CL_Component* parent)
-  : CL_Component(rect, parent)
-{
-  start = 0.0f;
-  end   = 100.0f;
-  value = 50.0f;
-  pressed = false;
-
-  slots.push_back(sig_mouse_down().connect(this, &Slider::on_mouse_down));
-  slots.push_back(sig_mouse_up().connect(this, &Slider::on_mouse_up));
-  slots.push_back(sig_mouse_move().connect(this, &Slider::on_mouse_move));
-  slots.push_back(sig_paint().connect(this, &Slider::draw));
-}
-
-Slider::~Slider()
-{
-}
-
-void
-Slider::draw()
-{
-  CL_Display::push_modelview();
-  CL_Display::add_translate(get_screen_x(), get_screen_y());
-    
-  CL_Display::fill_rect(CL_Rect(CL_Point(0, get_height()/2 - 2),
-                                CL_Size(get_width(), 5)),
-                        CL_Color(255, 255, 255, 255));
-
-  CL_Display::fill_rect(CL_Rect(CL_Point(int(-2 + (value/(end-start)) * get_width()), 0),
-                                CL_Size(5, get_height())),
-                        CL_Color(0, 0, 0, 255));
-
-  CL_Display::pop_modelview();    
-}
-
-void
-Slider::set_range(float start_, float end_)
-{
-  start = start_;
-  end   = end_;
-}
-
-CL_Signal_v1<float>&
-Slider::sig_on_change()
-{
-  return on_change;
-}
-
-void
-Slider::set_value(float value_)
-{
-  value = value_;
-  on_change(value);
-}
-
-void
-Slider::update_mouse(const CL_InputEvent& event)
-{
-  set_value(Math::mid(start, (float(event.mouse_pos.x) / get_width()) * (end - start), end));
-}
-
-void
-Slider::on_mouse_down(const CL_InputEvent& event)
-{
-  if (event.id == CL_MOUSE_LEFT)
-  {
-    pressed = true;
-    capture_mouse();
-    update_mouse(event);
-  }
-}
-
-void
-Slider::on_mouse_up  (const CL_InputEvent& event)
-{
-  if (event.id == CL_MOUSE_LEFT)
-  {
-    pressed = false;
-    release_mouse();
-    update_mouse(event);
-  }
-}
-
-void
-Slider::on_mouse_move(const CL_InputEvent& event)
-{
-  if (pressed)
-  {
-    update_mouse(event);
-  }
-}
-
-/* EOF */

Deleted: trunk/flexlay/lib/slider.hpp
===================================================================
--- trunk/flexlay/lib/slider.hpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/slider.hpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,54 +0,0 @@
-//  Pingus - A free Lemmings clone
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_FLEXLAY_SLIDER_HPP
-#define HEADER_FLEXLAY_SLIDER_HPP
-
-#include <ClanLib/GUI/component.h>
-
-/** Little Slider GUI component */
-class Slider : public CL_Component
-{
-protected:
-  virtual ~Slider();
-private:
-  std::vector<CL_Slot> slots;
-  float start;
-  float end;
-  float value;
-  bool pressed;
-
-  CL_Signal_v1<float> on_change;
-  
-  void update_mouse(const CL_InputEvent& event);
-public:
-  Slider(const CL_Rect& rect, CL_Component* parent);
-
-  CL_Signal_v1<float>& sig_on_change();
-
-  void set_range(float start, float end);
-  void set_value(float value);
-
-  void draw();
-  
-  void on_mouse_down(const CL_InputEvent& event);
-  void on_mouse_up  (const CL_InputEvent& event);
-  void on_mouse_move(const CL_InputEvent& event);
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/flexlay/lib/tile_editor.cpp
===================================================================
--- trunk/flexlay/lib/tile_editor.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/tile_editor.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,136 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "tile_editor.hpp"
-
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/keys.h>
-#include <ClanLib/Display/sprite.h>
-#include <ClanLib/Display/mouse.h>
-#include "tile.hpp"
-
-TileEditor::TileEditor(int x, int y, int w, int h, CL_Component* parent)
-  : CL_Component(CL_Rect(CL_Rect(CL_Point(x, y), 
-                                 CL_Size(w, h))), // FIXME: make this editable via script
-                 parent)
-{
-  tile = 0;
-  slots.connect(sig_paint(),      this, &TileEditor::draw);
-  slots.connect(sig_mouse_move(), this, &TileEditor::mouse_move);
-  slots.connect(sig_mouse_down(), this, &TileEditor::mouse_down);
-  slots.connect(sig_mouse_up  (), this, &TileEditor::mouse_up);
-}
-
-TileEditor::~TileEditor()
-{
-}
-  
-void
-TileEditor::draw()
-{
-  CL_Display::push_translate(get_screen_x(), get_screen_x());
-
-  //no_tile.draw(0, 0);
-  CL_Display::fill_rect(CL_Rect(0, 0, 32, 32), CL_Color(155, 0, 155));
-
-  if (tile)
-  {
-    tile->get_sprite().draw(0, 0);
-    CL_Display::flush();
-    for(int tile_y = 0; tile_y < 8; ++tile_y)
-      for(int tile_x = 0; tile_x < 8; ++tile_x)
-      {
-        if (tile->get_col(tile_x, tile_y))
-        {
-          CL_Display::fill_rect(CL_Rect(tile_x*16, tile_y*16,
-                                        tile_x*16 + 16, tile_y*16 + 16),
-                                CL_Color(255, 0, 0, 128));
-        }
-      }
-    CL_Display::flush();
-    if (has_mouse_over())
-    {
-      CL_Display::fill_rect(CL_Rect(CL_Point(int(mouse_pos.x)/16 * 16, 
-                                             int(mouse_pos.y)/16 * 16),
-                                    CL_Size(16, 16)),
-                            CL_Color(255, 255, 255, 128));
-    }
-  }
-  else
-  {
-  }
-
-  CL_Display::pop_modelview();
-}
-
-void
-TileEditor::mouse_move(const CL_InputEvent& event)
-{
-  mouse_pos = event.mouse_pos;
-  
-  if (CL_Mouse::get_keycode(CL_MOUSE_LEFT))
-    paint(event.mouse_pos, true);
-  else if (CL_Mouse::get_keycode(CL_MOUSE_RIGHT))
-    paint(event.mouse_pos, false);
-}
-
-void
-TileEditor::mouse_down(const CL_InputEvent& event)
-{
-  if (tile)
-  {
-    switch (event.id)
-    {
-      case CL_MOUSE_LEFT:
-        paint(event.mouse_pos, true);
-        break;
-              
-      case CL_MOUSE_RIGHT:
-        paint(event.mouse_pos, false);
-        break;
-        
-    }
-  }
-}
-
-void
-TileEditor::paint(CL_Point pos, bool val)
-{
-  if (tile)
-  {
-    int x = int(pos.x) / 16;
-    int y = int(pos.y) / 16;
-
-    if (x >= 0 && y >= 0
-        && x < 8 && y < 8)
-    {
-      tile->set_col(x, y, val);
-    }
-  }
-}
-
-void
-TileEditor::mouse_up(const CL_InputEvent& event)
-{
-}
-
-void
-TileEditor::set_tile(Tile* t)
-{
-  tile = t;
-}
-
-/* EOF */

Deleted: trunk/flexlay/lib/tile_editor.hpp
===================================================================
--- trunk/flexlay/lib/tile_editor.hpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/tile_editor.hpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,51 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_FLEXLAY_TILE_EDITOR_HPP
-#define HEADER_FLEXLAY_TILE_EDITOR_HPP
-
-#include <ClanLib/GUI/component.h>
-
-class Tile;
-
-/** */
-class TileEditor : public CL_Component
-{
-private:
-  Tile* tile;
-  CL_SlotContainer slots;
-  CL_Point mouse_pos;
-protected:
-  virtual ~TileEditor();
-public:
-  TileEditor(int x, int y, int w, int h, CL_Component* parent);
-  
-  void draw();
-  void mouse_move(const CL_InputEvent& event);
-  void mouse_down(const CL_InputEvent& event);
-  void mouse_up  (const CL_InputEvent& event);
-
-  void set_tile(Tile* tile);
-private:
-  void paint(CL_Point pos, bool val);
-
-  TileEditor (const TileEditor&);
-  TileEditor& operator= (const TileEditor&);
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/flexlay/lib/tile_selection.cpp
===================================================================
--- trunk/flexlay/lib/tile_selection.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/tile_selection.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,134 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <ClanLib/Display/display.h>
-#include <iostream>
-#include "math.hpp"
-#include "tileset.hpp"
-#include "tile_selection.hpp"
-
-class TileSelectionImpl
-{
-public:
-  TilemapLayer tilemap;
-  CL_Point start_pos;
-  CL_Rect  selection;
-  bool active;
-};
-
-TileSelection::TileSelection()
-  : impl(new TileSelectionImpl())
-{
-  impl->active = false;
-}
-
-TileSelection::~TileSelection()
-{
-}
-
-void
-TileSelection::start(TilemapLayer tilemap_, const CL_Point& pos)
-{
-  impl->tilemap = tilemap_;
-  impl->active = true;
-  impl->start_pos = pos;
-  update(impl->start_pos);
-}
-
-void
-TileSelection::update(const CL_Point& pos)
-{
-  impl->selection = CL_Rect(std::min(impl->start_pos.x, pos.x),
-                            std::min(impl->start_pos.y, pos.y),
-                            std::max(impl->start_pos.x, pos.x) + 1,
-                            std::max(impl->start_pos.y, pos.y) + 1);
-}
-
-bool
-TileSelection::is_active()
-{
-  return impl->active;
-}
-
-void
-TileSelection::clear()
-{
-  impl->selection = CL_Rect();
-  impl->active = false;
-}
-
-void
-TileSelection::draw(const CL_Color& color)
-{
-  int tile_size = impl->tilemap.get_tileset().get_tile_size();
-
-  CL_Display::fill_rect(CL_Rect(impl->selection.left   * tile_size, 
-                                impl->selection.top    * tile_size,
-                                impl->selection.right  * tile_size, 
-                                impl->selection.bottom * tile_size),
-                        color);
-}
-
-TileBrush
-TileSelection::get_brush(const Field<int>& field) const
-{
-  CL_Rect sel = impl->selection;
-
-  sel.normalize();
-
-  if (sel.left     > field.get_width() - 1
-      || sel.top   > field.get_height() - 1
-      || sel.right  <= 0
-      || sel.bottom <= 0)
-  { // Selection is empty
-    std::cout << "Error: Invalid selection" << std::endl;
-    TileBrush brush(1, 1);
-    brush.at(0, 0) = 0;
-    brush.set_opaque();
-    return brush;
-  }
-  else
-  { // Selection is valid
-    // Cut the selection to the field size
-    sel.left = Math::max(0, sel.left);
-    sel.top  = Math::max(0, sel.top);
-
-    sel.right  = Math::min(sel.right,  field.get_width()); 
-    sel.bottom = Math::min(sel.bottom, field.get_height()); 
-
-    TileBrush brush(sel.get_width(), 
-                    sel.get_height());
-
-    for(int y = sel.top; y < sel.bottom; ++y)
-      for(int x = sel.left; x < sel.right; ++x)
-      {
-        brush.at(x - sel.left, 
-                 y - sel.top) = field.at(x, y);
-      }
-
-    return brush;
-  }
-}
-
-CL_Rect
-TileSelection::get_rect() const
-{
-  CL_Rect sel = impl->selection;
-  sel.normalize();
-  return sel;
-}
-
-/* EOF */

Deleted: trunk/flexlay/lib/tile_selection.hpp
===================================================================
--- trunk/flexlay/lib/tile_selection.hpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/tile_selection.hpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,52 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_FLEXLAY_TILE_SELECTION_HPP
-#define HEADER_FLEXLAY_TILE_SELECTION_HPP
-
-#include "tile_brush.hpp"
-#include "tilemap_layer.hpp"
-
-class TileSelectionImpl;
-
-/** The TileSelection is a little helper class to manage rectangular
-    selections of tiles and provides a way to convert this selection
-    to a Brush which then can be used for either serialisation or be
-    used for painting on the map itself */
-class TileSelection
-{
-public:
-  TileSelection();
-  ~TileSelection();
-
-  void start (TilemapLayer tilemap, const CL_Point& pos);
-  void update(const CL_Point& pos);
-
-  void clear();
-  bool is_active();
-
-  CL_Rect get_rect() const;
-
-  void draw(const CL_Color& color = CL_Color(255, 255, 255, 100));
-
-  TileBrush get_brush(const Field<int>& field) const;
-private:
-  boost::shared_ptr<TileSelectionImpl> impl;
-};
-
-#endif
-
-/* EOF */

Modified: trunk/flexlay/lib/tilemap_layer.cpp
===================================================================
--- trunk/flexlay/lib/tilemap_layer.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/tilemap_layer.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -28,11 +28,9 @@
 #include "tileset.hpp"
 #include "editor_map.hpp"
 #include "tile_brush.hpp"
-#include "editor_map_component.hpp"
-#include "editor_map_component.hpp"
+#include "gui/editor_map_component.hpp"
 #include "blitter.hpp"
 #include "layer_impl.hpp"
-#include "editor_map_component.hpp"
 
 TilemapLayer TilemapLayer::current_;
 

Deleted: trunk/flexlay/lib/titlebar.cpp
===================================================================
--- trunk/flexlay/lib/titlebar.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/titlebar.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,122 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/keys.h>
-#include <ClanLib/Display/mouse.h>
-#include "fonts.hpp"
-#include "titlebar.hpp"
-
-class TitlebarImpl
-{
-public:
-  CL_Component* window;
-  Titlebar* parent;
-  CL_Point click_pos;
-  CL_Rect old_pos;
-  std::string title;
-  std::vector<CL_Slot> slots;
-  bool pressed;
-
-  TitlebarImpl(Titlebar* parent_) : parent(parent_) {}
-
-  void on_mouse_move(const CL_InputEvent& event);
-  void on_mouse_down(const CL_InputEvent& event);
-  void on_mouse_up(const CL_InputEvent& event);
-  void draw();
-};
-
-Titlebar::Titlebar(const CL_Rect& rect, const std::string& title, CL_Component* parent)
-  : CL_Component(rect, parent),
-    impl(new TitlebarImpl(this))
-{
-  impl->title = title;
-  impl->pressed = false;
-  impl->window = parent;
-
-  impl->slots.push_back(sig_mouse_down().connect(impl.get(), &TitlebarImpl::on_mouse_down));
-  impl->slots.push_back(sig_mouse_move().connect(impl.get(), &TitlebarImpl::on_mouse_move));
-  impl->slots.push_back(sig_mouse_up().connect(impl.get(), &TitlebarImpl::on_mouse_up));
-  impl->slots.push_back(sig_paint().connect(impl.get(), &TitlebarImpl::draw));
-}
-
-void
-TitlebarImpl::on_mouse_up(const CL_InputEvent& event)
-{
-  if (event.id == CL_MOUSE_LEFT)
-  {
-    pressed = false;
-    parent->release_mouse();
-  }
-}
-
-void
-TitlebarImpl::on_mouse_down(const CL_InputEvent& event)
-{
-  if (event.id == CL_MOUSE_LEFT)
-  {
-    pressed   = true;
-    click_pos = event.mouse_pos;
-    parent->capture_mouse();
-    window->raise();
-
-    old_pos = window->get_position();
-    click_pos.x += old_pos.left;
-    click_pos.y += old_pos.top;
-  } 
-}
-
-void
-TitlebarImpl::on_mouse_move(const CL_InputEvent& event)
-{
-  if(pressed)
-  {
-    CL_Rect rect = window->get_position();
-
-    CL_Point move(old_pos.left - (click_pos.x - (rect.left + event.mouse_pos.x)), 
-                  old_pos.top  - (click_pos.y - (rect.top  + event.mouse_pos.y)));
-
-    window->set_position(move.x, move.y);
-  }
-}
-
-void
-TitlebarImpl::draw()
-{
-  CL_Display::push_translate(parent->get_screen_x(), parent->get_screen_y());
-
-  // FIXME: Hack should be done via has_mouse_over(), but that doesn't include child components
-  if (parent->get_parent()->get_position().is_inside(CL_Point(CL_Mouse::get_x(), 
-                                                              CL_Mouse::get_y())))
-    //parent->get_parent()->has_mouse_over())
-  {
-    CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
-                                  CL_Size(parent->get_width()-1, parent->get_height())), 
-                          CL_Color(250, 250, 250));
-  }
-  else
-  {
-    CL_Display::fill_rect(CL_Rect(CL_Point(0, 0),
-                                  CL_Size(parent->get_width()-1, parent->get_height())), 
-                          CL_Color(240, 240, 240));
-  }
-
-  Fonts::verdana11.draw(4, 0, title);
-
-  CL_Display::pop_modelview();
-}
-                  
-/* EOF */

Deleted: trunk/flexlay/lib/titlebar.hpp
===================================================================
--- trunk/flexlay/lib/titlebar.hpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/titlebar.hpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,39 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_FLEXLAY_TITLEBAR_HPP
-#define HEADER_FLEXLAY_TITLEBAR_HPP
-
-#include <ClanLib/GUI/component.h>
-#include <boost/shared_ptr.hpp>
-
-class TitlebarImpl;
-
-/** */
-class Titlebar : public CL_Component
-{
-protected:
-  virtual ~Titlebar() {}
-public:
-  Titlebar(const CL_Rect& rect, const std::string& title, CL_Component* parent);
-
-private:
-  boost::shared_ptr<TitlebarImpl> impl;
-};
-
-#endif
-
-/* EOF */

Modified: trunk/flexlay/lib/tools/layer_move_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/layer_move_tool.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/tools/layer_move_tool.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -15,14 +15,16 @@
 //  along with this program; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
+#include "layer_move_tool.hpp"
+
 #include <ClanLib/Core/Math/point.h>
 #include <ClanLib/Display/display.h>
+
 #include "workspace.hpp"
 #include "tool_impl.hpp"
-#include "editor_map_component.hpp"
+#include "gui/editor_map_component.hpp"
 #include "editor_map.hpp"
 #include "layer.hpp"
-#include "layer_move_tool.hpp"
 
 class LayerMoveToolImpl : public ToolImpl
 {

Modified: trunk/flexlay/lib/tools/objmap_select_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/objmap_select_tool.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/tools/objmap_select_tool.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -15,22 +15,24 @@
 //  along with this program; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
+#include "objmap_select_tool.hpp"
+
 #include <algorithm>
 #include <ClanLib/Display/keys.h>
 #include <ClanLib/Display/keyboard.h>
 #include <ClanLib/Display/display.h>
-#include "editor_map_component.hpp"
+
 #include "editor_map.hpp"
-#include "editor_map_component.hpp"
+#include "gui/editor_map_component.hpp"
+#include "editor_names.hpp"
+#include "gui/editor_map_component.hpp"
 #include "gui_manager.hpp"
-#include "editor_names.hpp"
+#include "object_delete_command.hpp"
+#include "object_move_command.hpp"
+#include "objmap_control_point.hpp"
+#include "objmap_object.hpp"
 #include "popup_menu.hpp"
-#include "objmap_object.hpp"
-#include "objmap_control_point.hpp"
-#include "object_move_command.hpp"
-#include "object_delete_command.hpp"
 #include "tool_impl.hpp"
-#include "objmap_select_tool.hpp"
 
 class ObjMapSelectToolImpl : public ToolImpl
 {

Modified: trunk/flexlay/lib/tools/sketch_stroke_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/sketch_stroke_tool.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/tools/sketch_stroke_tool.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -15,6 +15,8 @@
 //  along with this program; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
+#include "sketch_stroke_tool.hpp"
+
 #include <iostream>
 #include <assert.h>
 #include <ClanLib/gl.h>
@@ -23,10 +25,10 @@
 #include <ClanLib/Display/mouse.h>
 #include <ClanLib/Display/display.h>
 #include <ClanLib/Display/input_context.h>
-#include "editor_map_component.hpp"
+
+#include "gui/editor_map_component.hpp"
 #include "tool.hpp"
 #include "bitmap_layer.hpp"
-#include "sketch_stroke_tool.hpp"
 #include "sprite_stroke_drawer.hpp"
 #include "marker_stroke_drawer.hpp"
 #include "stroke.hpp"

Modified: trunk/flexlay/lib/tools/sketch_stroke_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/sketch_stroke_tool.hpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/tools/sketch_stroke_tool.hpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -19,6 +19,7 @@
 #define HEADER_FLEXLAY_TOOLS_SKETCH_STROKE_TOOL_HPP
 
 #include "tool_impl.hpp"
+#include "tool.hpp"
 #include "stroke_drawer.hpp"
 
 class SketchStrokeToolImpl;

Modified: trunk/flexlay/lib/tools/tilemap_paint_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/tilemap_paint_tool.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/tools/tilemap_paint_tool.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -26,12 +26,12 @@
 #include "tilemap_layer.hpp"
 #include "tileset.hpp"
 #include "editor_map.hpp"
-#include "editor_map_component.hpp"
+#include "gui/editor_map_component.hpp"
 #include "tile.hpp"
 #include "workspace.hpp"
 #include "paint_command.hpp"
 #include "editor_names.hpp"
-#include "tile_selection.hpp"
+#include "gui/tile_selection.hpp"
 #include "tool_impl.hpp"
 #include "tilemap_paint_tool.hpp"
 

Modified: trunk/flexlay/lib/tools/tilemap_select_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/tilemap_select_tool.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/tools/tilemap_select_tool.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -15,17 +15,19 @@
 //  along with this program; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
+#include "tilemap_select_tool.hpp"
+
 #include <ClanLib/Display/display.h>
 #include <ClanLib/Display/keys.h>
 #include <ClanLib/Display/input_event.h>
+
 #include "globals.hpp"
 #include "tilemap_layer.hpp"
 #include "tool_impl.hpp"
 #include "editor_map.hpp"
-#include "editor_map_component.hpp"
+#include "gui/editor_map_component.hpp"
 #include "tile_brush.hpp"
 #include "editor_names.hpp"
-#include "tilemap_select_tool.hpp"
 
 class TileMapSelectToolImpl : public ToolImpl
 {

Modified: trunk/flexlay/lib/tools/tilemap_select_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/tilemap_select_tool.hpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/tools/tilemap_select_tool.hpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -20,8 +20,9 @@
 
 #include <ClanLib/Core/Math/rect.h>
 #include <ClanLib/Core/Math/point.h>
+
 #include "tool.hpp"
-#include "tile_selection.hpp"
+#include "gui/tile_selection.hpp"
 
 class TileMapSelectToolImpl;
 

Modified: trunk/flexlay/lib/tools/workspace_move_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/workspace_move_tool.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/tools/workspace_move_tool.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -15,12 +15,14 @@
 //  along with this program; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
+#include "workspace_move_tool.hpp"
+
 #include <ClanLib/Core/Math/point.h>
 #include <ClanLib/Core/Math/rect.h>
 #include "tool_impl.hpp"
-#include "editor_map_component.hpp"
+
+#include "gui/editor_map_component.hpp"
 #include "workspace.hpp"
-#include "workspace_move_tool.hpp"
 
 class WorkspaceMoveToolImpl : public ToolImpl
 {

Modified: trunk/flexlay/lib/tools/zoom2_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/zoom2_tool.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/tools/zoom2_tool.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -17,7 +17,8 @@
 
 #include <ClanLib/Display/keys.h>
 #include <ClanLib/Display/display.h>
-#include "editor_map_component.hpp"
+
+#include "gui/editor_map_component.hpp"
 #include "tool_impl.hpp"
 #include "zoom2_tool.hpp"
 

Modified: trunk/flexlay/lib/tools/zoom_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/zoom_tool.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/tools/zoom_tool.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -17,7 +17,8 @@
 
 #include <ClanLib/Display/keys.h>
 #include <ClanLib/Display/display.h>
-#include "editor_map_component.hpp"
+
+#include "gui/editor_map_component.hpp"
 #include "tool_impl.hpp"
 #include "zoom_tool.hpp"
 

Deleted: trunk/flexlay/lib/viewport.cpp
===================================================================
--- trunk/flexlay/lib/viewport.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/viewport.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,47 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "graphic_context_state.hpp"
-#include "viewport.hpp"
-
-class ViewportImpl
-{
-public:
-  CL_Component* child;
-  GraphicContextState gc_state;
-};
-
-Viewport::Viewport(CL_Component* child, const CL_Rect& rect, CL_Component* parent)
-  : CL_Component(rect, parent),
-    impl(new ViewportImpl())
-{
-  impl->child = child;
-  impl->gc_state.set_size(rect.get_width(), rect.get_height());
-}
-
-void
-Viewport::set_pos(const CL_Pointf& pos)
-{
-  impl->gc_state.set_pos(pos);
-}
-
-CL_Pointf
-Viewport::get_pos() const
-{
-  return impl->gc_state.get_pos();
-}
-
-/* EOF */

Deleted: trunk/flexlay/lib/viewport.hpp
===================================================================
--- trunk/flexlay/lib/viewport.hpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/viewport.hpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,42 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_FLEXLAY_VIEWPORT_HPP
-#define HEADER_FLEXLAY_VIEWPORT_HPP
-
-#include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/Math/rect.h>
-#include <boost/shared_ptr.hpp>
-
-class ViewportImpl;
-
-/** */
-class Viewport : public CL_Component
-{
-protected:
-  virtual ~Viewport() {}
-public:
-  Viewport(CL_Component* child, const CL_Rect& rect, CL_Component* parent);
-  
-  void set_pos(const CL_Pointf& pos);
-  CL_Pointf get_pos() const;
-private:
-  boost::shared_ptr<ViewportImpl> impl;
-};
-
-#endif
-
-/* EOF */

Deleted: trunk/flexlay/lib/window.cpp
===================================================================
--- trunk/flexlay/lib/window.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/window.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,168 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <iostream>
-#include <ClanLib/Display/display.h>
-#include "box.hpp"
-#include "icon.hpp"
-#include "helper.hpp"
-#include "titlebar.hpp"
-#include "window.hpp"
-
-class WindowImpl
-{
-public:
-  CL_Component* client_area;
-  CL_Component* parent;
-
-  CL_Rect old_position;
-  bool is_maximized;
-
-  Titlebar* titlebar;
-  Icon* close;
-  Icon* minimize;
-  Icon* maximize;
-
-  std::vector<CL_Slot> slots;
-
-  void draw();
-  void do_maximize();
-  void do_close();
-  void on_resize(int, int);
-};
-
-Window::Window(const CL_Rect& rect, const std::string& title, CL_Component* parent)
-  : CL_Component(rect, parent), impl(new WindowImpl())
-{
-  impl->titlebar = new Titlebar(CL_Rect(CL_Point(3+16,3), 
-                                        CL_Size(get_width()-6-18-18-18, 12+3)), title,
-                                this);
-  //Fonts::verdana11.draw(8+15, 3, title);
-
-  impl->close = new Icon(CL_Rect(CL_Point(3, 3), CL_Size(18,18)), 
-                         make_sprite("../data/images/window/close.png"),
-                         "", this);
-  impl->minimize = new Icon(CL_Rect(CL_Point(get_width()-3-18-18, 3), CL_Size(18,18)), 
-                            make_sprite("../data/images/window/minimize.png"),
-                            "", this);
-  impl->maximize = new Icon(CL_Rect(CL_Point(get_width()-3-18, 3), CL_Size(18,18)), 
-                            make_sprite("../data/images/window/maximize.png"),
-                            "", this);
-
-  impl->client_area = new CL_Component(CL_Rect(CL_Point(4, 3+12+7), 
-                                               CL_Size(rect.get_width()-10,
-                                                       rect.get_height()-28)), this);
-  impl->parent  = this;
-  impl->is_maximized = false;
-
-  impl->slots.push_back(sig_resize().connect(impl.get(),      &WindowImpl::on_resize));
-
-  impl->slots.push_back(sig_paint().connect(impl.get(),      &WindowImpl::draw));
-  impl->slots.push_back(impl->maximize->sig_clicked().connect(impl.get(), &WindowImpl::do_maximize));
-  impl->slots.push_back(impl->close->sig_clicked().connect(impl.get(), &WindowImpl::do_close));
-}
-
-Window::~Window()
-{
-  std::cout << "deleting: Window" << std::endl;
-}
-
-void
-WindowImpl::on_resize(int, int)
-{
-  titlebar->set_position(CL_Rect(CL_Point(3+16,3), CL_Size(parent->get_width()-6-18-18-18, 12+3)));
-  close->set_position(3, 3);
-  minimize->set_position(parent->get_width()-3-18-18, 3);
-  maximize->set_position(parent->get_width()-3-18, 3);
-  CL_Rect rect = parent->get_position();
-  client_area->set_position(CL_Rect(CL_Point(4, 3+12+7), 
-                                    CL_Size(rect.get_width()-10,
-                                            rect.get_height()-28)));
-}
-
-void
-WindowImpl::draw()
-{
-  CL_Display::push_translate (parent->get_screen_x(), parent->get_screen_y());
-
-  CL_Color highlight(255, 255, 255);
-  CL_Color midtone(150, 150, 150);
-
-  CL_Rect rect = parent->get_position() ;
-
-  Box::draw_window(CL_Rect(CL_Point(0, 0), CL_Size(rect.get_width()-1, rect.get_height()-1)));
-  Box::draw_panel_down(client_area->get_position());
-
-  /*
-    CL_Display::fill_rect(CL_Rect(CL_Point(0, 0), rect.get_size()), CL_Color(220, 220, 220));
-    CL_Display::draw_rect(CL_Rect(CL_Point(0, 0), rect.get_size()), CL_Color(0, 0, 0));
- 
-    CL_Display::draw_line(1, rect.get_height()-2,
-    rect.get_width()-2, rect.get_height()-2, midtone);
-    CL_Display::draw_line(rect.get_width()-2, 1,
-    rect.get_width()-2, rect.get_height()-2, midtone);
-
-    CL_Display::draw_line(1, 1,
-    rect.get_width()-2, 1, highlight);
-    CL_Display::draw_line(1, 1,
-    1, rect.get_height()-2, highlight);
-  */
-
-  CL_Display::pop_modelview();
-}
-
-void
-WindowImpl::do_close()
-{
-  parent->show(false);
-}
-
-void
-WindowImpl::do_maximize()
-{
-  // FIXME: Move this to scripting language
-  if (!is_maximized)
-  {
-    is_maximized = true;
-    old_position = parent->get_position();
-    parent->set_position(parent->get_parent()->get_position());
-  }
-  else
-  {
-    is_maximized = false;
-    parent->set_position(old_position);
-  }
-}
-
-CL_Component*
-Window::get_client_area()
-{
-  return impl->client_area;
-}
-
-void
-Window::hide()
-{
-  CL_Component::show(false);
-}
-
-void
-Window::show()
-{
-  CL_Component::show(true);
-}
-
-/* EOF */

Deleted: trunk/flexlay/lib/window.hpp
===================================================================
--- trunk/flexlay/lib/window.hpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/window.hpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -1,44 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_FLEXLAY_WINDOW_HPP
-#define HEADER_FLEXLAY_WINDOW_HPP
-
-
-class WindowImpl;
-
-/** */
-class Window : public CL_Component
-{
-protected:
-  virtual ~Window();
-public:
-  Window(const CL_Rect& rect, const std::string& title, CL_Component* parent);
-  
-  void hide();
-  void show();
-
-  CL_Component* get_client_area();
-private:
-  Window (const Window&);
-  Window& operator= (const Window&);
-
-  boost::shared_ptr<WindowImpl> impl;
-};
-
-#endif
-
-/* EOF */

Modified: trunk/flexlay/lib/workspace.cpp
===================================================================
--- trunk/flexlay/lib/workspace.cpp	2009-11-22 06:25:37 UTC (rev 727)
+++ trunk/flexlay/lib/workspace.cpp	2009-11-22 14:40:18 UTC (rev 728)
@@ -14,17 +14,19 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
+#include "workspace.hpp"
+
 #include <iostream>
 #include <map>
 #include <ClanLib/Display/display.h>
 #include <ClanLib/Display/display_window.h>
 #include <ClanLib/Display/keys.h>
+
 #include "editor_map.hpp"
-#include "editor_map_component.hpp"
+#include "gui/editor_map_component.hpp"
 #include "editor_names.hpp"
 #include "tools/tool.hpp"
 #include "tileset.hpp"
-#include "workspace.hpp"
 
 Workspace Workspace::current_(false);
 



From grumbel at mail.berlios.de  Sun Nov 22 15:44:03 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 22 Nov 2009 15:44:03 +0100
Subject: [Flexlay-commit] r729 - trunk/flexlay/lib
Message-ID: <200911221444.nAMEi3F0009453@sheep.berlios.de>

Author: grumbel
Date: 2009-11-22 15:44:03 +0100 (Sun, 22 Nov 2009)
New Revision: 729

Removed:
   trunk/flexlay/lib/tile_selector.cpp
   trunk/flexlay/lib/tile_selector.hpp
Log:
Moved CL_Component classes to gui/


Deleted: trunk/flexlay/lib/tile_selector.cpp
===================================================================
--- trunk/flexlay/lib/tile_selector.cpp	2009-11-22 14:40:18 UTC (rev 728)
+++ trunk/flexlay/lib/tile_selector.cpp	2009-11-22 14:44:03 UTC (rev 729)
@@ -1,261 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include "tile_selector.hpp"
-
-#include <iostream>
-#include <ClanLib/display.h>
-#include <ClanLib/core.h>
-
-#include "math.hpp"
-#include "tileset.hpp"
-#include "tile.hpp"
-#include "tools/tilemap_paint_tool.hpp"
-
-TileSelector::TileSelector(const CL_Rect& rect, CL_Component* parent) :
-  CL_Component(rect, parent),
-  width(1)
-{
-  index = 0;
-
-  slots.connect(sig_paint(),      this, &TileSelector::draw);
-  slots.connect(sig_mouse_move(), this, &TileSelector::mouse_move);
-  slots.connect(sig_mouse_down(), this, &TileSelector::mouse_down);
-  slots.connect(sig_mouse_up  (), this, &TileSelector::mouse_up);
- 
-  scale = 1.0f;
-  mouse_over_tile = -1;
-  scrolling = false;
-  region_select = false;
-  offset = 0;
-}
-
-TileSelector::~TileSelector()
-{
-  std::cout << "~TileSelector()" << std::endl;
-}
-
-CL_Rect 
-TileSelector::get_selection()
-{
-  CL_Rect selection(current_pos.x, current_pos.y, 
-                    region_select_start.x, region_select_start.y);
-
-  selection.normalize();
-  selection.right  += 1;
-  selection.bottom += 1;
-
-  selection.left  = Math::mid(0, selection.left, width);
-  selection.right = Math::mid(0, selection.right, width);
-
-  selection.top    = Math::max(0, selection.top);
-  
-  return selection;
-}
-
-void
-TileSelector::mouse_up(const CL_InputEvent& event)
-{
-  if (event.id == CL_MOUSE_MIDDLE)
-  {
-    scrolling = false;
-    release_mouse();
-  }
-  else if (event.id == CL_MOUSE_RIGHT)
-  {
-    release_mouse();
-    region_select = false;
-
-    CL_Rect selection = get_selection();
-    //selection.bottom = Math::mid(0, selection.right, width);
-
-    TileBrush brush(selection.get_width(), selection.get_height());
-    brush.set_transparent();
-
-    for(int y = 0; y < selection.get_height(); ++y)
-      for(int x = 0; x < selection.get_width(); ++x)
-      {
-        int tile = (selection.top + y) * width + (selection.left + x);
-
-        if (tile >= 0 && tile < int(tiles.size()))
-          brush.at(x, y) = tiles[tile];
-        else
-          brush.at(x, y) = 0;
-      }
-
-    TileMapPaintTool::current().set_brush(brush);
-  }
-}
-
-void
-TileSelector::mouse_down(const CL_InputEvent& event)
-{
-  if (event.id == CL_MOUSE_LEFT)
-  {
-    TileBrush brush(1, 1);
-
-    brush.set_opaque();
-    if (mouse_over_tile >= 0 && mouse_over_tile < int(tiles.size()))
-      brush.at(0, 0) = tiles[mouse_over_tile];
-    else
-      brush.at(0, 0) = 0;
-
-    TileMapPaintTool::current().set_brush(brush);
-  }
-  else if (event.id == CL_MOUSE_RIGHT) 
-  {
-    region_select = true;
-    region_select_start = current_pos;
-    capture_mouse();
-  }
-  else if (event.id == CL_MOUSE_MIDDLE)
-  {
-    scrolling = true;
-    mouse_pos = event.mouse_pos;
-    old_offset = offset;
-    capture_mouse();
-  }
-  else if (event.id == CL_MOUSE_WHEEL_UP)
-  {
-    offset -= static_cast<int>(tileset.get_tile_size()*scale);
-    if (offset < 0)
-      offset = 0;
-  }
-  else if (event.id == CL_MOUSE_WHEEL_DOWN)
-  {
-    offset += static_cast<int>(tileset.get_tile_size()*scale);
-  }
-}
-
-CL_Point
-TileSelector::get_mouse_tile_pos(const CL_InputEvent& event)
-{
-  return CL_Point(event.mouse_pos.x/static_cast<int>(tileset.get_tile_size()*scale),
-                  (event.mouse_pos.y+offset)/static_cast<int>(tileset.get_tile_size()*scale));
-}
-
-void
-TileSelector::mouse_move(const CL_InputEvent& event)
-{
-  CL_Point pos = get_mouse_tile_pos(event);
-  current_pos = pos;
-  mouse_over_tile = pos.y * width + pos.x;
-
-  if (scrolling)
-  {
-    offset = old_offset + (mouse_pos.y - event.mouse_pos.y);
-    if (offset < 0)
-      offset = 0;
-  }
-}
-
-void 
-TileSelector::draw()
-{
-  CL_Display::push_cliprect(get_screen_rect());
-  CL_Display::push_modelview();
-  CL_Display::add_translate(get_screen_x(), get_screen_y());
-  CL_Display::add_translate(0, -offset);
-
-  const TileBrush& brush = TileMapPaintTool::current().get_brush();
-
-  int start_row = offset / int(tileset.get_tile_size() * scale);
-  int end_row   = start_row + (get_screen_rect().get_height() / int(tileset.get_tile_size() * scale));
-  int end_index = std::min(end_row*width, int(tiles.size())); 
-  
-  // Draw tiles
-  for(int i = (start_row*width); i < end_index; ++i)
-  {
-    int x = i % width;
-    int y = i / width;
-
-    Tile* tile = tileset.create(tiles[i]);
-
-    CL_Rect rect(CL_Point(static_cast<int>(x * tileset.get_tile_size()*scale),
-                          static_cast<int>(y * tileset.get_tile_size()*scale)),
-                 CL_Size(static_cast<int>(tileset.get_tile_size()*scale),
-                         static_cast<int>(tileset.get_tile_size()*scale)));
-
-    if (tile)
-    {
-      CL_Sprite sprite = tile->get_sprite();
-
-      sprite.set_scale(scale, scale);
-
-      sprite.draw(static_cast<int>(x * tileset.get_tile_size()*scale), 
-                  static_cast<int>(y * tileset.get_tile_size()*scale));
-
-      // Use grid in the tileselector
-      //CL_Display::draw_rect(rect, CL_Color(0,0,0,128));
-    }
-
-    if (brush.get_width() == 1 && brush.get_height() == 1
-        && brush.at(0, 0) == tiles[i])
-    {
-      CL_Display::fill_rect(rect,
-                            CL_Color(0,0,255, 100));
-    }
-    else if (mouse_over_tile == int(i) && has_mouse_over())
-    {
-      CL_Display::fill_rect(rect, CL_Color(0,0,255, 20));
-    }
-  }
-
-  if (region_select)
-  {
-    CL_Rect rect = get_selection();
-
-    rect.top    *= static_cast<int>(tileset.get_tile_size()*scale);
-    rect.bottom *= static_cast<int>(tileset.get_tile_size()*scale);
-    rect.left   *= static_cast<int>(tileset.get_tile_size()*scale);
-    rect.right  *= static_cast<int>(tileset.get_tile_size()*scale);
-
-    CL_Display::fill_rect(rect, CL_Color(0,0,255, 100));
-  }
-  
-  CL_Display::pop_modelview();
-  CL_Display::pop_cliprect();
-}
-
-void
-TileSelector::set_scale(float s)
-{
-  scale = s;
-  width  = static_cast<int>(get_width()/(tileset.get_tile_size() * scale));
-}
-
-TileSelector::Tiles
-TileSelector::get_tiles() const
-{
-  return tiles;
-}
-
-void
-TileSelector::set_tileset(Tileset t)
-{
-  tileset = t;
-  // Recalc the number of tiles in a row
-  width  = static_cast<int>(get_width()/(tileset.get_tile_size() * scale));
-}
-
-void
-TileSelector::set_tiles(const Tiles& t)
-{
-  tiles = t;
-  offset = 0;
-}
-
-/* EOF */

Deleted: trunk/flexlay/lib/tile_selector.hpp
===================================================================
--- trunk/flexlay/lib/tile_selector.hpp	2009-11-22 14:40:18 UTC (rev 728)
+++ trunk/flexlay/lib/tile_selector.hpp	2009-11-22 14:44:03 UTC (rev 729)
@@ -1,79 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2000 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_FLEXLAY_TILE_SELECTOR_HPP
-#define HEADER_FLEXLAY_TILE_SELECTOR_HPP
-
-#include <ClanLib/gui.h>
-#include "tileset.hpp"
-
-class Tileset;
-
-class TileSelector : public CL_Component
-{
-public:
-  typedef std::vector<int> Tiles;
-  
-private:
-  CL_SlotContainer slots;
-  int width;
-  int index;
-  
-  int offset;
-  int old_offset;
-  int mouse_over_tile;
-  bool scrolling;
-  bool region_select;
-  CL_Point current_pos;
-  CL_Point region_select_start;
-  CL_Point mouse_pos;
-  float scale;
-  
-  /** set of tiles that should be available in the TileSelector */
-  Tiles tiles;
-
-  Tileset tileset;
-
-protected:
-  virtual ~TileSelector();
-public:
-  /** width and height in number of tiles */
-  TileSelector(const CL_Rect& rect, CL_Component* parent);
-  
-  void set_tileset(Tileset t);
-  void set_tiles(const Tiles& t);
-  Tiles get_tiles() const;
-  
-  /** Set the factor by which tiles are scaled down in the selector
-      widged (ie. for better overview) */
-  void set_scale(float s);
-
-  void draw();
-
-  /** Return the position of the mouse in x/y in tilesize */
-  CL_Point get_mouse_tile_pos(const CL_InputEvent& event);
-
-private:
-  CL_Rect get_selection();
-
-  void mouse_move(const CL_InputEvent& event);
-  void mouse_down(const CL_InputEvent& event);
-  void mouse_up  (const CL_InputEvent& event);
-};
-
-#endif
-
-/* EOF */



From grumbel at mail.berlios.de  Sun Nov 22 15:45:43 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 22 Nov 2009 15:45:43 +0100
Subject: [Flexlay-commit] r730 - in trunk/flexlay/lib: . gui
Message-ID: <200911221445.nAMEjhJq010039@sheep.berlios.de>

Author: grumbel
Date: 2009-11-22 15:45:43 +0100 (Sun, 22 Nov 2009)
New Revision: 730

Added:
   trunk/flexlay/lib/gui/menu.cpp
   trunk/flexlay/lib/gui/menu.hpp
   trunk/flexlay/lib/gui/tile_selector.cpp
   trunk/flexlay/lib/gui/tile_selector.hpp
Removed:
   trunk/flexlay/lib/menu.cpp
   trunk/flexlay/lib/menu.hpp
Modified:
   trunk/flexlay/lib/flexlay_wrap.i
Log:
Moved CL_Component classes to gui/


Modified: trunk/flexlay/lib/flexlay_wrap.i
===================================================================
--- trunk/flexlay/lib/flexlay_wrap.i	2009-11-22 14:44:03 UTC (rev 729)
+++ trunk/flexlay/lib/flexlay_wrap.i	2009-11-22 14:45:43 UTC (rev 730)
@@ -46,14 +46,14 @@
 #include "flexlay.hpp"
 #include "globals.hpp"
 #include "gui_manager.hpp"
-#include "tile_selector.hpp"
+#include "gui/tile_selector.hpp"
 #include "object_brush.hpp"
 #include "gui/object_selector.hpp"
 #include "gui/icon.hpp"
 #include "gui/window.hpp"
 #include "gui/panel.hpp"
 #include "gui/directory_view.hpp"
-#include "menu.hpp"
+#include "gui/menu.hpp"
 #include "gui/menubar.hpp"
 #include "gui/scrollbar.hpp"
 #include "graphic_context_state.hpp"
@@ -160,7 +160,7 @@
 %include "flexlay.hpp"
 %include "globals.hpp"
 %include "gui_manager.hpp"
-%include "tile_selector.hpp"
+%include "gui/tile_selector.hpp"
 %include "object_brush.hpp"
 %include "gui/object_selector.hpp"
 %include "gui/icon.hpp"
@@ -168,7 +168,7 @@
 %include "gui/panel.hpp"
 %include "gui/minimap.hpp"
 %include "gui/directory_view.hpp"
-%include "menu.hpp"
+%include "gui/menu.hpp"
 %include "gui/menubar.hpp"
 %include "gui/scrollbar.hpp"
 

Copied: trunk/flexlay/lib/gui/menu.cpp (from rev 727, trunk/flexlay/lib/menu.cpp)

Copied: trunk/flexlay/lib/gui/menu.hpp (from rev 727, trunk/flexlay/lib/menu.hpp)

Copied: trunk/flexlay/lib/gui/tile_selector.cpp (from rev 728, trunk/flexlay/lib/tile_selector.cpp)

Copied: trunk/flexlay/lib/gui/tile_selector.hpp (from rev 728, trunk/flexlay/lib/tile_selector.hpp)

Deleted: trunk/flexlay/lib/menu.cpp
===================================================================
--- trunk/flexlay/lib/menu.cpp	2009-11-22 14:44:03 UTC (rev 729)
+++ trunk/flexlay/lib/menu.cpp	2009-11-22 14:45:43 UTC (rev 730)
@@ -1,288 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/sprite.h>
-#include "fonts.hpp"
-#include "box.hpp"
-#include "menu.hpp"
-
-class MenuItem;
-
-class MenuImpl
-{
-public:
-  Menu* parent;
-  std::vector<CL_Slot> slots;
-
-  typedef std::vector<MenuItem*> Items;
-  Items items;
-  
-  int current_item;
-
-  int width;
-  int height;
-
-  MenuImpl() {
-    current_item = -1;
-  }
-
-  void draw();
-  void recalc_size();
-  int  get_width();
-  int  get_height();
-
-  void on_mouse_move(const CL_InputEvent& event);
-  void on_mouse_down(const CL_InputEvent& event);
-};
-
-class MenuItem
-{
-protected:
-  MenuImpl* parent;
-  CL_Signal_v0 on_clicked;
-
-public:
-  MenuItem(MenuImpl* parent_) 
-    : parent(parent_) {}
-
-  virtual ~MenuItem() {}
-
-  virtual void draw(int x, int y, bool active) =0;
-  virtual int get_width() =0;
-  virtual int get_height() =0;
-
-  CL_Signal_v0& sig_clicked() { return on_clicked; }
-};
-
-class SeparatorMenuItem : public MenuItem
-{
-public:
-  SeparatorMenuItem(MenuImpl* parent_) 
-    : MenuItem(parent_)
-  {}
-  virtual ~SeparatorMenuItem() {}
-
-  void draw(int x, int y, bool active) 
-  {
-    CL_Display::fill_rect(CL_Rect(CL_Point(x, y), CL_Size(parent->get_width()-7, 2)), 
-                          CL_Color(150, 150, 150));
-    CL_Display::fill_rect(CL_Rect(CL_Point(x, y+1), CL_Size(parent->get_width()-7, 1)),
-                          CL_Color(255, 255, 255));
-  }
-
-  int get_width()  { return 10; }
-  int get_height() { return 2; }
-};
-
-class TextMenuItem : public MenuItem
-{
-private:
-  CL_Sprite sprite;
-  std::string text;
-
-public:
-  TextMenuItem(const CL_Sprite& sprite_, const std::string& text_, MenuImpl* parent_)
-    : MenuItem(parent_),
-      sprite(sprite_),
-      text(text_) 
-  {
-    if (sprite)
-      sprite.set_alignment(origin_center);
-  }
-
-  virtual ~TextMenuItem() {}
-
-  void draw(int x, int y, bool active) {
-    if (active)
-      CL_Display::fill_rect(CL_Rect(CL_Point(x, y-2), CL_Size(parent->get_width() - 7, 18)), 
-                            CL_Color(255, 255, 255));
-    if (sprite)
-    {
-      sprite.draw(x+10, y+7);
-    }
-    Fonts::verdana11.draw(x+24, y, text);
-  }
-  int get_width()  { return Fonts::verdana11.bounding_rect(0, 0, text).get_width() + 16; }
-  int get_height() { return Fonts::verdana11.get_height(); }
-};
-
-Menu::Menu(const CL_Point& pos, CL_Component* parent)
-  : CL_Component(CL_Rect(pos, CL_Size(1,1)), parent),
-    impl(new MenuImpl())
-{
-  impl->parent = this;
-
-  impl->width  = 1;
-  impl->height = 1;
-
-  impl->slots.push_back(sig_paint().connect(impl.get(), &MenuImpl::draw));
-  impl->slots.push_back(sig_mouse_move().connect(impl.get(), &MenuImpl::on_mouse_move));
-  impl->slots.push_back(sig_mouse_down().connect(impl.get(), &MenuImpl::on_mouse_down));
-
-  show(false);
-}
-
-Menu::~Menu()
-{
-  clear();
-}
-
-void
-Menu::clear()
-{
-  for(MenuImpl::Items::iterator i = impl->items.begin(); i != impl->items.end(); ++i)
-    delete *i;
-  impl->items.clear();
-}
-
-MenuItemHandle
-Menu::add_separator()
-{
-  impl->items.push_back(new SeparatorMenuItem(impl.get()));
-  impl->recalc_size();
-  return impl->items.size()-1;
-}
-
-MenuItemHandle
-Menu::add_item(const std::string& name)
-{
-  impl->items.push_back(new TextMenuItem(CL_Sprite(), name, impl.get()));
-  impl->recalc_size();
-  return impl->items.size()-1;
-}
-
-MenuItemHandle
-Menu::add_item(const CL_Sprite& sprite, const std::string& name)
-{
-  impl->items.push_back(new TextMenuItem(sprite, name, impl.get()));
-  impl->recalc_size();
-  return impl->items.size()-1;
-}
-
-MenuItemHandle
-Menu::add_submenu(const std::string& name, const Menu& submenu)
-{
-  impl->recalc_size();
-  return -1;
-}
-
-void
-MenuImpl::recalc_size()
-{
-  height = 0;
-  width = 0;
-
-  for(Items::iterator i = items.begin(); i != items.end(); ++i)
-    width = std::max(width, (*i)->get_width());
-
-  for(Items::iterator i = items.begin(); i != items.end(); ++i)
-    height += (*i)->get_height() + 6;
-  
-  width  += 12 + 24;
-  height += 8;
-
-  parent->set_size(width, height);
-}
-
-void
-MenuImpl::draw()
-{
-  CL_Display::push_translate(parent->get_screen_x(), parent->get_screen_y());
-
-  Box::draw_window(CL_Rect(CL_Point(0, 0), 
-                           CL_Size(parent->get_width(),
-                                   parent->get_height())));
-  int x_pos = 3;
-  int y_pos = 6;
-
-  for(int i = 0; i < int(items.size()); ++i)
-  {
-    if (i == current_item)
-      items[i]->draw(x_pos, y_pos, true);
-    else
-      items[i]->draw(x_pos, y_pos, false);
-    y_pos += items[i]->get_height() + 6;
-  }
-  CL_Display::pop_modelview();
-}
-
-int
-MenuImpl::get_width()
-{
-  return width;
-}
-
-int
-MenuImpl::get_height()
-{
-  return height;
-}
-
-void
-MenuImpl::on_mouse_down(const CL_InputEvent& event)
-{
-  if (current_item != -1)
-  {
-    items[current_item]->sig_clicked()();
-  }
-  parent->release_mouse();
-  parent->show(false);
-}
-
-void
-MenuImpl::on_mouse_move(const CL_InputEvent& event)
-{
-  if (parent->has_mouse_over())
-  {
-    int y_pos = 6;
-
-    for(int i = 0; i < int(items.size()); ++i)
-    {
-      y_pos += items[i]->get_height() + 6;      
-      if (y_pos > event.mouse_pos.y)
-      {
-        current_item = i;
-        return;
-      }
-    }
-    current_item = -1;
-  }
-  else
-  {
-    current_item = -1;
-  }
-}
-
-CL_Signal_v0&
-Menu::sig_clicked(MenuItemHandle item)
-{
-  return impl->items[item]->sig_clicked();
-}
-
-void
-Menu::run()
-{
-  // FIXME: Make menu act sane on == 0 items
-  if (impl->items.size() > 0)
-  {
-    show(true);
-    capture_mouse();
-    raise();
-  }
-}
-
-/* EOF */

Deleted: trunk/flexlay/lib/menu.hpp
===================================================================
--- trunk/flexlay/lib/menu.hpp	2009-11-22 14:44:03 UTC (rev 729)
+++ trunk/flexlay/lib/menu.hpp	2009-11-22 14:45:43 UTC (rev 730)
@@ -1,53 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_FLEXLAY_MENU_HPP
-#define HEADER_FLEXLAY_MENU_HPP
-
-#include <ClanLib/GUI/component.h>
-#include <boost/shared_ptr.hpp>
-
-class MenuImpl;
-class CL_Sprite;
-
-typedef int MenuItemHandle;
-
-/** */
-class Menu : public CL_Component
-{
-protected:
-  virtual ~Menu();
-
-public:
-  Menu(const CL_Point& pos, CL_Component* parent);
-
-  void clear();
-
-  MenuItemHandle add_item(const std::string& name);
-  MenuItemHandle add_item(const CL_Sprite& sprite, const std::string& name);
-  MenuItemHandle add_submenu(const std::string& name, const Menu& submenu);
-  MenuItemHandle add_separator();
-
-  CL_Signal_v0& sig_clicked(MenuItemHandle item);
-
-  void run();
-private:
-  boost::shared_ptr<MenuImpl> impl;
-};
-
-#endif
-
-/* EOF */



From grumbel at mail.berlios.de  Sun Nov 22 16:06:30 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 22 Nov 2009 16:06:30 +0100
Subject: [Flexlay-commit] r731 - in trunk/flexlay/lib: . tools
Message-ID: <200911221506.nAMF6UnO012401@sheep.berlios.de>

Author: grumbel
Date: 2009-11-22 16:06:30 +0100 (Sun, 22 Nov 2009)
New Revision: 731

Modified:
   trunk/flexlay/lib/object_add_command.cpp
   trunk/flexlay/lib/tools/layer_move_tool.cpp
   trunk/flexlay/lib/tools/layer_move_tool.hpp
   trunk/flexlay/lib/tools/objmap_select_tool.hpp
   trunk/flexlay/lib/tools/sketch_stroke_tool.hpp
   trunk/flexlay/lib/tools/tilemap_paint_tool.hpp
   trunk/flexlay/lib/tools/tilemap_select_tool.hpp
   trunk/flexlay/lib/tools/tool.hpp
   trunk/flexlay/lib/tools/tool_impl.hpp
   trunk/flexlay/lib/tools/workspace_move_tool.hpp
   trunk/flexlay/lib/tools/zoom2_tool.hpp
   trunk/flexlay/lib/tools/zoom_tool.hpp
Log:
Copyright header updates


Modified: trunk/flexlay/lib/object_add_command.cpp
===================================================================
--- trunk/flexlay/lib/object_add_command.cpp	2009-11-22 14:45:43 UTC (rev 730)
+++ trunk/flexlay/lib/object_add_command.cpp	2009-11-22 15:06:30 UTC (rev 731)
@@ -14,9 +14,10 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include "object_layer.hpp"
 #include "object_add_command.hpp"
 
+#include "object_layer.hpp"
+
 class ObjectAddCommandImpl : public CommandImpl
 {
 public:

Modified: trunk/flexlay/lib/tools/layer_move_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/layer_move_tool.cpp	2009-11-22 14:45:43 UTC (rev 730)
+++ trunk/flexlay/lib/tools/layer_move_tool.cpp	2009-11-22 15:06:30 UTC (rev 731)
@@ -1,19 +1,18 @@
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2004 Ingo Ruhnke <grumbel at gmx.de>
 //
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
 //  This program is distributed in the hope that it will be useful,
 //  but WITHOUT ANY WARRANTY; without even the implied warranty of
 //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 //  GNU General Public License for more details.
-// 
+//  
 //  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "layer_move_tool.hpp"
 

Modified: trunk/flexlay/lib/tools/layer_move_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/layer_move_tool.hpp	2009-11-22 14:45:43 UTC (rev 730)
+++ trunk/flexlay/lib/tools/layer_move_tool.hpp	2009-11-22 15:06:30 UTC (rev 731)
@@ -1,19 +1,18 @@
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2004 Ingo Ruhnke <grumbel at gmx.de>
 //
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
 //  This program is distributed in the hope that it will be useful,
 //  but WITHOUT ANY WARRANTY; without even the implied warranty of
 //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 //  GNU General Public License for more details.
-// 
+//  
 //  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #ifndef HEADER_FLEXLAY_TOOLS_LAYER_MOVE_TOOL_HPP
 #define HEADER_FLEXLAY_TOOLS_LAYER_MOVE_TOOL_HPP

Modified: trunk/flexlay/lib/tools/objmap_select_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/objmap_select_tool.hpp	2009-11-22 14:45:43 UTC (rev 730)
+++ trunk/flexlay/lib/tools/objmap_select_tool.hpp	2009-11-22 15:06:30 UTC (rev 731)
@@ -1,19 +1,18 @@
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
 //  This program is distributed in the hope that it will be useful,
 //  but WITHOUT ANY WARRANTY; without even the implied warranty of
 //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 //  GNU General Public License for more details.
-// 
+//  
 //  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #ifndef HEADER_FLEXLAY_TOOLS_OBJMAP_SELECT_TOOL_HPP
 #define HEADER_FLEXLAY_TOOLS_OBJMAP_SELECT_TOOL_HPP

Modified: trunk/flexlay/lib/tools/sketch_stroke_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/sketch_stroke_tool.hpp	2009-11-22 14:45:43 UTC (rev 730)
+++ trunk/flexlay/lib/tools/sketch_stroke_tool.hpp	2009-11-22 15:06:30 UTC (rev 731)
@@ -1,19 +1,18 @@
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
 //  This program is distributed in the hope that it will be useful,
 //  but WITHOUT ANY WARRANTY; without even the implied warranty of
 //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 //  GNU General Public License for more details.
-// 
+//  
 //  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #ifndef HEADER_FLEXLAY_TOOLS_SKETCH_STROKE_TOOL_HPP
 #define HEADER_FLEXLAY_TOOLS_SKETCH_STROKE_TOOL_HPP

Modified: trunk/flexlay/lib/tools/tilemap_paint_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/tilemap_paint_tool.hpp	2009-11-22 14:45:43 UTC (rev 730)
+++ trunk/flexlay/lib/tools/tilemap_paint_tool.hpp	2009-11-22 15:06:30 UTC (rev 731)
@@ -1,19 +1,18 @@
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
 //  This program is distributed in the hope that it will be useful,
 //  but WITHOUT ANY WARRANTY; without even the implied warranty of
 //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 //  GNU General Public License for more details.
-// 
+//  
 //  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #ifndef HEADER_FLEXLAY_TOOLS_TILEMAP_PAINT_TOOL_HPP
 #define HEADER_FLEXLAY_TOOLS_TILEMAP_PAINT_TOOL_HPP

Modified: trunk/flexlay/lib/tools/tilemap_select_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/tilemap_select_tool.hpp	2009-11-22 14:45:43 UTC (rev 730)
+++ trunk/flexlay/lib/tools/tilemap_select_tool.hpp	2009-11-22 15:06:30 UTC (rev 731)
@@ -1,19 +1,18 @@
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
 //  This program is distributed in the hope that it will be useful,
 //  but WITHOUT ANY WARRANTY; without even the implied warranty of
 //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 //  GNU General Public License for more details.
-// 
+//  
 //  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #ifndef HEADER_FLEXLAY_TOOLS_TILEMAP_SELECT_TOOL_HPP
 #define HEADER_FLEXLAY_TOOLS_TILEMAP_SELECT_TOOL_HPP

Modified: trunk/flexlay/lib/tools/tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/tool.hpp	2009-11-22 14:45:43 UTC (rev 730)
+++ trunk/flexlay/lib/tools/tool.hpp	2009-11-22 15:06:30 UTC (rev 731)
@@ -1,19 +1,18 @@
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
 //  This program is distributed in the hope that it will be useful,
 //  but WITHOUT ANY WARRANTY; without even the implied warranty of
 //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 //  GNU General Public License for more details.
-// 
+//  
 //  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #ifndef HEADER_FLEXLAY_TOOLS_TOOL_HPP
 #define HEADER_FLEXLAY_TOOLS_TOOL_HPP

Modified: trunk/flexlay/lib/tools/tool_impl.hpp
===================================================================
--- trunk/flexlay/lib/tools/tool_impl.hpp	2009-11-22 14:45:43 UTC (rev 730)
+++ trunk/flexlay/lib/tools/tool_impl.hpp	2009-11-22 15:06:30 UTC (rev 731)
@@ -1,19 +1,18 @@
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
 //  This program is distributed in the hope that it will be useful,
 //  but WITHOUT ANY WARRANTY; without even the implied warranty of
 //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 //  GNU General Public License for more details.
-// 
+//  
 //  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #ifndef HEADER_FLEXLAY_TOOLS_TOOL_IMPL_HPP
 #define HEADER_FLEXLAY_TOOLS_TOOL_IMPL_HPP

Modified: trunk/flexlay/lib/tools/workspace_move_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/workspace_move_tool.hpp	2009-11-22 14:45:43 UTC (rev 730)
+++ trunk/flexlay/lib/tools/workspace_move_tool.hpp	2009-11-22 15:06:30 UTC (rev 731)
@@ -1,19 +1,18 @@
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
 //  This program is distributed in the hope that it will be useful,
 //  but WITHOUT ANY WARRANTY; without even the implied warranty of
 //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 //  GNU General Public License for more details.
-// 
+//  
 //  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #ifndef HEADER_FLEXLAY_TOOLS_WORKSPACE_MOVE_TOOL_HPP
 #define HEADER_FLEXLAY_TOOLS_WORKSPACE_MOVE_TOOL_HPP

Modified: trunk/flexlay/lib/tools/zoom2_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/zoom2_tool.hpp	2009-11-22 14:45:43 UTC (rev 730)
+++ trunk/flexlay/lib/tools/zoom2_tool.hpp	2009-11-22 15:06:30 UTC (rev 731)
@@ -1,19 +1,18 @@
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
 //  This program is distributed in the hope that it will be useful,
 //  but WITHOUT ANY WARRANTY; without even the implied warranty of
 //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 //  GNU General Public License for more details.
-// 
+//  
 //  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #ifndef HEADER_FLEXLAY_TOOLS_ZOOM2_TOOL_HPP
 #define HEADER_FLEXLAY_TOOLS_ZOOM2_TOOL_HPP

Modified: trunk/flexlay/lib/tools/zoom_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/zoom_tool.hpp	2009-11-22 14:45:43 UTC (rev 730)
+++ trunk/flexlay/lib/tools/zoom_tool.hpp	2009-11-22 15:06:30 UTC (rev 731)
@@ -1,19 +1,18 @@
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
 //  This program is distributed in the hope that it will be useful,
 //  but WITHOUT ANY WARRANTY; without even the implied warranty of
 //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 //  GNU General Public License for more details.
-// 
+//  
 //  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #ifndef HEADER_FLEXLAY_TOOLS_ZOOM_TOOL_HPP
 #define HEADER_FLEXLAY_TOOLS_ZOOM_TOOL_HPP



From grumbel at mail.berlios.de  Sun Nov 22 19:37:26 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 22 Nov 2009 19:37:26 +0100
Subject: [Flexlay-commit] r732 - in trunk/flexlay/lib: . gui tools
Message-ID: <200911221837.nAMIbQmn009513@sheep.berlios.de>

Author: grumbel
Date: 2009-11-22 19:37:23 +0100 (Sun, 22 Nov 2009)
New Revision: 732

Modified:
   trunk/flexlay/lib/bitmap_layer.cpp
   trunk/flexlay/lib/bitmap_layer.hpp
   trunk/flexlay/lib/box.cpp
   trunk/flexlay/lib/box.hpp
   trunk/flexlay/lib/brush_impl.hpp
   trunk/flexlay/lib/command.cpp
   trunk/flexlay/lib/command_group.hpp
   trunk/flexlay/lib/drawer_properties.hpp
   trunk/flexlay/lib/editor_map.cpp
   trunk/flexlay/lib/editor_map.hpp
   trunk/flexlay/lib/fonts.hpp
   trunk/flexlay/lib/generated_brush.cpp
   trunk/flexlay/lib/generated_brush.hpp
   trunk/flexlay/lib/graphic_context_state.hpp
   trunk/flexlay/lib/gui/colorpicker.hpp
   trunk/flexlay/lib/gui/console.hpp
   trunk/flexlay/lib/gui/directory_view.hpp
   trunk/flexlay/lib/gui/icon.hpp
   trunk/flexlay/lib/gui/menu.hpp
   trunk/flexlay/lib/gui/menubar.hpp
   trunk/flexlay/lib/gui/minimap.hpp
   trunk/flexlay/lib/gui/object_selector.cpp
   trunk/flexlay/lib/gui/object_selector.hpp
   trunk/flexlay/lib/gui/panel.hpp
   trunk/flexlay/lib/gui/scrollbar.hpp
   trunk/flexlay/lib/gui/tile_editor.hpp
   trunk/flexlay/lib/gui/tile_selection.cpp
   trunk/flexlay/lib/gui/tile_selector.cpp
   trunk/flexlay/lib/gui/tile_selector.hpp
   trunk/flexlay/lib/gui/titlebar.hpp
   trunk/flexlay/lib/gui/viewport.hpp
   trunk/flexlay/lib/gui/window.hpp
   trunk/flexlay/lib/gui_manager.hpp
   trunk/flexlay/lib/layer.cpp
   trunk/flexlay/lib/layer.hpp
   trunk/flexlay/lib/lispreader.hpp
   trunk/flexlay/lib/marker_stroke_drawer.hpp
   trunk/flexlay/lib/meta_data.hpp
   trunk/flexlay/lib/meta_data_impl.hpp
   trunk/flexlay/lib/object_brush.cpp
   trunk/flexlay/lib/object_layer.hpp
   trunk/flexlay/lib/object_move_command.hpp
   trunk/flexlay/lib/object_transform_command.hpp
   trunk/flexlay/lib/objmap_control_point.hpp
   trunk/flexlay/lib/objmap_object.hpp
   trunk/flexlay/lib/objmap_path_node.hpp
   trunk/flexlay/lib/objmap_rect_object.cpp
   trunk/flexlay/lib/objmap_sprite_object.hpp
   trunk/flexlay/lib/popup_menu.hpp
   trunk/flexlay/lib/sprite_stroke_drawer.cpp
   trunk/flexlay/lib/sprite_stroke_drawer.hpp
   trunk/flexlay/lib/tile.cpp
   trunk/flexlay/lib/tile_brush.hpp
   trunk/flexlay/lib/tilemap_layer.cpp
   trunk/flexlay/lib/tilemap_layer.hpp
   trunk/flexlay/lib/tilemap_minimap.hpp
   trunk/flexlay/lib/tools/layer_move_tool.hpp
   trunk/flexlay/lib/tools/objmap_select_tool.cpp
   trunk/flexlay/lib/tools/objmap_select_tool.hpp
   trunk/flexlay/lib/tools/sketch_stroke_tool.cpp
   trunk/flexlay/lib/tools/sketch_stroke_tool.hpp
   trunk/flexlay/lib/tools/tilemap_paint_tool.cpp
   trunk/flexlay/lib/tools/tilemap_paint_tool.hpp
   trunk/flexlay/lib/tools/tilemap_select_tool.cpp
   trunk/flexlay/lib/tools/tilemap_select_tool.hpp
   trunk/flexlay/lib/tools/tool.cpp
   trunk/flexlay/lib/tools/tool.hpp
   trunk/flexlay/lib/tools/tool_impl.hpp
   trunk/flexlay/lib/tools/workspace_move_tool.cpp
   trunk/flexlay/lib/tools/workspace_move_tool.hpp
   trunk/flexlay/lib/tools/zoom2_tool.cpp
   trunk/flexlay/lib/tools/zoom2_tool.hpp
   trunk/flexlay/lib/tools/zoom_tool.cpp
   trunk/flexlay/lib/tools/zoom_tool.hpp
   trunk/flexlay/lib/workspace.hpp
Log:
Further include and Copyright cleanup


Modified: trunk/flexlay/lib/bitmap_layer.cpp
===================================================================
--- trunk/flexlay/lib/bitmap_layer.cpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/bitmap_layer.cpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -14,24 +14,13 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include <iostream>
-#include <assert.h>
+#include "bitmap_layer.hpp"
+
 #include <ClanLib/gl.h>
-#include <ClanLib/Core/core_iostream.h>
 #include <ClanLib/Core/System/error.h>
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/sprite.h>
-#include <ClanLib/Display/pixel_buffer.h>
 #include <ClanLib/Display/canvas.h>
-#include <ClanLib/Display/blend_func.h>
-#include <ClanLib/Display/graphic_context.h>
-#include <ClanLib/Display/display_window.h>
 
-#include "flexlay.hpp"
-#include "layer_impl.hpp"
-#include "bitmap_layer.hpp"
 #include "objmap_object_impl.hpp"
-#include "math.hpp"
 
 BitmapLayer* BitmapLayer::current_ = 0;
 

Modified: trunk/flexlay/lib/bitmap_layer.hpp
===================================================================
--- trunk/flexlay/lib/bitmap_layer.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/bitmap_layer.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -17,14 +17,11 @@
 #ifndef HEADER_FLEXLAY_BITMAP_LAYER_HPP
 #define HEADER_FLEXLAY_BITMAP_LAYER_HPP
 
-#include <vector>
-#include <ClanLib/Core/Math/point.h>
-#include <ClanLib/Display/color.h>
 #include "objmap_object.hpp"
-#include "layer.hpp"
 #include "stroke.hpp"
 
 class BitmapLayerImpl;
+class CL_Canvas;
 
 /** This layer holds a simple bitmap, size and color format are
     configurable, it works similar to the SketchLayer, however it

Modified: trunk/flexlay/lib/box.cpp
===================================================================
--- trunk/flexlay/lib/box.cpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/box.cpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -14,9 +14,10 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include <ClanLib/Display/display.h>
 #include "box.hpp"
 
+#include <ClanLib/Display/display.h>
+
 CL_Color background   (210, 210, 210);
 CL_Color background_hl(240, 240, 240);
 CL_Color background_sw(200, 200, 200);

Modified: trunk/flexlay/lib/box.hpp
===================================================================
--- trunk/flexlay/lib/box.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/box.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -17,6 +17,7 @@
 #ifndef HEADER_FLEXLAY_BOX_HPP
 #define HEADER_FLEXLAY_BOX_HPP
 
+class CL_Rect;
 
 /** Little helper class to draw boxes and stuff in the GUI */
 class Box

Modified: trunk/flexlay/lib/brush_impl.hpp
===================================================================
--- trunk/flexlay/lib/brush_impl.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/brush_impl.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -19,7 +19,6 @@
 
 #include <ClanLib/Display/sprite.h>
 
-/** */
 class BrushImpl
 {
 public:

Modified: trunk/flexlay/lib/command.cpp
===================================================================
--- trunk/flexlay/lib/command.cpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/command.cpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -14,7 +14,6 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include <string>
 #include "command.hpp"
 
 Command::Command()

Modified: trunk/flexlay/lib/command_group.hpp
===================================================================
--- trunk/flexlay/lib/command_group.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/command_group.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -20,7 +20,6 @@
 #include <vector>
 #include "command.hpp"
 
-/** */
 class CommandGroup
 {
 private:

Modified: trunk/flexlay/lib/drawer_properties.hpp
===================================================================
--- trunk/flexlay/lib/drawer_properties.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/drawer_properties.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -21,7 +21,6 @@
 
 class DrawerPropertiesImpl;
 
-/** */
 class DrawerProperties
 {
 private:

Modified: trunk/flexlay/lib/editor_map.cpp
===================================================================
--- trunk/flexlay/lib/editor_map.cpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/editor_map.cpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -17,10 +17,10 @@
 #include "editor_map.hpp"
 
 #include <iostream>
-#include <ClanLib/Display/color.h>
 #include <ClanLib/Display/graphic_context.h>
-#include <ClanLib/signals.h>
 
+#include "meta_data.hpp"
+
 class EditorMapImpl
 {
 public:

Modified: trunk/flexlay/lib/editor_map.hpp
===================================================================
--- trunk/flexlay/lib/editor_map.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/editor_map.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -18,11 +18,9 @@
 #define HEADER_FLEXLAY_EDITOR_MAP_HPP
 
 #include <ClanLib/Core/Math/rect.h>
-#include <ClanLib/Core/System/sharedptr.h>
 #include <ClanLib/Display/color.h>
 
 #include "layer.hpp"
-#include "meta_data.hpp"
 #include "command.hpp"
 
 class CL_GraphicContext;

Modified: trunk/flexlay/lib/fonts.hpp
===================================================================
--- trunk/flexlay/lib/fonts.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/fonts.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -19,7 +19,6 @@
 
 #include <ClanLib/Display/font.h>
 
-/** */
 class Fonts
 {
 public:

Modified: trunk/flexlay/lib/generated_brush.cpp
===================================================================
--- trunk/flexlay/lib/generated_brush.cpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/generated_brush.cpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -14,9 +14,10 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include <ClanLib/Display/sprite_description.h>
 #include "generated_brush.hpp"
 
+#include <ClanLib/Display/sprite_description.h>
+
 class GeneratedBrushImpl : public BrushImpl
 {
 public:

Modified: trunk/flexlay/lib/generated_brush.hpp
===================================================================
--- trunk/flexlay/lib/generated_brush.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/generated_brush.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -22,7 +22,6 @@
 
 class GeneratedBrushImpl;
 
-/** */
 class GeneratedBrush
 {
 private:

Modified: trunk/flexlay/lib/graphic_context_state.hpp
===================================================================
--- trunk/flexlay/lib/graphic_context_state.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/graphic_context_state.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -17,7 +17,6 @@
 #ifndef HEADER_FLEXLAY_GRAPHIC_CONTEXT_STATE_HPP
 #define HEADER_FLEXLAY_GRAPHIC_CONTEXT_STATE_HPP
 
-#include <ClanLib/Core/Math/point.h>
 #include <ClanLib/Core/Math/rect.h>
 #include <boost/shared_ptr.hpp>
 

Modified: trunk/flexlay/lib/gui/colorpicker.hpp
===================================================================
--- trunk/flexlay/lib/gui/colorpicker.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/gui/colorpicker.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -23,7 +23,6 @@
 class ColorPickerAlpha;
 class ColorPickerBrightness;
 
-/** */
 class ColorPicker : public CL_Component
 {
 protected:

Modified: trunk/flexlay/lib/gui/console.hpp
===================================================================
--- trunk/flexlay/lib/gui/console.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/gui/console.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -24,7 +24,6 @@
 class CL_Size;
 class ConsoleImpl;
 
-/** */
 class Console : public CL_Component
 {
 protected:

Modified: trunk/flexlay/lib/gui/directory_view.hpp
===================================================================
--- trunk/flexlay/lib/gui/directory_view.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/gui/directory_view.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -22,7 +22,6 @@
 
 class DirectoryViewImpl;
 
-/** */
 class DirectoryView : public CL_Component
 {
 private:

Modified: trunk/flexlay/lib/gui/icon.hpp
===================================================================
--- trunk/flexlay/lib/gui/icon.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/gui/icon.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -23,7 +23,6 @@
 
 class IconImpl;
 
-/** */
 class Icon : public CL_Component
 {
 protected:

Modified: trunk/flexlay/lib/gui/menu.hpp
===================================================================
--- trunk/flexlay/lib/gui/menu.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/gui/menu.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -25,7 +25,6 @@
 
 typedef int MenuItemHandle;
 
-/** */
 class Menu : public CL_Component
 {
 protected:

Modified: trunk/flexlay/lib/gui/menubar.hpp
===================================================================
--- trunk/flexlay/lib/gui/menubar.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/gui/menubar.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -23,7 +23,6 @@
 class Menu;
 class MenubarImpl;
 
-/** */
 class Menubar : public CL_Component
 {
 protected:

Modified: trunk/flexlay/lib/gui/minimap.hpp
===================================================================
--- trunk/flexlay/lib/gui/minimap.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/gui/minimap.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -25,7 +25,6 @@
 class MinimapImpl;
 class EditorMapComponent;
 
-/** */
 class Minimap : public CL_Component
 {
 protected:

Modified: trunk/flexlay/lib/gui/object_selector.cpp
===================================================================
--- trunk/flexlay/lib/gui/object_selector.cpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/gui/object_selector.cpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -17,7 +17,7 @@
 #include <iostream>
 #include <ClanLib/Core/core_iostream.h>
 #include <ClanLib/display.h>
-#include "editor_map.hpp"
+//#include "editor_map.hpp"
 #include "editor_map_component.hpp"
 #include "object_selector.hpp"
 #include "object_add_command.hpp"

Modified: trunk/flexlay/lib/gui/object_selector.hpp
===================================================================
--- trunk/flexlay/lib/gui/object_selector.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/gui/object_selector.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -17,11 +17,8 @@
 #ifndef HEADER_FLEXLAY_OBJECT_SELECTOR_HPP
 #define HEADER_FLEXLAY_OBJECT_SELECTOR_HPP
 
-#include <ClanLib/GUI/component.h>
-#include <ClanLib/GUI/component.h>
 #include "object_brush.hpp"
 
-/** */
 class ObjectSelector : public CL_Component
 {
 private:

Modified: trunk/flexlay/lib/gui/panel.hpp
===================================================================
--- trunk/flexlay/lib/gui/panel.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/gui/panel.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -22,7 +22,6 @@
 
 class PanelImpl;
 
-/** */
 class Panel : public CL_Component
 {
 public:

Modified: trunk/flexlay/lib/gui/scrollbar.hpp
===================================================================
--- trunk/flexlay/lib/gui/scrollbar.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/gui/scrollbar.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -22,7 +22,6 @@
 
 class ScrollbarImpl;
 
-/** */
 class Scrollbar : public CL_Component
 {
 protected:

Modified: trunk/flexlay/lib/gui/tile_editor.hpp
===================================================================
--- trunk/flexlay/lib/gui/tile_editor.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/gui/tile_editor.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -21,7 +21,6 @@
 
 class Tile;
 
-/** */
 class TileEditor : public CL_Component
 {
 private:

Modified: trunk/flexlay/lib/gui/tile_selection.cpp
===================================================================
--- trunk/flexlay/lib/gui/tile_selection.cpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/gui/tile_selection.cpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -14,11 +14,13 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
+#include "tile_selection.hpp"
+
 #include <ClanLib/Display/display.h>
 #include <iostream>
+
 #include "math.hpp"
 #include "tileset.hpp"
-#include "tile_selection.hpp"
 
 class TileSelectionImpl
 {

Modified: trunk/flexlay/lib/gui/tile_selector.cpp
===================================================================
--- trunk/flexlay/lib/gui/tile_selector.cpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/gui/tile_selector.cpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -18,11 +18,10 @@
 
 #include <iostream>
 #include <ClanLib/display.h>
-#include <ClanLib/core.h>
 
 #include "math.hpp"
-#include "tileset.hpp"
 #include "tile.hpp"
+#include "tile_brush.hpp"
 #include "tools/tilemap_paint_tool.hpp"
 
 TileSelector::TileSelector(const CL_Rect& rect, CL_Component* parent) :

Modified: trunk/flexlay/lib/gui/tile_selector.hpp
===================================================================
--- trunk/flexlay/lib/gui/tile_selector.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/gui/tile_selector.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -18,6 +18,7 @@
 #define HEADER_FLEXLAY_TILE_SELECTOR_HPP
 
 #include <ClanLib/gui.h>
+
 #include "tileset.hpp"
 
 class Tileset;

Modified: trunk/flexlay/lib/gui/titlebar.hpp
===================================================================
--- trunk/flexlay/lib/gui/titlebar.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/gui/titlebar.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -22,7 +22,6 @@
 
 class TitlebarImpl;
 
-/** */
 class Titlebar : public CL_Component
 {
 protected:

Modified: trunk/flexlay/lib/gui/viewport.hpp
===================================================================
--- trunk/flexlay/lib/gui/viewport.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/gui/viewport.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -18,12 +18,9 @@
 #define HEADER_FLEXLAY_VIEWPORT_HPP
 
 #include <ClanLib/GUI/component.h>
-#include <ClanLib/Core/Math/rect.h>
-#include <boost/shared_ptr.hpp>
 
 class ViewportImpl;
 
-/** */
 class Viewport : public CL_Component
 {
 protected:

Modified: trunk/flexlay/lib/gui/window.hpp
===================================================================
--- trunk/flexlay/lib/gui/window.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/gui/window.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -20,7 +20,6 @@
 
 class WindowImpl;
 
-/** */
 class Window : public CL_Component
 {
 protected:

Modified: trunk/flexlay/lib/gui_manager.hpp
===================================================================
--- trunk/flexlay/lib/gui_manager.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/gui_manager.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -21,7 +21,6 @@
 
 class GUIManagerImpl;
 
-/** */
 class GUIManager
 {
 private:

Modified: trunk/flexlay/lib/layer.cpp
===================================================================
--- trunk/flexlay/lib/layer.cpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/layer.cpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -14,9 +14,10 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include "layer_impl.hpp"
 #include "layer.hpp"
 
+#include "layer_impl.hpp"
+
 Layer::Layer() :
   impl()
 {

Modified: trunk/flexlay/lib/layer.hpp
===================================================================
--- trunk/flexlay/lib/layer.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/layer.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -24,6 +24,7 @@
 class CL_Rect;
 class EditorMapComponent;
 class LayerImpl;
+class CL_Pointf;
 class CL_GraphicContext;
 
 /** Each \a EditorMap consists out of one or more \a Layer,

Modified: trunk/flexlay/lib/lispreader.hpp
===================================================================
--- trunk/flexlay/lib/lispreader.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/lispreader.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -175,7 +175,6 @@
 #define lisp_cons_p(obj)     (lisp_type((obj)) == LISP_TYPE_CONS)
 #define lisp_boolean_p(obj)  (lisp_type((obj)) == LISP_TYPE_BOOLEAN)
 
-/** */
 class LispReader
 {
 private:
@@ -196,7 +195,6 @@
   bool read_lisp (const char* name, lisp_object_t** b);
 };
 
-/** */
 class LispWriter
 {
 private:

Modified: trunk/flexlay/lib/marker_stroke_drawer.hpp
===================================================================
--- trunk/flexlay/lib/marker_stroke_drawer.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/marker_stroke_drawer.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -21,7 +21,6 @@
 
 class MarkerStrokeDrawerImpl;
 
-/** */
 class MarkerStrokeDrawer
 {
 private:

Modified: trunk/flexlay/lib/meta_data.hpp
===================================================================
--- trunk/flexlay/lib/meta_data.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/meta_data.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -21,7 +21,6 @@
 
 class MetaDataImpl;
 
-/** */
 class MetaData
 {
 private:

Modified: trunk/flexlay/lib/meta_data_impl.hpp
===================================================================
--- trunk/flexlay/lib/meta_data_impl.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/meta_data_impl.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -17,7 +17,6 @@
 #ifndef HEADER_FLEXLAY_META_DATA_IMPL_HPP
 #define HEADER_FLEXLAY_META_DATA_IMPL_HPP
 
-/** */
 class MetaDataImpl
 {
 private:

Modified: trunk/flexlay/lib/object_brush.cpp
===================================================================
--- trunk/flexlay/lib/object_brush.cpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/object_brush.cpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -14,7 +14,6 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include "objmap_sprite_object.hpp"
 #include "object_brush.hpp"
 
 class ObjectBrushImpl

Modified: trunk/flexlay/lib/object_layer.hpp
===================================================================
--- trunk/flexlay/lib/object_layer.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/object_layer.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -17,8 +17,6 @@
 #ifndef HEADER_FLEXLAY_OBJECT_LAYER_HPP
 #define HEADER_FLEXLAY_OBJECT_LAYER_HPP
 
-#include <ClanLib/Display/sprite.h>
-#include <ClanLib/GUI/component.h>
 #include "meta_data.hpp"
 #include "layer.hpp"
 #include "objmap_object.hpp"

Modified: trunk/flexlay/lib/object_move_command.hpp
===================================================================
--- trunk/flexlay/lib/object_move_command.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/object_move_command.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -24,7 +24,6 @@
 
 class ObjectMoveCommandImpl;
 
-/** */
 class ObjectMoveCommand
 {
 public:

Modified: trunk/flexlay/lib/object_transform_command.hpp
===================================================================
--- trunk/flexlay/lib/object_transform_command.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/object_transform_command.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -22,7 +22,6 @@
 
 class ObjMapObject;
 
-/** */
 class ObjectTransformCommand
 {
 public:

Modified: trunk/flexlay/lib/objmap_control_point.hpp
===================================================================
--- trunk/flexlay/lib/objmap_control_point.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/objmap_control_point.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -18,7 +18,6 @@
 #define HEADER_FLEXLAY_OBJMAP_CONTROL_POINT_HPP
 
 #include <ClanLib/Display/sprite.h>
-#include <boost/shared_ptr.hpp>
 
 #include "meta_data.hpp"
 

Modified: trunk/flexlay/lib/objmap_object.hpp
===================================================================
--- trunk/flexlay/lib/objmap_object.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/objmap_object.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -22,7 +22,6 @@
 
 class ObjMapObjectImpl;
 
-/** */
 class ObjMapObject
 {
 public:

Modified: trunk/flexlay/lib/objmap_path_node.hpp
===================================================================
--- trunk/flexlay/lib/objmap_path_node.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/objmap_path_node.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -20,7 +20,6 @@
 
 class ObjMapPathNodeImpl;
 
-/** */
 class ObjMapPathNode
 {
 public:

Modified: trunk/flexlay/lib/objmap_rect_object.cpp
===================================================================
--- trunk/flexlay/lib/objmap_rect_object.cpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/objmap_rect_object.cpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -14,12 +14,7 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include <iostream>
-#include <ClanLib/Core/core_iostream.h>
-#include <ClanLib/Display/display.h>
-#include <ClanLib/Display/sprite.h>
 #include "object_layer.hpp"
-#include "objmap_control_point.hpp"
 #include "objmap_rect_object.hpp"
 #include "flexlay.hpp"
 

Modified: trunk/flexlay/lib/objmap_sprite_object.hpp
===================================================================
--- trunk/flexlay/lib/objmap_sprite_object.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/objmap_sprite_object.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -20,11 +20,9 @@
 #include <ClanLib/Display/sprite.h>
 #include "objmap_object.hpp"
 
-#include "meta_data.hpp"
 
 class ObjMapSpriteObjectImpl;
 
-/** */
 class ObjMapSpriteObject
 {
 public:

Modified: trunk/flexlay/lib/popup_menu.hpp
===================================================================
--- trunk/flexlay/lib/popup_menu.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/popup_menu.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -19,7 +19,6 @@
 
 #include <ClanLib/GUI/menu.h>
 
-/** */
 class PopupMenu
 {
 private:

Modified: trunk/flexlay/lib/sprite_stroke_drawer.cpp
===================================================================
--- trunk/flexlay/lib/sprite_stroke_drawer.cpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/sprite_stroke_drawer.cpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -14,18 +14,12 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include <iostream>
-#include <assert.h>
-#include <ClanLib/Display/blend_func.h>
 #include <ClanLib/Display/canvas.h>
 #include <ClanLib/gl.h>
-#include <ClanLib/GL/opengl_wrap.h>
-#include "stroke.hpp"
 #include "stroke_drawer_impl.hpp"
 #include "sprite_stroke_drawer.hpp"
 #include "drawer_properties.hpp"
 #include "bitmap_layer.hpp"
-#include "sketch_layer.hpp"
 
 CL_ProgramObject* program = 0;
 

Modified: trunk/flexlay/lib/sprite_stroke_drawer.hpp
===================================================================
--- trunk/flexlay/lib/sprite_stroke_drawer.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/sprite_stroke_drawer.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -22,7 +22,6 @@
 class Stroke;
 class SpriteStrokeDrawerImpl;
 
-/** */
 class SpriteStrokeDrawer
 {
 public:

Modified: trunk/flexlay/lib/tile.cpp
===================================================================
--- trunk/flexlay/lib/tile.cpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/tile.cpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -14,6 +14,8 @@
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
+#include "tile.hpp"
+
 #include <ClanLib/Core/System/error.h>
 #include <ClanLib/Display/sprite_description.h>
 #include <ClanLib/Display/sprite.h>
@@ -21,9 +23,9 @@
 #include <ClanLib/Display/palette.h>
 #include <ClanLib/Display/Providers/provider_factory.h>
 #include <iostream>
+
 #include "string_converter.hpp"
 #include "tile_provider.hpp"
-#include "tile.hpp"
 
 class TileImpl
 {

Modified: trunk/flexlay/lib/tile_brush.hpp
===================================================================
--- trunk/flexlay/lib/tile_brush.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/tile_brush.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -19,7 +19,6 @@
 
 #include "field.hpp"
 
-/** */
 class TileBrush
 {
 private:

Modified: trunk/flexlay/lib/tilemap_layer.cpp
===================================================================
--- trunk/flexlay/lib/tilemap_layer.cpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/tilemap_layer.cpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -16,17 +16,12 @@
 
 #include "tilemap_layer.hpp"
 
-#include <math.h>
 #include <ClanLib/Display/display.h>
-#include <ClanLib/Display/pixel_buffer.h>
 #include <ClanLib/Display/pixel_format.h>
-#include <ClanLib/Display/palette.h>
 #include <ClanLib/Display/sprite.h>
-#include <ClanLib/gl.h>
 
 #include "tile.hpp"
 #include "tileset.hpp"
-#include "editor_map.hpp"
 #include "tile_brush.hpp"
 #include "gui/editor_map_component.hpp"
 #include "blitter.hpp"

Modified: trunk/flexlay/lib/tilemap_layer.hpp
===================================================================
--- trunk/flexlay/lib/tilemap_layer.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/tilemap_layer.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -28,7 +28,6 @@
 class TilemapLayerImpl;
 class EditorMapComponent;
 
-/** */
 class TilemapLayer
 {
 private:

Modified: trunk/flexlay/lib/tilemap_minimap.hpp
===================================================================
--- trunk/flexlay/lib/tilemap_minimap.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/tilemap_minimap.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -17,7 +17,6 @@
 #ifndef HEADER_FLEXLAY_TILEMAP_MINIMAP_HPP
 #define HEADER_FLEXLAY_TILEMAP_MINIMAP_HPP
 
-/** */
 class TilemapMinimap
 {
 private:

Modified: trunk/flexlay/lib/tools/layer_move_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/layer_move_tool.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/tools/layer_move_tool.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -21,7 +21,6 @@
 
 class LayerMoveToolImpl;
 
-/** */
 class LayerMoveTool : public Tool
 {
 public:

Modified: trunk/flexlay/lib/tools/objmap_select_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/objmap_select_tool.cpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/tools/objmap_select_tool.cpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -1,19 +1,18 @@
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
 //  This program is distributed in the hope that it will be useful,
 //  but WITHOUT ANY WARRANTY; without even the implied warranty of
 //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 //  GNU General Public License for more details.
-//
+//  
 //  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "objmap_select_tool.hpp"
 

Modified: trunk/flexlay/lib/tools/objmap_select_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/objmap_select_tool.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/tools/objmap_select_tool.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -24,7 +24,6 @@
 class CL_Menu;
 class ObjMapSelectToolImpl;
 
-/** */
 class ObjMapSelectTool
 {
 public:

Modified: trunk/flexlay/lib/tools/sketch_stroke_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/sketch_stroke_tool.cpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/tools/sketch_stroke_tool.cpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -1,40 +1,39 @@
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
 //  This program is distributed in the hope that it will be useful,
 //  but WITHOUT ANY WARRANTY; without even the implied warranty of
 //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 //  GNU General Public License for more details.
-//
+//  
 //  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "sketch_stroke_tool.hpp"
 
-#include <iostream>
-#include <assert.h>
+//#include <iostream>
+//#include <assert.h>
 #include <ClanLib/gl.h>
-#include <ClanLib/Display/input_event.h>
+//#include <ClanLib/Display/input_event.h>
 #include <ClanLib/Display/keys.h>
 #include <ClanLib/Display/mouse.h>
 #include <ClanLib/Display/display.h>
 #include <ClanLib/Display/input_context.h>
 
 #include "gui/editor_map_component.hpp"
-#include "tool.hpp"
+//#include "tool.hpp"
 #include "bitmap_layer.hpp"
 #include "sprite_stroke_drawer.hpp"
-#include "marker_stroke_drawer.hpp"
-#include "stroke.hpp"
-#include "stroke_drawer.hpp"
+//#include "marker_stroke_drawer.hpp"
+//#include "stroke.hpp"
+//#include "stroke_drawer.hpp"
 #include "drawer_properties.hpp"
-#include "flexlay.hpp"
+//#include "flexlay.hpp"
 
 class SketchStrokeToolImpl : public ToolImpl
 {

Modified: trunk/flexlay/lib/tools/sketch_stroke_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/sketch_stroke_tool.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/tools/sketch_stroke_tool.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -23,7 +23,6 @@
 
 class SketchStrokeToolImpl;
 
-/** */
 class SketchStrokeTool
 {
 private:

Modified: trunk/flexlay/lib/tools/tilemap_paint_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/tilemap_paint_tool.cpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/tools/tilemap_paint_tool.cpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -13,27 +13,23 @@
 //
 //  You should have received a copy of the GNU General Public License
 //  along with this program; if not, write to the Free Software
+
 //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#include "tilemap_paint_tool.hpp"
 
-#include <iostream>
-#include <ClanLib/Display/mouse.h>
 #include <ClanLib/Display/keyboard.h>
 #include <ClanLib/Display/keys.h>
 #include <ClanLib/Display/display.h>
 #include <ClanLib/Display/sprite.h>
 
-#include "globals.hpp"
 #include "tilemap_layer.hpp"
 #include "tileset.hpp"
 #include "editor_map.hpp"
 #include "gui/editor_map_component.hpp"
 #include "tile.hpp"
-#include "workspace.hpp"
 #include "paint_command.hpp"
-#include "editor_names.hpp"
 #include "gui/tile_selection.hpp"
 #include "tool_impl.hpp"
-#include "tilemap_paint_tool.hpp"
 
 TileMapPaintTool TileMapPaintTool::current_;
 

Modified: trunk/flexlay/lib/tools/tilemap_paint_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/tilemap_paint_tool.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/tools/tilemap_paint_tool.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -18,12 +18,10 @@
 #define HEADER_FLEXLAY_TOOLS_TILEMAP_PAINT_TOOL_HPP
 
 #include "tool.hpp"
-#include "tile_brush.hpp"
-#include "tilemap_layer.hpp"
 
 class TileMapPaintToolImpl;
+class TileBrush;
 
-/** */
 class TileMapPaintTool
 {
 private:

Modified: trunk/flexlay/lib/tools/tilemap_select_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/tilemap_select_tool.cpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/tools/tilemap_select_tool.cpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -1,19 +1,18 @@
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
 //  This program is distributed in the hope that it will be useful,
 //  but WITHOUT ANY WARRANTY; without even the implied warranty of
 //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 //  GNU General Public License for more details.
-//
+//  
 //  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "tilemap_select_tool.hpp"
 

Modified: trunk/flexlay/lib/tools/tilemap_select_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/tilemap_select_tool.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/tools/tilemap_select_tool.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -25,7 +25,6 @@
 
 class TileMapSelectToolImpl;
 
-/** */
 class TileMapSelectTool
 {
 public:

Modified: trunk/flexlay/lib/tools/tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/tool.cpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/tools/tool.cpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -1,19 +1,18 @@
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
 //  This program is distributed in the hope that it will be useful,
 //  but WITHOUT ANY WARRANTY; without even the implied warranty of
 //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 //  GNU General Public License for more details.
-//
+//  
 //  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "tool_impl.hpp"
 #include "tool.hpp"

Modified: trunk/flexlay/lib/tools/tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/tool.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/tools/tool.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -24,7 +24,6 @@
 
 class ToolImpl;
 
-/** */
 class Tool
 {
 protected:

Modified: trunk/flexlay/lib/tools/tool_impl.hpp
===================================================================
--- trunk/flexlay/lib/tools/tool_impl.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/tools/tool_impl.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -19,7 +19,6 @@
 
 class CL_InputEvent;
 
-/** */
 class ToolImpl
 {
 protected:

Modified: trunk/flexlay/lib/tools/workspace_move_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/workspace_move_tool.cpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/tools/workspace_move_tool.cpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -1,28 +1,27 @@
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
 //  This program is distributed in the hope that it will be useful,
 //  but WITHOUT ANY WARRANTY; without even the implied warranty of
 //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 //  GNU General Public License for more details.
-//
+//  
 //  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "workspace_move_tool.hpp"
 
-#include <ClanLib/Core/Math/point.h>
-#include <ClanLib/Core/Math/rect.h>
+//#include <ClanLib/Core/Math/point.h>
+//#include <ClanLib/Core/Math/rect.h>
 #include "tool_impl.hpp"
 
 #include "gui/editor_map_component.hpp"
-#include "workspace.hpp"
+//#include "workspace.hpp"
 
 class WorkspaceMoveToolImpl : public ToolImpl
 {

Modified: trunk/flexlay/lib/tools/workspace_move_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/workspace_move_tool.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/tools/workspace_move_tool.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -21,7 +21,6 @@
 
 class WorkspaceMoveToolImpl;
 
-/** */
 class WorkspaceMoveTool
 {
 public:

Modified: trunk/flexlay/lib/tools/zoom2_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/zoom2_tool.cpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/tools/zoom2_tool.cpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -1,22 +1,21 @@
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
 //  This program is distributed in the hope that it will be useful,
 //  but WITHOUT ANY WARRANTY; without even the implied warranty of
 //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 //  GNU General Public License for more details.
-//
+//  
 //  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-#include <ClanLib/Display/keys.h>
-#include <ClanLib/Display/display.h>
+//#include <ClanLib/Display/keys.h>
+//#include <ClanLib/Display/display.h>
 
 #include "gui/editor_map_component.hpp"
 #include "tool_impl.hpp"

Modified: trunk/flexlay/lib/tools/zoom2_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/zoom2_tool.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/tools/zoom2_tool.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -17,13 +17,12 @@
 #ifndef HEADER_FLEXLAY_TOOLS_ZOOM2_TOOL_HPP
 #define HEADER_FLEXLAY_TOOLS_ZOOM2_TOOL_HPP
 
-#include <ClanLib/Core/Math/rect.h>
-#include <ClanLib/Display/input_event.h>
+//#include <ClanLib/Core/Math/rect.h>
+//#include <ClanLib/Display/input_event.h>
 #include "tool.hpp"
 
 class Zoom2ToolImpl;
 
-/** */
 class Zoom2Tool
 {
 public:

Modified: trunk/flexlay/lib/tools/zoom_tool.cpp
===================================================================
--- trunk/flexlay/lib/tools/zoom_tool.cpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/tools/zoom_tool.cpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -1,19 +1,18 @@
 //  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
-//  This program is free software; you can redistribute it and/or
-//  modify it under the terms of the GNU General Public License
-//  as published by the Free Software Foundation; either version 2
-//  of the License, or (at your option) any later version.
-//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//  
 //  This program is distributed in the hope that it will be useful,
 //  but WITHOUT ANY WARRANTY; without even the implied warranty of
 //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 //  GNU General Public License for more details.
-//
+//  
 //  You should have received a copy of the GNU General Public License
-//  along with this program; if not, write to the Free Software
-//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include <ClanLib/Display/keys.h>
 #include <ClanLib/Display/display.h>

Modified: trunk/flexlay/lib/tools/zoom_tool.hpp
===================================================================
--- trunk/flexlay/lib/tools/zoom_tool.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/tools/zoom_tool.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -17,13 +17,12 @@
 #ifndef HEADER_FLEXLAY_TOOLS_ZOOM_TOOL_HPP
 #define HEADER_FLEXLAY_TOOLS_ZOOM_TOOL_HPP
 
-#include <ClanLib/Core/Math/rect.h>
-#include <ClanLib/Display/input_event.h>
+//#include <ClanLib/Core/Math/rect.h>
+//#include <ClanLib/Display/input_event.h>
 #include "tool.hpp"
 
 class ZoomToolImpl;
 
-/** */
 class ZoomTool
 {
 public:

Modified: trunk/flexlay/lib/workspace.hpp
===================================================================
--- trunk/flexlay/lib/workspace.hpp	2009-11-22 15:06:30 UTC (rev 731)
+++ trunk/flexlay/lib/workspace.hpp	2009-11-22 18:37:23 UTC (rev 732)
@@ -25,7 +25,6 @@
 class EditorMap;
 class Tool;
 
-/** */
 class Workspace
 {
 private:



From grumbel at mail.berlios.de  Sun Nov 22 20:34:14 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 22 Nov 2009 20:34:14 +0100
Subject: [Flexlay-commit] r733 - in trunk/flexlay/lib: . gui
Message-ID: <200911221934.nAMJYEKR018983@sheep.berlios.de>

Author: grumbel
Date: 2009-11-22 20:34:12 +0100 (Sun, 22 Nov 2009)
New Revision: 733

Modified:
   trunk/flexlay/lib/bitmap_layer.cpp
   trunk/flexlay/lib/bitmap_layer.hpp
   trunk/flexlay/lib/brush.cpp
   trunk/flexlay/lib/brush.hpp
   trunk/flexlay/lib/brush_impl.hpp
   trunk/flexlay/lib/brushmask.hpp
   trunk/flexlay/lib/drawer_properties.cpp
   trunk/flexlay/lib/drawer_properties.hpp
   trunk/flexlay/lib/generated_brush.cpp
   trunk/flexlay/lib/generated_brush.hpp
   trunk/flexlay/lib/gui/colorpicker.cpp
   trunk/flexlay/lib/gui/colorpicker.hpp
   trunk/flexlay/lib/gui/console.cpp
   trunk/flexlay/lib/gui/console.hpp
   trunk/flexlay/lib/gui/slider.cpp
   trunk/flexlay/lib/gui/slider.hpp
   trunk/flexlay/lib/helper.cpp
   trunk/flexlay/lib/helper.hpp
   trunk/flexlay/lib/marker_stroke_drawer.cpp
   trunk/flexlay/lib/marker_stroke_drawer.hpp
   trunk/flexlay/lib/objmap_control_point.cpp
   trunk/flexlay/lib/objmap_control_point.hpp
   trunk/flexlay/lib/objmap_object_impl.cpp
   trunk/flexlay/lib/objmap_object_impl.hpp
   trunk/flexlay/lib/objmap_path_node.cpp
   trunk/flexlay/lib/objmap_path_node.hpp
   trunk/flexlay/lib/onion_skin_layer.cpp
   trunk/flexlay/lib/onion_skin_layer.hpp
   trunk/flexlay/lib/sketch_layer.cpp
   trunk/flexlay/lib/sketch_layer.hpp
   trunk/flexlay/lib/sprite_brush.cpp
   trunk/flexlay/lib/sprite_brush.hpp
   trunk/flexlay/lib/sprite_stroke_drawer.cpp
   trunk/flexlay/lib/sprite_stroke_drawer.hpp
   trunk/flexlay/lib/stroke.cpp
   trunk/flexlay/lib/stroke.hpp
   trunk/flexlay/lib/stroke_drawer.cpp
   trunk/flexlay/lib/stroke_drawer.hpp
   trunk/flexlay/lib/stroke_drawer_impl.hpp
   trunk/flexlay/lib/tile_provider.cpp
   trunk/flexlay/lib/tile_provider.hpp
   trunk/flexlay/lib/tile_provider_impl.hpp
Log:
More Copyright header cleanup


Modified: trunk/flexlay/lib/bitmap_layer.cpp
===================================================================
--- trunk/flexlay/lib/bitmap_layer.cpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/bitmap_layer.cpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/bitmap_layer.hpp
===================================================================
--- trunk/flexlay/lib/bitmap_layer.hpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/bitmap_layer.hpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/brush.cpp
===================================================================
--- trunk/flexlay/lib/brush.cpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/brush.cpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/brush.hpp
===================================================================
--- trunk/flexlay/lib/brush.hpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/brush.hpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/brush_impl.hpp
===================================================================
--- trunk/flexlay/lib/brush_impl.hpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/brush_impl.hpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/brushmask.hpp
===================================================================
--- trunk/flexlay/lib/brushmask.hpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/brushmask.hpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2004 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/drawer_properties.cpp
===================================================================
--- trunk/flexlay/lib/drawer_properties.cpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/drawer_properties.cpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/drawer_properties.hpp
===================================================================
--- trunk/flexlay/lib/drawer_properties.hpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/drawer_properties.hpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/generated_brush.cpp
===================================================================
--- trunk/flexlay/lib/generated_brush.cpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/generated_brush.cpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/generated_brush.hpp
===================================================================
--- trunk/flexlay/lib/generated_brush.hpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/generated_brush.hpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/gui/colorpicker.cpp
===================================================================
--- trunk/flexlay/lib/gui/colorpicker.cpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/gui/colorpicker.cpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/gui/colorpicker.hpp
===================================================================
--- trunk/flexlay/lib/gui/colorpicker.hpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/gui/colorpicker.hpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/gui/console.cpp
===================================================================
--- trunk/flexlay/lib/gui/console.cpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/gui/console.cpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/gui/console.hpp
===================================================================
--- trunk/flexlay/lib/gui/console.hpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/gui/console.hpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/gui/slider.cpp
===================================================================
--- trunk/flexlay/lib/gui/slider.cpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/gui/slider.cpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/gui/slider.hpp
===================================================================
--- trunk/flexlay/lib/gui/slider.hpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/gui/slider.hpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/helper.cpp
===================================================================
--- trunk/flexlay/lib/helper.cpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/helper.cpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/helper.hpp
===================================================================
--- trunk/flexlay/lib/helper.hpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/helper.hpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/marker_stroke_drawer.cpp
===================================================================
--- trunk/flexlay/lib/marker_stroke_drawer.cpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/marker_stroke_drawer.cpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/marker_stroke_drawer.hpp
===================================================================
--- trunk/flexlay/lib/marker_stroke_drawer.hpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/marker_stroke_drawer.hpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/objmap_control_point.cpp
===================================================================
--- trunk/flexlay/lib/objmap_control_point.cpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/objmap_control_point.cpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/objmap_control_point.hpp
===================================================================
--- trunk/flexlay/lib/objmap_control_point.hpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/objmap_control_point.hpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/objmap_object_impl.cpp
===================================================================
--- trunk/flexlay/lib/objmap_object_impl.cpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/objmap_object_impl.cpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/objmap_object_impl.hpp
===================================================================
--- trunk/flexlay/lib/objmap_object_impl.hpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/objmap_object_impl.hpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/objmap_path_node.cpp
===================================================================
--- trunk/flexlay/lib/objmap_path_node.cpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/objmap_path_node.cpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/objmap_path_node.hpp
===================================================================
--- trunk/flexlay/lib/objmap_path_node.hpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/objmap_path_node.hpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/onion_skin_layer.cpp
===================================================================
--- trunk/flexlay/lib/onion_skin_layer.cpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/onion_skin_layer.cpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/onion_skin_layer.hpp
===================================================================
--- trunk/flexlay/lib/onion_skin_layer.hpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/onion_skin_layer.hpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/sketch_layer.cpp
===================================================================
--- trunk/flexlay/lib/sketch_layer.cpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/sketch_layer.cpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/sketch_layer.hpp
===================================================================
--- trunk/flexlay/lib/sketch_layer.hpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/sketch_layer.hpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/sprite_brush.cpp
===================================================================
--- trunk/flexlay/lib/sprite_brush.cpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/sprite_brush.cpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/sprite_brush.hpp
===================================================================
--- trunk/flexlay/lib/sprite_brush.hpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/sprite_brush.hpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/sprite_stroke_drawer.cpp
===================================================================
--- trunk/flexlay/lib/sprite_stroke_drawer.cpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/sprite_stroke_drawer.cpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/sprite_stroke_drawer.hpp
===================================================================
--- trunk/flexlay/lib/sprite_stroke_drawer.hpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/sprite_stroke_drawer.hpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/stroke.cpp
===================================================================
--- trunk/flexlay/lib/stroke.cpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/stroke.cpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/stroke.hpp
===================================================================
--- trunk/flexlay/lib/stroke.hpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/stroke.hpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/stroke_drawer.cpp
===================================================================
--- trunk/flexlay/lib/stroke_drawer.cpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/stroke_drawer.cpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/stroke_drawer.hpp
===================================================================
--- trunk/flexlay/lib/stroke_drawer.hpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/stroke_drawer.hpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/stroke_drawer_impl.hpp
===================================================================
--- trunk/flexlay/lib/stroke_drawer_impl.hpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/stroke_drawer_impl.hpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editoryy
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/tile_provider.cpp
===================================================================
--- trunk/flexlay/lib/tile_provider.cpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/tile_provider.cpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/tile_provider.hpp
===================================================================
--- trunk/flexlay/lib/tile_provider.hpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/tile_provider.hpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify

Modified: trunk/flexlay/lib/tile_provider_impl.hpp
===================================================================
--- trunk/flexlay/lib/tile_provider_impl.hpp	2009-11-22 18:37:23 UTC (rev 732)
+++ trunk/flexlay/lib/tile_provider_impl.hpp	2009-11-22 19:34:12 UTC (rev 733)
@@ -1,4 +1,4 @@
-//  Pingus - A free Lemmings clone
+//  Flexlay - A Generic 2D Game Editor
 //  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
 //
 //  This program is free software: you can redistribute it and/or modify



From grumbel at mail.berlios.de  Sun Nov 22 21:04:52 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 22 Nov 2009 21:04:52 +0100
Subject: [Flexlay-commit] r734 - trunk/flexlay/lib
Message-ID: <200911222004.nAMK4qwG021945@sheep.berlios.de>

Author: grumbel
Date: 2009-11-22 21:04:52 +0100 (Sun, 22 Nov 2009)
New Revision: 734

Removed:
   trunk/flexlay/lib/tilemap_minimap.hpp
Log:
Removed unused file


Deleted: trunk/flexlay/lib/tilemap_minimap.hpp
===================================================================
--- trunk/flexlay/lib/tilemap_minimap.hpp	2009-11-22 19:34:12 UTC (rev 733)
+++ trunk/flexlay/lib/tilemap_minimap.hpp	2009-11-22 20:04:52 UTC (rev 734)
@@ -1,32 +0,0 @@
-//  Flexlay - A Generic 2D Game Editor
-//  Copyright (C) 2002 Ingo Ruhnke <grumbel at gmx.de>
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//  
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//  
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-#ifndef HEADER_FLEXLAY_TILEMAP_MINIMAP_HPP
-#define HEADER_FLEXLAY_TILEMAP_MINIMAP_HPP
-
-class TilemapMinimap
-{
-private:
-public:
-
-private:
-  TilemapMinimap (const TilemapMinimap&);
-  TilemapMinimap& operator= (const TilemapMinimap&);
-};
-
-#endif
-
-/* EOF */



From grumbel at mail.berlios.de  Sun Nov 22 21:06:00 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Sun, 22 Nov 2009 21:06:00 +0100
Subject: [Flexlay-commit] r735 - trunk/flexlay/lib
Message-ID: <200911222006.nAMK60hG022040@sheep.berlios.de>

Author: grumbel
Date: 2009-11-22 21:06:00 +0100 (Sun, 22 Nov 2009)
New Revision: 735

Modified:
   trunk/flexlay/lib/tilemap_layer.cpp
Log:
Removed unused hex variable


Modified: trunk/flexlay/lib/tilemap_layer.cpp
===================================================================
--- trunk/flexlay/lib/tilemap_layer.cpp	2009-11-22 20:04:52 UTC (rev 734)
+++ trunk/flexlay/lib/tilemap_layer.cpp	2009-11-22 20:06:00 UTC (rev 735)
@@ -35,7 +35,6 @@
   Tileset tileset;
   CL_Color background_color;
   CL_Color foreground_color;
-  bool hex_mode;
 
   Field<int> field;
 
@@ -70,7 +69,6 @@
   // map-properties thingy
   impl->draw_grid      = false;
   impl->draw_attribute = false;
-  impl->hex_mode = false;
 
   for (int y = 0; y < impl->field.get_height(); ++y) 
     for (int x = 0; x < impl->field.get_width(); ++x)



From grumbel at mail.berlios.de  Mon Nov 23 16:21:24 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Mon, 23 Nov 2009 16:21:24 +0100
Subject: [Flexlay-commit] r736 - trunk/flexlay/lib
Message-ID: <200911231521.nANFLOfB000319@sheep.berlios.de>

Author: grumbel
Date: 2009-11-23 16:21:19 +0100 (Mon, 23 Nov 2009)
New Revision: 736

Modified:
   trunk/flexlay/lib/editor_map.cpp
   trunk/flexlay/lib/editor_map.hpp
   trunk/flexlay/lib/graphic_context_state.cpp
   trunk/flexlay/lib/graphic_context_state.hpp
   trunk/flexlay/lib/layer.cpp
   trunk/flexlay/lib/layer.hpp
   trunk/flexlay/lib/layer_impl.hpp
   trunk/flexlay/lib/object_layer.cpp
   trunk/flexlay/lib/onion_skin_layer.cpp
   trunk/flexlay/lib/sketch_layer.cpp
   trunk/flexlay/lib/tilemap_layer.cpp
   trunk/flexlay/lib/tilemap_layer.hpp
   trunk/flexlay/lib/workspace.cpp
Log:
Reduced EditorMapComponent dependency


Modified: trunk/flexlay/lib/editor_map.cpp
===================================================================
--- trunk/flexlay/lib/editor_map.cpp	2009-11-22 20:06:00 UTC (rev 735)
+++ trunk/flexlay/lib/editor_map.cpp	2009-11-23 15:21:19 UTC (rev 736)
@@ -99,10 +99,10 @@
 }
 
 void
-EditorMap::draw (EditorMapComponent* parent, CL_GraphicContext* gc)
+EditorMap::draw(const GraphicContextState& state, CL_GraphicContext* gc)
 {
   for(EditorMapImpl::Layers::iterator i = impl->layers.begin(); i != impl->layers.end(); ++i)
-    (*i).draw(parent, gc);
+    (*i).draw(state, gc);
   
   gc->flush();
 }

Modified: trunk/flexlay/lib/editor_map.hpp
===================================================================
--- trunk/flexlay/lib/editor_map.hpp	2009-11-22 20:06:00 UTC (rev 735)
+++ trunk/flexlay/lib/editor_map.hpp	2009-11-23 15:21:19 UTC (rev 736)
@@ -24,7 +24,6 @@
 #include "command.hpp"
 
 class CL_GraphicContext;
-class EditorMapComponent;
 class EditorMapImpl;
 class Layer;
 class MetaData;
@@ -37,8 +36,7 @@
 public:
   EditorMap(bool create = false);
 
-  /** FIXME: EditorMapComponent parameter shouldn't really be here */
-  void draw(EditorMapComponent* parent, CL_GraphicContext* gc);
+  void draw(const GraphicContextState& state, CL_GraphicContext* gc);
   
   /** Draw stuff that is only relevant on the GUI (bounding rects and such) */
   void draw_gui(CL_GraphicContext* gc);

Modified: trunk/flexlay/lib/graphic_context_state.cpp
===================================================================
--- trunk/flexlay/lib/graphic_context_state.cpp	2009-11-22 20:06:00 UTC (rev 735)
+++ trunk/flexlay/lib/graphic_context_state.cpp	2009-11-23 15:21:19 UTC (rev 736)
@@ -59,7 +59,7 @@
 }
 
 void
-GraphicContextState::push(CL_GraphicContext* gc)
+GraphicContextState::push(CL_GraphicContext* gc) const
 {
   if (gc == 0)
     gc = CL_Display::get_current_window()->get_gc();
@@ -75,7 +75,7 @@
 }
 
 void
-GraphicContextState::pop(CL_GraphicContext* gc)
+GraphicContextState::pop(CL_GraphicContext* gc) const
 {
   if (gc == 0)
     gc = CL_Display::get_current_window()->get_gc();
@@ -84,7 +84,7 @@
 }
 
 CL_Rectf
-GraphicContextState::get_clip_rect()
+GraphicContextState::get_clip_rect() const
 {
   return CL_Rectf(CL_Pointf(-impl->offset.x,
                             -impl->offset.y),
@@ -122,7 +122,7 @@
 }
 
 float
-GraphicContextState::get_zoom()
+GraphicContextState::get_zoom() const
 {
   return impl->zoom;
 }
@@ -178,7 +178,7 @@
 }
 
 float
-GraphicContextState::get_rotation()
+GraphicContextState::get_rotation() const
 {
   return impl->rotation;
 }

Modified: trunk/flexlay/lib/graphic_context_state.hpp
===================================================================
--- trunk/flexlay/lib/graphic_context_state.hpp	2009-11-22 20:06:00 UTC (rev 735)
+++ trunk/flexlay/lib/graphic_context_state.hpp	2009-11-23 15:21:19 UTC (rev 736)
@@ -35,12 +35,12 @@
 
   void set_size(int w, int h);
 
-  void push(CL_GraphicContext* gc = 0);
-  void pop (CL_GraphicContext* gc = 0);
+  void push(CL_GraphicContext* gc = 0) const;
+  void pop (CL_GraphicContext* gc = 0) const;
 
   /** Return a rectangle in world coordinates that represents the area
       visible on the screen */
-  CL_Rectf get_clip_rect();
+  CL_Rectf get_clip_rect() const;
 
   int get_width()  const;
   int get_height() const;
@@ -49,7 +49,7 @@
   void  set_rotation(float angle);
 
   /** Return the current rotation angel */
-  float get_rotation();
+  float get_rotation() const;
 
   /** Move the center of the visible area to pos */
   void      set_pos(const CL_Pointf& pos);
@@ -60,7 +60,7 @@
       position even after zoomed in/out */
   void  set_zoom(CL_Pointf pos, float z);
   void  set_zoom(float z);
-  float get_zoom(); 
+  float get_zoom() const; 
 
   void zoom_to (const CL_Rectf& rect);
 

Modified: trunk/flexlay/lib/layer.cpp
===================================================================
--- trunk/flexlay/lib/layer.cpp	2009-11-22 20:06:00 UTC (rev 735)
+++ trunk/flexlay/lib/layer.cpp	2009-11-23 15:21:19 UTC (rev 736)
@@ -33,7 +33,7 @@
 }
 
 void
-Layer::draw(EditorMapComponent* parent, CL_GraphicContext* gc) 
+Layer::draw(const GraphicContextState& state, CL_GraphicContext* gc) 
 { 
   if (impl.get())
   {
@@ -41,12 +41,12 @@
     {
       gc->push_modelview();
       gc->add_translate(impl->pos.x, impl->pos.y);
-      impl->draw(parent, gc);
+      impl->draw(state, gc);
       gc->pop_modelview();
     }
     else
     {
-      impl->draw(parent, gc);
+      impl->draw(state, gc);
     }
   }
 }

Modified: trunk/flexlay/lib/layer.hpp
===================================================================
--- trunk/flexlay/lib/layer.hpp	2009-11-22 20:06:00 UTC (rev 735)
+++ trunk/flexlay/lib/layer.hpp	2009-11-23 15:21:19 UTC (rev 736)
@@ -22,10 +22,10 @@
 #include "meta_data.hpp"
 
 class CL_Rect;
-class EditorMapComponent;
 class LayerImpl;
 class CL_Pointf;
 class CL_GraphicContext;
+class GraphicContextState;
 
 /** Each \a EditorMap consists out of one or more \a Layer,
     The \a Layer is an abstract base class from which the
@@ -48,7 +48,7 @@
       the layer itself) */
   void     set_metadata(MetaData data_);
 
-  void draw(EditorMapComponent* parent, CL_GraphicContext* gc);
+  void draw(const GraphicContextState& state, CL_GraphicContext* gc);
   bool has_bounding_rect() const;
   CL_Rect get_bounding_rect();
 

Modified: trunk/flexlay/lib/layer_impl.hpp
===================================================================
--- trunk/flexlay/lib/layer_impl.hpp	2009-11-22 20:06:00 UTC (rev 735)
+++ trunk/flexlay/lib/layer_impl.hpp	2009-11-23 15:21:19 UTC (rev 736)
@@ -21,7 +21,7 @@
 #include <ClanLib/Display/graphic_context.h>
 #include "meta_data.hpp"
 
-class EditorMapComponent;
+class GraphicContextState;
 
 class LayerImpl
 {
@@ -41,7 +41,7 @@
   {}
   virtual ~LayerImpl() {}
 
-  virtual void draw(EditorMapComponent* parent, CL_GraphicContext* gc) =0;
+  virtual void draw(const GraphicContextState& state, CL_GraphicContext* gc) =0;
   virtual bool has_bounding_rect() const =0;
 
   // FIXME: Should use CL_Rectf

Modified: trunk/flexlay/lib/object_layer.cpp
===================================================================
--- trunk/flexlay/lib/object_layer.cpp	2009-11-22 20:06:00 UTC (rev 735)
+++ trunk/flexlay/lib/object_layer.cpp	2009-11-23 15:21:19 UTC (rev 736)
@@ -31,7 +31,7 @@
   ObjectLayerImpl() {}
   virtual ~ObjectLayerImpl() {}
   
-  void draw(EditorMapComponent* parent, CL_GraphicContext* gc);
+  void draw(const GraphicContextState& state, CL_GraphicContext* gc);
   bool has_bounding_rect() const { return false; }
 };
 
@@ -45,12 +45,12 @@
 }
 
 void
-ObjectLayerImpl::draw(EditorMapComponent* parent, CL_GraphicContext* gc)
+ObjectLayerImpl::draw(const GraphicContextState& state, CL_GraphicContext* gc)
 {
   for(ObjectLayer::Objects::iterator i = objects.begin(); i != objects.end(); ++i)
   {
     // FIXME: Add clipping here
-    if (parent->get_clip_rect().is_overlapped((*i).get_bound_rect()))
+    if (state.get_clip_rect().is_overlapped((*i).get_bound_rect()))
       (*i).draw(gc);
   }
 

Modified: trunk/flexlay/lib/onion_skin_layer.cpp
===================================================================
--- trunk/flexlay/lib/onion_skin_layer.cpp	2009-11-22 20:06:00 UTC (rev 735)
+++ trunk/flexlay/lib/onion_skin_layer.cpp	2009-11-23 15:21:19 UTC (rev 736)
@@ -41,7 +41,7 @@
   std::vector<EditorMap> editormaps;
   std::vector<CL_Color>  color;
 
-  void draw(EditorMapComponent* parent, CL_GraphicContext* gc) 
+  void draw(const GraphicContextState& state, CL_GraphicContext* gc) 
   {
     // FIXME: We need to stop onion layer to draw onto itself
     surface.set_blend_func(blend_one, blend_one_minus_src_alpha);
@@ -60,8 +60,8 @@
 {
 }
 
-OnionSkinLayer::OnionSkinLayer(int width, int height)
-  : impl(new OnionSkinLayerImpl())
+OnionSkinLayer::OnionSkinLayer(int width, int height) :
+  impl(new OnionSkinLayerImpl())
 {
   impl->surface  = CL_Surface(CL_PixelBuffer(width/SCALE, height/SCALE, width*4/SCALE, CL_PixelFormat::rgba8888));
   impl->surface2 = CL_Surface(CL_PixelBuffer(width/SCALE, height/SCALE, width*4/SCALE, CL_PixelFormat::rgba8888));
@@ -109,7 +109,7 @@
     impl->canvas2->get_gc()->push_modelview();
     impl->canvas2->get_gc()->add_scale(1.0f/SCALE, 1.0f/SCALE);
 
-    impl->editormaps[i].draw(EditorMapComponent::current(), impl->canvas2->get_gc());
+    impl->editormaps[i].draw(EditorMapComponent::current()->get_gc_state(), impl->canvas2->get_gc());
 
     impl->canvas2->get_gc()->pop_modelview();
 

Modified: trunk/flexlay/lib/sketch_layer.cpp
===================================================================
--- trunk/flexlay/lib/sketch_layer.cpp	2009-11-22 20:06:00 UTC (rev 735)
+++ trunk/flexlay/lib/sketch_layer.cpp	2009-11-23 15:21:19 UTC (rev 736)
@@ -80,7 +80,7 @@
     }
   }
   
-  void draw(EditorMapComponent* parent, CL_GraphicContext* gc) 
+  void draw(const GraphicContextState& state, CL_GraphicContext* gc) 
   {
     // Nothing to draw, so we go byebye
     if (strokes.empty()) 
@@ -89,20 +89,20 @@
     if (canvas)
     {
       // Draw to canvas
-      if (last_zoom != parent->get_gc_state().get_zoom() ||
-          last_pos  != parent->get_gc_state().get_pos()  ||
-          last_rot  != parent->get_gc_state().get_rotation())
+      if (last_zoom != state.get_zoom() ||
+          last_pos  != state.get_pos()  ||
+          last_rot  != state.get_rotation())
       {
         // Rerender the image
-        last_zoom   = parent->get_gc_state().get_zoom();
-        last_pos    = parent->get_gc_state().get_pos();
-        last_rot    = parent->get_gc_state().get_rotation();
+        last_zoom   = state.get_zoom();
+        last_pos    = state.get_pos();
+        last_rot    = state.get_rotation();
 
-        parent->get_gc_state().push(canvas->get_gc());
+        state.push(canvas->get_gc());
         canvas->get_gc()->clear(CL_Color(0, 0, 0, 0));
         //canvas->get_gc()->clear(CL_Color::white);
 
-        CL_Rectf visible_area = parent->get_clip_rect();
+        CL_Rectf visible_area = state.get_clip_rect();
 
         for(Strokes::iterator i = strokes.begin(); i != strokes.end(); ++i)
         {
@@ -114,7 +114,7 @@
             i->draw(canvas->get_gc());
           }
         }
-        parent->get_gc_state().pop(canvas->get_gc());
+        state.pop(canvas->get_gc());
 
         canvas->sync_surface();
       }

Modified: trunk/flexlay/lib/tilemap_layer.cpp
===================================================================
--- trunk/flexlay/lib/tilemap_layer.cpp	2009-11-22 20:06:00 UTC (rev 735)
+++ trunk/flexlay/lib/tilemap_layer.cpp	2009-11-23 15:21:19 UTC (rev 736)
@@ -48,7 +48,7 @@
 
   bool has_bounding_rect() const;
   CL_Rect get_bounding_rect();
-  void draw(EditorMapComponent* parent, CL_GraphicContext* gc);
+  void draw(const GraphicContextState& state, CL_GraphicContext* gc);
 };
 
 TilemapLayer::TilemapLayer()
@@ -85,13 +85,13 @@
 }
 
 void
-TilemapLayer::draw(EditorMapComponent* parent, CL_GraphicContext* gc)
+TilemapLayer::draw(const GraphicContextState& state, CL_GraphicContext* gc)
 {
-  impl->draw(parent, gc);
+  impl->draw(state, gc);
 }
 
 void
-TilemapLayerImpl::draw(EditorMapComponent* parent, CL_GraphicContext* gc)
+TilemapLayerImpl::draw(const GraphicContextState& state, CL_GraphicContext* gc)
 {
   int tile_size = this->tileset.get_tile_size();
 
@@ -102,7 +102,7 @@
                           this->background_color);
   CL_Display::flush();
 
-  CL_Rect rect(parent->get_clip_rect());
+  CL_Rect rect(state.get_clip_rect());
 
   int start_x = std::max(0, rect.left / tile_size);
   int start_y = std::max(0, rect.top  / tile_size);

Modified: trunk/flexlay/lib/tilemap_layer.hpp
===================================================================
--- trunk/flexlay/lib/tilemap_layer.hpp	2009-11-22 20:06:00 UTC (rev 735)
+++ trunk/flexlay/lib/tilemap_layer.hpp	2009-11-23 15:21:19 UTC (rev 736)
@@ -18,9 +18,10 @@
 #define HEADER_FLEXLAY_TILEMAP_LAYER_HPP
 
 #include <ClanLib/Display/pixel_buffer.h>
+#include <boost/shared_ptr.hpp>
+
 #include "field.hpp"
 #include "meta_data.hpp"
-#include <boost/shared_ptr.hpp>
 #include "layer.hpp"
 
 class Tileset;
@@ -40,7 +41,7 @@
   TilemapLayer(Tileset tileset, int w,  int h);
   ~TilemapLayer();
 
-  void draw(EditorMapComponent* parent, CL_GraphicContext* gc);
+  void draw(const GraphicContextState& state, CL_GraphicContext* gc);
 
   Tileset get_tileset();
 

Modified: trunk/flexlay/lib/workspace.cpp
===================================================================
--- trunk/flexlay/lib/workspace.cpp	2009-11-22 20:06:00 UTC (rev 735)
+++ trunk/flexlay/lib/workspace.cpp	2009-11-23 15:21:19 UTC (rev 736)
@@ -58,7 +58,7 @@
   CL_Display::clear(CL_Color(100, 0, 100));
 
   impl->editor_map.draw_gui(CL_Display::get_current_window()->get_gc());
-  impl->editor_map.draw(EditorMapComponent::current(), CL_Display::get_current_window()->get_gc());
+  impl->editor_map.draw(EditorMapComponent::current()->get_gc_state(), CL_Display::get_current_window()->get_gc());
   
   // FIXME: Only draw active tool?!
   for(WorkspaceImpl::Tools::iterator it = impl->tools.begin();



From grumbel at mail.berlios.de  Mon Nov 23 16:27:44 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Mon, 23 Nov 2009 16:27:44 +0100
Subject: [Flexlay-commit] r737 - in trunk/flexlay/lib: . gui
Message-ID: <200911231527.nANFRi4S000705@sheep.berlios.de>

Author: grumbel
Date: 2009-11-23 16:27:44 +0100 (Mon, 23 Nov 2009)
New Revision: 737

Modified:
   trunk/flexlay/lib/generated_brush.cpp
   trunk/flexlay/lib/gui/editor_map_component.cpp
   trunk/flexlay/lib/onion_skin_layer.cpp
   trunk/flexlay/lib/tilemap_layer.hpp
   trunk/flexlay/lib/workspace.cpp
   trunk/flexlay/lib/workspace.hpp
Log:
Reduced EditorMapComponent dependency, replaced some incorrect dynamic_cast<> hacks with boost::dynamic_pointer_cast<>


Modified: trunk/flexlay/lib/generated_brush.cpp
===================================================================
--- trunk/flexlay/lib/generated_brush.cpp	2009-11-23 15:21:19 UTC (rev 736)
+++ trunk/flexlay/lib/generated_brush.cpp	2009-11-23 15:27:44 UTC (rev 737)
@@ -39,8 +39,8 @@
   BrushImpl* clone() const;
 };
 
-GeneratedBrush::GeneratedBrush(const Brush& brush)
-  : impl(dynamic_cast<GeneratedBrushImpl*>(brush.impl.get())) // FIXME: WANT WORK WITH REAL SMARTPTR!!!
+GeneratedBrush::GeneratedBrush(const Brush& brush) :
+  impl(boost::dynamic_pointer_cast<GeneratedBrushImpl>(brush.impl))
 {
 }
 
@@ -49,8 +49,8 @@
                                int    spikes,        /* 2 - 20     */
                                float  hardness,      /* 0.0 - 1.0  */
                                float  aspect_ratio,  /* y/x        */
-                               float  angle)
-  : impl(new GeneratedBrushImpl())
+                               float  angle) :
+  impl(new GeneratedBrushImpl())
 {
   impl->shape        = shape;
   impl->radius       = radius;

Modified: trunk/flexlay/lib/gui/editor_map_component.cpp
===================================================================
--- trunk/flexlay/lib/gui/editor_map_component.cpp	2009-11-23 15:21:19 UTC (rev 736)
+++ trunk/flexlay/lib/gui/editor_map_component.cpp	2009-11-23 15:27:44 UTC (rev 737)
@@ -18,6 +18,8 @@
 #include <ClanLib/Display/keyboard.h>
 #include <ClanLib/Display/mouse.h>
 #include <ClanLib/Display/display.h>
+#include <ClanLib/Display/display_window.h>
+
 #include "editor_map.hpp"
 #include "scrollbar.hpp"
 #include "editor_map_component.hpp"
@@ -163,7 +165,7 @@
   scrollbar_h->set_pos(gc_state.get_pos().x);
 
   gc_state.push();
-  workspace.draw();
+  workspace.draw(gc_state, CL_Display::get_current_window()->get_gc());
   gc_state.pop();
 
   CL_Display::pop_modelview();

Modified: trunk/flexlay/lib/onion_skin_layer.cpp
===================================================================
--- trunk/flexlay/lib/onion_skin_layer.cpp	2009-11-23 15:21:19 UTC (rev 736)
+++ trunk/flexlay/lib/onion_skin_layer.cpp	2009-11-23 15:27:44 UTC (rev 737)
@@ -55,8 +55,8 @@
   }
 };
 
-OnionSkinLayer::OnionSkinLayer(Layer layer)
-  : impl(dynamic_cast<OnionSkinLayerImpl*>(layer.impl.get())) // FIXME: WONT WORK WITH REAL SMARTPTR!!!
+OnionSkinLayer::OnionSkinLayer(Layer layer) :
+  impl(boost::dynamic_pointer_cast<OnionSkinLayerImpl>(layer.impl))
 {
 }
 

Modified: trunk/flexlay/lib/tilemap_layer.hpp
===================================================================
--- trunk/flexlay/lib/tilemap_layer.hpp	2009-11-23 15:21:19 UTC (rev 736)
+++ trunk/flexlay/lib/tilemap_layer.hpp	2009-11-23 15:27:44 UTC (rev 737)
@@ -27,7 +27,6 @@
 class Tileset;
 class TileBrush;
 class TilemapLayerImpl;
-class EditorMapComponent;
 
 class TilemapLayer
 {

Modified: trunk/flexlay/lib/workspace.cpp
===================================================================
--- trunk/flexlay/lib/workspace.cpp	2009-11-23 15:21:19 UTC (rev 736)
+++ trunk/flexlay/lib/workspace.cpp	2009-11-23 15:27:44 UTC (rev 737)
@@ -51,7 +51,7 @@
 }
 
 void
-Workspace::draw()
+Workspace::draw(const GraphicContextState& state, CL_GraphicContext* gc)
 {
   assert(impl.get());
 

Modified: trunk/flexlay/lib/workspace.hpp
===================================================================
--- trunk/flexlay/lib/workspace.hpp	2009-11-23 15:21:19 UTC (rev 736)
+++ trunk/flexlay/lib/workspace.hpp	2009-11-23 15:27:44 UTC (rev 737)
@@ -36,7 +36,7 @@
 
   Workspace(bool create = false);
 
-  void draw();
+  void draw(const GraphicContextState& state, CL_GraphicContext* gc);
 
   void mouse_up  (const CL_InputEvent& event);
   void mouse_down(const CL_InputEvent& event);



From grumbel at mail.berlios.de  Mon Nov 23 16:29:58 2009
From: grumbel at mail.berlios.de (grumbel at BerliOS)
Date: Mon, 23 Nov 2009 16:29:58 +0100
Subject: [Flexlay-commit] r738 - trunk/flexlay/lib
Message-ID: <200911231529.nANFTw2Z000844@sheep.berlios.de>

Author: grumbel
Date: 2009-11-23 16:29:58 +0100 (Mon, 23 Nov 2009)
New Revision: 738

Modified:
   trunk/flexlay/lib/object_layer.cpp
   trunk/flexlay/lib/sketch_layer.cpp
   trunk/flexlay/lib/tilemap_layer.cpp
   trunk/flexlay/lib/workspace.cpp
Log:
Reduced EditorMapComponent dependency


Modified: trunk/flexlay/lib/object_layer.cpp
===================================================================
--- trunk/flexlay/lib/object_layer.cpp	2009-11-23 15:27:44 UTC (rev 737)
+++ trunk/flexlay/lib/object_layer.cpp	2009-11-23 15:29:58 UTC (rev 738)
@@ -16,8 +16,8 @@
 
 #include "object_layer.hpp"
 
-#include "gui/editor_map_component.hpp"
 #include "layer_impl.hpp"
+#include "graphic_context_state.hpp"
 
 ObjectLayer ObjectLayer::current_;
 

Modified: trunk/flexlay/lib/sketch_layer.cpp
===================================================================
--- trunk/flexlay/lib/sketch_layer.cpp	2009-11-23 15:27:44 UTC (rev 737)
+++ trunk/flexlay/lib/sketch_layer.cpp	2009-11-23 15:29:58 UTC (rev 738)
@@ -28,8 +28,8 @@
 #include <ClanLib/Display/graphic_context.h>
 #include <ClanLib/Display/display_window.h>
 
+#include "gui/editor_map_component.hpp"
 #include "flexlay.hpp"
-#include "gui/editor_map_component.hpp"
 #include "layer_impl.hpp"
 #include "math.hpp"
 

Modified: trunk/flexlay/lib/tilemap_layer.cpp
===================================================================
--- trunk/flexlay/lib/tilemap_layer.cpp	2009-11-23 15:27:44 UTC (rev 737)
+++ trunk/flexlay/lib/tilemap_layer.cpp	2009-11-23 15:29:58 UTC (rev 738)
@@ -20,10 +20,10 @@
 #include <ClanLib/Display/pixel_format.h>
 #include <ClanLib/Display/sprite.h>
 
+#include "gui/editor_map_component.hpp"
 #include "tile.hpp"
 #include "tileset.hpp"
 #include "tile_brush.hpp"
-#include "gui/editor_map_component.hpp"
 #include "blitter.hpp"
 #include "layer_impl.hpp"
 

Modified: trunk/flexlay/lib/workspace.cpp
===================================================================
--- trunk/flexlay/lib/workspace.cpp	2009-11-23 15:27:44 UTC (rev 737)
+++ trunk/flexlay/lib/workspace.cpp	2009-11-23 15:29:58 UTC (rev 738)
@@ -22,8 +22,8 @@
 #include <ClanLib/Display/display_window.h>
 #include <ClanLib/Display/keys.h>
 
+#include "gui/editor_map_component.hpp"
 #include "editor_map.hpp"
-#include "gui/editor_map_component.hpp"
 #include "editor_names.hpp"
 #include "tools/tool.hpp"
 #include "tileset.hpp"



