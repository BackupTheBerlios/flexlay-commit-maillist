<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Flexlay-commit] r490 - in trunk: lib pingus ruby
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/flexlay-commit/2005-February/index.html" >
   <LINK REL="made" HREF="mailto:flexlay-commit%40lists.berlios.de?Subject=Re%3A%20%5BFlexlay-commit%5D%20r490%20-%20in%20trunk%3A%20lib%20pingus%20ruby&In-Reply-To=%3C200502251730.j1PHUWdc010611%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000000.html">
   <LINK REL="Next"  HREF="000002.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Flexlay-commit] r490 - in trunk: lib pingus ruby</H1>
    <B>Ingo Ruhnke at BerliOS</B> 
    <A HREF="mailto:flexlay-commit%40lists.berlios.de?Subject=Re%3A%20%5BFlexlay-commit%5D%20r490%20-%20in%20trunk%3A%20lib%20pingus%20ruby&In-Reply-To=%3C200502251730.j1PHUWdc010611%40sheep.berlios.de%3E"
       TITLE="[Flexlay-commit] r490 - in trunk: lib pingus ruby">grumbel at sheep.berlios.de
       </A><BR>
    <I>Fri Feb 25 18:30:32 CET 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000000.html">[Flexlay-commit] r489 - in trunk: lib netpanzer
</A></li>
        <LI>Next message: <A HREF="000002.html">[Flexlay-commit] r491 - trunk/pingus
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1">[ date ]</a>
              <a href="thread.html#1">[ thread ]</a>
              <a href="subject.html#1">[ subject ]</a>
              <a href="author.html#1">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: grumbel
Date: 2005-02-25 18:30:24 +0100 (Fri, 25 Feb 2005)
New Revision: 490

Added:
   trunk/pingus/gui.rb
   trunk/pingus/level.rb
   trunk/pingus/pingus-editor
   trunk/pingus/pingus-editor-gdb
   trunk/pingus/pingus.rb
   trunk/pingus/worldmap.rb
   trunk/pingus/worldobjs.rb
   trunk/pingus/xmlreader.rb
Modified:
   trunk/lib/clanlib.i
   trunk/lib/editor_map.cxx
   trunk/lib/editor_map.hxx
   trunk/lib/flexlay_wrap.i
   trunk/lib/object_layer.cxx
   trunk/lib/object_selector.cxx
   trunk/lib/objmap_object.cxx
   trunk/lib/objmap_object.hxx
   trunk/lib/objmap_object_impl.hxx
   trunk/lib/objmap_path_node.cxx
   trunk/lib/objmap_rect_object.cxx
   trunk/lib/objmap_rect_object.hxx
   trunk/lib/objmap_select_tool.cxx
   trunk/lib/objmap_sprite_object.cxx
   trunk/ruby/flexlay.rb
Log:
- some more work on pingus editor, basic load of level with exit/entrances and friends is now working
- added basic worldmap loading

Modified: trunk/lib/clanlib.i
===================================================================
--- trunk/lib/clanlib.i	2005-02-11 18:54:01 UTC (rev 489)
+++ trunk/lib/clanlib.i	2005-02-25 17:30:24 UTC (rev 490)
@@ -29,6 +29,14 @@
 	float x;
 	float y;
 };
+        
+class CL_Sprite
+{
+public:
+CL_Sprite(      
+	        	const std::string &amp;resource_id,
+		        CL_ResourceManager *manager);
+};
 
 
 class CL_Point
@@ -57,6 +65,16 @@
 	CL_Size get_size();
 };
 
+class CL_Colorf
+{
+public:
+        CL_Colorf(float r, float g, float b, float a);
+        float red;
+        float green;
+        float blue;
+        float alpha;
+};
+
 class CL_Color
 {
 public:
@@ -168,21 +186,56 @@
 class CL_ResourceManager
 {
 public:
+	CL_ResourceManager();
 	CL_ResourceManager(
 		const std::string &amp;config_file,
 		CL_InputSourceProvider *provider = 0,
 		bool delete_inputsource_provider = false);
 	~CL_ResourceManager();
 
-	std::list&lt;std::string&gt; get_all_resources(const std::string &amp;section_name);
-	std::list&lt;std::string&gt; get_all_sections();
+	std::vector&lt;std::string&gt; get_all_resources(const std::string &amp;section_name);
+	std::vector&lt;std::string&gt; get_all_sections();
 
-	std::list&lt;std::string&gt; get_resources_of_type(const std::string &amp;type_id);
-	std::list&lt;std::string&gt; get_resources_of_type(const std::string &amp;type_id, const std::string &amp;section_name);
+	std::vector&lt;std::string&gt; get_resources_of_type(const std::string &amp;type_id);
+	std::vector&lt;std::string&gt; get_resources_of_type(const std::string &amp;type_id, const std::string &amp;section_name);
 	void add_resources(const CL_ResourceManager &amp;additional_resources);
 	void remove_resources(const CL_ResourceManager &amp;additional_resources);
 };
 
 
+class CL_RadioButton : public CL_Button
+{
+public:
+	CL_RadioButton(
+		const CL_Point &amp;pos,
+		const std::string &amp;text,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+	bool is_checked() const;
+	void set_checked(bool check);
+};
+
+class CL_RadioGroup
+{
+public:
+	CL_RadioGroup();
+	~CL_RadioGroup();
+
+	const std::vector&lt;CL_RadioButton *&gt; &amp;get_buttons() const;
+	void add(CL_RadioButton *button, bool delete_component = false);
+};
+
+class CL_CheckBox : public CL_Button
+{
+public:
+        CL_CheckBox(
+		const CL_Point &amp;pos,
+		const std::string &amp;text,
+		CL_Component *parent,
+		CL_StyleManager *style = NULL);
+	bool is_checked() const;
+	void set_checked(bool check = true);
+};
+
 /* EOF */
 

Modified: trunk/lib/editor_map.cxx
===================================================================
--- trunk/lib/editor_map.cxx	2005-02-11 18:54:01 UTC (rev 489)
+++ trunk/lib/editor_map.cxx	2005-02-25 17:30:24 UTC (rev 490)
@@ -52,6 +52,8 @@
 
   CL_Signal_v0 on_change;
 
+  bool    has_bounding_rect;
+  CL_Rect bounding_rect;
 };
 
 EditorMap::EditorMap()
@@ -61,6 +63,7 @@
   impl-&gt;foreground_color = CL_Color(255, 80, 255);
   impl-&gt;modified = false;
   impl-&gt;serial = 0;
+  impl-&gt;has_bounding_rect = 0;
 }
 
 void
@@ -137,33 +140,60 @@
   return impl-&gt;metadata; 
 }
 
+bool
+EditorMap::has_bounding_rect() const
+{
+  return impl-&gt;has_bounding_rect;
+}
+
+void
+EditorMap::set_bounding_rect(const CL_Rect&amp; rect)
+{
+  if (rect != CL_Rect(0,0,0,0))
+    {
+      impl-&gt;has_bounding_rect = true;
+      impl-&gt;bounding_rect     = rect;
+    }
+  else
+    {
+      impl-&gt;has_bounding_rect = false;
+      impl-&gt;bounding_rect     = rect;
+    }
+}
+
 CL_Rect
 EditorMap::get_bounding_rect()
 {
-  bool init = false;
-  CL_Rect rect(0,0,0,0);
+  if (impl-&gt;has_bounding_rect)
+    {
+      return impl-&gt;bounding_rect;
+    }
+  else
+    {
+      bool init = false;
+      CL_Rect rect(0,0,0,0);
 
-  for(EditorMapImpl::Layers::iterator i = impl-&gt;layers.begin(); i != impl-&gt;layers.end(); ++i)
-    {
-      if (i-&gt;has_bounding_rect())
+      for(EditorMapImpl::Layers::iterator i = impl-&gt;layers.begin(); i != impl-&gt;layers.end(); ++i)
         {
-          if (!init)
+          if (i-&gt;has_bounding_rect())
             {
-              rect = i-&gt;get_bounding_rect();
-              init = true;
+              if (!init)
+                {
+                  rect = i-&gt;get_bounding_rect();
+                  init = true;
+                }
+              else
+                {
+                  CL_Rect other = i-&gt;get_bounding_rect();
+                  rect.top    = std::min(rect.top,    other.top);
+                  rect.bottom = std::max(rect.bottom, other.bottom);
+                  rect.left   = std::min(rect.left,   other.left);
+                  rect.right  = std::max(rect.right,  other.right);              
+                }
             }
-          else
-            {
-              CL_Rect other = i-&gt;get_bounding_rect();
-              rect.top    = std::min(rect.top,    other.top);
-              rect.bottom = std::max(rect.bottom, other.bottom);
-              rect.left   = std::min(rect.left,   other.left);
-              rect.right  = std::max(rect.right,  other.right);              
-            }
         }
+      return rect;
     }
-
-  return rect;
 }
 
 void

Modified: trunk/lib/editor_map.hxx
===================================================================
--- trunk/lib/editor_map.hxx	2005-02-11 18:54:01 UTC (rev 489)
+++ trunk/lib/editor_map.hxx	2005-02-25 17:30:24 UTC (rev 490)
@@ -56,8 +56,9 @@
   void   set_metadata(const MetaData&amp; obj);
   MetaData get_metadata() const;
 
-  bool has_bounding_rect() const { return true; }
+  bool has_bounding_rect() const;
   CL_Rect get_bounding_rect();
+  void    set_bounding_rect(const CL_Rect&amp; rect);
 
   void set_background_color(const CL_Color&amp; color);
 

Modified: trunk/lib/flexlay_wrap.i
===================================================================
--- trunk/lib/flexlay_wrap.i	2005-02-11 18:54:01 UTC (rev 489)
+++ trunk/lib/flexlay_wrap.i	2005-02-25 17:30:24 UTC (rev 490)
@@ -126,7 +126,9 @@
 
 %include &quot;std_string.i&quot;
 %include &quot;std_vector.i&quot;
+%template(Std_vector_string) std::vector&lt;std::string&gt;;
 %template(Std_vector_int) std::vector&lt;int&gt;;
+%template(Std_vector_CL_RadioButton) std::vector&lt;CL_RadioButton *&gt;;
 %template(Std_vector_ObjMapObject) std::vector&lt;ObjMapObject&gt;;
 %template(Std_vector_CL_Pointf) std::vector&lt;CL_Pointf&gt;;
 %template(Std_vector_Stroke) std::vector&lt;Stroke&gt;;

Modified: trunk/lib/object_layer.cxx
===================================================================
--- trunk/lib/object_layer.cxx	2005-02-11 18:54:01 UTC (rev 489)
+++ trunk/lib/object_layer.cxx	2005-02-25 17:30:24 UTC (rev 490)
@@ -86,7 +86,7 @@
 {
   for(Objects::reverse_iterator i = impl-&gt;objects.rbegin(); i != impl-&gt;objects.rend(); ++i)
     {
-      CL_Rect rect = (*i).get_bound_rect();
+      CL_Rectf rect = (*i).get_bound_rect();
      
       if (rect.is_inside(CL_Point(click_pos)))
         return *i;

Modified: trunk/lib/object_selector.cxx
===================================================================
--- trunk/lib/object_selector.cxx	2005-02-11 18:54:01 UTC (rev 489)
+++ trunk/lib/object_selector.cxx	2005-02-25 17:30:24 UTC (rev 490)
@@ -165,18 +165,16 @@
       int x = i%width;
       int y = i/width;
 
-      CL_Rect rect(CL_Point(static_cast&lt;int&gt;(x * obj_width),
-                            static_cast&lt;int&gt;(y * obj_height)),
-                   CL_Size(static_cast&lt;int&gt;(obj_width),
-                           static_cast&lt;int&gt;(obj_height)));
+      CL_Rectf rect(CL_Pointf(x * obj_width, y * obj_height),
+                    CL_Sizef(obj_width, obj_height));
 
       CL_Sprite sprite = brushes[i].get_sprite();
       sprite.set_alignment(origin_center, 0, 0);
       sprite.set_scale(std::min(1.0f, (float)obj_width/(float)sprite.get_width()),
                        std::min(1.0f, (float)obj_height/(float)sprite.get_height()));
         
-      sprite.draw(static_cast&lt;int&gt;(x * obj_width + obj_width/2), 
-                  static_cast&lt;int&gt;(y * obj_height + obj_height/2));
+      sprite.draw(x * obj_width + obj_width/2, 
+                  y * obj_height + obj_height/2);
         
       //CL_Display::draw_rect(rect, CL_Color(0,0,0,128));
         
@@ -186,6 +184,8 @@
         }
     }
 
+  CL_Display::pop_modelview();
+
   // Draw drag sprite
   if (drag_obj != -1)
     {
@@ -195,10 +195,8 @@
 
       CL_Sprite sprite = brushes[drag_obj].get_sprite();
       sprite.set_alpha(0.5f);
-      sprite.draw(mouse_pos.x, mouse_pos.y);
+      sprite.draw(mouse_pos.x + get_screen_x(), mouse_pos.y + get_screen_y());
     }
-
-  CL_Display::pop_modelview();
 }
 
 void

Modified: trunk/lib/objmap_object.cxx
===================================================================
--- trunk/lib/objmap_object.cxx	2005-02-11 18:54:01 UTC (rev 489)
+++ trunk/lib/objmap_object.cxx	2005-02-25 17:30:24 UTC (rev 490)
@@ -77,7 +77,7 @@
     impl-&gt;draw();
 }
 
-CL_Rect
+CL_Rectf
 ObjMapObject::get_bound_rect() const
 {
   if (impl.get())

Modified: trunk/lib/objmap_object.hxx
===================================================================
--- trunk/lib/objmap_object.hxx	2005-02-11 18:54:01 UTC (rev 489)
+++ trunk/lib/objmap_object.hxx	2005-02-25 17:30:24 UTC (rev 490)
@@ -47,8 +47,7 @@
   CL_Signal_v1&lt;ObjMapObject&gt;&amp; sig_deselect();
 
   void draw();
-  // FIXME: should be CL_Rectf
-  CL_Rect get_bound_rect() const;
+  CL_Rectf get_bound_rect() const;
 
   void add_control_points();
   void update_control_points();

Modified: trunk/lib/objmap_object_impl.hxx
===================================================================
--- trunk/lib/objmap_object_impl.hxx	2005-02-11 18:54:01 UTC (rev 489)
+++ trunk/lib/objmap_object_impl.hxx	2005-02-25 17:30:24 UTC (rev 490)
@@ -39,7 +39,7 @@
   virtual ~ObjMapObjectImpl();
 
   virtual void draw() =0;
-  virtual CL_Rect get_bound_rect() const  =0;
+  virtual CL_Rectf get_bound_rect() const  =0;
 
   virtual void add_control_points();
   virtual void update_control_points();

Modified: trunk/lib/objmap_path_node.cxx
===================================================================
--- trunk/lib/objmap_path_node.cxx	2005-02-11 18:54:01 UTC (rev 489)
+++ trunk/lib/objmap_path_node.cxx	2005-02-25 17:30:24 UTC (rev 490)
@@ -30,7 +30,7 @@
   ObjMapPathNodeImpl();
 
   void draw();
-  CL_Rect get_bound_rect() const;
+  CL_Rectf get_bound_rect() const;
 };
 
 ObjMapPathNodeImpl::ObjMapPathNodeImpl()
@@ -59,10 +59,10 @@
     }
 }
 
-CL_Rect
+CL_Rectf
 ObjMapPathNodeImpl::get_bound_rect() const
 {
-  return CL_Rect(CL_Point(pos) - CL_Point(16,16), CL_Size(32, 32));
+  return CL_Rectf(pos - CL_Pointf(16,16), CL_Sizef(32, 32));
 }
 
 ObjMapPathNode::ObjMapPathNode(const CL_Pointf&amp; pos_, 

Modified: trunk/lib/objmap_rect_object.cxx
===================================================================
--- trunk/lib/objmap_rect_object.cxx	2005-02-11 18:54:01 UTC (rev 489)
+++ trunk/lib/objmap_rect_object.cxx	2005-02-25 17:30:24 UTC (rev 490)
@@ -122,12 +122,12 @@
   }
 
   void draw();
-  CL_Rect get_bound_rect() const;
+  CL_Rectf get_bound_rect() const;
   void add_control_points();
   void update_control_points();
 };
 
-CL_Rect
+CL_Rectf
 ObjMapRectObject::get_rect() const
 {
   return impl-&gt;get_bound_rect();
@@ -219,12 +219,10 @@
   CL_Display::fill_rect(get_bound_rect(), color);
 }
 
-CL_Rect
+CL_Rectf
 ObjMapRectObjectImpl::get_bound_rect() const
 {
-  return CL_Rect(CL_Point(pos),
-                 CL_Size(static_cast&lt;int&gt;(size.width),
-                         static_cast&lt;int&gt;(size.height)));
+  return CL_Rectf(pos, size);
 }
 
 ObjMapObject

Modified: trunk/lib/objmap_rect_object.hxx
===================================================================
--- trunk/lib/objmap_rect_object.hxx	2005-02-11 18:54:01 UTC (rev 489)
+++ trunk/lib/objmap_rect_object.hxx	2005-02-25 17:30:24 UTC (rev 490)
@@ -39,7 +39,7 @@
   void set_color(const CL_Color&amp; color);
 
   void set_rect(const CL_Rect&amp; rect);
-  CL_Rect get_rect() const;
+  CL_Rectf get_rect() const;
 
   ObjMapObject to_object();
 private:

Modified: trunk/lib/objmap_select_tool.cxx
===================================================================
--- trunk/lib/objmap_select_tool.cxx	2005-02-11 18:54:01 UTC (rev 489)
+++ trunk/lib/objmap_select_tool.cxx	2005-02-25 17:30:24 UTC (rev 490)
@@ -121,7 +121,7 @@
     case DRAG:
       break;
     case SELECT:
-      CL_Display::draw_rect(CL_Rect(selection_rect),
+      CL_Display::draw_rect(selection_rect,
                             CL_Color(255, 255, 255));
       break;
     default:

Modified: trunk/lib/objmap_sprite_object.cxx
===================================================================
--- trunk/lib/objmap_sprite_object.cxx	2005-02-11 18:54:01 UTC (rev 489)
+++ trunk/lib/objmap_sprite_object.cxx	2005-02-25 17:30:24 UTC (rev 490)
@@ -27,7 +27,7 @@
   CL_Sprite sprite;
 
   void draw();
-  CL_Rect get_bound_rect() const;
+  CL_Rectf get_bound_rect() const;
 
   ObjMapObject*  duplicate(int handle_);
 };
@@ -49,10 +49,10 @@
 void
 ObjMapSpriteObjectImpl::draw()
 {
-  sprite.draw(static_cast&lt;int&gt;(pos.x), static_cast&lt;int&gt;(pos.y));
+  sprite.draw(pos.x, pos.y);
 }
 
-CL_Rect
+CL_Rectf
 ObjMapSpriteObjectImpl::get_bound_rect() const
 {
   CL_Point  align = CL_Point(0, 0);
@@ -64,8 +64,8 @@
                                                   sprite.get_height()));
   align.x = -align.x;
       
-  return CL_Rect(CL_Point(pos) - origin - align,
-                 CL_Size(sprite.get_width(), sprite.get_height()));
+  return CL_Rectf(pos - origin - align,
+                  CL_Sizef(sprite.get_width(), sprite.get_height()));
 }
 
 void

Added: trunk/pingus/gui.rb
===================================================================
--- trunk/pingus/gui.rb	2005-02-11 18:54:01 UTC (rev 489)
+++ trunk/pingus/gui.rb	2005-02-25 17:30:24 UTC (rev 490)
@@ -0,0 +1,125 @@
+##  $Id$
+##
+##  Flexlay - A Generic 2D Game Editor
+##  Copyright (C) 2005 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+##
+##  This program is free software; you can redistribute it and/or
+##  modify it under the terms of the GNU General Public License
+##  as published by the Free Software Foundation; either version 2
+##  of the License, or (at your option) any later version.
+##
+##  This program is distributed in the hope that it will be useful,
+##  but WITHOUT ANY WARRANTY; without even the implied warranty of
+##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+##  GNU General Public License for more details.
+##
+##  You should have received a copy of the GNU General Public License
+##  along with this program; if not, write to the Free Software
+##  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+class GUI
+  attr_reader :workspace, :objectselector;
+
+  def initialize()
+    @editor = Editor.new()
+    @gui    = @editor.get_gui_manager()
+
+    myrect      = CL_Rect.new(CL_Point.new(0, 56), CL_Size.new(665, 488+56))
+    @editor_map = EditorMapComponent.new(myrect, @gui.get_component())
+    @workspace  = Workspace.new(myrect.get_width(), myrect.get_height())
+    @editor_map.set_workspace(@workspace)
+
+    @selector_window = Panel.new(CL_Rect.new(CL_Point.new(800-134, 23+33), CL_Size.new(128 + 6, 558)),
+                                 @gui.get_component())
+
+    @objectselector = ObjectSelector.new(CL_Rect.new(0, 0, 128, 600), 42, 42, @selector_window)
+    @objectselector.show(true)
+    connect_v2_ObjectBrush_Point(@objectselector.sig_drop(), method(:on_object_drop))
+
+    create_menu()
+    create_toolbar()
+    create_button_panel()
+
+    connect_v2(@editor_map.sig_on_key(&quot;e&quot;), 
+               proc{ |x, y|
+                 puts &quot;Content: #{x}, #{y}&quot;
+                 $objmap_select_tool.get_selection().each {|i|
+                   i.get_data().property_dialog()
+                 }})
+  end
+
+  def run()
+    @gui.run()
+  end
+
+  def create_button_panel()
+    @button_panel = ButtonPanel.new(0, 23, 800, 33, true, @gui.get_component)
+    @button_panel.add_icon(&quot;../data/images/icons24/stock_new.png&quot;)
+    @button_panel.add_icon(&quot;../data/images/icons24/stock_open.png&quot;, proc{ level_load() })
+    @button_panel.add_small_icon(&quot;../data/images/icons24/downarrow.png&quot;, proc{ $controller.recent_files_menu.run() })
+    @button_panel.add_icon(&quot;../data/images/icons24/stock_save.png&quot;, proc{ level_save() })
+    @button_panel.add_icon(&quot;../data/images/icons24/stock_save_as.png&quot;, proc{ level_save_as() })
+    @button_panel.add_seperator()
+    @button_panel.add_icon(&quot;../data/images/icons24/stock_copy.png&quot;)
+    @button_panel.add_icon(&quot;../data/images/icons24/stock_paste.png&quot;)
+    @button_panel.add_seperator()
+    @undo_icon = @button_panel.add_icon(&quot;../data/images/icons24/stock_undo.png&quot;, proc{ @workspace.get_map().undo() })
+    @redo_icon = @button_panel.add_icon(&quot;../data/images/icons24/stock_redo.png&quot;, proc{ @workspace.get_map().redo() })
+  end
+
+  def create_toolbar()
+    @toolbar = ButtonPanel.new(0, 23+33, 33, 32*4+2, false, @gui.get_component)
+    @object = @toolbar.add_icon(&quot;../data/images/tools/stock-tool-clone-22.png&quot;, 
+                                proc{ workspace.set_tool($objmap_select_tool.to_tool())})
+
+    @toolbar = ButtonPanel.new(0, 23+33*2, 33, 32*4+2, false, @gui.get_component)
+    @object = @toolbar.add_icon(&quot;../data/images/tools/stock-tool-zoom-22.png&quot;, 
+                                proc{ workspace.set_tool($zoom_tool.to_tool())})
+  end
+
+  def create_menu()
+    @menu = CL_Menu.new(@gui.get_component())
+    @menu.add_item(&quot;File/Quit&quot;,  proc{ @gui.quit })
+    
+    @menu.add_item(&quot;Zoom/1:4 (25%) &quot;,  proc{ self.gui_set_zoom(0.25) })
+    @menu.add_item(&quot;Zoom/1:2 (50%) &quot;,  proc{ self.gui_set_zoom(0.5) })
+    @menu.add_item(&quot;Zoom/1:1 (100%) &quot;, proc{ self.gui_set_zoom(1.0) }) 
+    @menu.add_item(&quot;Zoom/2:1 (200%) &quot;, proc{ self.gui_set_zoom(2.0) })
+    @menu.add_item(&quot;Zoom/4:1 (400%) &quot;, proc{ self.gui_set_zoom(4.0) })
+  end
+
+  def on_map_change()
+    if (@workspace.get_map().undo_stack_size() &gt; 0)
+      @undo_icon.enable()
+    else
+      @undo_icon.disable()
+    end
+
+    if (@workspace.get_map().redo_stack_size() &gt; 0)
+      @redo_icon.enable()
+    else
+      @redo_icon.disable()        
+    end
+  end
+
+  def on_object_drop(brush, pos)
+    pos  = @editor_map.screen2world(pos)
+    (type, sprite) = get_ruby_object(brush.get_data()) # object type 'groundpiece'
+    
+    worldobj = WorldObj.new(type, sprite)
+    
+    obj = ObjMapSpriteObject.new(CL_Sprite.new(worldobj.get_image(), $resources), 
+                                 pos, 
+                                 make_metadata(worldobj))
+    worldobj.set_data(obj)
+
+    workspace.get_map().get_metadata().objects.add_object(obj.to_object())
+  end
+
+  def get_component()
+    return @gui.get_component()
+  end
+
+end
+
+# EOF #

Added: trunk/pingus/level.rb
===================================================================
--- trunk/pingus/level.rb	2005-02-11 18:54:01 UTC (rev 489)
+++ trunk/pingus/level.rb	2005-02-25 17:30:24 UTC (rev 490)
@@ -0,0 +1,89 @@
+require &quot;rexml/document&quot;
+require &quot;worldobjs.rb&quot;
+
+class Level
+  attr_reader :objects, :editormap
+  attr_accessor :levelname, :description, :author, :number_of_pingus, :number_to_save, :ambient_light, :comment, :levelsize, :actions
+
+  def initialize(filename = nil)
+    @objects   = ObjectLayer.new()
+    @editormap = EditorMap.new()
+    @editormap.add_layer(@objects.to_layer())
+    @editormap.set_metadata(self)
+    @editormap.set_bounding_rect(CL_Rect.new(0, 0, 2400, 600));
+
+    if filename then
+      load(filename)
+    end  
+  end
+
+  def load(filename)
+    doc = REXML::Document.new(File.new(filename))
+
+    @version = doc.elements['/pingus-level/version'].text.to_i
+
+    # Parse the header
+    header = doc.elements['/pingus-level/head'].elements
+    @levelname   = header['levelname'].text
+    @description = header['description'].text
+    @author      = header['author'].text
+    @number_of_pingus = header['number-of-pingus'].text.to_i
+    @number_to_save   = header['number-to-save'].text.to_i
+
+    @ambient_light = CL_Color.new((header['ambient-light/red'].text.to_f * 255).to_i,
+                                  (header['ambient-light/green'].text.to_f * 255).to_i,
+                                  (header['ambient-light/blue'].text.to_f  * 255).to_i,
+                                  (header['ambient-light/alpha'].text.to_f * 255).to_i)
+
+    @comment = header['comment'].text
+    @levelsize = CL_Size.new(header['levelsize/width'].text.to_i,
+                             header['levelsize/height'].text.to_i)
+    @editormap.set_bounding_rect(CL_Rect.new(CL_Point.new(0, 0), @levelsize))
+
+    @actions = header['actions'].elements.inject({}) {|h, e| h[e.name] = e.text.to_i; h }
+    
+    doc.elements.each(&quot;pingus-level/objects/*&quot;) { |element|
+      worldobj = WorldObj.new(element.name, element)
+
+      obj = ObjMapSpriteObject.new(CL_Sprite.new(worldobj.get_image(), $resources), 
+                                   worldobj.get_pos(), 
+                                   make_metadata(worldobj))
+      worldobj.set_data(obj)
+      
+      @objects.add_object(obj.to_object())
+    }
+  end
+
+  def save(filename)
+    doc = REXML::Document.new()
+    doc.xml_decl.xmldecl(&quot;1.0&quot;, &quot;ISO-8859-1&quot;, false)
+    root = doc.add_element(&quot;pingus-level&quot;)
+    head = root.add_element(&quot;head&quot;)
+    head.add_element(&quot;levelname&quot;).add_text(@levelname)
+    head.add_element(&quot;description&quot;).add_text(@description)
+    head.add_element(&quot;author&quot;).add_text(@author)
+    head.add_element(&quot;number_of_pingus&quot;).add_text(@number_of_pingus.to_s)
+    head.add_element(&quot;number_to_save&quot;).add_text(@number_to_save.to_s)
+    head.add_element(&quot;comment&quot;).add_text(@comment)
+    # FIXME: More to come
+    objects = root.add_element(&quot;objects&quot;)
+    @objects.get_objects().each { |object|
+      worldobj = object.get_metadata()
+      if worldobj then
+        worldobj.write_xml(objects)
+      end
+    }
+
+    f = File.new(filename, &quot;w&quot;)
+    doc.write(f, 0)
+    f.close()
+  end
+
+  def activate(workspace)
+    workspace.set_map(@editormap)
+    ObjectLayer.set_current(@objects)
+    connect(@editormap.sig_change(), proc{$gui.on_map_change()})
+  end
+end
+
+# EOF #

Added: trunk/pingus/pingus-editor
===================================================================
--- trunk/pingus/pingus-editor	2005-02-11 18:54:01 UTC (rev 489)
+++ trunk/pingus/pingus-editor	2005-02-25 17:30:24 UTC (rev 490)
@@ -0,0 +1,11 @@
+#!/bin/sh
+
+LD_LIBRARY_PATH=&quot;$LD_LIBRARY_PATH:`pwd`/../lib:`pwd`/../ruby&quot;
+export LD_LIBRARY_PATH
+
+RUBYLIB=$RUBYLIB:`pwd`/../ruby
+export RUBYLIB
+
+exec ruby -w ./pingus.rb &quot;$@&quot;
+
+# EOF #


Property changes on: trunk/pingus/pingus-editor
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/pingus/pingus-editor-gdb
===================================================================
--- trunk/pingus/pingus-editor-gdb	2005-02-11 18:54:01 UTC (rev 489)
+++ trunk/pingus/pingus-editor-gdb	2005-02-25 17:30:24 UTC (rev 490)
@@ -0,0 +1,11 @@
+#!/bin/sh
+
+LD_LIBRARY_PATH=&quot;$LD_LIBRARY_PATH:`pwd`/../lib:`pwd`/../ruby&quot;
+export LD_LIBRARY_PATH
+
+RUBYLIB=$RUBYLIB:`pwd`/../ruby
+export RUBYLIB
+
+exec gdb --args  ruby ./pingus.rb &quot;$@&quot;
+
+# EOF #


Property changes on: trunk/pingus/pingus-editor-gdb
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/pingus/pingus.rb
===================================================================
--- trunk/pingus/pingus.rb	2005-02-11 18:54:01 UTC (rev 489)
+++ trunk/pingus/pingus.rb	2005-02-25 17:30:24 UTC (rev 490)
@@ -0,0 +1,88 @@
+#!/usr/bin/ruby
+##  $Id$
+##
+##  Flexlay - A Generic 2D Game Editor
+##  Copyright (C) 2005 Ingo Ruhnke &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/flexlay-commit">grumbel at gmx.de</A>&gt;
+##
+##  This program is free software; you can redistribute it and/or
+##  modify it under the terms of the GNU General Public License
+##  as published by the Free Software Foundation; either version 2
+##  of the License, or (at your option) any later version.
+##
+##  This program is distributed in the hope that it will be useful,
+##  but WITHOUT ANY WARRANTY; without even the implied warranty of
+##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+##  GNU General Public License for more details.
+##
+##  You should have received a copy of the GNU General Public License
+##  along with this program; if not, write to the Free Software
+##  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+$datadir = &quot;/home/ingo/projects/pingus/svn/trunk/data/&quot;
+
+require &quot;flexlay_wrap&quot;
+include Flexlay_wrap
+
+require &quot;flexlay.rb&quot;
+
+flexlay = Flexlay.new()
+flexlay.init()
+
+$objmap_select_tool  = ObjMapSelectTool.new()
+$zoom_tool           = ZoomTool.new()
+
+require &quot;worldmap.rb&quot;
+require &quot;level.rb&quot;
+require &quot;worldobjs.rb&quot;
+require &quot;gui.rb&quot;
+
+$gui = GUI.new()
+
+$resources = CL_ResourceManager.new()
+$resources.add_resources(CL_ResourceManager.new($datadir + &quot;data/groundpieces-ground.xml&quot;))
+$resources.add_resources(CL_ResourceManager.new($datadir + &quot;data/groundpieces-solid.xml&quot;))
+$resources.add_resources(CL_ResourceManager.new($datadir + &quot;data/groundpieces-transparent.xml&quot;))
+$resources.add_resources(CL_ResourceManager.new($datadir + &quot;data/groundpieces-remove.xml&quot;))
+
+$resources.add_resources(CL_ResourceManager.new($datadir + &quot;data/core.xml&quot;));
+$resources.add_resources(CL_ResourceManager.new($datadir + &quot;data/entrances.xml&quot;));
+$resources.add_resources(CL_ResourceManager.new($datadir + &quot;data/exits.xml&quot;));
+$resources.add_resources(CL_ResourceManager.new($datadir + &quot;data/fonts.xml&quot;));
+$resources.add_resources(CL_ResourceManager.new($datadir + &quot;data/game.xml&quot;));
+$resources.add_resources(CL_ResourceManager.new($datadir + &quot;data/hotspots.xml&quot;));
+$resources.add_resources(CL_ResourceManager.new($datadir + &quot;data/liquids.xml&quot;));
+$resources.add_resources(CL_ResourceManager.new($datadir + &quot;data/pingus.xml&quot;));
+$resources.add_resources(CL_ResourceManager.new($datadir + &quot;data/story.xml&quot;));
+$resources.add_resources(CL_ResourceManager.new($datadir + &quot;data/textures.xml&quot;));
+$resources.add_resources(CL_ResourceManager.new($datadir + &quot;data/traps.xml&quot;));
+$resources.add_resources(CL_ResourceManager.new($datadir + &quot;data/worldmaps.xml&quot;));
+$resources.add_resources(CL_ResourceManager.new($datadir + &quot;data/worldobjs.xml&quot;));
+$resources.add_resources(CL_ResourceManager.new($datadir + &quot;data/alias.xml&quot;));
+
+if true then
+  worldmap = WorldMap.new()
+  worldmap.activate($gui.workspace)
+else
+  level = Level.new('/home/ingo/projects/pingus/svn/trunk/src/levelout.xml')
+  level.activate($gui.workspace)
+  level.save(&quot;/tmp/levelout.xml&quot;)
+end
+
+# puts $resources.get_all_sections()
+
+$resources.get_resources_of_type(&quot;sprite&quot;, &quot;groundpieces/ground/&quot;).each { |name|
+  begin
+    $gui.objectselector.add_brush(ObjectBrush.new(CL_Sprite.new(name, $resources),
+                                                  make_metadata([&quot;groundpiece&quot;, name])))
+  rescue CL_Error =&gt; err
+    puts err.message
+  end
+}
+
+$gui.workspace.set_tool($objmap_select_tool.to_tool())
+
+$gui.run()
+
+# flexlay.deinit()
+
+# EOF #

Added: trunk/pingus/worldmap.rb
===================================================================
--- trunk/pingus/worldmap.rb	2005-02-11 18:54:01 UTC (rev 489)
+++ trunk/pingus/worldmap.rb	2005-02-25 17:30:24 UTC (rev 490)
@@ -0,0 +1,79 @@
+require &quot;rexml/document&quot;
+require &quot;worldobjs.rb&quot;
+
+class WorldMap
+  def initialize()
+    @name        = &quot;&quot;
+    @description = &quot;&quot;
+    @author      = &quot;&quot;
+    @music       = &quot;pingus-1.it&quot;
+
+    @objects   = ObjectLayer.new()
+    @editormap = EditorMap.new()
+    @editormap.add_layer(@objects.to_layer())
+    @editormap.set_metadata(self)
+    @editormap.set_bounding_rect(CL_Rect.new(0, 0, 2400, 600));
+
+    load('/home/ingo/projects/pingus/svn/trunk/src/worldmapout.xml')
+  end    
+
+  def activate(workspace)
+    workspace.set_map(@editormap)
+    ObjectLayer.set_current(@objects)
+    connect(@editormap.sig_change(), proc{$gui.on_map_change()})
+  end
+
+  def load(filename)
+    doc = REXML::Document.new(File.new(filename))
+
+    # @version = doc.elements['/pingus-worldmap/version'].text.to_i
+    reader = XMLReader.new(doc.elements['/pingus-worldmap/head'])
+    @name        = reader.read(&quot;name&quot;,   :string,  &quot;Some Worldmap&quot;)
+    @description = reader.read(&quot;name&quot;,   :string,  &quot;&quot;)
+    @music       = reader.read(&quot;name&quot;,   :string,  &quot;pingus-1.it&quot;)
+    @width       = reader.read(&quot;width&quot;,  :int, 800)
+    @height      = reader.read(&quot;height&quot;, :int, 600)
+
+    @editormap.set_bounding_rect(CL_Rect.new(0, 0, @width, @height));
+
+    doc.elements['/pingus-worldmap/objects'].elements.each {|object|
+      case object.name
+      when &quot;surface&quot;
+        reader = XMLReader.new(object)
+        name  = reader.read(&quot;name&quot;,     :string, &quot;foo&quot;)
+        image = reader.read(&quot;surface&quot;,  :image,  &quot;&quot;)
+        pos   = reader.read(&quot;position&quot;, :vector, CL_Pointf.new(0,0))
+
+        obj = ObjMapSpriteObject.new(CL_Sprite.new(image, $resources), 
+                                     pos,
+                                     make_metadata(nil))
+        
+        @objects.add_object(obj.to_object())
+      else
+        puts &quot;Unknown worldmap object: '#{object.name}'&quot;
+      end
+    }
+    
+    doc.elements['/pingus-worldmap/graph/nodes'].elements.each {|object|
+      case object.name 
+      when &quot;leveldot&quot;
+        reader = XMLReader.new(object)
+        pos  = reader.read(&quot;dot/position&quot;, :vector, CL_Pointf.new(0, 0))
+
+        obj = ObjMapSpriteObject.new(CL_Sprite.new(&quot;core/worldmap/dot_green&quot;, $resources), 
+                                     pos,
+                                     make_metadata(nil))
+        
+        @objects.add_object(obj.to_object())      
+      else
+        puts &quot;Unknown graph object '#{object.name}'&quot;
+      end
+    }
+
+    doc.elements['/pingus-worldmap/graph/edges'].elements.each {|edge|
+      
+    }
+  end
+end
+
+# EOF #

Added: trunk/pingus/worldobjs.rb
===================================================================
--- trunk/pingus/worldobjs.rb	2005-02-11 18:54:01 UTC (rev 489)
+++ trunk/pingus/worldobjs.rb	2005-02-25 17:30:24 UTC (rev 490)
@@ -0,0 +1,172 @@
+require &quot;rexml/document&quot;
+require &quot;xmlreader.rb&quot;
+
+$objects = {
+  &quot;entrance&quot; =&gt; {
+    &quot;type&quot;         =&gt; [:string, &quot;generic&quot;],
+    &quot;owner-id&quot;     =&gt; [:int,     0],
+    &quot;direction&quot;    =&gt; [:enum,   &quot;misc&quot;, [&quot;left&quot;, &quot;right&quot;, &quot;misc&quot;]],
+    &quot;position&quot;     =&gt; [:vector, CL_Point.new(0, 0)],
+    &quot;release-rate&quot; =&gt; [:int,    25]},
+
+  &quot;exit&quot; =&gt; {
+    &quot;position&quot; =&gt; [:vector, CL_Point.new(0, 0)],
+    &quot;surface&quot;  =&gt; [:image,  &quot;&quot;],
+    &quot;owner-id&quot; =&gt; [:int,    0]},
+
+  &quot;fake-exit&quot; =&gt; {
+    &quot;position&quot; =&gt; [:vector, CL_Point.new(0, 0)]},
+
+  &quot;groundpiece&quot; =&gt; {
+    &quot;position&quot; =&gt; [:vector, CL_Point.new(0, 0)],
+    &quot;surface&quot;  =&gt; [:image, &quot;&quot;]},
+
+  &quot;guillotine&quot; =&gt; {
+    &quot;position&quot; =&gt; [:vector, CL_Point.new(0, 0)]},
+  
+  &quot;hammer&quot; =&gt; {
+    &quot;position&quot; =&gt; [:vector, CL_Point.new(0, 0)]},
+  
+  &quot;hotspot&quot; =&gt; {
+    &quot;position&quot; =&gt; [:vector, CL_Point.new(0, 0)],
+    &quot;surface&quot;  =&gt; [:image,  &quot;&quot;],
+    &quot;parallax&quot; =&gt; [:float,  0]},
+  
+  &quot;iceblock&quot; =&gt; {
+    &quot;position&quot; =&gt; [:vector, CL_Point.new(0, 0)]},
+  
+  &quot;info-box&quot; =&gt; {
+    &quot;position&quot;  =&gt; [:vector, CL_Point.new(0, 0)],
+    &quot;info-text&quot; =&gt; [:string, &quot;&quot;]},
+  
+  &quot;laser-exit&quot; =&gt; {
+    &quot;position&quot; =&gt; [:vector, CL_Point.new(0, 0)]},
+  
+  &quot;liquid&quot; =&gt; {
+    &quot;position&quot; =&gt; [:vector, CL_Point.new(0, 0)],
+    &quot;surface&quot;  =&gt; [:image,  &quot;&quot;],
+    &quot;width&quot;    =&gt; [:int,    1]},
+  
+  &quot;rain-generator&quot; =&gt; {},
+  
+  &quot;smasher&quot; =&gt; {
+    &quot;position&quot; =&gt; [:vector, CL_Point.new(0, 0)]},
+  
+  &quot;snow-generator&quot; =&gt; {
+    &quot;intensity&quot; =&gt; [:float, 1.0]},
+  
+  &quot;solid-color-background&quot; =&gt; {
+    &quot;color&quot; =&gt; [:color, CL_Color.new(0, 0, 0, 255)]},
+  
+  &quot;spike&quot; =&gt; {
+    &quot;position&quot; =&gt; [:vector, CL_Point.new(0, 0)]},
+  
+  &quot;starfield-background&quot; =&gt; {
+    &quot;small-stars&quot;  =&gt; [:int, 100],
+    &quot;middle-stars&quot; =&gt; [:int,  50],
+    &quot;large-stars&quot;  =&gt; [:int,  25]},
+  
+  &quot;surface-background&quot; =&gt; {
+    &quot;surface&quot;      =&gt; [:image, &quot;&quot;],
+    &quot;color&quot;        =&gt; [:color, CL_Color.new(0, 0, 0, 0)],
+    &quot;para-x&quot;       =&gt; [:float, 0.5],
+    &quot;para-y&quot;       =&gt; [:float, 0.5],
+    &quot;scroll-x&quot;     =&gt; [:float, 0],
+    &quot;scroll-y&quot;     =&gt; [:float, 0],
+    &quot;stretch-x&quot;    =&gt; [:float, 1],
+    &quot;stretch-y&quot;    =&gt; [:float, 1],
+    &quot;keep-aspect&quot;  =&gt; [:bool,  true]},
+
+  &quot;switch-door&quot; =&gt; {
+    &quot;position&quot; =&gt; [:vector, CL_Point.new(0, 0)]},
+  
+  &quot;teleporter&quot; =&gt; {
+    &quot;position&quot; =&gt; [:vector, CL_Point.new(0, 0)],
+    &quot;target&quot;   =&gt; [:vector, CL_Point.new(0, 0)]},
+
+  &quot;thunderstorm-background&quot; =&gt; {
+    &quot;position&quot; =&gt; [:vector, CL_Point.new(0, 0)]},
+  
+  &quot;woodthing&quot; =&gt; {
+    &quot;position&quot; =&gt; [:vector, CL_Point.new(0, 0)]}}
+
+class WorldObj
+  def initialize(typename, rest)
+    @data       = nil
+    @typename   = typename # Type of the object ('groundpiece', 'hotspot', ...)
+    @properties = {}       # Properties of the object ({'speed' =&gt; 10, 'paralax' =&gt; 10.0})
+    
+    if rest.class == REXML::Element then
+      element = rest
+      
+      reader = XMLReader.new(element)
+      $objects[typename].each {|k, v|
+        @properties[k] = reader.read(k, v[0], v[1])
+      }
+    elsif rest.class == String then
+      image = rest
+
+      $objects[typename].each {|k, v|
+        if k == &quot;surface&quot; then
+          @properties[k] = image
+        elsif k != &quot;position&quot; then
+          @properties[k] = v[1]
+        end
+      }
+    else
+      raise &quot;Error: Unknown type to WorldObj constructor&quot;
+    end
+  end
+
+  def write_xml(el)
+    el = el.add_element(@typename)
+    @properties.each{|k, v|
+      el.add_element(k).add_text(v.to_s)
+    }
+  end
+
+  def get_image()
+    return @properties['surface'] || &quot;core/misc/404sprite&quot;
+  end
+
+  def get_pos()
+    return @properties['position'] || CL_Pointf.new(0, 0)
+  end
+
+  def set_data(data)
+    @data = data
+    if @properties.has_key?('position') then
+      @data.to_object().set_pos(get_pos())
+      @properties.delete('position')
+    end
+  end
+
+  def property_dialog()
+    puts &quot;Property: #{@properties.inspect}&quot;
+
+    dialog = GenericDialog.new(&quot;'#{@typename}' Property Dialog&quot;, $gui.get_component())
+    @properties.each{|k, v|
+      case $objects[@typename][k][0]
+      when :string
+        dialog.add_string(&quot;#{k}: &quot;, v)
+      when :image
+        dialog.add_string(&quot;#{k}: &quot;, v)
+      when :int
+        dialog.add_int(&quot;#{k}: &quot;, v)
+      when :float
+        dialog.add_float(&quot;#{k}: &quot;, v)
+      when :bool
+        dialog.add_bool(&quot;#{k}: &quot;, v)
+      when :enum
+        dialog.add_enum(&quot;#{k}: &quot;, $objects[@typename][k][2], v)
+      else
+        puts &quot;Warning: Ignoring '#{k}' property, type '#{$objects[@typename][k][0]}' is unknown&quot;
+      end
+     }
+    dialog.set_callback(proc{|message| 
+                          @message = message
+                        })
+  end
+end
+
+# EOF #

Added: trunk/pingus/xmlreader.rb
===================================================================
--- trunk/pingus/xmlreader.rb	2005-02-11 18:54:01 UTC (rev 489)
+++ trunk/pingus/xmlreader.rb	2005-02-25 17:30:24 UTC (rev 490)
@@ -0,0 +1,46 @@
+class XMLReader
+  def initialize(el)
+    @el = el
+  end
+
+  def read(name, type, default = nil)
+    ret = @el.elements[name]
+    if ret then
+      case type
+        
+      when :string
+        return ret.text
+        
+      when :int
+        return ret.text.to_i
+
+      when :float
+        return ret.text.to_f
+
+      when :bool #  1 = true, 0 = false
+        if ret.text.to_i == 0 then
+          return true
+        else
+          return true
+        end
+
+      when :vector
+        return CL_Pointf.new(ret.elements['x'].text.to_f,
+                             ret.elements['y'].text.to_f)
+
+      when :size
+        return CL_Size.new(ret.elements['width'].text.to_t,
+                           ret.elements['height'].text.to_t)
+
+      when :image
+        # FIXME: handle modifier somewhere
+        return ret.elements['image'].text      
+
+      end
+    else
+      return default
+    end
+  end
+end
+
+# EOF #

Modified: trunk/ruby/flexlay.rb
===================================================================
--- trunk/ruby/flexlay.rb	2005-02-11 18:54:01 UTC (rev 489)
+++ trunk/ruby/flexlay.rb	2005-02-25 17:30:24 UTC (rev 490)
@@ -214,6 +214,30 @@
     update()
   end
     
+  def add_bool(name, value = false)
+    @items.push([&quot;bool&quot;,
+                  CL_Label.new(CL_Point.new(10, 10), name,
+                               @window.get_client_area()),
+                  CL_CheckBox.new(CL_Point.new(110, 10), 
+                                  &quot;&quot;,
+                                  @window.get_client_area())])
+    # @items[-1][2].set_text(value.to_s)
+    update()
+  end
+
+  def add_enum(name, types, value = &quot;foo&quot;)
+    group = CL_RadioGroup.new()
+    types.each {|type| 
+      group.add(CL_RadioButton.new(CL_Point.new(0, 0),
+                         type, @window.get_client_area()))
+    }
+    @items.push([&quot;enum&quot;,
+                  CL_Label.new(CL_Point.new(10, 10), name,
+                               @window.get_client_area()),
+                  group])
+    update()
+  end
+
   def add_int(name, value = 0)
     @items.push([&quot;int&quot;,
                  CL_Label.new(CL_Point.new(10, 10), name,
@@ -236,19 +260,27 @@
 
   def update()
     y = 10
-    @items.each do |(type, label, comp)| 
-      if type == &quot;int&quot; or type == &quot;string&quot; or type == &quot;float&quot; or type == &quot;void&quot;
-        label.set_position(10, y)
+    @items.each { |(type, label, comp)| 
+      label.set_position(10, y)
+
+      if type == &quot;int&quot; or type == &quot;string&quot; or type == &quot;float&quot; or type == &quot;void&quot; or type == &quot;bool&quot; then
         if comp then
           comp.set_position(110, y)
         end
         y += 25
-
-        @cancel.set_position(200, y)
-        @ok.set_position(260, y)
-        @window.set_size(330, y + 60)
+      elsif type == &quot;enum&quot;
+        y += 5
+        comp.get_buttons.each {|radio|
+          radio.set_position(110, y)
+          y += 20
+        }
+        y += 5
       end
-    end
+    }
+  
+    @cancel.set_position(200, y)
+    @ok.set_position(260, y)
+    @window.set_size(330, y + 60)
   end
 end
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000000.html">[Flexlay-commit] r489 - in trunk: lib netpanzer
</A></li>
	<LI>Next message: <A HREF="000002.html">[Flexlay-commit] r491 - trunk/pingus
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1">[ date ]</a>
              <a href="thread.html#1">[ thread ]</a>
              <a href="subject.html#1">[ subject ]</a>
              <a href="author.html#1">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/flexlay-commit">More information about the Flexlay-commit
mailing list</a><br>
</body></html>
